THDX hthd, PKSPECIAL_REGISTERS pksr);
#endif

#define KERNEL_MODULE_NAME     "nt"
#define KERNEL_IMAGE_NAME      "xboxkrnl.exe"
#define KERNEL_IMAGE_NAME_MP   "ntkrnlmp.exe"
#define OSLOADER_IMAGE_NAME    "osloader.exe"
#define HAL_IMAGE_NAME         "hal.dll"
#define HAL_MODULE_NAME        "HAL"


extern BOOL ApiIsAllowed;


typedef struct MODULEALIAS {
    CHAR    ModuleName[16];
    CHAR    Alias[16];
    BOOL    Special;
} MODULEALIAS, *LPMODULEALIAS;

#define MAX_MODULEALIAS 100

LPMODULEALIAS
FindAliasByImageName(
    LPSTR lpImageName
    );

LPMODULEALIAS
FindAddAliasByModule(
    LPSTR lpImageName,
    LPSTR lpModuleName
    );

typedef struct IMAGEINFO {
    DWORD                 CheckSum;
    DWORD                 TimeStamp;
    DWORD                 SizeOfImage;
    DWORD                 BaseOfImage;
    DWORD                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} IMAGEINFO, *LPIMAGEINFO;

void ParseDmParams( LPSTR p );
BOOL ReadImageInfo(LPSTR,LPSTR,LPSTR,LPIMAGEINFO);



#endif  // KERNEL

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\dmx32.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dmx32.c

Abstract:

Author:

    Wesley Witt (wesw) 15-Aug-1992

Environment:

    NT 4.0, Win95

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include "vcexcept.h"
#ifdef OMNI
#include "OMNI.h"
#endif
#ifndef XBOX
#include "tllp.h"
#endif
#include "fiber.h"

//DBF *lpdbf;

#undef LOCAL

typedef enum {
    Image_Unknown,
    Image_16,
    Image_32,
    Image_Dump
} IMAGETYPE;
typedef IMAGETYPE *PIMAGETYPE;

enum {
    System_Invalid = -1,             /* The exe can not be debugged  */
    System_Console =  1,             /* The exe needs a console      */
    System_GUI     =  0              /* The exe is a Windows exe     */
};


ULONG	gTraceFlag = 0;

BOOL
InRpcrt4(
	HPRCX	hthd,
	ULONG	ReturnDestination
	);

void
ActionAsyncStop(
	DEBUG_EVENT*	de,
	HTHDX			hthd,
	DWORD			unused,
	LPVOID			lpv
	);
	
/////
// Taken from vspawn.h
/////
const TCHAR szVCSpawnCmd[] = _T("vcspawn.exe");  // No exe?
const TCHAR szVCSToolFlag[] = _T(" -t ");  
const TCHAR szVCSPauseFlag[] = _T(" -p ");


static   TCHAR cModuleDemarcator = _T('|');

int    pCharMode(LPTSTR szAppName, PIMAGETYPE Image);

TCHAR       rgchDebug[256];
BOOL        FVerbose = 0;

// std{in,out,err} for redirection of console apps.  See ProcessDebuggeeRedirection()
static HANDLE           rgh[3] = {0, 0, 0};

DMTLFUNCTYPE        DmTlFunc = NULL;

static BOOL FDMRemote = FALSE;  // set true for remote debug

BOOL FUseOutputDebugString = FALSE;

BOOL fApprovedAttach;

BOOL FXSAVESupported = FALSE;

EXPECTED_EVENT  masterEE = {0L,0L};
EXPECTED_EVENT *eeList = &masterEE;

static HTHDXSTRUCT masterTH = {0L,0L};
HTHDX       thdList = &masterTH;

static HPRCXSTRUCT masterPR = {0L,0L};
HPRCX       prcList = &masterPR;

// control access to thread and process lists:
CRITICAL_SECTION csThreadProcList;
CRITICAL_SECTION csFXOps;
CRITICAL_SECTION csEventList;

// control access to Walk list
CRITICAL_SECTION    csWalk;

extern PDMN_SESSION psessNotify;

HPID hpidRoot = (HPID)INVALID;  // this hpid is our hook to the native EM
BOOL fUseRoot;                  // next CREATE_PROCESS will use hpidRoot

DEBUG_EVENT falseSSEvent;
DEBUG_EVENT falseBPEvent;
DEBUG_EVENT FuncExitEvent;
METHOD      EMNotifyMethod;

// Don't allow debug event processing during some shell operations
CRITICAL_SECTION csProcessDebugEvent;

// Event handles for synchronizing with the shell on proc/thread creates.
HANDLE hEventCreateProcess;
HANDLE hEventContinue;

// event handle for synchronizing connnect/reconnect with the tl
HANDLE hEventRemoteQuit;

HANDLE hEventNoDebuggee;        // set when no debuggee is attached

int    nWaitingForLdrBreakpoint = 0;

BOOL    fDisconnected = FALSE;

DWORD g_ProcFlags = 0;
BOOL fxFlagSet = FALSE;
DEBUG_EVENT deBackup;

#ifndef KERNEL
//
// crash dump stuff
//
#if 0
BOOL                            CrashDump;
PCONTEXT                        CrashContext;
PEXCEPTION_RECORD               CrashException;
PUSERMODE_CRASHDUMP_HEADER      CrashDumpHeader;
#endif
ULONG                           KiPcrBaseAddress;
ULONG                           KiProcessors;

HANDLE hDmPollThread = 0;       // Handle for event loop thread.
BOOL   fDmPollQuit = FALSE;     // tell poll thread to exit NOW
HANDLE hTerminateThread = 0;	// Handle for Terminate Thread

typedef DWORD ( WINAPI *LPFNGETNAME )
(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
);

//HANDLE hModPsapi = NULL;
BOOL   fAttemptedLoadingPsapi = FALSE;
LPFNGETNAME pFnGetModuleFileNameExA = NULL;

#if 0
SYSTEM_INFO SystemInfo;
OSVERSIONINFO OsVersionInfo;
#endif

WT_STRUCT             WtStruct;             // ..  for wt

VOID
Cleanup(
    VOID
    );

DWORD WINAPI
CallDmPoll(
    LPVOID lpv
    );

VOID
CrashDumpThread(
    LPVOID lpv
    );

void Close3Handles(
        HANDLE *rgh
        );

#if 0
XOSD
ProcessDebuggeeRedirection(
        LPTSTR lszCommandLine,
    STARTUPINFO FAR * psi
    );
#endif

BOOL
SetDebugPrivilege(
    void
    );

#ifdef OMNI
VOID ProcessOmniDllLoadEvent(DEBUG_EVENT* pdeIn, HTHDX hthd);
#endif
#endif // !KERNEL

#ifdef KERNEL
extern BOOL fCrashDump;

#ifdef NTKERNEL
KDOPTIONS KdOptions[] = {
    _T("BaudRate"),        KDO_BAUDRATE,      KDT_DWORD,     9600,
    _T("Port"),            KDO_PORT,          KDT_DWORD,     2,
    _T("Cache"),           KDO_CACHE,         KDT_DWORD,     8192,
    _T("Verbose"),         KDO_VERBOSE,       KDT_DWORD,     0,
    _T("InitialBp"),       KDO_INITIALBP,     KDT_DWORD,     0,
    _T("Defer"),           KDO_DEFER,         KDT_DWORD,     0,
    _T("UseModem"),        KDO_USEMODEM,      KDT_DWORD,     0,
    _T("LogfileAppend"),   KDO_LOGFILEAPPEND, KDT_DWORD,     0,
    _T("GoExit"),          KDO_GOEXIT,        KDT_DWORD,     0,
    _T("SymbolPath"),      KDO_SYMBOLPATH,    KDT_STRING,    0,
    _T("LogfileName"),     KDO_LOGFILENAME,   KDT_STRING,    0,
    _T("CrashDump"),       KDO_CRASHDUMP,     KDT_STRING,    0
};

VOID
GetKernelSymbolAddresses(
    VOID
    );

MODULEALIAS  ModuleAlias[MAX_MODULEALIAS];
#endif

#endif  // KERNEL


TCHAR  nameBuffer[256];

// Reply buffers to and from em
char  abEMReplyBuf[1024];       // Buffer for EM to reply to us in
char  abDMReplyBuf[1024];       // Buffer for us to reply to EM requests in
LPDM_MSG LpDmMsg = (LPDM_MSG)abDMReplyBuf;

// To send a reply of the struct msMyStruct, do this:
//      LpDmMsg->xosdRet = xosdMyReturnValue
//      memcpy (LpDmMsg->rgb, &msMyStruct, sizeof (msMyStruct));
//      Reply (sizeof (msMyStruct), LpDmMsg, hpid);

DDVECTOR DebugDispatchTable[] = {
    ProcessExceptionEvent,
    ProcessCreateThreadEvent,
    ProcessCreateProcessEvent,
    ProcessExitThreadEvent,
    ProcessExitProcessEvent,
    ProcessLoadDLLEvent,
    ProcessUnloadDLLEvent,
    ProcessOutputDebugStringEvent,
    ProcessRipEvent,
    ProcessBreakpointEvent,
    NULL,                       /* CHECK_BREAKPOINT_DEBUG_EVENT */
    ProcessSegmentLoadEvent,    /* SEGMENT_LOAD_DEBUG_EVENT */
    NULL,                       /* DESTROY_PROCESS_DEBUG_EVENT */
    NULL,                       /* DESTROY_THREAD_DEBUG_EVENT */
    NULL,                       /* ATTACH_DEADLOCK_DEBUG_EVENT */
    ProcessEntryPointEvent,     /* ENTRYPOINT_DEBUG_EVENT */
    NULL,                       /* LOAD_COMPLETE_DEBUG_EVENT */
    NULL,                       /* INPUT_DEBUG_STRING_EVENT */
    NULL,                       /* MESSAGE_DEBUG_EVENT */
    NULL,                       /* MESSAGE_SEND_DEBUG_EVENT */
    NULL,                       /* FUNC_EXIT_EVENT */
#ifdef KERNEL
    NULL,
#else
    ProcessOleEvent,            /* OLE_DEBUG_EVENT */
    ProcessFiberEvent,
#endif
    NULL,                       /* GENERIC_DEBUG_EVENT */
#ifdef KERNEL
    NULL,
	NULL,
#else
    ProcessBogusSSEvent,        /* BOGUS_WIN95_SINGLESTEP_EVENT */
	ProcessSpecialEvent,		/* SPECIAL_DEBUGGER_EVENT */
#endif
#ifdef OMNI
	ProcessOmniDllLoadEvent,
#else
	NULL,
#endif

    NULL
};

/*
 *  This array contains the set of default actions to be taken for
 *      all debug events if the thread has the "In Function Evaluation"
 *      bit set.
 */

DDVECTOR RgfnFuncEventDispatch[] = {
    EvntException,
    NULL,                       /* This can never happen */
    NULL,                       /* This can never happen */
    ProcessExitThreadEvent,
    EvntExitProcess,
    ProcessLoadDLLEvent,        /* Use normal processing */
    ProcessUnloadDLLEvent,      /* Use normal processing */
    ProcessOutputDebugStringEvent, /* Use normal processing */
    NULL,
    EvntBreakpoint,             /* Breakpoint processor */
    NULL,
    ProcessSegmentLoadEvent,    /* WOW event */
    NULL,
    NULL,
    NULL,
    ProcessEntryPointEvent,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
        ProcessBogusSSEvent,
#ifdef KERNEL
		NULL,
#else
		ProcessSpecialEvent,
#endif
    NULL
};

void    UNREFERENCED_PARAMETERS(LPVOID lpv,...)
{
    lpv=NULL;
}

#if 0
SPAWN_STRUCT          SpawnStruct;          // packet for causing CreateProcess()
#endif

DEBUG_ACTIVE_STRUCT   DebugActiveStruct;    // ... for DebugActiveProcess()

PKILLSTRUCT           KillQueue;
CRITICAL_SECTION      csKillQueue;

BOOL IsExceptionIgnored(HPRCX, DWORD);

TCHAR SearchPathString[ 10000 ];
BOOL SearchPathSet;
BOOL fUseRealName = FALSE;

#ifndef XBOX
HINSTANCE hInstance; // The DM DLL's hInstance

LPTSTR
FmtMsg(
    int msgid
    )
{
    void * lpb;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_IGNORE_INSERTS |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      0, 0, msgid, 0, (LPTSTR)&lpb, 0, 0))
    {
        return (LPTSTR) lpb;
    }
    else
    {
        return NULL;
    }
}
#endif

TCHAR szErrArg[_MAX_PATH];

LPTSTR
LszFromErr(
    DWORD dwErr
    )
{
#ifndef XBOX // LOCBUG
    #define NTERR(name) ERROR_##name, IDS_##name,
    static struct {
        DWORD   dwErr;
        UINT    idsErr;
    } mpiszErr [] = {
        NTERR(FILE_NOT_FOUND)
        NTERR(PATH_NOT_FOUND)
        NTERR(INVALID_HANDLE)
        NTERR(INVALID_DRIVE)
        NTERR(INVALID_PARAMETER)
        NTERR(INVALID_NAME)
        NTERR(BAD_PATHNAME)
        NTERR(FILENAME_EXCED_RANGE)
        NTERR(OUTOFMEMORY)
        NTERR(NOT_ENOUGH_MEMORY)
        NTERR(ACCESS_DENIED)
        NTERR(SHARING_VIOLATION)
        NTERR(OPEN_FAILED)
        NTERR(BAD_FORMAT)
        NTERR(CHILD_NOT_COMPLETE)
        NTERR(INVALID_MODULETYPE)
        NTERR(INVALID_EXE_SIGNATURE)
        NTERR(EXE_MARKED_INVALID)
        NTERR(BAD_EXE_FORMAT)
        NTERR(DIRECTORY)
        0,  IDS_UNKNOWN_ERROR
    };
#endif
    static TCHAR rgchErr[256+_MAX_PATH]; // must be static!
    static TCHAR rgchErrNum[256];
    LPTSTR sz = rgchErr;
    LPTSTR lszFmtErr = NULL;
    int i;

#ifdef XBOX // LOCBUG
	strcpy(sz, "debug error: ");
#else
    if (!LoadString(hInstance, IDS_COULD_NOT_LOAD_DEBUGGEE,
            sz, rgchErr + _tsizeof(rgchErr) - sz)) {
        assert(FALSE);
    }
#endif

    sz += _tcslen(sz);

    // If there's an argument to put in the string, put it here
    if (szErrArg[0]) {
        _tcscpy(sz, szErrArg);
        _tcscat(sz, _T(": "));
        sz += _tcslen(sz);
    }

#ifndef XBOX
    for (i = 0; mpiszErr[i].dwErr; ++i) {
        if (mpiszErr[ i ].dwErr == dwErr) {
            break;
        }
    }

    // If we didn't find an error string in our list, call FormatMessage
    // to get an error message from the operating system.
    if (mpiszErr[i].dwErr == 0) {
        lszFmtErr = FmtMsg(dwErr);
    }

    // If we got an error message from the operating system, display that,
    // otherwise display our own message.
    if (lszFmtErr) {
        _tcsncpy(sz, lszFmtErr, rgchErr + _tsizeof(rgchErr) - sz);
        rgchErr[_tsizeof(rgchErr)-1] = _T('\0');
    }
    else {
        // Even if we got through the above loop without finding a match,
        // we're okay, because the mpiszErr[] table ends with "unknown error".

        if (!LoadString(hInstance, mpiszErr[i].idsErr,
                sz, rgchErr+_tsizeof(rgchErr)-sz)) {
            assert(FALSE);
        }
    }
#endif

    sz += _tcslen(sz);

#ifndef XBOX
    if (!LoadString(hInstance, IDS_NTError,
            rgchErrNum, _tsizeof(rgchErrNum))) {
        assert(FALSE);
    }
    sz += _stprintf(sz, rgchErrNum, dwErr);
#endif

    return rgchErr;
}

void
SendNTError(
    HPRCX hprc,
    DWORD dwErr,
    LPTSTR lszString
    )
{
    LPTSTR     lszError;

    if (lszString) {
        lszError = lszString;
    }
    else {
        lszError = (LPTSTR) LszFromErr(dwErr);
    }

        SendDBCError(hprc, dwErr, lszError);
}

void
SendDBCError(
    HPRCX hprc,
    DWORD dwErr,
    LPTSTR lszString
    )
{
    typedef struct _LE {
        XOSD    xosd;
        TCHAR   rgchErr[];
    } LE;       // load error: passed with dbcError

    LE FAR *    ple;
    LPRTP       lprtp;
    DWORD       cbBuf;
    LPCTSTR     lszError;

        if (lszString) {
                lszError = lszString;
        }
        else {
                lszError = "";  // Empty string.
        }

    cbBuf = FIELD_OFFSET(RTP, rgbVar) + sizeof(LE) + (_tcslen(lszError) + 1)*sizeof(TCHAR);
    lprtp = (LPRTP) MHAlloc(cbBuf);
    assert(lprtp);
    ple = (LE *) (lprtp->rgbVar);

    ple->xosd = (XOSD) dwErr;
    _tcscpy(ple->rgchErr, lszError);
    lprtp->dbc = dbcError;

    if (hprc != NULL) {
                lprtp->hpid= hprc->hpid;
        } else {
                lprtp->hpid = hpidRoot;
    }

    lprtp->htid = NULL;
    lprtp->cb = cbBuf;
    DmTlFunc(tlfDebugPacket, lprtp->hpid, lprtp->cb, (LONG)(LPVOID) lprtp);
    MHFree(lprtp);
}

#if 0
BOOL
ResolveFile(
    LPTSTR   lpName,
    LPTSTR   lpFullName,
    BOOL    fUseRealName
    )
{
    DWORD   dwAttr;
    LPTSTR  lpFilePart;
    BOOL    fOk;

    if (fUseRealName) {
        dwAttr = GetFileAttributes(lpName);
        fOk = ((dwAttr != 0xffffffff)
             && ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0));

        if (fOk) {
            _ftcscpy(lpFullName, lpName);
        }

    } else {

        fOk = SearchPath(SearchPathString,
                         lpName,
                         NULL,
                         MAX_PATH,
                         lpFullName,
                         &lpFilePart
                         );
        if (!fOk) {
            *lpFullName = 0;
        }
    }
    return fOk;
}

#ifndef KERNEL
XOSD
Load(
    HPRCX hprc,
    LPCTSTR szAppName,
    LPCTSTR szArg,
    LPVOID pattrib,
    LPVOID tattrib,
    DWORD creationFlags,
    BOOL fInheritHandles,
    CONST LPCTSTR* environment,
    LPCTSTR currentDirectory,
    STARTUPINFO FAR * pStartupInfo,
    LPPROCESS_INFORMATION lppi
    )
/*++

Routine Description:


Arguments:


Return Value:

    TRUE if the process was successfully created and FALSE otherwise.

--*/
{
    XOSD      xosd;
    int       type;
    TCHAR     ch;
    int       fQuotedFileName;
    int       l;
    IMAGETYPE Image;
    LPTSTR    lpch;
    // Just spawning an exec, not debugging
    BOOL      fSpawnOrphan =  !(creationFlags & DEBUG_PROCESS || creationFlags & DEBUG_ONLY_THIS_PROCESS);

    static TCHAR szFullName[MAX_PATH];
    static TCHAR szCommandLine[8192];
    static TCHAR szCurrentDir[MAX_PATH]; // Directory to spawn the debuggee in.

    Unreferenced( pattrib );
    Unreferenced( tattrib );
    Unreferenced( creationFlags );

    /* NOTE: Might have to do the same sort of copying for
     * szArg, pattrib, tattrib and
     * startupInfo. Determine if this is necessary.
     */

    //
    // global flag to help with special handling of DOS/WOW apps.
    //

    FLoading16 = FALSE;


    //
    //  Form the command line.
    //

    //
    //  First, we extract the program name and get its full path. Then
    //  we append the arguments.
    //

    if (szAppName[0] == _T('"')) {
        // If the user specified a quoted name (ie: a Long File Name, perhaps?),

    // Examination of the calling code reveals that quotes are stripped 
    // from the exe name.  I'm curious if this ever changes, so I've put
    // a benign assert here.  If you hit it, rest assured it doesn't mean
    // that anything is wrong.  I'd appreciate an email about it to
    // JayBaz.  If it annoys you, remove it.  I don't mind.
    assert (FALSE);

        fQuotedFileName=TRUE;
        szAppName++;    // Advance past the quote.
    } else {
        fQuotedFileName=FALSE;
    }

    //
    // Null terminate the command line
    //

    if (  (_ftcslen(szAppName) > 2 && szAppName[1] == _T(':'))
        || szAppName[0] == _T('\\')) {

        _ftcscpy(szCommandLine, szAppName);
        fUseRealName = TRUE;

    } else if (_ftcschr(szAppName, _T('\\')) || !SearchPathSet) {

        _ftcscpy(szCommandLine, _T(".\\") );
        _ftcscat(szCommandLine, szAppName );
        fUseRealName = TRUE;

    } else {

        if (!*SearchPathString) {
            _ftcscpy(SearchPathString, _T(".;"));
            l = 2;
            l += GetSystemDirectory(SearchPathString+l,
                                    _tsizeof(SearchPathString)-l);
            SearchPathString[l++] = _T(';');
            l += GetWindowsDirectory(SearchPathString+l,
                                     _tsizeof(SearchPathString)-l);
            SearchPathString[l++] = _T(';');
            GetEnvironmentVariable(_T("PATH"),
                                   SearchPathString+l,
                                   _tsizeof(SearchPathString)-l);
        }

        _ftcscpy(szCommandLine, szAppName);
        fUseRealName = FALSE;
    }

    if (fQuotedFileName) {
        szAppName--;
    }

    //
    // to be similar to the shell, we look for:
    //
    // .COM
    // .EXE
    // nothing
    //
    // since '.' is a valid filename character on many filesystems,
    // we don't automatically assume that anything following a '.'
    // is an "extension."  If the extension is "COM" or "EXE", leave
    // it alone; otherwise try the extensions.
    //

    lpch = _ftcschr(szCommandLine, _T('.'));
    if (lpch &&
             ( lpch[1] == 0
            || _ftcsicmp(lpch, _T(".COM")) == 0
            || _ftcsicmp(lpch, _T(".EXE")) == 0)
    ) {
        lpch = NULL;
    } else {
        lpch = szCommandLine + _ftcslen(szCommandLine);
    }

    *szFullName = 0;
    if (lpch) {
        _ftcscpy(lpch, _T(".COM"));
        ResolveFile(szCommandLine, szFullName, fUseRealName);
    }
    if (!*szFullName && lpch) {
        _ftcscpy(lpch, _T(".EXE"));
        ResolveFile(szCommandLine, szFullName, fUseRealName);
    }
    if (!*szFullName) {
        if (lpch) {
            *lpch = 0;
        }
        ResolveFile(szCommandLine, szFullName, fUseRealName);
    }

    if (!*szFullName) {

        return xosdFileNotFound;

    }


    if ((type = pCharMode(szFullName, &Image)) == INVALID) {

        return xosdFileNotFound;

    } else {

        switch ( Image ) {
            case Image_Unknown:
                // treat as a com file
                //return xosdBadFormat;

            case Image_16:
                FLoading16 = TRUE;
#if defined(TARGET_i386)
                if ( (type == System_GUI) &&
                        !(creationFlags & CREATE_SEPARATE_WOW_VDM) &&
                        IsWOWPresent() )
                {
                    // TODO need dbcError here
                    return xosdGeneral;
                }
                break;
#else
                // TODO all platforms will suppport this
                return xosdGeneral;
#endif

            default:
                break;

        }
    }

    creationFlags |= (type?CREATE_NEW_CONSOLE:0);

    {
        //
        //  Add rest of arguments and quotes just in case
        //

        static TCHAR szCommandLineT[8192];

        // assert for the non-believers
        assert (szCommandLine[0] != _T('\"'));

        _ftcscpy (szCommandLineT, _T("\""));
        _ftcscat (szCommandLineT, szCommandLine);
        _ftcscat (szCommandLineT, _T("\""));
        _ftcscat (szCommandLineT, szArg);
        _ftcscpy (szCommandLine, szCommandLineT);

    }

    if (Image == Image_Dump) {
        //
        // must be a crash dump file
        //
        if (!StartCrashPollThread()) {
            return xosdUnknown;
        }
        return xosdNone;
    }

    if (!fSpawnOrphan) {
        if (!StartDmPollThread()) {
            return xosdUnknown;
        }
    }

    // Handle the current directory
    if ( currentDirectory == NULL ) {
            TCHAR szDir[_MAX_DIR];
            // szCurrentDir is temporarily used to get the drive letter in it.
            _tsplitpath(szFullName, szCurrentDir, szDir, NULL, NULL);
            // After the _tcscat szCurrentDir will have the right value.
            _tcscat(szCurrentDir, szDir);
    } else {
            _tcscpy(szCurrentDir, currentDirectory);
    }

    ResetEvent(SpawnStruct.hEventApiDone);

    SpawnStruct.szAppName = szFullName;

    xosd = ProcessDebuggeeRedirection (szCommandLine, pStartupInfo);
    if (xosd != xosdNone) {
        return xosd;
    }

    if (pStartupInfo -> dwFlags & STARTF_USESTDHANDLES && !fInheritHandles) {
        // If we're redirecting the debuggee's STDIO, inheritHandles must be set.
        assert (FALSE);
        fInheritHandles = TRUE;
    }

    if (!_ftcslen (szCommandLine)) {
        //
        // In Win 95, if the Args are an empty string,
        // the AppName is interpreted as with arguments.  This fixes it.
        //

        SpawnStruct.szArgs = NULL;

    } else {
        //
        // parse any IO redirection
        //
        SpawnStruct.szArgs = szCommandLine;
    }

    if (!_ftcslen(szCurrentDir)) {
        SpawnStruct.pszCurrentDirectory = NULL;
    } else {
        SpawnStruct.pszCurrentDirectory = szCurrentDir;
    }

    SpawnStruct.fdwCreate = creationFlags;
    SpawnStruct.si        = *pStartupInfo;
    SpawnStruct.fInheritHandles = fInheritHandles;

    //
    // The second argument to get command line should have both the exe name
    // and the command line args. GetCommandLine & argv[] are based on the second
    // argument and we need the exe name to appear there.
    //

    if (fSpawnOrphan) {

		//
        // If we're not debugging, it's because we're doing an Execute
		// Instead of making the debug thread spawn, we spawn here.
		//

        // First, if it's a console app we run the app with 'vcspawn -p -t' so
		// the user gets a 'Press any key to continue' when it's done.
		//
		
		IMAGETYPE iType;
		
		if (pCharMode (SpawnStruct.szAppName, &iType) == System_Console) {
			LPTSTR lpFilePart;
			static TCHAR szVCSpawnCmdPath[_MAX_PATH + 1];
			// We rely on only our vcspawn.exe in path.
			if (SearchPath(
				NULL,			/* lpPath */
				szVCSpawnCmd,		/* lpFileName */
				NULL,			/* lpExtension */
				_MAX_PATH,		/* nBurrerLength */
				szVCSpawnCmdPath,	/* lpBuffer */
				&lpFilePart		/* lpFilePart */
				) != 0) {
				//
				// We found vcspawn on the path
				//
				
				static TCHAR szArgsTmp[8128];
				
				// Build a new szArgs that looks like this:
				// "vcspawn -t -p d:\Path\MyDebuggee arg1 arg2..."
				
				_ftcscpy (szArgsTmp, szVCSpawnCmd);      // "vcspawn.exe"
				_ftcscat (szArgsTmp, szVCSToolFlag);	 // " -t " 
				_ftcscat (szArgsTmp, szVCSPauseFlag);    // " -p " 
				_ftcscat (szArgsTmp, SpawnStruct.szArgs); // the rest 
				
				// Put it back in the args
				_ftcscpy (SpawnStruct.szArgs, szArgsTmp);
				
				// Make vcspawn the exe to run, as found by SearchPath
				_ftcscpy (SpawnStruct.szAppName, szVCSpawnCmdPath);
			}
		}

        SpawnStruct.fReturn = CreateProcess( SpawnStruct.szAppName,
            SpawnStruct.szArgs,
            NULL,
            NULL,
            SpawnStruct.fInheritHandles,
            SpawnStruct.fdwCreate,
            NULL,
            SpawnStruct.pszCurrentDirectory,
            &SpawnStruct.si,
            lppi);

        Close3Handles(rgh);
        if (!SpawnStruct.fReturn) {
            SpawnStruct.dwError = GetLastError();
        } else {
			 // Close the thread and process handles
            CloseHandle(lppi->hThread);
            CloseHandle(lppi->hProcess);
		}
    } else {
        
        
		//
        //  This is a semaphore!  Set it last!
        //

        SpawnStruct.fSpawn    = TRUE;

        if (WaitForSingleObject( SpawnStruct.hEventApiDone, INFINITE ) != 0) {
            SpawnStruct.fReturn = FALSE;
            SpawnStruct.dwError = GetLastError();
        }
    }


    if (SpawnStruct.fReturn) {

        xosd = xosdNone;

    } else {

        DPRINT(1, (_T("Failed.\n")));

        xosd = xosdGeneral;
        // make a dbcError with SpawnStruct.dwError
        SendNTError(hprc, SpawnStruct.dwError, NULL);

    }

    return xosd;
}

#endif  // !KERNEL
#endif // 0


HPRCX
InitProcess(
    HPID hpid
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    HPRCX   hprc;

    /*
     * Create a process structure, place it
     * at the head of the master list.
     */

    hprc = (HPRCX)MHAlloc(sizeof(HPRCXSTRUCT));
    memset(hprc, 0, sizeof(*hprc));

    EnterCriticalSection(&csThreadProcList);

    hprc->next          = prcList->next;
    prcList->next       = hprc;
    hprc->hpid          = hpid;
    hprc->exceptionList = NULL;
    hprc->pid           = (PID)-1;      // Indicates prenatal process
    hprc->pstate        = 0;
    hprc->cLdrBPWait    = 0;
    hprc->fExited		= 0;
    hprc->hEventCreateThread = CreateEvent(NULL, TRUE, TRUE, NULL);
    hprc->f16bit        = FALSE;
	//hprc->fSoftBroken   = FALSE;

#ifndef KERNEL
    hprc->pFbrCntx      = NULL;  //Ignore Fibers
    hprc->FbrLst        = NULL;
    hprc->OrpcDebugging = ORPC_NOT_DEBUGGING;
    hprc->dwKernel32Base = 0;
    hprc->llnlg = LLInit(sizeof ( NLG ), llfNull, NULL, NLGComp );
#endif
	hprc->fStepInto		= FALSE;
	hprc->hExitFailed	= NULL;
	hprc->hAsyncStopRequest = NULL;

	VERIFY (CreateTimerEventQueue (&hprc->TimerQueue));
    InitExceptionList(hprc);

    LeaveCriticalSection(&csThreadProcList);

    return hprc;
}


void
ActionDebugNewReady(
    DEBUG_EVENT * pde,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    )
/*++

Routine Description:

    This function is called when a new child process is ready to run.
    The process is in exactly the same state as in ActionAllDllsLoaded.
    However, in this case the debugger is not waiting for a reply.

Arguments:


Return Value:

--*/
{
#if defined(INTERNAL)
    LPBYTE lpbPacket;
    WORD   cbPacket;
    PDLL_DEFER_LIST pddl;
    PDLL_DEFER_LIST pddlT;
    DEBUG_EVENT     de;
#endif

    DPRINT(5, (_T("Child finished loading\n")));

#ifdef TARGET_i386
    hthd->fContextDirty = FALSE;  // Undo the change made in ProcessDebugEvent
#endif

    hprc->pstate &= ~ps_preStart;       // Clear the loading state flag
    hprc->pstate |=  ps_preEntry;       // next stage...
    hthd->tstate |=  ts_stopped;        // Set that we have stopped on event
    --nWaitingForLdrBreakpoint;

#if 0
    SendDllLoads(hthd);
#endif

#if defined(INTERNAL)
    hprc->fNameRequired = TRUE;

    for (pddl = hprc->pDllDeferList; pddl; pddl = pddlT) {

        pddlT = pddl->next;

        de.dwDebugEventCode        = LOAD_DLL_DEBUG_EVENT;
        de.dwProcessId             = pde->dwProcessId;
        de.dwThreadId              = pde->dwThreadId;
        de.u.LoadDll               = pddl->LoadDll;

        if (LoadDll(&de, hthd, &cbPacket, &lpbPacket) && (cbPacket != 0)) {
            LeaveCriticalSection(&csProcessDebugEvent);
            NotifyEM(&de, hthd, cbPacket, lpbPacket);
            EnterCriticalSection(&csProcessDebugEvent);
        }

        MHFree(pddl);
    }
    hprc->pDllDeferList = NULL;
#endif

    /*
     * Prepare to stop on thread entry point
     */

    SetupEntryBP(hthd);

    /*
     * leave it stopped and notify the debugger.
     */
#if defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)
    SetBPFlag(hthd, EMBEDDED_BP);
#endif
    pde->dwDebugEventCode = LOAD_COMPLETE_DEBUG_EVENT;

    NotifyEM(pde, hthd, 0, 0L);

    return;
}                                       /* ActionDebugNewReady() */


void
ActionDebugActiveReady(
    DEBUG_EVENT * pde,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    )
/*++

Routine Description:

    This function is called when a newly attached process is ready to run.
    This process is not the same as the previous two.  It is either running
    or at an exception, and a thread has been created by DebugActiveProcess
    for the sole purpose of hitting a breakpoint.

    If we have an event handle, it needs to be signalled before the
    breakpoint is continued.

Arguments:


Return Value:

--*/
{

    DPRINT(5, (_T("Active process finished loading\n")));

#ifdef TARGET_i386
    hthd->fContextDirty = FALSE;  // Undo the change made in ProcessDebugEvent
#endif // i386

    hprc->pstate &= ~ps_preStart;
    hthd->tstate |=  ts_stopped;    // Set that we have stopped on event
    --nWaitingForLdrBreakpoint;

#if 0
    // BUGBUG kentf this is not wise.  As implemented, this will run code
    // in the crashed debuggee, calling LoadLibrary and other foolish things.
    SendDllLoads(hthd);
#endif

    /*
     * If this is a crashed process, tell the OS
     * to raise the exception.
     * Tell the EM that we are finished loading;
     * it will say GO, and we will catch the exception
     * soon after.
     */

    if (pde->dwProcessId == DebugActiveStruct.dwProcessId) {
        if (DebugActiveStruct.hEventGo) {
            SetEvent(DebugActiveStruct.hEventGo);
            CloseHandle(DebugActiveStruct.hEventGo);
        }
        DebugActiveStruct.dwProcessId = 0;
        DebugActiveStruct.hEventGo = 0;
        SetEvent(DebugActiveStruct.hEventReady);
    }

#if defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)
    SetBPFlag(hthd, EMBEDDED_BP);
#endif
    pde->dwDebugEventCode = LOAD_COMPLETE_DEBUG_EVENT;

    NotifyEM(pde, hthd, 0, 0L);

    return;
}                                       /* ActionDebugActiveReady() */


void
ActionEntryPoint16(
    DEBUG_EVENT   * pde,
    HTHDX           hthdx,
    DWORD           unused,
    LPVOID          lpv
    )
/*++

Routine Description:

    This is the registered event routine called when vdm
    sends a DBG_TASKSTART notification.

Arguments:


Return Value:

    None

--*/
{
    hthdx->hprc->pstate &= ~ps_preEntry;
    hthdx->tstate |= ts_stopped;
    NotifyEM(pde, hthdx, 0, (LPVOID)ENTRY_BP);
}


void
ActionEntryPoint(
    DEBUG_EVENT   * pde,
    HTHDX           hthd,
    DWORD           unused,
    LPVOID          lpv
    )
/*++

Routine Description:

    This is the registered event routine called when the base
    exe's entry point is executed.  The action we take here
    depends on whether we are debugging a 32 bit or 16 bit exe.

Arguments:

    pde     - Supplies debug event for breakpoint

    hthd    - Supplies descriptor for thread that hit BP

    unused  - unused

    lpv     - unused

Return Value:

    None

--*/
{
    PBREAKPOINT pbp;

    Unreferenced(lpv);

    pbp = AtBP(hthd);
    assert(pbp);
    RemoveBP(pbp);

    // the main reason we are here.
    ExprBPRestoreDebugRegs(hthd);

    if (hthd->hprc->f16bit) {

        //
        // if this is a 16 bit exe, continue and watch for
        // the task start event.
        //

        SetDebugEventThreadState (hthd->hprc, ts_running);

        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0 );


    } else {
        // if this is a 32 bit exe, stay stopped and notify the EM
        hthd->hprc->pstate &= ~ps_preEntry;
        hthd->tstate |= ts_stopped;
        pde->dwDebugEventCode = ENTRYPOINT_DEBUG_EVENT;
        NotifyEM(pde, hthd, 0, (LPVOID)ENTRY_BP);
        //DMSqlStartup( hthd->hprc );
    }
}


void
HandleDebugActiveDeadlock(
    HPRCX hprc
    )
{
    DEBUG_EVENT de;
    HTHDX   hthd;

    // This timed out waiting for the loader
    // breakpoint.  Clear the prestart state,
    // and tell the EM we are screwed up.
    // The shell should then stop waiting for
    // the loader BP.

    hprc->pstate &= ~ps_preStart;
    --nWaitingForLdrBreakpoint;
    ConsumeAllProcessEvents(hprc, TRUE);

    if (hprc->pid == DebugActiveStruct.dwProcessId) {
        if (DebugActiveStruct.hEventGo) {
            SetEvent(DebugActiveStruct.hEventGo);
            CloseHandle(DebugActiveStruct.hEventGo);
        }
        DebugActiveStruct.dwProcessId = 0;
        DebugActiveStruct.hEventGo = 0;
        SetEvent(DebugActiveStruct.hEventReady);
    }

    de.dwDebugEventCode      = ATTACH_DEADLOCK_DEBUG_EVENT;
    de.dwProcessId           = hprc->pid;
    hthd = hprc->hthdChild;
    if (hthd) {
        de.dwThreadId = hthd->tid;
    } else {
        de.dwThreadId = 0;
    }
    NotifyEM(&de, hthd, 0, 0);

}                                   /* HandleDebugActiveDeadlock() */



BOOL
SetupSingleStep(
    HTHDX hthd,
    BOOL  DoContinue,
	BOOL  fOnTrace
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    hthd        -   Supplies The handle to the thread which is to
                    be single stepped
    DoContinue  -   Supplies continuation flag

	fOnTrace-   for Instr of type INSTR_CANNOT_TRACE, we have already set
					a hardcoded bp, we should not set up single stepping in 
					this case - fOnTrace toggles trace bit 
					

Return Value:

    TRUE if successfly started step and FALSE otherwise

--*/
{

    PBREAKPOINT         pbp;
    ADDR                addr;

#if defined(NO_TRACE_FLAG)

    /*
     *  Set a breakpoint at the next legal offset and mark the breakpoint
     *  as being for a single step.
     */

	if (fOnTrace) {

        AddrInitEx( &addr, 0, GetNextOffset(hthd, FALSE), 
				    hthd->fAddrOff64, FALSE
				   );
        pbp = SetBP( hthd->hprc, hthd, bptpExec, 
				     bpnsStop, &addr, (HPID) INVALID
					);
        if ( pbp != NULL ) {
            pbp->isStep++;
        }
	}

    /*
     * Now issue the command to execute the child
     */

    if ( DoContinue ) {
        ThreadContinueDebugEvent (hthd);
    }


#else   // NO_TRACE_FLAG


#if defined(TARGET_i386)
#ifndef KERNEL

    /*
     *  Set the single step flag in the context and then start the
     *  thread running
     *
     *  Modify the processor flags in the child's context
     */

    //
    // If we are passing an exception on to the child we cannot set the
    // trace flag, so do the non-trace version of this code.
    //


    hthd->fContextDirty = TRUE;

	if (!fOnTrace) {
        HthdReg(hthd,EFlags) &= ~TF_BIT_MASK;
	}
	else {

        if (!IsPassingException (hthd->hprc)) {
            HthdReg(hthd,EFlags) |= TF_BIT_MASK;

        } else {
            int lpf = 0;

            HthdReg(hthd,EFlags) &= ~TF_BIT_MASK;

            //
            //  this sequence initializes addr to the addr after the current inst

            AddrFromHthdx (&addr, hthd);
            IsCall (hthd, &addr, &lpf, FALSE);


            pbp = SetBP( hthd->hprc, hthd, bptpExec, 
					     bpnsStop, &addr, (HPID) INVALID);
           if ( pbp != NULL ) {
               pbp->isStep++;
           }
       }
	}

#endif  // KERNEL

#elif defined(TARGET_IA64)

#else   // i386

#error "Need code for new CPU with trace bit"

#endif  // i386

    /*
     * Now issue the command to execute the child
     */

    if ( DoContinue ) {
        ThreadContinueDebugEvent (hthd);
    }

#endif  // NO_TRACE_FLAG

    return TRUE;
}                                       /*  SetupSingleStep() */
VOID
ActionReturnStep(
    DEBUG_EVENT   * pde,
    HTHDX           hthd,
    DWORD           unused,
    LPVOID          lpv
    )
/*++
        lpv - stack pointer at the top of the call
--*/
{
    BREAKPOINT* pbp = AtBP(hthd);

    assert(pbp);
#if defined(_M_ALPHA)
	if (STACK_POINTER(hthd) >= (DWORD)lpv) {
#else
    if (STACK_POINTER(hthd) > (DWORD)lpv) {
#endif
		RemoveBP (pbp);

#if 0
		//
		// If ORPC debuging is on and we've stopped in an ORPC section,
		// continue on.
		//
		
		if (hthd->hprc->OrpcDebugging == ORPC_DEBUGGING &&
			FAddrInOle (hthd->hprc, PC (hthd)) ||
			InRpcrt4 (hthd->hprc, PC (hthd))) {

            RegisterExpectedEvent (hthd->hprc,
                                   hthd,
                                   OLE_DEBUG_EVENT,
                                   orpcServerGetBufferSize,
                                   DONT_NOTIFY,
                                   ActionOrpcServerGetBufferSize,
                                   FALSE,
                                   (LPVOID) FALSE
                                   );

            ThreadContinueDebugEvent (hthd);

		} else
#endif

		{

			pde->dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
			pde->u.Exception.ExceptionRecord.ExceptionCode = EXCEPTION_SINGLE_STEP;
			ConsumeAllThreadEvents (hthd, FALSE);
			NotifyEM(pde, hthd, 0, NULL);
		}
    } else {
        METHOD *ContinueSSMethod;
        assert(pbp != EMBEDDED_BP);
        assert(pbp != NULL);
        ClearBPFlag(hthd);
        RestoreInstrBP(hthd, pbp);
        ContinueSSMethod = (METHOD*) MHAlloc(sizeof(METHOD));
        ContinueSSMethod->notifyFunction = MethodContinueSS;
        ContinueSSMethod->lparam = ContinueSSMethod;
        ContinueSSMethod->lparam2 = pbp;
        ++pbp->cthd;
        /* Reenable */
        RegisterExpectedEvent(hthd->hprc, hthd,
                              BREAKPOINT_DEBUG_EVENT,
                              (DWORD) pbp,
                              DONT_NOTIFY,
                              ActionReturnStep,
                              FALSE,
                              lpv);
        SingleStepEx(hthd, ContinueSSMethod, FALSE, FALSE, TRUE);
    }
}

BOOL
SetupReturnStep(
    HTHDX hthd,
    BOOL  DoContinue,
    LPADDR lpaddr,
    LPADDR addrStack
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    hthd        -   Supplies The handle to the thread which is to
                    be single stepped

    DoContinue  -   Supplies continuation flag

    lpaddr      -   Supplies the address to step to

    addrStack    -   Supplies the address for SP.
Return Value:

    TRUE if successfully started step and FALSE otherwise

--*/
{
    BREAKPOINT *        pbp;

    /*
     */

    pbp = SetBP( hthd->hprc, hthd, bptpExec, bpnsStop, lpaddr, (HPID)INVALID);

        if ( !pbp ) {

#if 0
#ifndef KERNEL
			if (CrashDump) {
				return FALSE;
			}
#endif
#endif
		
			//
			// On Win95 we might not be able to set the bp because
			// we might be in a callback and returning to system code.
			//
			
			//assert(IsChicago ());

			if (IsInSystemDll(GetAddrOff(*lpaddr))) {
				SendDBCErrorStep(hthd->hprc);
			} else {
					assert(FALSE); // Shouldn't happen any other time.
			}

			return FALSE;
		}


    if (addrStack) {
        RegisterExpectedEvent(hthd->hprc, hthd,
                              BREAKPOINT_DEBUG_EVENT,
                              (DWORD)pbp,
                              DONT_NOTIFY,
                              ActionReturnStep,
                              FALSE,
                              (LPVOID) GetAddrOff(*addrStack));
    }

#if 0

    SetupOrpcRangeStep (hthd);

#endif

    /*
     * Now issue the command to execute the child
     */

    if ( DoContinue ) {
        ExprBPContinue( hthd->hprc, hthd );
        ThreadContinueDebugEvent (hthd);
    }

    return TRUE;
}                                       /*  SetupReturnStep() */



void
SetupEntryBP(
    HTHDX   hthd
    )
/*++

Routine Description:

    Set a breakpoint and make a persistent expected event for the
    entry point of the first thread in a new process.

Arguments:

    hthd    - Supplies descriptor for thread to act on.

Return Value:

    None

--*/
{
    ADDR            addr;
    BREAKPOINT    * bp;
#if defined(TARGET_PPC)
    OFFSET        real_addr_entry_pt;
    DWORD         cb;
#endif

    AddrInit(&addr,
             0,
             0,
             (OFFSET)hthd->lpStartAddress,
             TRUE,
             TRUE,
             FALSE,
             FALSE);

#if defined(TARGET_PPC)

    // for PPC we have a function entry at lpStartAddress because
    // of the darn TOC, so  we need to dereference it
    // All other BP's work out fine 'cause we use the CV info. which
    // gets around the problem.


    AddrReadMemory(hthd->hprc, hthd, &addr,
                      &real_addr_entry_pt,
                      sizeof(real_addr_entry_pt),&cb);

    if (cb != sizeof(real_addr_entry_pt)) {

        DPRINT(1,(_T("Could not read the info located at 0x%lx -- cb = %ld"),addr.addr.off,cb));
        assert(FALSE);
        return;
    }

    DPRINT(1,(_T("The dereferenced address of the entry pt is 0x%lx"),
           real_addr_entry_pt));


    AddrInit(&addr,
             0,
             0,
             real_addr_entry_pt,
             TRUE,
             TRUE,
             FALSE,
             FALSE);

#endif // PPC

    bp = SetBP(hthd->hprc, hthd, bptpExec, bpnsStop, &addr, (HPID)ENTRY_BP);

    // register expected event
    RegisterExpectedEvent(hthd->hprc,
                          hthd,
                          BREAKPOINT_DEBUG_EVENT,
                          (DWORD)bp,
                          DONT_NOTIFY,
                          ActionEntryPoint,
                          TRUE,     // Persistent!
                          NULL
                         );
}                                   /* SetupEntryBP() */


#ifdef KERNEL
VOID
RestoreKernelBreakpoints (
    HTHDX   hthd,
    UOFF32  Offset
    )
/*++

Routine Description:

    Restores all breakpoints in our bp list that fall in the range of
    offset -> offset+dbgkd_maxstream.  This is necessary because the kd
    stub in the target system clears all breakpoints in this range before
    delivering an exception to the debugger.

Arguments:

    hthd    - handle to the current thread

    Offset  - beginning of the range, usually the current pc

Return Value:

    None

--*/
{

    BREAKPOINT              *pbp;
    DBGKD_WRITE_BREAKPOINT  bps[MAX_KD_BPS];
    DWORD                   i = 0;


    EnterCriticalSection(&csThreadProcList);

    ZeroMemory( bps, sizeof(bps) );

    for (pbp=bpList->next; pbp; pbp=pbp->next) {

        if (GetAddrOff(pbp->addr) >= Offset &&
            GetAddrOff(pbp->addr) <  Offset+DBGKD_MAXSTREAM) {
            if (i < MAX_KD_BPS) {
                bps[i++].BreakPointAddress = (LPVOID)GetAddrOff(pbp->addr);
            }
        }
    }

    if (i) {
        WriteBreakPointEx( hthd, i, bps, 0 );

        for (i=0,pbp=bpList->next; pbp; pbp=pbp->next) {

            if (GetAddrOff(pbp->addr) == (DWORD)bps[i].BreakPointAddress) {
                pbp->hBreakPoint = bps[i++].BreakPointHandle;

            }
        }
    }

    LeaveCriticalSection(&csThreadProcList);
}
#endif // KERNEL


#ifndef KERNEL

void
UpdateThreadContext(
    HTHDX   hthd
    )
/*++

Routine Description:

    This routine updates a thread's context, including real/32bit modes and
    context dirty flags.

--*/
{
#if defined(TARGET_i386)
    LDT_ENTRY           ldtEntry;
#endif

#ifndef REGSYNC
    hthd->ctx.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT |
		CONTEXT_EXTENDED_REGISTERS;
    DbgGetThreadContext( hthd, &hthd->ctx);
    hthd->fContextDirty = FALSE;
    hthd->fIsCallDone = FALSE;
#if 0
    if (hthd->ctx.EFlags & V86FLAGS_V86) {
        hthd->fAddrIsReal  = TRUE;
        hthd->fAddrIsFlat  = FALSE;
        hthd->fAddrOff32   = FALSE;
    } else
#endif
	{
        hthd->fAddrIsReal  = FALSE;
        hthd->fAddrIsFlat = hthd->fAddrOff32 = TRUE;
    }
#else
	/* Start with an empty context until somebody wants something */
	hthd->ctx.ContextFlags = 0;
    hthd->fIsCallDone = FALSE;
    hthd->fContextDirty = FALSE;
    hthd->fAddrIsReal  = FALSE;
	hthd->fAddrIsFlat = hthd->fAddrOff32 = TRUE;
#endif
}


void
SetDebugEventThreadState(
    HPRCX   hprc,
    TSTATEX state
    )
{
    HTHDX   hthd;

    hthd = (HTHDX) HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);

    assert (hthd);
    switch (state)
    {
        case ts_running:
            hthd->tstate &= ~(ts_stopped | ts_first | ts_second);
            hthd->tstate |= ts_running;
            break;

        default:
            assert (FALSE);
    }
}



void
ProcessDebugEvent(
    DEBUG_EVENT *  de
    )
/*++

Routine Description:

    This routine is called whenever a debug event notification comes from
    the operating system.

Arguments:

    de      - Supplies a pointer to the debug event which just occured

Return Value:

    None.

Notes:

    This is the user-mode version of this function.

--*/

{
    EXPECTED_EVENT *    ee;
    DWORD               eventCode = de->dwDebugEventCode;
    DWORD               subClass = 0L;
    HTHDX               hthd = NULL;
    HPRCX               hprc;
    BREAKPOINT *        bp;
    ADDR                addr;
    BP_UNIT             instr;
    DWORD               len;
    BOOL                fInstrIsBp;

    DPRINT(3, (_T("Event Code == %x\n"), eventCode));

    hprc = HPRCFromPID(de->dwProcessId);

    /*
     * While killing process, ignore everything
     * except for exit events.
     */

    if (hprc) {
        hprc->cLdrBPWait = 0;

        //
        // If any of the threads are stopped, we got a debug event while
        // processing another debug event.  This can happen in console apps.
        // Ignore it and continue on.
        //

#if 0
		if (!CrashDump) 
#endif
		{

			for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {

				if (hthd->tstate & ts_stopped && !(hthd->tstate & ts_dead)) {
					/* We need to continue this thread if it's hit an
					 * exception or a breakpoint */

					// REVIEW jlange -- why do we ever get here?
					assert(FALSE);
					if(eventCode == EXCEPTION_DEBUG_EVENT) {
						DmContinueThread(de->dwThreadId, FALSE);
						DmGo();
					}
#if 0
					ContinueDebugEvent (de->dwProcessId, de->dwThreadId,
										DBG_CONTINUE);
#endif
					return ;
				}
					
            }
		}
    
        
                
#ifndef KERNEL
        hprc->lastTidDebugEvent = de->dwThreadId;
#endif
    }

    if ( hprc && (hprc->pstate & ps_killed) ) {
        if (eventCode == EXCEPTION_DEBUG_EVENT) {

            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                      0);
            return;

        } else if (eventCode != EXIT_THREAD_DEBUG_EVENT
          && eventCode != EXIT_PROCESS_DEBUG_EVENT ) {
            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                      0);
            return;
        }
    }

    EnterCriticalSection(&csProcessDebugEvent);

    if (eventCode == CREATE_THREAD_DEBUG_EVENT){

        DPRINT(3, (_T("*** NEW TID = (PID,TID)(%08lx, %08lx)\n"),
                      de->dwProcessId, de->dwThreadId));

    } else {

        /*
         *  Find our structure for this event's process
         */

        DEBUG_PRINT(_T("Not Create Thread Debug Event\r\n"));
        hthd = HTHDXFromPIDTID((PID)de->dwProcessId,(TID)de->dwThreadId);

        //
        //  Update the context for all threads, not just the main one.  We
        //  may be able to do this a little quicker by using the
        //  fContextDirty flag.
        //

        //
        //  First, update the main threads ExceptionRecord if necessary

        if (hthd && eventCode == EXCEPTION_DEBUG_EVENT) {
            hthd->ExceptionRecord = de->u.Exception.ExceptionRecord;
        }

        //
        //  Loop through all threads and update contexts

        if (hthd && hprc) {
            HTHDX   hthdT;
            //
            // If for any reason this is set unset it.
            //
#ifndef KERNEL
            hprc->pFbrCntx = NULL;
#endif
            /* If this is an exit process event, we can't deal with getting
             * the thread context, so we just handle the event and get out
             * of here */
            if(eventCode == EXIT_PROCESS_DEBUG_EVENT) {
                ProcessExitProcessEvent(de, hthd);
                goto done;
            }

            //
            // v-vadimp - since the fxsave/fxrstor hack screws up exception handling we have to limit its use:
            // 1. try to get extended registers only if the event was an exception (should not need them for dll loading, thread starts, etc)
            // 2. do not get them for a first chance exception that are the user's list - exceptuion handlers will be screwed up (the user will not see extended registers)
            // 3. do get them for second-chance exceptions, when all user hanlers have excuted
            //			
            hthd->fContextExtendedDirty = FALSE;
            if (FXSAVESupported && (eventCode == EXCEPTION_DEBUG_EVENT)) {
                hthd->fContextExtendedDirty = TRUE;
                if (de->u.Exception.dwFirstChance == 1) {
                    EXCEPTION_LIST   *eList;
                    for (eList=hprc->exceptionList; eList; eList=eList->next) {
                        if (eList->excp.dwExceptionCode == (DWORD)de->u.Exception.ExceptionRecord.ExceptionCode ) {
                            break;
                        }
                    }
                    hthd->fContextExtendedDirty = (eList == NULL);
                }
            }

            for (hthdT = hprc->hthdChild; hthdT; hthdT = hthdT->nextSibling) {
                UpdateThreadContext (hthdT);
            }

        } else if (hprc && (hprc->pstate & ps_killed)) {

            /*
             * this is an event for a thread that
             * we never created:
             */
            if (eventCode == EXIT_PROCESS_DEBUG_EVENT) {
                /* Process exited on a thread we didn't pick up */
                ProcessExitProcessEvent(de, NULL);
            } else {
                /* this is an exit thread for a thread we never picked up */
                AddQueue( QT_CONTINUE_DEBUG_EVENT,
                          de->dwProcessId,
                          de->dwThreadId,
                          DBG_CONTINUE,
                          0);
            }
            goto done;

        } else if (eventCode!=CREATE_PROCESS_DEBUG_EVENT) {

            //
            // This will happen sometimes when killing a process with
            // ProcessTerminateProcessCmd and ProcessUnloadCmd.
            //

            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      DBG_CONTINUE,
                      0);
            goto done;

        }
    }

    //
    //  Mark the thread as having been stopped for some event.
    //

    if (hthd) {
        hthd->tstate &= ~ts_running;
        hthd->tstate |= ts_stopped;
    }

    /* If it is an exception event get the subclass */

    if (eventCode == EXCEPTION_DEBUG_EVENT) {

        subClass = de->u.Exception.ExceptionRecord.ExceptionCode;
        DPRINT(1, (_T("Exception Event: subclass = %x    "), subClass));

        switch (subClass) {
        case (DWORD)STATUS_SEGMENT_NOTIFICATION:
            eventCode = de->dwDebugEventCode = SEGMENT_LOAD_DEBUG_EVENT;
            break;

        case (DWORD)EXCEPTION_SINGLE_STEP:
#if !defined(TARGET_i386)
            assert(_T("!EXCEPTION_SINGLE_STEP on non-x86!"));
#endif
            AddrFromHthdx(&addr, hthd);

            //
            // This may be a single step or a hardware breakpoint.
            // If it is a single step, leave it at that.  If it is
            // a hardware breakpoint, convert it to a BREAKPOINT_DEBUG_EVENT.
            //

            DecodeSingleStepEvent( hthd, de, &eventCode, &subClass );
            break;

        case (DWORD)EXCEPTION_BREAKPOINT:

            /*
             * Check if it is a BREAKPOINT exception:
             * If it is, change the debug event to our pseudo-event,
             * BREAKPOINT_DEBUG_EVENT (this is a pseudo-event because
             * the API does not define such an event, and we are
             * synthesizing not only the class of event but the
             * subclass as well -- the subclass is set to the appropriate
             * breakpoint structure)
             */

            AddrFromHthdx(&addr, hthd);
            //
            // correct for machine overrun on a breakpoint
            //
            // On NT the offset value is overrun by 1 every time except
            // for when doing post-mortem debugging. The value in the
            // Debug Event structure is always correct though
            //

            addr.addr.off = (DWORD) de->u.Exception.ExceptionRecord.ExceptionAddress ;

            DPRINT(3, (_T("Looking for BP@%lx\n"), addr.addr.off));

            EnterCriticalSection(&csThreadProcList);
            /*
             *  Lookup the breakpoint in our (the dm) table
             *  Need to do this before the instruction check
             */
            bp = FindBP(hthd->hprc, hthd, bptpExec, (BPNS)-1, &addr, FALSE);
            //
            //  We need to be able to find BPs for message BPs as well

            if (bp == NULL) {
                bp = FindBP (hthd->hprc,
                             hthd,
                             bptpMessage,
                             (BPNS) -1,
                             &addr,
                             FALSE);
            }

            SetBPFlag(hthd, bp?bp:EMBEDDED_BP);
            LeaveCriticalSection(&csThreadProcList);

            //
            // Determine the start of the breakpoint instruction
            //

            if ((AddrReadMemory(hprc, hthd, &addr, &instr, BP_SIZE, &len) == 0)
                            || (len != BP_SIZE)) {
                DPRINT(1, (_T("Memory read failed!!!\n")));
                assert(FALSE);
                instr = 0;
            }

            /*
             *  It may have been a 0xcd 0x03 rather than a 0xcc
             *  (ie: check if it is a 1 or a 2 byte INT 3)
             */

            fInstrIsBp = FALSE;
            if (instr == BP_OPCODE) {
                fInstrIsBp = TRUE;
            } else if (instr == 0x3) { // 0xcd?
                --addr.addr.off;
                if (AddrReadMemory(hprc,
                                  hthd,
                                  &addr,
                                  &instr,
                                  1,
                                  &len)
                     && (len == 1)
                     && (instr == 0xcd)) {

                    fInstrIsBp = TRUE;
                } else {
                    ++addr.addr.off;
                }
            } else {
			    /* Because Xbox breakpoints don't actually show the int 3 as
                 * being in memory, we need to explicitly check whether this
                 * was a set breakpoint */
                DWORD dwType;
                if(SUCCEEDED(DmIsBreakpoint((PVOID)addr.addr.off, &dwType)) &&
                        dwType == DMBREAK_FIXED)
                    fInstrIsBp = TRUE;
            }

            PC(hthd) = (LONG)addr.addr.off;
            hthd->fContextDirty = TRUE;

            if (!bp && !fInstrIsBp) {
                //
                // If the instruction is not a bp, and there is no record of
                // the bp, this happened because the exception was already
                // in the queue when we cleared the bp.
                //
                // We will just continue it.
                //
                DPRINT(1, (_T("Continuing false BP.\n")));
				SetDebugEventThreadState(hthd->hprc, ts_running);
                AddQueue(QT_CONTINUE_DEBUG_EVENT,
                         hthd->hprc->pid,
                         hthd->tid,
                         DBG_CONTINUE,
                         0 );
                goto done;
            }


            //
            // Q: What does it mean if we find the bp record, but the
            // instruction is not a bp???
            //
            // A: It means that this thread hit the BP after another
            // thread hit it, but before this thread could be suspended
            // by the debug subsystem.  The debugger cleared the BP
            // temporarily in order that the other thread could run
            // past it, and will put it back as soon as that thread
            // hits the temp BP on the next instruction.
            //
            //assert(!bp || fInstrIsBp);

            /*
             *  Reassign the event code to our pseudo-event code
             */
            DPRINT(3, (_T("Reassigning event code!\n")));

            /*
             *  For some machines there is not single instruction tracing
             *  on the chip.  In this case we need to do it in software.
             *
             *  Check to see if the breakpoint we just hit was there for
             *  doing single step emulation.  If so then remap it to
             *  a single step exception.
             */

            if (bp && bp->isStep){
                de->u.Exception.ExceptionRecord.ExceptionCode
                  = subClass = (DWORD)EXCEPTION_SINGLE_STEP;
                RemoveBP(bp);
                break;
            }

            /*
             * Reassign the subclass to point to the correct
             * breakpoint structure
             *
             */

            de->dwDebugEventCode = eventCode = BREAKPOINT_DEBUG_EVENT;
            de->u.Exception.ExceptionRecord.ExceptionAddress =
                (PVOID) addr.addr.off;
            de->u.Exception.ExceptionRecord.ExceptionCode =
              subClass = (DWORD)bp;

            break;


#if 0
            case EXCEPTION_ORPC_DEBUG:
            {
                ORPC orpc;

                // Is this really an OLE notification?
                if ((orpc = OrpcFromPthd(hthd, de)) != orpcNil) {
                    if (orpc == orpcUnrecognized) {
                        // Unrecognized notification.  Resume execution.
                        AddQueue(QT_CONTINUE_DEBUG_EVENT,
                                 hthd->hprc->pid,
                                 hthd->tid,
                                 DBG_CONTINUE,
                                 0 );
                        return;
                    }

                    /*
                    ** Reassign the event code to our pseudo-event code
                    */
                    de->dwDebugEventCode = eventCode = OLE_DEBUG_EVENT;

                    /*
                    ** Reassign the exception code to the type of OLE
                    ** event that occurred.
                    */
                    de->u.Exception.ExceptionRecord.ExceptionCode =
                        subClass = (DWORD) orpc;
                }
                break;
            }
#endif
            case EXCEPTION_FIBER_DEBUG:
            {
                //If fibers are in use change to fiber event
                if(hprc->fUseFbrs) {
                    de->dwDebugEventCode = eventCode = FIBER_DEBUG_EVENT;
                }
                break;
            }
			case EXCEPTION_VISUALCPP_DEBUGGER:
				de->dwDebugEventCode = eventCode = SPECIAL_DEBUGGER_EVENT;
				break;

#ifdef OMNI
			case EXCEPTION_OMNI_DEBUGGER_PRESENT:
				// just catch the exception
                /* this is an exit thread for a thread we never picked up */
                AddQueue( QT_CONTINUE_DEBUG_EVENT,
                          de->dwProcessId,
                          de->dwThreadId,
                          DBG_CONTINUE,
                          0);
				goto done;

            case EXCEPTION_OMNI_DLL_LOAD:
            {
                // Omni Modload - simulate a LoadDll
                de->dwDebugEventCode = eventCode = OMNI_DLL_LOAD_EVENT;
                break;
            }
#endif
        }
    }

    /*
     *  Check if this debug event was expected
     */

    ee = PeeIsEventExpected(hthd, eventCode, subClass, TRUE);


    /*
     * If it wasn't, clear all consummable events
     * and then run the standard handler with
     * notifications going to the execution model
     */

    assert((0 < eventCode) && (eventCode < MAX_EVENT_CODE));

    if (!ee) {

        if ((hthd != NULL) && (hthd->tstate & ts_funceval)) {
            assert(RgfnFuncEventDispatch[eventCode-EXCEPTION_DEBUG_EVENT]);
            RgfnFuncEventDispatch[eventCode-EXCEPTION_DEBUG_EVENT](de, hthd);
        } else {
            assert(DebugDispatchTable[eventCode-EXCEPTION_DEBUG_EVENT]);
            DebugDispatchTable[eventCode-EXCEPTION_DEBUG_EVENT](de,hthd);
        }

    } else {

        /*
         *  If it was expected then call the action
         * function if one was specified
         */

        if (ee->action) {
            (ee->action)(de, hthd, 0, ee->lparam);
        }

        /*
         *  And call the notifier if one was specified
         */

        if (ee->notifier) {
            METHOD  *nm = ee->notifier;
            (nm->notifyFunction)(de, hthd, 0, nm->lparam);
        }

        MHFree(ee);
    }

done:

    LeaveCriticalSection(&csProcessDebugEvent);
    return;
}                               /* ProcessDebugEvent() */



#else // KERNEL




void
ProcessDebugEvent(
    DEBUG_EVENT              *de,
    DBGKD_WAIT_STATE_CHANGE  *sc
    )
/*++

Routine Description:

    This routine is called whenever a debug event notification comes from
    the operating system.

Arguments:

    de      - Supplies a pointer to the debug event which just occured

Return Value:

    None.

Comments:

    This is the kernel debugging version of this fucntion.

--*/

{
    EXPECTED_EVENT *    ee;
    DWORD               eventCode = de->dwDebugEventCode;
    DWORD               subClass = 0L;
    HTHDX               hthd = NULL;
    HPRCX               hprc;
    PBREAKPOINT         bp;
    ADDR                addr;
    DWORD               cb;
    BP_UNIT             instr;
    BOOL                fInstrIsBp = FALSE;


    DPRINT(3, (_T("Event Code == %x\n"), eventCode));

    hprc = HPRCFromPID(de->dwProcessId);

    /*
     * While killing process, ignore everything
     * except for exit events.
     */

    if (hprc) {
        hprc->cLdrBPWait = 0;
    }

    if ( hprc && (hprc->pstate & ps_killed) ) {
        if (eventCode == EXCEPTION_DEBUG_EVENT) {

            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                      0);
            return;

        } else if (eventCode != EXIT_THREAD_DEBUG_EVENT
          && eventCode != EXIT_PROCESS_DEBUG_EVENT ) {

            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                      0);
            return;
        }
    }

    EnterCriticalSection(&csProcessDebugEvent);

    if (eventCode == CREATE_THREAD_DEBUG_EVENT){

        DPRINT(3, (_T("*** NEW TID = (PID,TID)(%08lx, %08lx)\n"),
                      de->dwProcessId, de->dwThreadId));

    } else {

        /*
         *  Find our structure for this event's process
         */

        hthd = HTHDXFromPIDTID((PID)de->dwProcessId,(TID)de->dwThreadId);

        /*
         *  Update our context structure for this thread if we found one
         *      in our list.  If we did not find a thread and this is
         *      not a create process debug event then return without
         *      processing the event as we are in big trouble.
         */

        if (hthd) {
            if (eventCode == EXCEPTION_DEBUG_EVENT) {
                hthd->ExceptionRecord = de->u.Exception.ExceptionRecord;
            }
            hthd->context.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
            DbgGetThreadContext(hthd,&hthd->context);
            hthd->fContextDirty = FALSE;
            hthd->fIsCallDone   = FALSE;
            hthd->fAddrIsReal   = FALSE;
            hthd->fAddrIsFlat   = TRUE;
            hthd->fAddrOff32    = TRUE;

        } else if (hprc && (hprc->pstate & ps_killed)) {

            /*
             * this is an event for a thread that
             * we never created:
             */

            if (eventCode == EXIT_PROCESS_DEBUG_EVENT) {
                /* Process exited on a thread we didn't pick up */
                ProcessExitProcessEvent(de, NULL);
            } else {
                /* this is an exit thread for a thread we never picked up */
                AddQueue( QT_CONTINUE_DEBUG_EVENT,
                          de->dwProcessId,
                          de->dwThreadId,
                          DBG_CONTINUE,
                          0);
            }
            goto done;

        } else if (eventCode != CREATE_PROCESS_DEBUG_EVENT) {

            assert (FALSE);

            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      de->dwProcessId,
                      de->dwThreadId,
                      DBG_CONTINUE,
                      0);
            goto done;
        }
    }

    /*
     *  Mark the thread as having been stopped for some event.
     */

    if (hthd) {
        hthd->tstate &= ~ts_running;
        hthd->tstate |= ts_stopped;
    }

    /* If it is an exception event get the subclass */

    if (eventCode==EXCEPTION_DEBUG_EVENT){

        subClass = de->u.Exception.ExceptionRecord.ExceptionCode;
        DPRINT(1, (_T("Exception Event: subclass = %x    "), subClass));

        switch (subClass) {
        case (DWORD)STATUS_SEGMENT_NOTIFICATION:
            eventCode = de->dwDebugEventCode = SEGMENT_LOAD_DEBUG_EVENT;
            break;

        case (DWORD)EXCEPTION_SINGLE_STEP:
#if !defined(TARGET_i386)
            assert(_T("!EXCEPTION_SINGLE_STEP on non-x86!"));
#endif
            AddrFromHthdx(&addr, hthd);
            RestoreKernelBreakpoints( hthd, GetAddrOff(addr) );

            //
            // This may be a single step or a hardware breakpoint.
            // If it is a single step, leave it at that.  If it is
            // a hardware breakpoint, convert it to a BREAKPOINT_DEBUG_EVENT.
            //

            DecodeSingleStepEvent( hthd, de, &eventCode, &subClass );
            break;

        case (DWORD)EXCEPTION_BREAKPOINT:

            /*
             * Check if it is a BREAKPOINT exception:
             * If it is, change the debug event to our pseudo-event,
             * BREAKPOINT_DEBUG_EVENT (this is a pseudo-event because
             * the API does not define such an event, and we are
             * synthesizing not only the class of event but the
             * subclass as well -- the subclass is set to the appropriate
             * breakpoint structure)
             */

            hthd->fDontStepOff = FALSE;

            AddrFromHthdx(&addr, hthd);

            /*
             *  Lookup the breakpoint in our (the dm) table
             */

            bp = FindBP(hthd->hprc, hthd, bptpExec, (BPNS)-1, &addr, FALSE);
            SetBPFlag(hthd, bp);

            /*
             *  Reassign the event code to our pseudo-event code
             */
            DPRINT(3, (_T("Reassigning event code!\n")));

            /*
             *  For some machines there is not single instruction tracing
             *  on the chip.  In this case we need to do it in software.
             *
             *  Check to see if the breakpoint we just hit was there for
             *  doing single step emulation.  If so then remap it to
             *  a single step exception.
             */

            if (bp) {
                if (bp->isStep){
                    de->u.Exception.ExceptionRecord.ExceptionCode
                      = subClass = (DWORD)EXCEPTION_SINGLE_STEP;
                    RemoveBP(bp);
                    RestoreKernelBreakpoints( hthd, GetAddrOff(addr) );
                    break;
                } else {
                    RestoreKernelBreakpoints( hthd, GetAddrOff(addr) );
                }
            }

            //
            // Determine the start of the breakpoint instruction
            //

            if (fCrashDump) {
                cb = DmpReadMemory((LPVOID)GetAddrOff(addr),&instr,BP_SIZE);
                if (cb != BP_SIZE) {
                    DPRINT(1, (_T("Memory read failed!!!\n")));
                    instr = 0;
                }
            } else {
                if (DmKdReadVirtualMemoryNow((LPVOID)GetAddrOff(addr),&instr,BP_SIZE,&cb) || cb != BP_SIZE) {
                    DPRINT(1, (_T("Memory read failed!!!\n")));
                    instr = 0;
                }
            }

#if defined(TARGET_ALPHA)

            switch (instr) {
                case 0:
                case CALLPAL_OP | CALLKD_FUNC:
                case CALLPAL_OP |    BPT_FUNC:
                case CALLPAL_OP |   KBPT_FUNC:
                     fInstrIsBp = TRUE;
                     break;
                default:
                    addr.addr.off -= BP_SIZE;
                    if (fCrashDump) {
                        cb = DmpReadMemory((LPVOID)GetAddrOff(addr),&instr,BP_SIZE);
                        if (cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    } else {
                        if (DmKdReadVirtualMemoryNow((LPVOID)GetAddrOff(addr),&instr,BP_SIZE,&cb) || cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    }
                    switch (instr) {
                        case 0:
                        case CALLPAL_OP | CALLKD_FUNC:
                        case CALLPAL_OP |    BPT_FUNC:
                        case CALLPAL_OP |   KBPT_FUNC:
                             fInstrIsBp = TRUE;
                             hthd->fDontStepOff = TRUE;
                             break;
                        default:
                             fInstrIsBp = FALSE;
                    }
            }

#elif defined(TARGET_PPC)
                if ((instr == BP_OPCODE) || (instr == 0))
                   fInstrIsBp = TRUE;

                if ((!fInstrIsBp) && (LPVOID) GetAddrOff(addr)) {
                    addr.addr.off -= BP_SIZE;
                    if (fCrashDump) {
                        cb = DmpReadMemory((LPVOID)GetAddrOff(addr),&instr,BP_SIZE);
                        if (cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    } else {
                        if (DmKdReadVirtualMemoryNow((LPVOID)GetAddrOff(addr),&instr,BP_SIZE,&cb) || cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    }

                    if (instr == PPC_KERNEL_BREAKIN_OPCODE)
                    {
                        fInstrIsBp = TRUE;
                        hthd->fDontStepOff = TRUE;

                    }
}

#elif defined(TARGET_i386)

            /*
             *  It may have been a 0xcd 0x03 rather than a 0xcc
             *  (ie: check if it is a 1 or a 2 byte INT 3)
             */

            fInstrIsBp = FALSE;
            if (instr == BP_OPCODE || instr == 0) {
                fInstrIsBp = TRUE;
            } else
            if (instr == 0x3) { // 0xcd?
                --addr.addr.off;
                if (fCrashDump) {
                    cb = DmpReadMemory((LPVOID)GetAddrOff(addr),&instr,BP_SIZE);
                    if (cb != BP_SIZE) {
                        DPRINT(1, (_T("Memory read failed!!!\n")));
                        instr = 0;
                    }
                } else {
                    if (DmKdReadVirtualMemoryNow((LPVOID)GetAddrOff(addr),&instr,BP_SIZE,&cb) || cb != BP_SIZE) {
                        DPRINT(1, (_T("Memory read failed!!!\n")));
                        instr = 0;
                    }
                }
                if (cb == 1 && instr == 0xcd) {
                    --addr.addr.off;
                    fInstrIsBp = TRUE;
                }
            } else {
                hthd->fDontStepOff = TRUE;
            }

#elif defined(TARGET_MIPS)

            {
                PINSTR bi = (PINSTR)&instr;
                if ((bi->break_instr.Opcode == SPEC_OP &&
                     bi->break_instr.Function == BREAK_OP) || (instr == 0)) {

                    fInstrIsBp = TRUE;

                }

                if (!fInstrIsBp) {
                    addr.addr.off -= BP_SIZE;
                    if (fCrashDump) {
                        cb = DmpReadMemory((LPVOID)GetAddrOff(addr),&instr,BP_SIZE);
                        if (cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    } else {
                        if (DmKdReadVirtualMemoryNow((LPVOID)GetAddrOff(addr),&instr,BP_SIZE,&cb) || cb != BP_SIZE) {
                            DPRINT(1, (_T("Memory read failed!!!\n")));
                            instr = 0;
                        }
                    }
                    if (bi->break_instr.Opcode == SPEC_OP &&
                        bi->break_instr.Function == BREAK_OP &&
                        bi->break_instr.Code == BREAKIN_BREAKPOINT) {

                        fInstrIsBp = TRUE;
                        hthd->fDontStepOff = TRUE;

                    }
                }
            }

#else

#pragma error( "undefined processor type" );

#endif

            if (!bp && !fInstrIsBp) {
                DMPrintShellMsg( _T("Stopped at an unexpected exception: code=%08x addr=%08x\n"),
                                 de->u.Exception.ExceptionRecord.ExceptionCode,
                                 de->u.Exception.ExceptionRecord.ExceptionAddress
                               );
            }

            /*
             * Reassign the subclass to point to the correct
             * breakpoint structure
             *
             */

            de->dwDebugEventCode = eventCode = BREAKPOINT_DEBUG_EVENT;
            de->u.Exception.ExceptionRecord.ExceptionAddress =
                (PVOID) addr.addr.off;
            de->u.Exception.ExceptionRecord.ExceptionCode =
              subClass = (DWORD)bp;

            break;
        }
    }

    /*
     *  Check if this debug event was expected
     */

    ee = PeeIsEventExpected(hthd, eventCode, subClass, TRUE);


    /*
     * If it wasn't, clear all consummable events
     * and then run the standard handler with
     * notifications going to the execution model
     */

    assert((0 < eventCode) && (eventCode < MAX_EVENT_CODE));

    if (!ee) {

        if ((hthd != NULL) && (hthd->tstate & ts_funceval)) {
            assert(RgfnFuncEventDispatch[eventCode-EXCEPTION_DEBUG_EVENT]);
            RgfnFuncEventDispatch[eventCode-EXCEPTION_DEBUG_EVENT](de, hthd);
        } else {
            assert(DebugDispatchTable[eventCode-EXCEPTION_DEBUG_EVENT]);
            DebugDispatchTable[eventCode-EXCEPTION_DEBUG_EVENT](de,hthd);
        }

    } else {

        /*
         *  If it was expected then call the action
         * function if one was specified
         */

        if (ee->action) {
            (ee->action)(de, hthd, 0, ee->lparam);
        }

        /*
         *  And call the notifier if one was specified
         */

        if (ee->notifier) {
            METHOD  *nm = ee->notifier;
            (nm->notifyFunction)(de, hthd, 0, nm->lparam);
        }

        MHFree(ee);
    }

done:
    LeaveCriticalSection(&csProcessDebugEvent);
    return;
}                               /* ProcessDebugEvent() */



#endif // KERNEL

#if 0

#ifndef KERNEL
////////////////////////////////////////////////////////////////////

//  Helper functions for LoadDll.

////////////////////////////////////////////////////////////////////

//
// iTemp1 is a magic module ID number for when we have to make
// up a name for a module.
//

static iTemp1 = 0;

BOOL
GetModnameFromImage(
    PIMAGE_NT_HEADERS       pNtHdr,
    PIMAGE_SECTION_HEADER   pSH,
    LOAD_DLL_DEBUG_INFO   * pldd,
    LPTSTR                  lpName,
    int                     cbName
    )
/*++

Routine Description:

    This routine attempts to get the name of the exe as placed
    in the debug section section by the linker.

Arguments:

    pNtHdr  - Supplies pointer to NT headers in image PE header

    pSH     - Supplies pointer to section headers

    pldd    - Supplies the info structure from the debug event

    lpName  - Returns the exe name

    cbName  - Supplies the size of the buffer at lpName

Return Value:

    TRUE if a name was found, FALSE if not.
    The exe name is returned as an ANSI string in lpName.

--*/
{
    /*
     * See if the exe name is in the image
     */
    PIMAGE_OPTIONAL_HEADER      pOptHdr = &pNtHdr->OptionalHeader;
    PIMAGE_DEBUG_DIRECTORY      pDebugDir;
    IMAGE_DEBUG_DIRECTORY       DebugDir;
    PIMAGE_DEBUG_MISC           pMisc;
    PIMAGE_DEBUG_MISC           pT;
    DWORD                       rva;
    int                         nDebugDirs;
    int                         i;
    int                         l;
    BOOL                        rVal = FALSE;

    nDebugDirs = pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                 sizeof(IMAGE_DEBUG_DIRECTORY);

    if (!nDebugDirs) {
        return FALSE;
    }

    rva = pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

    for (i = 0; i < pNtHdr->FileHeader.NumberOfSections; i++) {
        if (rva >= pSH[i].VirtualAddress
          && rva < pSH[i].VirtualAddress + pSH[i].SizeOfRawData)
        {
            break;
        }
    }

    if (i >= pNtHdr->FileHeader.NumberOfSections) {
        return FALSE;
    }

    //
    // this is a pointer in the debuggee image:
    //
    if (pldd->hFile == 0) {
        pDebugDir = (PIMAGE_DEBUG_DIRECTORY)
                    ((rva - pSH[i].VirtualAddress) + pSH[i].VirtualAddress);
    } else {
        pDebugDir = (PIMAGE_DEBUG_DIRECTORY)
                    (rva - pSH[i].VirtualAddress + pSH[i].PointerToRawData);
    }

    for (i = 0; i < nDebugDirs; i++) {

        SetReadPointer((ULONG)(&pDebugDir[i]), FILE_BEGIN);
        DoRead((LPV)&DebugDir, sizeof(DebugDir));

        if (DebugDir.Type == IMAGE_DEBUG_TYPE_MISC) {

            l = DebugDir.SizeOfData;
            pMisc = pT = MHAlloc(l);

            if (pldd->hFile == 0) {
                SetReadPointer((ULONG)DebugDir.AddressOfRawData, FILE_BEGIN);
            } else {
                SetReadPointer((ULONG)DebugDir.PointerToRawData, FILE_BEGIN);
            }

            DoRead((LPV)pMisc, l);

            while (l > 0) {
                if (pMisc->DataType != IMAGE_DEBUG_MISC_EXENAME) {
                    l -= pMisc->Length;
                    if (l > (int)DebugDir.SizeOfData) {
                        l = 0; // Avoid AV on bad exe
                        break;
                    }
                    pMisc = (PIMAGE_DEBUG_MISC)
                                (((LPSTR)pMisc) + pMisc->Length);
                } else {

                    PVOID pExeName;

                    pExeName = (PVOID)&pMisc->Data[ 0 ];

#if !defined(_UNICODE)
                    if (!pMisc->Unicode) {
                        _tcscpy(lpName, (LPSTR)pExeName);
                        rVal = TRUE;
                    } else {
                        WideCharToMultiByte(CP_ACP,
                                            0,
                                            (LPWSTR)pExeName,
                                            -1,
                                            lpName,
                                            cbName,
                                            NULL,
                                            NULL);
                        rVal = TRUE;
                    }
#else
                    if (pMisc->Unicode) {
                        wcscpy(lpName, (LPTSTR)pExeName);
                        rVal = TRUE;
                    } else {
                        MultiByteToWideChar(CP_ACP,
                                            0,
                                            (LPTSTR)pExeName,
                                            -1,
                                            lpName,
                                            cbName);
                        rVal = TRUE;
                    }
#endif
                    if (_ftcsicmp(&lpName[_ftcslen(lpName)-4], _T(".DBG")) == 0) {
                        TCHAR    rgchPath[_MAX_PATH];
                        TCHAR    rgchBase[_MAX_FNAME];

                        _tsplitpath(lpName, NULL, rgchPath, rgchBase, NULL);
                        if (_ftcslen(rgchPath)==4) {
                            rgchPath[_ftcslen(rgchPath)-1] = 0;
                            _ftcscpy(lpName, rgchBase);
                            _ftcscat(lpName, _T("."));
                            _ftcscat(lpName, rgchPath);
                        } else {
                            _ftcscpy(lpName, rgchBase);
                            _ftcscat(lpName, _T(".exe"));
                        }
                    }
                    break;
                }
            }

            MHFree(pT);

            break;

        }
    }

    return rVal;
}


BOOL
GetModnameFromExportTable(
    PIMAGE_NT_HEADERS       pNtHdr,
    PIMAGE_SECTION_HEADER   pSH,
    LOAD_DLL_DEBUG_INFO   * pldd,
    LPTSTR                  lpName,
    int                     cbName
    )
/*++

Routine Descriotion:

    This routine attempts to invent an exe name for a DLL
    from the module name found in the export table.  This
    will fail if there is no export table, so it is not
    usually useful for EXEs.

Arguments:

    pNtHdr  - Supplies pointer to NT header in image PE header

    pSH     - Supplies pointer to section header table

    pldd    - Supplies ptr to info record from debug event

    lpName  - Returns name when successful

    cbName  - Supplies size of buffer at lpName

Return Value:

    TRUE if successful and name is copied to lpName, FALSE
    if not successful.

--*/
{
    IMAGE_EXPORT_DIRECTORY      expDir;
    ULONG                       ExportVA;
    ULONG                       oExports;
    int                         iobj;
    int                         cobj;

    /*
     * Find object which has the same RVA as the
     * export table.
     */

    cobj = pNtHdr->FileHeader.NumberOfSections;

    ExportVA = pNtHdr->
                OptionalHeader.
                 DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
                  VirtualAddress;

    if (!ExportVA) {
        return FALSE;
    }

    for (iobj=0; iobj<cobj; iobj++) {
        if (pSH[iobj].VirtualAddress == ExportVA) {
            oExports = pSH[iobj].PointerToRawData;
            break;
        }
    }

    if (iobj >= cobj) {
        return FALSE;
    }

    if (  (SetReadPointer(oExports, FILE_BEGIN) == -1L)
       || !DoRead(&expDir, sizeof(expDir)) ) {

        return FALSE;
    }

    SetReadPointer(oExports + (ULONG) expDir.Name - ExportVA,
                   FILE_BEGIN);

    _ftcscpy(lpName, _T("#:\\"));

    if (!DoRead(lpName+3, cbName - 3)) {
        // It's a DLL, but we can't get the name...
        _stprintf(lpName+3, _T("DLL%02d.DLL"), ++iTemp1);
    }

    return TRUE;
}

BOOL
GetModNameUsingPsApi(
    HTHDX hthd,
    LOAD_DLL_DEBUG_INFO *pldd,
    LPTSTR              lpName,
    int                 cbName
    )
/*++

Routine Descriotion:

    This routine attempts to get the fullpathname for a DLL
    by calling an entry point in psapi.dll.  This
    will fail on Win95

Arguments:

    hthd    - Ptr to the current thread structure.
    pldd    - Supplies ptr to info record from debug event

    lpName  - Returns name when successful

    cbName  - Supplies size of buffer at lpName

Return Value:

    TRUE if successful and name is copied to lpName, FALSE
    if not successful.

--*/
{
    BOOL fRet = FALSE;

#if 0
    if ( IsChicago( ) ) {
        return FALSE;
    }
#endif

	_asm int 3

    if (hModPsapi == NULL && !fAttemptedLoadingPsapi) {
        fAttemptedLoadingPsapi = TRUE;
        if ((hModPsapi = LoadLibrary("psapi.dll")) != NULL) {
	        pFnGetModuleFileNameExA = (LPFNGETNAME)GetProcAddress(hModPsapi, "GetModuleFileNameExA");
        }		
    }

    if (pFnGetModuleFileNameExA != NULL) {

        if ( (*pFnGetModuleFileNameExA) (  hthd->hprc->rwHand,
                            (HMODULE)pldd->lpBaseOfDll, /* Same as hModule */
                            lpName,
                            cbName )
            )
        {
            fRet = TRUE;
        }
    }

    return fRet;
}



#ifdef INTERNAL
void
DeferIt(
    HTHDX       hthd,
    DEBUG_EVENT *pde
    )
{
    PDLL_DEFER_LIST pddl;
    PDLL_DEFER_LIST *ppddl;

    pddl = MHAlloc(sizeof(DLL_DEFER_LIST));
    pddl->next = NULL;
    pddl->LoadDll = pde->u.LoadDll;
    for (ppddl = &hthd->hprc->pDllDeferList; *ppddl; ) {
         ppddl = & ((*ppddl)->next);
    }
    *ppddl = pddl;
}
#endif  // INTERNAL

/*** FFilesIdentical
 *
 * PURPOSE:
 *      Determine whether a filename and a file handle refer to the same file.
 *
 * INPUT:
 *      szFilename: a filename
 *      hFile: a file handle
 *
 * OUTPUT:
 *      Returns TRUE if these refer to the same file.
 */

BOOL
FFilesIdentical(
    LPTSTR szFileName,
    HANDLE hFile
    )
{
    HANDLE  hFile2;
    BY_HANDLE_FILE_INFORMATION bhfi1, bhfi2;
    BOOL fIdentical = FALSE;

    hFile2 = CreateFile(szFileName, GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile2 != INVALID_HANDLE_VALUE)
    {
        if (GetFileInformationByHandle(hFile , &bhfi1) &&
            GetFileInformationByHandle(hFile2, &bhfi2))
        {
            if (bhfi1.dwVolumeSerialNumber == bhfi2.dwVolumeSerialNumber &&
                bhfi1.nFileIndexHigh       == bhfi2.nFileIndexHigh &&
                bhfi1.nFileIndexLow        == bhfi2.nFileIndexLow)
            {
                fIdentical = TRUE;
            }
        }

        VERIFY(CloseHandle(hFile2));
    }

    return fIdentical;
}

/*** FINDMODULE
 *
 * PURPOSE:
 *      Find a module (DLL or EXE) on the path.
 *
 * INPUT:
 *      szModName   Buffer with the name of a module, e.g. "FOO.EXE",
 *                  "BAR.DLL", etc.  May have mixed case.
 *      cchModName  Length of buffer szModName.
 *
 * OUTPUT:
 *      szModName   Replaced with a more specific (but not necessarily
 *                  canonical) path to the module, e.g.
 *                  "C:\NT\SYSTEM\FOO.EXE", "MYDIR\BAR.DLL", if the
 *                  module can be found.  If it can't be found or
 *                  there isn't enough space in the buffer, the buffer
 *                  is left unchanged.
 *
 ********************************************************************/

BOOL
FindModule(
    LPTSTR szModName,
    UINT cchModName
    )
{
    LPTSTR pSlash;
    LPTSTR szFullPath = (LPTSTR)_alloca( cchModName*sizeof(TCHAR) );

    /*
    ** We call SearchPath which is a convenient way to
    ** find a file along the path that Windows uses to load a DLL.
    ** REVIEW: BUG: In order to find the DLL correctly, the call to
    ** SearchPath must be made with the Current Directory set to the
    ** Current Directory of the process that has just loaded the DLL.
    */
    DWORD result = SearchPath( NULL, szModName, NULL, cchModName, szFullPath, &pSlash );
    if ( (result!=0) && (result!=cchModName) )
    {
        _tcscpy( szModName, szFullPath );
        return TRUE;
    }

    return(FALSE);
}

/*** GetNTDebugModuleFileNameLastChance
 *
 * PURPOSE:
 *      Do the best job we can of getting a filename for an EXE or DLL
 *      which has just been loaded.  There is no good way to do this under
 *      NT, so we kludge around a lot.  For EXEs, we saved the name of
 *      the EXE we started before starting it.  For DLLs, we look in the
 *      export table of the DLL for its name, which may or may not be
 *      correct.
 *
 * INPUT:
 *      hProcess    Handle to the process in question (either the
 *                  process which has just started, or the process
 *                  for which a DLL has just been loaded)
 *      hFile       Handle to disk file for the EXE or DLL
 *      lpBaseOfImage   Address in hProcess's address space of the
 *                  beginning of the newly loaded EXE or DLL
 *      cchModName  Size of szModName
 *
 * OUTPUT:
 *      szModName   Buffer where module name (possibly with path)
 *                  is written
 *
 ********************************************************************/

BOOL
FGetNTFileName (
    HTHDX           hthd,
    PDLLLOAD_ITEM   pdll,
    HANDLE          hFile,
    LPTSTR          szModName,
    UINT            cchModName
    )
{
    BOOL fRet = FindModule(szModName, cchModName);

    /* If this isn't the right filename, keep looking ... */
    if (FFilesIdentical(szModName, hFile)) {
        fRet = TRUE;
    } else {
        /* Try to determine the filename from the handle, by whatever
        ** means available
        */
#if 1
        fRet = FALSE;
#else
        if (!FTrojanGetDebugModuleFileName(hthd, pdll, szModName, cchModName))
        {
            /* We shouldn't get here!  We've got to do everything
            ** we possibly can to get the filename, because if we don't
            ** get the filename, we'll have major problems later on.
            ** If we ever hit the assertion, we've just got to come up
            ** with some other ways to try to determine the filename.
            */
            assert(FALSE);
        } else {
            fRet = TRUE;
        }
#endif
    }
    return(fRet);
}


/*** FIXCASE
 *
 * PURPOSE:
 *      Fix the upper/lower case of a filename so that it matches what
 *      is on disk.  If the disk in question supports mixed-case
 *      filenames, we change the name we have to match the case of the
 *      name on disk; otherwise, we set the name to lower case (because
 *      that's prettier than upper case).
 *
 * INPUT:
 *      szFilename  Name of file.
 *
 * OUTPUT:
 *      szFilename  Upper/lower case changed.
 *
 ********************************************************************/

VOID
FixCase(
    LPTSTR szFilename
    )
{

#ifdef WIN32

    TCHAR           rgchDrive[4];   /* "X:\" */
    LPTSTR          szDrive;
    DWORD           dwFlags;
    WIN32_FIND_DATA wfd;
    LPTSTR          pch;
    LPTSTR          pchStart;
    TCHAR           ch;
    HANDLE          hSearch;

    if (szFilename[0] && szFilename[1] == _T(':')) {
        _stprintf(rgchDrive, _T("%c:\\"), szFilename[0]);
        szDrive = rgchDrive;
    }
    else {
        szDrive = NULL;
    }

    if (GetVolumeInformation(szDrive, NULL, 0, NULL, NULL, &dwFlags, NULL, 0)
        &&
        (dwFlags & FS_CASE_IS_PRESERVED)
        ) {

        /*
        ** For each filename component, check what case it has on disk.
        */
        pch = szFilename;

        if (pch[0] && pch[1] == _T(':')) {  /* path has drive letter?   */
            *pch = (TCHAR)_totupper ( *pch );       /* upper case drive letter  */
            pch += 2;
        }

        if (*pch == _T('/') || *pch == _T('\\')) {
            *pch = _T('\\');
            ++pch;
        }

        while (*pch) {

            pchStart = pch;

            while (*pch && *pch != _T('\\') && *pch != _T('/')) {
                pch = _tcsinc( pch );
            }

            ch = *pch;
            *pch = _T('\0');

            /*
            ** Find this filename component
            */
            hSearch = FindFirstFile(szFilename, &wfd);

            /*
            ** If the search failed, or if it returned a name of a
            ** different length than the one we asked for (e.g. we
            ** asked for "FOO." and it gave us "FOO"), we'll give
            ** up and convert the rest of the name to lower case
            */
            if (hSearch == INVALID_HANDLE_VALUE ||
                _ftcslen(pchStart) != _ftcslen(wfd.cFileName)) {
                *pch = ch;
                _ftcslwr ( pchStart );
                return;
            }

            /*
            ** Copy the correct case into our filename
            */
            _tcscpy ( pchStart, wfd.cFileName );

            /*
            ** Close the search
            */
            assert ( !FindNextFile(hSearch, &wfd) );
            VERIFY(FindClose ( hSearch ));

            /*
            ** Restore the slash or NULL
            */
            *pch = ch;

            /*
            ** If we're on a separator, move to next filename component
            */
            if (*pch) {
                *pch = _T('\\');
                pch++;
            }
        }

        return;
    }

#endif

    /*
    ** Convert to lower case, with backslashes
    */

    _ftcslwr(szFilename);

    for (; *szFilename; szFilename = _tcsinc( szFilename) ) {
        if (*szFilename == _T('/')) {
            *szFilename = _T('\\');
        }
    }
}

void
FixFilename(
    TCHAR *szTempFilename,
    const TCHAR *szInFilename
    )
/*++

/*** FIXFILENAME
 *
 * PURPOSE:
 *      Fix the upper/lower case of a filename and so that it matches what
 *      is on disk.  Also if we have a 8.3 name for a long filename
 *      convert the whole path to its long filename equivalen.
 *      If the disk in question supports mixed-case
 *      filenames, we change the name we have to match the case of the
 *      name on disk; otherwise, we set the name to lower case (because
 *      that's prettier than upper case).
 *
 * INPUT:
 *      szInFilename  Name of file. .
 *
 * OUTPUT:
 *      szTempFilename  Upper/lower case changed, long filename variant.
 *                      Assumes size is big enough to hold long
 *                  filename
 *
 * Note: Win95 has an API to do this (called via an int 31h or somesuch),
 * but NT has no such API. Why? To make everyone go through this pain I guess.
 *
 ********************************************************************/

{
    CHAR            rgchDrive[4];   /* "X:\" */
    CHAR *          szDrive;
    DWORD           dwFlags;
    WIN32_FIND_DATA wfd;
    CHAR *          pch;
    CHAR *          pchTemp;
    CHAR *          pchStart;
    CHAR            ch;
    HANDLE          hSearch;
    CHAR            szFilename[512];

    _tcscpy( szFilename, szInFilename );                // make local copy

    if (szFilename[0] && szFilename[1] == ':') {
        sprintf(rgchDrive, "%c:\\", szFilename[0]);
        szDrive = rgchDrive;
    }
    else {
        szDrive = NULL;
    }

    if (GetVolumeInformation(szDrive, NULL, 0, NULL, NULL, &dwFlags, NULL, 0)
        &&
        (dwFlags & FS_CASE_IS_PRESERVED)
        ) {

        /*
        ** For each filename component, check what case it has on disk.
        */
        pch = szFilename;
        pchTemp = szTempFilename;

        if (pch[0] && pch[1] == ':') {  /* path has drive letter?   */
            _tcsncpy(pchTemp, pch, 2);

            /* upper case drive letter  */
            *pchTemp = (char) CharUpper ( (LPTSTR)(unsigned long)(unsigned char)(*pchTemp) );       /* upper case drive letter  */
            pch += 2;
            pchTemp += 2;
        }

        if (*pch == '/' || *pch == '\\') {
            *pch = *pchTemp = '\\';
            ++pchTemp;
            ++pch;
        }

        while (*pch) {
            size_t iLen;

            pchStart = pch;

            while (*pch && *pch != '\\' && *pch != '/')
                pch = _tcsinc( pch );

            ch = *pch;
            *pch = '\0';

            /*
            ** Find this filename component
            */
            hSearch = FindFirstFile(szFilename, &wfd);

            /*
            ** If the search failed, we'll give
            ** up and convert the rest of the name to lower case
            */
            if (hSearch == INVALID_HANDLE_VALUE )
            {
                *pch = ch;
                CharLower ( pchStart );
                // Copy over the rest of the filename to the temporary buffer.
                // this will now have the best we can do about converting
                // this filename.
                _tcscpy(pchTemp, pchStart);

                _tcscpy(szFilename, szTempFilename);

                return;
            }

            /*
            ** Copy the correct name into the temp filename,
            */
            iLen = _tcslen(wfd.cFileName);
            _tcsncpy ( pchTemp, wfd.cFileName, iLen );
            pchTemp += iLen;

            /*
            ** Close the search
            */
            assert ( !FindNextFile(hSearch, &wfd) );
            FindClose ( hSearch );

            /*
            ** Restore the slash or NULL
            */
            *pch = ch;

            /*
            ** If we're on a separator, move to next filename component
            */
            if (*pch) {
                *pchTemp = *pch = '\\';
                pch++; pchTemp++;
            }
        }

        *pchTemp = '\0';
    }
    else
        _tcscpy(szTempFilename, szFilename );           // just copy it if not case sensitive
}


void
FixupDebugImage(
	IN OUT TCHAR*	ImageBuffer
	)
/*++

Routine Description:

	This routine fixes up an image name of the form xxx\image.dbg to be
	image.xxx or -- the more common case -- dll\image.dbg to be image.dll.

	The prefix (xxx above) must be three characters.  If it is not, we will
	not match it.  The path also must be relative or we will not match.

Comments:

	This seems pretty hokey, but we really go to the ends of the earth to
	try and find the real image name.

--*/
{
	TCHAR*	pch = NULL;
	TCHAR*	pchT = NULL;
	TCHAR	bufferT [10];
	int		len;
	
	pch = _tcsrchr (ImageBuffer, '.');

	if (pch && _tcsicmp (pch, _T (".dbg")) == 00) {

		//
		// check if it is of the form "xxx\foo.dbg"
		//

		pchT = ImageBuffer;

		pchT = _tcsinc (pchT);
		pchT = _tcsinc (pchT);
		pchT = _tcsinc (pchT);
		
		if (*pchT == '\\') {
			len = pchT - ImageBuffer;
			memcpy (bufferT, ImageBuffer, len);
			bufferT [len] = '\000';

			pchT = _tcsinc (pchT);
			_tcscpy (ImageBuffer, pchT);
			pch = _tcsrchr (ImageBuffer, '.');
			pch = _tcsinc (pch);
			memcpy (pch, bufferT, len);
		}
	}

}
			
	
#ifdef OMNI
typedef struct DMOmniClass {
	DWORD	cSections;
	BOOL	fEnabled;
	DWORD	cbJITMaps;
	OmniSectionMapRecord *pSectionMap;
}  DMOmniClass;

__inline DWORD DMOmniPVOffset(DMOmniClass *this, DWORD i)
{
	assert (i < this->cSections);
	return (this->pSectionMap + i)->pvBase;
}
__inline DWORD DMOmniRVAOffset(DMOmniClass *this, DWORD i)
{
	assert (i < this->cSections);
	return (this->pSectionMap + i)->rvaBase;
}
__inline DWORD DMOmniCbSizeOfSection(DMOmniClass *this, DWORD i)
{
	assert (i < this->cSections);
	return (this->pSectionMap + i)->cb;
}
__inline LPVOID DMOmniPJITMap(DMOmniClass *this, DWORD i) 
{
	assert (i < this->cSections);
	return (this->pSectionMap + i)->pJITFixupMap;
}
__inline VOID DMOmniCopyJITMaps(DMOmniClass *this, BYTE* pb)
{
	DWORD i;
	for (i=0; i < this->cSections; i++)
	{
		if ((this->pSectionMap + i)->pJITFixupMap)
		{
			_fmemcpy(pb , (this->pSectionMap + i)->pJITFixupMap, (this->pSectionMap + i)->cb);
			pb += (this->pSectionMap + i)->cb;
		}
	}
}

void DMOmniClassInit(DMOmniClass * this, HPRCX hprc, PVOID pOmniAddrMapIn)
{
	OmniAddrMap OAM;
	if (pOmniAddrMapIn) 
	{
		DWORD cbSectionMap;	 
		DWORD i;
		PVOID pv;

		this->cbJITMaps = 0;

		if (!DbgReadMemory( hprc, (PVOID)pOmniAddrMapIn, (PVOID)&(OAM), sizeof(OmniAddrMap), NULL))
		{
			goto errExit;
		}

		this->cSections = OAM.cSection;
		cbSectionMap = this->cSections * sizeof(OmniSectionMapRecord);

		if (!(this->pSectionMap = (OmniSectionMapRecord *) MHAlloc(cbSectionMap)))
			goto errExit;

		if (!DbgReadMemory( hprc, (PVOID)(OAM.rgSectionMap), (PVOID)(this->pSectionMap), cbSectionMap, NULL))
		{
			goto errExit;
		}

		for (i = 0; i < this->cSections; i++)
		{
			if (this->pSectionMap[i].pJITFixupMap && this->pSectionMap[i].pJITBase) 
			{
				DWORD *pdw;
				PVOID *pv;
				if (!(pv = MHAlloc(this->pSectionMap[i].cb)))
				{
					goto errExit;
				}
				if (!DbgReadMemory(hprc, (PVOID)(this->pSectionMap[i].pJITFixupMap),
					pv, this->pSectionMap[i].cb, NULL)) 
				{
					goto errExit;
				}
				this->pSectionMap[i].pJITFixupMap = pv;
				// add JITBase address to jit map offsets
				for (pdw = (DWORD *) pv;
					(char *)pdw < (char *)pv + this->pSectionMap[i].cb;
					pdw++)
				{
					//preserve zero entries (except for the first entry)
					//these are in the middle of a bytecode instructions > 4 bytes
					if (*pdw || (pdw == (DWORD *)pv))
						*pdw += (DWORD)(this->pSectionMap[i].pJITBase);
				}
				this->cbJITMaps += this->pSectionMap[i].cb;
			}
		}
		this->fEnabled = TRUE;
		return;
	}

errExit:
	this->cbJITMaps = 0;
	this->cSections = 0;
	this->pSectionMap = 0;
	this->fEnabled = FALSE;
}

void DMOmniClassClose(DMOmniClass *this)
{
	DWORD i;

	// free up any jit maps
	for (i=0; i < this->cSections; i++)
	{
		if ((this->pSectionMap + i)->pJITFixupMap)
			MHFree((this->pSectionMap + i)->pJITFixupMap);
	}

	if (this->pSectionMap) MHFree(this->pSectionMap);

}


BOOL
LoadDll5Parm(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket,
	LPVOID			pOmniAddrMap
    );

__inline BOOL LoadDll(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket
    )
{
	return LoadDll5Parm(de, hthd, lpcbPacket, lplpbPacket, NULL);
}

BOOL
LoadDll5Parm(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket,
	LPVOID			pOmniAddrMap
    )
#else
BOOL
LoadDll(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket
    )
#endif
/*++

Routine Description:

    This routine is used to load the signification information about
    a PE exe file.  This information consists of the name of the exe
    just loaded (hopefully this will be provided later by the OS) and
    a description of the sections in the exe file.

Arguments:

    de         - Supplies a pointer to the current debug event

    hthd       - Supplies a pointer to the current thread structure

    lpcbPacket - Returns the count of bytes in the created packet

    lplpbPacket - Returns the pointer to the created packet

Return Value:

    True on success and FALSE on failure

--*/

{
    LOAD_DLL_DEBUG_INFO *       ldd = &de->u.LoadDll;
    LPMODULELOAD                lpmdl;
    TCHAR                       szModName[512];
    TCHAR                       szAnsiName[512];
    DWORD                       offset, cbObject;
    DWORD                       lenSz, lenTable;
    DWORD                       cobj, iobj;
    DWORD                       isecTLS;
    IMAGE_DOS_HEADER            dosHdr;
    IMAGE_NT_HEADERS            ntHdr;
    IMAGE_SECTION_HEADER *      rgSecHdr = NULL;
    HANDLE                      hFile;
    int                         iDll;
    HPRCX                       hprc = hthd->hprc;
    DWORD                       cb;
    TCHAR                       rgch[512];
    LPVOID                      lpv;
    LPTSTR                      lpsz;
    ADDR                        addr;
    BOOL                        fTlsPresent;
    OFFSET                      off;
    TCHAR                       fname[_MAX_FNAME];
    TCHAR                       ext[_MAX_EXT];
#ifdef OMNI
	DMOmniClass DMOmni;
#endif


	_asm int 3

    if ( hprc->pstate & (ps_killed | ps_dead) ) {
        //
        //  Process is dead, don't bother doing anything.
        //
        return FALSE;
    }

#ifdef OMNI
	DMOmniClassInit (&DMOmni, hprc, pOmniAddrMap);
#endif

    //
    //  Create an entry in the DLL list and set the index to it so that
    //  we can have information about all DLLs for the current system.
    //
    for (iDll=0; iDll<hprc->cDllList; iDll+=1) {
        if ((hprc->rgDllList[iDll].offBaseOfImage == (DWORD)ldd->lpBaseOfDll) ||
            (!hprc->rgDllList[iDll].fValidDll)) {
            break;
        }
    }

    if (iDll == hprc->cDllList) {
        //
        // the dll list needs to be expanded
        //
        hprc->cDllList += 10;
        if (!hprc->rgDllList) {
            hprc->rgDllList = (PDLLLOAD_ITEM) MHAlloc(sizeof(DLLLOAD_ITEM) * 10);
            memset(hprc->rgDllList, 0, sizeof(DLLLOAD_ITEM)*10);
        } else {
            hprc->rgDllList = MHRealloc(hprc->rgDllList,
                                  hprc->cDllList * sizeof(DLLLOAD_ITEM));
            memset(&hprc->rgDllList[hprc->cDllList-10], 0, 10*sizeof(DLLLOAD_ITEM));
        }
    } else if (hprc->rgDllList[iDll].offBaseOfImage != (DWORD)ldd->lpBaseOfDll) {
        memset(&hprc->rgDllList[iDll], 0, sizeof(DLLLOAD_ITEM));
    }

    //
    // stick the demarcator at the start of the string so that we
    // don't have to move the string over later.
    //
    *szModName = cModuleDemarcator;

    //
    //   Process the DOS header.  It is currently regarded as mandatory
    //
    //   This has to be read before attempting to resolve the
    //   name of a module on NT.  If the name resolution is aborted,
    //   the memory allocated for the IMAGE_SECTION_HEADER must be
    //   freed.
    //
again:
    if (ldd->hFile == 0) {
        SetPointerToMemory(hprc, ldd->lpBaseOfDll);
    } else {
        SetPointerToFile(ldd->hFile);
    }

    SetReadPointer(0, FILE_BEGIN);

    if (DoRead(&dosHdr, sizeof(dosHdr)) == FALSE) {
		if ( (ldd->hFile!=0) && (ldd->hFile!=INVALID_HANDLE_VALUE) ) {
			// bad handle from OS, fallback to reading DLL from memory
			CloseHandle(ldd->hFile);
			ldd->hFile = 0;
			goto again;
		}
        DPRINT(1, (_T("ReadFile got error %u\r\n"), GetLastError()));
        goto exitFalse;
    }

    //
    //  Read in the PE header record
    //

    if ((dosHdr.e_magic != IMAGE_DOS_SIGNATURE) ||
        (SetReadPointer(dosHdr.e_lfanew, FILE_BEGIN) == -1L)) {
        goto exitFalse;
    }

    if (!DoRead(&ntHdr, sizeof(ntHdr))) {
        goto exitFalse;
    }

    //
    //      test whether we have a TLS directory
    //
    fTlsPresent = !!ntHdr.OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_TLS ].Size;

    if (sizeof(ntHdr.OptionalHeader) != ntHdr.FileHeader.SizeOfOptionalHeader) {
        SetReadPointer(ntHdr.FileHeader.SizeOfOptionalHeader -
                       sizeof(ntHdr.OptionalHeader), FILE_CURRENT);
    }

#ifdef OMNI
	if (DMOmni.fEnabled)
	{
		cobj = DMOmni.cSections;
	}
	else
#endif
	{
		//
		//   Save off the count of objects in the dll/exe file
		//
		cobj = ntHdr.FileHeader.NumberOfSections;
        
		//
		//   Save away the offset in the file where the object table
		//   starts.  We will need this later to get information about
		//   each of the objects.
		//
		rgSecHdr = (IMAGE_SECTION_HEADER *) MHAlloc( cobj * sizeof(IMAGE_SECTION_HEADER));
		if (!DoRead( rgSecHdr, cobj * sizeof(IMAGE_SECTION_HEADER))) {
		    assert (FALSE );
			MHFree(rgSecHdr);
			goto exitFalse;
		}
	}



    if (hprc->rgDllList[iDll].offBaseOfImage == (DWORD)ldd->lpBaseOfDll) {

        //
        // in this case we are re-doing a mod load for a dll
        // that is part of a process that is being reconnected
        //
        assert( hprc->rgDllList[iDll].szDllName != NULL );
        _ftcscpy( szModName + 1, hprc->rgDllList[iDll].szDllName );

    } else {


        if (CrashDump) {
            _ftcscpy( szModName+1, ldd->lpImageName );

			FixupDebugImage (szModName + 1);

			
        } else if ((ldd->lpImageName != NULL)
            && DbgReadMemory(hprc,
                             ldd->lpImageName,
                             &lpv,
                             sizeof(lpv),
                             (int *) &cb)
            && (cb == sizeof(lpv))
            && (lpv != NULL)
            && DbgReadMemory(hprc,
                             lpv,
                             rgch,
                             sizeof(rgch),
                             (int *) &cb))
        {

            // we're happy...
#if !defined(_UNICODE)
            if (!ldd->fUnicode) {
                FixFilename(szModName+1, rgch );
            } else {
                WideCharToMultiByte(CP_ACP,
                                    0,
                                    (LPWSTR)rgch,
                                    -1,
                                    szAnsiName,
                                    _tsizeof(szAnsiName),
                                    NULL,
                                    NULL);
                FixFilename(szModName + 1, szAnsiName );
			}
            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(szModName+1) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, szModName+1);
            } else {
				goto exitFalse;
            }
#else
            if (ldd->fUnicode) {
                FixFilename(szModName+1, rgch );
            } else {
                MultiByteToWideChar(CP_ACP,
                                    0,
                                    (LPTSTR)rgch,
                                    -1,
                                    szAnsiName,
                                    _tsizeof(szAnsiName));
                FixFilename(szModName + 1, szAnsiName );
                if ((hprc->rgDllList[iDll].szDllName = MHAlloc((_tcslen(szModName+1) + 1)) * sizeof(TCHAR)) != NULL)
                {
                    _tcscpy(hprc->rgDllList[iDll].szDllName, szModName+1);
                } else {
					goto exitFalse;
                }
            }
#endif

        }

        else {
#ifdef OMNI
			assert(!DMOmni.fEnabled);
#endif
			if (*nameBuffer) {

            /*
             *      If *nameBuffer != 0 then we know we are really
             *      dealing with the root exe and we can steal the
             *      name from there.
             */

            if (FDMRemote) {
                _tsplitpath( nameBuffer, NULL, NULL, fname, ext );
                sprintf( szModName+1, _T("#:\\%s%s"), fname, ext );
            } else {
                _tcscpy(szModName + 1, nameBuffer);     // do NOT FixFilename this one
            }

            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(szModName+1) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, szModName+1);
            } else {
			     goto exitFalse;
            }

        } else if (GetModNameUsingPsApi(hthd, ldd, rgch, _tsizeof(rgch))) {
            // cool...
            FixFilename(szModName + 1, rgch);
            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(szModName+1) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, szModName+1);
            }
            else
            {
			     goto exitFalse;
            }
        } else if (GetModnameFromImage(&ntHdr, rgSecHdr, ldd, rgch, _tsizeof(rgch))) {

            // joyful...
            lpsz = _ftcsrchr(rgch, _T('\\'));
            if (!lpsz) {
                lpsz = _ftcsrchr(rgch, _T(':'));
            }
            if (lpsz) {
                lpsz = _ftcsinc(lpsz);
            } else {
                lpsz = rgch;
            }
#if defined(DOLPHIN)
            if (FGetNTFileName(hthd, &hprc->rgDllList[iDll], ldd->hFile, rgch, _tsizeof(rgch))) {
                _ftcscpy(szModName + 1, rgch);
            }
                        else
#endif
            {
                _ftcscpy(szModName + 1, _T("#:\\"));
                _ftcscpy(szModName + 4, lpsz);
            }

            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(lpsz) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, lpsz);
            }
            else
            {
				goto exitFalse;
            }

        } else if (GetModnameFromExportTable(&ntHdr, rgSecHdr, ldd, rgch, _tsizeof(rgch))) {

            // serene...
            _ftcscpy(szModName + 1, rgch);
            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(rgch) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, rgch);
            }
            else
            {
			     goto exitFalse;
            }

        } else {

            // hopeless...
#if defined(DOLPHIN)
            if (!LoadString(hInstance, IDS_UnknownExe, rgch, _tsizeof(rgch))) {
                assert(FALSE);
            }
            if (FGetNTFileName(hthd, &hprc->rgDllList[iDll], ldd->hFile, rgch, _tsizeof(rgch))) {
                _ftcscpy(szModName + 1, rgch);
            } else
#endif
            sprintf(szModName+1, _T("#:\\APP%02d.EXE"), ++iTemp1);
            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(szModName + 1) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, szModName + 1);
            }
            else
            {
		        goto exitFalse;
            }
        }
		}

        *nameBuffer = 0;
    }

    //
    // for remote case, kill the drive letter to
    // prevent finding same exe on wrong platform,
    // except when user gave path to exe.
    //
    if (fUseRealName) {
        fUseRealName = FALSE;
    }
    lenSz=_ftcslen(szModName);
    DPRINT(10, (_T("*** LoadDll %s  base=%x\n"), szModName, ldd->lpBaseOfDll));

    szModName[lenSz] = 0;

    lpsz = _ftcsrchr(szModName, _T('\\'));
    if (!lpsz) {
        lpsz = _ftcsrchr(szModName, _T(':'));
    }
    if (lpsz) {
        lpsz = _ftcsinc(lpsz);
    } else {
        lpsz = szModName;
    }

    if (_ftcsicmp(lpsz, _T("kernel32.dll")) == 0) {
        hprc->dwKernel32Base = (DWORD)ldd->lpBaseOfDll;
    }

    if (hprc->rgDllList[iDll].offBaseOfImage != (DWORD)ldd->lpBaseOfDll) {
        //
        // new dll to add to the list
        //
        hprc->rgDllList[iDll].fValidDll = TRUE;
        hprc->rgDllList[iDll].offBaseOfImage = (OFFSET) ldd->lpBaseOfDll;
        hprc->rgDllList[iDll].cbImage = ntHdr.OptionalHeader.SizeOfImage;
    }

    //
    //  Find address of OLE RPC tracing export (if any)
    //

    //
    // If hFile is NULL, we can not do any RPC debugging. This may happen in
    // certain platforms. So, check for this.
    
    if (ldd->hFile != NULL) {
    
        FGetExport (&hprc->rgDllList[iDll],
                    (HFILE)ldd->hFile,
                    _T("DllDebugObjectRPCHook"),
                    &hprc->rgDllList[iDll].lpvOleRpc
                    );
    } else {
    
        hprc->rgDllList[iDll].lpvOleRpc = NULL;
    }

    //DMSqlLoadDll( hprc, ldd, iDll );

    szModName[lenSz] = cModuleDemarcator;

    if (/* FDMRemote */ TRUE ) {
        if (ldd->hFile != 0 && ldd->hFile != (HANDLE)-1) {
            CloseHandle(ldd->hFile);  //  don't need this anymore
        }
        hFile = (HANDLE)-1; // remote: can't send file handle across wire
    } else {

        if (ldd->hFile == 0) {
            hFile = (HANDLE)-1;
        } else {
            hFile = ldd->hFile; // local: let SH use our handle
        }
    }

    /*
     *  Make up a record to send back from the name.
     *  Additionally send back:
     *          The file handle (if local)
     *          The load base of the dll
     *          The time and date stamp of the exe
     *          The checksum of the file
     */

    sprintf( szModName+lenSz+1, _T("0x%08lX%c0x%08lX%c0x%08lX%c0x%08lX%c"),
            ntHdr.FileHeader.TimeDateStamp, cModuleDemarcator,
            ntHdr.OptionalHeader.CheckSum, cModuleDemarcator,
            hFile, cModuleDemarcator,
            (long) ldd->lpBaseOfDll, cModuleDemarcator);
    lenSz = _ftcslen(szModName);
    /*
     * Allocate the packet which will be sent across to the EM.
     * The packet will consist of:
     *     The MODULELOAD structure             sizeof(MODULELOAD) +
     *     The section description array        cobj*sizeof(OBJD) +
     *     The name of the DLL                  lenSz+1
     */

	lenTable = (cobj * sizeof(OBJD));
#ifdef OMNI
    *lpcbPacket = (WORD)(sizeof(MODULELOAD) + lenTable + (lenSz+1) * sizeof(TCHAR) +
		DMOmni.cbJITMaps);
#else
    *lpcbPacket = (WORD)(sizeof(MODULELOAD) + lenTable + (lenSz+1) * sizeof(TCHAR));
#endif
    *lplpbPacket= (LPBYTE)(lpmdl=(LPMODULELOAD)MHAlloc(*lpcbPacket));
    lpmdl->lpBaseOfDll = ldd->lpBaseOfDll;
    lpmdl->cobj = cobj;
    lpmdl->mte = (WORD) -1;
#ifdef OMNI
	lpmdl->fOmniMap = DMOmni.fEnabled;
#endif
#ifdef TARGET_i386
    lpmdl->CSSel    = (unsigned short)hthd->context.SegCs;
    lpmdl->DSSel    = (unsigned short)hthd->context.SegDs;
#else
    lpmdl->CSSel = lpmdl->DSSel = 0;
#endif // i386

    //
    // Set up the descriptors for each of the section headers so that the EM
    // can map between section numbers and flat addresses.
    //

    lpmdl->uoffDataBase = 0;
    
    for (iobj=0; iobj<cobj; iobj++) {
        OLESEG oleseg;

        lpmdl->rgobjd[iobj].wPad = 1;

#ifdef OMNI
		if (DMOmni.fEnabled)
		{
			lpmdl->rgobjd[iobj].offset  = DMOmniPVOffset(&DMOmni, iobj);
			lpmdl->rgobjd[iobj].rvaOffset  = DMOmniRVAOffset(&DMOmni, iobj);
			lpmdl->rgobjd[iobj].cb = DMOmniCbSizeOfSection(&DMOmni, iobj);
			lpmdl->rgobjd[iobj].pOmniJITMap = DMOmniPJITMap(&DMOmni, iobj);
			lpmdl->rgobjd[iobj].wSel = 0;
		}
		else
#endif
		{
#ifdef OMNI
			lpmdl->rgobjd[iobj].pOmniJITMap = NULL;
#endif
			offset = rgSecHdr[iobj].VirtualAddress + (long) ldd->lpBaseOfDll;
			cbObject = rgSecHdr[iobj].Misc.VirtualSize;
			if (cbObject == 0) {
			    cbObject = rgSecHdr[iobj].SizeOfRawData;
			}

			lpmdl->rgobjd[iobj].offset = offset;
			lpmdl->rgobjd[iobj].cb = cbObject;
#if defined(TARGET_i386)

			if (IMAGE_SCN_CNT_CODE & rgSecHdr[iobj].Characteristics) {
			    lpmdl->rgobjd[iobj].wSel = (WORD) hthd->context.SegCs;
			} else {
			    lpmdl->rgobjd[iobj].wSel = (WORD) hthd->context.SegDs;
			}
#else
			lpmdl->rgobjd[iobj].wSel = 0;
#endif  // TARGET_i386

			if (!_fmemcmp( rgSecHdr[iobj].Name, ".data\0\0", IMAGE_SIZEOF_SHORT_NAME)) {
				if (lpmdl->uoffDataBase == 0) {
					lpmdl->uoffDataBase = offset;
				}
			}
        
#if 0
			//
			// If the section is one of the special OLE segments, we keep track
			// of the address ranges in the OLERG structure.
			//
         
			if ((oleseg = GetOleSegType(rgSecHdr[iobj].Name)) != olenone) {
				OLERG*      lpolerg;
				DWORD       i;

				hprc->rgDllList[iDll].fContainsOle = TRUE;

				++hprc->colerg;
				if (hprc->rgolerg) {

				 hprc->rgolerg = MHRealloc(hprc->rgolerg,
				                           hprc->colerg * sizeof(OLERG));

				} else {
            
				 hprc->rgolerg = MHAlloc(hprc->colerg * sizeof(OLERG));
				}

				/* find place to insert new OLE range */

				for (i = 0; i < hprc->colerg - 1; ++i) {
					if (offset < hprc->rgolerg[i].uoffMin) {
						break;
					}
				}

				/* insert an OLERG */
				memmove(&hprc->rgolerg[i+1],
                    &hprc->rgolerg[i],
                    sizeof(OLERG) * (hprc->colerg - i - 1));

				/* insert new OLE range */
				lpolerg = &hprc->rgolerg[i];
				lpolerg->uoffMin   = offset;
				lpolerg->uoffMax   = offset + cbObject;
				lpolerg->segType   = oleseg;

#if 0
				// undef this is you want to see the module names and ranges
				// of the orpc modules
            
				DebugPrint ("dll: %s\n", szModName);

				DebugPrint ("Ole segment: %s %#x - %#x\n",
					rgSecHdr [iobj].Name,
                    lpolerg->uoffMin,
                    lpolerg->uoffMax);
#endif
            
			}

#endif

			if ( fTlsPresent && !_fmemcmp ( rgSecHdr[iobj].Name, ".tls\0\0\0", IMAGE_SIZEOF_SHORT_NAME ) ) {
				isecTLS = iobj + 1;
			}
		}
    }

    lpmdl->fRealMode = FALSE;
    lpmdl->fFlatMode = TRUE;
    lpmdl->fOffset32 = TRUE;
    lpmdl->dwSizeOfDll = ntHdr.OptionalHeader.SizeOfImage;
    lpmdl->uoffiTls = 0;
    lpmdl->isecTLS = 0;
    lpmdl->iTls = 0;       // cache it later on demand if uoffiTls != 0

    /*
     *  Copy the name of the dll to the end of the packet.
     */

    _fmemcpy(((BYTE*)&lpmdl->rgobjd)+lenTable, szModName, lenSz+1);
#ifdef OMNI
	if (DMOmni.fEnabled) 
	{
		DMOmniCopyJITMaps(&DMOmni, ((BYTE*)&lpmdl->rgobjd)+lenTable + lenSz + 1);
	}
#endif

    /*
     *  Locate the TLS section if one exists.  If so then get the
     *      pointer to the TLS index
     *
     *  Structure at the address is:
     *
     *          VA      lpRawData
     *          ULONG   cbRawData
     *          VA      lpIndex
     *          VA      lpCallBacks
     */

     if (ntHdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != 0) {
#ifdef OMNI
		 // cannot support tls debugging in omni as of yet
		 assert(!DMOmni.fEnabled);
#endif
         if ((DbgReadMemory(hprc,
                            ntHdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + (char *) ldd->lpBaseOfDll + 8,
                            &off,
                            sizeof(OFFSET),
                            &cb) == 0) ||
             (cb != sizeof(OFFSET))) {
             assert(FALSE);
         }

         hprc->rgDllList[iDll].offTlsIndex = off;
         lpmdl->uoffiTls = off;
         lpmdl->isecTLS = isecTLS;
     }

    /*
     * free up the memory used for holding the section headers
     */

#ifdef OMNI
	if (!DMOmni.fEnabled)
#endif
		MHFree(rgSecHdr);


    if (fDisconnected) {

        //
        // this will prevent the dm from sending a message up to
        // the shell.  the dm's data structures are setup just fine
        // so that when the debugger re-connects we can deliver the
        // mod loads correctly.
        //

exitFalse:
#ifdef OMNI
		DMOmniClassClose(&DMOmni);
#endif
		return FALSE;

    }

#ifdef OMNI
		DMOmniClassClose(&DMOmni);
#endif
    return TRUE;
}                               /* LoadDll() */

#endif  // !KERNEL
#endif // 0

int
FindTLSSection(
    PDMN_MODLOAD pdmml
    )
{
    IMAGE_DOS_HEADER dosh;
    IMAGE_NT_HEADERS nth;
    int isec;
    DWORD dwSecHdrAddr;
    IMAGE_SECTION_HEADER sh;

    /* Start by getting the DOS header */
    if(FAILED(DmGetMemory(pdmml->BaseAddress, sizeof dosh, &dosh, NULL)))
        return 0;

    /* Verify the signature */
    if(dosh.e_magic != IMAGE_DOS_SIGNATURE)
        return 0;

    /* Get the base NT headers */
    if(FAILED(DmGetMemory((PVOID)((DWORD)pdmml->BaseAddress + dosh.e_lfanew),
            sizeof nth, &nth, NULL)))
        return 0;

    /* Walk the section header list, looking for .tls */
    dwSecHdrAddr = (DWORD)pdmml->BaseAddress + dosh.e_lfanew + sizeof nth +
        nth.FileHeader.SizeOfOptionalHeader - sizeof nth.OptionalHeader;
    for(isec = 0; isec < nth.FileHeader.NumberOfSections; ++isec) {
        if(FAILED(DmGetMemory((PVOID)dwSecHdrAddr, sizeof sh, &sh, NULL)))
            return 0;
        if(0 == _fmemcmp(sh.Name, ".tls\0\0\0", IMAGE_SIZEOF_SHORT_NAME))
            return isec + 1;
        dwSecHdrAddr += sizeof sh;
    }

    /* Didn't find it */
    return 0;
}

BOOL
LoadDll(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket
    )
{
    LOAD_DLL_DEBUG_INFO *       ldd = &de->u.LoadDll;
	PDMN_MODLOAD				pdmml = ldd->hFile;
    LPMODULELOAD                lpmdl;
    TCHAR                       szModName[512];
    DWORD                       offset, cbObject;
    DWORD                       lenSz, lenTable;
    DWORD                       cobj, iobj;
    DWORD                       isecTLS;
    int                         iDll;
    HPRCX                       hprc = hthd->hprc;
    DWORD                       cb;
    LPVOID                      lpv;
    LPTSTR                      lpsz;
    ADDR                        addr;
    OFFSET                      off;
	PDM_WALK_MODSECT			pdmws;
	DMN_SECTIONLOAD				dmsl;
	PDMN_SECTIONLOAD			*rgpdmsl;

    if ( hprc->pstate & (ps_killed | ps_dead) ) {
        //
        //  Process is dead, don't bother doing anything.
        //
        return FALSE;
    }


    //
    //  Create an entry in the DLL list and set the index to it so that
    //  we can have information about all DLLs for the current system.
    //
    for (iDll=0; iDll<hprc->cDllList; iDll+=1) {
        if ((hprc->rgDllList[iDll].offBaseOfImage == (DWORD)ldd->lpBaseOfDll) ||
            (!hprc->rgDllList[iDll].fValidDll)) {
            break;
        }
    }

    if (iDll == hprc->cDllList) {
        //
        // the dll list needs to be expanded
        //
        hprc->cDllList += 10;
        if (!hprc->rgDllList) {
            hprc->rgDllList = (PDLLLOAD_ITEM) MHAlloc(sizeof(DLLLOAD_ITEM) * 10);
            memset(hprc->rgDllList, 0, sizeof(DLLLOAD_ITEM)*10);
        } else {
            hprc->rgDllList = MHRealloc(hprc->rgDllList,
                                  hprc->cDllList * sizeof(DLLLOAD_ITEM));
            memset(&hprc->rgDllList[hprc->cDllList-10], 0, 10*sizeof(DLLLOAD_ITEM));
        }
    } else if (hprc->rgDllList[iDll].offBaseOfImage != (DWORD)ldd->lpBaseOfDll) {
        memset(&hprc->rgDllList[iDll], 0, sizeof(DLLLOAD_ITEM));
    }

    //
    // stick the demarcator at the start of the string so that we
    // don't have to move the string over later.
    //
    *szModName = cModuleDemarcator;

	// Walk this module's section list
	pdmws = NULL;
	cobj = 0;
    rgpdmsl = NULL;
	while(SUCCEEDED(DmWalkModuleSections(&pdmws, pdmml->Name, &dmsl)))
	{
        /* Reallocate the module list if necessary */
        if((cobj & 31) == 0) {
        	PDMN_SECTIONLOAD *rgpdmslT;
            rgpdmslT = rgpdmsl;
            rgpdmsl = MHAlloc((cobj + 32) * sizeof(void *));
            if(rgpdmslT) {
                memcpy(rgpdmsl, rgpdmslT, cobj * sizeof(void *));
                MHFree(rgpdmslT);
            }
            if(!rgpdmsl) {
                /* We're screwed now */
                cobj = 0;
                break;
            }
        }

		rgpdmsl[cobj] = MHAlloc(sizeof(dmsl));
		if(!rgpdmsl[cobj])
			break;
		*rgpdmsl[cobj++] = dmsl;
	}
	DmCloseModuleSections(pdmws);

    if (hprc->rgDllList[iDll].offBaseOfImage == (DWORD)ldd->lpBaseOfDll) {

        //
        // in this case we are re-doing a mod load for a dll
        // that is part of a process that is being reconnected
        //
        assert( hprc->rgDllList[iDll].szDllName != NULL );
        _ftcscpy( szModName + 1, hprc->rgDllList[iDll].szDllName );

    } else {

#if 0
        if (CrashDump) {
            _ftcscpy( szModName+1, ldd->lpImageName );

			_asm int 3
			//FixupDebugImage (szModName + 1);

			
        } else
#endif
		{

            // we're happy...
            //FixFilename(szModName+1, rgch );
			strcpy(szModName+1, pdmml->Name);
            if ((hprc->rgDllList[iDll].szDllName = MHAlloc(_tcslen(szModName+1) + 1)) != NULL)
            {
                _tcscpy(hprc->rgDllList[iDll].szDllName, szModName+1);
            } else {
				goto exitFalse;
            }

		}

        *nameBuffer = 0;
    }

    //
    // for remote case, kill the drive letter to
    // prevent finding same exe on wrong platform,
    // except when user gave path to exe.
    //
    if (fUseRealName) {
        fUseRealName = FALSE;
    }
    lenSz=_ftcslen(szModName);
    DPRINT(10, (_T("*** LoadDll %s  base=%x\n"), szModName, ldd->lpBaseOfDll));

    szModName[lenSz] = 0;

    lpsz = _ftcsrchr(szModName, _T('\\'));
    if (!lpsz) {
        lpsz = _ftcsrchr(szModName, _T(':'));
    }
    if (lpsz) {
        lpsz = _ftcsinc(lpsz);
    } else {
        lpsz = szModName;
    }

	// REVIEW jlange -- change this to ntoskrnl?
    if (_ftcsicmp(lpsz, _T("kernel32.dll")) == 0) {
        hprc->dwKernel32Base = (DWORD)ldd->lpBaseOfDll;
    }

    if (hprc->rgDllList[iDll].offBaseOfImage != (DWORD)ldd->lpBaseOfDll) {
        //
        // new dll to add to the list
        //
        hprc->rgDllList[iDll].fValidDll = TRUE;
        hprc->rgDllList[iDll].offBaseOfImage = (OFFSET) ldd->lpBaseOfDll;
        hprc->rgDllList[iDll].cbImage = pdmml->Size;
    }

    szModName[lenSz] = cModuleDemarcator;

    /*
     *  Make up a record to send back from the name.
     *  Additionally send back:
     *          The file handle (if local)
     *          The load base of the dll
     *          The time and date stamp of the exe
     *          The checksum of the file
     */

    sprintf( szModName+lenSz+1, _T("0x%08lX%c0x%08lX%c0x%08lX%c0x%08lX%c"),
            pdmml->TimeStamp, cModuleDemarcator,
            pdmml->CheckSum, cModuleDemarcator,
            -1L, cModuleDemarcator,
            (long) ldd->lpBaseOfDll, cModuleDemarcator);
    lenSz = _ftcslen(szModName);
    /*
     * Allocate the packet which will be sent across to the EM.
     * The packet will consist of:
     *     The MODULELOAD structure             sizeof(MODULELOAD) +
     *     The section description array        cobj*sizeof(OBJD) +
     *     The name of the DLL                  lenSz+1
     */

	lenTable = (cobj * sizeof(OBJD));
    *lpcbPacket = (WORD)(sizeof(MODULELOAD) + lenTable + (lenSz+1) * sizeof(TCHAR));
    *lplpbPacket= (LPBYTE)(lpmdl=(LPMODULELOAD)MHAlloc(*lpcbPacket));
    lpmdl->lpBaseOfDll = ldd->lpBaseOfDll;
    lpmdl->cobj = cobj;
    lpmdl->mte = (WORD) -1;
    lpmdl->CSSel = lpmdl->DSSel = 0;

    //
    // Set up the descriptors for each of the section headers so that the EM
    // can map between section numbers and flat addresses.
    //

    lpmdl->uoffDataBase = 0;

    isecTLS = 0;
    for (iobj=0; iobj<cobj; iobj++) {

        lpmdl->rgobjd[iobj].wPad = 1;

		lpmdl->rgobjd[iobj].offset = (DWORD)rgpdmsl[iobj]->BaseAddress;;
		lpmdl->rgobjd[iobj].cb = rgpdmsl[iobj]->Size;
		lpmdl->rgobjd[iobj].wSel = 0;

		if (!memcmp( rgpdmsl[iobj]->Name, ".data\0\0", 7)) {
			if (lpmdl->uoffDataBase == 0) {
				lpmdl->uoffDataBase = lpmdl->rgobjd[iobj].offset;
			}
		}

		MHFree(rgpdmsl[iobj]);

    }

    if(rgpdmsl)
        MHFree(rgpdmsl);

    lpmdl->fRealMode = FALSE;
    lpmdl->fFlatMode = TRUE;
    lpmdl->fOffset32 = TRUE;
    lpmdl->dwSizeOfDll = pdmml->Size;
    lpmdl->uoffiTls = 0;
    lpmdl->isecTLS = 0;
    lpmdl->iTls = 0;       // cache it later on demand if uoffiTls != 0

    /*
     *  Copy the name of the dll to the end of the packet.
     */

    memcpy(((BYTE*)&lpmdl->rgobjd)+lenTable, szModName, lenSz+1);

    /*
     *  Locate the TLS section if one exists.  If so then get the
     *      pointer to the TLS index
     */

    if(pdmml->Flags & DMN_MODFLAG_TLS) {
        /* The TLS section is gone from the list at this point, but if the
         * PE headers are present, then we can figure out which section was
         * the TLS sections by examining them */
        isecTLS = FindTLSSection(pdmml);
        if(isecTLS) {
            hprc->rgDllList[iDll].offTlsIndex = 1;
            lpmdl->uoffiTls = 1;
            lpmdl->isecTLS = isecTLS;
        }
    }

    if (fDisconnected) {

        //
        // this will prevent the dm from sending a message up to
        // the shell.  the dm's data structures are setup just fine
        // so that when the debugger re-connects we can deliver the
        // mod loads correctly.
        //

exitFalse:
		return FALSE;

    }

    return TRUE;
}

#ifdef KERNEL

BOOL
GetModnameFromImage(
    HPRCX                   hprc,
    LOAD_DLL_DEBUG_INFO     *ldd,
    LPTSTR                   lpName
    )
/*++

Routine Description:

    This routine attempts to get the name of the exe as placed
    in the debug section by the linker.

Arguments:

Return Value:

    TRUE if a name was found, FALSE if not.
    The exe name is returned as an ANSI string in lpName.

--*/
{
    #define ReadMem(b,s) DbgReadMemory( hprc, (LPVOID)(address), (b), (s), NULL ); address += (s)

    IMAGE_DEBUG_DIRECTORY       DebugDir;
    PIMAGE_DEBUG_MISC           pMisc;
    PIMAGE_DEBUG_MISC           pT;
    DWORD                       rva;
    int                         nDebugDirs;
    int                         i;
    int                         j;
    int                         l;
    BOOL                        rVal = FALSE;
    PVOID                       pExeName;
    IMAGE_NT_HEADERS            nh;
    IMAGE_DOS_HEADER            dh;
    IMAGE_ROM_OPTIONAL_HEADER   rom;
    DWORD                       address;
    DWORD                       sig;
    PIMAGE_SECTION_HEADER       pSH;
    DWORD                       cb;


    lpName[0] = 0;

    address = (ULONG)ldd->lpBaseOfDll;

    ReadMem( &dh, sizeof(dh) );

    if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
        address = (ULONG)ldd->lpBaseOfDll + dh.e_lfanew;
    } else {
        address = (ULONG)ldd->lpBaseOfDll;
    }

    ReadMem( &sig, sizeof(sig) );
    address -= sizeof(sig);

    if (sig == IMAGE_NT_SIGNATURE) {
        ReadMem( &nh, sizeof(nh) );
    } else {
        ReadMem( &nh.FileHeader, sizeof(IMAGE_FILE_HEADER) );
        if (nh.FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_ROM_OPTIONAL_HEADER) {
            ReadMem( &rom, sizeof(rom) );
            ZeroMemory( &nh.OptionalHeader, sizeof(nh.OptionalHeader) );
            nh.OptionalHeader.SizeOfImage      = rom.SizeOfCode;
            nh.OptionalHeader.ImageBase        = rom.BaseOfCode;
        } else {
            return FALSE;
        }
    }

    cb = nh.FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER;
    pSH = MHAlloc( cb );
    ReadMem( pSH, cb );

    nDebugDirs = nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                 sizeof(IMAGE_DEBUG_DIRECTORY);

    if (!nDebugDirs) {
        return FALSE;
    }

    rva = nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

    for(i = 0; i < nh.FileHeader.NumberOfSections; i++) {
        if (rva >= pSH[i].VirtualAddress &&
            rva < pSH[i].VirtualAddress + pSH[i].SizeOfRawData) {
            break;
        }
    }

    if (i >= nh.FileHeader.NumberOfSections) {
        return FALSE;
    }

    rva = ((rva - pSH[i].VirtualAddress) + pSH[i].VirtualAddress);

    for (j = 0; j < nDebugDirs; j++) {

        address = rva + (sizeof(DebugDir) * j) + (ULONG)ldd->lpBaseOfDll;
        ReadMem( &DebugDir, sizeof(DebugDir) );

        if (DebugDir.Type == IMAGE_DEBUG_TYPE_MISC) {

            l = DebugDir.SizeOfData;
            pMisc = pT = MHAlloc(l);

            if ((ULONG)DebugDir.AddressOfRawData < pSH[i].VirtualAddress ||
                  (ULONG)DebugDir.AddressOfRawData >=
                                         pSH[i].VirtualAddress + pSH[i].SizeOfRawData) {
                //
                // the misc debug data MUST be in the .rdata section
                // otherwise windbg cannot access it as it is not mapped in
                //
                continue;
            }

            address = (ULONG)DebugDir.AddressOfRawData + (ULONG)ldd->lpBaseOfDll;
            ReadMem( pMisc, l );

            while (l > 0) {
                if (pMisc->DataType != IMAGE_DEBUG_MISC_EXENAME) {
                    l -= pMisc->Length;
                    pMisc = (PIMAGE_DEBUG_MISC)
                                (((LPSTR)pMisc) + pMisc->Length);
                } else {

                    pExeName = (PVOID)&pMisc->Data[ 0 ];

                    if (!pMisc->Unicode) {
                        _tcscpy(lpName, (LPSTR)pExeName);
                        rVal = TRUE;
                    } else {
                        WideCharToMultiByte(CP_ACP,
                                            0,
                                            (LPWSTR)pExeName,
                                            -1,
                                            lpName,
                                            MAX_PATH,
                                            NULL,
                                            NULL);
                        rVal = TRUE;
                    }

                    /*
                     *  Undo stevewo's error
                     */

                    if (_ftcsicmp(&lpName[_ftcslen(lpName)-4], ".DBG") == 0) {
                        TCHAR    rgchPath[_MAX_PATH];
                        TCHAR    rgchBase[_MAX_FNAME];

                        _splitpath(lpName, NULL, rgchPath, rgchBase, NULL);
                        if (_ftcslen(rgchPath)==4) {
                            rgchPath[_ftcslen(rgchPath)-1] = 0;
                            _ftcscpy(lpName, rgchBase);
                            _ftcscat(lpName, _T("."));
                            _ftcscat(lpName, rgchPath);
                        } else {
                            _ftcscpy(lpName, rgchBase);
                            _ftcscat(lpName, _T(".exe"));
                        }
                    }
                    break;
                }
            }

            MHFree(pT);

            break;

        }
    }

    return rVal;
}

LPMODULEALIAS
FindAddAliasByModule(
    LPSTR lpImageName,
    LPSTR lpModuleName
    )
/*++

Routine Description:

    Look for an alias entry by its "common" name, for example, look
    for "NT".  If it does not exist, and a new image name has been
    provided, add it.  If it does exist and a new image name has been
    provided, replace the image name.  Return the new or found record.

Arguments:


Return Value:


--*/
{
    int i;

    for (i=0; i<MAX_MODULEALIAS; i++) {
        if (ModuleAlias[i].ModuleName[0] == 0) {
            if (!lpImageName) {
                return NULL;
            } else {
                _tcscpy( ModuleAlias[i].Alias, lpImageName );
                _tcscpy( ModuleAlias[i].ModuleName, lpModuleName );
                ModuleAlias[i].Special = 1;
                return &ModuleAlias[i];
            }
        }
        if (_tcsicmp( ModuleAlias[i].ModuleName, lpModuleName ) == 0) {
            if (lpImageName) {
                _tcscpy( ModuleAlias[i].Alias, lpImageName);
            }
            return &ModuleAlias[i];
        }
    }
}

LPMODULEALIAS
FindAliasByImageName(
    LPSTR lpImageName
    )
{
    int i;

    for (i=0; i<MAX_MODULEALIAS; i++) {
        if (ModuleAlias[i].ModuleName[0] == 0) {
            return NULL;
        }
        if (_tcsicmp( ModuleAlias[i].Alias, lpImageName ) == 0) {
            return &ModuleAlias[i];
        }
    }
}

LPMODULEALIAS
CheckForRenamedImage(
    HPRCX hprc,
    LOAD_DLL_DEBUG_INFO *ldd,
    LPTSTR lpOrigImageName,
    LPTSTR lpModuleName
    )
{
    CHAR  ImageName[MAX_PATH];
    CHAR  fname[_MAX_FNAME];
    CHAR  ext[_MAX_EXT];
    DWORD i;


    if (_ftcsicmp( ldd->lpImageName, lpOrigImageName ) != 0) {
        return NULL;
    }

    if (GetModnameFromImage( hprc, ldd, ImageName ) && ImageName[0]) {
        _splitpath( ImageName, NULL, NULL, fname, ext );
        sprintf( ImageName, _T("%s%s"), fname, ext );
        return FindAddAliasByModule(ImageName, lpModuleName);
    }

    return NULL;
}


BOOL
LoadDll(
    DEBUG_EVENT *   de,
    HTHDX           hthd,
    LPWORD          lpcbPacket,
    LPBYTE *        lplpbPacket
    )
/*++

Routine Description:

    This routine is used to load the signification information about
    a PE exe file.  This information consists of the name of the exe
    just loaded (hopefully this will be provided later by the OS) and
    a description of the sections in the exe file.

Arguments:

    de         - Supplies a pointer to the current debug event

    hthd       - Supplies a pointer to the current thread structure

    lpcbPacket - Returns the count of bytes in the created packet

    lplpbPackt - Returns the pointer to the created packet

Return Value:

    True on success and FALSE on failure

--*/

{
    LOAD_DLL_DEBUG_INFO *       ldd = &de->u.LoadDll;
    LPMODULELOAD                lpmdl;
    CHAR                        szModName[MAX_PATH];
    DWORD                       lenSz;
    INT                         iDll;
    HPRCX                       hprc = hthd->hprc;
    CHAR                        fname[_MAX_FNAME];
    CHAR                        ext[_MAX_EXT];
    CHAR                        szFoundName[_MAX_PATH];
    LPMODULEALIAS               Alias = NULL;
    DWORD                       i;
    IMAGEINFO                   ii;

    static int FakeDllNumber = 0;
    TCHAR FakeDllName[13];

    //
    // extern owned by kdapi.c:
    //
    extern DWORD CacheProcessors;


    if ( hprc->pstate & (ps_killed | ps_dead) ) {
        //
        //  Process is dead, don't bother doing anything.
        //
        return FALSE;
    }

    if ( *(LPTSTR)ldd->lpImageName == 0 ) {
        ldd->lpImageName = FakeDllName;
        sprintf(FakeDllName, _T("DLL%05x"), FakeDllNumber++);
    }

    if (_ftcsicmp( ldd->lpImageName, HAL_IMAGE_NAME ) == 0) {
        Alias = CheckForRenamedImage( hprc, ldd, HAL_IMAGE_NAME, HAL_MODULE_NAME );
    }

    if (_ftcsicmp( ldd->lpImageName, KERNEL_IMAGE_NAME ) == 0) {
        Alias = CheckForRenamedImage( hprc, ldd, KERNEL_IMAGE_NAME, KERNEL_MODULE_NAME );
    if (!Alias && CacheProcessors > 1) {
            Alias = FindAddAliasByModule( KERNEL_IMAGE_NAME_MP, KERNEL_MODULE_NAME );
        }
    }

    if (!Alias) {
        Alias = FindAliasByImageName(ldd->lpImageName);
    }

    //
    //  Create an entry in the DLL list and set the index to it so that
    //  we can have information about all DLLs for the current system.
    //
    for (iDll=0; iDll<hprc->cDllList; iDll+=1) {
        if (!hprc->rgDllList[iDll].fValidDll) {
            break;
        }
    }

    if (iDll == hprc->cDllList) {
        //
        // the dll list needs to be expanded
        //
        hprc->cDllList += 10;
        hprc->rgDllList = MHRealloc(hprc->rgDllList,
                                  hprc->cDllList * sizeof(DLLLOAD_ITEM));
        memset(&hprc->rgDllList[hprc->cDllList-10], 0, 10*sizeof(DLLLOAD_ITEM));
    } else {
        memset(&hprc->rgDllList[iDll], 0, sizeof(DLLLOAD_ITEM));
    }

    hprc->rgDllList[iDll].fValidDll = TRUE;
    hprc->rgDllList[iDll].offBaseOfImage = (OFFSET) ldd->lpBaseOfDll;
    hprc->rgDllList[iDll].cbImage = ldd->dwDebugInfoFileOffset;
    if (Alias) {
        _splitpath( Alias->ModuleName, NULL, NULL, fname, ext );
    } else {
        _splitpath( ldd->lpImageName, NULL, NULL, fname, ext );
    }
    hprc->rgDllList[iDll].szDllName = MHAlloc(_ftcslen(fname)+_ftcslen(ext)+4);
    sprintf( hprc->rgDllList[iDll].szDllName, _T("%s%s"), fname, ext );
    hprc->rgDllList[iDll].NumberOfSections = 0;
    hprc->rgDllList[iDll].Sections = NULL;
    hprc->rgDllList[iDll].sec = NULL;

    *szFoundName = 0;
    if (!((ULONG)ldd->lpBaseOfDll & 0x80000000)) {
        //
        // must be a usermode module
        //
        if (ReadImageInfo( hprc->rgDllList[iDll].szDllName,
                           szFoundName,
                           (LPSTR)KdOptions[KDO_SYMBOLPATH].value,
                           &ii )) {
            //
            // we found the debug info, so now save the sections
            // this data is used by processgetsectionscmd()
            //
            hprc->rgDllList[iDll].NumberOfSections = ii.NumberOfSections;
            hprc->rgDllList[iDll].sec = ii.Sections;
            hprc->rgDllList[iDll].offBaseOfImage = ii.BaseOfImage;
            hprc->rgDllList[iDll].cbImage = ii.SizeOfImage;
            ldd->hFile = (HANDLE)ii.CheckSum;
        }
    }

#ifdef TARGET_i386
    hprc->rgDllList[iDll].SegCs = (WORD) hthd->context.SegCs;
    hprc->rgDllList[iDll].SegDs = (WORD) hthd->context.SegDs;
#endif

    //
    //  Make up a record to send back from the name.
    //  Additionally send back:
    //          The file handle (if local)
    //          The load base of the dll
    //          The time and date stamp of the exe
    //          The checksum of the file
    //          ... and optionally the string "MP" to signal
    //              a multi-processor system to the symbol handler
    //
    *szModName = cModuleDemarcator;

    //
    // Send the name found by ReadImageInfo if it found an exe; if it
    // only found a dbg, send the default name.
    //
    _ftcscpy( szModName + 1,
            *szFoundName ? szFoundName : hprc->rgDllList[iDll].szDllName);
    lenSz=_ftcslen(szModName);
    szModName[lenSz] = cModuleDemarcator;
    sprintf( szModName+lenSz+1,_T("0x%08lX%c0x%08lX%c0x%08lX%c0x%08lX%c"),
             -1,                             cModuleDemarcator,    // timestamp
             ldd->hFile,                     cModuleDemarcator,    // checksum
             -1,                             cModuleDemarcator,
             hprc->rgDllList[iDll].offBaseOfImage,  cModuleDemarcator
           );

    if (Alias) {
        _ftcscat( szModName, Alias->Alias );
        lenSz = _ftcslen(szModName);
        szModName[lenSz] = cModuleDemarcator;
        szModName[lenSz+1] = 0;
        if (Alias->Special == 2) {
            // If it's a one-shot alias, nuke it.
            memset(Alias, 0, sizeof(MODULEALIAS));
        }
    }

    lenSz = _ftcslen(szModName);
    _ftcsupr(szModName);

    //
    // Allocate the packet which will be sent across to the EM.
    // The packet will consist of:
    //     The MDL structure                    sizeof(MDL) +
    //     The section description array        cobj*sizeof(OBJD) +
    //     The name of the DLL                  lenSz+1
    //
    *lpcbPacket = (WORD)(sizeof(MODULELOAD) + (lenSz+1));
    *lplpbPacket= (LPBYTE)(lpmdl=(LPMODULELOAD)MHAlloc(*lpcbPacket));
    ZeroMemory( lpmdl, *lpcbPacket );
    lpmdl->lpBaseOfDll = (LPVOID) hprc->rgDllList[iDll].offBaseOfImage;
    // mark the MDL packet as deferred:
    lpmdl->cobj = -1;
    lpmdl->mte = (WORD) -1;
#ifdef TARGET_i386
    lpmdl->CSSel    = (unsigned short)hthd->context.SegCs;
    lpmdl->DSSel    = (unsigned short)hthd->context.SegDs;
#else
    lpmdl->CSSel = lpmdl->DSSel = 0;
#endif

    lpmdl->fRealMode = 0;
    lpmdl->fFlatMode = 1;
    lpmdl->fOffset32 = 1;

    lpmdl->dwSizeOfDll = hprc->rgDllList[iDll].cbImage;

    //
    //  Copy the name of the dll to the end of the packet.
    //
    memcpy(((BYTE*)&lpmdl->rgobjd), szModName, lenSz+1);

    if (fDisconnected) {

        //
        // this will prevent the dm from sending a message up to
        // the shell.  the dm's data structures are setup just fine
        // so that when the debugger re-connects we can deliver the
        // mod loads correctly.
        //

        return FALSE;

    }

    return TRUE;
}                               /* LoadDll() */




#endif // KERNEL


/**     ConsumeThreadEventsAndNotifyEM
**
**              Description:
**                      Does exactly what it says it does
*/

void
ConsumeThreadEventsAndNotifyEM(
        DEBUG_EVENT* de,
        HTHDX hthd,
        DWORD wParam,
        LPVOID lparam
        )
{
    ConsumeAllThreadEvents(hthd, FALSE);
    NotifyEM(de, hthd, wParam, lparam);
}



/***    NotifyEM
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**      Given a debug event from the OS send the correct information
**      back to the debugger.
**
*/


void
NotifyEM(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD wparam,
    LPVOID lparam
    )
/*++

Routine Description:

    This is the interface for telling the EM about debug events.

    In general, de describes an event which the debugger needs
    to know about.  In some cases, a reply is needed.  In those
    cases this routine handles the reply and does the appropriate
    thing with the data from the reply.

Arguments:

    de      - Supplies debug event structure

    hthd    - Supplies thread that got the event

    wparam  - Supplies data specific to event

    lparam  - Supplies data specific to event

Return Value:

    None

--*/
{
    DWORD       eventCode = de->dwDebugEventCode;
    DWORD       subClass;
    RTP         rtp;
    RTP *       lprtp;
    WORD        cbPacket=0;
    LPBYTE      lpbPacket;
    LPVOID      toFree=(LPVOID)0;
    WORD        packetType = tlfDebugPacket;


    if (hthd) {
        rtp.hpid = hthd->hprc->hpid;
        rtp.htid = hthd->htid;
    } else if (hpidRoot == (HPID)INVALID) {
        return;
    } else {
        // cheat:
        rtp.hpid = hpidRoot;
        rtp.htid = NULL;
    }
    subClass = de->u.Exception.ExceptionRecord.ExceptionCode;

    switch(eventCode){

    case FUNC_EXIT_EVENT:
        if (hthd->fDisplayReturnValues) {
            cbPacket = sizeof(ADDR);
            rtp.dbc = dbcExitedFunction;
            lpbPacket = (LPBYTE) lparam;
                        assert(lpbPacket);
        } else {
            return;
        }
        break;

    case EXCEPTION_DEBUG_EVENT:
        if (subClass!=EXCEPTION_SINGLE_STEP){
            PEXCEPTION_RECORD pexr=&de->u.Exception.ExceptionRecord;
            DWORD cParam = pexr->NumberParameters;
            DWORD nBytes = sizeof(EPR)+sizeof(DWORD)*cParam;
            LPEPR lpepr  = MHAlloc(nBytes);

            toFree    = (LPVOID) lpepr;
            cbPacket  = (WORD)   nBytes;
            lpbPacket = (LPBYTE) lpepr;
#ifdef TARGET_i386
            lpepr->bpr.segCS = (SEGMENT)HthdReg(hthd,SegCs);
            lpepr->bpr.segSS = (SEGMENT)HthdReg(hthd,SegSs);
#endif
            lpepr->bpr.offEBP =  (DWORD)FRAME_POINTER(hthd);
            lpepr->bpr.offESP =  (DWORD)STACK_POINTER(hthd);
            lpepr->bpr.offEIP =  (DWORD)PC(hthd);
            lpepr->bpr.fFlat  =  hthd->fAddrIsFlat;
            lpepr->bpr.fOff32 =  hthd->fAddrOff32;
            lpepr->bpr.fReal  =  hthd->fAddrIsReal;

            lpepr->dwFirstChance  = de->u.Exception.dwFirstChance;
            lpepr->ExceptionCode    = pexr->ExceptionCode;
            lpepr->ExceptionFlags   = pexr->ExceptionFlags;
            lpepr->NumberParameters = cParam;
            for(;cParam;cParam--) {
                lpepr->ExceptionInformation[cParam-1]=
                  pexr->ExceptionInformation[cParam-1];
            }

            rtp.dbc = dbcException;
            break;
        };

                // Add 'foo returned' to Auto watch window
        if (hthd->fReturning) {
            hthd->fReturning = FALSE;
            NotifyEM(&FuncExitEvent, hthd, 0, &hthd->addrFrom );
        }



        // Fall through when subClass == EXCEPTION_SINGLE_STEP

    case BREAKPOINT_DEBUG_EVENT:
    case ENTRYPOINT_DEBUG_EVENT:
    case CHECK_BREAKPOINT_DEBUG_EVENT:
    case LOAD_COMPLETE_DEBUG_EVENT:
        {
            LPBPR lpbpr = MHAlloc ( sizeof ( BPR ) );
            toFree=lpbpr;
            cbPacket = sizeof ( BPR );
            lpbPacket = (LPBYTE) lpbpr;

#ifdef TARGET_i386
            lpbpr->segCS = (SEGMENT)HthdReg(hthd,SegCs);
            lpbpr->segSS = (SEGMENT)HthdReg(hthd,SegSs);
#endif

            lpbpr->offEBP =  (DWORD)FRAME_POINTER(hthd);
            lpbpr->offESP =  (DWORD)STACK_POINTER(hthd);
            lpbpr->offEIP =  (DWORD)PC(hthd);
            lpbpr->fFlat  =  hthd->fAddrIsFlat;
            lpbpr->fOff32 =  hthd->fAddrOff32;
            lpbpr->fReal  =  hthd->fAddrIsReal;
            lpbpr->dwNotify = (DWORD)lparam;

            if (eventCode==EXCEPTION_DEBUG_EVENT) {
                rtp.dbc = dbcStep;
                break;
            } else {              /* (the breakpoint case) */

                // REVIEW: It would be cleaner to setup something which got
                // called when the EE got consumed and turned this off. I
                // don't think the DM has this notion except for preset bps.
                // I think a general function for cleanup would be a good
                // idea here.

                if (eventCode != CHECK_BREAKPOINT_DEBUG_EVENT) {
                hthd->fReturning = FALSE;
                }

                if (eventCode == ENTRYPOINT_DEBUG_EVENT) {
                    rtp.dbc = dbcEntryPoint;
                } else if (eventCode == LOAD_COMPLETE_DEBUG_EVENT) {
                    rtp.dbc = dbcLoadComplete;
                } else if (eventCode == CHECK_BREAKPOINT_DEBUG_EVENT) {
                    rtp.dbc = dbcCheckBpt;
                    packetType = tlfRequest;
                } else {
                    rtp.dbc = dbcBpt;
                }

                /* NOTE: Ok try to follow this: If this was one
                 *   of our breakpoints then we have already
                 *   decremented the IP to point to the actual
                 *   INT3 instruction (0xCC), this is so we
                 *   can just replace the byte and continue
                 *   execution from that point on.
                 *
                 *   But if it was hard coded in by the user
                 *   then we can't do anything but execute the
                 *   NEXT instruction (because there is no
                 *   instruction "under" this INT3 instruction)
                 *   So the IP is left pointing at the NEXT
                 *   instruction. But we don't want the EM
                 *   think that we stopped at the instruction
                 *   after the INT3, so we need to decrement
                 *   offEIP so it's pointing at the hard-coded
                 *   INT3. Got it?
                 *
                 *   On an ENTRYPOINT_DEBUG_EVENT, the address is
                 *   already right, and lparam is ENTRY_BP.
                 */

                if (!lparam) {
                    lpbpr->offEIP = (UOFFSET)de->
                       u.Exception.ExceptionRecord.ExceptionAddress;
                }
            }

        }
        break;


    case CREATE_PROCESS_DEBUG_EVENT:
        /*
         *  A Create Process event has occured.  The following
         *  messages need to be sent back
         *
         *  dbceAssignPID: Associate our handle with the debugger
         *
         *  dbcModLoad: Inform the debugger of the module load for
         *  the main exe (this is done at the end of this routine)
         */
        {
            HPRCX  hprc = (HPRCX)lparam;

            /*
             * Has the debugger requested this process?
             * ie: has it already given us the HPID for this process?
             */
            if (hprc->hpid != (HPID)INVALID){

                lpbPacket = (LPBYTE)&(hprc->pid);
                cbPacket  = sizeof(hprc->pid);

                /* Want the hprc for the child NOT the DM */
                rtp.hpid  = hprc->hpid;

#if 0
#ifndef KERNEL
                //
                // hack for made-up image names:
                //
                iTemp1    = 0;
#endif
#endif
                rtp.dbc   = dbceAssignPID;
            }

            /*
             * The debugger doesn't know about this process yet,
             * request an HPID for this new process.
             */

            else {
                LPNPP lpnpp = MHAlloc(cbPacket=sizeof(NPP));

                toFree            = lpnpp;
                lpbPacket         = (LPBYTE)lpnpp;
                packetType        = tlfRequest;

                /*
                 * We must temporarily assign a valid HPID to this HPRC
                 * because OSDebug will try to de-reference it in the
                 * TL callback function
                 */
                rtp.hpid          = hpidRoot;
                lpnpp->pid        = hprc->pid;
                lpnpp->fReallyNew = TRUE;
                rtp.dbc           = dbcNewProc;
            }
        }
        break;

    case CREATE_THREAD_DEBUG_EVENT:
        {
            LPTCR lptcr = (LPTCR) MHAlloc(cbPacket=sizeof(TCR));
            toFree      = lpbPacket = (LPBYTE)lptcr;
            packetType  = tlfRequest;

            lptcr->tid     = hthd->tid;
            lptcr->uoffTEB = (UOFFSET) hthd->offTeb;

            rtp.hpid = hthd->hprc->hpid;
            rtp.htid = hthd->htid;
            rtp.dbc  = dbcCreateThread;
        }
        break;

    case EXIT_PROCESS_DEBUG_EVENT:
        cbPacket    = sizeof(DWORD);
        lpbPacket   = (LPBYTE) &(de->u.ExitProcess.dwExitCode);

        hthd->hprc->pstate |= ps_exited;
        rtp.hpid    = hthd->hprc->hpid;
        rtp.htid    = hthd->htid;
        rtp.dbc = dbcProcTerm;
        break;

    case EXIT_THREAD_DEBUG_EVENT:
        cbPacket    = sizeof(DWORD);
        lpbPacket   = (LPBYTE) &(de->u.ExitThread.dwExitCode);

        hthd->tstate        |= ts_dead; /* Mark thread as dead */
        hthd->hprc->pstate  |= ps_deadThread;
        rtp.dbc = dbcThreadTerm;
        break;

    case DESTROY_PROCESS_DEBUG_EVENT:
        DPRINT(3, (_T("DESTROY PROCESS\n")));
        hthd->hprc->pstate |= ps_destroyed;
        rtp.dbc = dbcDeleteProc;
        break;

    case DESTROY_THREAD_DEBUG_EVENT:
        /*
         *  Check if already destroyed
         */

        assert( (hthd->tstate & ts_destroyed) == 0 );

        DPRINT(3, (_T("DESTROY THREAD\n")));

        hthd->tstate |= ts_destroyed;
        cbPacket    = sizeof(DWORD);
//NOTENOTE a-kentf exit code is bogus here
        lpbPacket   = (LPBYTE) &(de->u.ExitThread.dwExitCode);
        rtp.dbc     = dbcDeleteThread;
        break;


    case LOAD_DLL_DEBUG_EVENT:

        packetType  = tlfRequest;
        rtp.dbc     = dbcModLoad;

#ifndef KERNEL
        //
        // this was changed for a deadlock problem in user mode.
        // if somebody gets ambitious, they can match the change
        // for the KD side.
        //
        lpbPacket   = lparam;
        cbPacket    = (USHORT)wparam;
#else
        if (!LoadDll(de, hthd, &cbPacket, &lpbPacket) || (cbPacket == 0)) {
            return;
        }
#endif
        //ValidateHeap();
        toFree      = (LPVOID)lpbPacket;
        break;

    case UNLOAD_DLL_DEBUG_EVENT:
        packetType  = tlfRequest;
        cbPacket  = sizeof(DWORD);
        lpbPacket = (LPBYTE) &(de->u.UnloadDll.lpBaseOfDll);

        rtp.dbc   = dbceModFree32;
        break;

    case OUTPUT_DEBUG_STRING_EVENT:
        {
            LPINFOAVAIL   lpinf;
            DWORD   cbR;

            rtp.dbc = dbcInfoAvail;

            cbPacket = (WORD)(sizeof(INFOAVAIL) +
                               de->u.DebugString.nDebugStringLength + 1);
            lpinf = (LPINFOAVAIL) lpbPacket = MHAlloc(cbPacket);
            toFree = lpbPacket;

            lpinf->fReply   = FALSE;
            lpinf->fUniCode = de->u.DebugString.fUnicode;

			memcpy(&lpinf->buffer[0], de->u.DebugString.lpDebugStringData,
				de->u.DebugString.nDebugStringLength);
            lpinf->buffer[de->u.DebugString.nDebugStringLength] = 0;
        }
        break;


    case INPUT_DEBUG_STRING_EVENT:
        {
            LPINFOAVAIL   lpinf;

            packetType = tlfRequest;
            rtp.dbc = dbcInfoReq;

            cbPacket =
                (WORD)(sizeof(INFOAVAIL) + de->u.DebugString.nDebugStringLength + 1);
            lpinf = (LPINFOAVAIL) lpbPacket = MHAlloc(cbPacket);
            toFree = lpbPacket;

            lpinf->fReply   = TRUE;
            lpinf->fUniCode = de->u.DebugString.fUnicode;

            memcpy( &lpinf->buffer[0],
                    de->u.DebugString.lpDebugStringData,
                    de->u.DebugString.nDebugStringLength);
            lpinf->buffer[ de->u.DebugString.nDebugStringLength ] = 0;
        }
        break;

    case RIP_EVENT:
#if 0
        {
            LPRIP_INFO  prip   = &de->u.RipInfo;
            DWORD       nBytes = sizeof(NT_RIP);
            LPNT_RIP    lprip  = MHAlloc(nBytes);

            toFree    = (LPVOID) lprip;
            cbPacket  = (WORD)   nBytes;
            lpbPacket = (LPBYTE) lprip;

#ifdef TARGET_i386
            lprip->bpr.segCS = (SEGMENT)hthd->context.SegCs;
            lprip->bpr.segSS = (SEGMENT)hthd->context.SegSs;
#endif
            lprip->bpr.offEBP =  (DWORD)FRAME_POINTER(hthd);
            lprip->bpr.offESP =  (DWORD)STACK_POINTER(hthd);
            lprip->bpr.offEIP =  (DWORD)PC(hthd);
            lprip->bpr.fFlat  =  hthd->fAddrIsFlat;
            lprip->bpr.fOff32 =  hthd->fAddrOff32;
            lprip->bpr.fReal  =  hthd->fAddrIsReal;

            lprip->ulErrorCode  = prip->dwError;
            lprip->ulErrorLevel = prip->dwType;

            rtp.dbc = dbcNtRip;
        }
#endif  // !OSDEBUG4
		
		/* If we hit a RIP, we need to bring up a msgbox for the assert,
		 * and then stop execution, which we do by faking an async stop */
		{
			LPBPR lpbpr;

			XboxRip((LPSTR)de->u.RipInfo.dwError);
			if(de->u.RipInfo.dwError)
				MHFree((PVOID)de->u.RipInfo.dwError);
			cbPacket = sizeof(BPR);
			lpbpr = MHAlloc(cbPacket);
			toFree = lpbpr;
			lpbPacket = (LPBYTE)lpbpr;
			
#ifdef TARGET_i386
            lpbpr->segCS = (SEGMENT)HthdReg(hthd,SegCs);
            lpbpr->segSS = (SEGMENT)HthdReg(hthd,SegSs);
#endif
            lpbpr->offEBP =  (DWORD)FRAME_POINTER(hthd);
            lpbpr->offESP =  (DWORD)STACK_POINTER(hthd);
            lpbpr->offEIP =  (DWORD)PC(hthd);
            lpbpr->fFlat  =  hthd->fAddrIsFlat;
            lpbpr->fOff32 =  hthd->fAddrOff32;
            lpbpr->fReal  =  hthd->fAddrIsReal;
			lpbpr->dwNotify = 0;

			rtp.dbc = dbcAsyncStop;
		}

        break;

    case ATTACH_DEADLOCK_DEBUG_EVENT:
        {
			// We get here if we've timed out waiting to attach to the 
			// debuggee. This applies both in the AttachToActive/JIT and 
			// normal debugging cases. In the latter case, starting a debuggee 
			// which can't find all DLLs and then waiting at the System dialog
			// while it times out.

			// A DebugPacket needs an XOSD and a string;
			struct _ATTACH_DEADLOCK_DEBUG_PACKET {
				XOSD	xosd;
				LPTSTR	lpstrMessage;
			} addp = { xosdAttachDeadlock, NULL };

			assert (!lparam && !wparam); // Should be 0; 
			assert (packetType == tlfDebugPacket);

            cbPacket    = sizeof(addp);
            lpbPacket   = (LPBYTE) &addp;
            rtp.dbc     = dbcError;
        }
        break;

    case MESSAGE_DEBUG_EVENT:
    case MESSAGE_SEND_DEBUG_EVENT:
        cbPacket = sizeof ( MSGI );
        lpbPacket = (LPBYTE) lparam;

        rtp.dbc = (eventCode == MESSAGE_DEBUG_EVENT) ? dbcMsgBpt :dbcSendMsgBpt;
        break;

    default:
        DPRINT(1, (_T("Error, unknown event\n\r")));
        SetDebugEventThreadState (hthd->hprc, ts_running);
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
        return;
    }


    DPRINT(3, (_T("Notify the debugger: dbc=%x, hpid=%x, htid=%x, cbpacket=%d "),
                  rtp.dbc, rtp.hpid, rtp.htid, cbPacket+FIELD_OFFSET(RTP, rgbVar)));

    if (!(rtp.cb=cbPacket)) {
        DmTlFunc(packetType, rtp.hpid, FIELD_OFFSET(RTP, rgbVar), (LONG)(LPV) &rtp);
    }
    else {
        lprtp = (LPRTP)MHAlloc(FIELD_OFFSET(RTP, rgbVar)+cbPacket);
        memcpy(lprtp, &rtp, FIELD_OFFSET(RTP, rgbVar));
        memcpy(lprtp->rgbVar, lpbPacket, cbPacket);

        DmTlFunc(packetType, rtp.hpid,(WORD)(FIELD_OFFSET(RTP, rgbVar)+cbPacket),
                 (LONG)(LPV) lprtp);

        MHFree(lprtp);
    }

    if (toFree) {
        MHFree(toFree);
    }

    DPRINT(3, (_T("\n")));

    switch(eventCode){

      case CREATE_THREAD_DEBUG_EVENT:
        if (packetType == tlfRequest) {
            hthd->htid = *((HTID *) abEMReplyBuf);
        }
        SetEvent(hthd->hprc->hEventCreateThread);
        break;

      case CREATE_PROCESS_DEBUG_EVENT:
        if (packetType == tlfRequest) {
            ((HPRCX)lparam)->hpid = *((HPID *) abEMReplyBuf);
        } else {
            XOSD xosd = xosdNone;
            DmTlFunc( tlfReply,
                      ((HPRCX)lparam)->hpid,
                      sizeof(XOSD),
                      (LONG)(LPV) &xosd);
        }

        SetEvent(hEventCreateProcess);

        break;

      case OUTPUT_DEBUG_STRING_EVENT:
        // just here to synchronize
        break;

      case INPUT_DEBUG_STRING_EVENT:
        de->u.DebugString.nDebugStringLength = _ftcslen(abEMReplyBuf) + 1;
        memcpy(de->u.DebugString.lpDebugStringData,
               abEMReplyBuf,
               de->u.DebugString.nDebugStringLength);
        break;

#ifdef KERNEL
      // as noted above, synchronization is done differently in
      // the user and KD versions:
      case LOAD_DLL_DEBUG_EVENT:
        if (_ftcsicmp( de->u.LoadDll.lpImageName, KERNEL_IMAGE_NAME ) == 0) {
          GetKernelSymbolAddresses();
        }
        break;
#endif

      default:
        break;
    }

    //ValidateHeap();
    return;
}                               /* NotifyEM() */

/*** ACTIONTERMINATEPROCESS
 *
 * PURPOSE:
 *
 * INPUT:
 *
 * OUTPUT:
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 ****************************************************************************/

VOID
ActionTerminateProcess (
    DEBUG_EVENT   * pde,
    HTHDX           hthd,
    DWORD           unused,
    LPVOID          lpv
    )
{
    ConsumeAllProcessEvents ( (HPRCX)lpv, TRUE );

    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);

    hthd->hprc->pstate |= ps_dead;

} /* ACTIONTERMINATEPROCESS */

/*** ACTIONPROCESSLOADFAILED
 *
 * PURPOSE:
 *      When we issued the CreateProcess, that succeeded; but then we
 *      got an exception with the EXCEPTION_NONCONTINUABLE flag set,
 *      which means after letting the debuggee continue we would get
 *      a process-termination notification.  (For example, if the
 *      system can't find a DLL that the process needs, it sends a
 *      STATUS_DLL_NOT_FOUND notification with this flag set.)  So
 *      we've said ok, and now the system has sent us a procterm
 *      notification for it.
 *
 * INPUT:
 *
 * OUTPUT:
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 ****************************************************************************/

VOID
ActionProcessLoadFailed (
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    )
{
    /* Call another action proc & do what it does */
    ActionTerminateProcess(pde, hthd, 0, hthd->hprc);
}

/*** ACTIONNONCONTINUABLEEXCEPTION
 *
 * PURPOSE:
 *      When we issued the CreateProcess, that succeeded; but then we
 *      got an exception with the EXCEPTION_NONCONTINUABLE flag set,
 *      which means after letting the debuggee continue we would get
 *      a process-termination notification.  (For example, if the
 *      system can't find a DLL that the process needs, it sends a
 *      STATUS_DLL_NOT_FOUND notification with this flag set.)  So
 *      we've said ok, and now the system has sent us a last-chance
 *      notification for it.
 *
 * INPUT:
 *
 * OUTPUT:
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 ****************************************************************************/

VOID
ActionNoncontinuableException (
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    )
{
    // [cuda#5673 7/8/93 mikemo]  This is very strange -- it seems that
    // in some situations NT has now sent us a SECOND first-chance
    // notification, even though it already sent us one.  I don't know
    // why this is, but if this happens, I register another event expecting
    // a last-chance notification, instead of expecting exit-process.
    if (pde->u.Exception.dwFirstChance) {
        RegisterExpectedEvent(hthd->hprc,
                              hthd,
                              EXCEPTION_DEBUG_EVENT,
                              (DWORD)pde->u.Exception.ExceptionRecord.ExceptionCode,
                              DONT_NOTIFY,
                              ActionNoncontinuableException,
                              FALSE,
                              NULL
                              );
    } else {
        RegisterExpectedEvent(hthd->hprc, hthd, EXIT_PROCESS_DEBUG_EVENT,
            NO_SUBCLASS, DONT_NOTIFY, ActionProcessLoadFailed, FALSE,
            NULL);
    }

    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              (DWORD)DBG_EXCEPTION_NOT_HANDLED,
              0);
}


void
ProcessExceptionEvent(
    DEBUG_EVENT* de,
    HTHDX hthd
    )
{
    DWORD       subclass = de->u.Exception.ExceptionRecord.ExceptionCode;
    DWORD       firstChance = de->u.Exception.dwFirstChance;
    PBREAKPOINT bp=NULL;

    //
    //  If the thread is in a pre-start state we failed in the
    //  program loader, probably because a link couldn't be resolved.
    //
    if ( hthd->hprc->pstate & ps_preStart ) {
        BOOL  fNonContinuable;
        DPRINT(1, (_T("Exception during init\n")));

        fNonContinuable = !!(de->u.Exception.ExceptionRecord.ExceptionFlags &
            EXCEPTION_NONCONTINUABLE);
        if (fNonContinuable) {
            DWORD dwRet;
            LPTSTR lszError = NULL;

            hthd->hprc->pstate &= ~ps_preStart;
            hthd->tstate |= ts_stopped;
            /*
            ** The debugger is expecting either an OS-specific error code
            ** or an XOSD (XOSDs are negative).  We don't have an OS
            ** error code (all we have is an exception number).  The debugger
            ** treats STATUS_DLL_NOT_FOUND as an error code, but doesn't
            ** recognize any other exception codes, so for other exception
            ** codes, just return xosdLoadChild.
            */
            if (subclass == STATUS_DLL_NOT_FOUND) {
                TCHAR rgch[256]; // same as magic number in em\errors.c
#ifdef XBOX // LOCBUG
				strcpy(lszError = rgch, "dll not found");
#else
                if (!LoadString(hInstance, IDS_STATUS_DLL_NOT_FOUND, rgch, _tsizeof(rgch))) {
                    assert(FALSE);
                } else {
                    lszError = rgch;
                }
#endif
                dwRet = xosdFileNotFound;
            }
            else {
                dwRet = xosdGeneral;
            }
            SendNTError(hthd->hprc, dwRet, lszError);

            /*
            ** Actually the CreateProcess succeeded, and then we
            ** received a notification with an exception; so we need
            ** to keep calling ContinueDebugEvent until the process
            ** is really dead.
            */
            hthd->hprc->pstate |= ps_exited;
            ConsumeAllProcessEvents(hthd->hprc, TRUE);
            RegisterExpectedEvent(hthd->hprc,
                                  hthd,
                                  EXCEPTION_DEBUG_EVENT,
                                  subclass,
                                  DONT_NOTIFY,
                                  ActionNoncontinuableException,
                                  FALSE,
                                  NULL);
            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      hthd->hprc->pid,
                      hthd->tid,
                      (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                      0);
            return;
        }
        //
        // since we will probably never see the expected BP,
        // clear it out, and clear the prestart flag on the
        // thread, then go ahead and deliver the exception
        // to the shell.
        //
        ConsumeAllProcessEvents(hthd->hprc, TRUE);
        hthd->hprc->pstate &= ~ps_preStart;
        hthd->tstate |= ts_stopped;
    }


    switch(subclass) {

    case (DWORD)EXCEPTION_SINGLE_STEP:
#if defined(DOLPHIN)
#if defined(NO_TRACE_BIT)
        //
        // BUGBUG kentf This next bit of code is a rather overcomplicated
        // BUGBUG   way of creating a deadlock.  The same task could be
        // BUGBUG   accomplished with considerably less code.
        // BUGBUG
        // BUGBUG The problem which this intends to solve is as follows:
        // BUGBUG   When a thread is stepped using a code breakpoint, it
        // BUGBUG   may happen that another thread will execute the
        // BUGBUG   breakpoint.  Since that thread is not intended to stop
        // BUGBUG   there, we must replace the instruction and allow that
        // BUGBUG   thread to continue.  During the time that the "wrong"
        // BUGBUG   thread is executing the instruction, it may happen that
        // BUGBUG   the "right" thread will hit that instruction, and run
        // BUGBUG   through it, thereby missing the breakpoint.
        // BUGBUG
        // BUGBUG   The following code attempts to solve the problem by
        // BUGBUG   suspending all of the threads in the process while
        // BUGBUG   stepping the "wrong" thread off of the breakpoint.
        // BUGBUG
        // BUGBUG   This algorithm assumes that the "wrong" thread will be
        // BUGBUG   able to complete the instruction while all of the other
        // BUGBUG   threads are suspended.  This assumption is easily
        // BUGBUG   disproven.  For example, try this on a call to
        // BUGBUG   WaitForSingleObject.
        // BUGBUG
        // BUGBUG   Secondly, this code assumes that the next debug event
        // BUGBUG   will be the exception from the "wrong" thread completing
        // BUGBUG   the new step.  This is a absolutely not the case, and
        // BUGBUG   the code below will fail in ways much more disastrous
        // BUGBUG   than running through a step.
        // BUGBUG
        // BUGBUG
        // BUGBUG   Note 1:  This particular condition cannot arise on
        // BUGBUG   a processor with a step flag, since the step flag
        // BUGBUG   cannot cause a single step exception on the
        // BUGBUG   wrong thread (except as a result of an OS bug).
        //
        {
            /* This single step was intended for another thread */
            HPRCX hprc = hthd->hprc;
            HTHDX hthdCurr = NULL;
            BREAKPOINT* tmpBP = NULL;
            UOFF32 NextOffset;
            ADDR addr;
            BP_UNIT opcode = BP_OPCODE;
            DWORD i;

            AddrFromHthdx(&addr, hthd);
            if (bp = AtBP(hthd)) {
                RestoreInstrBP(hthd, bp);
            }
            /* Suspend all threads except this one */
            for (hthdCurr = hprc->hthdChild; hthdCurr != NULL; hthdCurr = hthdCurr->nextSibling) {
                if (hthdCurr != hthd) {
                    if (SuspendThread(hthdCurr->rwHand) == -1L) {
                        ; // Internal error;
                    }
                }
            }
            /* Set BP at next offset so we can get off this SS */
            NextOffset = GetNextOffset( hthd, FALSE);
            if (NextOffset != 0) {
                ADDR tmpAddr;
                AddrInit(&tmpAddr, 0, 0, NextOffset, TRUE, TRUE, FALSE, FALSE);
                tmpBP = SetBP( hprc, hthd, bptpExec, bpnsStop, &tmpAddr, (HPID) INVALID );
                assert(tmpBP);
            } else {
                assert(FALSE);
            }
            /* Get off SS */
            VERIFY(ContinueDebugEvent(hprc->pid, hthd->tid, DBG_CONTINUE));
            if (WaitForDebugEvent(de, INFINITE)) {
                assert(de->dwDebugEventCode == EXCEPTION_DEBUG_EVENT);
            } else {
                //
                // BUGBUG kentf This is certain to occur.
                //
                assert(FALSE);
            }
            hthd->context.ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;
            VERIFY(GetThreadContext(hthd->rwHand, &hthd->context));
            hthd->fContextDirty = FALSE;
            hthd->fIsCallDone = FALSE;
            RemoveBP(tmpBP);
            /* Resume all threads except this one */
            for (hthdCurr = hprc->hthdChild; hthdCurr != NULL; hthdCurr = hthdCurr->nextSibling) {
                if (hthdCurr != hthd) {
                    if (ResumeThread(hthdCurr->rwHand) == -1L) {
                        assert(FALSE); // Internal error;
                    }
                }
            }

            if (bp == NULL) {
                bp = SetBP(hprc, hthd, bptpExec, bpnsStop, &addr, FALSE);
            } else {
            /* Put back SS */
                AddrWriteMemory(hprc, hthd, &bp->addr, (LPBYTE)&opcode, BP_SIZE, &i);
                bp->instances++;
            }
            bp->isStep++;
            SetDebugEventThreadState (hthd->hprc, ts_running);
            AddQueue( QT_CONTINUE_DEBUG_EVENT,
                      hthd->hprc->pid,
                      hthd->tid,
                      (DWORD)DBG_CONTINUE,
                      0);
            return;
        }
#endif // NO_TRACE_BIT
#endif // DOLPHIN
        break;


    default:


        /*
         *  The user can define a set of exceptions for which we do not do
         *      notify the shell on a first chance occurance.
         */

#if defined (TARGET_i386) && !defined (KERNEL)

        //
        // If we are stepping (=> trace flag set) and we are attempting
        // to step on a statement that raising an exception that gets
        // caught somewhere else, then having the trace flag set
        // prevents us from ending up where the NLG thing takes us.
        // Turn it off & assume that we will get a second chance.
        // This is wrong for disasm stepping and may be otherwise
        // problematic.
        //

        HthdReg(hthd,EFlags) &= ~TF_BIT_MASK;
        hthd->fContextDirty = TRUE;
#endif

        if (!firstChance) {

            DPRINT(3, (_T("2nd Chance Exception %08lx.\n"),subclass));
            hthd->tstate |= ts_second;

        } else {

            hthd->tstate |= ts_first;

            switch (ExceptionAction(hthd->hprc,subclass)) {

              case efdNotify:

                NotifyEM(de,hthd,0,(LPVOID)bp);
                // fall through to ignore case

              case efdIgnore:

                DPRINT(3, (_T("Ignoring Exception %08lx.\n"),subclass));
                SetDebugEventThreadState (hthd->hprc, ts_running);
                AddQueue( QT_CONTINUE_DEBUG_EVENT,
                          hthd->hprc->pid,
                          hthd->tid,
                          (DWORD)DBG_EXCEPTION_NOT_HANDLED,
                          0);
                return;

              case efdStop:
              case efdCommand:
                break;
            }
        }

        break;
    }

    // Cleanup ...

    hthd->fReturning = FALSE;
    ConsumeAllThreadEvents(hthd, FALSE);

    //ExprBPStop(hthd->hprc, hthd);
    NotifyEM(de,hthd,0,(LPVOID)bp);
}                                   /* ProcessExceptionEvent() */


void
ProcessRipEvent(
    DEBUG_EVENT   * de,
    HTHDX           hthd
    )
{
    if (hthd) {
        hthd->tstate |= ts_rip;
    }
    NotifyEM( de, hthd, 0,NULL );
}                               /* ProcessRipEvent() */


void
ProcessBreakpointEvent(
    DEBUG_EVENT   * pde,
    HTHDX           hthd
    )
{
	BOOL		fBreak = FALSE;
    MSGI		msgi;
	LPVOID		lpv = 0;
    PBREAKPOINT pbp = (BREAKPOINT*)pde->u.Exception.ExceptionRecord.ExceptionCode;


    DPRINT(1, (_T("Hit a breakpoint -- ")));

    if (!pbp) {

        DPRINT(1, (_T("[Embedded BP]\n")));
		fBreak = TRUE;
		lpv = pbp;

    } else if (!pbp->hthd || pbp->hthd == hthd) {

        DPRINT(1, (_T("[One of our own BP's.]\n")));
        if (pbp->bpType == bptpMessage) {

            if (!GetWndProcMessage (hthd, &msgi.dwMessage)) {
                assert (FALSE);
			}

            msgi.dwMask = 0;        // mask is currently unused in the dm
            msgi.addr = pbp->addr;
			pde->dwDebugEventCode = MESSAGE_DEBUG_EVENT;

			lpv = &msgi;
			fBreak = TRUE;

        } else if (CheckDataBP (hthd, pbp)) {

            if ((pbp->bpNotify == bpnsStop) ||
                (pbp->bpNotify == bpnsCheck && CheckBpt(hthd, pbp))) {
				
				fBreak = TRUE;
				lpv = pbp;
				
            } else {

                if (pbp->bpNotify == bpnsContinue) {
                    // NotifyEM(...);
                }
				fBreak = FALSE;
            }
        } else {
			fBreak = FALSE;
        }

    } else {

        DPRINT(1, (_T("[BP for another thread]\n")));

        //
        // data bp should never hit on the wrong thread
        //
        assert (pbp->hWalk == NULL);

		fBreak = FALSE;

    }

	if (hthd->hprc->pstate & ps_breaking) {

		if (pbp) {
			SetBPFlag (hthd, pbp);
		}
		_asm int 3
		//ActionAsyncStop (NULL, hthd, 0, NULL);

	} else if (fBreak) {

		if (pbp) {
			SetBPFlag (hthd, pbp);
		}
		ConsumeAllThreadEvents (hthd, FALSE);
		NotifyEM (pde, hthd, 0, lpv);

	} else {

		ContinueFromBP (hthd, pbp);
	}
}

VOID
ContinueFromBP(
    HTHDX hthd,
    PBREAKPOINT pbp
    )
{
    void MethodContinueSS(DEBUG_EVENT*, HTHDX, DWORD, METHOD*);
    METHOD *ContinueSSMethod;
    if (!AtBP(hthd)) {
        ExprBPContinue( hthd->hprc, hthd );
        SetDebugEventThreadState (hthd->hprc, ts_running);
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
    } else {
        ContinueSSMethod = (METHOD*)MHAlloc(sizeof(METHOD));
        ContinueSSMethod->notifyFunction = (ACVECTOR)MethodContinueSS;
        ContinueSSMethod->lparam         = ContinueSSMethod;
        ContinueSSMethod->lparam2        = pbp;
        if(pbp && pbp != EMBEDDED_BP)
            ++pbp->cthd;

        RestoreInstrBP(hthd, pbp);
        SingleStep(hthd, ContinueSSMethod, FALSE, FALSE);
    }
}


VOID
StuffHthdx(
    DEBUG_EVENT *de,
    HPRCX hprc,
    HTHDX hthd
    )
/*++

Routine Description:

    Common code for CreateProcess and CreateThread events.  Stuff
    the hthd with default values, add the new structure to the process'
    chain.  Critical section csThreadProcList must be held when calling
    this routine.

Arguments:

    de - Supplies debug event

    hprc - Supplies process structure

    hthd - Supplies empty thread struct, returns full one.

Return Value:


--*/
{
    hthd->next          = thdList->next;
    thdList->next       = hthd;

    hthd->nextSibling   = hprc->hthdChild;
    hprc->hthdChild     = (LPVOID)hthd;

    hthd->hprc          = hprc;
    hthd->htid          = 0;
    hthd->atBP          = (BREAKPOINT*)0;
    hthd->tstate        = ts_stopped;

    hthd->fAddrIsReal   = FALSE;
    hthd->fAddrIsFlat   = TRUE;
    hthd->fAddrOff32    = TRUE;
    hthd->fWowEvent     = FALSE;
    hthd->fStopOnNLG    = FALSE;
    hthd->fReturning    = FALSE;
    hthd->fDisplayReturnValues = TRUE;
#ifdef KERNEL
    hthd->fContextStale = TRUE;
#endif
#if 0
#ifndef KERNEL
    hthd->pcs           = NULL;
    hthd->poleret       = NULL;
#endif
#endif
    InitializeListHead(&hthd->WalkList);
    hthd->WalkData = NULL;

    hthd->tid           = de->dwThreadId;
    if (de->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        hthd->rwHand        = de->u.CreateProcessInfo.hThread;
        hthd->offTeb        = (OFFSET) de->u.CreateProcessInfo.lpThreadLocalBase;
        hthd->lpStartAddress= (LPVOID) de->u.CreateProcessInfo.lpStartAddress;
    } else {
        hthd->rwHand        = de->u.CreateThread.hThread;
        hthd->offTeb        = (OFFSET) de->u.CreateThread.lpThreadLocalBase;
        hthd->lpStartAddress= (LPVOID) de->u.CreateThread.lpStartAddress;
    }
	hthd->szThreadName[0] = 0;
	//hthd->fSoftBroken = FALSE;
}


void
ProcessCreateProcessEvent(
    DEBUG_EVENT   * pde,
    HTHDX           hthd
    )
/*++

Routine Description:

    This routine does the processing needed for a create process
    event from the OS.  We need to do the following:

      - Set up our internal structures for the newly created thread
        and process
      - Get notifications back to the debugger

Arguments:

    pde    - Supplies pointer to the DEBUG_EVENT structure from the OS

    hthd   - Supplies thread descriptor that thread event occurred on

Return Value:

    none

--*/
{
    DEBUG_EVENT                 de2;
    CREATE_PROCESS_DEBUG_INFO  *pcpd = &pde->u.CreateProcessInfo;
    HPRCX                       hprc;
    LPBYTE                      lpbPacket;
    WORD                        cbPacket;

    DEBUG_PRINT(_T("ProcessCreateProcessEvent\r\n"));

    ResetEvent(hEventCreateProcess);

    hprc = InitProcess((HPID)INVALID);

    //
    // Stuff the process structure
    //

    if (fUseRoot) {
        hprc->pstate           |= ps_root;
        hprc->hpid              = hpidRoot;
        fUseRoot                = FALSE;
        hprc->f16bit = FALSE;
    }

    hprc->pid     = pde->dwProcessId;
	// mark the process as connecting so we can sort things out
    hprc->pstate  = ps_preStart | ps_connect;

#ifndef KERNEL
    hprc->lastTidDebugEvent = pde->dwThreadId;
#endif

    ResetEvent(hprc->hEventCreateThread);


    //
    // Create the first thread structure for this app
    //

    hthd = (HTHDX)MHAlloc(sizeof(HTHDXSTRUCT));
    memset(hthd, 0, sizeof(*hthd));

    EnterCriticalSection(&csThreadProcList);

    StuffHthdx(pde, hprc, hthd);

    LeaveCriticalSection(&csThreadProcList);


#ifndef KERNEL
#if defined(TARGET_i386)
    hthd->ctx.ContextFlags = CONTEXT_FULL;
    DbgGetThreadContext( hthd, &hthd->ctx );
    hprc->segCode = (SEGMENT) HthdReg(hthd,SegCs);
#endif  // i386
#endif  // !KERNEL


#if 0
#ifndef KERNEL
    //
    // try to create a handle with more permissions
    //
    if (!CrashDump) {
        hprc->rwHand = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pde->dwProcessId);
        if (!hprc->rwHand) {
            hprc->rwHand = pcpd->hProcess;
        }
    }
#endif // KERNEL
#endif

    /*
     * There is going to be a breakpoint to announce that the
     * process is loaded and runnable.
     */
    nWaitingForLdrBreakpoint++;
    if (pcpd->lpStartAddress == NULL) {
        // in an attach, the BP will be in another thread.
        RegisterExpectedEvent( hprc,
                               (HTHDX)NULL,
                               BREAKPOINT_DEBUG_EVENT,
                               NO_SUBCLASS,
                               DONT_NOTIFY,
                               (ACVECTOR)ActionDebugActiveReady,
                               FALSE,
                               hprc);
#ifndef KERNEL
#if defined(INTERNAL)
        // don't ever let it defer name resolutions
        hprc->fNameRequired = TRUE;
#endif
#endif

    } else {
        // On a real start, the BP will be in the first thread.
        RegisterExpectedEvent( hthd->hprc,
                               hthd,
                               BREAKPOINT_DEBUG_EVENT,
                               NO_SUBCLASS,
                               DONT_NOTIFY,
                               (ACVECTOR)ActionDebugNewReady,
                               FALSE,
                               hprc);
    }

    /*
     * Notify the EM of this newly created process.
     * If not the root proc, an hpid will be created and added
     * to the hprc by the em.
     */
    NotifyEM(pde, hthd, 0,hprc);

#ifndef KERNEL
    /*
     *  We also need to drop out a module load notification
     *  on this exe.
     */

    de2.dwDebugEventCode        = LOAD_DLL_DEBUG_EVENT;
    de2.dwProcessId             = pde->dwProcessId;
    de2.dwThreadId              = pde->dwThreadId;
    de2.u.LoadDll.hFile         = pde->u.CreateProcessInfo.hFile;
    de2.u.LoadDll.lpBaseOfDll   = pde->u.CreateProcessInfo.lpBaseOfImage;
    de2.u.LoadDll.lpImageName   = pde->u.CreateProcessInfo.lpImageName;
    de2.u.LoadDll.fUnicode      = pde->u.CreateProcessInfo.fUnicode;

    if (LoadDll(&de2, hthd, &cbPacket, &lpbPacket) && (cbPacket != 0)) {
        LeaveCriticalSection(&csProcessDebugEvent);
        NotifyEM(&de2, hthd, cbPacket, lpbPacket);
        EnterCriticalSection(&csProcessDebugEvent);
    }
#endif // !KERNEL
	// until we get loaddll working, let's try this
	SetDebugEventThreadState(hprc, ts_running);

    /*
     * Fake up a thread creation notification.
     */
    pde->dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
    NotifyEM(pde, hthd, 0, hprc);

    /*
     * Dont let the new process run:  the shell will say Go()
     * after receiving a CreateThread event.
     */

}                              /* ProcessCreateProcessEvent() */


void
ProcessCreateThreadEvent(
    DEBUG_EVENT    *pde,
    HTHDX           creatorHthd
    )
{
    CREATE_THREAD_DEBUG_INFO  * ctd = &pde->u.CreateThread;
    HTHDX                       hthd;
    HTHDX                       hthdT;
    HPRCX                       hprc;
    CONTEXT                     context;
#if defined(KERNEL) && defined(HAS_DEBUG_REGS)
    KSPECIAL_REGISTERS          ksr;
#endif // KERNEL && i386

    Unreferenced(creatorHthd);

    DPRINT(3, (_T("\n***CREATE THREAD EVENT\n")));

    //
    // Determine the hprc
    //
    hprc= HPRCFromPID(pde->dwProcessId);

    ResetEvent(hprc->hEventCreateThread);

#if 0
    if (ctd->hThread == NULL) {
        DPRINT(1, (_T("BAD HANDLE! BAD HANDLE!(%08lx)\n"), ctd->hThread));
        AddQueue( QT_CONTINUE_DEBUG_EVENT, pde->dwProcessId, pde->dwThreadId, DBG_CONTINUE, 0);
        return;
    }
#endif

    if (!hprc) {
        DPRINT(1, (_T("BAD PID! BAD PID!\n")));
        AddQueue( QT_CONTINUE_DEBUG_EVENT, pde->dwProcessId, pde->dwThreadId, DBG_CONTINUE, 0);
        return;
    }

    //
    // Create the thread structure
    //
    hthd = (HTHDX)MHAlloc(sizeof(HTHDXSTRUCT));
    memset( hthd, 0, sizeof(*hthd));

    //
    // Stuff the structure
    //

    EnterCriticalSection(&csThreadProcList);

    StuffHthdx(pde, hprc, hthd);

    LeaveCriticalSection(&csThreadProcList);

#ifndef KERNEL
    hprc->lastTidDebugEvent = pde->dwThreadId;
#endif

    //
    //  Let the expression breakpoint manager that a new thread
    //  has been created.
    //

    ExprBPCreateThread( hprc, hthd );

    //
    // initialize cache entries
    //

    context.ContextFlags = CONTEXT_FULL;
    DbgGetThreadContext( hthd, &context );

#if defined(KERNEL) && defined(HAS_DEBUG_REGS)
    GetExtendedContext( hthd, &ksr );
#endif  // KERNEL && i386

    //
    //  Notify the EM of this new thread
    //

    if (fDisconnected) {
        SetDebugEventThreadState (hthd->hprc, ts_running);
        AddQueue (QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);

    } else {
        NotifyEM(pde, hthd, 0, hprc);
    }

    return;
}


#ifndef KERNEL
VOID
UnloadAllModules(
    HPRCX           hprc,
    HTHDX           hthd
    )
{
    DEBUG_EVENT     de;
    DWORD           i;


    for (i=0; i<(DWORD)hprc->cDllList; i++) {
        if ((hprc->rgDllList[i].fValidDll) &&  (!hprc->rgDllList[i].fWow)) {
            de.dwDebugEventCode = UNLOAD_DLL_DEBUG_EVENT;
            de.dwProcessId = hprc->pid;
            de.dwThreadId = hthd ? hthd->tid : 0;
            de.u.UnloadDll.lpBaseOfDll = (LPVOID)hprc->rgDllList[i].offBaseOfImage;
            NotifyEM( &de, hthd, 0, NULL );
            DestroyDllLoadItem( &hprc->rgDllList[i] );
        }
    }

    return;
}
#endif // !KERNEL


void
ProcessExitProcessEvent(
    DEBUG_EVENT* pde,
    HTHDX hthd
    )
{
    HPRCX               hprc;
    XOSD                xosd;
    HTHDX               hthdT;
	DWORD				flag;

    /*
     * do all exit thread handling:
     *
     * If thread was created during/after the
     * beginning of termination processing, we didn't
     * pick it up, so don't try to destroy it.
     */

    if (!hthd) {
        hprc = HPRCFromPID (pde->dwProcessId);
    } else {
        hprc = hthd->hprc;
    }

	flag = InterlockedSetFlag (&hprc->fExited);

	if (hthd) {
		hthd->tstate |= ts_dead;
		hthd->dwExitCode = pde->u.ExitProcess.dwExitCode;
	}

    ConsumeAllProcessEvents (hprc, TRUE);

	/*
     * If process hasn't initialized yet, we were expecting
     * a breakpoint to notify us that all the DLLs are here.
     * We didn't get that yet, so reply here.
     */

	if (hprc->pstate & ps_preStart) {
		assert (FALSE); // MATH: review
        xosd = xosdUnknown;
        DmTlFunc( tlfReply, hprc->hpid, sizeof(XOSD), (LONG)(LPV) &xosd);
    }

	for (hthdT = hprc->hthdChild; hthdT; hthdT = hthdT->nextSibling) {
		if ( !(hthdT->tstate & ts_dead) ) {
			hthdT->tstate |= ts_dead;
			hthdT->tstate &= ~ts_stopped;
		}
	}

	hprc->pstate |= ps_dead;
	hprc->dwExitCode = pde->u.ExitProcess.dwExitCode;

	RemoveFiberList (hprc);


	if (!(hprc->pstate & ps_killed)) {

		assert (hprc->hExitFailed == NULL);
		UnloadAllModules (hprc, hthd ? hthd : hprc->hthdChild);
		RemoveAllHprcBP (hprc);

        assert (hthd);
        pde->dwDebugEventCode = EXIT_THREAD_DEBUG_EVENT;
        pde->u.ExitThread.dwExitCode = hprc->dwExitCode;
        NotifyEM (pde, hthd, 0, (LPVOID)0);

	} else {
	
		/*
         * If ProcessTerminateProcessCmd() killed this,
         * silently continue the event and release the semaphore.
         *
         * Don't notify the EM of anything; ProcessUnloadCmd()
         * will do that for any undestroyed threads.
         */

		if (hprc->hExitFailed) {
			VERIFY (RemoveTimerEvent (hprc, hprc->hExitFailed));
			hprc->hExitFailed = NULL;
		}

		assert (hprc->pstate & ps_killed);

#if 0
		AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  pde->dwProcessId,
                  pde->dwThreadId,
                  DBG_CONTINUE,
                  0);
#endif

		if (flag == FLAG_SET) {
			ProcessUnloadCmd (hprc, NULL, NULL);
		}
	}

    //DMSqlTerminate (hprc);
}


void
ProcessExitThreadEvent(
    DEBUG_EVENT* pde,
    HTHDX hthd
    )
{
    HPRCX       hprc = hthd->hprc;

    DPRINT(3, (_T("***** ProcessExitThreadEvent, hthd == %x\n"), (DWORD)hthd));


    hthd->tstate |= ts_dead;

    if (hthd->tstate & ts_frozen) {
        //ResumeThread(hthd->rwHand);
        hthd->tstate &= ~ts_frozen;
    }

    hthd->dwExitCode = pde->u.ExitThread.dwExitCode;

    /*
     *  Free all events for this thread
     */

    ConsumeAllThreadEvents(hthd, TRUE);

    //
    //  Let the Expression Breakpoint manager know that this thread
    //  is gone.
    //
    ExprBPExitThread( hprc, hthd );


    if (hprc->pstate & ps_killed) {

    // BUGBUG: This should be set to stopped.
//      hthd->tstate &= ~ts_stopped;
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
    } else if (fDisconnected) {
        hthd->hprc->pstate |= ps_exited;
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
    } else {
        NotifyEM(pde, hthd, 0, (LPVOID)0);
    }

    return;
}                                      /* ProcessExitThreadEvent() */


void
ProcessLoadDLLEvent(
    DEBUG_EVENT* de,
    HTHDX hthd
)
{
#ifndef KERNEL
    LPBYTE lpbPacket;
    WORD   cbPacket;

    if (LoadDll(de, hthd, &cbPacket, &lpbPacket) || (cbPacket == 0)) {
        LeaveCriticalSection(&csProcessDebugEvent);
        NotifyEM(de, hthd, cbPacket, lpbPacket);
        EnterCriticalSection(&csProcessDebugEvent);
    }

	SetDebugEventThreadState (hthd->hprc, ts_running);

	/* Can't continue if we're still connecting */
	if(!(hthd->hprc->pstate & ps_connect)) {
		AddQueue( QT_CONTINUE_DEBUG_EVENT,
				  hthd->hprc->pid,
				  hthd->tid,
				  DBG_CONTINUE,
				  0);
	}

#endif // !KERNEL


#ifdef KERNEL
    NotifyEM(de, hthd, 0, (LPVOID)0);

    SetDebugEventThreadState (hthd->hprc, ts_running);
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);
#endif // KERNEL

    return;
}                                      /* ProcessLoadDLLEvent() */


void
ProcessUnloadDLLEvent(
    DEBUG_EVENT* pde,
    HTHDX hthd
    )
{
    int         iDll;
    HPRCX       hprc = hthd->hprc;

    DPRINT(10, (_T("*** UnloadDll %x\n"), pde->u.UnloadDll.lpBaseOfDll));

    for (iDll = 0; iDll < hprc->cDllList; iDll++) {
        if (hprc->rgDllList[iDll].fValidDll &&
            (hprc->rgDllList[iDll].offBaseOfImage ==
             (OFFSET) pde->u.UnloadDll.lpBaseOfDll)) {
            break;
        }
    }

    /*
     *  Make sure that we found a legal address.  If not then assert
     *  and check for problems.
     */

#ifndef KERNEL
    // this happens all the time in kernel mode
    // when user mode modloads are enabled
    assert( iDll != hprc->cDllList );
#endif

    if (iDll != hprc->cDllList) {

        if (!fDisconnected) {
			OutputDebugString("Unloading DLL ");
			OutputDebugString(hprc->rgDllList[iDll].szDllName);
            LeaveCriticalSection(&csProcessDebugEvent);
            NotifyEM(pde, hthd, 0, (LPVOID)0);
            EnterCriticalSection(&csProcessDebugEvent);
        }

        DestroyDllLoadItem( &hprc->rgDllList[iDll] );
    }

    SetDebugEventThreadState (hthd->hprc, ts_running);
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);
    return;
}

#ifdef OMNI
//
//  Omni JIT support
//
VOID ProcessOmniDllLoadEvent(DEBUG_EVENT* pdeIn, HTHDX hthd)
{
    HPRCX hprc = hthd->hprc;


    EXCEPTION_DEBUG_INFO *pExceptDebugInfo = &(pdeIn->u.Exception);
	DEBUG_EVENT de;
    LPBYTE lpbPacket;
    WORD   cbPacket;

 	assert(pExceptDebugInfo->ExceptionRecord.NumberParameters == 5);
	de.dwDebugEventCode = LOAD_DLL_DEBUG_EVENT;
    de.dwProcessId = hprc->pid;
    de.dwThreadId = hthd->tid;
    de.u.LoadDll.hFile = NULL;
    de.u.LoadDll.lpBaseOfDll = (LPVOID) pExceptDebugInfo->ExceptionRecord.ExceptionInformation[0];
    de.u.LoadDll.dwDebugInfoFileOffset = (DWORD)pExceptDebugInfo->ExceptionRecord.ExceptionInformation[1];
    de.u.LoadDll.nDebugInfoSize = 0;
    de.u.LoadDll.lpImageName = (LPVOID) pExceptDebugInfo->ExceptionRecord.ExceptionInformation[2];
    de.u.LoadDll.fUnicode = (WORD) pExceptDebugInfo->ExceptionRecord.ExceptionInformation[3];

    if (LoadDll5Parm(&de, hthd, &cbPacket, &lpbPacket, (LPVOID)pExceptDebugInfo->ExceptionRecord.ExceptionInformation[4]) ||
		(cbPacket == 0)) {
        LeaveCriticalSection(&csProcessDebugEvent);
        NotifyEM(&de, hthd, cbPacket, lpbPacket);
        EnterCriticalSection(&csProcessDebugEvent);
    }

    SetDebugEventThreadState (hthd->hprc, ts_running);
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);


	return;

}

#endif

void
DestroyDllLoadItem(
    PDLLLOAD_ITEM pDll
    )
{
    if (pDll->szDllName) {
        MHFree(pDll->szDllName);
        pDll->szDllName = NULL;
    }

#ifdef KERNEL
    if (pDll->sec) {
        MHFree(pDll->sec);
        pDll->sec = NULL;
    }
#endif

	if (pDll->Sections) {
		MHFree (pDll->Sections);
		pDll->Sections = NULL;
	}

    pDll->offBaseOfImage = 0;
    pDll->cbImage = 0;
    pDll->fValidDll = FALSE;

    return;
}


void
ProcessOutputDebugStringEvent(
    DEBUG_EVENT* de,
    HTHDX hthd
    )
/*++

Routine Description:

    Handle an OutputDebugString from the debuggee

Arguments:

    de      - Supplies DEBUG_EVENT struct

    hthd    - Supplies thread descriptor for thread
              that generated the event

Return Value:

    None

--*/
{
    int     cb = de->u.DebugString.nDebugStringLength;

#if DBG
    char    rgch[256];
    HANDLE  rwHand;

    if (FVerbose) {
        cb = min(cb, 256);
        rwHand = hthd->hprc->rwHand;
		memcpy(rgch, de->u.DebugString.lpDebugStringData, cb);
        rgch[cb] = 0;

        DPRINT(3, (_T("%s\n"), rgch));
    }
#endif

    NotifyEM(de, hthd, 0, NULL);

    SetDebugEventThreadState (hthd->hprc, ts_running);
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);

    return;
}

#ifndef KERNEL

void
ProcessBogusSSEvent(
    DEBUG_EVENT* de,
    HTHDX hthd
    )
/*++

Routine Description:

    Handle a Bogus Win95 Single step event. Just continue execution
        as if nothing happened.

Arguments:

    de      - Supplies DEBUG_EVENT struct

    hthd    - Supplies thread descriptor for thread
              that generated the event

Return Value:

    None

--*/
{
    SetDebugEventThreadState (hthd->hprc, ts_running);
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);
    return;
}

void 
HandleDisappearedProcess(
    HPRCX hprc
)
{
    DEBUG_EVENT de;
    HTHDX hthd;

    assert(hprc);

    de.dwProcessId = hprc->pid;
    de.dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
    de.u.ExitProcess.dwExitCode = 0;
    hthd = hprc->hthdChild;
    if (hthd) {
        de.dwThreadId = hthd->tid;
    } else {
        de.dwThreadId = 0;
    }

    ProcessDebugEvent(&de);
    return;
}       /* HandleDisappearedProcess */

#endif


void
Reply(
    UINT   length,
    LPVOID lpbBuffer,
    HPID   hpid
    )
/*++

Routine Description:

    Send a reply packet to a tlfRequest from the EM

Arguments:

    length      - Supplies length of reply
    lpbBuffer   - Supplies reply data
    hpid        - Supplies handle to EM process descriptor

Return Value:

    None

--*/
{
    /*
     *  Add the size of the packet header to the length
     */

    length += FIELD_OFFSET(DM_MSG, rgb);

    DPRINT(5, (_T("Reply to EM [%d]\n"), length));

    assert(length <= sizeof(abDMReplyBuf) || lpbBuffer != abDMReplyBuf);

    if (DmTlFunc) { // IF there is a TL loaded, reply
        DmTlFunc(tlfReply, hpid, length, (LONG)(LPV) lpbBuffer);
    }

    return;
}


VOID FAR PASCAL
DMFunc(
    DWORD cb,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This is the main entry point for the DM.  This takes dmf
    message packets from the debugger and handles them, usually
    by dispatching to a worker function.

Arguments:

    cb      - supplies size of data packet

    lpdbb   - supplies pointer to packet

Return Value:


--*/
{
    DMF     dmf;
    HPRCX   hprc;
    HTHDX   hthd;
    XOSD    xosd = xosdNone;

    dmf = (DMF) (lpdbb->dmf & 0xffff);
    DEBUG_PRINT(_T("DMFunc\r\n"));

    DPRINT(5, (_T("DmFunc [%2x] "), dmf));

    hprc = HPRCFromHPID(lpdbb->hpid);
    hthd = HTHDXFromHPIDHTID(lpdbb->hpid, lpdbb->htid);


    switch ( dmf ) {
#ifndef OSDEBUG4
      case dmfGetPrompt:
        {
        LPPROMPTMSG pm;
        DPRINT(5, (_T("dmfGetPrompt\n")));
        pm = (LPPROMPTMSG) LpDmMsg->rgb;
        *pm = *((LPPROMPTMSG) lpdbb->rgbVar);
        memcpy( pm, lpdbb->rgbVar, pm->len+sizeof(PROMPTMSG) );

#if   defined(KERNEL) && defined(TARGET_i386)
        _ftcscpy( pm->szPrompt, _T("KDx86> ") );
#elif defined(KERNEL) && defined(TARGET_PPC)
        _ftcscpy( pm->szPrompt, _T("KDppc> ") );
#elif defined(KERNEL) && defined(TARGET_MIPS)
        _ftcscpy( pm->szPrompt, _T("KDmips> ") );
#elif defined(KERNEL) && defined(TARGET_ALPHA)
        _ftcscpy( pm->szPrompt, _T("KDalpha> ") );
#elif defined(KERNEL)

#pragma error( "unknown target machine" );

#else

        // don't change prompt in user mode

#endif

        LpDmMsg->xosdRet = xosdNone;
        Reply( pm->len+sizeof(PROMPTMSG), LpDmMsg, lpdbb->hpid );
        }
        break;
#endif  // !OSDEBUG4

      case dmfSelLim:
        DPRINT(5, (_T("dmfSelLim\n")));
        ProcessSelLimCmd(hprc, hthd, lpdbb);
        break;

      case dmfSetMulti:
        DPRINT(5, (_T("dmfSetMulti\n")));
        LpDmMsg->xosdRet = xosdNone;
        Reply( 0, LpDmMsg, lpdbb->hpid );
        break;

      case dmfClearMulti:
        DPRINT(5, (_T("dmfClearMulti\n")));
        LpDmMsg->xosdRet = xosdNone;
        Reply( 0, LpDmMsg, lpdbb->hpid );
        break;

      case dmfDebugger:
        DPRINT(5, (_T("dmfDebugger\n")));
        LpDmMsg->xosdRet = xosdNone;
        Reply( 0, LpDmMsg, lpdbb->hpid );
        break;

      case dmfCreatePid:
        DPRINT(5,(_T("dmfCreatePid\r\n")));
        ProcessCreateProcessCmd(hprc, hthd, lpdbb);
        break;

      case dmfDestroyPid:
        DPRINT(5, (_T("dmfDestroyPid\n")));
        LpDmMsg->xosdRet = FreeProcess(hprc, TRUE);
        Reply( 0, LpDmMsg, lpdbb->hpid);
        break;

      case dmfSpawnOrphan:
        DPRINT(5, (_T("dmfSpawnOrphan\n")));
        ProcessSpawnOrphanCmd (hprc, hthd, lpdbb);
        break;

      case dmfProgLoad:
        DPRINT(5, (_T("dmfProgLoad\n")));
        if(!fApprovedAttach) {
            fApprovedAttach = TRUE;
            xosd = AttachOrReboot();
        }
        if(xosd == xosdNone)
            ProcessProgLoadCmd(hprc, hthd, lpdbb);
        else
            Reply( 0, &xosd, lpdbb->hpid);
        break;

      case dmfProgFree:
        DPRINT(5, (_T("dmfProgFree\n")));


#ifndef KERNEL

        ProcessTerminateProcessCmd(hprc, hthd, lpdbb);

#else // KERNEL
        if (!hprc) {
            LpDmMsg->xosdRet = xosdNone;
            Reply( 0, LpDmMsg, lpdbb->hpid);
            break;
        }

        if (KdOptions[KDO_GOEXIT].value) {
            HTHDX hthdT;
            PBREAKPOINT bp;
            KdOptions[KDO_GOEXIT].value = 0;
            for (hthdT = hprc->hthdChild; hthdT; hthdT = hthdT->nextSibling) {
                if (hthdT->tstate & ts_stopped) {
                    if (bp = AtBP(hthdT)) {
                        if (!hthdT->fDontStepOff) {
                            IncrementIP(hthdT);
                        }
                    }
                    if (hthdT->fContextDirty) {
                        DbgSetThreadContext( hthdT, &hthdT->context );
                        hthdT->fContextDirty = FALSE;
                    }
                    KdOptions[KDO_GOEXIT].value = 1;
                    break;
                }
            }
        }

        ClearBps();

        ProcessTerminateProcessCmd(hprc, hthd, lpdbb);
        ProcessUnloadCmd(hprc, hthd, lpdbb);

        if (KdOptions[KDO_GOEXIT].value) {
            ContinueTargetSystem( DBG_CONTINUE, NULL );
        }


#endif  // KERNEL

        LpDmMsg->xosdRet = xosdNone;
        Reply( 0, LpDmMsg, lpdbb->hpid);
        break;

      case dmfBreakpoint:
        DEBUG_PRINT(_T("dmfBreakpoint\r\n"));
        ProcessBreakpointCmd(hprc, hthd, lpdbb);
        break;

      case dmfReadMem:
        // This replies in the function
        DPRINT(5, (_T("dmfReadMem\n")));
        ProcessReadMemoryCmd(hprc, hthd, lpdbb);
        break;

      case dmfWriteMem:
        DPRINT(5, (_T("dmfWriteMem\n")));
        ProcessWriteMemoryCmd(hprc, hthd, lpdbb);
        break;

      case dmfReadReg:
        DPRINT(5, (_T("dmfReadReg\n")));
        ProcessGetContextCmd(hprc, hthd, lpdbb);
        break;

      case dmfWriteReg:
        DPRINT(5, (_T("dmfWriteReg\n")));
        ProcessSetContextCmd(hprc, hthd, lpdbb);
        break;

#ifdef HAS_DEBUG_REGSNOTREALLY
      case dmfReadRegEx:
        DPRINT(5, (_T("dmfReadRegEx\n")));
#ifdef KERNEL
        ProcessGetExtendedContextCmd(hprc, hthd, lpdbb);
#else
        ProcessGetDRegsCmd(hprc, hthd, lpdbb);
#endif
        break;

      case dmfWriteRegEx:
        DPRINT(5, (_T("dmfWriteRegEx\n")));
#ifdef KERNEL
        ProcessSetExtendedContextCmd(hprc, hthd, lpdbb);
#else
        ProcessSetDRegsCmd(hprc, hthd, lpdbb);
#endif
        break;

#else   // HAS_DEBUG_REGS
      case dmfReadRegEx:
      case dmfWriteRegEx:
        DEBUG_PRINT(_T("Read/WriteRegEx\r\n"));
        //assert(dmf != dmfReadRegEx && dmf != dmfWriteRegEx);
        LpDmMsg->xosdRet = xosdUnknown;
        Reply( 0, LpDmMsg, lpdbb->hpid );
        break;
#endif  // HAS_DEBUG_REGS

      case dmfGo:
        DPRINT(5, (_T("dmfGo\n")));
#if !defined(KERNEL)
        //Turn off fiber debugging
        hprc->pFbrCntx = NULL;
#endif
        ProcessContinueCmd(hprc, hthd, lpdbb);
        break;

#if defined(KERNEL)
      case dmfTerm:
        DPRINT(5, (_T("dmfTerm\n")));
        ProcessTerminateProcessCmd(hprc, hthd, lpdbb);
        break;
#endif

      case dmfStop:
        DPRINT(5, (_T("dmfStop\n")));
        ProcessAsyncStopCmd(hprc, hthd, lpdbb);
        break;

      case dmfFreeze:
        DPRINT(5, (_T("dmfFreeze\n")));
        ProcessFreezeThreadCmd(hprc, hthd, lpdbb);
        break;

      case dmfResume:
        DPRINT(5, (_T("dmfResume\n")));
        ProcessAsyncGoCmd(hprc, hthd, lpdbb);
        break;

      case dmfInit:
        DPRINT(5, (_T("dmfInit\n")));
        fApprovedAttach = FALSE;
        Reply( 0, &xosd, lpdbb->hpid);
        break;

      case dmfUnInit:
        DPRINT(5, (_T("dmfUnInit\n")));
#ifdef KERNEL
        DmPollTerminate();
#else
        Cleanup();
#endif
        Reply ( 1, LpDmMsg, lpdbb->hpid);
        break;


      case dmfGetDmInfo:
        DEBUG_PRINT(_T("getDmInfo\r\n"));
        ProcessGetDmInfoCmd(hprc, lpdbb, cb);
        break;

    case dmfSetupExecute:
        DPRINT(5, (_T("dmfSetupExecute\n")));
        ProcessSetupExecuteCmd(hprc, hthd, lpdbb);
        break;

    case dmfStartExecute:
        DPRINT(5, (_T("dmfStartExecute\n")));
        ProcessStartExecuteCmd(hprc, hthd, lpdbb);
        break;

    case dmfCleanUpExecute:
        DPRINT(5, (_T("dmfCleanupExecute\n")));
        ProcessCleanUpExecuteCmd(hprc, hthd, lpdbb);
        break;

    case dmfSystemService:
        ProcessSystemServiceCmd( hprc, hthd, lpdbb );
        break;

    case dmfDebugActive:
        DPRINT(5, (_T("dmfDebugActive\n")));
        ProcessDebugActiveCmd( hprc, hthd, lpdbb);
        break;

    case dmfSetPath:
        DPRINT(5, (_T("dmfSetPath\n")));
        ProcessSetPathCmd( hprc, hthd, lpdbb );
        break;

    case dmfQueryTlsBase:
        DPRINT(5, (_T("dmfQueryTlsBase\n")));
        ProcessQueryTlsBaseCmd(hprc, hthd, lpdbb );
        break;

    case dmfQuerySelector:
        //DPRINT(5, (_T("dmfQuerySelector\n")));
        ProcessQuerySelectorCmd(hprc, hthd, lpdbb );
        break;

    case dmfVirtualQuery:
        DEBUG_PRINT(_T("VirtualQuery\r\n"));
        ProcessVirtualQueryCmd(hprc, lpdbb);
        break;

    case dmfRemoteQuit:
        DEBUG_PRINT(_T("RemoteQuit\r\n"));
        ProcessRemoteQuit();
        break;

#ifdef KERNEL
    case dmfGetSections:
        ProcessGetSectionsCmd( hprc, hthd, lpdbb );
        break;
#endif

    case dmfSetExceptionState:
        DEBUG_PRINT(_T("SetExceptionState\r\n"));
        ProcessSetExceptionState(hprc, hthd, lpdbb);
        break;

    case dmfGetExceptionState:
        DEBUG_PRINT(_T("GetExceptionState\r\n"));
        ProcessGetExceptionState(hprc, hthd, lpdbb);
        break;

    case dmfSingleStep:
        DEBUG_PRINT(_T("SingleStep\r\n"));
#if !defined(KERNEL)
        //Turn off fiber debugging
        hprc->pFbrCntx = NULL;
#endif
        ProcessSingleStepCmd(hprc, hthd, lpdbb);
        break;

    case dmfRangeStep:
        DEBUG_PRINT(_T("RangeStep\r\n"));
#if !defined(KERNEL)
        //Turn off fiber debugging
        hprc->pFbrCntx = NULL;
#endif
        ProcessRangeStepCmd(hprc, hthd, lpdbb);
        break;

    case dmfReturnStep:
        DEBUG_PRINT(_T("ReturnStep\r\n"));
        ProcessReturnStepCmd(hprc, hthd, lpdbb);
        break;

#ifndef KERNEL
    case dmfNonLocalGoto:
        DEBUG_PRINT(_T("NonLocalGoto\r\n"));
        //Turn off fiber debugging
        hprc->pFbrCntx = NULL;
        ProcessNonLocalGoto(hprc, hthd, lpdbb);
        break;
#endif

    case dmfThreadStatus:
        DEBUG_PRINT(_T("ThreadStatus\r\n"));
        Reply( ProcessThreadStatCmd(hprc, hthd, lpdbb), LpDmMsg, lpdbb->hpid);
        break;

    case dmfProcessStatus:
        DEBUG_PRINT(_T("ProcessStatus\r\n"));
                LpDmMsg->xosdRet = xosdNone;
        Reply( ProcessProcStatCmd(hprc, hthd, lpdbb), LpDmMsg, lpdbb->hpid);
        break;

    case dmfGetTimeStamp:
        if(!fApprovedAttach) {
            fApprovedAttach = TRUE;
            xosd = AttachOrReboot();
        }
        if(xosd == xosdNone)
            Reply (ProcessGetTimeStamp (hprc, hthd, lpdbb), LpDmMsg, lpdbb->hpid);
        else
            Reply( 0, &xosd, lpdbb->hpid);
        break;

	case dmfCreateUserCrashDump:

		//
		// NYI
		//
		
		LpDmMsg->xosdRet = xosdUnknown;
		Reply( 0, LpDmMsg, lpdbb->hpid );
		break;

	case dmfGetSpecialReg:
		Reply( ProcessGetSpecialReg(hprc, hthd, lpdbb), LpDmMsg, lpdbb->hpid);
		break;

	case dmfSetSpecialReg:
		Reply( ProcessSetSpecialReg(hprc, hthd, lpdbb), LpDmMsg, lpdbb->hpid);
		break;

    default:
        DPRINT(5, (_T("Unknown\n")));
        assert(FALSE);
        break;
    }

    return;
}                         /* DMFunc() */

#ifndef KERNEL

BOOL
StartDmPollThread(
    void
    )
/*++

Routine Description:

    This creates the DM poll thread.

Arguments:

    none

Return Value:

    TRUE if the thread was successfully created or already
    existed.

--*/
{
    DWORD   tid;

    if (hDmPollThread) {
        return TRUE;
    }

	fDmPollQuit = FALSE; // need this set before the thread starts
    hDmPollThread = CreateThread(0,0,CallDmPoll,0,0,&tid);

    return hDmPollThread != 0;
}

#if 0
BOOL
StartCrashPollThread(
    void
    )
/*++

Routine Description:

    This creates the DM poll thread for a crash dump file.

Arguments:

    none

Return Value:

    TRUE if the thread was successfully created or already existed.

--*/
{
    DWORD   tid;

    if (hDmPollThread) {
        return TRUE;
    }

    hDmPollThread = CreateThread(0,0,(LPTHREAD_START_ROUTINE)CrashDumpThread,0,0,&tid);

    return hDmPollThread != 0;
}

VOID
CrashDumpThread(
    LPVOID lpv
    )
{
    HPRCX            hprc;
    HTHDX            hthd;
    HTHDX            hthdNew;
    LPBYTE           lpbPacket;
    WORD             cbPacket;
    PCRASH_MODULE    CrashModule;
    DEBUG_EVENT      de;
    DWORD            i;
    CHAR             buf[_MAX_FNAME];
    DWORD            DumpVer = CrashDumpHeader->MajorVersion;
	CHAR             szMainName[_MAX_FNAME + _MAX_EXT];


    CrashDump = TRUE;
	fDmPollQuit = FALSE;

    //
    // simulate a create process debug event
    //
    CrashModule = (PCRASH_MODULE)((PUCHAR)CrashDumpHeader+CrashDumpHeader->ModuleOffset);
    de.dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
    de.dwProcessId = 1;
    de.dwThreadId  = 1;
    de.u.CreateProcessInfo.hFile = NULL;
    de.u.CreateProcessInfo.hProcess = NULL;
    de.u.CreateProcessInfo.hThread = NULL;
    de.u.CreateProcessInfo.lpBaseOfImage = (LPVOID)CrashModule->BaseOfImage;
    de.u.CreateProcessInfo.dwDebugInfoFileOffset = 0;
    de.u.CreateProcessInfo.nDebugInfoSize = 0;
    de.u.CreateProcessInfo.lpStartAddress = NULL;
    de.u.CreateProcessInfo.lpThreadLocalBase = NULL;
    if (!CrashModule->ImageName[0]) {
		if (nameBuffer[0])
		{
			// Dr Watson didn't give us the name of the exe, so make one up based
			// on the .dmp filename
			_splitpath( nameBuffer, NULL, NULL, buf, NULL );
			_makepath( szMainName, NULL, NULL, buf, ".exe" );
			de.u.CreateProcessInfo.lpImageName = szMainName;
		}
		else
			de.u.CreateProcessInfo.lpImageName = "unknown.exe";
    } else {
       de.u.CreateProcessInfo.lpImageName = CrashModule->ImageName;
    }
    _ftcscpy( nameBuffer, de.u.CreateProcessInfo.lpImageName);
    de.u.CreateProcessInfo.fUnicode = FALSE;
    ProcessDebugEvent(&de);
    WaitForSingleObject( hEventCreateProcess, INFINITE );

    //
    // mark the process as 'being connected' so that the continue debug
    // events that are received from the shell are ignored
    //
    hprc = HPRCFromPID(1);
    hthd = hprc->hthdChild;
    hprc->pstate |= ps_connect;

    if (DumpVer >= 4) {
        DmpGetThread( 0, &hthd->CrashThread );
    } else {
        ZeroMemory(&hthd->CrashThread, sizeof(CRASH_THREAD));
        hthd->CrashThread.ThreadId = hthd->tid;
    }

    //
    // generates the mod load events
    //
    for (i=1; i<CrashDumpHeader->ModuleCount; i++) {

		int	len = CrashModule->ImageName [0] ? CrashModule->ImageNameLength : 1;

		CrashModule = (PCRASH_MODULE)
						((PUCHAR)CrashModule + sizeof(CRASH_MODULE) + len );
										
        de.dwDebugEventCode                = LOAD_DLL_DEBUG_EVENT;
        de.dwProcessId                     = 1;
        de.dwThreadId                      = 1;
        de.u.LoadDll.hFile                 = NULL;
        de.u.LoadDll.lpBaseOfDll           = (LPVOID)CrashModule->BaseOfImage;
        if (!CrashModule->ImageName[0]) {
           sprintf( buf, "mod_%x.dll", CrashModule->BaseOfImage );
           de.u.LoadDll.lpImageName = buf;
        } else {
           de.u.LoadDll.lpImageName = CrashModule->ImageName;
        }
        de.u.LoadDll.fUnicode              = FALSE;
        de.u.LoadDll.nDebugInfoSize        = 0;
        de.u.LoadDll.dwDebugInfoFileOffset = 0;
        if (LoadDll(&de,hthd,&cbPacket,&lpbPacket) && (cbPacket != 0)) {
            NotifyEM(&de, hthd, cbPacket, lpbPacket);
        }
    }

    //
    // create all of the threads
    //
    for (i=1; i<CrashDumpHeader->ThreadCount; i++) {
        //
        // generate a thread create event
        //
        ResetEvent( hprc->hEventCreateThread );
        ResetEvent( hEventContinue );
        de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
        de.dwProcessId = hprc->pid;
        de.dwThreadId = i + 1;
        de.u.CreateThread.hThread = (HANDLE) (i + 1);
        de.u.CreateThread.lpThreadLocalBase = 0;
        de.u.CreateThread.lpStartAddress = 0;

        //
        // Take critical section here so that it is still
        // held after leaving ProcessDebugEvent
        //
        EnterCriticalSection(&csProcessDebugEvent);
        ProcessDebugEvent(&de);
        hthdNew = HTHDXFromPIDTID(1,(i+1));
        DbgGetThreadContext( hthdNew, &hthdNew->context );
        if (DumpVer >= 4) {
            DmpGetThread( i, &hthdNew->CrashThread );
        } else {
            ZeroMemory(&hthdNew->CrashThread, sizeof(CRASH_THREAD));
            hthdNew->CrashThread.ThreadId = hthdNew->tid;
        }
        LeaveCriticalSection(&csProcessDebugEvent);
        WaitForSingleObject( hprc->hEventCreateThread, INFINITE );

        //
        // wait for the shell to continue the new thread
        //
        WaitForSingleObject( hEventContinue, INFINITE );
    }

    //
    // generate a load complete debug event
    //

	ConsumeAllProcessEvents (hprc, FALSE);
	
    de.dwProcessId = hprc->pid;
    de.dwThreadId = hprc->hthdChild->tid;
    de.dwDebugEventCode = LOAD_COMPLETE_DEBUG_EVENT;
    NotifyEM( &de, hthd, 0, 0L);

    WaitForSingleObject( hEventContinue, INFINITE );

    //
    // Get the debug event for the crash
    //
    if (DumpVer >= 4) {
        de = *(LPDEBUG_EVENT)((PUCHAR)CrashDumpHeader+CrashDumpHeader->DebugEventOffset);
        //
        // convert the thread and process ids into the internal version...
        //
        de.dwProcessId = 1;
        for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
            if (de.dwThreadId == hthd->CrashThread.ThreadId) {
                de.dwThreadId = hthd->tid;
                break;
            }
        }
    } else {
        //
        // if this is an old crashdump file, try to find the crashed thread
        //
        de.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
        de.u.Exception.ExceptionRecord  = *CrashException;
        for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
            if (PC(hthd) == (DWORD)CrashException->ExceptionAddress) {
                de.dwThreadId = hthd->tid;
            }
        }
    }

    ProcessDebugEvent( &de );

    while (!fDmPollQuit) {
        //
        // Handle kill commands
        //
        if (KillQueue) {
            CompleteTerminateProcessCmd();
        }
        Sleep( 500 );
    }
}
#endif // 0


DWORD WINAPI
CallDmPoll(
    LPVOID lpv
    )

/*++

Routine Description:

    This is the debug event loop.  This routine creates or
    attaches to child process, and monitors them for debug
    events.  It serializes the dispatching of events from
    multiple process, and continues the events when the
    worker functions have finished processing the events.

Arguments:

    lpv - Supplies an argument provided by CreateThread.

Return Value:

    None.

--*/

{
    DEBUG_EVENT de;
	DEQ deq;
    int         nprocs = 0;
    UINT        ErrMode;
	HPRCX       hprc;

    Unreferenced( lpv );
    DEBUG_PRINT(_T("CallDmPoll\r\n"));

#if 0
#ifdef _DEBUG
	// lets make it obvious which thread this is, Debug only
	SetThreadName( GetCurrentThreadId(), "DMPoll", 0);
#endif
#endif // 0

    //
    // Crank up priority to improve performance, and improve our
    // chances of winning races with the debuggee.
    //
    //
    // NOTE:
    //
    //  Setting the thread priority here makes emulation a LOT faster.
    //  Unfortunately, it also starves out the UI threads when we are
    //  emulating.
    //
    
    // SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_ABOVE_NORMAL);


	//fDmPollQuit is set in StartPollThread
    //fDmPollQuit = FALSE;
    while (!fDmPollQuit) {

        //
        // Handle kill commands
        //
        if (KillQueue) {
            CompleteTerminateProcessCmd();
            goto doContinues;
        }

#if 0
        //
        // Handle spawn commands
        //
        if (SpawnStruct.fSpawn) {
            SpawnStruct.fSpawn = FALSE;
            ErrMode = SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | 0 );
            SpawnStruct.fReturn =
                CreateProcess( SpawnStruct.szAppName,
                             SpawnStruct.szArgs,
                             NULL,
                             NULL,
                             SpawnStruct.fInheritHandles,
                             SpawnStruct.fdwCreate,
                             NULL,
                             SpawnStruct.pszCurrentDirectory,
                             &SpawnStruct.si,
                             &pi
                             );
            SetErrorMode(  SEM_NOALIGNMENTFAULTEXCEPT | ErrMode );
            if (SpawnStruct.fReturn == 0) {
                SpawnStruct.dwError = GetLastError();
            } else {
                SpawnStruct.dwError = 0;
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                Close3Handles(rgh);
            }

            SetEvent(SpawnStruct.hEventApiDone);
        }

        //
        // Handle attach commands
        //
        if (DebugActiveStruct.fAttach) {
            DebugActiveStruct.fAttach = FALSE;
            SetDebugPrivilege ();
            DebugActiveStruct.fReturn = DebugActiveProcess(DebugActiveStruct.dwProcessId);
            if (DebugActiveStruct.fReturn == 0) {
                DebugActiveStruct.dwError = GetLastError();
            } else {
                DebugActiveStruct.dwError = 0;
            }
            SetEvent(DebugActiveStruct.hEventApiDone);
        }
#endif

        if (WtStruct.fWt) {
            WtStruct.fWt = FALSE;
            switch(WtStruct.dwType) {
                case IG_WATCH_TIME_STOP:
                    WtStruct.hthd->wtmode = 2;
                    break;

                case IG_WATCH_TIME_RECALL:
                    break;

                case IG_WATCH_TIME_PROCS:
                    break;
            }
        }

#if 0
#ifndef KERNEL
        // In some cases the process just disappears from under us with no notifications.
        // This is only known to happen on Win95.

        if (IsChicago() && prcList->next != NULL) {
            hprc = NULL;

            EnterCriticalSection(&csThreadProcList);

            for (hprc = prcList->next; hprc ; hprc = hprc->next) {
                if (!(hprc->pstate & (ps_dead|ps_killed)))  {
                    if (WaitForSingleObject(hprc->rwHand, 0) == WAIT_OBJECT_0) {
                        break;
                    }
                }
            }
            
            LeaveCriticalSection(&csThreadProcList);

            // Fake up the process terminate notification. 
            if (hprc != hprcxNull)  {
                HandleDisappearedProcess(hprc);
            }
        }
#endif
#endif

        if (WaitDEQ(&deq, (DWORD) WAITFORDEBUG_MS)) {
			de = deq.de;

#if 0
			//
			// This code simulates the OS not sending us an EXIT_PROCESS
			// event.  Enable it ONLY to test that termination case.
			//

			assert (FALSE);
			if (de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {

				AddQueue (QT_CONTINUE_DEBUG_EVENT,
						  de.dwProcessId,
						  de.dwThreadId,
						  DBG_CONTINUE,
						  0);
				continue;
			}
#endif
						
			UserTimerStop();


            if ( de.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT ) {
                assert(HPRCFromPID(de.dwProcessId) == NULL);
                     
                if (nprocs == 0) {
                    ResetEvent(hEventNoDebuggee);
                }
                ++nprocs;
            } else if ( de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {
                --nprocs;
            }

            if (fDisconnected) {
                if (de.dwDebugEventCode == LOAD_DLL_DEBUG_EVENT       ||
                    de.dwDebugEventCode == UNLOAD_DLL_DEBUG_EVENT     ||
                    de.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT  ||
                    de.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT      ) {

                    //
                    // we can process these debug events very carefully
                    // while disconnected from the shell.  the only requirement
                    // is that the dm doesn't call NotifyEM while disconnected.
                    //

                } else
#if 0
                if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {

                    //
                    // if the exception is to be ignored, we can handle it here.
                    // if not, we have to wait for a reconnect.
                    //

                } else
#endif
                {

                    WaitForSingleObject( hEventRemoteQuit, INFINITE );
                    ResetEvent( hEventRemoteQuit );
                    fDisconnected = FALSE;
                    //
                    // this is a remote session reconnecting
                    //
                    ReConnectDebugger( &de, FALSE );

                }
            }

            if ( fxFlagSet && 
                (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) &&
                (de.u.Exception.dwFirstChance == 0) ) {
                    //
                    //	v-vadimp
                    //
                    // this is not pretty, but there seems to be not other way...
                    //
                    // when a second chance exception is generated, for it the OS reports the record of the SS (or BP) 
                    // exception generated by the FXSAVE/FXRSTOR hack code hit while processing the first chance exception, 
                    // hence the debugger gets totally hosed. So what we do here is restore u.Exception.ExceptionRecord from
                    // the backup we made when the first chance exception hit (presumably they are the same, and the backup
                    // area has not been used again, i.e. no exceptions have been reported between the first anc second chance). 
                    // Also the OS not only wacks the exception record, but also updates the thread's IP to point to where it thinks
                    // the exception is occuring (i.e. the trojan FXSAVE/FXRSTOR code location), so the IP has to be restored too.
                    //
                    CONTEXT ContextRestore;
                    HTHDX hthd = HTHDXFromPIDTID(de.dwProcessId,de. dwThreadId);
					
                    assert (deBackup.dwDebugEventCode == EXCEPTION_DEBUG_EVENT);
                    assert (deBackup.u.Exception.dwFirstChance == 1);
                    assert (deBackup.dwProcessId == deBackup.dwProcessId);
                    assert (deBackup.dwThreadId == deBackup.dwThreadId);
					
                    de.u.Exception.ExceptionRecord = deBackup.u.Exception.ExceptionRecord;
                    
                    //do not use CONTEXT_FULL - it will do FXSAVE/FXRSTOR again!!!
                    ContextRestore.ContextFlags = CONTEXT_CONTROL; 
                    VERIFY(DbgGetThreadContext(hthd, &ContextRestore));
                    ContextRestore.Eip = (DWORD)de.u.Exception.ExceptionRecord.ExceptionAddress;
                    VERIFY(DbgSetThreadContext(hthd, &ContextRestore));

            }

            fxFlagSet = FALSE;
            deBackup = de;

            ProcessDebugEvent(&de);

			if(de.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
				/* We need to free the string */
				MHFree(de.u.DebugString.lpDebugStringData);

        } else if (WaitForSingleObject( hEventRemoteQuit, 0 ) ==
                                                               WAIT_OBJECT_0) {

            //
            // this is a remote session reconnecting
            //
            ResetEvent( hEventRemoteQuit );
            ReConnectDebugger( NULL, FALSE );

        } else if (nWaitingForLdrBreakpoint) {

            // look for processes that are looking for a loader bp.
            // See how long it has been since they got an event.

            EnterCriticalSection(&csThreadProcList);
            for (hprc = prcList->next; hprc; hprc = hprc->next) {
                if (hprc->pstate & ps_preStart) {
                    if (++hprc->cLdrBPWait > LDRBP_MAXTICKS) {
                        // Signal a timeout for this one.
                        // just jump out of this loop - if
                        // another one is going to time out,
                        // it can do it on the next pass.
                        break;
                    }
                }
            }
            LeaveCriticalSection(&csThreadProcList);

            if (hprc) {
                HandleDebugActiveDeadlock(hprc);
            }

        } else if (nprocs == 0) {
			
			Sleep (WAITFORDEBUG_MS);

        } else {

			EnterCriticalSection (&csThreadProcList);

			for (hprc = prcList->next; hprc; hprc = hprc->next) {
				FireOutstandingTimerEvents (hprc);
			}

			LeaveCriticalSection (&csThreadProcList);
		}
		

    doContinues:
        if (DequeueAllEvents(TRUE, FALSE) && nprocs <= 0) {
            SetEvent(hEventNoDebuggee);
        }
    }

    DEBUG_PRINT(_T("CallDmPoll Exit\r\n"));

	return 0;	// NOTREACHED

}


#if 0

BOOL
SetDebugPrivilege(
    void
    )
/*++

Routine Description:

    Enables SeDebugPrivilege if possible.

Arguments:

    none

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HANDLE  hToken;
    LUID    DebugValue;
    TOKEN_PRIVILEGES tkp;
    BOOL    rVal = TRUE;

    if (!OpenProcessToken(GetCurrentProcess(),
         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        return FALSE;
    }

    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &DebugValue)) {

        rVal = FALSE;

    } else {

        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Luid = DebugValue;
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        AdjustTokenPrivileges(hToken,
            FALSE, &tkp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);

        if (GetLastError() != ERROR_SUCCESS) {
            rVal = FALSE;
        }
    }

    CloseHandle(hToken);

    return rVal;
}

#endif  // !KERNEL
#endif // 0


/********************************************************************/
/*                                                                  */
/* Dll Version                                                      */
/*                                                                  */
/********************************************************************/

#ifdef KERNEL

#ifdef DEBUGVER
DEBUG_VERSION('D','M',"NT Kernel Debugger Monitor")
#else
RELEASE_VERSION('D','M',"NT Kernel Debugger Monitor")
#endif

#else // KERNEL

#ifdef DEBUGVER
DEBUG_VERSION('D','M',"WIN32 Debugger Monitor")
#else
RELEASE_VERSION('D','M',"WIN32 Debugger Monitor")
#endif

#endif  // KERNEL

DBGVERSIONCHECK()

#define EXTENDED_REGISTERS_SUPPORT_KEY     _T("Software\\Microsoft\\Devstudio\\6.0\\Debug")


int
WINAPI
DmDllMain(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
/*++

Routine Description:

    Entry point called by the loader during DLL initialization
    and deinitialization.  This creates and destroys some per-
    instance objects.

Arguments:

    hModule     - Supplies base address of dll

    dwReason    - Supplies flags describing why we are here

    dwReserved  - depends on dwReason.

Return Value:

    TRUE

--*/
{
    Unreferenced(hModule);
    Unreferenced(dwReserved);
	//SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);
    switch (dwReason) {

      case DLL_THREAD_ATTACH:
        break;

      case DLL_THREAD_DETACH:
        break;

      case DLL_PROCESS_DETACH:
		  if(psessNotify)
			  DmCloseNotificationSession(psessNotify);

#ifndef XBOX // XBUG
        if(hDmPollThread > 0) {
		//Badness has happened do our best to minimize the fallout
            TerminateThread(hDmPollThread,0);
            CloseHandle(hDmPollThread);
		}
		if(hTerminateThread > 0) {
        //Badness has happened do our best to minimize the fallout
            TerminateThread(hTerminateThread,0);
            CloseHandle(hTerminateThread);
		}
#endif
        //CloseHandle(SpawnStruct.hEventApiDone);
        CloseHandle(hEventCreateProcess);
        CloseHandle(hEventRemoteQuit);
        CloseHandle(hEventNoDebuggee);
        CloseHandle(hEventContinue);

        DeleteCriticalSection(&csProcessDebugEvent);
        DeleteCriticalSection(&csThreadProcList);
        DeleteCriticalSection(&csFXOps);
        DeleteCriticalSection(&csEventList);
        DeleteCriticalSection(&csWalk);
#if !defined(KERNEL)
        CloseHandle(DebugActiveStruct.hEventApiDone);
        CloseHandle(DebugActiveStruct.hEventReady);
        DeleteCriticalSection(&csKillQueue);
#endif
        break;

      case DLL_PROCESS_ATTACH:

        InitializeCriticalSection(&csProcessDebugEvent);
        InitializeCriticalSection(&csThreadProcList);
        InitializeCriticalSection(&csFXOps);
        InitializeCriticalSection(&csEventList);
        InitializeCriticalSection(&csWalk);

        hEventCreateProcess = CreateEvent(NULL, TRUE, FALSE, NULL);
        hEventRemoteQuit = CreateEvent(NULL, TRUE, FALSE, NULL);
        hEventContinue = CreateEvent(NULL, TRUE, FALSE, NULL);
        hEventNoDebuggee    = CreateEvent(NULL, TRUE, FALSE, NULL);
        //SpawnStruct.hEventApiDone = CreateEvent(NULL, TRUE, FALSE, NULL);

#if !defined(KERNEL)
        InitializeCriticalSection(&csKillQueue);
        DebugActiveStruct.hEventApiDone = CreateEvent(NULL, TRUE, TRUE, NULL);
        DebugActiveStruct.hEventReady   = CreateEvent(NULL, TRUE, TRUE, NULL);

        /*
         * These parameters are from SCOTTLU
         */

#ifndef XBOX
        SetProcessShutdownParameters(0x3ff, 0);
#endif

#endif

#ifndef XBOX
		hInstance = hModule;
#endif

#if 0
#if !defined(KERNEL)
        //
        // get helpful info
        //

        GetSystemInfo(&SystemInfo);
        OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
        GetVersionEx(&OsVersionInfo);

#if defined (TARGET_MIPS)

        if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            (OsVersionInfo.dwBuildNumber & 0xffff) > 1144) {
            MipsContextSize = Ctx64Bit;
        } else {
            MipsContextSize = Ctx32Bit;
        }

#endif // TARGET_MIPS

#if 0
        FChicago = ((GetVersion() & 0x80000000) && ((GetVersion() & 0xff)>3));
#endif // TARGET_i386

#endif // KERNEL
#endif

        break;
    }

#ifdef XBOX
	return 0;
#else
    return TlDllMain(hModule, dwReason, dwReserved);
#endif
}

#if 0
BOOL
PASCAL
IsChicago(
    VOID
    )
/*++

Routine Description:

    This routine allows the caller to determine if the DM is running on
    the Win95 family

Return Value:

    TRUE if running on Win95 and FALSE othewise.

--*/
{
    return FChicago;
}
#endif

#ifndef XBOX

BOOL
PASCAL
DmDllInit(
    LPDBF  lpb
    )

/*++

Routine Description:

    This routine allows the shell (debugger or remote stub)
    to provide a service callback vector to the DM.

Arguments:

    lpb - Supplies an array of functions for callbacks

Return Value:

    TRUE if successfully initialized and FALSE othewise.

--*/

{
    lpdbf = lpb;
    return TRUE;
}                                   /* DmDllInit() */
#endif


#ifdef KERNEL
void
ParseDmParams(
    LPTSTR p
    )
{
    DWORD                       i;
    CHAR                        szPath[MAX_PATH];
    CHAR                        szStr[_MAX_PATH];
    LPTSTR                       lpPathNext;
    LPTSTR                       lpsz1;
    LPTSTR                       lpsz2;
    LPTSTR                       lpsz3;


    for (i=0; i<MAX_MODULEALIAS; i++) {
        if (!ModuleAlias[i].Special) {
            ZeroMemory( &ModuleAlias[i], sizeof(MODULEALIAS) );
        }
    }

    do {
        p = _ftcstok( p, _T("=") );
        if (p) {
            for (i=0; i<MAXKDOPTIONS; i++) {
                if (_ftcsicmp(KdOptions[i].keyword,p)==0) {
                    break;
                }
            }
            if (i < MAXKDOPTIONS) {
                p = _ftcstok( NULL, _T(" ") );
                if (p) {
                    switch (KdOptions[i].typ) {
                        case KDT_DWORD:
                            KdOptions[i].value = atol( p );
                            break;

                        case KDT_STRING:
                            KdOptions[i].value = (DWORD) _ftcsdup( p );
                            break;
                    }
                    p = p + (_ftcslen(p) + 1);
                }
            } else {
                if (_ftcsicmp( p, _T("alias") ) == 0) {
                    p = _ftcstok( NULL, _T("#") );
                    if (p) {
                        for (i=0; i<MAX_MODULEALIAS; i++) {
                            if (ModuleAlias[i].ModuleName[0] == 0) {
                                break;
                            }
                        }
                        if (i < MAX_MODULEALIAS) {
                            _ftcscpy( ModuleAlias[i].ModuleName, p );
                            p = _ftcstok( NULL, _T(" ") );
                            if (p) {
                                _ftcscpy( ModuleAlias[i].Alias, p );
                                p = p + (_ftcslen(p) + 1);
                            }
                        } else {
                            p = _ftcstok( NULL, _T(" ") );
                        }
                    }
                } else {
                    p = _ftcstok( NULL, _T(" ") );
                }
            }
        }
    } while(p && *p);

    if (KdOptions[KDO_VERBOSE].value > 1) {
        FVerbose = KdOptions[KDO_VERBOSE].value;
    }
    else {
        FVerbose = 0;
    }

    szPath[0] = 0;
    lpPathNext = _ftcstok((LPTSTR)KdOptions[KDO_SYMBOLPATH].value, _T(";"));
    while (lpPathNext) {
        lpsz1 = szStr;
        while ((lpsz2 = _ftcschr(lpPathNext, _T('%'))) != NULL) {
            _ftcsncpy(lpsz1, lpPathNext, lpsz2 - lpPathNext);
            lpsz1 += lpsz2 - lpPathNext;
            lpsz2++;
            lpPathNext = _ftcschr(lpsz2, _T('%'));
            if (lpPathNext != NULL) {
                *lpPathNext++ = 0;
                lpsz3 = getenv(lpsz2);
                if (lpsz3 != NULL) {
                    _ftcscpy(lpsz1, lpsz3);
                    lpsz1 += _ftcslen(lpsz3);
                }
            } else {
                lpPathNext = _T("");
            }
        }
        _ftcscpy(lpsz1, lpPathNext);
        _ftcscat( szPath, szStr );
        _ftcscat( szPath, _T(";") );
        lpPathNext = _ftcstok(NULL, _T(";"));
    }

    if ( szPath[0] != 0 ) {
        if (szPath[_ftcslen(szPath)-1] == _T(';')) {
            szPath[_ftcslen(szPath)-1] = _T('\0');
        }
        _ftcscpy( (LPTSTR)KdOptions[KDO_SYMBOLPATH].value, szPath );
    }
}


VOID
ProcessRemoteQuit(
    VOID
    )
{
    HPRCX      hprc;
    PBREAKPOINT pbp;
    PBREAKPOINT pbpT;


    EnterCriticalSection(&csThreadProcList);

    for(hprc=prcList->next; hprc; hprc=hprc->next) {
        for (pbp = BPNextHprcPbp(hprc, NULL); pbp; pbp = pbpT) {
            pbpT = BPNextHprcPbp(hprc, pbp);
            RemoveBP(pbp);
        }
    }

    LeaveCriticalSection(&csThreadProcList);

    fDisconnected = TRUE;
    ResetEvent( hEventRemoteQuit );
}

#endif  // KERNEL



XOSD FAR PASCAL
DMInit(
    DMTLFUNCTYPE lpfnTl,
    LPTSTR        lpch
    )
/*++

Routine Description:

    This is the entry point called by the TL to initialize the
    connection from DM to TL.

Arguments:

    lpfnTl  - Supplies entry point to TL

    lpch    - Supplies command line arg list

Return Value:

    XOSD value: xosdNone for success, other values reflect reason
    for failure to initialize properly.

--*/
{
    int i, n;
    XOSD xosd;

    DEBUG_PRINT(_T("DMInit\r\n"));

    if (lpfnTl != NULL) {

#if 0
		/*
         **  Parse out anything interesting from the command line args
         */

        while (*lpch) {

            while (isspace(*lpch)) {
                lpch++;
            }

            if (*lpch != _T('/') && *lpch != _T('-')) {
                break;
            }

            lpch++;

            switch (*lpch++) {

              case 0:   // don't skip over end of string
                --lpch;

              default:  // assert, continue is ok.
                assert(FALSE);
                break;


              case 'v':
              case 'V':

                while (isspace(*lpch)) {
                    lpch++;
                }
                FVerbose = atoi(lpch);
                while (isdigit(*lpch)) {
                    lpch++;
                }
                break;

              case 'r':
              case 'R':
                FDMRemote = TRUE;
                break;

              case 'd':
              case 'D':
                FUseOutputDebugString = TRUE;
                break;

            }
        }
#endif // 0
#ifdef KERNEL
        ParseDmParams( lpch );
#endif


        /* Define a false single step event */
        falseSSEvent.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
        falseSSEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_SINGLE_STEP;

        falseBPEvent.dwDebugEventCode = BREAKPOINT_DEBUG_EVENT;
        falseBPEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_BREAKPOINT;

        FuncExitEvent.dwDebugEventCode = FUNC_EXIT_EVENT;
        FuncExitEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_SINGLE_STEP;

        /* Define the standard notification method */
        EMNotifyMethod.notifyFunction = ConsumeThreadEventsAndNotifyEM;
        EMNotifyMethod.lparam     = (LPVOID)0;

        SearchPathString[0] = _T('\0');
        SearchPathSet       = FALSE;

        InitEventQueue();
		InitDEQ();

        //
        // initialize data breakpoint handler
        //
        ExprBPInitialize();

		// Xbox has known hardware
        g_ProcFlags = PROCESSOR_FLAGS_EXTENDED | PROCESSOR_FLAGS_I386_MMX |
			PROCESSOR_FLAGS_I386_MMX2 | PROCESSOR_FLAGS_I386_MMX3;

#if 0
#ifdef TARGET_i386
{
        DWORD mmx = 0, mmx2 = 0, mmx3 = 0, threednow = 0;

        _asm
        {
            push ebx
            push ecx
            push edx

            pushfd
            pop eax
            mov ebx,eax
            xor eax,00200000h
            push eax
            popfd
            pushfd
            pop eax
            cmp eax,ebx
            jz nocpuid

            mov eax, 1  ;
            cpuid

            mov eax,edx ;
            shr edx,23  ;   //MMX
            and edx,1   ;
            mov mmx,edx ;

            mov edx,eax ;
            shr edx,25  ;   //Katmai
            and edx,1   ;
            mov mmx2,edx;   

            mov edx,eax	;
            shr edx,26	;	//Willamette
            and edx,1	;
            mov mmx3,edx;	

            mov eax,80000000h
            cpuid
            cmp eax,80000000h
            jbe notamd
            mov eax,80000001h
            cpuid
            shr edx,31
            and edx,1
            mov threednow,edx
notamd:
nocpuid:
            pop edx
            pop ecx
            pop ebx
        }

        if (mmx == 1) {
            //Old MMX           
            g_ProcFlags |= PROCESSOR_FLAGS_I386_MMX;
        }

        if (threednow) {
            // 3DNow
            g_ProcFlags |= PROCESSOR_FLAGS_I386_3DNOW;
        }

		if (mmx2) {
			//
			// v-vadimp - On NT4 or Win9x try executing FXSAVE to see if the OS supports it 
			// (instrumental for the hack to get extended registers), then check the registry - 
			// we only support the hack if the user explicitly requested it by creating the above 
			// registry key. Set FXSAVESupport accordingly. Win2K supports the extended registers 
			// through the regular Get/SetContext calls
			//
#if 0 // ignore this code until I know what it does
			if (FChicago || !(!(GetVersion() & 0x80000000) && ((GetVersion() & 0xff) == 5))) {
				// We need to have SIMD support in the CPU and in the OS task switcher
				// See Intel AP-900 note for details
				// (this currently means NT4 SP5 and later, or Win98)
				DWORD dwVal;
				DWORD dwLen=4;
				DWORD dwType;
				HKEY hkey = NULL;
				BOOL bDoHack = (
					(RegOpenKey(HKEY_CURRENT_USER, EXTENDED_REGISTERS_SUPPORT_KEY, &hkey)==ERROR_SUCCESS) &&
					(RegQueryValueEx(hkey, "SIMDRegisters", NULL, &dwType, (LPBYTE)&dwVal, &dwLen)==ERROR_SUCCESS) &&
					dwVal && 
					(dwType==REG_DWORD)
					);
				if (bDoHack)
				{
					__try
					{
						// xorps xmm0,xmm0
						_asm _emit 0Fh
						_asm _emit 57h
						_asm _emit 0C0h
					}
					__except(EXCEPTION_EXECUTE_HANDLER)
					{
						bDoHack = FALSE;
					}
				}
				FXSAVESupported = bDoHack;
				if (!bDoHack)
				{
					mmx2 = 0;				// disable KNI regs if we can't get to them
					mmx3 = 0;
				}
				if (hkey)
					RegCloseKey(hkey);
			}
#endif // 0

			if (mmx2 == 1) {
				//Katmai
				g_ProcFlags |= (PROCESSOR_FLAGS_EXTENDED | PROCESSOR_FLAGS_I386_MMX2);
			}
        
			if (mmx3 == 1) {
				//Willamette
				g_ProcFlags |= (PROCESSOR_FLAGS_EXTENDED | PROCESSOR_FLAGS_I386_MMX3);
			}
		}
}
#endif
#endif // 0

        // SetDebugErrorLevel(SLE_WARNING);

        /*
         **  Save the pointer to the Transport layer entry function
         */

        DmTlFunc = lpfnTl;

        /*
         **  Try and connect up to the other side of the link
         */

        DmTlFunc( tlfSetBuffer, NULL, sizeof(abEMReplyBuf), (LONG)(LPV) abEMReplyBuf );

        if ((xosd = DmTlFunc( tlfConnect, NULL, 0, 0)) != xosdNone ) {
            return(xosd);
        }

        DPRINT(10, (_T("DM & TL are now connected\n")));

    } else {

        DmTlFunc( tlfDisconnect, NULL, 0, 0);
        DmTlFunc( tlfSetBuffer, NULL, 0, 0);
        FDMRemote = FALSE;
        DmTlFunc = (DMTLFUNCTYPE) NULL;

    }

    return xosdNone;
}                               /* DmInit() */



#ifndef KERNEL
VOID
Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup of DM, prepare for exit.

Arguments:

    None

Return Value:

    None

--*/
{
    HTHDX           pht, phtt;
    HPRCX           php, phpt;
    BREAKPOINT      *bp, *bpt;
    int             iDll;


    /* Free all threads and close their handles */
    for (pht = thdList->next; pht; pht = phtt) {
        phtt = pht->next;
        if (pht->rwHand != (HANDLE)INVALID) {
            CloseHandle(pht->rwHand);
        }
        MHFree(pht);
    }
    thdList->next = NULL;


    /* Free all processes and close their handles */
	
    for(php = prcList->next; php; php = phpt) {
        phpt = php->next;

        RemoveExceptionList(php);
        // Free any fibers that may be left
        RemoveFiberList(php);

        for (iDll = 0; iDll < php->cDllList; iDll++) {
            DestroyDllLoadItem(&php->rgDllList[iDll]);
        }
        MHFree(php->rgDllList);

        if (php->rwHand != (HANDLE)INVALID) {
            CloseHandle(php->rwHand);
        }
        CloseHandle(php->hEventCreateThread);
		DeleteTimerEventQueue (&php->TimerQueue);
        MHFree(php);
    }
    prcList->next = NULL;

    /* Free all breakpoints */
    for(bp = bpList->next; bp; bp = bpt) {
        bpt = bp->next;
        MHFree(bp);
    }
    bpList->next = NULL;


#if 0
    // Ask the disassembler to clean itself up.
    CleanupDisassembler( );

    if (hModPsapi) {
        FreeLibrary(hModPsapi);
        hModPsapi = NULL;
        fAttemptedLoadingPsapi = FALSE;
        pFnGetModuleFileNameExA = NULL;
    }
#endif

    if (hDmPollThread) {
        fDmPollQuit = TRUE;
        WaitForSingleObject(hDmPollThread, INFINITE);
		CloseHandle(hDmPollThread);
        hDmPollThread = 0;
    }

}
#endif  // !KERNEL


#ifndef XBOX
BOOL
WINAPIV
DMPrintShellMsgEx(
	DWORD	ids,
	...
	)
{
	TCHAR		szFormat [512];
	TCHAR		buf[512];
    DWORD		bufLen;
    va_list		marker;
    LPINFOAVAIL lpinf;
    LPRTP		lprtp = NULL;
    BOOL		rVal = TRUE;

	if (!LoadString (hInstance, ids, szFormat, sizeof (szFormat))) {
		assert (FALSE);
		return FALSE;
	}

    va_start( marker, ids );
    bufLen = _vsnprintf(buf, sizeof(buf), szFormat, marker );
    va_end( marker);

    if (bufLen == -1) {
        buf[sizeof(buf) - 1] = _T('\0');
    }

    __try {
        bufLen   = _ftcslen(buf) + 1;
        lprtp    = (LPRTP) MHAlloc( FIELD_OFFSET(RTP, rgbVar)+sizeof(INFOAVAIL)+bufLen );
        lpinf    = (LPINFOAVAIL)(lprtp->rgbVar);

        lprtp->dbc  = dbcInfoAvail;
        lprtp->hpid = hpidRoot;
        lprtp->htid = NULL;
        lprtp->cb   = (int)bufLen;

        lpinf->fReply    = FALSE;
        lpinf->fUniCode  = FALSE;
        memcpy( lpinf->buffer, buf, bufLen );

        DmTlFunc( tlfDebugPacket,
                  lprtp->hpid,
                  (FIELD_OFFSET(RTP, rgbVar)+sizeof(INFOAVAIL)+bufLen),
                  (LONG)(LPV) lprtp
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rVal = FALSE;

    }

    if (lprtp) {
       MHFree( lprtp );
    }

    return rVal;
}
#endif
	
BOOL
WINAPIV
DMPrintShellMsg(
    LPTSTR szFormat,
    ...
    )
/*++

Routine Description:

   This function prints a string on the shell's
   command window.

Arguments:

    szFormat    - Supplies format string for sprintf

    ...         - Supplies variable argument list

Return Value:

    TRUE      -> all is ok and the string was printed
    FALSE     -> something's hosed and no string printed

--*/
{
    TCHAR     buf[512];
    DWORD    bufLen;
    va_list  marker;
    LPINFOAVAIL lpinf;
    LPRTP    lprtp = NULL;
    BOOL     rVal = TRUE;

    va_start( marker, szFormat );
    bufLen = _vsnprintf(buf, sizeof(buf), szFormat, marker );
    va_end( marker);

    if (bufLen == -1) {
        buf[sizeof(buf) - 1] = _T('\0');
    }

    __try {
        bufLen   = _ftcslen(buf) + 1;
        lprtp    = (LPRTP) MHAlloc( FIELD_OFFSET(RTP, rgbVar)+sizeof(INFOAVAIL)+bufLen );
        lpinf    = (LPINFOAVAIL)(lprtp->rgbVar);

        lprtp->dbc  = dbcInfoAvail;
        lprtp->hpid = hpidRoot;
        lprtp->htid = NULL;
        lprtp->cb   = (int)bufLen;

        lpinf->fReply    = FALSE;
        lpinf->fUniCode  = FALSE;
        memcpy( lpinf->buffer, buf, bufLen );

        DmTlFunc( tlfDebugPacket,
                  lprtp->hpid,
                  (FIELD_OFFSET(RTP, rgbVar)+sizeof(INFOAVAIL)+bufLen),
                  (LONG)(LPV) lprtp
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rVal = FALSE;

    }

    if (lprtp) {
       MHFree( lprtp );
    }

    return rVal;
}

void
WINAPI
_DbgTrace(
	ULONG	Flag,
	LPCTSTR	szFormat,
	...
	)
{
    va_list  marker;
    int n;

	if (gTraceFlag & Flag) {

		va_start( marker, szFormat );
		n = _vsnprintf(rgchDebug, _tsizeof(rgchDebug), szFormat, marker );
		va_end( marker);

		if (n == -1) {
			rgchDebug[_tsizeof(rgchDebug)-1] = 0;
		}

		OutputDebugString( rgchDebug );
	}
}
	
VOID
WINAPIV
DebugPrint(
    LPTSTR szFormat,
    ...
    )
{
    va_list  marker;
    int n;

    va_start( marker, szFormat );
    n = _vsnprintf(rgchDebug, _tsizeof(rgchDebug), szFormat, marker );
    va_end( marker);

    if (n == -1) {
        rgchDebug[_tsizeof(rgchDebug)-1] = 0;
    }

    OutputDebugString( rgchDebug );
}

#if 0
BOOL
InitializeDump(
	IN	LPSTR				szAppName,
	OUT	PCONTEXT*			Context,
	OUT	PEXCEPTION_RECORD*	Exception,
	OUT	PVOID*				DmpHeader
	)
{
	CRASHDUMP_VERSION_INFO	CrashVersionInfo = {0};

	if (!DmpInitialize (szAppName, Context, Exception, DmpHeader)) {
		return FALSE;
	}

	if (!DmpDetectVersionParameters (&CrashVersionInfo)) {
		return FALSE;
	}

	//
	// If DmpDetectVersionParameters succeeded, it automatically initialized
	// the version parameters.
	//
	
	return TRUE;
}
	

int
pCharMode(
    LPTSTR        szAppName,
    PIMAGETYPE    pImageType
    )
/*++

Routine Description:

    This routine is used to determine the type of exe which we are going
    to be debugging.  This is decided by looking for exe headers and making
    decisions based on the information in the exe headers.

Arguments:

    szAppName  - Supplies the path to the debugger exe

    pImageType - Returns the type of the image

Return Value:

    System_Invalid     - could not find the exe file
    System_GUI         - GUI application
    System_Console     - console application

--*/

{
    IMAGE_DOS_HEADER    dosHdr;
    IMAGE_OS2_HEADER    os2Hdr;
    IMAGE_NT_HEADERS    ntHdr;
    DWORD               cb;
    HANDLE              hFile;
    int                 ret;
    BOOL                GotIt;
    _tcscpy(nameBuffer, szAppName);

    // don't use OpenFile as it fails paths >127 bytes long

    hFile = CreateFile( szAppName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if (hFile == (HANDLE)-1) {

        /*
         *      Could not open file!
         */

        DEBUG_PRINT_2(_T("CreateFile(%s) --> %u\r\n"), szAppName, GetLastError());
        return System_Invalid;

    }

    /*
     *  Try and read an MZ Header.  If you can't then it can not possibly
     *  be a legal exe file.  (Not strictly true but we will ignore really
     *  short com files since they are unintersting).
     */

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    if ((!ReadFile(hFile, &dosHdr, sizeof(dosHdr), &cb, NULL)) ||
        (cb != sizeof(dosHdr))) {

        if (_ftcsicmp(&szAppName[_ftcslen(szAppName) - 4], _T(".COM")) == 0) {
            *pImageType = Image_16;
        } else {
            DPRINT(1, (_T("dosHdr problem.\n")));
            *pImageType = Image_Unknown;
        }

        CloseHandle(hFile);
        return System_GUI;

    }

    /*
     *  Verify the MZ header.
     *
     *  NOTENOTE        Messup the case of no MZ header.
     */

    if (dosHdr.e_magic != IMAGE_DOS_SIGNATURE) {
        /*
         *  We did not start with the MZ signature.  If the extension
         *      is .COM then it is a COM file.
         */

        if (_ftcsicmp(&szAppName[_ftcslen(szAppName) - 4], _T(".COM")) == 0) {
            *pImageType = Image_16;
        } else {
            DPRINT(1, (_T("MAGIC problem(MZ).\n")));
            *pImageType = Image_Unknown;
        }

        CloseHandle(hFile);
#ifndef KERNEL
        if (InitializeDump ( szAppName, &CrashContext, &CrashException, &CrashDumpHeader )) {
            if (
#if defined(TARGET_i386)
                CrashDumpHeader->MachineImageType != IMAGE_FILE_MACHINE_I386
#elif defined(TARGET_MIPS)
                CrashDumpHeader->MachineImageType != IMAGE_FILE_MACHINE_R4000 ||
                CrashDumpHeader->MachineImageType != IMAGE_FILE_MACHINE_R10000
#elif defined(TARGET_ALPHA)
                CrashDumpHeader->MachineImageType != IMAGE_FILE_MACHINE_ALPHA
#elif defined(TARGET_PPC)
                CrashDumpHeader->MachineImageType != IMAGE_FILE_MACHINE_POWERPC
#else
#error( "unknown target machine" );
#endif
                                    ) {
                return System_Invalid;
            }
            *pImageType = Image_Dump;
        }
#endif  // !KERNEL
        return System_Console;
    }

    if ( dosHdr.e_lfanew == 0 ) {
        /*
         *  Straight DOS exe.
         */

        DPRINT(1, (_T("[DOS image].\n")));
        *pImageType = Image_16;

        CloseHandle(hFile);
        return System_Console;
    }

    /*
     *  Now look at the next EXE header (either NE or PE)
     */

    SetFilePointer(hFile, dosHdr.e_lfanew, NULL, FILE_BEGIN);
    GotIt = FALSE;
    ret = System_GUI;

    /*
     *  See if this is a Win16 program
     */

    if (ReadFile(hFile, &os2Hdr, sizeof(os2Hdr), &cb, NULL)  &&
        (cb == sizeof(os2Hdr))) {

        if ( os2Hdr.ne_magic == IMAGE_OS2_SIGNATURE ) {
            /*
             *  Win16 program  (may be an OS/2 exe also)
             */

            DPRINT(1, (_T("[Win16 image].\n")));
            *pImageType = Image_16;
            GotIt  = TRUE;
        } else if ( os2Hdr.ne_magic == IMAGE_OS2_SIGNATURE_LE ) {
            /*
             *  OS2 program - Not supported
             */

            DPRINT(1, (_T("[OS/2 image].\n")));
            *pImageType = Image_Unknown;
            GotIt  = TRUE;
        }
    }

    /*
     *  If the above failed, see if it is an NT program
     */

    if ( !GotIt ) {
        SetFilePointer(hFile, dosHdr.e_lfanew, NULL, FILE_BEGIN);

        if (ReadFile(hFile, &ntHdr, sizeof(ntHdr), &cb, NULL) &&
            (cb == sizeof(ntHdr))                             &&
            (ntHdr.Signature == IMAGE_NT_SIGNATURE)) {
            /*
             *  All CUI (Character user interface) subsystems
             *  have the lowermost bit set.
             */

            DPRINT(1, ((ntHdr.OptionalHeader.Subsystem & 1) ?
                       _T("[*Character mode app*]\n") : _T("[*Windows mode app*]\n")));

            ret = ((ntHdr.OptionalHeader.Subsystem & 1)) ?
              System_Console : System_GUI;
            *pImageType = Image_32;
        } else {
            DWORD   FileSize;

            FileSize = SetFilePointer(hFile, 0, NULL, FILE_END);

            if ( (DWORD)dosHdr.e_lfanew > FileSize ) {
                //
                //  Bogus e_lfanew, assume DOS
                //
                DPRINT(1, (_T("[DOS image assumed].\n")));
                *pImageType = Image_16;
                ret =  System_Console;

            } else {

                //
                //  Not an NT image.
                //
                DPRINT(1, (_T("MAGIC problem(PE).\n")));
                *pImageType = Image_Unknown;
            }
        }
    }

    CloseHandle(hFile);
    return ret;
}                               /* pCharMode() */
#endif


VOID
ReConnectDebugger(
    DEBUG_EVENT *lpde,
    BOOL        fNoDllLoad
    )

/*++

Routine Description:

    This function handles the case where the dm/tl is re-connected to
    a debugger.  This function must re-instate the debugger to the
    correct state that existed before the disconnect action.

    (wesw) 11-3-93

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD            i;
    DEBUG_EVENT      de;
    HPRCX            hprc;
    HTHDX            hthd;
    HTHDX            hthd_lb;
    DWORD            id;
    HANDLE           hThread;
    HPID             hpidNext = hpidRoot;
    BOOL             fException = FALSE;


    //
    // the dm is now connected
    //
    fDisconnected = FALSE;

    //
    // check to see if a re-connection is occurring while the
    // process is running or after a non-servicable debug event
    //
    if (lpde && lpde->dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {

        hprc = HPRCFromPID(lpde->dwProcessId);
        hthd = HTHDXFromPIDTID((PID)lpde->dwProcessId,(TID)lpde->dwThreadId);

        if (lpde->u.Exception.dwFirstChance) {
            hthd->tstate |= ts_first;
        } else {
            hthd->tstate |= ts_second;
        }

        hthd->tstate &= ~ts_running;
        hthd->tstate |= ts_stopped;
    }

    //
    // generate a create process event
    //
    hprc=prcList->next;
    hprc->hpid = hpidNext;
    hpidNext = (HPID) INVALID;
    hthd=hprc->hthdChild;
    ResetEvent(hEventCreateProcess);
    de.dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
    de.dwProcessId = hprc->pid;
    de.dwThreadId = hthd->tid;
    de.u.CreateProcessInfo.hFile = NULL;
    de.u.CreateProcessInfo.hProcess = hprc->rwHand;
    de.u.CreateProcessInfo.hThread = hthd->rwHand;
    de.u.CreateProcessInfo.lpBaseOfImage = (LPVOID)hprc->rgDllList[0].offBaseOfImage;
    de.u.CreateProcessInfo.dwDebugInfoFileOffset = 0;
    de.u.CreateProcessInfo.nDebugInfoSize = 0;
    de.u.CreateProcessInfo.lpStartAddress = (LPVOID)(DWORD)PC(hthd);
    de.u.CreateProcessInfo.lpThreadLocalBase = NULL;
    de.u.CreateProcessInfo.lpImageName = NULL;
    de.u.CreateProcessInfo.fUnicode = 0;
    NotifyEM(&de, hthd, 0, hprc);
    WaitForSingleObject(hEventCreateProcess, INFINITE);

    //
    // mark the process as 'being connected' so that the continue debug
    // events that are received from the shell are ignored
    //
    hprc->pstate |= ps_connect;


    //
    // look for a thread that is stopped and not dead
    //
    for (hthd=hprc->hthdChild,hthd_lb=NULL; hthd; hthd=hthd->nextSibling) {
        if ((!(hthd->tstate & ts_dead)) && (hthd->tstate & ts_stopped)) {
            hthd_lb = hthd;
            break;
        }
    }

    if (hthd_lb == NULL) {
        //
        // if we get here then there are no threads that are stopped
        // so we must look for the first alive thread
        //
        for (hthd=hprc->hthdChild,hthd_lb=NULL; hthd; hthd=hthd->nextSibling) {
            if (!(hthd->tstate & ts_dead)) {
                hthd_lb = hthd;
                break;
            }
        }
    }

    if (hthd_lb == NULL) {
        //
        // if this happens then we are really screwed.  there are no valid
        // threads to use, so lets bail out.
        //
        return;
    }

    if ((hthd_lb->tstate & ts_first) || (hthd_lb->tstate & ts_second)) {
        fException = TRUE;
    }

    //
    // generate mod loads for all the dlls for this process
    //
    // this MUST be done before the thread creates because the
    // current PC of each thread can be in any of the loaded
    // modules.
    //
    hthd = hthd_lb;
    if (!fNoDllLoad) {
        for (i=0; i<(DWORD)hprc->cDllList; i++) {
            if (hprc->rgDllList[i].fValidDll) {
                de.dwDebugEventCode        = LOAD_DLL_DEBUG_EVENT;
                de.dwProcessId             = hprc->pid;
                de.dwThreadId              = hthd->tid;
                de.u.LoadDll.hFile         = NULL;
                de.u.LoadDll.lpBaseOfDll   = (LPVOID)hprc->rgDllList[i].offBaseOfImage;
                de.u.LoadDll.lpImageName   = hprc->rgDllList[i].szDllName;
                de.u.LoadDll.fUnicode      = FALSE;
                NotifyEM(&de, hthd, 0, hprc);
            }
        }
    }


    //
    // loop thru all the threads for this process and
    // generate a thread create event for each one
    //
    for (hthd=hprc->hthdChild; hthd; hthd=hthd->nextSibling) {
        if (!(hthd->tstate & ts_dead)) {
            if (fException && hthd_lb == hthd) {
                //
                // do this one last
                //
                continue;
            }

            //
            // generate a thread create event
            //
            ResetEvent( hprc->hEventCreateThread );
            ResetEvent( hEventContinue );
            de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
            de.dwProcessId = hprc->pid;
            de.dwThreadId = hthd->tid;
            NotifyEM( &de, hthd, 0, hprc );

            WaitForSingleObject( hprc->hEventCreateThread, INFINITE );

            //
            // wait for the shell to continue the new thread
            //
            WaitForSingleObject( hEventContinue, INFINITE );
        }
    }

    if (fException) {
        hthd = hthd_lb;
        //
        // generate a thread create event
        //
        ResetEvent( hprc->hEventCreateThread );
        ResetEvent( hEventContinue );
        de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
        de.dwProcessId = hprc->pid;
        de.dwThreadId = hthd->tid;
        NotifyEM( &de, hthd, 0, hprc );

        WaitForSingleObject( hprc->hEventCreateThread, INFINITE );

        //
        // wait for the shell to continue the new thread
        //
        WaitForSingleObject( hEventContinue, INFINITE );
    }

    //
    // generate a breakpoint event
    //
    hthd = hthd_lb;

    if (hthd->tstate & ts_running) {

#if 0
        //
        // this will create a thread in the debuggee that will
        // immediatly stop at a breakpoint.  this will cause the
        // shell to think that we are processing a normal attach.
        //

        HMODULE hModule = GetModuleHandle("ntdll.dll");
        FARPROC ProcAddr = GetProcAddress(hModule, "DbgBreakPoint" );


        hThread = CreateRemoteThread( (HANDLE) hprc->rwHand,
                                      NULL,
                                      4096,
                                      (LPTHREAD_START_ROUTINE) ProcAddr,
                                      0,
                                      0,
                                      &id
                                    );

#endif
		DmHaltThread(0);

    } else if (!lpde) {

        de.dwProcessId                  = hprc->pid;
        de.dwThreadId                   = hthd->tid;
        if ((hthd->tstate & ts_first) || (hthd->tstate & ts_second)) {
            de.dwDebugEventCode         = EXCEPTION_DEBUG_EVENT;
        } else {
            de.dwDebugEventCode         = BREAKPOINT_DEBUG_EVENT;
        }
        de.u.Exception.dwFirstChance    = hthd->tstate & ts_first;
        de.u.Exception.ExceptionRecord  = hthd->ExceptionRecord;
        NotifyEM(&de, hthd, 0, 0);

    }

    //
    // reset the process state
    //
    hprc->pstate &= ~ps_connect;

    return;
}

/*
 * HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
 *
 * In NT 3.x, it is impossible for a GUI app to spawn a console
 * app and have one or two of the console app's standard handles
 * redirected away from the console; you can only do it with
 * either none of the handles redirected, or all three of them.
 * See also the struct STARTUPINFO in the Win32 Programmer's Reference
 *
 * However, I learned by experimentation that it just so happens
 * that there are a few magic values I can pass in for stdin,
 * stdout, and stderr, which will have the desired effect of
 * leaving that handle attached to the console.  For example,
 * if I pass ((HANDLE)3) for stdin, stdin will stay attached
 * to the console.  stdout is ((HANDLE)7), and stderr is
 * ((HANDLE)11)
 *
 * In UNIX, you would probably use 0, 1, and 2.  Perhaps it is no
 * conicidence that for x={0, 1, 2}, the magic handles are (x<<2 | 3)
 *
 * HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
 */
HANDLE const rghMagic[3] = {(HANDLE)3, (HANDLE)7, (HANDLE)11};

/*
 * Close3Handles: helper function for I/O redirection
 */

void
Close3Handles(
    HANDLE *rgh
    )
{
    int iFile;

    for (iFile=0; iFile<3; ++iFile) {
        if (rgh[iFile] != 0 &&
             rgh[iFile] != INVALID_HANDLE_VALUE &&
             rgh[iFile] != rghMagic[iFile])
        {
             VERIFY(CloseHandle(rgh[iFile]));
             rgh[iFile] = 0;
        }
    }
}

#if 0
XOSD
ProcessDebuggeeRedirection(
LPTSTR lszCommandLine,
STARTUPINFO FAR * psi
)
/*++

Routine Description:

    Parse command line redirection

Arguments:

    szCommandLine           A string representing the command line.
    psi                     Where we leave our mark


Return Value:

    xosdNone                        If no error
    xosdIORedirBadFile      If we can't open the file
    xosdIORedirSyntax       If the redir syntax is bad

Notes:

    The redirection-related text is removed from lszCommandLine
    Redirection is a hack in NT
    psi -> dwFlags += STARTF+USESTDHANDLES
    psi -> hStd{Input,Output,Error} are set

--*/
{

    LPTSTR          lszArg;
    LPTSTR          lszBegin;
    LPTSTR          lszEnd;

    BOOL            fInQuote = FALSE;
    BOOL            fAppend;

    // iFile is 0,1,2 for std{in,out,err}
    int             iFile, iFileFrom;
    CHAR            ch;

    lszArg = lszCommandLine;

    while (*lszArg) {
        // skip over quoted text on command line
        if (*lszArg == '"') {
            fInQuote = !fInQuote;
        }
        if (fInQuote) {
            // If in quoted text, increment lszArg
            lszArg = _ftcsinc( lszArg );
            continue;
        }

        lszBegin = lszArg;

        // recognize leading digit for "2>blah", "0<blah", etc.
        // Put it in iFile
        if (*lszArg >= '0' && *lszArg <= '2') {
            // iFile holds the file descriptor
            iFile = *lszArg - '0';
            lszArg = _ftcsinc( lszArg );
            if (*lszArg == '\0') {
                break;
            }
        } else {
            // For 'foo.exe > bar.txt' (no file number), we'll figure it out later.
            iFile = -1;
        }

        // If there is redirection going on, process it.
        if (*lszArg == '<' || *lszArg == '>') {
            psi -> dwFlags |= STARTF_USESTDHANDLES;

            // if there was no explicit leading digit, figure out the
            // implicit one: 0 for "<", 1 for ">" or ">>"
            if (iFile == -1) {
                if (*lszArg == '<') {
                    iFile = 0;
                } else {
                    iFile = 1;
                }
            } else if (iFile == 0) {
                if (*lszArg == '>') {
                    Close3Handles(rgh);
#if 0 // The error handling upstairs is bad, so just don't bother redirecting.
                    return xosdIORedirSyntax;
#else
					rgh[iFile] = 0; // Don't redirect, then
#endif
                }
            } else {
                if (*lszArg == '<') {
                    Close3Handles(rgh);
#if 0 // The error handling upstairs is bad, so just don't bother redirecting.
                    return xosdIORedirSyntax;
#else
					rgh[iFile] = 0; // Don't redirect, then
#endif
                }
            }

            if (lszArg[0] == '>' && lszArg[1] == '>') {
                fAppend = TRUE;
                lszArg = _ftcsinc( lszArg );
            } else {
                fAppend = FALSE;
            }
            lszArg = _ftcsinc( lszArg );

            // deal with "2>&1" and so on
            if (*lszArg == '&') {
                lszArg = _ftcsinc( lszArg );

                while (*lszArg == ' ' || *lszArg == '\t') {
                    lszArg = _ftcsinc( lszArg );
                }

                // error conditions:
                //              1<&x    where ix not in [012]
                //              1<&1
                //              2>>&1
                if (*lszArg < '0' || *lszArg > '2' ||
                        *lszArg - '0' == iFile || fAppend) {
                    Close3Handles(rgh);
#if 0 // The error handling upstairs is bad, so just don't bother redirecting.
                    return xosdIORedirSyntax;
#else
					rgh[iFile] = 0; // Don't redirect, then
#endif
                }

                iFileFrom = *lszArg - '0';

                if (rgh[iFileFrom] == 0 ||
                        rgh[iFileFrom] == INVALID_HANDLE_VALUE) {
                    rgh[iFile] = rgh[iFileFrom];
                } else {
                    HANDLE hProcess = GetCurrentProcess();

                    if (!DuplicateHandle(
                                    hProcess, rgh[iFileFrom],
                                    hProcess, &rgh[iFile],
                                    0, TRUE, DUPLICATE_SAME_ACCESS))
                    {
                        Close3Handles(rgh);
#if 0 // The error handling upstairs is bad, so just don't bother redirecting.
                        return xosdIORedirBadFile;
#else
						rgh[iFile] = 0; // Don't redirect, then
#endif
                    }
                }
                lszArg = _ftcsinc( lszArg );    // get past last digit
            } else {
                static char rgchEndFilename[] = "\t \"&,;<=>";
                static SECURITY_ATTRIBUTES sa = {sizeof(sa), 0, TRUE};

                // skip blanks after "<" or ">"
                while (*lszArg == ' ' || *lszArg == '\t') {
                    ++lszArg;
                }

                // append null to szArg
                lszEnd = lszArg;
                while (*lszEnd && !_tcschr(rgchEndFilename, *lszEnd)) {
                    lszEnd = _ftcsinc( lszEnd );
                }
                ch = *lszEnd;
                *lszEnd = '\0';

                if (iFile) {

                    // std{out,err}
                    rgh[iFile] = CreateFile (
					  lszArg,
					  GENERIC_READ|GENERIC_WRITE,
					  FILE_SHARE_READ,
					  &sa,
					  fAppend ? OPEN_EXISTING : CREATE_ALWAYS,
					  FILE_ATTRIBUTE_NORMAL,
					  0);
				
                } else {
                    // stdin
                    rgh[iFile] = CreateFile (
                                        lszArg,
                                        GENERIC_READ,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                                        &sa,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        0);
                }

                if (rgh[iFile] == INVALID_HANDLE_VALUE) {
                    //  // The file could not be opened as desired.
                    //  _ftcsncpy(szErrArg, lszArg, sizeof(szErrArg));
                    //  szErrArg[sizeof(szErrArg)-1] = '\0';
                    //  _ftcsncpy(szErrExe, lszExe, sizeof(szErrExe));
                    //  szErrExe[sizeof(szErrExe)-1] = '\0';

                    // restore byte after arg
                    *lszEnd = ch;

                    Close3Handles(rgh);
#if 0 // The error handling upstairs is bad, so just don't bother redirecting.
                    return xosdIORedirBadFile;
#else
					rgh[iFile] = 0; // Don't redirect, then
#endif
                }

                // restore byte after arg
                *lszEnd = ch;

                // if ">>", move to end of file
                if (fAppend) {
                    SetFilePointer(rgh[iFile], 0, NULL, FILE_END);
                }

                // advance lszArg to end of string
                lszArg = lszEnd;
            }

            // remove the redirection from the command line
            if (*lszArg == ' ' || *lszArg == '\t') {
                lszArg++;
            }
            _fmemmove(lszBegin, lszArg,
                        (_ftcslen(lszArg)+1) * sizeof(TCHAR));
            lszArg = lszBegin;
        } else {
            lszArg = _ftcsinc( lszArg );
        }

    } // while

    if (lszCommandLine[0] == ' ' && lszCommandLine[1] == '\0') {
        lszCommandLine[0] = '\0';
    }


    // If we're redirecting at all
    if (psi -> dwFlags & STARTF_USESTDHANDLES) {

        OSVERSIONINFO ver;


        ver.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&ver);

        for (iFile=0; iFile<3; ++iFile) {

            // If they're still unset.

            if (rgh[iFile] == 0) {
                // If we are using NT 3.x or greater,
                // use the hack magic handles. See comments
                // near the definition of rghMagic

                // Unluckily it looks like it is still needed for 4.0
                if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                    rgh[iFile] = rghMagic[iFile];
                } else {
                    rgh[iFile] = INVALID_HANDLE_VALUE;
                }
            }
        }

        psi -> hStdInput  = rgh[0];
        psi -> hStdOutput = rgh[1];
        psi -> hStdError  = rgh[2];
    }

    return xosdNone;
} //ProcessDebuggeeRedirection
#endif


VOID
SetExceptionAddress(
    DEBUG_EVENT*    pde,
    DWORD           addr
    )
{
    pde->u.Exception.ExceptionRecord.ExceptionAddress = (PVOID) addr;
}



#if DBG

VOID
DumpThdHeader(
    )
{
    DebugPrint ("hthd      htid\n");
}

VOID
DumpThread(
    HTHDX   hthd
    )
{
    if (hthd == NULL) {
        DebugPrint ("<Invalid hthd == NULL>\n");
    }

    DebugPrint ("%#x %#x\n", hthd, hthd->tid);
}


// hthd tid

VOID
DumpThreads(
    )
{
    HTHDX   hthd;
    
    DebugPrint ("\n");
    DumpThdHeader ();

    for (hthd = thdList->next; hthd; hthd = hthd->next) {
        DumpThread (hthd);
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\bp.h ===
/*
 *  Prototypes and structures for breakpoint handler
 */

extern  BOOL        BPInRange(HPRCX, HTHDX, BREAKPOINT*, LPADDR, DWORD,
                              LPDWORD);
extern  BREAKPOINT* FindProcBP(HPRCX);
extern  BREAKPOINT* FindThreadBP(HTHDX);
extern  BREAKPOINT* FindIdBP(HDEP);
extern  BOOL        RemoveBP(BREAKPOINT*);
extern  BOOL        RemoveAllHprcBP(HPRCX);
extern  void        SetBPFlag(HTHDX, BREAKPOINT*);
extern  BREAKPOINT* AtBP(HTHDX);
extern  void        ClearBPFlag(HTHDX);
extern  void        RestoreInstrBP(HTHDX, BREAKPOINT*);
extern  BREAKPOINT* BPNextHprcPbp( HPRCX hprc, BREAKPOINT * pbp );
extern  BREAKPOINT* BPNextHthdPbp( HTHDX hthd, BREAKPOINT * pbp );

PBREAKPOINT
SetBP(
    HPRCX hprc,
    HTHDX hthd,
    BPTP bptype,
    BPNS bpnotify,
    LPADDR paddr,
    HPID id
    );

PBREAKPOINT
FindBP(
    HPRCX hprc,
    HTHDX hthd,
    BPTP bptype,
    BPNS bpnotify,
    LPADDR paddr,
    BOOL fExact
    );

BOOL
SetBPEx(
      HPRCX         hprc,
      HTHDX         hthd,
      HPID          id,
      DWORD         Count,
      ADDR         *Addrs,
      PBREAKPOINT  *Bps,
      DWORD         ContinueStatus
      );

BOOL
RemoveBPEx(
    DWORD      Count,
    PBREAKPOINT *Bps
    );

PBREAKPOINT
GetNewBp(
    HPRCX         hprc,
    HTHDX         hthd,
    BPTP          BpType,
    BPNS          BpNotify,
    ADDR         *AddrBp,
    HPID          id,
    BREAKPOINT   *BpUse
    );

BOOL
WriteBreakPoint(
    IN PBREAKPOINT Breakpoint
    );

BOOL
RestoreBreakPoint(
    IN PBREAKPOINT Breakpoint
    );

void
AddBpToList(
    PBREAKPOINT pbp
    );


void ReleaseBP(PBREAKPOINT pbp);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\event.c ===
/*************************************************************************
**                                                                      **
**                              EVENT.C                                 **
**                                                                      **
**************************************************************************
**                                                                      **
**  This file contains the expected event checker.  When the default    **
**  event handling for a debug event (from the OS) is not the           **
**  desired handling, then an expected event may be registered.         **
**  For every event which occurs the expected event handler checks      **
**  to see if it is the expected event and if so then it will           **
**  cause the action function associated with the expected event        **
**  to be executed.  The default event handler will not be executed     **
**                                                                      **
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/************************************************************************/


/************************************************************************/

extern EXPECTED_EVENT   masterEE, *eeList;
extern HTHDXSTRUCT      masterTH;
extern HPRCXSTRUCT      masterPR;
extern HTHDX            thdList;
extern HPRCX            prcList;
extern HTHDX            ourHTHD;
extern HPRCX            ourHPRC;
extern DEBUG_EVENT      falseSSEvent;
extern METHOD           EMNotifyMethod;
extern char             lpbBuffer;
extern DDVECTOR         DebugDispatchTable[];
extern CMD_DESC         CommandDispatchTable[];
extern CRITICAL_SECTION csEventList;

/************************************************************************/

/************************************************************************/



PEXPECTED_EVENT
RegisterExpectedEvent(
    HPRCX       hprc,
    HTHDX       hthd,
    DWORD       eventCode,
    DWORD       subClass,
    METHOD    * notifier,
    ACVECTOR    action,
    BOOL        fPersistent,
    LPVOID      lparam
    )
/*++


Routine Description:

    This function is used to register an expected event.  When a registered
    event occurs, the normal dispatcher is not called; instead an optional
    notifier function and an action function are called.

    If an event is marked Persistent, it will not be discarded when another
    event occurs.

    If hthd is supplied, an exact process/thread match is required to score
    a hit.  If hthd is 0 then any thread in hprc will be matched to it.

Arguments:

    hprc        - Supplies descriptor for process to check for expected event

    hthd        - Supplies optional thread to check for expected event

    eventCode   - Supplies event code to check for

    subClass    - Supplies sub-class of event code (for exceptions)

    notifier    - Supplies optional notifier procedure

    action      - Supplies procedure to be called on event

    fPersistent - Supplies flag to mark event as persistent

    lparam      - Supplies Optional data for action routine.

Return Value:

    Address of the event just registered (NULL on failure)

--*/
{
    PEXPECTED_EVENT ee;

    DPRINT(5, ("[REE: DE=%x, SC=%x, HTHD=%x]\n", eventCode, subClass, hthd));

    /* Handy asserts */
    if (eventCode == BREAKPOINT_DEBUG_EVENT) {
        assert(subClass != 0);
    }


    /* Allocate the structure */

    ee = (PEXPECTED_EVENT) MHAlloc(sizeof(EXPECTED_EVENT));
    if (ee == NULL) {
        return NULL;
    }

    /* Attach it to the expected event list */

    EnterCriticalSection(&csEventList);

    ee->next        = eeList->next;
    eeList->next    = ee;

    /* Stuff it */

    ee->hprc        = hprc;
    ee->hthd        = hthd;
    ee->eventCode   = eventCode;
    ee->subClass    = subClass;
    ee->notifier    = notifier;
    ee->action      = action;
    ee->fPersistent = fPersistent;
    ee->lparam      = lparam;

    LeaveCriticalSection(&csEventList);

    return ee;
}                       /* RegisterExpectedEvent() */



PEXPECTED_EVENT
PeeIsEventExpected(
    HTHDX hthd,
    DWORD eventCode,
    DWORD subClass,
    BOOL bRemove
    )
/*++

Routine Description:

    This function will go though the list of expected events and
    return the first event which matches all of the required criteria.
    The event is removed from the list of expected events if bRemove
    is TRUE.

Arguments:

    hthd        - Supplies descriptor for Thread in which the event occured

    eventCode   - Supplies Event code which occured

    subClass    - Supplies sub-class of the event code

    bRemove     - Removes from the expected event list.

Return Value:

    The event if one was located, NULL otherwise.

--*/
{
    PEXPECTED_EVENT    prev=eeList;
    PEXPECTED_EVENT    ee;


    if ((hthd == NULL) && ((eventCode == CREATE_THREAD_DEBUG_EVENT) ||
                           (eventCode == CREATE_PROCESS_DEBUG_EVENT))) {
        return (PEXPECTED_EVENT)NULL;
    }

    EnterCriticalSection(&csEventList);

    //assert(hthd != NULL);

    /* Try to find an event with the given description */


    for (ee = prev->next; ee; prev=prev->next,ee=ee->next) {

        if (((hthd == 0) ||
             (ee->hthd==hthd) ||
             (ee->hprc == hthd->hprc && ee->hthd==(HTHDX)0)) &&
            (ee->eventCode==eventCode) &&
            ((ee->subClass==NO_SUBCLASS) ||
             ee->subClass==subClass)) {

            /* Found it, remove it from the list */

            if (bRemove) {
                prev->next = ee->next;
            }

            LeaveCriticalSection(&csEventList);

            DPRINT(5, ("Event Expected: %x\n", ee));

            /* and return it to the caller */

            return ee;
        }
    }

    LeaveCriticalSection(&csEventList);

    DPRINT(5, ("\n"));

    return (PEXPECTED_EVENT)NULL;
}                                   /* PeeIsEventExpected() */


void
ConsumeAllThreadEvents(
    HTHDX   hthd,
    BOOL    fClearPersistent
    )
/*++

Routine Description:

    This function will go through the list of expected events and
    remove all events found associated with the specified Thread.

Arguments:

    hthd                - Supplies thread descriptor

    fClearPersistent    - If FALSE, events marked "persistent" will
                          not be cleared.

Return Value:

    None

--*/
{
    PEXPECTED_EVENT    prev;
    PEXPECTED_EVENT    ee;
    PEXPECTED_EVENT    eet;

	if (hthd->hprc->hAsyncStopRequest) {
		VERIFY (RemoveTimerEvent (hthd->hprc, hthd->hprc->hAsyncStopRequest));
		hthd->hprc->hAsyncStopRequest = NULL;
	}
		
	if (hthd && hthd->hprc) {
		hthd->hprc->fStepInto = FALSE;
	}

    // It is a little unfortunate that this must go here.

    ClearThreadWalkFlags (hthd);
    
    /* Try to find events for the specified thread */

    EnterCriticalSection(&csEventList);

    prev = eeList;
    for (ee = eeList->next; ee; ee = eet){

        eet = ee->next;

        if (ee->hthd != hthd || (!fClearPersistent && ee->fPersistent)) {

            prev = ee;

        } else {

            /* Found one, remove it from the list */

            prev->next = eet;

            /* Check if it was a breakpoint event*/

            if (ee->eventCode==EXCEPTION_DEBUG_EVENT
                && ee->subClass==EXCEPTION_BREAKPOINT) {

                /* it was a breakpoint event,    */
                /* must free the bp structure    */
                RemoveBP((PBREAKPOINT)ee->lparam);

            } else if ( ee->eventCode==BREAKPOINT_DEBUG_EVENT ) {

                RemoveBP((PBREAKPOINT)ee->subClass);

            }

            /* Free the event structure      */
            MHFree(ee);
        }
    }

    LeaveCriticalSection(&csEventList);

    return;
}


void
ConsumeAllProcessEvents(
    HPRCX   hprc,
    BOOL    fClearPersistent
    )
/*++

Routine Description:

    This function will go through the list of expected events and
    remove all events found associated with the specified Process.

Arguments:

    hprc                - Supplies process descriptor

    fClearPersistent    - If FALSE, events marked "persistent" will
                          not be cleared.

Return Value:

    None

--*/
{
    PEXPECTED_EVENT    prev;
    PEXPECTED_EVENT    ee;
    PEXPECTED_EVENT    eet;

	if (hprc) {
		hprc->fStepInto = FALSE;
	}
	
	if (hprc->hAsyncStopRequest) {
		VERIFY (RemoveTimerEvent (hprc, hprc->hAsyncStopRequest));
		hprc->hAsyncStopRequest = NULL;
	}

	ClearProcessWalkFlags (hprc);
    
    /* Try to find events for the specified prcess */

    EnterCriticalSection(&csEventList);

    prev = eeList;
    for ( ee = prev->next; ee; ee = eet ) {

        eet = ee->next;

        if (ee->hprc != hprc || (!fClearPersistent && ee->fPersistent)) {

            prev = ee;

        } else {

            /* Found one, remove it from the list */

            prev->next = ee->next;

            /* Check if it was a breakpoint event*/

            if (ee->eventCode==EXCEPTION_DEBUG_EVENT
                && ee->subClass==EXCEPTION_BREAKPOINT) {

                /* it was a breakpoint event,    */
                /* must free the bp structure    */
                RemoveBP((PBREAKPOINT)ee->lparam);

            } else if ( ee->eventCode==BREAKPOINT_DEBUG_EVENT ) {

                RemoveBP((PBREAKPOINT)ee->subClass);

            }

            /* Free the event structure      */
            MHFree(ee);
        }
    }

    LeaveCriticalSection(&csEventList);
    return;
}

VOID
ConsumeSpecifiedEvent(
    PEXPECTED_EVENT eeDel
    )
{
    PEXPECTED_EVENT    prev;
    PEXPECTED_EVENT    ee;
    PEXPECTED_EVENT    eet;

    /* Try to find events for the specified prcess */

    EnterCriticalSection(&csEventList);

    prev = eeList;
    for ( ee = prev->next; ee; ee = eet ) {

        eet = ee->next;

        if (ee != eeDel) {

            prev = ee;

        } else {

            /* Found it, remove it from the list */

            prev->next = ee->next;

            /* Check if it was a breakpoint event*/

            if (ee->eventCode==EXCEPTION_DEBUG_EVENT
                && ee->subClass==EXCEPTION_BREAKPOINT) {

                /* it was a breakpoint event,    */
                /* must free the bp structure    */
                RemoveBP((PBREAKPOINT)ee->lparam);

            } else if ( ee->eventCode==BREAKPOINT_DEBUG_EVENT ) {

                RemoveBP((PBREAKPOINT)ee->subClass);

            }

            /* Free the event structure      */
            MHFree(ee);

            break;
        }
    }

    LeaveCriticalSection(&csEventList);
    return;
}


#if DBG

char* szEvents [] = {
        "<None>",
        "Exception",
        "CreateThread",
        "CreateProcess",
        "ExitThread",
        "ExitProcess",
        "LoadDll",
        "UnloadDll",
        "DebugString",
        "Rip",
        "Breakpoint",
        "CheckBreakpoint",
        "SegmentLoad",
&        "DestroyProcess",
        "DestroyThread",
        "AttachDeadlock",
        "Entrypoint",
        "LoadComplete",
        "InputDebugString",
        "Message",
        "MessageSend",
        "FuncExit",
        "Ole",
        "Fiber",
        "Generic",
        "BogusWin95",
        "MAX"
};

char*
szOrpcEvents [] = {
        "Nil",
        "Unrecognized",
        "ClientGetBufferSize",
        "ClientFillBuffer",
        "ServerNotify",
        "ServerGetBufferSize",
        "ServerFillBuffer",
        "ClientNotify"
};

#if 0
char*
OleEventToStr(
    DWORD   eventCode
    )
{
    if (eventCode < 0 || eventCode >= orpcClientNotify) {
        return "<Bad Event>";
    }

    return szOrpcEvents [eventCode];
}
#endif
    
VOID
DumpEventHeader(
    )
{
    DebugPrint ("  Event     Hthd      Class          SubClass\n");
}

char*
EventToStr(
    DWORD   eventCode
    )
{
    if (eventCode < 0 || eventCode >= MAX_EVENT_CODE) {
        return "<Bad Event>";
    }

    return szEvents [eventCode];
}


VOID
DumpBpHeader(
    );

VOID
DumpBp(
    PBREAKPOINT
    );
    
VOID
DumpEventSubClass(
    DWORD   event,
    DWORD   subClass
    )
{
    switch (event) {

#if 0
        case OLE_DEBUG_EVENT:
            DebugPrint ("%s\n", OleEventToStr (subClass));
            break;
#endif

        case BREAKPOINT_DEBUG_EVENT:
#if 0
            DebugPrint ("\n    ");
            DumpBpHeader ();
            DebugPrint ("    ");
            DumpBp ((PBREAKPOINT) subClass);
#endif

            DebugPrint ("bp = %#x; addr = %#x\n",
                        subClass,
                        ((PBREAKPOINT) subClass)->addr.addr.off);
            break;

        default:
            DebugPrint ("\n");
    }
}
                
    

VOID
DumpEvent(
    PEXPECTED_EVENT ee
    )
{
    DebugPrint (" %c%08x  %08x  %-15.15s",
            ee->fPersistent ? '*' : ' ',
            ee,
            ee->hthd,
            EventToStr (ee->eventCode));

    DumpEventSubClass (ee->eventCode, ee->subClass);
}

VOID
DumpEvents(
    )
{
    PEXPECTED_EVENT ee;

    // NOTE: this does not lock the critical section.  Be careful.

    try {
    
        DumpEventHeader ();
        
        for (ee = eeList->next ; ee; ee = ee->next) {
            DumpEvent (ee);
        
        }
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint ("<Error: exception dumping evenet list>\n");
    }
    

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\fiber.h ===
/* 
** fiber.h
** 9/23/96
** Fiber Debugging Support
*/

typedef enum {
	ecreate_fiber=1,
	edelete_fiber
} EFBR;

#define EXCEPTION_FIBER_DEBUG (0x8EEFFAD5)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\dmxbox.c ===
/*
 *
 * dmxbox.cpp
 *
 * Xbox implementation of the DM
 *
 */

#include "precomp.h"
#pragma hdrstop
#include "fiber.h"
#include "fbrdbg.h"
//#include "xfiber.h"

#define REPLY(TYPE, name) TYPE name = (TYPE)LpDmMsg->rgb

/****************************************************************************/
//
// ContinueDebugEvent() queue.
//  We can only have one debug event pending per process, but there may be
//  one event pending for each process we are debugging.
//
//  There are 200 entries in a static sized queue.  If there are ever more
//  than 200 debug events  pending, AND windbg actually handles them all in
//  less than 1/5 second, we will be in trouble.  Until then, sleep soundly.
//
/****************************************************************************/
typedef struct tagCQUEUE {
    struct tagCQUEUE *next;
    DWORD  pid;
    DWORD  tid;
	BOOL fException;
} CQUEUE, *LPCQUEUE;

static LPCQUEUE lpcqFirst;
static LPCQUEUE lpcqLast;
static LPCQUEUE lpcqFree;
static CQUEUE cqueue[200];
static CRITICAL_SECTION csContinueQueue;

static DWORD dwExecState;
static PVOID rgpvDataBreak[4];
static BYTE rgbDataBreak[4][2];

extern HANDLE hEventCreateProcess;
extern HANDLE hEventContinue;
extern DEBUG_EVENT falseSSEvent;
extern CRITICAL_SECTION csKillQueue;
extern PKILLSTRUCT KillQueue;
extern BOOL         fDisconnected;
extern HPRCX        prcList;

HANDLE hevtReboot;
HANDLE hevtStartBreak;
DWORD g_tidBreak;
PVOID g_pvThreadStart;
DWORD dwTidStopped;
BOOL fDeqStopped;
PDMN_SESSION psessNotify;
BOOL g_fXapiDataValid;
DM_XTLDATA g_dmxd;

DEQ *pdeqFirst;
CRITICAL_SECTION csDEQ;
HANDLE hevtDEQ;

DWORD XboxNotification(ULONG, DWORD);
void GetModLoadDebugEvent(PDMN_MODLOAD, DEBUG_EVENT *);

BOOL FEnsureXapiData(void)
{
    if(!g_fXapiDataValid && SUCCEEDED(DmGetXtlData(&g_dmxd)))
        g_fXapiDataValid = TRUE;
    return g_fXapiDataValid;
}

BOOL WriteBreakPoint(PBREAKPOINT pbp)
{
	return SUCCEEDED(DmSetBreakpoint((PVOID)pbp->addr.addr.off));
}

BOOL RestoreBreakPoint(PBREAKPOINT pbp)
{
	return SUCCEEDED(DmRemoveBreakpoint((PVOID)pbp->addr.addr.off));
}

#ifdef XBOX
#define GR(reg) pcr->reg = dmcr.reg
#define SR(reg) dmcr.reg = pcr->reg

/* Xbox context doesn't match x86 context, so do the dance */
BOOL DbgGetThreadContext(HTHDX hthd, PCONTEXT pcr)
{
	CONTEXT dmcr;
	SR(ContextFlags);
	if(FAILED(DmGetThreadContext(hthd->tid, &dmcr)))
		return FALSE;
	GR(ContextFlags);
	if((dmcr.ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
		GR(Esp);
		GR(Ebp);
		GR(Eip);
		GR(EFlags);
		GR(SegSs);
		GR(SegCs);
	}
	if((dmcr.ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
		GR(Eax);
		GR(Ebx);
		GR(Ecx);
		GR(Edx);
		GR(Edi);
		GR(Esi);
	}
	return TRUE;
}

BOOL DbgSetThreadContext(HTHDX hthd, PCONTEXT pcr)
{
	CONTEXT dmcr;
	SR(ContextFlags);
	if((dmcr.ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
		SR(Esp);
		SR(Ebp);
		SR(Eip);
		SR(EFlags);
		SR(SegSs);
		SR(SegCs);
	}
	if((dmcr.ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
		SR(Eax);
		SR(Ebx);
		SR(Ecx);
		SR(Edx);
		SR(Edi);
		SR(Esi);
	}
	return SUCCEEDED(DmSetThreadContext(hthd->tid, &dmcr));
}
#else
BOOL DbgGetThreadContext(HTHDX hthd, PCONTEXT pcr)
{
	return(SUCCEEDED(DmGetThreadContext(hthd->tid, (PCONTEXT)pcr)));
}

BOOL DbgSetThreadContext(HTHDX hthd, PCONTEXT pcr)
{
	return SUCCEEDED(DmSetThreadContext(hthd->tid, (PCONTEXT)pcr));
}
#endif

#ifdef REGSYNC
void EnsureHthdReg(HTHDX hthdx, DWORD dwFlags)
{
	DWORD dwHave = hthdx->ctx.ContextFlags;
	DWORD dwNeed = dwFlags & ~dwHave;
	if(dwNeed) {
		hthdx->ctx.ContextFlags = dwNeed;
		DmGetThreadContext(hthdx->tid, (PCONTEXT)&hthdx->ctx);
		hthdx->ctx.ContextFlags |= dwHave;
	}
}
#endif

BOOL DbgReadMemory(HPRCX hprc, LPCVOID lpOffset, LPVOID lpb, DWORD cb, LPDWORD lpRead)
{
	DWORD cbT;
	if(!lpRead)
		lpRead = &cbT;
	return(SUCCEEDED(DmGetMemory(lpOffset, cb, lpb, lpRead)) && *lpRead == cb);
}

BOOL DbgWriteMemory(HPRCX hprc, LPVOID lpOffset, LPBYTE lpb, DWORD cb, LPDWORD lpWritten)
{
	DWORD cbT;
	if(!lpWritten)
		lpWritten = &cbT;
	return(SUCCEEDED(DmSetMemory(lpOffset, cb, lpb, lpWritten)) && *lpWritten == cb);
}

void DmSetFocus(HPRCX hprc)
{
	/* Xbox apps are always in focus, so don't need to do anything */
}

DWORD ProcessThreadStatCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	REPLY(LPTST, lptst);
	DM_THREADINFO dmti;

    if (!hthd) {
        WaitForSingleObject(hprc->hEventCreateThread, INFINITE);
        hthd = HTHDXFromHPIDHTID(lpdbb->hpid, lpdbb->htid);
        assert(hthd != 0);
        if (!hthd) {
            LpDmMsg->xosdRet = xosdBadThread;
            return sizeof(TST);
        }
    }

	if(FAILED(DmGetThreadInfo(hthd->tid, &dmti))) {
		LpDmMsg->xosdRet = xosdBadThread;
		return sizeof(TST);
	}

	ZeroMemory(lptst, sizeof *lptst);
    lptst->dwThreadID = hthd->tid;

	if (hthd->szThreadName[0])
		sprintf(lptst->rgchThreadID, "%.*s", IDSTRINGSIZE-1, hthd->szThreadName );
	else
		lptst->rgchThreadID[0] = 0;

	lptst->dwSuspendCount = dmti.SuspendCount;
    lptst->dwSuspendCountMax = MAXIMUM_SUSPEND_COUNT;

	lptst->dwPriority = dmti.Priority;
	lptst->dwPriorityMax = 31;

	sprintf(lptst->rgchPriority, "%2d", lptst->dwPriority);

    if (hthd->tstate & ts_running) {
        lptst->dwState = tstRunning;
        _tcscpy(lptst->rgchState, "Running");
    } else if (hthd->tstate & ts_stopped) {
        lptst->dwState = tstStopped;
        if (hthd->tstate & ts_frozen) {
            //This thread is suspended via threadsuspenditself
            //So it can only get suspended once.
            lptst->dwSuspendCount = 1;
        }
        _tcscpy(lptst->rgchState, "Stopped");
    } else if (hthd->tstate & ts_dead) {
        lptst->dwState = tstExiting;
        _tcscpy(lptst->rgchState, "Exiting");
    } else if (hthd->tstate & ts_destroyed) {
        lptst->dwState = tstDead;
        _tcscpy(lptst->rgchState, "Dead");
    } else {
        lptst->dwState = tstRunnable;
        _tcscpy(lptst->rgchState, "Pre-run");
    }


    if (hthd->tstate & ts_rip ) {
        lptst->dwState |= tstRip;
        _tcscat(lptst->rgchState, ", RIPped");
    } else if (hthd->tstate & ts_first) {
        lptst->dwState |= tstExcept1st;
        _tcscat(lptst->rgchState, ", 1st chance");
    } else if (hthd->tstate & ts_second) {
        lptst->dwState |= tstExcept2nd;
        _tcscat(lptst->rgchState, ", 2nd chance");
    }


    if (hthd->tstate & ts_frozen) {
        lptst->dwState |= tstFrozen;
        _tcscat(lptst->rgchState, ", suspended");
    }

	LpDmMsg->xosdRet = xosdNone;
	return sizeof (TST);
}

BOOL MakeThreadSuspendItself(HTHDX hthd)
{
	return SUCCEEDED(DmSuspendThread(hthd->tid));
}

ULONG ProcessGetSpecialReg(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	DWORD cb = 0;

	switch (*(DWORD*)lpdbb->rgbVar) {
	case CV_ALLREG_ERR:
		{
			DM_THREADINFO dmti;

			/* Last error is first in xapi data */
			if(FEnsureXapiData() && SUCCEEDED(DmGetThreadInfo(hthd->tid,
                    &dmti)) && dmti.TlsBase &&
                    SUCCEEDED(DmGetMemory((PBYTE)dmti.TlsBase +
                    g_dmxd.LastErrorOffset, sizeof(DWORD), LpDmMsg->rgb,
                    NULL)))
				cb = sizeof(DWORD);
		}
		break;
	}

    if (cb)
    {
        LpDmMsg->xosdRet = xosdNone;
        return cb;
    }

    LpDmMsg->xosdRet = xosdInvalidParameter;
    return 0;
}

ULONG ProcessSetSpecialReg(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	/* We don't have any registers that we can set */
	LpDmMsg->xosdRet = xosdInvalidParameter;
    return 0;
}

VOID
ActionNLGDispatch (
    DEBUG_EVENT*	pde,
    HTHDX			hthd,
    DWORD			unused,
    LPVOID			lpv
    )
/*++

Routine Description:


--*/
{
    ADDR                addrPC, addrReturn;
    HNLG                hnlg;
    LPNLG               lpnlg;
    NLG_DESTINATION     nlgDest;
    XOSD                xosd;
    BOOL                fStop = FALSE;
    DWORD               cb;
    BREAKPOINT*			bp = (BREAKPOINT*)lpv;
    METHOD*				ContinueSSMethod;
	BREAKPOINT*			bpT = NULL;

    assert(bp);

    AddrFromHthdx (&addrPC, hthd);

    hnlg = CheckNLG (hthd->hprc, hthd, NLG_DISPATCH, &addrPC);
	assert (hnlg);
    ClearBPFlag (hthd);

    RestoreInstrBP (hthd, bp);

    lpnlg = LLLock (hnlg);

    addrReturn = lpnlg->addrNLGReturn;

    xosd = AddrReadMemory (
        hthd->hprc,
        hthd,
        &lpnlg->addrNLGDestination,
        &nlgDest,
        sizeof ( NLG_DESTINATION ),
        &cb
        );

    LLUnlock (hnlg);

    if (nlgDest.dwSig == NLG_SIG) {

		fStop = FALSE;

		if (nlgDest.dwCode == NLG_COM_PLUS_THUNK) {

			if (hthd->hprc->fStepInto) {
				fStop = TRUE;
			}

		} else if (nlgDest.dwCode != NLG_DESTRUCTOR_ENTER) {

			CANSTEP CanStep;
			ADDR    addrSP;

			GetAddrOff (addrSP) = GetSPFromNLGDest (hthd, &nlgDest);

			//
			// NOTE: This is really a stack-based BP
			//
			
			if (GetAddrOff (hthd->addrStack) < GetAddrOff (addrSP)) {

				fStop = TRUE;


#ifndef TARGET_i386

				SetAddrOff (&addrPC, nlgDest.uoffDestination);
				GetCanStep (hthd->hprc->hpid, hthd->htid, &addrPC, &CanStep);

				switch (CanStep.Flags) {

					case CANSTEP_YES:
						GetAddrOff (addrPC) += CanStep.PrologOffset;
						break;

					default:
						fStop = FALSE;
//						assert (FALSE);
						break;
				}
#endif
			}
		}

		if (fStop) {
		
//				ConsumeAllThreadEvents (hthd);
			SetAddrOff (&addrPC, nlgDest.uoffDestination);
			bpT = SetBP (hthd->hprc,
						 hthd,
						 bptpExec,
						 bpnsStop,
						 &addrPC,
						 (HPID)INVALID
						 );

			RegisterExpectedEvent (hthd->hprc,
								   hthd,
								   BREAKPOINT_DEBUG_EVENT,
								   (DWORD)bpT,
								   DONT_NOTIFY,
								   ActionNLGDestination,
								   FALSE,
								   bpT
								   );
		}
    }

    //
    // Keep ourselves registered. Then Consume will remove this BP
    //
	
    RegisterExpectedEvent (
        hthd->hprc,
        hthd,
        BREAKPOINT_DEBUG_EVENT,
        (DWORD)lpv,
        DONT_NOTIFY,
        ActionNLGDispatch,
        FALSE,
        lpv
        );

    ContinueSSMethod = (METHOD*)MHAlloc(sizeof(METHOD));
    assert (ContinueSSMethod);
    ContinueSSMethod->notifyFunction = MethodContinueSS;
    ContinueSSMethod->lparam         = ContinueSSMethod;
    ContinueSSMethod->lparam2        = lpv;
    if(lpv && lpv != EMBEDDED_BP)
        ++((PBREAKPOINT)lpv)->cthd;
    SingleStep (hthd, ContinueSSMethod, FALSE, FALSE);

} // ActionNLGDispatch

/*** PROCESSDMFNONLOCALGOTO
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURN:
 *
 * DESCRIPTION:
 *
 *      This is called in response to a dmfNonLocalGoto command from the EM.
 *
 ****************************************************************************/

VOID
ProcessNonLocalGoto (
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    LPNLG   lpnlg = (LPNLG)lpdbb->rgbVar;
    HNLG    hnlg;
    XOSD    xosd = xosdNone;

    if ( lpnlg->fEnable ) {
        hnlg = LLCreate ( hprc->llnlg );

        if ( !hnlg ) {
            /*
            ** REVIEW: Memory Failure
            */
            assert ( FALSE );
        }
        else {
            LPNLG lpnlgT;
            BREAKPOINT *bp;
            LLAdd ( hprc->llnlg, hnlg );
            lpnlgT = LLLock ( hnlg );

            *lpnlgT = *lpnlg;

            emiAddr ( lpnlgT->addrNLGDispatch ) = 0;
            emiAddr ( lpnlgT->addrNLGReturn ) = 0;
            emiAddr ( lpnlgT->addrNLGReturn2 ) = 0;
            emiAddr ( lpnlgT->addrNLGDestination ) = 0;

            LLUnlock ( hnlg );
        }
    }
    else {
        hnlg = LLFind ( hprc->llnlg, NULL, &lpnlg->hemi, (LONG)nfiHEMI );
        if ( !hnlg ) {
            /*
            ** We better have it otherwise the EM shouldn't be telling us
            ** about to remove it.
            */
            assert ( FALSE );
        } else {
            LPNLG   lpnlgT = LLLock ( hnlg );

            BREAKPOINT *bp = FindBP( hprc, hthd, bptpExec, bpnsStop, &lpnlgT->addrNLGDispatch, TRUE);
            EXPECTED_EVENT *ee = PeeIsEventExpected(NULL, BREAKPOINT_DEBUG_EVENT, (DWORD)bp, TRUE);
            if (ee) {
                ConsumeSpecifiedEvent(ee);
            }

            LLUnlock ( hnlg );

            LLDelete ( hprc->llnlg, hnlg );
        }

    }

    Reply(0, &xosd, lpdbb->hpid);
} // ProcessDmfNonLocalGoto

/***
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURN:
 *
 * DESCRIPTION:
 *
 ****************************************************************************/

INT
WINAPI
NLGComp (
    LPNLG lpnlg,
    LPV lpvKey,
    LONG lParam
    )
{
    NFI nfi = (NFI)lParam;

    switch ( nfi ) {
        case nfiHEMI :
            if ( lpnlg->hemi == *(LPHEMI)lpvKey ) {
                return fCmpEQ;
            } else {
                return fCmpLT;
            }
            break;

        default :
            assert ( FALSE );
			return fCmpEQ;
            break;
    }

} // NLGComp
/*** CHECKNLG
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURN:
 *
 * DESCRIPTION:
 *
 ****************************************************************************/

HNLG
CheckNLG (
    HPRCX hprc,
    HTHDX hthd,
    NLG_LOCATION nlgLoc,
    LPADDR lpaddrPC
    )
{
    HNLG    hnlg = hnlgNull;
    HNLG    hnlgRet = hnlgNull;

    while ( !hnlgRet && ( hnlg = LLNext ( hprc->llnlg, hnlg ) ) ) {
                LPNLG   lpnlg = LLLock ( hnlg );
                LPADDR  lpaddr;
                LPADDR  lpaddr2 = NULL;

        switch ( nlgLoc ) {
            case NLG_DISPATCH :
                lpaddr = &lpnlg->addrNLGDispatch;
                break;

            case NLG_RETURN :
                lpaddr = &lpnlg->addrNLGReturn;
                lpaddr2 = &lpnlg->addrNLGReturn2;
                break;

            default :
                assert ( FALSE );
        }

        if ( FAddrsEq ( *lpaddr, *lpaddrPC ) ) {
            hnlgRet = hnlg;
        } else if ((lpaddr2 != NULL) && FAddrsEq ( *lpaddr2, *lpaddrPC ) ) {
            hnlgRet = hnlg;
        }
        LLUnlock ( hnlg );
    }

    return ( hnlgRet );

} // CheckNLG


VOID
ActionNLGDestination (
    DEBUG_EVENT* pde,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    )
{
    BREAKPOINT* bp = (BREAKPOINT*)lpv;

    assert(bp);
    RemoveBP(bp);
    hthd->fReturning = FALSE;
    ConsumeAllThreadEvents(hthd, FALSE);

    NotifyEM(&falseSSEvent, hthd, 0, 0);
}

void ProcessRemoteQuit(void) { _asm int 3 }

void ProcessVirtualQueryCmd(HPRCX hprc, LPDBB lpdbb)
{
	REPLY(MEMORY_BASIC_INFORMATION *, pmbi);
	LPCVOID lpv;
	BYTE b;
	DWORD cb;
	int cbRet;

	memset(pmbi, 0, sizeof *pmbi);
	lpv = (LPCVOID)((LPADDR)lpdbb->rgbVar)->addr.off;
	if(SUCCEEDED(DmGetMemory(lpv, 1, &b, &cb)))
	{
		LpDmMsg->xosdRet = xosdNone;
		/* this isn't really right, but it'll do for now */
		pmbi->BaseAddress = (PVOID)((DWORD)lpv & 0xfffff000);
		pmbi->AllocationBase = pmbi->BaseAddress;
		pmbi->AllocationProtect = cb ? PAGE_EXECUTE_READWRITE : PAGE_NOACCESS;
		pmbi->RegionSize = 0x1000;
		pmbi->State = cb ? MEM_COMMIT : MEM_FREE;
		pmbi->Protect = pmbi->AllocationProtect;
		pmbi->Type = MEM_PRIVATE;
		cbRet = sizeof *pmbi;
	}
	else
	{
		LpDmMsg->xosdRet = xosdGeneral;
		cbRet = 0;
	}

	Reply(cbRet, LpDmMsg, lpdbb->hpid);
}

void ProcessQuerySelectorCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb) { _asm int 3 }
void ProcessQueryTlsBaseCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb) { _asm int 3 }
void ProcessDebugActiveCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb) { _asm int 3 }

void ProcessGetDmInfoCmd(HPRCX hprc, LPDBB lpdbb, DWORD cb)
{
	REPLY(LPDMINFO, lpi);

	LpDmMsg->xosdRet = xosdNone;

	memset(lpi, 0, sizeof (LPDMINFO));

	/* I wish I knew what all these were.  These are just copied from the
	 * Win32x86 dm */
    lpi->mAsync = asyncRun |
                  asyncMem |
                  asyncStop |
                  asyncBP  |
                  asyncKill |
                  asyncWP |
                  asyncSpawn;
    lpi->fHasThreads = 1;
    lpi->fReturnStep = 0;
    lpi->fAlwaysFlat = 1;
    lpi->fHasReload  = 0;

    lpi->cbSpecialRegs = 0;
    lpi->MajorVersion = 0;
    lpi->MinorVersion = 0;

    lpi->Breakpoints = bptsExec |
                       bptsDataC |
                       bptsDataW |
                       bptsDataR |
                       bptsDataExec;

	lpi->Processor.Type = mptix86;
	lpi->Processor.Endian = endLittle;
	lpi->Processor.Level = 6;
	lpi->Processor.Flags = g_ProcFlags;

	//
    // hack so that TL can call tlfGetVersion before
    // reply buffer is initialized.
    //
    if ( cb >= (FIELD_OFFSET(DBB, rgbVar) + sizeof(DMINFO)) ) {
        memcpy(lpdbb->rgbVar, lpi, sizeof(DMINFO));
    }

    Reply( sizeof(DMINFO), LpDmMsg, lpdbb->hpid );
}

DWORD ProcessAsyncGoCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
    XOSD       xosd = xosdNone;
    DEBUG_EVENT de;

    DEBUG_PRINT("ProcessAsyncGoCmd called.\n\r");

    if ((hthd->tstate & ts_frozen)) {
		if (hthd->tstate & ts_stopped) {
			//
			// if at a debug event, it won't really be suspended,
			// so just clear the flag.
			//
			hthd->tstate &= ~ts_frozen;

		} else if (FAILED(DmResumeThread(hthd->tid))) {

            xosd = xosdBadThread;

        } else {

            hthd->tstate &= ~ts_frozen;

            /*
             * deal with dead, frozen, continued thread:
             */
            if ((hthd->tstate & ts_dead) && !(hthd->tstate & ts_stopped)) {

				_asm int 3

                de.dwDebugEventCode = DESTROY_THREAD_DEBUG_EVENT;
                de.dwProcessId = hprc->pid;
                de.dwThreadId = hthd->tid;
                NotifyEM(&de, hthd, 0, NULL);
                FreeHthdx(hthd);

                hprc->pstate &= ~ps_deadThread;
                for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                    if (hthd->tstate & ts_dead) {
                        hprc->pstate |= ps_deadThread;
                    }
                }

            }
        }
    }

    Reply(0, &xosd, lpdbb->hpid);
    return(xosd);
}

void ProcessAsyncStopCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	/* Do we need to worry about stop/go? */
	XOSD xosd = SUCCEEDED(DmHaltThread(0)) ? xosdNone : xosdUnknown;
	Reply(0, &xosd, lpdbb->hpid);
}

BOOL
Enqueue_KillCmd(
    HPRCX   hprc
    )
{
    PKILLSTRUCT pk = NULL;

    pk = (PKILLSTRUCT)malloc (sizeof(KILLSTRUCT));
    pk->hprc = hprc;

    EnterCriticalSection (&csKillQueue);

    pk->next = KillQueue;
    KillQueue = pk;

    LeaveCriticalSection (&csKillQueue);

    return TRUE;
}

BOOL
Dequeue_KillCmd(
    HPRCX*  lphprc
    )
{
    PKILLSTRUCT pk = NULL;

    EnterCriticalSection(&csKillQueue);

    pk = KillQueue;
    if (pk) {
        KillQueue = pk->next;
    }

    LeaveCriticalSection(&csKillQueue);

    if (!pk) {
        return FALSE;
    }

    *lphprc = pk->hprc;
    free (pk);

    return TRUE;
}

BOOL
ProcessTerminateProcessCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    assert (hprc);
    return Enqueue_KillCmd (hprc);
}

VOID
ExitFailed(
    HPRCX   hprc,
    LPVOID  lpv
    )
/*++

Routine Description:

    This routine is called when we failed to receive the final exit event
    within a specified ammount of time.

Comments:

    Be very careful with this.  The process COULD HAVE exited successfully,
    but not yet notified the debugger.  Do not make any assumptions.

--*/
{
    if (InterlockedSetFlag (&hprc->fExited) == FLAG_ALREADY_SET) {

        //
        // Somebody beat us to the punch.
        //

        return;
    }

    ProcessUnloadCmd (hprc, NULL, NULL);
}

VOID
FlushThreadContexts(
    HPRCX   hprc
    )
{
    HTHDX   hthd = NULL;

    assert (hprc);
    for (hthd = hprc->hthdChild; hthd; hthd = hthd->next) {

        if (hthd->fContextDirty) {
            DbgSetThreadContext(hthd, &hthd->ctx);
            hthd->fContextDirty = FALSE;
        }
        hthd->fWowEvent = FALSE;
    }
}

VOID
CompleteTerminateProcessCmd(
    )
/*++

Routine Description:

    Terminate the process.


--*/
{
    HPRCX               hprc;
    HTHDX               hthd;
    BOOL                fStopped = FALSE;

    if (!Dequeue_KillCmd (&hprc)) {
        assert (FALSE);
        return ;
    }
    assert (hprc);

#if 0
    if (CrashDump) {
        ProcessUnloadCmd (hprc, NULL, NULL);
        return;
    }
#endif

	// we should probably flush the DEQ here as well
    ConsumeAllProcessEvents (hprc, TRUE);
    //ClearAllDebugRegisters (hprc);
    RemoveAllHprcBP (hprc);
    FlushThreadContexts (hprc);

    //
    // Setting the state to ps_killed means that nothing will ever
    // attempt to operate on the process again.  This is critical
    // for Win95.
    //

    hprc->pstate |= ps_killed;

    if ((hprc->pstate & ps_dead) || (hprc->rwHand == (HANDLE)INVALID)) {

        if (InterlockedSetFlag (&hprc->fExited) == FLAG_SET) {
            ProcessUnloadCmd (hprc, NULL, NULL);
        }

    } else {
		
		/* Make the box reboot */
		DmReboot(DMBOOT_WAIT | DMBOOT_WARM);

        for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
            if (hthd->tstate & ts_stopped) {
                fStopped = TRUE;
                break;
            }
        }

        //
        // If we are stopped, we will never get the PROCESS_EXIT event,
        // so unload the proc manually here.
        //

        if (fStopped) {

            if (InterlockedSetFlag (&hprc->fExited) == FLAG_SET) {
                ProcessUnloadCmd (hprc, NULL, NULL);
            }

        } else {
            hprc->hExitFailed = CreateTimerEvent (hprc,
                                                  ExitFailed,
                                                  NULL,
                                                  2000,
                                                  TRUE);
        }
    }

}

int
NumberOfThreads(
    HPRCX hprc
    )
{
    int nthrds=1;
    HTHDX hthd = hprc->hthdChild;
    hthd = hthd->next;
    while(hthd != NULL){
        nthrds++;
        hthd = hthd->next;
    }

    return nthrds;
}

VOID
GetActiveFibers(
    HPRCX   hprc,
    LPVOID* buf
    )
{
    HTHDX hthd = hprc->hthdChild;
    TEB teb;
    int ct = 0;
    int cbr;

    //
    // Determine the fiber loaded on eachthread
    // Don't display that fiber
    //

    while(hthd != NULL){
        DbgReadMemory(hprc,(LPCVOID)hthd->offTeb,
                    (LPVOID)&teb, sizeof(teb),&cbr);
        DbgReadMemory(hprc,(LPCVOID)teb.NtTib.Self,
                    (LPVOID)&teb,sizeof(teb),&cbr);
        buf[ct++] = teb.NtTib.FiberData;
        hthd = hthd->next;
    }

}

void LocalProcessSystemServiceCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
    LPSSS       lpsss =  (LPSSS) lpdbb->rgbVar;

    switch( lpsss->ssvc ) {
    case ssvcFiberDebug:
    {
        HFBRX hfbr = hprc->FbrLst;
        OFBRS   ofbrs = *((OFBRS *) lpsss->rgbData);
        DWORD iAfbrs;
        LPVOID *Actvfbrs;
        int cb=0;
        iAfbrs = NumberOfThreads(hthd->hprc);
        Actvfbrs = malloc(iAfbrs*sizeof(LPVOID));
        GetActiveFibers(hthd->hprc,Actvfbrs);

        if(ofbrs.op == OFBR_SET_FBRCNTX){
            hprc->pFbrCntx = ofbrs.FbrCntx;
        } else if(ofbrs.op == OFBR_ENABLE_FBRS) {
            hprc->fUseFbrs = TRUE;
        } else if(ofbrs.op == OFBR_DISABLE_FBRS) {
            hprc->fUseFbrs = FALSE;
        } else if(ofbrs.op == OFBR_QUERY_LIST_SIZE) {
            cb = sizeof(int);
            //count size of the list of fibers
            while(hfbr){
                DWORD i;
                BOOL fskip;//skip fibers loaded in threads
                for(fskip = FALSE,i=0;i < iAfbrs; i++){
                    if(Actvfbrs[i] == hfbr->fbrstrt)
                        fskip = TRUE;
                }
                if(!fskip){
                    cb +=4;
                }
                hfbr = hfbr->next;
            }
            //put byte count at the beginning
            memcpy(lpsss->rgbData+sizeof(int),&cb,sizeof(int));
            cb = 2*sizeof(int);
            memcpy(lpsss->rgbData,&cb,sizeof(int));
            lpsss->cbReturned = cb;
        } else if(ofbrs.op == OFBR_GET_LIST){
            cb = sizeof(int);
            while(hfbr){
                BOOL fskip;//skip fibers loaded in threads
                DWORD i;
                for(fskip = FALSE,i=0;i<iAfbrs;i++){
                    if(Actvfbrs[i] == hfbr->fbrstrt)
                        fskip = TRUE;
                }
                if(!fskip){
                    memcpy(lpsss->rgbData+cb,&(hfbr->fbrcntx),4);
                    cb +=4;
                }
                hfbr = hfbr->next;
            }
            //put byte count at the beginning
            memcpy(lpsss->rgbData,&cb,sizeof(int));
            lpsss->cbReturned = cb;
        }

        LpDmMsg->xosdRet = xosdNone;
        memcpy(LpDmMsg->rgb,lpsss->rgbData,cb);
        Reply (cb, LpDmMsg, lpdbb->hpid);
        free(Actvfbrs);
    }
    break;

    default:
	    LpDmMsg->xosdRet = xosdUnsupported;
	    Reply(0, LpDmMsg, lpdbb->hpid);
        break;
    }
}

void ProcessSSVCCustomCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb) { _asm int 3 }
void ProcessIoctlGenericCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb) { _asm int 3 }

ULONG ProcessGetTimeStamp(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	REPLY(LPTCSR, lptcsr);
	DM_XBE xbe;
	HRESULT hr;

	hr = DmGetXbeInfo((LPSTR)lpdbb->rgbVar, &xbe);
	if(hr == XBDM_NOSUCHFILE)
		LpDmMsg->xosdRet = xosdFileNotFound;
	else if(FAILED(hr))
		LpDmMsg->xosdRet = xosdUnknown;
	else {
		LpDmMsg->xosdRet = xosdNone;
		lptcsr->TimeStamp = xbe.TimeStamp;
		lptcsr->CheckSum = xbe.CheckSum;
	}
	return sizeof *lptcsr;
}

HRESULT HrEnsureNotifier(void)
{
    if(!psessNotify)
        return DmOpenNotificationSession(DM_PERSISTENT, &psessNotify);
    return XBDM_NOERR;
}

DWORD AttachNotification(DWORD dwNotification, DWORD dwParam)
{
	if((dwNotification & DM_NOTIFICATIONMASK) == DM_BREAK) {
		PDMN_BREAK pdmbr = (PDMN_BREAK)dwParam;
		/* This is our halt breakpoint, so we just need to capture the
		 * thread id */
		g_tidBreak = pdmbr->ThreadId;
		SetEvent(hevtStartBreak);
	}
	return 0;
}

DWORD LaunchNotification(DWORD dwNotification, DWORD dwParam)
{
	DEBUG_EVENT de;
	DMN_MODLOAD dmml;

	memset(&de, 0, sizeof de);
	switch(dwNotification & DM_NOTIFICATIONMASK) {
	case DM_CREATETHREAD:
#define pdmct ((PDMN_CREATETHREAD)dwParam)
		/* This is our first thread, so we flag its create info and wake up the
		 * launching thread to continue with the launch */
		g_tidBreak = pdmct->ThreadId;
		g_pvThreadStart = pdmct->StartAddress;
		SetEvent(hevtStartBreak);
		break;
#undef pdmct
	case DM_EXCEPTION:
#define pdme ((PDMN_EXCEPTION)dwParam)
		/* If this was a first-chance exception, then we will just continue
		 * it */
		if((pdme->Flags & DM_EXCEPT_FIRSTCHANCE) &&
			!(pdme->Flags & DM_EXCEPT_NONCONTINUABLE))
		{
			DmContinueThread(pdme->ThreadId, TRUE);
			DmGo();
			break;
		}
		/* Otherwise fall through */
#undef pdme
	case DM_BREAK:
		/* Uh oh, we failed to launch for some reason.  We need to inform the
		 * shell that there is no process, which we will do by leaving
		 * the start thread ID at zero */
		assert(!g_tidBreak);
		if((dwNotification & DM_NOTIFICATIONMASK) == DM_BREAK)
			/* Explicit launch failure, so reboot */
			DmReboot(DMBOOT_WAIT | DMBOOT_WARM);
#ifndef XBOX
		else
			/* Forward the error back on to kd if necessary */
			DmSendCommand(NULL, "kd exceptif", NULL, 0);
#endif
		SetEvent(hevtStartBreak);
		break;
	}
	return 0;
}

HRESULT HrLaunchTitle(SOS *psos)
{
	HRESULT hr;
	char szPathName[MAX_PATH];
	char szDirName[MAX_PATH];
	char szTitleName[MAX_PATH];
	char szTitleExt[8];
	char szDriveName[8];
	int cchDirName;
	char *szPath;
    char *szArgs;

	hr = HrEnsureNotifier();
	if(FAILED(hr))
		return hr;

#ifndef XBOX
	/* Reboot the box if we have to */
	if(dwExecState != DMN_EXEC_PENDING) {
        assert(!hevtReboot);
		hevtReboot = CreateEvent(NULL, FALSE, FALSE, NULL);
		hr = DmNotify(psessNotify, DM_EXEC, XboxNotification);
		if(SUCCEEDED(hr)) {
			DmReboot(DMBOOT_WAIT | DMBOOT_WARM);
			if(WaitForSingleObject(hevtReboot, 120000) == WAIT_TIMEOUT)
				hr = XBDM_CONNECTIONLOST;
			else {
				assert(dwExecState == DMN_EXEC_PENDING);
			}
		}
		CloseHandle(hevtReboot);
		hevtReboot = NULL;
	}

	if(FAILED(hr))
		return hr;
#endif

	/* Find the directory */
	szPath = psos->lszRemoteExe;
	/* Since splitpath can't understand names like 'xe:\foo', we need to look
	 * for something that appears to be of that form */
	if((szPath[0] == 'x' || szPath[0] == 'X') && szPath[1] && szPath[2] == ':')
		++szPath;
	_splitpath(szPath, szDriveName, szDirName, szTitleName, szTitleExt);
	cchDirName = strlen(szDirName);
	if(cchDirName && szDirName[cchDirName - 1] == '\\')
		szDirName[--cchDirName] = 0;
	sprintf(szPathName, "%s\\%s", szDriveName, szDirName[0] == '\\' ?
		szDirName + 1 : szDirName);
	strcat(szTitleName, szTitleExt);
    szArgs = psos->lszCmdLine;
    switch(szArgs[0]) {
    case 0:
        /* No args */
        szArgs = NULL;
        break;
    case ' ':
        /* VC prepends a space to the args, which we want to strip */
        ++szArgs;
        break;
    }
	return DmSetTitle(szPathName, szTitleName, szArgs);
}

enum {
	CONNECT_LAUNCH,
	CONNECT_ATTACH,
	CONNECT_ATTACH_RUNNING,
	CONNECT_ATTACH_STOPPED,
	CONNECT_ATTACH_ASSERT,
};

typedef struct _CONN {
    int mdConnect;
    DMN_MODLOAD dmmlXbe;
    HANDLE hevtLoaded;
} CONN, *PCONN;

DWORD ConnectThread(LPVOID pvParam)
{
	/* We're going to connect to a running process.  We do so by synthesizing
	 * all of the events the debugger would normally expect to see during
	 * the course of process launch */
	int mdConnect;
	DWORD rgtid[128];
	DWORD ctid;
	DWORD itid;
	DWORD dwNotify;
	DEBUG_EVENT de;
	DMN_MODLOAD dmml;
	DMN_BREAK dmbr;
	DM_THREADSTOP dmts;
    DM_THREADINFO dmti;
	CONTEXT cr;
	HPRCX hprc;
    PDM_WALK_MODULES pdmwm;
    CONN conn;

    /* Grab our parameters */
    memcpy(&conn, pvParam, sizeof conn);
    SetEvent(conn.hevtLoaded);
    mdConnect = conn.mdConnect;

	/* Set up our notifications */
	DmStopOn(DMSTOP_CREATETHREAD | DMSTOP_FCE, TRUE);
	for(dwNotify = 1; dwNotify <= DM_NOTIFYMAX; ++dwNotify)
		DmNotify(psessNotify, dwNotify, XboxNotification);

	memset(&de, 0, sizeof de);
	/* Send the create process message.  If we're launching, we have the ID
	 * of the first thread, and if we're connecting, we'll just pick the first
	 * one in the thread list */
	ctid = sizeof(rgtid) / sizeof(DWORD);
	if(FAILED(DmGetThreadList(rgtid, &ctid)))
		ctid = rgtid[0] = 0;
	de.dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
	de.dwProcessId = 1;
	if(mdConnect == CONNECT_LAUNCH) {
		de.dwThreadId = g_tidBreak;
		de.u.CreateProcessInfo.lpStartAddress = g_pvThreadStart;
	} else 
		de.dwThreadId = rgtid[0];
	de.u.CreateProcessInfo.hFile = &conn.dmmlXbe;
	de.u.CreateProcessInfo.lpImageName = (PVOID)0x00010000;
	de.u.CreateProcessInfo.lpBaseOfImage = conn.dmmlXbe.BaseAddress;

    if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
        de.u.CreateProcessInfo.lpThreadLocalBase = dmti.TlsBase;
    else
        de.u.CreateProcessInfo.lpThreadLocalBase = NULL;
	ResetEvent(hEventContinue);
	ProcessDebugEvent(&de);
	WaitForSingleObject(hEventCreateProcess, INFINITE);
	WaitForSingleObject(hEventContinue, INFINITE);
	hprc = HPRCFromPID(1);
	assert(hprc);
	assert(hprc->pstate & ps_connect);

	/* Notify of the created threads */
	memset(&de.u, 0, sizeof de.u);
	de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
	/* Loop over all the threads to notify of their creation.  If we're
	 * launching, we hit all of them and skip the one we already sent -- which
	 * hopefully should total zero notifications (why would any other threads
	 * exist if we've only created the first one?).  If we're not launching,
	 * we skip the first thread since we already sent that one with the
	 * process */
	for(itid = mdConnect != CONNECT_LAUNCH; itid < ctid; ++itid)
		{
		if(mdConnect != CONNECT_LAUNCH || rgtid[itid] != g_tidBreak) {
			/* For each thread, we need to wait for the DM to acknowledge
			 * creation and continuation of the thread, and only then can we
			 * mark the thread as running */
			ResetEvent(hprc->hEventCreateThread);
			ResetEvent(hEventContinue);
			de.dwThreadId = rgtid[itid];
            if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
                de.u.CreateThread.lpThreadLocalBase = dmti.TlsBase;
            else
                de.u.CreateThread.lpThreadLocalBase = NULL;
			ProcessDebugEvent(&de);
			WaitForSingleObject(hprc->hEventCreateThread, INFINITE);
			WaitForSingleObject(hEventContinue, INFINITE);
			SetDebugEventThreadState(hprc, ts_running);
		}
	}

	/* Enumerate the loaded DLLs and advise */
    pdmwm = NULL;
	while(SUCCEEDED(DmWalkLoadedModules(&pdmwm, &dmml))) {
        if(dmml.BaseAddress != conn.dmmlXbe.BaseAddress) {
		    GetModLoadDebugEvent(&dmml, &de);
		    ProcessDebugEvent(&de);
        }
	}
	DmCloseLoadedModules(pdmwm);

	/* At this point, we shouldn't have any deq's pending or in the works,
	 * though we might have some continue events needing to be flushed */
	assert(!dwTidStopped);
	assert(!fDeqStopped);
	assert(!pdeqFirst);
	DequeueAllEvents(TRUE, TRUE);

	switch(mdConnect) {
	case CONNECT_LAUNCH:
		/* We've sent all appropriate messages, and we're just waiting for
		 * that breakpoint we're about to hit, so we'll continue the
		 * initial thread and let the fireworks fly */
		hprc->pstate &= ~ps_connect;
		DmContinueThread(g_tidBreak, FALSE);
		DmGo();
		break;
	case CONNECT_ATTACH:
		/* this should have been converted to something else, but we'll just
		 * treat it like connect to running */
		assert(FALSE);
		// fall through
	case CONNECT_ATTACH_RUNNING:
		/* We forced this stop, which means we're connecting to a running
		 * process.  We'll repost the breakpoint event and let it trigger
		 * everything else */
		hprc->pstate &= ~ps_connect;
		cr.ContextFlags = CONTEXT_FULL;
		if(FAILED(DmGetThreadContext(g_tidBreak, (PCONTEXT)&cr)) ||
				!(cr.ContextFlags & CONTEXT_INTEGER))
			return xosdLineNotConnected;
		dmbr.ThreadId = g_tidBreak;
		dmbr.Address = (PVOID)cr.Eip;
		XboxNotification(DM_BREAK | DM_STOPTHREAD, (DWORD)&dmbr);
		break;
	case CONNECT_ATTACH_STOPPED:
		/* We didn't force this stop, so we'll say we've finished the load,
		 * and then we'll go through every stopped thread and post a reason
		 * for its stopped state */
		ConsumeAllProcessEvents (hprc, FALSE);
		ResetEvent(hEventContinue);
		de.dwDebugEventCode = LOAD_COMPLETE_DEBUG_EVENT;
		NotifyEM( &de, HTHDXFromPIDTID(1, rgtid[0]), 0, 0L);
		WaitForSingleObject( hEventContinue, INFINITE );

		/* We're connected now, so post those debug events */
		hprc->pstate &= ~(ps_connect | ps_preStart);
		mdConnect = CONNECT_ATTACH_RUNNING;
		for(itid = 0; itid < ctid; ++itid) {
			if(SUCCEEDED(DmIsThreadStopped(rgtid[itid], &dmts))) {
				if(dmts.NotifiedReason == DM_ASSERT) {
					CONTEXT dmcr;
					/* We missed the assert text, so we'll continue past the
					 * assert with an invalid continue and force the assert
					 * to repeat */
					dmcr.ContextFlags = CONTEXT_INTEGER;
					DmGetThreadContext(rgtid[itid], &dmcr);
					dmcr.Eax = 0;
					DmSetThreadContext(rgtid[itid], &dmcr);
					DmContinueThread(rgtid[itid], FALSE);
					if(mdConnect == CONNECT_ATTACH_RUNNING)
						mdConnect = CONNECT_ATTACH_ASSERT;
				} else if(dmts.NotifiedReason != DM_NONE) {
					mdConnect = CONNECT_ATTACH_STOPPED;
					XboxNotification(dmts.NotifiedReason | DM_STOPTHREAD,
						(DWORD)&dmts.u);
					break;
				} else {
					/* We should have continued these threads */
					assert(FALSE);
				}
			}
		}
		assert(mdConnect != CONNECT_ATTACH_RUNNING);
		/* If our only stops are on asserts, we need to continue to force the
		 * assert to reappear */
		if(mdConnect == CONNECT_ATTACH_ASSERT)
			DmGo();
		break;
	}

	/* Our work here is done */
	return 0;
}

XOSD XboxConnect(int mdConnect)
{
	/* To connect to the active process, we need to suspend execution so that
	 * we can find a thread to break into -- either we find a thread that's
	 * already stopped or we halt into any available thread.  Once we set that
	 * up, we synthesize a create process event to get things rolling */
	DWORD rgtid[128];
	DWORD ctid;
	DWORD itid;
	DWORD tidStopped;
	DM_THREADSTOP dmts;
    CONN conn;
    DMN_MODLOAD dmmlTls;
    BOOL fSawXBE;
    PDM_WALK_MODULES pdmwm;
    HANDLE hthr;

	/* Suspend execution while we sort things out */
	DmStop();
	DmSendCommand(NULL, "kd disable", NULL, 0);

	/* Make sure our cleanup thread is going */
	if(!StartDmPollThread())
		return xosdUnknown;

	if(mdConnect == CONNECT_ATTACH) {
		/* Before we can do anything, we need to find a thread that's stopped
		 * on a breakpoint or exception.  We'll continue any thread we find
		 * that's not stopped for a good reason */
		ctid = sizeof rgtid / sizeof(DWORD);
		if(FAILED(DmGetThreadList(rgtid, &ctid)) || ctid == 0)
			return xosdLineNotConnected;
		tidStopped = 0;
		for(itid = 0; itid < ctid; ++itid) {
			if(SUCCEEDED(DmIsThreadStopped(rgtid[itid], &dmts)))
			{
				if(dmts.NotifiedReason == DM_NONE || dmts.NotifiedReason ==
						DM_DEBUGSTR)
					DmContinueThread(rgtid[itid], FALSE);
				else
					mdConnect = CONNECT_ATTACH_STOPPED;
			}
		}
		if(mdConnect == CONNECT_ATTACH)
		{
			XOSD xosd;
			/* No stopped thread, so we need to stop one */
			ResetEvent(hevtStartBreak);
			/* Make sure we see the first break */
			if(FAILED(DmNotify(psessNotify, DM_BREAK, AttachNotification)))
				return xosdGeneral;
			DmGo();
			DmHaltThread(0);
			if(WaitForSingleObject(hevtStartBreak, 10000) == WAIT_TIMEOUT)
				xosd = xosdUnknown;
			else
				xosd = xosdNone;
			DmNotify(psessNotify, DM_NONE, AttachNotification);
			if(xosd != xosdNone)
				return xosd;
			mdConnect = CONNECT_ATTACH_RUNNING;
		}
	}

    /* We need to make sure we can find the XBE module.  We may be running on
     * an old build that doesn't report the XBE, so we'll key off of the last
     * module in the list that has TLS if that's the case */
    pdmwm = NULL;
    fSawXBE = FALSE;
    dmmlTls.Flags = 0;
    while(SUCCEEDED(DmWalkLoadedModules(&pdmwm, &conn.dmmlXbe))) {
        if(conn.dmmlXbe.Flags & DMN_MODFLAG_XBE) {
            fSawXBE = TRUE;
            break;
        } else if(conn.dmmlXbe.Flags & DMN_MODFLAG_TLS)
            memcpy(&dmmlTls, &conn.dmmlXbe, sizeof dmmlTls);
    }
    DmCloseLoadedModules(pdmwm);
    if(!fSawXBE) {
        if(dmmlTls.Flags)
            /* Didn't see the XBE, but we did find a module with TLS.  Pretend
             * it's the XBE */
            memcpy(&conn.dmmlXbe, &dmmlTls, sizeof dmmlTls);
        else
            return xosdBadProcess;
    }

	/* Now that our state is set up, we spin off a thread to send all of the
	 * notifications through and we'll continue with startup */
    conn.hevtLoaded = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(!conn.hevtLoaded)
        return xosdOutOfMemory;
    conn.mdConnect = mdConnect;
    hthr = CreateThread(NULL, 0, ConnectThread, &conn, 0, NULL);
    if(!hthr) {
        CloseHandle(conn.hevtLoaded);
        return xosdOutOfMemory;
    }
    CloseHandle(hthr);

    /* Wait until the new thread has copied out the connection info before
     * returning */
    WaitForSingleObject(conn.hevtLoaded, INFINITE);
    CloseHandle(conn.hevtLoaded);
	return xosdNone;
}

void ProcessProgLoadCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	XOSD xosd = xosdNone;
	HPRCX hprc1, hprcT;

    fDisconnected = FALSE;

    assert (lpdbb -> dmf == dmfProgLoad);

     /*
     * For various strange reasons the list of processes may not have
     * been completely cleared.  If not do so now
     */

    for (hprc1 = prcList; hprc1 != hprcxNull; hprc1 = hprcT) {
        hprcT = hprc1->next;

        if (hprc1->pstate & ps_dead) {
            FreeProcess( hprc1, FALSE );
        }
    }

	/* Get our first notifications set up */
	if(!hevtStartBreak)
		hevtStartBreak = CreateEvent(NULL, TRUE, FALSE, NULL);
	if(!hevtStartBreak)
		xosd = xosdUnknown;
	g_tidBreak = 0;
	if(FAILED(HrEnsureNotifier()))
		xosd = xosdLineNotConnected;
	else {
		DmNotify(psessNotify, DM_NONE, XboxNotification);
		if(FAILED(DmNotify(psessNotify, DM_EXEC, XboxNotification)))
			xosd = xosdLineNotConnected;
	}
	assert(dwExecState != DMN_EXEC_REBOOT);

	/* If we're in a pending state, then we are expected to launch the app.
	 * If we're running something right now, but it's not debuggable, then
	 * we'll treat it as pending so we can force a launch.  What we do is to
	 * set the title to run, ask for a breakpoint, and start execution.  We
	 * set ourselves up to send the create process when the first create
	 * thread arrives, so that we can get the process start address correct.
	 * Then we continue with the remainder of the normal launch process */
	if(xosd == xosdNone) {
		if(dwExecState == DMN_EXEC_PENDING || DmConnectDebugger(TRUE) ==
            XBDM_NOTDEBUGGABLE)
		{
			HRESULT hr;
			PRL prl;

			DPRINT(5, (_T("Launching the title\n")));
			UnpackLoadCmd(lpdbb->rgbVar, &prl);
			hr = HrLaunchTitle(&prl);
			if(hr == XBDM_NOSUCHFILE)
				xosd = xosdFileNotFound;
			else if(FAILED(hr))
				xosd = xosdUnknown;
			else {
				hr = DmSetInitialBreakpoint();
				if(SUCCEEDED(hr))
					hr = DmStopOn(DMSTOP_CREATETHREAD, TRUE);
				if(FAILED(hr)) {
					DPRINT(5, (_T("Can't start\n")));
					/* If we can't get our startup breakpoint, we'll start the
					 * machine but fail to launch */
					DmGo();
					xosd = xosdGeneral;
#ifndef XBOX
					goto LaunchErr;
#endif
				} else {
					ResetEvent(hevtStartBreak);
					DmNotify(psessNotify, DM_CREATETHREAD, LaunchNotification);
					DmNotify(psessNotify, DM_BREAK, LaunchNotification);
					DmNotify(psessNotify, DM_EXCEPTION, LaunchNotification);
					DmGo();
					/* We wait for the creation of the first thread, but we
					 * won't wait any longer than sixty seconds */
					WaitForSingleObject(hevtStartBreak, 60000);
					DmNotify(psessNotify, DM_NONE, LaunchNotification);
					DPRINT(5, (_T("Title launched, hit break\n")));
					if(g_tidBreak && SUCCEEDED(DmConnectDebugger(TRUE)))
						xosd = XboxConnect(CONNECT_LAUNCH);
					else {
#ifndef XBOX
						char szError[256];
LaunchErr:
						xosd = xosdGeneral;
						if(LoadString(hInstance, IDS_ERR_NOSTART, szError,
								sizeof szError))
							SendDBCError(hprc, xosd, szError);
#endif
					}
				}
			}
		} else
			xosd = XboxConnect(CONNECT_ATTACH);
	}

	/* If we succeeded, then the reply will come from the create process
	 * event.  Otherwise we need to reply right now */
	if(xosd != xosdNone)
		Reply(0, &xosd, lpdbb->hpid);
}

void ProcessSpawnOrphanCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb)
{
	XOSD xosd;
	SOS sos;
	HRESULT hr;
	HPRCX hprc1, hprcT;

    fDisconnected = FALSE;

    if (!UnpackLoadCmd(lpdbb->rgbVar, &sos)) {
        assert(FALSE); // Can't deal with failure
    }

    assert (lpdbb -> dmf == dmfSpawnOrphan);
	assert( sos.lpso!=NULL );

    for (hprc1 = prcList; hprc1 != hprcxNull; hprc1 = hprcT) {
        hprcT = hprc1->next;

        if (hprc1->pstate & ps_dead) {
            FreeProcess( hprc1, FALSE );
        }
    }

	hr = HrLaunchTitle(&sos);
	/* We don't want to hear anything about this title */
	DmCloseNotificationSession(psessNotify);
	psessNotify = NULL;
	if(SUCCEEDED(hr))
		DmGo();
	if(hr == XBDM_NOSUCHFILE)
		xosd = xosdFileNotFound;
	else if(FAILED(hr))
		xosd = xosdUnknown;
	else
		xosd = xosdNone;

    if (xosd == xosdNone) {
        sos.lpso -> dwPid = 1;
        LoadString (hInstance, IDS_EXECUTE_OK, sos.lpso -> rgchErr, sizeof (sos.lpso -> rgchErr));
    } else {
        sos.lpso -> dwPid = 0;
        LoadString (hInstance, IDS_EXECUTE_FAILED, sos.lpso -> rgchErr, sizeof (sos.lpso -> rgchErr));
    }

    memcpy (LpDmMsg -> rgb, sos.lpso, sizeof (SPAWNORPHAN));
    LpDmMsg->xosdRet = xosd;
    Reply (sizeof (SPAWNORPHAN), LpDmMsg, lpdbb -> hpid);
}
	
void InitDEQ(void)
{
	hevtDEQ = CreateEvent(NULL, FALSE, FALSE, NULL);
	InitializeCriticalSection(&csDEQ);
	pdeqFirst = NULL;
}

void PostDEQ(DEBUG_EVENT *pde, BOOL fStopThread)
{
	DEQ *pdeq;
	DEQ **ppdeq;
	char *pch;

	EnterCriticalSection(&csDEQ);
	pdeq = MHAlloc(sizeof(DEQ));
	pdeq->de = *pde;
	/* We may have some supplemental data that we need to stick in here as
	 * well */
	switch(pde->dwDebugEventCode)
	{
	case LOAD_DLL_DEBUG_EVENT:
		pdeq->dmml = *(PDMN_MODLOAD)pde->u.LoadDll.hFile;
		break;
	case CREATE_PROCESS_DEBUG_EVENT:
		if(pde->u.CreateProcessInfo.hFile)
			pdeq->dmml = *(PDMN_MODLOAD)pde->u.CreateProcessInfo.hFile;
		break;
	}
	pdeq->fNeedsContinue = fStopThread;
	pdeq->pdeqNext = NULL;
	for(ppdeq = &pdeqFirst; *ppdeq; ppdeq = &(*ppdeq)->pdeqNext);
	*ppdeq = pdeq;
	if(!fDeqStopped)
		SetEvent(hevtDEQ);
	LeaveCriticalSection(&csDEQ);
}

BOOL WaitDEQ(DEQ *pdeqOut, DWORD dwWaitTime)
{
	DEQ *pdeq;

	do {
		if(WaitForSingleObject(hevtDEQ, dwWaitTime) == WAIT_TIMEOUT)
			return FALSE;
		EnterCriticalSection(&csDEQ);
		if(fDeqStopped)
			pdeq = NULL;
		else if(pdeq = pdeqFirst) {
			fDeqStopped = TRUE;
			pdeqFirst = pdeq->pdeqNext;
		}
		LeaveCriticalSection(&csDEQ);
	} while(!pdeq);

	if(pdeq->fNeedsContinue)
		dwTidStopped = pdeq->de.dwThreadId;

	*pdeqOut = *pdeq;
	MHFree(pdeq);
	/* May need to fix up the resulting debug event */
	switch(pdeqOut->de.dwDebugEventCode)
	{
	case LOAD_DLL_DEBUG_EVENT:
		pdeqOut->de.u.LoadDll.hFile = (HANDLE)&pdeqOut->dmml;
		break;
	case CREATE_PROCESS_DEBUG_EVENT:
		if(pdeqOut->de.u.CreateProcessInfo.hFile)
			pdeqOut->de.u.CreateProcessInfo.hFile = (HANDLE)&pdeqOut->dmml;
		break;
	}

	return TRUE;
}

DWORD HandleBreakNotification(DWORD dwExceptCode, BOOL fStop, PDMN_BREAK pdmbr)
{
	DEBUG_EVENT de;
	EXCEPTION_RECORD *per;

	memset(&de, 0, sizeof de);
	de.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
	de.dwProcessId = 1;
	de.dwThreadId = pdmbr->ThreadId;
	de.u.Exception.dwFirstChance = 0;
	per = &de.u.Exception.ExceptionRecord;
	per->ExceptionCode = dwExceptCode;
	per->ExceptionAddress = pdmbr->Address;
	if(dwExceptCode == STATUS_BREAKPOINT)
	{
		per->NumberParameters = 1;
		per->ExceptionInformation[0] = BREAKPOINT_BREAK;
	}
	else
		per->NumberParameters = 0;
	PostDEQ(&de, fStop);
	return 0;
}

DWORD HandleDataBreakNotification(BOOL fStop, PDMN_DATABREAK pdmdb)
{
	DEBUG_EVENT de;
	EXCEPTION_RECORD *per;

	memset(&de, 0, sizeof de);
	de.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
	de.dwProcessId = 1;
	de.dwThreadId = pdmdb->ThreadId;
	de.u.Exception.dwFirstChance = 0;
	per = &de.u.Exception.ExceptionRecord;
	per->ExceptionCode = STATUS_SINGLE_STEP;
	per->ExceptionAddress = pdmdb->Address;
	/* We'll fill in the data address and break type as parameters */
	per->NumberParameters = 2;
	per->ExceptionInformation[0] = (DWORD)pdmdb->DataAddress;
	per->ExceptionInformation[1] = pdmdb->BreakType;
	PostDEQ(&de, fStop);
	return 0;
}

void GetModLoadDebugEvent(PDMN_MODLOAD pdmml, DEBUG_EVENT *pde)
{
	HPRCX hprc;

	memset(pde, 0, sizeof *pde);
	pde->dwDebugEventCode = LOAD_DLL_DEBUG_EVENT;
	pde->dwProcessId = 1;
	/* We'll take any valid thread ID */
	hprc = HPRCFromPID(1);
	if(hprc && hprc->hthdChild)
		pde->dwThreadId = hprc->hthdChild->tid;
	pde->u.LoadDll.hFile = (HANDLE)pdmml; // for LoadDll's use
	pde->u.LoadDll.lpBaseOfDll = pdmml->BaseAddress;
	pde->u.LoadDll.lpImageName = (PVOID)0x00010000;
}

DWORD HandleModLoadNotification(PDMN_MODLOAD pdmml)
{
	DEBUG_EVENT de;

	GetModLoadDebugEvent(pdmml, &de);
	PostDEQ(&de, FALSE);
	return 0;
}

DWORD HandleDebugStrNotification(BOOL fStop, PDMN_DEBUGSTR pdmds)
{
	DEBUG_EVENT de;

	memset(&de, 0, sizeof de);
	de.dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;
	de.dwProcessId = 1;
	de.dwThreadId = pdmds->ThreadId;
	de.u.DebugString.nDebugStringLength = (WORD)pdmds->Length;
	/* We need to take responsibility for allocating a copy of the string
	 * data */
	de.u.DebugString.lpDebugStringData = MHAlloc(pdmds->Length + 1);
	memcpy(de.u.DebugString.lpDebugStringData, pdmds->String, pdmds->Length);
	PostDEQ(&de, fStop);
	return 0;
}

DWORD HandleExceptionNotification(BOOL fStop, PDMN_EXCEPTION pdme)
{
	EXCEPTION_RECORD *per;
	DEBUG_EVENT de;

	memset(&de, 0, sizeof de);
	de.dwProcessId = 1;
	de.dwThreadId = pdme->ThreadId;
	de.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
	de.u.Exception.dwFirstChance = pdme->Flags & DM_EXCEPT_FIRSTCHANCE;
	per = &de.u.Exception.ExceptionRecord;
	per->ExceptionCode = pdme->Code;
	per->ExceptionAddress = pdme->Address;
	if(pdme->Flags & DM_EXCEPT_NONCONTINUABLE)
		per->ExceptionFlags |= EXCEPTION_NONCONTINUABLE;
    if(pdme->Code == EXCEPTION_ACCESS_VIOLATION) {
		per->NumberParameters = 2;
		per->ExceptionInformation[0] = pdme->Information[0];
		per->ExceptionInformation[1] = pdme->Information[1];
	}
	PostDEQ(&de, fStop);
	return 0;
}

DWORD HandleFiberNotification(BOOL fStop, PDMN_FIBER pdmfib)
{
    HPRCX hprc;
    hprc = HPRCFromPID(1);

    /* Only post the fiber event if we're supporting fibers */
    if(hprc->fUseFbrs) {
        EXCEPTION_RECORD *per;
	    DEBUG_EVENT de;

	    memset(&de, 0, sizeof de);
	    de.dwProcessId = 1;
        /* We'll put in any valid thread id */
	    de.dwThreadId = hprc->hthdChild->tid;
	    de.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
	    de.u.Exception.dwFirstChance = 0;
	    per = &de.u.Exception.ExceptionRecord;
	    per->ExceptionCode = EXCEPTION_FIBER_DEBUG;
	    per->ExceptionAddress = NULL;
        if(pdmfib->Create) {
            per->NumberParameters = 3;
            per->ExceptionInformation[0] = ecreate_fiber;
            per->ExceptionInformation[2] = (ULONG)pdmfib->StartAddress;
        } else {
            per->NumberParameters = 2;
            per->ExceptionInformation[0] = edelete_fiber;
        }
        per->ExceptionInformation[1] = pdmfib->FiberId;
	    PostDEQ(&de, fStop);
    }
	return 0;
}

DWORD HandleCreateThreadNotification(BOOL fStop, PDMN_CREATETHREAD pdmct)
{
	DEBUG_EVENT de;
    DM_THREADINFO dmti;

	memset(&de, 0, sizeof de);
	de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
	de.dwProcessId = 1;
	de.dwThreadId = pdmct->ThreadId;
	de.u.CreateThread.lpStartAddress = pdmct->StartAddress;
    if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
        de.u.CreateThread.lpThreadLocalBase = dmti.TlsBase;
    else
        de.u.CreateThread.lpThreadLocalBase = NULL;
    PostDEQ(&de, fStop);
	return 0;
}

DWORD HandleDestroyThreadNotification(DWORD tid)
{
	DEBUG_EVENT de;

	memset(&de, 0, sizeof de);
	de.dwDebugEventCode = EXIT_THREAD_DEBUG_EVENT;
	de.dwProcessId = 1;
	de.dwThreadId = tid;
	PostDEQ(&de, FALSE);
	return 0;
}

DWORD HandleAssertNotification(BOOL fStop, PDMN_DEBUGSTR pdmds)
{
	char chRet;

	chRet = XboxAssert(pdmds);
	if(fStop) {
		/* We stopped for this assert, so we need to set the reply and
		 * continue the thread */
		CONTEXT dmcr;
		dmcr.ContextFlags = CONTEXT_INTEGER;
		DmGetThreadContext(pdmds->ThreadId, &dmcr);
		dmcr.Eax = chRet;
		DmSetThreadContext(pdmds->ThreadId, &dmcr);
		DmContinueThread(pdmds->ThreadId, FALSE);
		DmGo();
	}
	return 0;
}

DWORD HandleRipNotification(BOOL fStop, PDMN_DEBUGSTR pdmds)
{
	DEBUG_EVENT de;
	LPSTR psz;

	memset(&de, 0, sizeof de);
	de.dwProcessId = 1;
	de.dwThreadId = pdmds->ThreadId;
	de.dwDebugEventCode = RIP_EVENT;
	/* We need to keep a copy of the debugstr, if we have one */
	if(pdmds->String) {
		psz = MHAlloc(pdmds->Length + 1);
		memcpy(psz, pdmds->String, pdmds->Length);
		psz[pdmds->Length] = 0;
	} else
		psz = NULL;
	de.u.RipInfo.dwError = (DWORD)psz;
	PostDEQ(&de, fStop);
	return 0;
}

DWORD XboxNotification(DWORD dwMsg, DWORD dwParam)
{
	BOOL fStop = dwMsg & DM_STOPTHREAD;
    BOOL fSetEvent;

	switch(dwMsg & DM_NOTIFICATIONMASK)
	{
	case DM_ASSERT:
		return HandleAssertNotification(fStop, (PDMN_DEBUGSTR)dwParam);
	case DM_BREAK:
		return HandleBreakNotification(STATUS_BREAKPOINT, fStop,
			(PDMN_BREAK)dwParam);
	case DM_SINGLESTEP:
		return HandleBreakNotification(STATUS_SINGLE_STEP, fStop,
			(PDMN_BREAK)dwParam);
	case DM_DATABREAK:
		return HandleDataBreakNotification(fStop, (PDMN_DATABREAK)dwParam);
	case DM_MODLOAD:
		return HandleModLoadNotification((PDMN_MODLOAD)dwParam);
	case DM_RIP:
		return HandleRipNotification(fStop, (PDMN_DEBUGSTR)dwParam);
	case DM_DEBUGSTR:
		return HandleDebugStrNotification(fStop, (PDMN_DEBUGSTR)dwParam);
	case DM_EXCEPTION:
		return HandleExceptionNotification(fStop, (PDMN_EXCEPTION)dwParam);
	case DM_CREATETHREAD:
		return HandleCreateThreadNotification(fStop,
			(PDMN_CREATETHREAD)dwParam);
    case DM_FIBER:
        return HandleFiberNotification(fStop, (PDMN_FIBER)dwParam);
	case DM_DESTROYTHREAD:
		if(fStop) {
			DmContinueThread(dwParam, FALSE);
			DmGo();
		}
		return HandleDestroyThreadNotification(dwParam);
	case DM_EXEC:
        fSetEvent = FALSE;
		if(hevtReboot) {
			if(dwExecState == DMN_EXEC_REBOOT && dwParam != DMN_EXEC_REBOOT)
				fSetEvent = TRUE;
		}
#ifndef XBOX
		else if(dwExecState == DMN_EXEC_REBOOT) {
			DEBUG_EVENT de;
			HPRCX hprc;
			PDMN_SESSION psess;

			/* Need to send process termination */
			memset(&de, 0, sizeof de);
			de.dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
			de.dwProcessId = 1;
			hprc = HPRCFromPID(1);
			if(hprc && hprc->hthdChild)
				de.dwThreadId = hprc->hthdChild->tid;
			else
				de.dwThreadId = 0;
			PostDEQ(&de, FALSE);
			/* Don't allow any more notifications until the process restarts */
			psess = psessNotify;
			psessNotify = NULL;
			DmCloseNotificationSession(psess);
		}
#endif
		dwExecState = dwParam;
        if(fSetEvent)
            SetEvent(hevtReboot);
		break;
	}

	//DequeueAllEvents(TRUE, FALSE);
	return 0;
}

void ProcessSpecialEvent(DEBUG_EVENT *pde, HTHDX hthd) { _asm int 3 }

VOID
ProcessFiberEvent(
    DEBUG_EVENT* pde,
    HTHDX        hthd
    )
{
    HPRCX hprc = hthd->hprc;
    HFBRX hfbr;
    EXCEPTION_DEBUG_INFO *dbginfo = (EXCEPTION_DEBUG_INFO *) &(pde->u);
    EFBR    efbr = dbginfo->ExceptionRecord.ExceptionInformation[0];

    // There are only two cases - Create Fiber and Delete Fiber

    switch(efbr) {
    case ecreate_fiber:

        hfbr = (HFBRX)MHAlloc(sizeof(HFBRXSTRUCT));
        memset(hfbr, 0, sizeof(*hfbr));

        // Add to the process's list of fibers
        hfbr->next = hprc->FbrLst;
        hprc->FbrLst = hfbr;

        // Grab the start and context pointers for the fiber

        hfbr->fbrstrt = (LPVOID)dbginfo->ExceptionRecord.ExceptionInformation[1];
        hfbr->fbrcntx = (LPVOID)dbginfo->ExceptionRecord.ExceptionInformation[2];

        // Have the debuggee continue after the exception
        hthd->tstate &= ~(ts_stopped|ts_first|ts_second);
        hthd->tstate |= ts_running;
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                DBG_CONTINUE,
                0);
        break;
    case edelete_fiber:
        {
            HFBRX  prevhfbr;
            LPVOID fbrstrt = (LPVOID)dbginfo->ExceptionRecord.ExceptionInformation[1];
            LPVOID fbrcntx = (LPVOID)dbginfo->ExceptionRecord.ExceptionInformation[2];

            hfbr = hprc->FbrLst;
            if((hfbr->fbrstrt == fbrstrt) &&
                    (hfbr->fbrcntx == fbrcntx)){
                    hprc->FbrLst = hfbr->next;
                    MHFree(hfbr);
            } else {
                prevhfbr = hfbr;
                hfbr = hfbr->next;
                while(hfbr){
                    if((hfbr->fbrstrt == fbrstrt) &&
                        (hfbr->fbrcntx == fbrcntx)){
                        prevhfbr->next = hfbr->next;
                        MHFree(hfbr);
                        break;
                    } else {
                        prevhfbr = hfbr;
                        hfbr = hfbr->next;
                    }
                }
            }
            // Have the debuggee continue after the exception
        hthd->tstate &= ~(ts_stopped|ts_first|ts_second);
        hthd->tstate |= ts_running;
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                DBG_CONTINUE,
                0);
        break;
        }
    }
}

void ProcessOleEvent(DEBUG_EVENT *pde, HTHDX hthd) { _asm int 3 }
void ProecssEntryPointEvent(DEBUG_EVENT *pde, HTHDX hthd) { _asm int 3 }
void ProcessSegmentLoadEvent(DEBUG_EVENT *pde, HTHDX hthd) { _asm int 3 }
void ProcessEntryPointEvent(DEBUG_EVENT *pde, HTHDX hthd) { _asm int 3 }

BOOL DequeueAllEvents(BOOL fForce, BOOL fConsume)
{
    LPCQUEUE    lpcq;
    BOOL        fDid = FALSE;
    HPRCX       hprc;
    HTHDX       hthd;

    EnterCriticalSection(&csContinueQueue);

    while ( lpcq=lpcqFirst ) {
        hprc = HPRCFromPID (lpcq->pid);

        if (hprc) {
            for (hthd = hprc->hthdChild; hthd; hthd = hthd->next) {
                if (hthd->fContextDirty) {
                    DbgSetThreadContext(hthd, &hthd->ctx);

                    hthd->fContextDirty = FALSE;
                }
                hthd->fWowEvent = FALSE;
            }

            //assert (hprc->lastTidDebugEvent == lpcq->tid);
			/* Since we continue to process debug events which don't actually
			 * stop execution, it's possible we've got a queued continue event
			 * for an older debug event.  If so, we skip it */
			if(hprc->lastTidDebugEvent != lpcq->tid) {
				assert(lpcq->tid != dwTidStopped);
				goto skipit;
			}
        }

        //UserTimerGo();

#if 0
        if (hprc) {
            assert (!hprc->fSoftBroken);
            for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                assert (!hthd->fSoftBroken);
            }
        }
#endif


		EnterCriticalSection(&csDEQ);
		if(lpcq->tid == dwTidStopped) {
			fDid = SUCCEEDED(DmContinueThread(lpcq->tid, lpcq->fException));
			/* Make sure everything else is running too */
			DmGo();
			dwTidStopped = 0;
			assert(fDeqStopped);
		} else
			fDid = fDeqStopped;
		if(fDeqStopped && pdeqFirst)
			SetEvent(hevtDEQ);
		fDeqStopped = FALSE;
		/* The only way we should be able to get here without doing any
		 * work is if we're creating the process */
		assert(fDid || !hprc || (hprc->pstate & ps_connect));
		LeaveCriticalSection(&csDEQ);

skipit:
        lpcqFirst = lpcq->next;
        if (lpcqFirst == NULL) {
            lpcqLast = NULL;
        }

        lpcq->next = lpcqFree;
        lpcqFree   = lpcq;
    }

    LeaveCriticalSection(&csContinueQueue);
    return fDid;
}                               /* DequeueContinueDebugEvents() */

void InitEventQueue(void)
{
    int n;
    int i;

    InitializeCriticalSection(&csContinueQueue);

    n = sizeof(cqueue) / sizeof(CQUEUE);
    for (i = 0; i < n-1; i++) {
        cqueue[i].next = &cqueue[i+1];
    }
    cqueue[n-1].next = NULL;
    lpcqFree = &cqueue[0];
    lpcqFirst = NULL;
    lpcqLast = NULL;
}


void QueueContinueDebugEvent(DWORD dwPid, DWORD dwTid, BOOL fException)
{
    LPCQUEUE lpcq;

    EnterCriticalSection(&csContinueQueue);

    lpcq = lpcqFree;
    assert(lpcq);

    lpcqFree = lpcq->next;

    lpcq->next = NULL;
    if (lpcqLast) {
        lpcqLast->next = lpcq;
    }
    lpcqLast = lpcq;

    if (!lpcqFirst) {
        lpcqFirst = lpcq;
    }

    lpcq->pid = dwPid;
    lpcq->tid = dwTid;
    lpcq->fException = fException;

    LeaveCriticalSection(&csContinueQueue);

    return;
}                               /* QueueContinueDebugEvent() */

void AddQueue (DWORD dwType, DWORD dwPid, DWORD dwTid, DWORD dwData,
	DWORD dwLen)
{
    HPRCX   hprc = HPRCFromPID (dwPid);

    assert (hprc);

    switch (dwType) {
        case QT_CONTINUE_DEBUG_EVENT:
        case QT_TRACE_DEBUG_EVENT:

            //
            // Another hack to the DM: this one's for soft async stop
            // support.
            //

#if 0
            if (hprc) {

                if (hprc->fSoftBroken) {
                    HTHDX   hthd = NULL;

                    hprc->fSoftBroken = FALSE;

                    for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                        if (hthd->fSoftBroken) {
                            hthd->fSoftBroken = FALSE;
                            VERIFY (ResumeThread (hthd->rwHand) != -1);
                        }
                    }

                    // successfully soft broke, so bailout

                    return;
                }
            }
#endif

            //
            // The thread id MUST BE hprc->lastTidDebugEvent.  Also, we
            // cannot necessarily find this during the dequeue because
            // at the time of dequeue the process structure may be gone.
            //

            if (hprc) {
				HTHDX hthd;
                dwTid = hprc->lastTidDebugEvent;
				/* We're in trouble if we try to continue this thread while 
				 * it's still marked stopped */
				hthd = HTHDXFromPIDTID(dwPid, dwTid);
				/* It is actually possible to get here if we have no hthd --
				 * in that case, we've gotten a continue in response to a
				 * thread terminate, and we're only going through the motions
				 * to keep the deq alive */
				assert(!hthd || !(hthd->tstate & ts_stopped));
            }

			assert(dwData == DBG_CONTINUE ||
				dwData == DBG_EXCEPTION_NOT_HANDLED);
#if 0
            if (!CrashDump)
#endif
			{
                QueueContinueDebugEvent (dwPid, dwTid,
					dwData == DBG_EXCEPTION_NOT_HANDLED);
            }
            break;

        case QT_RELOAD_MODULES:
        case QT_REBOOT:
        case QT_CRASH:
        case QT_RESYNC:
            assert(!"Unsupported usermode QType in AddQueue.");
            break;

        case QT_DEBUGSTRING:
            assert(!"Is this a bad idea?");
            DMPrintShellMsg( "%s", (LPSTR)dwData );
            free((LPSTR)dwData);
            break;

    }

    if (dwType == QT_CONTINUE_DEBUG_EVENT) {
        SetEvent( hEventContinue );
    }

    return;
}

void UserTimerStop(void)
{
}

VOID
RemoveFiberList(
    HPRCX hprc
    )
{
    HFBRX hfbr = hprc->FbrLst;
    HFBRX next = NULL;
    while(hfbr){
        next = hfbr->next;
        MHFree(hfbr);
        hfbr = next;
    }
    hprc->FbrLst = NULL;
}

BOOL
SetupDebugRegister(
    HTHDX       hthd,
    int         Register,
    int         DataSize,
    DWORD       DataAddr,
    DWORD       BpType
    )
{
	DWORD dwType;
	
	assert(Register >= 0 && Register < 4);

	ClearDebugRegister(hthd, Register);

	switch(BpType) {
    case bptpDataR:
        dwType = DMBREAK_READWRITE;
        break;

    case bptpDataW:
    case bptpDataC:
        dwType = DMBREAK_WRITE;
        break;

    case bptpDataExec:
        dwType = DMBREAK_EXECUTE;
        break;

    default:
        assert(!"Invalid BpType!!");
        return FALSE;
	}

	if(SUCCEEDED(DmSetDataBreakpoint((PVOID)DataAddr, dwType, DataSize))) {
		rgbDataBreak[Register][0] = (BYTE)dwType;
		rgbDataBreak[Register][1] = (BYTE)DataSize;
		rgpvDataBreak[Register] = (PVOID)DataAddr;
	}
	return rgbDataBreak[Register][0] != DMBREAK_NONE;
}

VOID
ClearDebugRegister(
    HTHDX   hthd,
    int     Register
    )
{
	assert(Register >= 0 && Register < 4);

	if(rgbDataBreak[Register][0] != DMBREAK_NONE) {
		PVOID pv;
		int i;

		rgbDataBreak[Register][0] = DMBREAK_NONE;
		pv = rgpvDataBreak[Register];

		/* Clear this one out first */
		DmSetDataBreakpoint(pv, DMBREAK_NONE, 0);

		for(i = 0; i < 4; ++i) {
			if(rgbDataBreak[i][0] != DMBREAK_NONE && rgpvDataBreak[i] == pv &&
					FAILED(DmSetDataBreakpoint(pv, rgbDataBreak[i][0],
					rgbDataBreak[i][1])))
				rgbDataBreak[i][0] = DMBREAK_NONE;
		}
	}
}

VOID
ClearAllDebugRegisters(
	HPRCX hprc
	)
{
	int i;

	for(i = 0; i < 4; ++i)
		ClearDebugRegister(NULL, i);
}

BOOL
DecodeSingleStepEvent(
    HTHDX           hthd,
    DEBUG_EVENT*    de,
    PDWORD          eventCode,
    PDWORD          subClass
    )
{
	/* We've encoded the data breakpoint information in the debug event, if
	 * it was a data breakpoint.  But GetWalkBPFromBits wants the actual dr6
	 * value, so if this is truly a data breakpoint, we'll walk our list and
	 * set the appropriate register bit if we find one */
	PEXCEPTION_RECORD per = &de->u.Exception.ExceptionRecord;

	if(per->NumberParameters) {
		/* A data breakpoint */
		int i;
		
		for(i = 0; i < 4; ++i) {
			if((DWORD)rgpvDataBreak[i] == per->ExceptionInformation[0] &&
				rgbDataBreak[i][0] == per->ExceptionInformation[1])
			{
				DWORD dwDr6 = 1 << i;
				PBREAKPOINT bp;
				 
				bp = GetWalkBPFromBits (hthd, dwDr6);

				if (bp && CheckDataBP (hthd, bp)) {
					de->dwDebugEventCode = *eventCode = BREAKPOINT_DEBUG_EVENT;
					*subClass = (DWORD) bp;
					per->ExceptionCode = *subClass;
				}
			}
		}
	}
	return TRUE;
}

DWORD ExecNotify(DWORD dw, DWORD dwState)
{
    dwExecState = dwState;
    return 0;
}

XOSD AttachOrReboot(void)
{
    XOSD xosd = xosdNone;
    HRESULT hr;

    if(FAILED(HrEnsureNotifier()))
        return xosdLineNotConnected;

    /* At init, we clear everything out */
    DmNotify(psessNotify, DM_NONE, NULL);
    
    /* Get the current execution state */
    DmNotify(psessNotify, DM_EXEC, ExecNotify);
    DmNotify(psessNotify, DM_NONE, NULL);

    /* If we're running an active process, we need to ask whether we should
     * attach to it or launch a new one */
    if((dwExecState == DMN_EXEC_START || dwExecState == DMN_EXEC_STOP) &&
        SUCCEEDED(DmConnectDebugger(TRUE)))
    {
        char szMsg[1024];
        char szTitle[256];
        char sz[512];
        DM_XBE xbe;

        xbe.LaunchPath[0] = 0;
        if(FAILED(DmGetXbeInfo(NULL, &xbe)))
            LoadString(hInstance, IDS_UNKNOWN_XBE, xbe.LaunchPath,
                sizeof xbe.LaunchPath);

        if(LoadString(hInstance, IDS_ATTACH, sz, sizeof sz)) {
            sprintf(szMsg, sz, xbe.LaunchPath);
            szTitle[0] = 0;
            LoadString(hInstance, IDS_XBOX_TITLE, szTitle, sizeof szTitle);
            if(MessageBox(NULL, szMsg, szTitle, MB_YESNO) == IDYES) {
                /* Need to reboot.  We need to wait for the reboot to
                 * complete */
                assert(!hevtReboot);
		        hevtReboot = CreateEvent(NULL, FALSE, FALSE, NULL);
		        hr = DmNotify(psessNotify, DM_EXEC, XboxNotification);
		        if(SUCCEEDED(hr)) {
			        DmReboot(DMBOOT_WAIT | DMBOOT_WARM);
			        if(WaitForSingleObject(hevtReboot, 120000) == WAIT_TIMEOUT)
				        xosd = xosdLineNotConnected;
			        else {
				        assert(dwExecState == DMN_EXEC_PENDING);
			        }
		        }
		        CloseHandle(hevtReboot);
		        hevtReboot = NULL;
                DmNotify(psessNotify, DM_NONE, NULL);
            }
        }
    }

    return xosd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\funccall.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    funchdr.c

Abstract:

    This file contians the code used for supporting function evaluation
    from the expression evaluator.

Author:

    Jim Schaad (jimsch) 06-04-92

Environment:

    Win32 - User



--*/

#include "precomp.h"
#pragma hdrstop



SetFile()


/**********************************************************************/

void NtfyFuncCall(DEBUG_EVENT * lpde, HTHDX hthd, DWORD unused, LPVOID lpvoid);

/**********************************************************************/


METHOD     MthdFuncNotify = {NtfyFuncCall};

extern DMTLFUNCTYPE        DmTlFunc;
extern LPDM_MSG            LpDmMsg;

/**********************************************************************/



VOID
ProcessSetupExecuteCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This function is called in response to a dmfSetupExecute request.
    It will create a local Execute Object and return the handle to
    the object.

Arguments:

    hprc        - Supplies the process handle for the operation
    hthd        - Supplies the thread handle for the operation
    lpdbb       - Supplies a pointer to possible futher information

Return Value:

    None.

--*/

{
    LPEXECUTE_OBJECT_DM lpeo;

    Unreferenced( hprc );

    DPRINT(1, ("Setup Execute"));

    /*
     *  In order for this to be a valid operation the requested
     *  thread must be in a stopped state (and don't allow evaluation
     *  until we have hit the loader breakpoint)
     */

    if (((hthd->tstate & ts_stopped) == 0) ||
         ((hthd->tstate & (ts_dead|ts_destroyed)) != 0) ||
         (hprc->pstate & (ps_preEntry|ps_preStart))) {

        LpDmMsg->xosdRet = xosdBadThread;
        goto Exit;
    }

    // By doing a funceval on a thread, you loose the exception.  You will
    // have to re-run the instruction to get the exception.
    
    hthd->tstate &= ~(ts_first |  ts_second);

    lpeo = MHAlloc(sizeof(EXECUTE_OBJECT_DM));
    if (lpeo == NULL) {
        LpDmMsg->xosdRet = xosdOutOfMemory;
        goto Exit;
    }
    memset(lpeo, 0, sizeof(EXECUTE_OBJECT_DM));

    LpDmMsg->xosdRet = xosdNone;
    *((HIND *)LpDmMsg->rgb) = (HIND) lpeo;
	EnsureHthdReg(hthd, CONTEXT_CONTROL);
	lpeo->ctxSav = hthd->ctx;

	/* Last thing we need to do is prep the Xbox for the function call. */
	if(SUCCEEDED(DmSetupFunctionCall(hthd->tid))) {
		/* We just changed ESP, so we need the new value */
		CONTEXT cr;

		cr.ContextFlags = CONTEXT_CONTROL;
		if(FAILED(DmGetThreadContext(hthd->tid, &cr)))
			/* If this failed, we're in deep trouble */
			cr.Esp = HthdReg(hthd, Esp);
		HthdReg(hthd, Esp) = cr.Esp;
		/* Now we need to tell the EM that the registers have changed */
		DMSendDebugPacket(dbcNil, hprc->hpid, hthd->htid, 0, NULL);
	} else {
		MHFree(lpeo);
		LpDmMsg->xosdRet = xosdOutOfMemory;
		goto Exit;
	}

    hthd->tstate |= ts_funceval;
    hthd->cFuncEval += 1;

Exit:
    Reply(sizeof(HIND), LpDmMsg, lpdbb->hpid);
    return;
}                               /* ProcessSetupExecute() */


VOID
ProcessStartExecuteCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    hprc        - Supplies the process handle for the operation
    hthd        - Supplies the thread handle for the operation
    lpdbb       - Supplies a pointer to possible futher information

Return Value:

    None.

--*/

{
    LPEXECUTE_STRUCT    lpes = (LPEXECUTE_STRUCT) (lpdbb->rgbVar);
    LPEXECUTE_OBJECT_DM lpeo;
    XOSD                xosd;


    /*
     *  Start by saving the information in the EXECUTE_STRUCT in
     *  the local Execute Object structure.
     */

    lpeo = (LPEXECUTE_OBJECT_DM) lpes->hindDm;

    DPRINT(1, ("Start Execute @%08x", lpes->addr.addr.off));

    lpeo->addrStart = lpes->addr;
    lpeo->pbpSave = AtBP(hthd);
    lpeo->fIgnoreEvents = lpes->fIgnoreEvents;
    lpeo->hthd = hthd;
    lpeo->lpbp = SetBP(hprc, hthd, bptpExec, bpnsStop, &(lpeo->addrStart), (HPID) lpeo);

    /*
     * Mark a breakpoint at the current address
     */

    SetBPFlag(hthd, lpeo->lpbp);

    /*
     *  Call a machine specific fucntion to setup stacks and some
     *  work in the Execute Object for later use.
     */

    xosd = SetupFunctionCall(lpeo, lpes);

    /*
     *  If the set up worked successfully, the next step to to register
     *  an expected debug event and
     *  step the child.
     */

    if (xosd == xosdNone) {
        SingleStep(hthd, &MthdFuncNotify, FALSE, TRUE);
    }

    LpDmMsg->xosdRet = xosd;
    Reply(0, LpDmMsg, lpdbb->hpid);
    return;
}                               /* ProcessStartExecute() */



VOID
ProcessCleanUpExecuteCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    hprc        - Supplies the process handle for the operation
    hthd        - Supplies the thread handle for the operation
    lpdbb       - Supplies a pointer to possible futher information

Return Value:

    None.

--*/

{
    LPEXECUTE_OBJECT_DM lpeo = *(LPEXECUTE_OBJECT_DM *) (lpdbb->rgbVar);

    DPRINT(1, ("Cleanup Execute"));

    hthd->cFuncEval -= 1;
    if (hthd->cFuncEval == 0) {
        hthd->tstate &= ~ts_funceval;
    }

    if (lpeo->lpbp) {
        RemoveBP(lpeo->lpbp);
    }

    /*
     * This is wrong if the BP could be removed during function evaluation
     */

    SetBPFlag(hthd, lpeo->pbpSave);

	/* Restore the register state and tell the EM that we've done so */
	hthd->ctx = lpeo->ctxSav;
	hthd->fContextDirty = TRUE;
	DMSendDebugPacket(dbcNil, hprc->hpid, hthd->htid, 0, NULL);

    LpDmMsg->xosdRet = xosdNone;
    Reply(0, LpDmMsg, lpdbb->hpid);

    MHFree( lpeo );
    return;
}                               /* ProcessCleanUpCmd() */



void
NtfyFuncCall(
    DEBUG_EVENT * lpde,
    HTHDX         hthd,
    DWORD         unused,
    LPVOID        lpv
    )

/*++

Routine Description:

    This function is called as the notifyer function for expected events
    for executing of functions for the expression evaluator.

Arguments:

    lpde        - Supplies the pointer to the debug event exception structure
    hthd        - Supplies the handle to the thread of the exception
    lpv         - Supplies a pointer to extra data for the expectation

Return Value:

    None.

--*/

{
    Unreferenced( lpde );
    Unreferenced( lpv );

    /*
     *  Debug output first
     */

    DEBUG_PRINT("** NtfyFuncCall **\n");

    hthd->tstate &= ~(ts_stopped|ts_first|ts_second);
    hthd->tstate |= ts_running;
    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);

    return;
}                               /* NtfyFuncCall() */




VOID
EvntBreakpoint(
    DEBUG_EVENT *    de,
    HTHDX            hthd
    )

/*++

Routine Description:

    This routine is called if the current thread is processing a function
    evaluation and a breakpoint debug event occurs.  The routine checks
    to see if the desired breakpoint has been reached.  If it has not
    then the breakpoint will be consumed and the thread continued.  If it
    has then a dbcExecuteDone notification will be sent to the debugger.

Arguments:

    de          - Supplies a pointer to the current debug event.
    hthd        - Supplies the handle of the current thread

Return Value:

    None.

--*/

{
    LPEXECUTE_OBJECT_DM lpeo;
    BREAKPOINT *        lpbpp;
    HIND                hzero = 0;

    lpbpp = (PBREAKPOINT) de->u.Exception.ExceptionRecord.ExceptionCode;
    if (lpbpp) {
        lpeo = (LPEXECUTE_OBJECT_DM) lpbpp->id;
    } else {
        lpeo = NULL;
    }

    DPRINT(1, ("Hit Execute Breakpoint (%08x)", lpbpp));

    /*
     *  This may have been a recursive call.  TO deal with this we need
     *  to check that the stack pointers are the same as when we started
     *  doing the function evaluation.
     *
     *  If it is not ok on the stacks then merely continue.  Note that this
     *  requires doing a single step event.
     *
     */

    if ((lpeo == NULL) || !CompareStacks(lpeo)) {
        SetBPFlag(hthd, lpbpp);

#if defined(TARGET_i386) && defined(KERNEL)
        DecrementIP( hthd );
#endif

        DPRINT(1, ("  Compare Stacks fail\n"));

        SingleStep(hthd, &MthdFuncNotify, FALSE, TRUE);

    } else {

        DPRINT(1, ("  Execute done\n"));

        /*
         *  We really did finish so send a message to that effect
         */

        DMSendDebugPacket(dbcExecuteDone,
                          hthd->hprc->hpid,
                          hthd->htid,
                          sizeof(HIND),
                          &hzero
                          );
    }
    return;
}                               /* EvntBreakpoint() */



VOID
EvntException(
    DEBUG_EVENT *    de,
    HTHDX            hthd
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    HIND hzero = 0;

    // allow the function being evaluated to get the first chance at the exception,
    // because it might have a handler for it
    if (de->u.Exception.dwFirstChance) {
        ProcessExceptionEvent( de, hthd );
        return;
    }

    DPRINT(1, ("Execute -- Exececption Occured\n"));

    hthd->fExceptionHandled = TRUE;

    DMSendDebugPacket(dbcExecuteDone,
                      hthd->hprc->hpid,
                      hthd->htid,
                      sizeof(HIND),
                      &hzero
                      );
    return;
}                               /* EvntException() */



VOID
EvntExitProcess(
    DEBUG_EVENT *    de,
    HTHDX            hthd
    )
/*++

Routine Description:

    This function is called if an exit process event is called while
    a function is being evaluated.

    This is a pain to deal with.  First the function evaluation must
    be killed and then we need to do normal processing

Arguments:

    de   - Supplies the Exit Process Debug event
    hthd - Supplies the handle to the current thread

Return Value:

    None.

--*/

{
    HIND hzero = 0;

    DPRINT(1, ("Execute -- Exit Process Occurred\n"));

    hthd->fExceptionHandled = TRUE;

    DMSendDebugPacket(dbcExecuteDone,
                      hthd->hprc->hpid,
                      hthd->htid,
                      sizeof(HIND),
                      &hzero
                      );

    ProcessExitProcessEvent(de, hthd);

    return;
}                               /* EvntExitProcess() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\i386thnk.c ===
#include "precomp.h"
#pragma hdrstop


BOOL
FIsVCallThunk(
    BYTE *          rgbBuffer,
    DWORD           cbBuff,
    HTHDX           hthd,
    UOFFSET         uoffEIP,
    UOFFSET *       lpuoffThunkDest,
    LPDWORD         lpdwThunkSize
    )
{
    static BYTE rgbVCall[] = {
        0x8B, 0x44, 0x24, 0x04,     // MOV  EAX, [ESP+4]
        0x8B, 0x00,                 // MOV  EAX, [EAX]
    };

    BOOL    fRet = FALSE;
    UOFFSET uoffEAX;
    BYTE *  pbNextInstr = NULL;

    assert( sizeof( rgbVCall ) <= CB_THUNK_MAX );
    assert( sizeof( UOFFSET ) == sizeof( long ) );

    // this_ptr in register
    if ( *(short UNALIGNED *)&rgbBuffer[ 0 ] == 0x018B ) {  // MOV  EAX, [ECX]
        // MOV  EAX, [ECX]
        fRet = DbgReadMemory(
                hthd->hprc,
                (LPCVOID)HthdReg(hthd,Ecx),
                (LPVOID)&uoffEAX,
                sizeof( UOFFSET ),
                NULL
                );

        pbNextInstr = &rgbBuffer[ 2 ];
    }
    else if ( cbBuff >= sizeof( rgbVCall ) &&
        !memcmp( rgbBuffer, rgbVCall, sizeof( rgbVCall ) )
    ) {
            // MOV  EAX, [ESP+4]
        fRet = DbgReadMemory(
                hthd->hprc,
                (LPCVOID)( HthdReg(hthd,Esp) + 4 ),
                (LPVOID)&uoffEAX,
                sizeof( UOFFSET ),
                NULL
            ) &&

            // MOV  EAX, [EAX]
            DbgReadMemory(
                hthd->hprc,
                (LPCVOID)uoffEAX,
                (LPVOID)&uoffEAX,
                sizeof( UOFFSET ),
                NULL
            );

        pbNextInstr = &rgbBuffer[ sizeof( rgbVCall ) ];
    }

    // Everything is fine so far, now get the last instruction
    // and return address
    if ( fRet ) {
        UOFFSET uoffDisp;

        // JMP [EAX+disp] (get displacement)
        if ( *(short UNALIGNED *)pbNextInstr == 0x60FF) {
            uoffDisp = (UOFFSET)*( pbNextInstr + 2 );
            pbNextInstr += 3;
        }
        // JMP[EAX+disp] (disp is 4 btyes)
        else if (*(short UNALIGNED *)pbNextInstr == 0xA0FF) {
            uoffDisp = *(UOFFSET *)(pbNextInstr + 2);
            pbNextInstr += 6;
        }
        // JMP [EAX]
        else if ( *(short UNALIGNED *)pbNextInstr == 0x20FF ) {
            uoffDisp = (UOFFSET)0;
            pbNextInstr += 2;
        }

        // Don't care, but this will force the compare
        // below to fail
        else {
            cbBuff = (DWORD)0;
        }

        // If we have made it here, then pbNextInstr must
        // have been reset to non-null
        assert( pbNextInstr );
        assert( pbNextInstr != rgbBuffer );

        // If the buffer is smaller than the number of bytes
        // consumed in this thunk or we can read the address
        // fail ([eap+disp])
        if ( cbBuff < (DWORD)( pbNextInstr - rgbBuffer - 1 ) ||
            !DbgReadMemory(
                hthd->hprc,
                (LPCVOID)( uoffEAX + uoffDisp ),
                lpuoffThunkDest,
                sizeof( UOFFSET ),
                NULL
            )
        ) {
            fRet = FALSE;
        }
    }
    if (fRet) {
        *lpdwThunkSize = pbNextInstr - rgbBuffer;
    }
    return fRet;
}

BOOL
FIsVTDispAdjustorThunk(
    BYTE *          rgbBuffer,
    DWORD           cbBuff,
    HTHDX           hthd,
    UOFFSET         uoffEIP,
    UOFFSET *       lpuoffThunkDest,
    LPDWORD         lpdwThunkSize
    )
{
    BOOL    fThisOnStack = (BOOL)( *(long *)&rgbBuffer[ 0 ] == 0x04244C8BL );
    BYTE *  pbNextInstr = &rgbBuffer[ 0 ];

    // If on the stack skip over this instruction
    if ( fThisOnStack ) {
        pbNextInstr += 4;
    }

    // Required SUB ECX, [ECX + dvtordisp]
    if ( *pbNextInstr == 0x2B ) {
        ++pbNextInstr;

        // SUB ECX, [ECX + byte/sign-extend]
        if ( *pbNextInstr == 0x49 ) {
            pbNextInstr += 2;
        }
        // SUB ECX, [ECX + dword]
        else if ( *pbNextInstr == 0x89 ) {
            pbNextInstr += 5;
        }
        else {
            return FALSE;
        }

        // Maybe an adjust (byte/sign extended)
        if ( *(short UNALIGNED *)pbNextInstr == 0xE983 ) {
            pbNextInstr += 3;
        }

        // Maybe an adjust (dword)
        else if ( *(short UNALIGNED *)pbNextInstr == 0xE981 ) {
            pbNextInstr += 6;
        }

        // If this is on the stack there must be a MOV [ESP + 4 ],ECX
        if ( fThisOnStack ) {
            if ( *(long UNALIGNED *)pbNextInstr != 0x04244C89L ) {
                return FALSE;
            }
            pbNextInstr += 4;
        }

        // Now make sure that the number of bytes consumed in this
        // thunk is valid.  By now, we know that we needed everything
        // up to this instruction and including the (hopefully) jmp
        // instruction number of bytes.
        //
        // Now we should have a direct relative jump (JMP  xxxxxxxx )
        if ( cbBuff >= (DWORD)( pbNextInstr - rgbBuffer + 5 ) &&
            *pbNextInstr == 0xE9
        ) {
            *lpuoffThunkDest = uoffEIP + pbNextInstr - rgbBuffer +
                *(DWORD UNALIGNED *)( pbNextInstr + 1 ) + 5;
            *lpdwThunkSize = pbNextInstr - rgbBuffer + 5;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
FIsAdjustorThunk(
    BYTE *          rgbBuffer,
    DWORD           cbBuff,
    HTHDX           hthd,
    UOFFSET         uoffEIP,
    UOFFSET FAR *   lpuoffThunkDest,
    LPDWORD         lpdwThunkSize
    )
{
    BYTE *  pbNextInstr = &rgbBuffer[ 0 ];
    BOOL    fRet = FALSE;

    // this adjustor ADD (byte/sign extended)
    if ( *pbNextInstr == 0x83 ) {
        ++pbNextInstr;

        // this in ECX: ECX, byte const
        if ( *pbNextInstr == 0xC1 || *pbNextInstr == 0xE9 ) {
            pbNextInstr += 2;
        }
        // this on stack:  ADD DWORD PTR [ESP+4],byte const
        else {
            DWORD dwInstrCode = (*(DWORD UNALIGNED *)pbNextInstr & 0x00FFFFFF );
            if ( dwInstrCode == 0x0004246CL || dwInstrCode == 0x00042444L ) {
                pbNextInstr += 4;
            }
            else {
                // not an adjustor thunk
                return FALSE;
            }
        }
        fRet = TRUE;
    }

    // this adjustor ADD (dword)
    else if ( *pbNextInstr == 0x81 ) {
        ++pbNextInstr;

        // this in ECX: ECX, dword const
        if ( *pbNextInstr == 0xC1 || *pbNextInstr == 0xE9 ) {
            pbNextInstr += 5;
        }
        // this on stack:  ADD DWORD PTR [ESP+4],byte const
        else {
            DWORD dwInstrCode = (*(DWORD UNALIGNED *)pbNextInstr & 0x00FFFFFF );
            if ( dwInstrCode == 0x0004246CL || dwInstrCode == 0x00042444L ) {
                pbNextInstr += 7;
            }
            else {
                // not an adjustor thunk
                return FALSE;
            }
        }
        fRet = TRUE;
    }

    if ( fRet ) {
        // Now make sure that the number of bytes consumed in this
        // thunk is valid.  By now, we know that we needed everything
        // up to this instruction and including the (hopefully) jmp
        // instruction number of bytes.
        //
        // Now we should have a direct relative jump (JMP  xxxxxxxx )
        if ( cbBuff >= (DWORD)( pbNextInstr - rgbBuffer + 5 ) &&
            *pbNextInstr == 0xE9
        ) {
            *lpuoffThunkDest = uoffEIP + pbNextInstr - rgbBuffer +
                *( DWORD UNALIGNED * )( pbNextInstr + 1 ) + 5;
            *lpdwThunkSize = pbNextInstr - rgbBuffer + 5;
        }
        else {
            fRet = FALSE;
        }
    }
    return fRet;
}

BOOL
FIsIndirectJump(
    BYTE *          rgbBuffer,
    DWORD           cbBuff,
    HTHDX           hthd,
    UOFFSET         uoffEIP,
    UOFFSET FAR *   lpuoffThunkDest,
    LPDWORD         lpdwThunkSize
    )
{
    // FF 25 xxxxxxxx is indirect jump (jmp [xxxxxxxx])
    // Buffer needs to be opcode + 32-bit offset
    if ( cbBuff >= 6 && *(short *)rgbBuffer == 0x25FF ) {
        if ( DbgReadMemory (
                hthd->hprc,
                (LPCVOID)*(DWORD *)&rgbBuffer[ 2 ],
                lpuoffThunkDest,
                sizeof(UOFFSET),
                NULL)
        ) {
            *lpdwThunkSize = 6;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
FIsDirectJump(
    BYTE *          rgbBuffer,
    DWORD           cbBuff,
    HTHDX           hthd,
    UOFFSET         uoffEIP,
    UOFFSET FAR *   lpuoffThunkDest,
    LPDWORD         lpdwThunkSize
    )
{
    // E9 = direct jump.  (jmp xxxxxxxx).
    // Buffer must be large enough for opcode plus 32-bit offset
    if ( cbBuff >= 5 && rgbBuffer[ 0 ] == 0xE9 ) {
        *lpuoffThunkDest = uoffEIP +
            *( DWORD * )( rgbBuffer + sizeof ( BYTE ) ) + 5;
        *lpdwThunkSize = 5;
        return TRUE;
    }
    return FALSE;
}


/*** GETPMFDEST
 *
 * PURPOSE:
 *      Given the this pointer and a SI PMF figure out the address of the member
 *      function being called.
 *
 * INPUT:
 *      uThis           - value of the this pointer.
 *      uPMF            - the ptr to mbr function.
 *      lpuoffDest      - Where the PMF is going to
 *
 * OUTPUT:
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 ****************************************************************************/

 BOOL
 GetPMFDest(
    HTHDX hthd,
    UOFFSET uThis,
    UOFFSET uPMF,
    UOFFSET *lpuOffDest
    )
 {
    static BYTE rgbVCall[] = {
        0x8B, 0x44, 0x24, 0x04,     // MOV  EAX, [ESP+4]
        0x8B, 0x00,                 // MOV  EAX, [EAX]
    };

    UOFFSET uOffCurr;
    UOFFSET uOffNext = uPMF;
    BYTE rgbBuffer[CB_THUNK_MAX];
    DWORD dwLength;
    int cThunks = 8; // Look for a max of 8 to avoid any infinite loop.
    UOFFSET uVtable; // The v-table ptr.
    UOFFSET uOffDisp; // The disp in the vtable where the func ptr is.
    BYTE * pbNextInstr = NULL;
    DWORD dwSize;

    *lpuOffDest = (UOFFSET)0;

    // First skip past any ilink thunks so we get to the
    // vcall thunk.
    do
    {
        uOffCurr = uOffNext;
        dwLength = CB_THUNK_MAX;

        // Read until a read succeeds or there's no room left to read
        if (--cThunks == 0 ||
            !DbgReadMemory (
                 hthd->hprc,
                 (LPVOID)uOffCurr,
                 rgbBuffer,
                 dwLength,
                 &dwLength
                 )) {

            // If we couldn't read anything at the location OR
            // we have already looked at 8 thunks, just return
            // indicating  we couldn't find it.
            return FALSE;
        }

    } while ( FIsDirectJump( rgbBuffer, dwLength, hthd, uOffCurr,
                    &uOffNext, &dwSize)
              || FIsIndirectJump( rgbBuffer, dwLength, hthd, uOffCurr,
                    &uOffNext, &dwSize ) );

    // At this point we should still have a valid set of code bytes
    // in rgbBuffer, and uOffCurr will have the address to it.
    assert(dwLength);

    // There is code here which is essentially duplication of the
    // logic in FIsVCallThunk.

    if ((dwLength >= 2) &&
        *(short *)rgbBuffer == 0x018B ) {       //  MOV EAX, [ECX]
        pbNextInstr = &rgbBuffer[ 2 ];
        dwLength -= 2;
    }
    else if ( dwLength >= sizeof( rgbVCall) &&
        !memcmp(rgbBuffer, rgbVCall, sizeof(rgbVCall) )
    ) {
        pbNextInstr = &rgbBuffer[ sizeof( rgbVCall ) ];
        dwLength -= sizeof( rgbVCall );
    }
    else {
        // This must be a pointer to a non-virtual member func.
        *lpuOffDest = uOffCurr;
        return TRUE;
    }

    assert( pbNextInstr );

    // JMP [EAX+disp] (get displacement)
    if ( dwLength >= 3 && *(short UNALIGNED *)pbNextInstr == 0x60FF ) {
        uOffDisp = (UOFFSET)*(pbNextInstr + 2);
    }
    // JMP [EAX+disp] (4 byte displacement)
    else if ( dwLength >= 6 && *(short UNALIGNED *)pbNextInstr == 0xA0FF ) {
        uOffDisp = *(UOFFSET *)(pbNextInstr + 2);
    }
    else if ( dwLength >=2 &&  *(short UNALIGNED *)pbNextInstr == 0x20FF ) {
        uOffDisp = (UOFFSET) 0;
    }
    else { // Not one of the jump variants, must not be a thunk.
        assert(FALSE);
        return FALSE;
    }

    // Get the vtable ptr
    if ( !DbgReadMemory(
            hthd->hprc,
            (LPCVOID)uThis,
            &uVtable,
            sizeof(UOFFSET),
            NULL
            )
    ) {
        return FALSE;
    }

    // Use the vtable pointer and uOffDisp to get the
    // vtable entry corresponding to this call.

    if ( DbgReadMemory(
            hthd->hprc,
            (LPCVOID)( uVtable + uOffDisp ),
            lpuOffDest,
            sizeof ( UOFFSET ),
            NULL
            )
    ) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\i386mach.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mach.c

Abstract:

    This file contains the x86 specific code for dealing with
    machine dependent issues that invlove registers, instruction
    disassembly, function calling and other interesting things.

Author:

    Jim Schaad (jimsch)

Environment:

    Win32 - User

Notes:

--*/
#include "precomp.h"
#pragma hdrstop

#include "i386excp.h"

extern CRITICAL_SECTION csContinueQueue;

/**********************************************************************/

extern LPDM_MSG LpDmMsg;

/**********************************************************************/

#if    DBG
static char * rgszTrace[] = {
    "Trace", "BreakPoint", "Cannot Trace", "Soft Int", "Call"
};
#endif // DBG

#define MAXL 20L

#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)


static int	mod;        /* mod of mod/rm byte */



//
// Stuff for debug registers
//


typedef struct _DR7 *PDR7;
typedef struct _DR7 {
    DWORD       L0      : 1;
    DWORD       G0      : 1;
    DWORD       L1      : 1;
    DWORD       G1      : 1;
    DWORD       L2      : 1;
    DWORD       G2      : 1;
    DWORD       L3      : 1;
    DWORD       G3      : 1;
    DWORD       LE      : 1;
    DWORD       GE      : 1;
    DWORD       Pad1    : 3;
    DWORD       GD      : 1;
    DWORD       Pad2    : 1;
    DWORD       Pad3    : 1;
    DWORD       Rwe0    : 2;
    DWORD       Len0    : 2;
    DWORD       Rwe1    : 2;
    DWORD       Len1    : 2;
    DWORD       Rwe2    : 2;
    DWORD       Len2    : 2;
    DWORD       Rwe3    : 2;
    DWORD       Len3    : 2;
} DR7;


#define RWE_EXEC        0x00
#define RWE_WRITE       0x01
#define RWE_RESERVED    0x02
#define RWE_READWRITE   0x03


DWORD       LenMask[ MAX_DEBUG_REG_DATA_SIZE + 1 ] = DEBUG_REG_LENGTH_MASKS;


BOOL
IsRet(
    HTHDX hthd,
    LPADDR  addr
    )
{
    BYTE instr;
    DWORD cBytes;
    if (!AddrReadMemory( hthd->hprc, hthd, addr, &instr, 1, &cBytes )) {
        return FALSE;
    }

    return  ((instr == 0xc2) || (instr == 0xc3) ||
                 (instr == 0xca) || (instr == 0xcb)) ?
                 RETURN_USER :
                 RETURN_NONE;
}



void
IsCallEx(
    HTHDX   hthd,
    LPADDR  lpaddr,
    LPINT   lpf,
    BOOL    fStepOver,
	LPADDR	addrDest
    )
/*++

Routine Description:

    This function checks to see if the specified instruction is
    a call instruction.

Arguments:

    hthd        - Supplies the handle to the current thread

    lpaddr      - Supplies the address to check for the call instruction at

    lpf         - Returns TRUE if is a call instruction

    fStepOver   - Supplies TRUE if doing a step over

	addrDest    - If this is a call instruction, gives the destination.
				  At this time this only works for "simple calls",
				  i.e., E8 calls.

Return Value:

    None.

--*/

{
    int     mode_32;
    int     opsize_32;
    DWORD   cBytes;
    DWORD   cb;
    char    membuf [ MAXL ];
    char    *pMem;
    UCHAR   opcode, savedOpcode;
    int     fPrefix;
    int     fRepPrefix;
    int     ttt;
    int     mode;
    int     rm;
    BOOL    fAddrSet;
    ULONG   rgul[2];
    USHORT  rgus[2];
    ADDR    addrSp;
    UOFFSET     uNextEip = GetAddrOff(*lpaddr);
	OFFSET	offDest = 0;

	if (addrDest) {
		memset (addrDest, 0, sizeof (*addrDest));
	}
	
    /*
     * local addressing mode
     */

    mode_32 = opsize_32 = hthd->fAddrOff32;

    /*
     * Read enough bytes to get the longest possible instruction
     */

    if (!AddrReadMemory( hthd->hprc,
                         hthd,
                         lpaddr,
                         membuf,
                         MAXL,
                         &cBytes) ||
            (cBytes == 0)) {
        goto done;
    }

    DPRINT(1, ("(IsCall?) EIP=%08x Type=", *lpaddr));

    /*
     *  point to begin of instruction
     */

    pMem = membuf;

    /*
     * read and process any prefixes first
     */

    fPrefix = TRUE;
    fRepPrefix = FALSE;

    do {
        opcode = (UCHAR) *pMem++;   /* get opcode */

        /*
         *  Operand size prefix
         */

        if (opcode == 0x66) {
            opsize_32 = !opsize_32;
        }
        /*
         * Address size prefix
         */

        else if (opcode == 0x67) {
            mode_32 = !mode_32;
        }
        /*
         *  REP and REPNE prefix
         */
        else if ((opcode & ~1) == 0xf2) {
            fRepPrefix = TRUE;
        }
        /*
         *  LOCK prefix   (0xf0)
         *  Segment Override (0x26, 0x36, 0x2e, 0x3e, 0x64, 0x65)
         */
        else if ( opcode != 0xf0 &&
                  (opcode & ~0x18) != 0x26 &&
                  (opcode & ~1) != 0x64 ) {
            fPrefix = FALSE;
        }
    } while ( fPrefix );

    /*
     *  Now start checking for the instructions which must be treated
     *  in a special manner.   Any instruction which does not respect
     *  the trace bit (either due to flag munging or faulting) needs
     *  to be treated specially.  Also all call ops need to be treated
     *  specially (step in vs step over).  Finally interupts need to
     *  be treated specially since they could cause faults in 16-bit mode
     */

    fAddrSet = FALSE;

    savedOpcode = opcode;

    /*
     *  Break point instruction
     */
    if (opcode == 0xcc) {
        *lpf = INSTR_BREAKPOINT;
    }
    // NOTENOTE -- missing the INTO instruction
    /*
     *  all other interrrupt instructions
     */
    else if (opcode == 0xcd) {
        opcode = (UCHAR) *pMem++;

        /*
         * Is this really a 2-byte version of INT 3 ?
         */
        if (opcode == 0x3) {
            *lpf = INSTR_BREAKPOINT;
        }
        /*
         * Is this a funky 16-bit floating point instruction?  if so then
         *      we need to make sure and step over it
         */
        else if (!ADDR_IS_FLAT(*lpaddr) &&
                 (0x34 <= opcode) && (opcode <= 0x3c)) {
            if (opcode == 0x3C) {
                pMem++;
            }
            opcode = *pMem++;
            mode = opcode & 0xc0;
            rm = opcode & 0x03;
            switch ( mode) {
            case 0:
                if (rm == 0x6) {
                    pMem += 2;
                }
                break;

            case 1:
                pMem += 1;
                break;

            case 2:
                pMem += 2;
                break;
            }
            *lpf = INSTR_CANNOT_TRACE;
            GetAddrOff(*lpaddr) += pMem - membuf;
            fAddrSet = TRUE;
        }
        /*
         *   This is an FWAIT instr -- 2 bytes long
         */
        else if (!ADDR_IS_FLAT(*lpaddr) && opcode == 0x3d) {
            *lpf = INSTR_CANNOT_TRACE;
            GetAddrOff(*lpaddr) += 2;
            fAddrSet = TRUE;
        }
        /*
         *  This is a 0x3f interrupt -- I think this is for
         *      overlays in dos
         */
        else if (!ADDR_IS_FLAT(*lpaddr) && (opcode == 0x3f)) {
            if (fStepOver) {
                *lpf = INSTR_CANNOT_TRACE;
                AddrInit(&addrSp, 0, SsSegOfHthdx(hthd), STACK_POINTER(hthd),
                         FALSE, FALSE, FALSE, hthd->fAddrIsReal);
                if (!AddrReadMemory(hthd->hprc,
                                    hthd,
                                    &addrSp,
                                    rgus,
                                    4,
                                    &cb) ||
                        (cb != 4) ) {
                    goto done;
                }
                AddrInit(lpaddr, 0, rgus[1], (UOFF32) rgus[0], FALSE, FALSE,
                         FALSE, hthd->fAddrIsReal);
                fAddrSet = TRUE;
            }
        }
        /*
         *  OK its really an interrupt --- deal with it
         */
        else {
            if (!fStepOver && hthd->fAddrIsReal) {
                *lpf = INSTR_CANNOT_TRACE;
                AddrInit(&addrSp, 0, 0, opcode*4, FALSE, FALSE, FALSE, TRUE);
                if (!AddrReadMemory(hthd->hprc,
                                    hthd,
                                    &addrSp,
                                    rgus,
                                    4,
                                    &cb) ||
                        (cb != 4) ) {
                    goto done;
                }
                AddrInit(lpaddr, 0, rgus[1], (UOFF32) rgus[0], FALSE, FALSE,
                         FALSE, TRUE);
                fAddrSet = TRUE;
            }
        }
    }
    /*
     *  Now check for various call instructions
     */
    else if (opcode == 0xe8) {  /* near direct call */
        *lpf = INSTR_IS_CALL;
		if (opsize_32) {
			offDest = *(LONG*) pMem;
		} else {
			offDest = *(SHORT*) pMem;
		}
        pMem += (1 + opsize_32) * 2;
    } else if (opcode == 0x9a) { /* far direct call */
        *lpf = INSTR_IS_CALL;
		if (opsize_32) {
			offDest = *(LONG*) pMem;
		} else {
			offDest = *(SHORT*) pMem;
		}
        pMem += (2 + opsize_32) * 2;
    } else if (opcode == 0xff) {

		//
		// If you hit this assert you will need to figure out how to get
		// the destination.  Assert is here mostly to tell you that it
		// is NYI.
		//
		
		assert (addrDest == NULL);
        opcode = *pMem++;       /* compute the modRM bits for instruction */
        ttt = BIT53(opcode);
        if ((ttt & ~1) == 2) {  /* indirect call */
            *lpf = INSTR_IS_CALL;

            mod = BIT76(opcode);
            if (mod != 3) {    /* non-register operand */
                rm = BIT20( opcode );
                if (mode_32) {
                    if (rm == 4) {
                        rm = BIT20(*pMem++); /* get base from SIB */
                    }

                    if (mod == 0) {
                        if (rm == 5) {
                            pMem += 4; /* long direct address */
                        }
                    } else if (mod == 1) {
                        pMem++; /* register with byte offset */
                    } else {
                        pMem += 4; /* register with long offset */
                    }
                } else {        /* 16-bit mode */
                    if (mod == 0) {
                        if (rm == 6) {
                            pMem += 2; /* short direct address */
                        }
                    } else {
                        pMem += mod; /* reg, byte, word offset */
                    }
                }
            }
        }
    }
    /*
     * Now catch all of the repeated instructions
     *
     *  INSB  (0x6c) INSW  (0x6d) OUTSB (0x6e) OUTSW (0x6f)
     *  MOVSB (0xa4) MOVSW (0xa5) CMPSB (0xa6) CMPSW (0xa7)
     *  STOSB (0xaa) STOSW (0xab)
     *  LODSB (0xac) LODSW (0xad) SCASB (0xae) SCASW (0xaf)
     */
    else if (fRepPrefix && (((opcode & ~3) == 0x6c) ||
                            ((opcode & ~3) == 0xa4) ||
                            ((opcode & ~1) == 0xaa) ||
                            ((opcode & ~3) == 0xac))) {
        if (fStepOver) {
            *lpf = INSTR_CANNOT_TRACE;
        } else {
            /*
             *  Cannot trace the ins/outs instructions
             */
            if ((opcode & ~3) == 0x6c) {
                *lpf = INSTR_CANNOT_TRACE;
            }
        }
    }
    /*
     *  Now catch IO instructions -- these will generally fault and
     *  be interpreted.
     */
    else if ((opcode & ~3) == 0x6c) {
        *lpf = INSTR_CANNOT_TRACE;
    }
    /*
     *  Now catch other instructions which change registers
     */
    else if ((opcode == 0xfa) || (opcode == 0xfb) ||
             (opcode == 0x9d) || (opcode == 0x9c)) {
        *lpf = INSTR_CANNOT_TRACE;
    }
    /*
     * Now catch irets
     */
    else if (opcode == 0xcf) {
        *lpf = INSTR_CANNOT_TRACE;
        AddrInit(&addrSp, 0, SsSegOfHthdx(hthd), STACK_POINTER(hthd),
                 hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE,
                 hthd->fAddrIsReal);
        if (opsize_32) {
            if (!AddrReadMemory(hthd->hprc,
                                hthd,
                                &addrSp,
                                rgul,
                                8,
                                &cb) ||
                    (cb != 8) ) {
                goto done;
            }
            AddrInit(lpaddr, 0, (SEGMENT) rgul[1], rgul[0],
                     hthd->fAddrIsFlat, TRUE, FALSE, FALSE);
        } else {
            if (!AddrReadMemory(hthd->hprc,
                                hthd,
                                &addrSp,
                                rgus,
                                4,
                                &cb) ||
                    (cb != 4) ) {
                goto done;
            }
            AddrInit(lpaddr, 0, rgus[1], (UOFF32) rgus[0], FALSE, FALSE,
                     FALSE, hthd->fAddrIsReal);
        }
        fAddrSet = TRUE;
    }
    /*
     *  Assume that we want to just trace the instruction
     */
    else {
        *lpf = INSTR_TRACE_BIT;
        goto done;
    }

    /*
     *
     */

    DPRINT(1, ("%s", rgszTrace[*lpf]));

    /*
     * Have read enough bytes?   no -- expect somebody else to blow up
     */

    if (cBytes < (DWORD)(pMem - membuf)) {
        *lpf = INSTR_TRACE_BIT;
        goto done;
    }

    if (!fAddrSet) {
        GetAddrOff(*lpaddr) += pMem - membuf;
    }

	if (addrDest) {
		*addrDest = *lpaddr;
		GetAddrOff (*addrDest) += offDest;
	}

    /*
     * Dump out the bytes for later checking
     */

#if DBG
    if (FVerbose) {
        DWORD  i;
        DPRINT(1, ("length = %d  bytes=", cBytes & 0xff));
        for (i=0; i<cBytes; i++) {
            DPRINT(1, (" %02x", membuf[i]));
        }
    }
#endif

 done:
#if 0
    if (IsChicago()) {
        // Check for return to Win95 system code - can't step that code
        if ((savedOpcode == 0xc2) || (savedOpcode == 0xc3)) {
            ADDR addr = *lpaddr;    // initialize all fields

            addr.addr.off = hthd->context.Esp;
            AddrReadMemory(hthd->hprc, hthd, &addr, &uNextEip, sizeof(uNextEip), &cBytes);
        }
        if (IsInSystemDll(uNextEip)) {
            *lpf = INSTR_CANNOT_STEP;
        }
    }
#endif
    hthd->fIsCallDone = TRUE;
    hthd->addrIsCall = *lpaddr;
    hthd->iInstrIsCall = *lpf;
    return;
}                               /* IsCall() */



void
IsCall(
	HTHDX	hthd,
	LPADDR	lpaddr,
	LPINT	lpf,
	BOOL	fStepOver
	)
{
	IsCallEx (hthd, lpaddr, lpf, fStepOver, NULL);
}



XOSD
SetupFunctionCall(
    LPEXECUTE_OBJECT_DM lpeo,
    LPEXECUTE_STRUCT    lpes
    )
/*++

Routine Description:

    This function contains the machine dependent code for initializing
    the function call system.

Arguments:

    lpeo   - Supplies a pointer to the Execute Object for the Function call

    lpes   - Supplies a pointer to the Execute Struct from the DM

Return Value:

    XOSD error code

--*/

{
    CONTEXT     context;
    OFFSET      off;
    int         cb;
    ULONG       ul;
    HPRCX       hprc = lpeo->hthd->hprc;
    ADDR        addr;

    /*
     *  Can only execute functions on the current stopped thread.  Therefore
     *  assert that the current thread is stopped.
     */

    assert(lpeo->hthd->tstate & ts_stopped);
    if (!(lpeo->hthd->tstate & ts_stopped)) {
        return xosdBadThread;
    }

    /*
     * Can copy the context from the cached context in the thread structure
     */

	EnsureHthdReg(lpeo->hthd, CONTEXT_CONTROL);
    context = lpeo->hthd->ctx;

    /*
     *  Now get the current stack offset
     */

    lpeo->addrStack.addr.off = context.Esp;
    lpeo->addrStack.addr.seg = (SEGMENT) context.SegSs;
    if (!lpeo->hthd->fAddrOff32) {
        lpeo->addrStack.addr.off &= 0xffff;
    }

    /*
     *  Put the return address onto the stack.  If this is a far address
     *  then it needs to be a far return address.  Else it must be a
     *  near return address.
     */

    if (lpeo->hthd->fAddrOff32) {
        if (lpes->fFar) {
            assert(FALSE);          /* Not used for Win32 */
        }

        off = context.Esp - 4;
        if (DbgWriteMemory(hprc, (char *) off, &lpeo->addrStart.addr.off,
                               4, &cb) == 0 ||
            (cb != 4)) {
            return xosdUnknown;
        }
    } else {
        if (lpes->fFar) {
            off = context.Esp - 4;
            ul = (lpeo->addrStart.addr.seg << 16) | lpeo->addrStart.addr.off;
            addr = lpeo->addrStack;
            GetAddrOff(addr) -= 4;
            TranslateAddress(hprc, lpeo->hthd, &addr, TRUE);
            if ((DbgWriteMemory(hprc, (char *) GetAddrOff(addr),
                                    &ul, 4, &cb) == 0) ||
                (cb != 4)) {
                return xosdUnknown;
            }
        } else {
            off = context.Esp & 0xffff - 2;
            addr = lpeo->addrStack;
            GetAddrOff(addr) -= 2;
            TranslateAddress(hprc, lpeo->hthd, &addr, TRUE);
            if ((DbgWriteMemory(hprc, (char *) GetAddrOff(addr),
                                    &lpeo->addrStart.addr.off, 2, &cb) == 0) ||
                (cb != 2)) {
                return xosdUnknown;
            }
        }
    }

    /*
     *  Set the new stack pointer and starting address in the context and
     *  write them back to the thread.
     */

    HthdReg(lpeo->hthd,Esp) = off;
    HthdReg(lpeo->hthd,Eip) = lpeo->addrStart.addr.off;

    lpeo->hthd->fContextDirty = TRUE;

    return xosdNone;
}                               /* SetupFunctionCall() */




BOOL
CompareStacks(
    LPEXECUTE_OBJECT_DM       lpeo
    )

/*++

Routine Description:

    This routine is used to determine if the stack pointers are currect
    for terminating function evaluation.

Arguments:

    lpeo        - Supplies the pointer to the DM Execute Object description

Return Value:

    TRUE if the evaluation is to be terminated and FALSE otherwise

--*/

{
    if (lpeo->hthd->fAddrOff32) {
        if (lpeo->ctxSav.Esp <= HthdReg(lpeo->hthd,Esp)) {
            return TRUE;
        }
    } else if ((lpeo->addrStack.addr.off <= (HthdReg(lpeo->hthd,Esp) & 0xffff)) &&
               (lpeo->addrStack.addr.seg == (SEGMENT) HthdReg(lpeo->hthd,SegSs))) {
        return TRUE;
    }
    return FALSE;
}                               /* CompareStacks() */

#ifndef KERNEL
#if 0

void
ProcessGetDRegsCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    LPDWORD   lpdw = (LPDWORD)LpDmMsg->rgb;
    CONTEXT   cxt;
    int       rs = 0;

    DEBUG_PRINT( "ProcessGetDRegsCmd :\n");

	_asm int 3
	LpDmMsg->xosdRet = xosdGeneral;
#if 0
    if (hthd == 0) {
        rs = 0;
    } else {
        cxt.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        if (!GetThreadContext(hthd->rwHand, &cxt)) {
            LpDmMsg->xosdRet = xosdUnknown;
            rs = 0;
        } else {
            lpdw[0] = hthd->context.Dr0;
            lpdw[1] = hthd->context.Dr1;
            lpdw[2] = hthd->context.Dr2;
            lpdw[3] = hthd->context.Dr3;
            lpdw[4] = hthd->context.Dr6;
            lpdw[5] = hthd->context.Dr7;
            LpDmMsg->xosdRet = xosdNone;
            rs = sizeof(CONTEXT);
        }
    }
#endif

    Reply( rs, LpDmMsg, lpdbb->hpid );
    return;
}                             /* ProcessGetDRegsCmd() */


void
ProcessSetDRegsCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    XOSD        xosd = xosdNone;
	_asm int 3
#if 0
    LPDWORD     lpdw = (LPDWORD)(lpdbb->rgbVar);

    Unreferenced(hprc);

    DPRINT(5, ("ProcessSetDRegsCmd : "));

    hthd->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    hthd->context.Dr0 = lpdw[0];
    hthd->context.Dr1 = lpdw[1];
    hthd->context.Dr2 = lpdw[2];
    hthd->context.Dr3 = lpdw[3];
    hthd->context.Dr6 = lpdw[4];
    hthd->context.Dr7 = lpdw[5];


    if (hthd->fWowEvent) {
        WOWSetThreadContext(hthd, &hthd->context);
    } else {
        SetThreadContext(hthd->rwHand, &hthd->context);
    }
#endif

    Reply(0, &xosd, lpdbb->hpid);

    return;
}                               /* ProcessSetDRegsCmd() */
#endif // 0


DWORDLONG
GetFunctionResult(
    PCALLSTRUCT pcs
    )
{
    return pcs->context.Eax;
}

#if 0
VOID
vCallFunctionHelper(
    HTHDX hthd,
    FARPROC lpFunction,
    int cArgs,
    va_list vargs
    )
{
    int i;
    DWORD dw;

    //
    // set up the args to SuspendThread
    //

    for (i = 0; i < cArgs; i++) {

        DWORD dw;
        DWORD arg = va_arg(vargs, DWORD);

        HthdReg(hthd,Esp) -= 4;
        DbgWriteMemory(hthd->hprc,
                           (PVOID)HthdReg(hthd,Esp),
                           &arg,
                           sizeof(arg),
                           &dw);
    }

    HthdReg(hthd,Esp) -= 4;
    DbgWriteMemory(hthd->hprc,
                       (PVOID)HthdReg(hthd,Esp),
                       &(PC(hthd)),
                       sizeof(DWORD),
                       &dw);

    PC(hthd) = (DWORD)lpFunction;
    hthd->fContextDirty = TRUE;
}
#endif // 0

#endif // !KERNEL

BOOL
ProcessFrameStackWalkNextCmd(HPRCX hprc,
                             HTHDX hthd,
                             PCONTEXT context,
                             LPVOID pctxPtrs)

{
    return FALSE;
}


#if 0

XOSD disasm ( LPSDI lpsdi, void*Memory, int Size );
BOOL ParseAddr ( char*, ADDR* );
BOOL ParseNumber( char*, DWORD*, int );


typedef struct _BTNODE {
    char    *Name;
    BOOL    IsCall;
    BOOL    TargetAvail;
} BTNODE;


BTNODE BranchTable[] = {
    { "call"    ,   TRUE    ,   TRUE    },
    { "ja"      ,   FALSE   ,   TRUE    },
    { "jae"     ,   FALSE   ,   TRUE    },
    { "jb"      ,   FALSE   ,   TRUE    },
    { "jbe"     ,   FALSE   ,   TRUE    },
    { "jcxz"    ,   FALSE   ,   TRUE    },
    { "je"      ,   FALSE   ,   TRUE    },
    { "jecxz"   ,   FALSE   ,   TRUE    },
    { "jg"      ,   FALSE   ,   TRUE    },
    { "jge"     ,   FALSE   ,   TRUE    },
    { "jl"      ,   FALSE   ,   TRUE    },
    { "jle"     ,   FALSE   ,   TRUE    },
    { "jmp"     ,   FALSE   ,   TRUE    },
    { "jne"     ,   FALSE   ,   TRUE    },
    { "jno"     ,   FALSE   ,   TRUE    },
    { "jnp"     ,   FALSE   ,   TRUE    },
    { "jns"     ,   FALSE   ,   TRUE    },
    { "jo"      ,   FALSE   ,   TRUE    },
    { "jp"      ,   FALSE   ,   TRUE    },
    { "js"      ,   FALSE   ,   TRUE    },
    { "loop"    ,   FALSE   ,   FALSE   },
    { "loope"   ,   FALSE   ,   FALSE   },
    { "loopne"  ,   FALSE   ,   FALSE   },
    { "loopnz"  ,   FALSE   ,   FALSE   },
    { "loopz"   ,   FALSE   ,   FALSE   },
    { "ret"     ,   FALSE   ,   FALSE   },
    { "retf"    ,   FALSE   ,   FALSE   },
    { "retn"    ,   FALSE   ,   FALSE   },
    { NULL      ,   FALSE   ,   FALSE   }
};



DWORD
BranchUnassemble(
    void   *Memory,
    ADDR   *Addr,
    BOOL   *IsBranch,
    BOOL   *TargetKnown,
    BOOL   *IsCall,
    BOOL   *IsTable,
    ADDR   *Target
    )
{
    XOSD    xosd;
    DWORD   Consumed = 0;
    DWORD   i;
    int     s;
    char    *p;
    ADDR    Trgt;

    AddrInit( &Trgt, 0, 0, 0, TRUE, TRUE, FALSE, FALSE );

    *IsBranch = FALSE;
    *IsTable  = FALSE;

    Sdi.dop = dopOpcode| dopOperands | dopEA;
    Sdi.addr = *Addr;

    xosd = disasm( &Sdi, Memory, 16 );

    if ( xosd == xosdNone ) {

        *IsTable = Sdi.fJumpTable;

        for ( i=0; BranchTable[i].Name != NULL; i++ ) {

            s = strcmp( Sdi.lpch, BranchTable[i].Name );

            if ( s == 0 ) {

                *IsBranch = TRUE;
                *IsCall = BranchTable[i].IsCall;
                if (*IsTable) {
                    *Target = Sdi.addrEA0;
                    //
                    // We might know the target, but for this
                    // purpose, we don't want to deal with it.
                    //
                    *TargetKnown = FALSE;
                }
                else if (BranchTable[i].TargetAvail &&
                         (p = Sdi.lpch) &&
                         *(p += (_tcslen(p)+1)) ) {

                    Trgt = *Addr;
                    if ( ParseAddr( p, &Trgt ) ) {
                        *TargetKnown = TRUE;
                    } else {
                        AddrInit( &Trgt, 0, 0, 0, TRUE, TRUE, FALSE, FALSE );
                        *TargetKnown = FALSE;
                    }
                    *Target = Trgt;
                }
                else {
                    *Target = Trgt;
                    *TargetKnown = FALSE;
                }

                break;

            } else if ( s < 0 ) {

                break;
            }
        }

        Consumed = GetAddrOff( Sdi.addr ) - GetAddrOff(*Addr);
    }

    return Consumed;
}



BOOL
ParseAddr (
    char *szAddr,
    ADDR *Addr
    )
{

    char    *p;
    BOOL    fParsed;
    SEGMENT Segment;
    UOFF16  Off16;
    UOFF32  Off32;
    DWORD   Dword;

    assert( szAddr );
    assert( Addr );

    fParsed = FALSE;

    p = _tcschr( szAddr, ':' );

    if ( p ) {

        *p = '\0';
        p++;

        if ( ParseNumber( szAddr, &Dword, 16 ) ) {

            Segment = (SEGMENT)Dword;

            if ( ParseNumber( p, &Dword, 16 ) ) {

                Off16   = (UOFF16)Dword;
                fParsed = TRUE;

                GetAddrSeg(*Addr) = Segment;
                GetAddrOff(*Addr) = Off16;
            }
        }
    } else {

        if ( ParseNumber( szAddr, &Dword, 16 ) ) {

            Off32   = (UOFF32)Dword;
            fParsed = TRUE;

            GetAddrOff(*Addr) = Off32;
        }
    }

    return fParsed;
}


BOOL
ParseNumber (
    char  *szNumber,
    DWORD *Number,
    int    Radix
    )
{
    BOOL  fParsed = FALSE;
    char *p       = szNumber;
    char *q;

    assert( szNumber );
    assert( Number );

    if ( _tcslen(p) > 2 &&
         p[0]=='0' &&
         (p[1]=='x' || p[1]=='X') ) {

        p+=2;
        assert( Radix == 16 );
    }

    q = p;
    while ( *q && isxdigit(*q) ) {
        q++;
    }

    if ( !*q ) {
        *Number = _tcstoul( p, NULL, Radix );
        fParsed = TRUE;
    }

    return fParsed;
}

#endif // 0


#if 0
BOOL
SetupDebugRegister(
    HTHDX       hthd,
    int         Register,
    int         DataSize,
    DWORD       DataAddr,
    DWORD       BpType
    )
{
	_asm int 3
#if 0
    DWORD               Len;
    DWORD               rwMask;

#ifdef KERNEL
    KSPECIAL_REGISTERS  ksr;
    PDWORD  Dr0 = &ksr.KernelDr0;
    PDWORD  Dr1 = &ksr.KernelDr1;
    PDWORD  Dr2 = &ksr.KernelDr2;
    PDWORD  Dr3 = &ksr.KernelDr3;
    PDR7    Dr7 = (PDR7)&(ksr.KernelDr7);
#else
    CONTEXT     Context;
    PDWORD  Dr0 = &Context.Dr0;
    PDWORD  Dr1 = &Context.Dr1;
    PDWORD  Dr2 = &Context.Dr2;
    PDWORD  Dr3 = &Context.Dr3;
    PDR7    Dr7 = (PDR7)&(Context.Dr7);
#endif


#ifdef KERNEL
    if (!GetExtendedContext(hthd, &ksr))
#else
    Context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    if (!GetThreadContext(hthd->rwHand, &Context))
#endif
    {
        return FALSE;
    }


    Len  = LenMask[ DataSize ];

    switch ( BpType ) {
        case bptpDataR:
            rwMask = RWE_READWRITE;
            break;

        case bptpDataW:
        case bptpDataC:
            rwMask = RWE_WRITE;
            break;

        case bptpDataExec:
            rwMask = RWE_EXEC;
            //
            // length must be 0 for exec bp
            //
            Len = 0;
            break;

        default:
            assert(!"Invalid BpType!!");
            break;
    }


    switch( Register ) {
      case 0:
        *Dr0          = DataAddr;
        Dr7->Len0     = Len;
        Dr7->Rwe0     = rwMask;
        Dr7->L0       = 0x01;
        break;
      case 1:
        *Dr1          = DataAddr;
        Dr7->Len1     = Len;
        Dr7->Rwe1     = rwMask;
        Dr7->L1       = 0x01;
        break;
      case 2:
        *Dr2          = DataAddr;
        Dr7->Len2     = Len;
        Dr7->Rwe2     = rwMask;
        Dr7->L2       = 0x01;
        break;
      case 3:
        *Dr3          = DataAddr;
        Dr7->Len3     = Len;
        Dr7->Rwe3     = rwMask;
        Dr7->L3       = 0x01;
        break;
    }

    Dr7->LE = 0x01;

#ifdef KERNEL
    ksr.KernelDr6 = 0;
    return SetExtendedContext(hthd, &ksr);
#else
    Context.Dr6 = 0;
    return SetThreadContext(hthd->rwHand, &Context);
#endif
#endif
}

#ifndef KERNEL

VOID
ClearAllDebugRegisters(
	HPRCX hprc
	)
{
#if 0
    HTHDX    hthd;
    CONTEXT     Context;

    Context.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    /*
    ** OSDebug only supports hardware breakpoints across all threads;
    ** NT supports them on a per-thread basis.  So we just set the
    ** specified breakpoint on all currently existing threads.
    */

    for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {

		if (!(hthd->tstate & ts_dead)) {

			if (!GetThreadContext(hthd->rwHand, &Context)) {
                continue;
			}

			Context.Dr7 = 0;
            SetThreadContext(hthd->rwHand, &Context);
		}
	}
#endif
}
#endif


VOID
ClearDebugRegister(
    HTHDX   hthd,
    int     Register
    )
{
	_asm int 3
#if 0
#ifdef KERNEL
    KSPECIAL_REGISTERS  ksr;
    PDWORD  Dr0 = &ksr.KernelDr0;
    PDWORD  Dr1 = &ksr.KernelDr1;
    PDWORD  Dr2 = &ksr.KernelDr2;
    PDWORD  Dr3 = &ksr.KernelDr3;
    PDR7    Dr7 = (PDR7)&(ksr.KernelDr7);
#else
    CONTEXT     Context;
    PDWORD  Dr0 = &Context.Dr0;
    PDWORD  Dr1 = &Context.Dr1;
    PDWORD  Dr2 = &Context.Dr2;
    PDWORD  Dr3 = &Context.Dr3;
    PDR7    Dr7 = (PDR7)&(Context.Dr7);
#endif


#ifdef KERNEL
    if (GetExtendedContext(hthd, &ksr))
#else
    Context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    if (GetThreadContext(hthd->rwHand, &Context))
#endif
    {

        switch( Register ) {
          case 0:
            *Dr0          = 0;
            Dr7->Len0     = 0;
            Dr7->Rwe0     = 0;
            Dr7->L0       = 0;
            break;
          case 1:
            *Dr1          = 0;
            Dr7->Len1     = 0;
            Dr7->Rwe1     = 0;
            Dr7->L1       = 0;
            break;
          case 2:
            *Dr2          = 0;
            Dr7->Len2     = 0;
            Dr7->Rwe2     = 0;
            Dr7->L2       = 0;
            break;
          case 3:
            *Dr3          = 0;
            Dr7->Len3     = 0;
            Dr7->Rwe3     = 0;
            Dr7->L3       = 0;
            break;
        }

#ifdef KERNEL
        ksr.KernelDr6 = 0;
        SetExtendedContext(hthd, &ksr);
#else
        Context.Dr6 = 0;
        SetThreadContext( hthd->rwHand, &Context );
#endif
    }
#endif
}
#endif // 0

#ifndef KERNEL

BOOL
IsBogusWin95SSEvent(
    HTHDX           hthd,
    DEBUG_EVENT*    de,
    PDWORD          eventCode,
    PDWORD          subClass
    )
{
#if 0
    if (IsChicago () &&
        !PeeIsEventExpected(hthd, *eventCode, *subClass, FALSE)) {
        return TRUE;
    }
#endif

    return FALSE;
}

#else

BOOL
IsBogusWin95SSEvent(
    HTHDX           hthd,
    DEBUG_EVENT*    de,
    PDWORD          eventCode,
    PDWORD          subClass
    )
{
    return FALSE;
}

#endif

#if 0
BOOL
DecodeSingleStepEvent(
    HTHDX           hthd,
    DEBUG_EVENT*    de,
    PDWORD          eventCode,
    PDWORD          subClass
    )
/*++

Routine Description:


Arguments:

    hthd    - Supplies thread that has a single step exception pending

    de      - Supplies the DEBUG_EVENT structure for the exception

    eventCode - Returns the remapped debug event id

    subClass - Returns the remapped subClass id


Return Value:

    TRUE if event was a real single step or was successfully mapped
    to a breakpoint.  FALSE if a register breakpoint occurred which was
    not expected.

--*/
{
    DWORD       dr6 = 0;
    PBREAKPOINT bp;

#ifdef KERNEL

    KSPECIAL_REGISTERS ksr;

    GetExtendedContext( hthd, &ksr);
    dr6 = ksr.KernelDr6;

#else

	dr6 = 0;

#if 0 // XBUG -- fix for hardware BPs
    CONTEXT     Context;

    Context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    DbgGetThreadContext( hthd, &Context);
    dr6 = Context.Dr6;

    Context.Dr6 = 0;
    DbgSetThreadContext( hthd, &Context );
#endif
#endif

#define DR6_HARDWARE_BP_FIRED_MASK  0x0f
#define DR6_BS_FLAG                 0x4000

    //
    // NOTE: SingleStep and watchpoints/databreakpoints are NOT mutually
    // exclusive.  This means DR6 may signal that both of these events happend.
    // In this case, if the breakpoint is going to be fired, we allow the
    // databp to take precedence.  Otherwise -- if the databp is not going to
    // be fired -- we allow the step to take precedence.
    //

    //
    // Algorithm:
    //
    //  If only BS flag is set or BP_FIRED is set, then do that event.
    //  Otherwise, allow the BP_FIRED event take precedence if we check
    //  the BP and it should be fired.  This will end up ignoring the SS
    //  event, which really does not seem like a problem.
    //

    if (dr6 & DR6_HARDWARE_BP_FIRED_MASK) {

        bp = GetWalkBPFromBits (hthd, dr6 & DR6_HARDWARE_BP_FIRED_MASK);

        if (bp) {
            if (CheckDataBP (hthd, bp)) {
                de->dwDebugEventCode = *eventCode = BREAKPOINT_DEBUG_EVENT;
                *subClass = (DWORD) bp;
                de->u.Exception.ExceptionRecord.ExceptionCode = *subClass;
                return TRUE;
            } else {
                if (!(dr6 & DR6_BS_FLAG)) {
                    *eventCode = BOGUS_WIN95_SINGLESTEP_EVENT;
                    de->dwDebugEventCode = BOGUS_WIN95_SINGLESTEP_EVENT;
                    *subClass = 0;
                    de->u.Exception.ExceptionRecord.ExceptionCode = 0;
                    return TRUE;
                }
            }
        }

    }

    if (dr6 & DR6_BS_FLAG) {

        if (IsBogusWin95SSEvent (hthd, de, eventCode, subClass)) {

            // Win95 will sometimes give us totally bogus single step events
            // out of the blue. Map them to a new internal event code, so we
            // can ignore them later.

            // Win95 bogus events are not limited to true "single step" events.
            // We also get bogus events without the DR6.BS flag set.

            de->dwDebugEventCode = *eventCode = BOGUS_WIN95_SINGLESTEP_EVENT;
            de->u.Exception.ExceptionRecord.ExceptionCode = *subClass = 0;

            return TRUE;

        } else {

            //
            // Normal single step event; the event should be correct.
            
            return TRUE;
        }
    }

    //
    // Note: we often get cases where dr6 == 0.  This is a single step.
    //

    return TRUE;
}
#endif // 0





ULONGLONG
GetRegValue(
    PCONTEXT regs,
    int cvindex
    )
{
    switch (cvindex) {
        case CV_REG_EAX:
            return regs->Eax;

        case CV_REG_EBX:
            return regs->Ebx;

        case CV_REG_ECX:
            return regs->Ecx;

        case CV_REG_EDX:
            return regs->Edx;

        case CV_REG_ESP:
            return regs->Esp;

        case CV_REG_EBP:
            return regs->Ebp;

        case CV_REG_ESI:
            return regs->Esi;

        case CV_REG_EDI:
            return regs->Edi;

        case CV_REG_EIP:
            return regs->Eip;

        default:
            assert(!"GetRegValue called with unrecognized index");
            return (ULONGLONG)0 - 1;

    }
}


//----------------------------------------------------------------------------
// Code related to exception handling below.

#ifndef KERNEL


/*
 * PrnTopOfExceptionStack()
 *
 * Returns the address of the Registration Node currently at the top of the NT
 * exception stack
 */

RN *
PrnTopOfExceptionStack(
    HTHDX hthd
    )
{
    RN *        prn;
    DWORD       cb;

    // read registration node from FS:0
    if ((DbgReadMemory(hthd->hprc, (char *)hthd->offTeb + except_list,
        &prn, sizeof(prn), &cb) ==0) ||
        (cb != sizeof(prn))
    )
    {
        // 0xFFFFFFFF is the value NT uses to indicate an empty stack, so
        // that's what we'll use if the read failed
        prn = (RN FAR *) 0xFFFFFFFF;
    }

    return prn;
}


// Helper function to add an entry to the exception handler list.
// Adds the lpAddr passed in to the EXHDLR allocating new memory if
// neccessary. Returns back the count of the number of elements
// allocated in EXHDLR

BOOL
AddToExHdlr(
    EXHDLR *pExHdlr,
    ADDR *lpAddr,
    DWORD *lpdwCountAlloc
    )
{
    assert(pExHdlr);
    assert(lpAddr);
    assert(lpdwCountAlloc);

    if (pExHdlr->count == *lpdwCountAlloc) {
        (*lpdwCountAlloc) *= 2;
        MHRealloc(pExHdlr, sizeof(EXHDLR) + (*lpdwCountAlloc) * sizeof(ADDR));
        if (pExHdlr == NULL) {
            return FALSE;
        }
    } else {
        assert(pExHdlr->count < *lpdwCountAlloc);
        if (pExHdlr->count > *lpdwCountAlloc) {
            return FALSE;
        }
    }

    pExHdlr->addr[pExHdlr->count] = (*lpAddr);
    pExHdlr->count++;

    return TRUE;
}

DWORD
GetSPFromNLGDest(
    HTHDX hthd,
    LPNLG_DESTINATION pNlgDest
    )
{
        Unreferenced(hthd);
        return (pNlgDest->uoffFramePointer);
}

void *
InfoExceptionDuringStep(
    HTHDX hthd
    )
{
        // Information that needs to be propagated from the step location
        // to the action handler when an exception occurs is passed in the
        // void * returned by this function.
        return PrnTopOfExceptionStack(hthd);
}

EXHDLR *
GetExceptionCatchLocations(
    HTHDX hthd,
    LPVOID lpv
    )
{
    BOOL fFoundFinally = FALSE;     // have we found any try/finally's yet
                                    // which are not nested inside the active
                                    // function call.
    BOOL fFoundExcept = FALSE;      // have we found any try/except's
    STE             ste;
    DWORD           cb;
    SCOPE           scope;
    CHAR            rgbSig[4];      // signature, "XC00" or 0x19930520
    BYTE            rgbLH[10];      // Lang Hdlr: "mov eax, ...; jmp ..."
    FUNCINFO        funcinfo;       // C++ EH function info
    TBME            tbme;
    HT              ht;
    DWORD           itry;
    DWORD           icatch;
    INT             thunk;
    UOFFSET         uoffThunk;
    int             countAllocated = 32;    // Initial no of entries in ExHdlr.
    RN              rn;
    RN *            prn;
    RN *            prnOldTopOfStack = (RN *)lpv;
    BOOL            fInsideCall;
    ADDR            addr = {0};
    HPRCX           hprc = hthd->hprc;
    EXHDLR *        pExHdlr;

    pExHdlr = (EXHDLR *)MHAlloc(sizeof(EXHDLR) + countAllocated * sizeof(ADDR));
    pExHdlr->count = 0;  // None allocated yet.

    if (pExHdlr == NULL) {
        return NULL;
    }

    // initialize pieces of the addr correctly.
    AddrFromHthdx(&addr, hthd);

    prn = PrnTopOfExceptionStack(hthd);

    if (prnOldTopOfStack) {
            fInsideCall = TRUE;
    } else {
            fInsideCall = FALSE;
    }

    // Walk through all active registration nodes

    while ( ( prn != NULL ) && ( prn != (RN FAR *)0xFFFFFFFF ) ) {

        //
        // Remember if the registration node we've just reached is equal to
        // the old top of stack.
        //
        if (prn == prnOldTopOfStack) {
            fInsideCall = FALSE;
        }

        //
        // Read the registration node
        //

        if (!DbgReadMemory(hprc, prn, &rn, sizeof(rn), &cb)) {
            assert(FALSE); // this can only happen if exception list is bogus!
            break;
        }

        //
        // If lpfnLanguageHandler actually points to a thunk, figure out
        // where the thunk points
        //
        IsThunk(hthd, (ULONG) rn.lpfnLanguageHandler, &thunk, &uoffThunk, NULL);

        if (thunk != THUNK_NONE) {
            rn.lpfnLanguageHandler = (LPFN) uoffThunk;
        }

        //
        // The code below assumes that the implementation-dependent part of
        // the Registration Node matches the Microsoft C format.  To make
        // sure this is the case, we check for a special signature.  There
        // are two formats supported:
        //
        // (1)  SEH format: check for signature in front of the
        //              lpfnLanguageHandler.  In the C runtime,
        //              _except_handler2() is immediately preceeded by the
        //              bytes "XC00".
        // (2)  C++ EH format: the lpfnLanguageHandler points to:
        //                      mov eax, offset FuncInfo
        //                      jmp __CxxFrameHandler
        //              The FuncInfo structure begins with a magic number
        //              which consists of the number 0x19930520.
        //
        // If neither of these signatures is present, the node must have
        // been created either by assembly code or by some language product
        // other than Microsoft C, so we will skip over this registration
        // node since we don't know its format.
        //
        if (
            // lpfnLanguageHandler points to SEH handler?
            DbgReadMemory(hprc,
                    (LPVOID) ((ULONG)rn.lpfnLanguageHandler - sizeof(rgbSig)),
                    rgbSig, sizeof(rgbSig), &cb)
            &&
            (memcmp(rgbSig, "XC00", sizeof(rgbSig)) == 0)
           )
        {
            // Walk through all active scope table entries

            for (scope=rn.scopeCur; scope != scopeNil; scope=ste.scopeEnclosing) {
                // Read the scopetable entry (UNDONE: we're reading lots of
                // tiny chunks which are also close to each other -- we could
                // optimize this!)

                if (!DbgReadMemory(hprc,
                        (LPVOID)(rn.rgste + scope*sizeof(STE)), &ste, sizeof(ste),
                        &cb))
                {
                    // this can only happen if scope list is bogus!
                    assert(FALSE);
                    break;
                }

                // Set a breakpoint if this is a try/except or the first
                // try/finally which is not nested inside the function
                // call that we're stepping over

                if (ste.lpfnFilter || (!fFoundFinally && !fInsideCall)) {
                    // Set a breakpoint at the address of the handler

                    GetAddrOff( addr ) = (UOFFSET) ste.lpfnHandler;

                    // We are not interested in stopping if this is a nested
                    // handler
                    if (!fInsideCall) {
                        if (!AddToExHdlr(pExHdlr, &addr, &countAllocated)) {
                            break;
                        }
                    }
                }

                if (ste.lpfnFilter == NULL) {
                    fFoundFinally = TRUE;
                } else {
                    fFoundExcept = TRUE;
                }
            }
        }
        else
        if (
            // lpfnLanguageHandler points to C++ EH handler?
            DbgReadMemory(hprc,
                rn.lpfnLanguageHandler, rgbLH, sizeof(rgbLH), &cb)
            &&
            rgbLH[0] == 0xB8 &&             // "mov eax, ..."
            rgbLH[5] == 0xE9 &&             // "jmp ..."
            DbgReadMemory(hprc,
                *(LPVOID*)(rgbLH+1), &funcinfo, sizeof(funcinfo), &cb)
            &&
            funcinfo.dwMagic == 0x19930520
           ) {
            for (itry = 0; itry < funcinfo.dwTryBlocks; ++itry) {
                if (DbgReadMemory(hprc,
                                      funcinfo.ptbme + itry,
                                      &tbme,
                                      sizeof(tbme),
                                      &cb)
                ) {
                    for (icatch = 0; icatch < tbme.dwCatches; ++icatch) {
                        if (DbgReadMemory(hprc,
                                              tbme.pht + icatch,
                                              &ht,
                                              sizeof(ht),
                                              &cb)
                        ) {
                            // Set a breakpoint
                            GetAddrOff( addr ) = (UOFFSET) ht.lpfnCatch;

                            // We are not interested in stopping if this is a nested
                            // handler
                            if (!fInsideCall) {
                                if (!AddToExHdlr(pExHdlr, &addr, &countAllocated)) {
                                    break;
                                }
                            }

                            fFoundExcept = TRUE;
                        }
                    }
                }
            }
        }
        // Move to next registration node in chain

        prn = rn.prnNext;
    }

    // Now that we have the whole list, we should
    return pExHdlr;
}


BOOL
GetWndProcMessage(
    HTHDX   hthd,
    UINT*   pmsg
    )
/*++

Routine Description:

    This function is used to get the current Windows message (WM_CREATE, etc)
    from the stack. You must be at the first instruction of the WndProc and
    that instruction must be unexecuted.

Return Value:

    False on failure; True otherwise.

--*/
{

    ADDR    addr;
    BOOL    succ;
    ULONG   cbRead;

    AddrInit (&addr, 0, PcSegOfHthdx (hthd), STACK_POINTER (hthd) + 8,
              hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal);


    succ = AddrReadMemory (hthd->hprc, hthd, &addr, pmsg, 4, &cbRead);

    if (succ && cbRead == 4) {
        return TRUE;
    }

    return FALSE;
}


BOOL
GetSinglePVOIDArgument(
	HTHDX	hthd,
	PVOID*	Argument
	)
/*++

Routine Description:

	Given that we are sitting on a CALL instruction, and that the function
	is a stdcall function taking exactly one PVOID argument, retrieve that
	argument.

--*/
{
	//
	// Read the this pointer from the current ESP.
	//
	
	
	return DbgReadMemory (hthd->hprc,
						  (LPVOID) STACK_POINTER (hthd),
						  Argument,
						  sizeof (PVOID),
						  NULL);
}

BOOL
GetDoublePVOIDArgument(
	HTHDX	hthd,
	DWORD*	Argument1,
	DWORD*	Argument2
	)
/*++

Routine Description:

	Same as GetSinglePVOIDArgument except that for a function taking exactly
	two PVOID arguments.

--*/
{
	BOOL	fSucc = FALSE;
	
	fSucc = DbgReadMemory (hthd->hprc,
						  (LPVOID) STACK_POINTER (hthd),
						  Argument2,
						  sizeof (PVOID),
						  NULL);

	if (fSucc) {

		fSucc = DbgReadMemory (hthd->hprc,
							  (LPVOID) (STACK_POINTER (hthd) + sizeof (PVOID)),
							  Argument1,
							  sizeof (PVOID),
							  NULL);
	}

	return fSucc;
}


#endif // !KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\funccall.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    funccall.h

Abstract:

    Contains the types and protypes for funccall.c

Author:

    Jim Schaad (jimsch) 05-06-92

Environment:

    Win32 - User

--*/

/*
 *
 */

typedef struct _EXECUTE_OBJECT_DM {
    ADDR        addrStart;      /* Starting address of function call     */
    ADDR        addrStack;      /* Starting stack offset                 */
    CONTEXT     ctxSav;
    BOOL        fIgnoreEvents;  /* Ignore events during execution        */
    HTHDX       hthd;           /* Thread for evaluating fucntion        */
    BREAKPOINT * lpbp;          /* Pointer to breakpoint at starting addres */
    BREAKPOINT * pbpSave;       /* Breakpoint thread is on at start     */
    int         tmp;
} EXECUTE_OBJECT_DM;

typedef EXECUTE_OBJECT_DM FAR * LPEXECUTE_OBJECT_DM;

/**********************************************************************/

extern  VOID    ProcessSetupExecuteCmd(HPRCX, HTHDX, LPDBB);
extern  VOID    ProcessStartExecuteCmd(HPRCX, HTHDX, LPDBB);
extern  VOID    ProcessCleanUpExecuteCmd(HPRCX, HTHDX, LPDBB);
extern  VOID    EvntException(DEBUG_EVENT *, HTHDX);
extern  VOID    EvntExitProcess(DEBUG_EVENT *, HTHDX);
extern  VOID    EvntBreakpoint(DEBUG_EVENT *, HTHDX);

extern  XOSD    SetupFunctionCall(LPEXECUTE_OBJECT_DM, LPEXECUTE_STRUCT);
extern  BOOL    CompareStacks(LPEXECUTE_OBJECT_DM);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\i386excp.h ===
// This file holds the x86 specific exception stack info definitions. 

#ifndef KERNEL

#if defined(TARGET_i386)

//----------------------------------------------------------------------
// Exception list types
//
// All types described in this section relate to the list of exception
// handlers that is maintained by the operating system.  For more SEH
// information, see "N386 Structured Exception Handling Specification"
// (N386-SEH.DOC).  The C++ EH types are derived from types in the C
// runtime's h\ehdata.h (currently on \\hobie\c32rw\src\crtwin32).
//----------------------------------------------------------------------

typedef long SCOPE;				// exception scope: index into a scopetable
#define scopeNil ((SCOPE)-1)

typedef VOID (FAR *LPFN)(VOID);

// The STE (scopetable element) type is one element in a scopetable; it
// defines one try/except or try/finally block.  The scopeEnclosing field
// is an index to the try/except or try/finally block that encloses this
// one *within the same function*.

typedef struct STE			// scopetable element
{
	SCOPE	scopeEnclosing;	// index of the scope that encloses one within
							//   this same scopetable, or scopeNil if none
	LPFN	lpfnFilter;		// filter function (returns -1, 0, or 1)
	LPFN	lpfnHandler;	// ptr to except block (if lpfnFilter != NULL)
							//   or finally block (if lpfnFilter == NULL)
} STE;

// The RN (registration node) type is what is pointed to by the except_list in
// the TEB.  In the MSC implementation, there is one registration node for
// each active function which contains any try/except or try/finally blocks.
// The RN is added to the list at function entry, and removed at function exit;
// thus, it will be in the list whether or not there are currently any active
// handlers from this function.

typedef struct RN					// registration node
{
	// fields that are valid for all implementations

	struct RN FAR *	prnNext;			// next registration node in chain
	LPFN			lpfnLanguageHandler;// points to CRT's _except_handler2()

	// language/implementation specific fields (these are what MSC uses)

	UOFFSET			rgste;				// ptr to scopetable (array of STEs)
										//   (type==ULONG for Win32s ptr arith)
	SCOPE			scopeCur;			// currently active scope for this node
	DWORD			ebp;				// this function's EBP register value

} RN;

// _except_list is an extern of type Absolute, which specifies the offset
// within the TEB of a thread's exception list.  The DWORD at this
// location is actually an "RN *", which points to the first registration
// node on the exception stack.
//
// To obtain its value from a C file, we have to use this little trick of
// pretending it's an integer, and then taking the address of the integer.

extern int FAR _except_list;
#define     except_list   ((UOFFSET)&_except_list)

//----------------------------------------------------------------------

// C++ EH types

typedef struct HT		// Handler Type
{
	DWORD	dwFlags;		// misc. flags
	LPVOID	pType;			// pointer to type descriptor
	DWORD	dwDispCatchObj;	// displacement of catch obj from base of current
							// stack frame
	LPFN	lpfnCatch;		// the interesting part: addr of the catch itself
} HT;

typedef struct TBME		// Try Block Map Entry
{
	DWORD	dwTryLow;		// lowest state index of try
	DWORD	dwTryHigh;		// highest state index of try
	DWORD	dwCatchHigh;	// highest state index of any associated catch
	DWORD	dwCatches;		// number of entries in array
	HT FAR *pht;			// list of handlers for this try
} TBME;

typedef struct FUNCINFO	// Function Info, one per function with C++ EH
{
	DWORD		dwMagic;		// magic number, should be 0x19930520
	DWORD		dwMaxState;		// highest state number plus one (thus
								// the number of entries in the unwind map)
	VOID FAR *	pume;			// where the unwind map is
	DWORD		dwTryBlocks;	// number of 'try' blocks in this function
	TBME FAR *	ptbme;			// where the handler map is
	// ... more stuff we don't care about ...
} FUNCINFO;

//----------------------------------------------------------------------

#endif // TARGET_i386

#endif // !KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\list.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\lp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tllp.h

Abstract:

	Simple wrapper classes for events and mutexes.

Author:

	Matthew Hendel (math)
	
--*/


#ifndef _TLLP_H_
#define _TLLP_H_

#ifdef __cplusplus

#define DEBUG_DEADLOCK_TIMEOUT	INFINITE  // 90 * 1000		// 90 sec

class TEvent
{
	HANDLE	m_Event;

  public:

	TEvent(
		)
	{
		m_Event = NULL;
	}

	~TEvent(
		)
	{
		Close ();
	}

	BOOL
	Create(
		LPSECURITY_ATTRIBUTES	lpEventAttributes = NULL,
	    BOOL					fManualReset = FALSE,
	    BOOL					fInitialState = FALSE,
	    LPCTSTR					lpName = NULL
	    )
	{
		m_Event = CreateEvent (lpEventAttributes, fManualReset, fInitialState,
							   lpName);

		return (m_Event != NULL);
	}

	BOOL
	Open(
		ULONG	dwAccess,
		BOOL	fInheritHandles,
		LPCTSTR	lpName
		)
	{
		assert (!m_Event);
		m_Event = OpenEvent (dwAccess, fInheritHandles, lpName);

		return (m_Event != NULL);
	}

	BOOL
	Close(
		)
	{
		BOOL	fSucc = CloseHandle (m_Event);
		m_Event = NULL;

		return fSucc;
	}

	ULONG
	Wait(
		ULONG	TimeOut = INFINITE
		);

	BOOL
	Set(
		)
	{
		assert (m_Event);
		return SetEvent (m_Event);
	}

	BOOL
	Pulse(
		)
	{
		assert (m_Event);
		return PulseEvent (m_Event);
	}

	BOOL
	Reset(
		)
	{
		assert (m_Event);
		return ResetEvent (m_Event);
	}

};


class TMutex
{
	HANDLE	m_hMutex;

  public:

	TMutex(
		)
	{
		m_hMutex = NULL;
	}

	~TMutex(
		)
	{
		Close ();
	}

	BOOL
	Create(
		LPSECURITY_ATTRIBUTES	lpMutexAttributes = NULL,
		BOOL					fInitialOwner = FALSE,
		LPCTSTR					lpName = NULL
		)
	{
		assert (m_hMutex == NULL);

		m_hMutex = CreateMutex (lpMutexAttributes, fInitialOwner, lpName);

		return (m_hMutex != NULL);
	}
		

	BOOL
	Open(
		ULONG	DesiredAccess,
		BOOL	fInheritHandles,
		LPCTSTR	lpName
		)
	{
		m_hMutex = OpenMutex (DesiredAccess, fInheritHandles, lpName);

		return (m_hMutex != NULL);
	}

	BOOL
	Close(
		)
	{
		BOOL	fSucc = CloseHandle (m_hMutex);
		m_hMutex = NULL;

		return fSucc;
	}
		
	ULONG
	Wait(
		ULONG	TimeOut = INFINITE
		);

	BOOL
	Release(
		)
	{
		return ReleaseMutex (m_hMutex);
	}

};

extern "C"
#endif // __cplusplus

BOOL WINAPI TlDllMain(HINSTANCE, DWORD, DWORD);

#endif // _TLLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\lp.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tllp.c

Abstract:

    This implements the local transport layer for OSDebug versions
    2 and 4 on Win32.

Author:

    Jim Schaad (jimsch)
    Kent Forschmiedt (kentf)


--*/
#ifdef WIN32
#include <windows.h>
#endif

#include <stdlib.h>

#include <string.h>
#include <memory.h>



#include "odtypes.h"
#include "od.h"
#include "odp.h"
#include "odassert.h"
#include "emdm.h"

extern "C" LPDBF lpdbf = (LPDBF)0;         // the debugger helper functions

#include "tllp.h"
#include "tlutil.h"
#include <xboxdbg.h>
#include "resource.h"

extern "C" extern HINSTANCE hInstance;

#include "dbgver.h"
extern AVS Avs;

#ifndef CVWS
int _acrtused = 0;
#endif

int fReplyDM = FALSE;
int fReplyEM = FALSE;

HANDLE hevtReboot;
PDMN_SESSION psessTl;

char szLastError[512];

DWORD TlNotify(DWORD dwNotification, DWORD dwParam)
{
	if((dwNotification & DM_NOTIFICATIONMASK) == DM_EXEC)
		if(dwParam == DMN_EXEC_REBOOT)
			ResetEvent(hevtReboot);
		else
			SetEvent(hevtReboot);
	return 0;
}

#if DBG

ULONG
TEvent::Wait(
	ULONG	TimeOut	// = INFINITE
	)
/*++

Routine Description:

	Wait for the event to be signaled.  In the debug version, we do some
	deadlock checking (when waiting forever).  If we wait for longer than
	DEBUG_DEADLOCK_TIMEOUT we will assert.

--*/
{
	ULONG	ret;
	
	if (TimeOut == INFINITE)
	{
		ret = WaitForSingleObject (m_Event, DEBUG_DEADLOCK_TIMEOUT);

		assert (ret == WAIT_OBJECT_0);
	}

	return ret;
}


ULONG
TMutex::Wait(
	ULONG	TimeOut // = INFINITE
	)
/*++

Routine Description:

	See comments under TEvent::Wait ().

--*/
{
	ULONG	ret;

	if (TimeOut == INFINITE)
	{
		ret = WaitForSingleObject (m_hMutex, DEBUG_DEADLOCK_TIMEOUT);

		assert (ret == WAIT_OBJECT_0);
	}

	return ret;
}

#else

ULONG
TEvent::Wait(
	ULONG	TimeOut // = INFINITE
	)
{
	return WaitForSingleObject (m_Event, TimeOut);
}

ULONG
TMutex::Wait(
	ULONG	TimeOut // = INFINITE
	)
{
	return WaitForSingleObject (m_hMutex, TimeOut);
}

#endif

// debug monitor function definitions.

extern "C" {
void FAR PASCAL LOADDS DMInit (DMTLFUNCTYPE, LPVOID);
XOSD FAR PASCAL LOADDS TLFunc ( TLF, HPID, LPARAM, LPARAM);
XOSD FAR PASCAL LOADDS DMTLFunc ( TLF, HPID, LPARAM, LPARAM);
BOOL FAR PASCAL LOADDS DmDllInit (LPDBF);
VOID FAR PASCAL LOADDS DMFunc (DWORD, LPDBB);
}

LOCAL TLCALLBACKTYPE TLCallBack;    // central osdebug callback function

TEvent*	DmReplyEvent = NULL;
TMutex*	DmRequestMutex = NULL;
TEvent*	EmReplyEvent = NULL;
TMutex*	EmRequestMutex = NULL;


// these variables are static to prevent collisions with other TL's

static BOOL fConDM = FALSE;
static BOOL fConEM = FALSE;
static BOOL fConnected = FALSE;

static LPBYTE  	lpbDM;
static LONG 	ibMaxDM;
static DWORD	ibDM;

static LPBYTE 	lpbEM;
static LONG		ibMaxEM;
static DWORD	ibEM;


TLIS Tlis = {
    FALSE,                // fCanSetup
    0xffffffff,           // dwMaxPacket
    0xffffffff,           // dwOptPacket
    TLISINFOSIZE,         // dwInfoSize ?? what is this for ??
    FALSE,                // fRemote
#if defined(_M_IX86)
    mptix86,              // mpt
    mptix86,              // mptRemote
#elif defined(_M_MRX000)
    mptmips,              // mpt
    mptmips,              // mptRemote
#elif defined(_M_ALPHA)
    mptdaxp,              // mpt
    mptdaxp,              // mptRemote
#else
#error( "unknown target machine" );
#endif
    {  "Local Transport Layer (LOCAL:)" } // rgchInfo
};



/**** DBGVersionCheck                                                   ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *                                                                         *
 *      To export our version information to the debugger.                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *      NONE.                                                              *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Returns - A pointer to the standard version information.           *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *      Just returns a pointer to a static structure.                      *
 *                                                                         *
 ***************************************************************************/

#ifdef DEBUGVER
DEBUG_VERSION('T','L',"TCP/IP Xbox Transport Layer (Debug)")
#else
RELEASE_VERSION('T','L',"TCP/IP Xbox Transport Layer")
#endif

DBGVERSIONCHECK()



BOOL
DllVersionMatch(
    HANDLE hMod,
    LPSTR pType
    )
{
    DBGVERSIONPROC  pVerProc;
    LPAVS           pavs;

    pVerProc = (DBGVERSIONPROC)GetProcAddress((HINSTANCE)hMod, DBGVERSIONPROCNAME);
    if (!pVerProc) {
        return(FALSE);  // no version entry point
    } else {
        pavs = (*pVerProc)();

        if ((pType[0] != pavs->rgchType[0] || pType[1] != pavs->rgchType[1]) ||
          (Avs.iApiVer != pavs->iApiVer) ||
          (Avs.iApiSubVer != pavs->iApiSubVer)) {
            return(FALSE);
        }
    }

    return(TRUE);
}



XOSD
WINAPI
TLFunc (
    TLF		wCommand,
    HPID	hpid,
    LPARAM	wParam,
    LPARAM	lParam
    )

/*++

Routine Description:

    This function contains the dispatch loop for commands comming into
    the transport layer.  The address of this procedure is exported to
    users of the DLL.

Arguments:

    wCommand    - Supplies the command to be executed.
    hpid        - Supplies the hpid for which the command is to be executed.
    wParam      - Supplies information about the command.
    lParam      - Supplies information about the command.

Return Value:

    XOSD error code.  xosdNone means that no errors occured.  Other error
    codes are defined in osdebug\include\od.h.

--*/

{
    XOSD xosd = xosdNone;

    Unreferenced( hpid );

    switch ( wCommand ) {

    case tlfInit:

        lpdbf = (LPDBF) wParam;
        TLCallBack = (TLCALLBACKTYPE) lParam;
        xosd = xosdNone;
        break;

    case tlfLoadDM:

        if (DmDllInit(lpdbf) == FALSE) {
            xosd = xosdUnknown;
            break;
        }

        DMInit (DMTLFunc, (LPVOID) ((LPLOADDMSTRUCT)lParam)->lpDmParams);

        break;

    case tlfDestroy:
        break;

    case tlfGetProc:
        *((TLFUNCTYPE FAR *) lParam) = TLFunc;
        break;

    case tlfConnect:
		/* Make sure we can connect to the Xbox */
		{
			HRESULT hr;
			char szHostName[256];


			if(GetHostName(mptUnknown, szHostName, sizeof szHostName,
					lpdbf->lpfnGetSet))
				DmSetXboxName(szHostName);
			DmUseSharedConnection(TRUE);
			/* Get a couple of things squared away */
			if(!hevtReboot)
				hevtReboot = CreateEvent(NULL, TRUE, FALSE, NULL);
			if(!psessTl)
                /* Pass in the secret VC flag to avoid leaks */
				hr = DmOpenNotificationSession(DM_PERSISTENT | 0x20000,
                    &psessTl);
			else
				hr = XBDM_NOERR;
			if(SUCCEEDED(hr))
				hr = DmNotify(psessTl, DM_EXEC, TlNotify);
			if(FAILED(hr))
			{
				hr = DmTranslateError(hr, szLastError, sizeof(szLastError));
                if(FAILED(hr) && hr != XBDM_NOERRORSTRING)
                {
                    szLastError[0]=0;
                }
				
				xosd = xosdGeneral;
				break;
			}
			/* If a reboot in progress, wait until it's complete */
			if(WaitForSingleObject(hevtReboot, 120000) == WAIT_TIMEOUT) {
				if(!LoadString(hInstance, IDS_ERR_BOOTTIMEOUT, szLastError,
						sizeof szLastError))
					szLastError[0] = 0;
				xosd = xosdGeneral;
				break;
			}
		}

        fConEM = TRUE;
        fConnected = fConDM;
        break;

    case tlfDisconnect:
		/* You'd think we need to close our notification session here -- or
		 * in DLL_PROCESS_DETACH -- but VC unloads and reloads the tl every
		 * time a new connection is initiated, and we need to keep persistent
		 * notifications alive.  Instead, we just disconnect the tl's
		 * notification functions and keep the session open (which means the
		 * notifier's resources will stay around forever, though this is
		 * apparently not anathema to the VC resource usage scheme) */
        DmNotify(psessTl, DM_NONE, NULL);
        DmUseSharedConnection(FALSE);

        fConDM = fConnected = FALSE;
        break;

	case tlfGetLastError:
		strncpy((char *)lParam, szLastError, wParam);
		break;

    case tlfSetBuffer:

        lpbDM = (LPBYTE) lParam;
        ibMaxDM = wParam;
        break;

    case tlfReply:

        if (!fConnected)
		{
			xosd = xosdLineNotConnected;
        }
		else
		{
            if (wParam <= ibMaxEM)
			{
                _fmemcpy ( lpbEM, (LPBYTE) lParam, wParam );
                ibEM = wParam;
            }
			else
			{
                ibEM = 0;
                xosd = xosdInvalidParameter;
            }

			EmReplyEvent->Set ();
        }
        break;


    case tlfDebugPacket:

        if ( !fConnected )
		{
            xosd = xosdLineNotConnected;
        }
        else
		{
            DMFunc ( wParam, (LPDBB) lParam );
        }
        break;

    case tlfRequest:

        if ( !fConnected )
		{
			xosd = xosdLineNotConnected;
        }
		else
		{
			EmRequestMutex->Wait ();
            ibDM = 0;
			DMFunc (wParam, (LPDBB) lParam);
			DmReplyEvent->Wait ();
			EmRequestMutex->Release ();

		}
        break;

    case tlfGetVersion:     // don't need to do remote version check
        *((AVS*)lParam) = Avs;
        xosd = xosdNotRemote;
        break;


    case tlfGetInfo:

        _fmemcpy((LPTLIS)lParam, &Tlis, sizeof(TLIS));
        break;

    case tlfSetup:
        break;

    default:

        assert ( FALSE );
        break;
    }

    return xosd;
}                               /* TLFunc() */

//
// DMTLFunc is what the debug monitor will call when it has something
// to do.
//

XOSD
WINAPI
DMTLFunc (
    TLF 	wCommand,
    HPID	hpid,
    LPARAM	wParam,
    LPARAM	lParam
    )
{
    XOSD xosd = xosdNone;

    switch ( wCommand ) {

        case tlfInit:

            break;

        case tlfDestroy:

            break;

        case tlfConnect:

            fConDM = TRUE;
            fConnected = fConEM;
            break;

        case tlfDisconnect:

            fConEM = fConnected = FALSE;
            break;

        case tlfSetBuffer:

            lpbEM = (LPBYTE) lParam;
            ibMaxEM = wParam;
            break;

        case tlfReply:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
             }
			 else
			 {
                if ( wParam <= ibMaxDM )
				{
                    ibDM = wParam;
                    _fmemcpy ( lpbDM, (LPBYTE) lParam, wParam );
                }
				else
				{
                    ibDM = 0;
                }

				DmReplyEvent->Set ();
				
            }
            break;

        case tlfDebugPacket:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
            }
			else
			{
                TLCallBack ( hpid, wParam, lParam );
            }
            break;

        case tlfRequest:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
            }
			else
			{

				DmRequestMutex->Wait ();
                TLCallBack (hpid, wParam, lParam );
				EmReplyEvent->Wait ();
				DmRequestMutex->Release ();

                if (ibEM == 0)
				{
                    xosd = xosdInvalidParameter;
                }
            }
            break;

        default:

            assert ( FALSE );
            break;
    }

    return xosd;

}

extern "C"
int
WINAPI
TlDllMain(
    HINSTANCE	hModule,
    DWORD 		dwReason,
    DWORD 		dwReserved
    )
{
	switch (dwReason)
	{
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
                break;

        case DLL_PROCESS_ATTACH:

			DisableThreadLibraryCalls (hModule);

			DmReplyEvent = new TEvent;
			DmReplyEvent->Create ();
			
			DmRequestMutex = new TMutex;
			DmRequestMutex->Create ();
			
			EmReplyEvent = new TEvent ;
			EmReplyEvent->Create ();
			
			EmRequestMutex = new TMutex;
			EmRequestMutex->Create ();
			
            break;

        case DLL_PROCESS_DETACH:

			delete DmReplyEvent;
			delete DmRequestMutex;
			delete EmReplyEvent;
			delete EmRequestMutex;
            break;
    }
		
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tllp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tllp.h

Abstract:

	Simple wrapper classes for events and mutexes.

Author:

	Matthew Hendel (math)
	
--*/


#ifndef _TLLP_H_
#define _TLLP_H_

#ifdef __cplusplus

#define DEBUG_DEADLOCK_TIMEOUT	INFINITE  // 90 * 1000		// 90 sec

class TEvent
{
	HANDLE	m_Event;

  public:

	TEvent(
		)
	{
		m_Event = NULL;
	}

	~TEvent(
		)
	{
		Close ();
	}

	BOOL
	Create(
		LPSECURITY_ATTRIBUTES	lpEventAttributes = NULL,
	    BOOL					fManualReset = FALSE,
	    BOOL					fInitialState = FALSE,
	    LPCTSTR					lpName = NULL
	    )
	{
		m_Event = CreateEvent (lpEventAttributes, fManualReset, fInitialState,
							   lpName);

		return (m_Event != NULL);
	}

	BOOL
	Open(
		ULONG	dwAccess,
		BOOL	fInheritHandles,
		LPCTSTR	lpName
		)
	{
		assert (!m_Event);
		m_Event = OpenEvent (dwAccess, fInheritHandles, lpName);

		return (m_Event != NULL);
	}

	BOOL
	Close(
		)
	{
		BOOL	fSucc = CloseHandle (m_Event);
		m_Event = NULL;

		return fSucc;
	}

	ULONG
	Wait(
		ULONG	TimeOut = INFINITE
		);

	BOOL
	Set(
		)
	{
		assert (m_Event);
		return SetEvent (m_Event);
	}

	BOOL
	Pulse(
		)
	{
		assert (m_Event);
		return PulseEvent (m_Event);
	}

	BOOL
	Reset(
		)
	{
		assert (m_Event);
		return ResetEvent (m_Event);
	}

};


class TMutex
{
	HANDLE	m_hMutex;

  public:

	TMutex(
		)
	{
		m_hMutex = NULL;
	}

	~TMutex(
		)
	{
		Close ();
	}

	BOOL
	Create(
		LPSECURITY_ATTRIBUTES	lpMutexAttributes = NULL,
		BOOL					fInitialOwner = FALSE,
		LPCTSTR					lpName = NULL
		)
	{
		assert (m_hMutex == NULL);

		m_hMutex = CreateMutex (lpMutexAttributes, fInitialOwner, lpName);

		return (m_hMutex != NULL);
	}
		

	BOOL
	Open(
		ULONG	DesiredAccess,
		BOOL	fInheritHandles,
		LPCTSTR	lpName
		)
	{
		m_hMutex = OpenMutex (DesiredAccess, fInheritHandles, lpName);

		return (m_hMutex != NULL);
	}

	BOOL
	Close(
		)
	{
		BOOL	fSucc = CloseHandle (m_hMutex);
		m_hMutex = NULL;

		return fSucc;
	}
		
	ULONG
	Wait(
		ULONG	TimeOut = INFINITE
		);

	BOOL
	Release(
		)
	{
		return ReleaseMutex (m_hMutex);
	}

};

extern "C"
#endif // __cplusplus

BOOL WINAPI TlDllMain(HINSTANCE, DWORD, DWORD);

#endif // _TLLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\rescommon.h ===
#define IDS_ASSERT_ARI      512
#define IDS_ASSERT_TITLE    513
#define IDS_RIP             514
#define IDS_ATTACH          515
#define IDS_XBOX_TITLE      516
#define IDS_UNKNOWN_XBE     517
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\procem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    procem.c

Abstract:


Author:


Environment:

    NT 3.1

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if 0
#ifndef KERNEL
#include <crash.h>
extern BOOL CrashDump;
#endif
#include "dmsql.h"
#endif

#include "vcexcept.h"

SetFile()


extern DEBUG_ACTIVE_STRUCT DebugActiveStruct;
extern PKILLSTRUCT KillQueue;
extern CRITICAL_SECTION csKillQueue;

extern WT_STRUCT WtStruct;

extern EXPECTED_EVENT   masterEE, *eeList;

extern HTHDX        thdList;
extern HPRCX        prcList;
extern CRITICAL_SECTION csThreadProcList;

extern DEBUG_EVENT  falseSSEvent;
extern METHOD       EMNotifyMethod;

extern CRITICAL_SECTION csProcessDebugEvent;
extern HANDLE hEventCreateProcess;
extern HANDLE hEventNoDebuggee;
extern HANDLE hDmPollThread;
extern HANDLE hEventRemoteQuit;
extern HANDLE hEventContinue;

extern LPDM_MSG     LpDmMsg;
extern BYTE abEMReplyBuf[];

extern HPID         hpidRoot;
extern BOOL         fUseRoot;
extern BOOL         fDisconnected;

extern DMTLFUNCTYPE        DmTlFunc;

//extern SYSTEM_INFO  SystemInfo;

extern char       nameBuffer[];
VOID
MethodContinueSS(
    DEBUG_EVENT*,
    HTHDX,
    DWORD,
    METHOD*
    );

BOOL
MakeThreadSuspendItself(
     HTHDX
     );

VOID
ProcessIoctlGenericCmd(
    HPRCX   hprc,
    HTHDX   hthd,
    LPDBB   lpdbb
    );

VOID
ProcessIoctlCustomCmd(
    HPRCX   hprc,
    HTHDX   hthd,
    LPDBB   lpdbb
    );

XOSD
GetThreadSuspendCount(
        HTHDX hthd,
        LPDWORD lpdwSuspendCount
        );

#ifdef KERNEL
extern BOOL       DmKdBreakIn;
#endif

#if 0
#if 0
BOOL    fSmartRangeStep = TRUE;
#else
BOOL    fSmartRangeStep = FALSE;
#endif
#endif


void
ActionRemoveBP(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    BREAKPOINT* bp
    )
{
    Unreferenced( de );
    Unreferenced( hthd );

    RemoveBP(bp);
}




VOID
ProcessCreateProcessCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    Create a process requested by the EM.

Arguments:

    hprc   -

    hthd   -

    lpdbb  -

Return Value:

    None.

--*/

{
    XOSD       xosd = xosdNone;

    Unreferenced( hprc );
    Unreferenced( hthd );

    DEBUG_PRINT_2(
        "ProcessCreateProcessCmd called with HPID=%d, (sizeof(HPID)=%d)",
        lpdbb->hpid, sizeof(HPID));

    hpidRoot = lpdbb->hpid;
    fUseRoot = TRUE;

    Reply(0, &xosd, lpdbb->hpid);

    return;
}                               /* ProcessCreateProcessCmd() */

DWORD
ProcessProcStatCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    LPPST lppst = (LPPST)LpDmMsg->rgb;

    Unreferenced( lpdbb );

    DEBUG_PRINT("ProcessProcStatCmd\n");

    lppst->dwProcessID = hprc->pid;
    sprintf(lppst->rgchProcessID, "%5d", hprc->pid);

    /*
     *  Check if any of this process's threads are running
     */

    if (hprc->pstate & ps_exited) {
        lppst->dwProcessState = pstExited;
        _tcscpy(lppst->rgchProcessState, "Exited");
    } else if (hprc->pstate & ps_dead) {
        lppst->dwProcessState = pstDead;
        _tcscpy(lppst->rgchProcessState, "Dead");
    } else {
        lppst->dwProcessState = pstRunning;
        _tcscpy(lppst->rgchProcessState, "Running");

        EnterCriticalSection(&csThreadProcList);
        for (hthd = (HTHDX)hprc->hthdChild;hthd;hthd=hthd->nextSibling) {
            if (hthd->tstate & ts_stopped) {
                lppst->dwProcessState = pstStopped;
                _tcscpy(lppst->rgchProcessState, "Stopped");
                break;
            }
        }
        LeaveCriticalSection(&csThreadProcList);
    }

    return sizeof(PST);
}

XOSD
GetThreadSuspendCount(
        HTHDX hthd,
        LPDWORD lpdwSuspendCount
        )
{
	XOSD xosd = xosdNone;
	DM_THREADINFO dmti;

	assert(lpdwSuspendCount);
	assert(hthd != NULL);

	if(FAILED(DmGetThreadInfo(hthd->tid, &dmti)))
		xosd = xosdBadThread;
	else
		dmti.SuspendCount = 0;

	*lpdwSuspendCount = dmti.SuspendCount;
	return xosd;
}


BOOL
CheckForAllThreadsFrozen(
	HPRCX hprc,
    HTHDX hthd,
	LPDBB lpdbb
	)
{
	if (hthd->tstate & ts_frozen) {
        //
        // We are about to freeze the thread we are continuing
        // If all the other threads are suspended we should
        // return an error since no execution is possible.
        //
        HTHDX hthdNext;
        BOOL fAllThreadsSuspended = TRUE;

        for (hthdNext = (HTHDX)hprc->hthdChild;hthdNext;hthdNext=hthdNext->nextSibling) {
            if (hthdNext != hthd) {
                DWORD dwSuspendCount;
                if ((GetThreadSuspendCount(hthdNext, &dwSuspendCount) == xosdNone) &&
                        (dwSuspendCount == 0)) {

                    //
                    // Found a thread that is not suspended
                    //
                    fAllThreadsSuspended = FALSE;
                    break;
                }
            }
        }

        if (fAllThreadsSuspended) {
            XOSD xosd = xosdAllThreadsSuspended ;
            SendDBCError(hprc, xosd, NULL);
            Reply(0, &xosd, lpdbb->hpid);
            return TRUE;
        }

        //
        // this thread is not really suspended.  We need to
        // continue it and cause it to be suspended before
        // allowing it to actually execute the user's code.
        //
        if (!MakeThreadSuspendItself(hthd)) {
            hthd->tstate &= ~ts_frozen;
        }
    } else if( hthd->tid != hprc->lastTidDebugEvent) {
		//We have called continue on a thread other than
		//the one that got the debug event
		//check to see if we've been told to suspend the one 
		//that got the debug event.
		HTHDX hthdNext;
		for (hthdNext = (HTHDX)hprc->hthdChild;hthdNext;hthdNext=hthdNext->nextSibling) {
            if (hthdNext->tid == hprc->lastTidDebugEvent){
				if(hthdNext->tstate & ts_frozen) {
					//if pcs is set then this thread will already suspend itself
					//if (!hthd->pcs && !MakeThreadSuspendItself(hthdNext)) {
					if (!MakeThreadSuspendItself(hthdNext)) {
						hthdNext->tstate &= ~ts_frozen;
					}
				} else {
					break;
				}
            }
        }
	}
	return FALSE;
}
	
#if 0

DWORD
ProcessThreadStatCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    LPTST       lptst = (LPTST) LpDmMsg->rgb;
    XOSD        xosd = xosdNone;

#ifndef KERNEL
    typedef NTSTATUS (* QTHREAD)(HANDLE,THREADINFOCLASS,PVOID,ULONG,PULONG);

    NTSTATUS                   Status;
    THREAD_BASIC_INFORMATION   ThreadBasicInfo;
    QTHREAD                    Qthread;
    DWORD                      dw;
#endif  // KERNEL


    Unreferenced( hprc );
    DEBUG_PRINT("ProcessThreadStatCmd : ");

#ifdef KERNEL

    assert(hthd != 0);

#else   // KERNEL

    if (!hthd) {
        WaitForSingleObject(hprc->hEventCreateThread, INFINITE);
        hthd = HTHDXFromHPIDHTID(lpdbb->hpid, lpdbb->htid);
        assert(hthd != 0);
        if (!hthd) {
            LpDmMsg->xosdRet = xosdBadThread;
            return sizeof(TST);
        }
    }

#endif  // KERNEL


    ZeroMemory(lptst, sizeof(TST));

#ifdef KERNEL

    lptst->dwThreadID = hthd->tid;
    sprintf(lptst->rgchThreadID, "%5d", lptst->dwThreadID);

    lptst->dwSuspendCount = 0;
    lptst->dwSuspendCountMax = 0;
    lptst->dwPriority = 1;
    lptst->dwPriorityMax = 1;
    sprintf(lptst->rgchPriority, "%2d", lptst->dwPriority);

#else // !KERNEL

    if (CrashDump) {
        lptst->dwThreadID = hthd->CrashThread.ThreadId;
    } else {
        lptst->dwThreadID = hthd->tid;
    }

	if (hthd->szThreadName[0])
		sprintf(lptst->rgchThreadID, "%.*s", IDSTRINGSIZE-1, hthd->szThreadName );
	else
		lptst->rgchThreadID[0] = 0;

    if (CrashDump) {
        lptst->dwSuspendCount = hthd->CrashThread.SuspendCount;
    } else {
        xosd = GetThreadSuspendCount(hthd, &lptst->dwSuspendCount);
    }

    lptst->dwSuspendCountMax = MAXIMUM_SUSPEND_COUNT;

    if (CrashDump) {
        dw = hthd->CrashThread.PriorityClass;
    } else {
        dw = GetPriorityClass(hprc->rwHand);
    }

    if (!dw) {

        xosd = xosdBadThread;

    } else {

        switch (dw) {

          case IDLE_PRIORITY_CLASS:
            lptst->dwPriority = 4;
            lptst->dwPriorityMax = 15;
            break;

          case NORMAL_PRIORITY_CLASS:
			_asm int 3
			lptst->dwPriority = 8;
#if 0
            if (IsChicago()) {
                lptst->dwPriority = 8;
            } else {
                lptst->dwPriority = 9;
            }
#endif
            lptst->dwPriorityMax = 15;
            break;

          case HIGH_PRIORITY_CLASS:
            lptst->dwPriority = 13;
            lptst->dwPriorityMax = 15;
            break;

          case REALTIME_PRIORITY_CLASS:
            lptst->dwPriority = 4;
            lptst->dwPriorityMax = 31;
            break;
        }

        if (CrashDump) {
            dw = hthd->CrashThread.Priority;
        } else {
            dw = GetThreadPriority(hthd->rwHand);
        }
        if (dw == THREAD_PRIORITY_ERROR_RETURN) {
            xosd = xosdBadThread;
        } else {
            lptst->dwPriority += dw;
            if ((long)lptst->dwPriority > (long)lptst->dwPriorityMax) {
                lptst->dwPriority = lptst->dwPriorityMax;
            } else if ((long)lptst->dwPriority < (long)(lptst->dwPriorityMax - 15)) {
                lptst->dwPriority = lptst->dwPriorityMax - 15;
            }
            sprintf(lptst->rgchPriority, "%2d", lptst->dwPriority);
        }
    }

#endif // !KERNEL

	
    if (hthd->tstate & ts_running) {
        lptst->dwState = tstRunning;
        _tcscpy(lptst->rgchState, "Running");
    } else if (hthd->tstate & ts_stopped) {
        lptst->dwState = tstStopped;
        if (hthd->tstate & ts_frozen) {
			//This thread is suspended via threadsuspenditself
			//So it can only get suspended once.
			lptst->dwSuspendCount = 1;
		}
        _tcscpy(lptst->rgchState, "Stopped");
    } else if (hthd->tstate & ts_dead) {
        lptst->dwState = tstExiting;
        _tcscpy(lptst->rgchState, "Exiting");
    } else if (hthd->tstate & ts_destroyed) {
        lptst->dwState = tstDead;
        _tcscpy(lptst->rgchState, "Dead");
    } else {
        lptst->dwState = tstRunnable;
        _tcscpy(lptst->rgchState, "Pre-run");
    }


    if (hthd->tstate & ts_rip ) {
        lptst->dwState |= tstRip;
        _tcscat(lptst->rgchState, ", RIPped");
    } else if (hthd->tstate & ts_first) {
        lptst->dwState |= tstExcept1st;
        _tcscat(lptst->rgchState, ", 1st chance");
    } else if (hthd->tstate & ts_second) {
        lptst->dwState |= tstExcept2nd;
        _tcscat(lptst->rgchState, ", 2nd chance");
    }


    if (hthd->tstate & ts_frozen) {
        lptst->dwState |= tstFrozen;
        _tcscat(lptst->rgchState, ", suspended");
    }

    lptst->dwTeb = 0;
#ifndef KERNEL
    if (CrashDump) {
        lptst->dwTeb = hthd->CrashThread.Teb;
    } else {
        Qthread = (QTHREAD)GetProcAddress( GetModuleHandle( "ntdll.dll" ),
                                           "NtQueryInformationThread" );
        if (Qthread) {
            Status = Qthread( hthd->rwHand,
                             ThreadBasicInformation,
                             &ThreadBasicInfo,
                             sizeof(ThreadBasicInfo),
                             NULL
                            );
            if (NT_SUCCESS(Status)) {
                lptst->dwTeb = (DWORD)ThreadBasicInfo.TebBaseAddress;
            }
        }
    }
#endif  // !KERNEL

    LpDmMsg->xosdRet = xosd;
    return sizeof(TST);
}
#endif

/***    UnpackLoadCmd
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**      Crack the load command from the debugger
*/
BOOL
UnpackLoadCmd(
    CONST LPVOID lpv,
    LPPRL lpprl
    )
{
    BYTE * lpb = lpv;

    if ( !lpv || !lpprl ) {
        return FALSE;
    }

    lpprl->dwChildFlags = *(DWORD *)lpb;

    lpb += sizeof(DWORD);
    lpprl->lszRemoteExe = lpb;

    lpb += _tcslen(lpb) + 1;
    lpprl->lszCmdLine = lpb;

    lpb += _tcslen(lpb) + 1;
    lpprl->lszRemoteDir = lpb;

    lpb += _tcslen(lpb) + 1;
    lpprl -> lpso = (LPSPAWNORPHAN)lpb;

    return TRUE;
}

#if 0
/***    ProcessLoadCmd
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**      Process a load command from the debugger
*/

void
ProcessProgLoadCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
#ifdef KERNEL

    LPPRL       lpprl = (LPPRL)(lpdbb->rgbVar);
    LPSTR       p;
    char        progname[MAX_PATH];
    char        fname[_MAX_FNAME];
    char        ext[_MAX_EXT];

    if (fDisconnected) {
        DmKdBreakIn = TRUE;
        SetEvent( hEventRemoteQuit );
        LpDmMsg->xosdRet = xosdNone;
        Reply(0, LpDmMsg, lpdbb->hpid);
        return;
    }

    // The debugger will pass us a quoted string version of the name.  Parse out the quotes.

    for (p=lpprl->lszCmdLine+1; p && *p && *p !='"'; p++) ;
    if (*p=='"') {
        *p = '\0';
    }
    _splitpath( lpprl->lszCmdLine+1, NULL, NULL, fname, ext );
    if (_tcsicmp(ext,"exe") != 0) {
        _tcscpy(ext, "exe" );
    }
    _makepath( progname, NULL, NULL, fname, ext );

    if ((_tcsicmp(progname,KERNEL_IMAGE_NAME)==0) ||
        (_tcsicmp(progname,OSLOADER_IMAGE_NAME)==0)) {

        if (!DmKdConnectAndInitialize( progname )) {
            LpDmMsg->xosdRet = xosdFileNotFound;
        } else {
            LpDmMsg->xosdRet = xosdNone;
        }

    } else {
        LpDmMsg->xosdRet = xosdFileNotFound;
    }

    Reply(0, LpDmMsg, lpdbb->hpid);
    return;

#else   // !KERNEL

    char **     szEnvironment=NULL;
    DWORD       dwCreationFlags;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    XOSD        xosd;
    PRL         prl;
    HPRCX       hprc1;
    HPRCX       hprcT;


    fDisconnected = FALSE;

    if (!UnpackLoadCmd(lpdbb->rgbVar, &prl)) {
        assert(FALSE); // Can't deal with failure
    }

    assert (lpdbb -> dmf == dmfProgLoad);

     /*
     * For various strange reasons the list of processes may not have
     * been completely cleared.  If not do so now
     */

    for (hprc1 = prcList; hprc1 != hprcxNull; hprc1 = hprcT) {
        hprcT = hprc1->next;

        if (hprc1->pstate & ps_dead) {
            FreeProcess( hprc1, FALSE );
        }
    }


    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    si.dwFlags = STARTF_USESHOWWINDOW;

    switch ( prl.dwChildFlags & (ulfMinimizeApp | ulfNoActivate) )
    {
      case 0:
        si.wShowWindow = SW_SHOWNORMAL;
        break;
      case ulfMinimizeApp:
        si.wShowWindow = SW_SHOWMINIMIZED;
        break;
      case ulfNoActivate:
        si.wShowWindow = SW_SHOWNOACTIVATE;
        break;
      case (ulfMinimizeApp | ulfNoActivate):
        si.wShowWindow = SW_SHOWMINNOACTIVE;
        break;
    }

    dwCreationFlags = (prl.dwChildFlags & ulfMultiProcess)?
                         DEBUG_PROCESS :
                         DEBUG_ONLY_THIS_PROCESS;

    if (prl.dwChildFlags & ulfWowVdm) {
        dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
    }

    DEBUG_PRINT_2("Load Program: \"%s\"  HPRC=0x%x\n",
                  prl.lszRemoteExe, (DWORD) hprc);

    //DMSqlPreLoad( prl.dwChildFlags );

    xosd = Load(hprc,
                prl.lszRemoteExe,
                prl.lszCmdLine,
                (LPVOID)0,                // &lc->processAttributes,
                (LPVOID)0,                // &lc->threadAttributes,
                dwCreationFlags,
                (prl.dwChildFlags & ulfInheritHandles) != 0,
                szEnvironment,
                prl.lszRemoteDir,
                &si,
                &pi);

    /*
    **  If the load failed then we need to reply right now.  Otherwise
    **  we will delay the reply until we get the All Dlls loaded exception.
    */

    // NB: this was: if (!fUseRoot && xosd != xosdNone)
    // which is completely bogus (race condition on fUseRoot)
    
    if (xosd != xosdNone) {

        Reply(0, &xosd, lpdbb->hpid);
    }

    return;
#endif // !KERNEL
}

void
ProcessSpawnOrphanCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    SOS                     sos;
    XOSD                    xosd;
    DWORD                   dwCreationFlags = 0;
    HPRCX                   hprc1;
    HPRCX                   hprcT;

    fDisconnected = FALSE;

    if (!UnpackLoadCmd(lpdbb->rgbVar, &sos)) {
        assert(FALSE); // Can't deal with failure
    }

    assert (lpdbb -> dmf == dmfSpawnOrphan);
	assert( sos.lpso!=NULL );

    for (hprc1 = prcList; hprc1 != hprcxNull; hprc1 = hprcT) {
        hprcT = hprc1->next;

        if (hprc1->pstate & ps_dead) {
            FreeProcess( hprc1, FALSE );
        }
    }

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    si.dwFlags = STARTF_USESHOWWINDOW;

    switch ( sos.dwChildFlags & (ulfMinimizeApp | ulfNoActivate) )
    {
      case 0:
        si.wShowWindow = SW_SHOWNORMAL;
        break;
      case ulfMinimizeApp:
        si.wShowWindow = SW_SHOWMINIMIZED;
        break;
      case ulfNoActivate:
        si.wShowWindow = SW_SHOWNOACTIVATE;
        break;
      case (ulfMinimizeApp | ulfNoActivate):
        si.wShowWindow = SW_SHOWMINNOACTIVE;
        break;
    }

    if (sos.dwChildFlags & ulfWowVdm) {
        dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
    }

    DEBUG_PRINT_2("Spawn Orphan: \"%s\"  HPRC=0x%x\n",
                  sos.lszRemoteExe, (DWORD) hprc);

    xosd = Load(hprc,
                sos.lszRemoteExe,
                sos.lszCmdLine,
                (LPVOID)0,                // &lc->processAttributes,
                (LPVOID)0,                // &lc->threadAttributes,
                dwCreationFlags,
                (sos.dwChildFlags & ulfInheritHandles) != 0,
                NULL,                   // szEnvironment
                sos.lszRemoteDir,
                &si,
                &pi);

    if (xosd == xosdNone) {
        sos.lpso -> dwPid = pi.dwProcessId;
        LoadString (hInstance, IDS_EXECUTE_OK, sos.lpso -> rgchErr, sizeof (sos.lpso -> rgchErr));
    } else {
        sos.lpso -> dwPid = 0;
        LoadString (hInstance, IDS_EXECUTE_FAILED, sos.lpso -> rgchErr, sizeof (sos.lpso -> rgchErr));
    }
    memcpy (LpDmMsg -> rgb, sos.lpso, sizeof (SPAWNORPHAN));
    LpDmMsg->xosdRet = xosd;
    Reply (sizeof (SPAWNORPHAN), LpDmMsg, lpdbb -> hpid);

    return;


} // ProcessSpawnCmd
#endif // 0

DWORD
ProcessUnloadCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{
    DEBUG_EVENT devent, *pde=&devent;
    HTHDXSTRUCT tHthdS;
    HTHDX       hthdT;

    Unreferenced( lpdbb );

    DEBUG_PRINT("ProcessUnloadCmd called.\n");

    /*
     * Verify we got a valid HPRCX
     */

    if (!hprc) {
        return FALSE;
    }

    if (hprc->pstate != (ps_root | ps_destroyed)) {

        if (hprc->hthdChild != 0) {
            tHthdS = *((HTHDX)(hprc->hthdChild));
        } else {
            memset( &tHthdS, 0, sizeof( HTHDXSTRUCT ) );
            tHthdS.hprc   = hprc;
            tHthdS.rwHand = (HANDLE)-1;
        }

        /*
         *  Pump back destruction notifications
         */
        pde->dwDebugEventCode = DESTROY_THREAD_DEBUG_EVENT;
        pde->dwProcessId      = hprc->pid;

        for(hthd=hprc->hthdChild; hthd; hthd = hthdT){

            hthdT = hthd->nextSibling;

            if (hthd->rwHand != (HANDLE)INVALID) {
                pde->dwThreadId = hthd->tid;
                NotifyEM(pde, hthd, 0, hprc);
                //
                // The session manager "owns" this handle...
                //
                //CloseHandle(hthd->rwHand);
            }
            FreeHthdx(hthd);
        }

        hprc->hthdChild = NULL;

#if 0
#ifndef KERNEL
        if (hprc->rwHand != (HANDLE)INVALID /* && hprc->CloseProcessHandle*/) {
            CloseHandle(hprc->rwHand);
            hprc->rwHand = (HANDLE)INVALID;
        }
#endif  // KERNEL
#endif

        pde->dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
        pde->u.ExitProcess.dwExitCode = hprc->dwExitCode;
        NotifyEM(pde, &tHthdS, 0, hprc);

        pde->dwDebugEventCode = DESTROY_PROCESS_DEBUG_EVENT;
        NotifyEM(pde, &tHthdS, 0, hprc);
    }

    return (DWORD) TRUE;
}                              /* ProcessUnloadCmd() */


XOSD
FreeProcess(
    HPRCX hprc,
    BOOL  fKillRoot
    )
{
    HPRCX               chp;
    HPRCX *             pphp;
    PBREAKPOINT         pbp;
    PBREAKPOINT         pbpT;
    int                 iDll;

    EnterCriticalSection(&csThreadProcList);

    pphp = &prcList->next;
    chp = *pphp;

    while (chp) {
        if (chp != hprc) {
            pphp = &chp->next;
        } else {
#ifndef KERNEL
            if (chp->rwHand != (HANDLE)INVALID && chp->CloseProcessHandle) {
                CloseHandle(chp->rwHand);
                chp->rwHand = (HANDLE)INVALID;
            }
#endif
            RemoveExceptionList(chp);

            for (pbp = BPNextHprcPbp(hprc, NULL); pbp; pbp = pbpT) {
                pbpT = BPNextHprcPbp(hprc, pbp);
                RemoveBP(pbp);
            }

            for (iDll = 0; iDll < chp->cDllList; iDll++) {
                DestroyDllLoadItem(&chp->rgDllList[iDll]);
            }
            MHFree(chp->rgDllList);

            if (chp->rgolerg) {
                MHFree (chp->rgolerg);
            }

            if (!fKillRoot && (chp->pstate & ps_root)) {
                chp->pid    = (PID)-1;
                chp->pstate = ps_root | ps_destroyed;
                pphp = &chp->next;
            } else {
                CloseHandle(chp->hEventCreateThread);
                *pphp = chp->next;
                MHFree(chp);
            }
        }
        chp = *pphp;
    }

    /*
     * special case:
     * if everything has been deleted except for the "sticky"
     * root process, delete it now, and set fUseRoot.
     * The hpid remains the same.  If that changes, the EM needs
     * to send a DestroyPid/CreatePid to change it here.
     */
    if (prcList->next
          && prcList->next->next == NULL
            && prcList->next->pstate == (ps_root | ps_destroyed)) {

        MHFree(prcList->next);
        prcList->next = NULL;
        fUseRoot = TRUE;
    }


    LeaveCriticalSection(&csThreadProcList);

    return xosdNone;
}                               /* FreeProcess() */


XOSD
HandleWatchpoints(
    HPRCX hprcx,
    BOOL fSet,
    LPBPIS lpbpis,
    LPDWORD lpdwNotification
    )
{
    BOOL        fRet;
    ADDR        addr = {0};
    DWORD       cb;
    HTHDX       hthdx;
    XOSD        xosd  = xosdNone;
    PBREAKPOINT pbp;
    HANDLE      hWalk;
    BOOL        fEmulate = FALSE;

    // NYI.
    assert (lpdwNotification == NULL);

    hthdx = !lpbpis->fOneThd ? 0:
                  HTHDXFromHPIDHTID(hprcx->hpid, lpbpis->htid);

    switch ( lpbpis->bptp ) {

      case bptpDataR:
      case bptpDataW:
      case bptpDataC:
      case bptpDataExec:
      case bptpRange:

        if (lpbpis->bptp == bptpRange) {
            addr = lpbpis->rng.addr;
            cb = lpbpis->rng.cb;
        } else {
            addr = lpbpis->data.addr;
            cb = lpbpis->data.cb;
            fEmulate = lpbpis->data.fEmulate;
        }

        if (cb != 0) {
            fRet = ADDR_IS_FLAT(addr) ||
                         TranslateAddress(hprcx, hthdx, &addr, TRUE);
            assert(fRet);
            if (!fRet) {
                xosd = xosdBadAddress;
                break;
            }
        }

        if (fSet) {

            hWalk = GetNewWalk (hprcx,
                                hthdx,
                                GetAddrOff (addr),
                                cb,
                                lpbpis->bptp,
                                fEmulate);

            if (hWalk) {
                pbp = GetNewBp (hprcx,
                                hthdx,
                                lpbpis->bptp,
                                lpbpis->bpns,
                                NULL,
                                NULL,
                                NULL);
                assert (pbp);
                pbp->hWalk = hWalk;
                AddBpToList (pbp);
            } else {
                xosd = xosdUnknown;
            }
        } else {

            // assert(*lpdwNotification != 0);

            // if (!RemoveBP((PBREAKPOINT)*lpdwNotification)) {
            //  xosd = xosdUnknown;
            // }

            //
            // This can all be replaced with the above three lines
            // when the shell starts deleting BPs by handle instead of
            // by description.
            //

            extern
            PVOID
            FindWalk (
                HTHDX hthd,
                DWORD Addr,
                DWORD Size,
                BPTP BpType
                );
            
            extern
            PBREAKPOINT
            FindBpForWalk(
                PVOID Walk
                );


            PVOID pv;

            pv = FindWalk (hthdx ? hthdx : hprcx->hthdChild,
                           GetAddrOff(addr),
                           cb,
                           lpbpis->bptp);

            pbp = FindBpForWalk (pv);

            if (!pbp) {
                xosd = xosdUnknown;
            } else {
                RemoveBP(pbp);
            }

            //
            //
            //
        }

        break;

      case bptpRegC:
      case bptpRegR:
      case bptpRegW:

      default:

        xosd = xosdUnsupported;
        break;
    }

    return xosd;
}


XOSD
HandleBreakpoints(
    HPRCX   hprcx,
    BOOL    fSet,
    LPBPIS  lpbpis,
    LPDWORD lpdwNotification
    )
{
    LPADDR lpaddr;
    HTHDX hthdx;
    BREAKPOINT  *bp;
    XOSD xosd = xosdNone;

    assert(lpdwNotification == NULL);

    switch (lpbpis->bptp) {
      case bptpExec:
        lpaddr = &lpbpis->exec.addr;
        break;

      case bptpMessage:
        lpaddr = &lpbpis->msg.addr;
        break;

      case bptpMClass:
        assert (FALSE);
        lpaddr = &lpbpis->mcls.addr;
        break;
    }

    if (fSet) {
        DPRINT(5, ("Set a breakpoint: %d @%08x:%04x:%08x",
               ADDR_IS_FLAT(*lpaddr), lpaddr->emi,
               lpaddr->addr.seg, lpaddr->addr.off));

        hthdx = !lpbpis->fOneThd? 0 :
                               HTHDXFromHPIDHTID(hprcx->hpid, lpbpis->htid);

        bp = SetBP(hprcx, hthdx, lpbpis->bptp, lpbpis->bpns, lpaddr, 0);

        if (bp == NULL) {
            xosd = xosdUnknown;
        } else {
            // *lpdwNotification = (DWORD)bp;
        }

    } else {

        DEBUG_PRINT("Clear a breakpoint");

        hthdx = !lpbpis->fOneThd? 0 :
                               HTHDXFromHPIDHTID(hprcx->hpid, lpbpis->htid);

        bp = FindBP(hprcx, hthdx, lpbpis->bptp, lpbpis->bpns, lpaddr, TRUE);

        if (bp != NULL) {
            // assert((DWORD)bp == *lpdwNotification);
            RemoveBP(bp);
        } else if ( (hprcx->pstate & (ps_destroyed | ps_killed)) == 0) {
            // Don't fail if this process is already trashed.
            xosd = xosdUnknown;
        }
    }

    return xosd;
}


VOID
ProcessBreakpointCmd(
    HPRCX hprcx,
    HTHDX hthdx,
    LPDBB lpdbb
    )
{
    XOSD xosd = xosdNone;
    XOSD * lpxosd;
    LPDWORD lpdwMessage;
    LPDWORD lpdwNotification;
    LPBPS lpbps = (LPBPS)lpdbb->rgbVar;
    LPBPIS lpbpis;
    UINT i;
    DWORD SizeofBps = SizeofBPS(lpbps);

    if (!lpbps->cbpis) {
        // enable or disable all extant bps.
        // is this used?
        assert(0 && "clear/set all BPs not implemented in DM");
        xosd = xosdUnsupported;
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }

#ifdef KERNEL
    if (!ApiIsAllowed) {
        xosd = xosdUnknown;
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }
#endif

    lpdwMessage = DwMessage(lpbps);
    lpxosd = RgXosd(lpbps);
    lpdwNotification = DwNotification(lpbps);
    lpbpis = RgBpis(lpbps);

    // walk the list of breakpoint commands

    for (i = 0; i < lpbps->cbpis; i++) {
        switch( lpbpis[i].bptp ) {
          case bptpDataC:
          case bptpDataR:
          case bptpDataW:
          case bptpDataExec:
          case bptpRegC:
          case bptpRegR:
          case bptpRegW:
          case bptpRange:

            //
            // dispatch to watchpoint handler
            //
            lpxosd[i] = HandleWatchpoints(hprcx, lpbps->fSet, &lpbpis[i],
                                                         NULL /*&lpdwNotification[i]*/);
            if (xosd == xosdNone) {
                xosd = lpxosd[i];
            }
            break;

          case bptpMessage:
          case bptpMClass:

            //
            // handle as address BP - let debugger handle the details
            //

          case bptpExec:
            lpxosd[i] = HandleBreakpoints(hprcx, lpbps->fSet, &lpbpis[i],
                                                         NULL /*&lpdwNotification[i]*/);
            if (xosd == xosdNone) {
                xosd = lpxosd[i];
            }
            break;

          case bptpInt:
            // ???
            assert(0 && "don't know what these are supposed to do");
            break;
        }
    }

    // send whole structure back to EM

    LpDmMsg->xosdRet = xosd;
    memcpy(LpDmMsg->rgb, lpbps, SizeofBps);
    Reply(SizeofBps, LpDmMsg, lpdbb->hpid);
}

VOID
ProcessSelLimCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )

/*++

Routine Description:

    This function is called in response to a request from the EM to return
    the max valid address in a given segment. Since there are no segments
    in a flat-model system, we just return the max valid user address in the
    address space.

Arguments:

    hprc    - Supplies the handle to the process descriptor

    hthd    - Supplies the handle to the thread descriptor

    lpdbb   - Supplies the request packet.

Return Value:

    None.

--*/

{
    LPDWORD lpdw = (LPDWORD)LpDmMsg->rgb; // For non-Win95 systems the whole addr space is valid.

    Unreferenced(hprc);
    Unreferenced(hthd);

    #ifdef SANJAY_TAKE_A_LOOK_AT_THIS
        #ifndef KERNEL
            if ( IsChicago( ) )
            {
                *lpdw = (ULONG)SystemInfo.lpMaximumApplicationAddress;
            }
            else
        #endif
            {
                        *lpdw = 0xFFFFFFFF ; // For NT all addresses are valid.
                }
    #endif // SANJAY...

    *lpdw = 0xFFFFFFFF;

    LpDmMsg->xosdRet = xosdNone;
    Reply( sizeof( DWORD), LpDmMsg, lpdbb->hpid );

    return;
}                   /* ProcessSelLimCmd() */


	

VOID
ProcessReadMemoryCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )

/*++

Routine Description:

    This function is called in response to a request from the EM to read
    the debuggees memory.  It will take care of any address translations
    which need to be done and request the read operation from the OS.

Arguments:

    hprc    - Supplies the handle to the process descriptor

    hthd    - Supplies the handle to the thread descriptor

    lpdbb   - Supplies the request packet.

Return Value:

    None.

--*/

{
    LPRWP       lprwp    = (LPRWP) lpdbb->rgbVar;
    DWORD       cb       = (DWORD) lprwp->cb;
    LPDM_MSG    lpm      = (LPDM_MSG)MHAlloc( cb + sizeof(DWORD) + FIELD_OFFSET(DM_MSG, rgb));
    char *      buffer   = lpm->rgb + sizeof(DWORD);
    DWORD       length;

    DPRINT(5, ("ProcessReadMemoryCmd : %x %d:%04x:%08x %d\n", hprc,
                  lprwp->addr.emi, lprwp->addr.addr.seg,
                  lprwp->addr.addr.off, cb));


    if (AddrReadMemory(hprc, hthd, &(lprwp->addr), buffer, cb, &length) == 0) {
        lpm->xosdRet = xosdUnknown;
        Reply(0, lpm, lpdbb->hpid);
    } else {
        lpm->xosdRet = xosdNone;
        *((DWORD *) (lpm->rgb)) = length;
        Reply( length + sizeof(DWORD), lpm, lpdbb->hpid);
    }

    MHFree(lpm);
    return;
}                   /* ProcessReadMemoryCmd() */



VOID
ProcessWriteMemoryCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )

/*++

Routine Description:

    this routine is called to case a write into a debuggess memory.

Arguments:

    hprc        - Supplies a handle to the process to write memory in
    hthd        - Supplies a handle to a thread
    lpdbb       - points to data for the command

Return Value:

    XOSD error code

--*/

{
    LPRWP       lprwp = (LPRWP)lpdbb->rgbVar;
    DWORD       cb    = lprwp->cb;
    char *      buffer    = lprwp->rgb;

    HANDLE      rwHand;
    DWORD       length = 0;
    DWORD       offset;
    BP_UNIT     instr;
    BREAKPOINT  *bp;

    DEBUG_PRINT("ProcessWriteMemoryCmd called\n");

#if 0
    /*
     * Sanitize the memory block before writing it into memory :
     * ie: replace any breakpoints that might be in the block
     */

    for(bp=bpList->next; bp; bp=bp->next) {
        if (BPInRange(hprc, hthd, bp, &lprwp->addr, cb, &offset, &instr)) {
            bp->instr1 = *((BP_UNIT *) (buffer + offset));
            *((BP_UNIT *) (buffer + offset)) = BP_OPCODE;
        }
    }
#endif

    rwHand = hprc->rwHand;

    if (AddrWriteMemory(hprc, hthd, &lprwp->addr, buffer, cb, &length)) {
        LpDmMsg->xosdRet = xosdNone;
    }
    else {
        LpDmMsg->xosdRet = xosdUnknown;
    }

    *((DWORD *) (LpDmMsg->rgb)) = length;

    Reply(sizeof(DWORD), LpDmMsg, lpdbb->hpid);

    return;
}                               /* ProcessWriteMemoryCmd() */


VOID
ProcessGetContextCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )

/*++

Routine Description:

    This routine is called in response to a request to get the full
    context of a thread for a particular frame.
    The current frame is 0.  They count back positively; caller is 1.

Arguments:

    hprc        - Supplies the handle of process for the thread

    hthd        - Supplies the handle of the thread

    lpdbb       - Supplies pointer to argument area for request

Return Value:

    None.

--*/

{
    LPCONTEXT       lpreg = (LPCONTEXT)LpDmMsg->rgb;
    BOOL            rval;


    Unreferenced(hprc);

    DEBUG_PRINT( "ProcessGetContextCmd\n");

    if (hthd == 0) {
        LpDmMsg->xosdRet = xosdUnknown;
        Reply( 0, LpDmMsg, lpdbb->hpid );
        return;
    }

    lpreg->ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT;

#if 0
#ifndef KERNEL
    //
    // if it is in the middle of a function call, we want
    // to show the saved context, not the real one.
    //
    if (hthd->pcs) {
        memcpy(lpreg, &hthd->pcs->context, sizeof(CONTEXT));
        LpDmMsg->xosdRet = xosdNone;
        Reply( sizeof(CONTEXT), LpDmMsg, lpdbb->hpid );
    } else
#endif  // !KERNEL
#endif
    //
    // if the thread is stopped and the stored context is good, use it.
    // SJS - Unless updating a fiber Context.
    //
    if ((hthd->tstate & ts_stopped) && (!hthd->hprc->pFbrCntx)
#ifdef KERNEL
                                          &&(!hthd->fContextStale)
#endif  // KERNEL
    ) {
		EnsureHthdReg(hthd, CONTEXT_FULL | CONTEXT_FLOATING_POINT);
        memcpy(lpreg, &hthd->ctx, sizeof(CONTEXT));
        LpDmMsg->xosdRet = xosdNone;
        Reply( sizeof(CONTEXT), LpDmMsg, lpdbb->hpid );
    } else if (DbgGetThreadContext(hthd,lpreg)) {
        LpDmMsg->xosdRet = xosdNone;
        Reply( sizeof(CONTEXT), LpDmMsg, lpdbb->hpid );
    } else {
        LpDmMsg->xosdRet = xosdUnknown;
        Reply( 0, LpDmMsg, lpdbb->hpid );
    }
    return;
}                               /* ProcessGetContextCmd() */


VOID
ProcessSetContextCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This function is used to update the register set for a thread

Arguments:

    hprc        - Supplies a handle to a process

    hthd        - Supplies the handle to the thread to be updated

    lpdbb       - Supplies the set of context information

Return Value:

    None.

--*/

{
    LPCONTEXT   lpcxt = (LPCONTEXT)(lpdbb->rgbVar);
    XOSD        xosd = xosdNone;
    ADDR        addr;

    Unreferenced(hprc);

    DPRINT(5, ("ProcessSetContextCmd : "));

    // If we are fiber debugging don't do anything
    if(hthd->hprc->pFbrCntx) {
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }

    lpcxt->ContextFlags = CONTEXT_FULL | CONTEXT_FLOATING_POINT |
		CONTEXT_EXTENDED_REGISTERS;

#if 0
#ifndef KERNEL
    //
    // if it is in a trojan function call, we want to set the
    // saved context.
    //
    if (hthd->pcs) {
        memcpy(&hthd->pcs->context, lpcxt, sizeof(CONTEXT));
    } else
#endif // !KERNEL
#endif
    {
        memcpy(&hthd->ctx, lpcxt, sizeof(CONTEXT));

        if (hthd->tstate & ts_stopped) {
            hthd->fContextDirty = TRUE;
            hthd->fContextExtendedDirty = TRUE;
            /*
             *  If we change the program counter then we may be pointing
             *      at a different breakpoint.  If so then setup to point
             *      to the new breakpoint
             */

            AddrFromHthdx(&addr, hthd);
            SetBPFlag(hthd, FindBP(hthd->hprc, hthd, bptpExec, (BPNS)-1, &addr, FALSE));
#ifndef KERNEL
        } else if (hthd->fWowEvent) {
            WOWSetThreadContext(hthd, lpcxt);
#endif
        } else {
            DbgSetThreadContext(hthd, lpcxt);
        }
    }

    Reply(0, &xosd, lpdbb->hpid);

    return;
}                               /* ProcessSetContextCmd() */




void
PushRunningThread(
    HTHDX hthd,
    HTHDX hthdFocus
    )
/*++

Routine Description:

    Someone's trying to step a thread that didn't stop. We must push
    the stopped thread otherwise it will hit the same BP it's currently at.

Arguments:

    hthd        - the stopped thread

    hthdFocus   - the thread we want to step/go

Return Value:

    none

--*/
{
    BREAKPOINT* bp;
    if (bp = AtBP(hthd)) {
        if (bp != EMBEDDED_BP && bp->isStep) {
          // Hit SS again
        } else {
            /*
             * We are recovering from a breakpoint, so restore the
             * original instruction, single step and then finally go.
             */

            METHOD *ContinueSSMethod;

            DEBUG_PRINT("***Recovering from a breakpoint");

            ClearBPFlag(hthd);
            if (bp == EMBEDDED_BP) {

                IncrementIP(hthd);

            } else {

                ContinueSSMethod = (METHOD*)MHAlloc(sizeof(METHOD));
                ContinueSSMethod->notifyFunction = (ACVECTOR)MethodContinueSS;
                ContinueSSMethod->lparam         = ContinueSSMethod;
                ContinueSSMethod->lparam2        = bp;
                if(bp)
                    ++bp->cthd;

                RestoreInstrBP(hthd, bp);
                SingleStepEx(hthd, ContinueSSMethod, FALSE, FALSE, FALSE);

            }
        }
    }
}


VOID
ProcessSingleStepCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This command is called to do a single step of the processor.  If
    calls are made then it will step into the command.

Arguments:

    hprc        - Supplies process handle

    hthd        - Supplies thread handle

    lpdbb       - Supplies information on command

Return Value:

    None.

--*/

{
    LPEXOP      lpexop = (LPEXOP)lpdbb->rgbVar;
    XOSD        xosd = xosdNone;
    HTHDX       hthdT;

	DbgTrace ((TR_RANGESTEP,
			   "\n\nBeginning Step Into ============================>>\n"));


	if (hthd && hthd->hprc) {
		hthd->hprc->fStepInto = TRUE;
	}
	
    if (hprc->pstate & ps_dead) {
        hprc->pstate |= ps_dead;
        /*
         *  The process has exited, and we have
         *  announced the death of all its threads (but one).
         *  All that remains is to clean up the remains.
         */

        ProcessUnloadCmd(hprc, hthd, lpdbb);
        Reply(0, &xosd, lpdbb->hpid);
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
        return;
    }

	if (CheckForAllThreadsFrozen (hprc, hthd, lpdbb)) {
		return;
	}

	//
	// Check for an exception on the thread we got the event on.  Only when
	// really broken.
	//
	
#if 0
	if (!hprc->fSoftBroken) {
#endif
		hthdT = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);

		if (!lpexop->fPassException && !hthdT->fExceptionHandled) {
			hthdT->fExceptionHandled = TRUE;
		}
#if 0
	} else {

		//
		// When we are soft-broken, this is not an issue.
		//
		
		hthdT = hthd;
	}
#endif

	if (lpexop->fSetFocus) {
		DmSetFocus(hprc);
    }

    if (!(hthd->tstate & ts_stopped)) {
        HTHDX lastHthd = HTHDXFromPIDTID(hprc->pid, hprc->lastTidDebugEvent);
        if (lastHthd) {
            PushRunningThread(lastHthd, hthd);
        } else {
            hprc->lastTidDebugEvent = hthd->tid;
        }
    }
	
    //
	// Catch any exception that changes flow of control
	//
	
	if (!SetupNLG(hthd, NULL)) {
		RegisterExpectedEvent(hthd->hprc, (HTHDX)hthd,
							  EXCEPTION_DEBUG_EVENT,
							  NO_SUBCLASS,
							  DONT_NOTIFY,
							  ActionExceptionDuringStep,
							  FALSE,
							  InfoExceptionDuringStep(hthd)
							  );
	}


    if (hthd->tstate & ts_stepping) {
        xosd = xosdUnknown;
    } else if (lpexop->fStepOver) {
        StepOver(hthd, &EMNotifyMethod, FALSE, FALSE);
    } else {
        SingleStep(hthd, &EMNotifyMethod, FALSE, FALSE);
    }

    Reply(0, &xosd, lpdbb->hpid);
    return;
}                               /* ProcessSingleStepCmd() */



VOID
ProcessRangeStepCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This routine is called to start a range step.  This will continue
    to do steps as long as the current PC is between the starting
    and ending addresses

Arguments:

    hprc        - Supplies the process handle to be stepped

    hthd        - Supples the thread handle to be stepped

    lpdbb       - Supples the information about the command

Return Value:

    None.

--*/

{
    LPRST       lprst = (LPRST)lpdbb->rgbVar;
    XOSD        xosd = xosdNone;
    HTHDX       hthdT;

	DbgTrace ((TR_RANGESTEP,
			   "\n\nBeginning Range Step ============================>>\n"));

    DEBUG_PRINT_2("RangeStep [%08x - %08x]\n", lprst->offStart, lprst->offEnd);

    if (hprc->pstate & ps_dead) {

        hprc->pstate |= ps_dead;
        /*
         *  The process has exited, and we have
         *  announced the death of all its threads (but one).
         *  All that remains is to clean up the remains.
         */

        ProcessUnloadCmd(hprc, hthd, lpdbb);
        Reply(0, &xosd, lpdbb->hpid);
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
        return;
    }

    assert(hthd);

    hthd->fDisplayReturnValues = lprst->exop.fReturnValues;

#if 0
	if (!hprc->fSoftBroken) {
#endif
		hthdT = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);

		if (!lprst->exop.fPassException && !hthdT->fExceptionHandled) {
			hthdT->fExceptionHandled = TRUE;
		}
#if 0
	} else {
		hthdT = hthd;
	}
#endif

  	if (CheckForAllThreadsFrozen (hprc, hthd, lpdbb)) {
		return;
	}

    //
    // FUTURE: This flag is not correctly reset when a StepOut
    // Fails because we're in a Win95 callback (e.g. WndProc).
    // 
    // We should make sure it gets reset and assert it here.
    //

	hthd->fReturning = FALSE;

    if (!(hthd->tstate & ts_stopped)) {
        HTHDX lastHthd = HTHDXFromPIDTID(hprc->pid, hprc->lastTidDebugEvent);
        if (lastHthd) {
            PushRunningThread(lastHthd, hthd);
        } else {
            hprc->lastTidDebugEvent = hthd->tid;
        }
    }

	if (hthd && hthd->hprc) {
		hthd->hprc->fStepInto = !lprst->exop.fStepOver;
	}
	
	//
	// Catch any exception that changes flow of control
	//
	
	if (!SetupNLG(hthd, NULL)) {
		RegisterExpectedEvent (hthd->hprc,
							   (HTHDX)hthd,
							   EXCEPTION_DEBUG_EVENT,
							   NO_SUBCLASS,
							   DONT_NOTIFY,
							   ActionExceptionDuringStep,
							   FALSE,
							   InfoExceptionDuringStep(hthd)
							   );
        }


#if defined (TARGET_MIPS) || defined(TARGET_PPC)
      // v-ibmaa:  Added this fix in order to be able to tell if we need to
      //       pass this exception through, or let the IDE handle it.
      //       Not sure if the other RISC vendors wish to add
      //           themseleves to this list
  
      hthd->fPassException       = lprst->fPassException;
#endif

#if 0
    if ( !fSmartRangeStep ||
            !SmartRangeStep(hthd,
                            lprst->offStart,
                            lprst->offEnd,
                            !lprst->exop.fInitialBP,
                            lprst->exop.fStepOver
                            ))
#endif
	{
        RangeStep(hthd,
                  lprst->offStart,
                  lprst->offEnd,
                  !lprst->exop.fInitialBP,
                  lprst->exop.fStepOver
                  );
    }
    Reply(0, &xosd, lpdbb->hpid);
    return;
}                               /* ProcessRangeStepCmd() */


VOID
ProcessReturnStepCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

Arguments:

    hprc        - Supplies the process handle to be stepped

    hthd        - Supples the thread handle to be stepped

    lpdbb       - Supples the information about the command

Return Value:

    None.

--*/

{
    LPRTRNSTP  lprtrnstp = (LPRTRNSTP)lpdbb->rgbVar;
    XOSD       xosd = xosdNone;

	DbgTrace ((TR_RANGESTEP,
			   "\n\nBeginning Return Step ============================>>\n"));

    if (hprc->pstate & ps_dead) {

        hprc->pstate |= ps_dead;
        /*
         *  The process has exited, and we have
         *  announced the death of all its threads (but one).
         *  All that remains is to clean up the remains.
         */

        ProcessUnloadCmd(hprc, hthd, lpdbb);
        Reply(0, &xosd, lpdbb->hpid);
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
        return;
    }

	if (CheckForAllThreadsFrozen (hprc, hthd, lpdbb)) {
		return;
	}

    if (lprtrnstp->exop.fSetFocus) {
       DmSetFocus (hprc);
    }

    if (!(hthd->tstate & ts_stopped)) {
        HTHDX lastHthd = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);
        if (lastHthd) {
            PushRunningThread (lastHthd, hthd);
        } else {
            hprc->lastTidDebugEvent = hthd->tid;
        }
    }

	//
	// Catch any exception that changes flow of control
	//
	
	if (!SetupNLG(hthd, &lprtrnstp->addrStack)) {
		RegisterExpectedEvent (hthd->hprc,
							   (HTHDX)hthd,
							   EXCEPTION_DEBUG_EVENT,
							   NO_SUBCLASS,
							   DONT_NOTIFY,
							   ActionExceptionDuringStep,
							   FALSE,
							   InfoExceptionDuringStep(hthd)
							   );
	}

	hthd->fDisplayReturnValues = lprtrnstp->exop.fReturnValues;
    ReturnStep(hthd, &EMNotifyMethod, FALSE, FALSE, &(lprtrnstp->addrRA), &(lprtrnstp->addrStack));
    Reply(0, &xosd, lpdbb->hpid);

}                               /* ProcessReturnStepCmd() */



VOID
ProcessContinueCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This function is used to cause a process to be executed.
    It is called in response to a GO command.

Arguments:

    hprc        - Supplies handle to process to execute

    hthdd       - Supplies handle to thread

    lpdbb       - Command buffer

Return Value:

    xosd Error code

TODO:
    Are there any times where we do not want to allow a GO command
    to be executed.

    Two other possible problems here that need to be deal with are:

    1.  Single thread go commands

    2.  The current thread not being the thread where the last debug
        event occured.  In this case the DoContinueDebugEvent
        command SHOULD NOT WORK.

--*/

{
    LPEXOP      lpexop = (LPEXOP)lpdbb->rgbVar;
    BREAKPOINT  *bp;
    XOSD        xosd = xosdNone;
    DEBUG_EVENT de;
    HTHDXSTRUCT hthdS;
    DWORD       cs;
    HTHDX       hthdT;

    DPRINT(5, ("ProcessContinueCmd : pid=%08lx, tid=%08lx, hthd=%08lx",
            hprc->pid, hthd ? hthd->tid : -1, hthd));

    if (lpexop->fSetFocus) {
       DmSetFocus(hprc);
    }

    if (hprc->pstate & ps_connect) {
        Reply(0, &xosd, lpdbb->hpid);
        SetEvent( hEventContinue );
        return;
    }

    //
    // Don't enter during event processing, because we
    // might be here before the DM has finished with the
    // event we are responding to.
    //
    // Don't worry about new events during our processing,
    // since they won't apply to this process.
    //

    EnterCriticalSection(&csProcessDebugEvent);
    LeaveCriticalSection(&csProcessDebugEvent);

    if (hprc->pstate & ps_dead) {

        hprc->pstate |= ps_dead;

		//
        // The process has exited, and we have announced
        // the death of all its threads (but one).
        // All that remains is to clean up the remains.
        //

        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hprc->pid,
                  hprc->lastTidDebugEvent,
                  DBG_CONTINUE,
                  0);
        ProcessUnloadCmd(hprc, hthd, lpdbb);
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }


    if (!hthd) {
        WaitForSingleObject(hprc->hEventCreateThread, INFINITE);
        hthd = HTHDXFromHPIDHTID(lpdbb->hpid, lpdbb->htid);
        assert(hthd != 0);
        if (!hthd) {
            xosd = xosdBadThread;
            Reply(0, &xosd, lpdbb->hpid);
            return;
        }
    }


    if (hthd->tstate & ts_dead) {

        //
        //  Note that if a terminated thread is frozen
        //  then we do not send a destroy on it yet:
        //  ProcessAsyncGoCmd() deals with those cases.
        //

        hthdS = *hthd;    // keep some info

        //
        // If it isn't frozen, destroy it.
        //

        if ( !(hthd->tstate & ts_frozen)) {
            de.dwDebugEventCode = DESTROY_THREAD_DEBUG_EVENT;
            NotifyEM(&de, hthd, 0, NULL);
            FreeHthdx(hthd);
            hprc->pstate &= ~ps_deadThread;
        }

        //
        // if there are other dead threads (how??)
        // put the deadThread bit back.
        //

        for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
            if (hthd->tstate & ts_dead) {
                hprc->pstate |= ps_deadThread;
            }
        }

        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthdS.hprc->pid,
                  hthdS.tid,
                  DBG_CONTINUE,
                  0);
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }


	//
    // NOTE: this is a little bit questionable.  The problem we are trying
    // to solve is this: when we step thread A and get a BP on thread B and
    // do a go on thread B, we will still have events/bps registered for
    // thread A.  By doing ConsumeAllProcessEvents () here we make sure that
    // go really means go.
	//

    if (!(hprc->pstate & (ps_preEntry | ps_preStart))) {
        if (lpexop->fGo) {
            ConsumeAllProcessEvents (hprc, FALSE);
        }
    }
    
    if (CheckForAllThreadsFrozen (hprc, hthd, lpdbb)) {
		return;
	}

    //
    //  If the current thread is sitting on a breakpoint then it is necessary
    //  to do a step over it and then try and do a go.  Steps are necessary
    //  to ensure that the breakpoint will be restored.
    //
    //  If the breakpoint is embedded in the code path and not one we
    //  set then just advance the IP past the breakpoint.
    //
    //  NOTENOTE - jimsch - it is necessary to do a single thread step
    //          to ensure that no other threads of execution would have
    //          hit the breakpoint we are disabling while the step on
    //          the current thead is being executed.
    //
    //  NOTENOTE - jimsch - INTEL - two byte int 3 is not deal with
    //          correctly if it is embedded.
    //
    //  NOTE:
    //      We can receive a "continue" on a thread other than the one which
    //      got the debug event on.  The stepping over the BP must occure on
    //      the tidLastDebugEvent thread, NOT the one which we get the continue
    //      on or we will never remove the BP.
    //

#if 0
	if (!hprc->fSoftBroken) {
#endif
	
		hthdT = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);
#if 0
	} else {
		hthdT = hthd;
	}
#endif

    if (bp = AtBP(hthdT)) {
        //
        // We are recovering from a breakpoint, so restore the
        // original instruction, single step and then finally go.
        //

        METHOD *ContinueSSMethod;

        DEBUG_PRINT("Recovering from a breakpoint\n");

        if (bp == EMBEDDED_BP) {

            //
            // "step" past the bp and continue.
            //
            /* This "embedded BP" may actually be one of our BPs that got
             * removed after the exception was taken and after we did the
             * instruction check but before we did the bp lookup.  In that
             * case, we won't increment the IP */

            if (!hthd->fDontStepOff) {
                ClearBPFlag (hthdT);
                hthdT->fIsCallDone = FALSE;
                IncrementIP (hthdT);
            }

        } else {

            ContinueSSMethod = (METHOD*)MHAlloc (sizeof(METHOD));
            ContinueSSMethod->notifyFunction = (ACVECTOR)MethodContinueSS;
            ContinueSSMethod->lparam         = ContinueSSMethod;
            ContinueSSMethod->lparam2        = bp;
            if(bp)
                ++bp->cthd;

            SingleStep (hthdT, ContinueSSMethod, FALSE, FALSE);
            Reply (0, &xosd, lpdbb->hpid);
            return;
        }
    }

    //
    //  Have the Expression BP manager know that we are continuing
    //

    // NB: should ExprBPContinue () use the thread we are continuing, hthd,
    // or the thread that received the debug event, hthdT?

    ExprBPContinue (hprc, hthd);

    //
    //  Do a continue debug event and continue execution
    //

    assert ( (hprc->pstate & ps_destroyed) == 0 );

    //
    // fExceptionHandled may also have been set by function eval code.
    //

#if 0
	if (!hprc->fSoftBroken) {
#endif
		hthdT = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);
#if 0
	} else {
		hthdT = hthd;
	}
#endif

    if (!lpexop->fPassException && !hthdT->fExceptionHandled)
        hthdT->fExceptionHandled = TRUE;

    if ((hthdT->tstate & (ts_first | ts_second)) && !hthdT->fExceptionHandled) {
        cs = (DWORD)DBG_EXCEPTION_NOT_HANDLED;

    } else {
        cs = (DWORD)DBG_CONTINUE;
    }

    SetDebugEventThreadState (hthd->hprc, ts_running);

    for (hthdT = hthd->hprc->hthdChild; hthdT ; hthdT = hthdT->nextSibling) {
        hthdT->fExceptionHandled = FALSE;
    }

    Reply(0, &xosd, lpdbb->hpid);

    //
    // In user mode crashdumps, this is how we emulate the
    // continuation of the loader breakpoint.
    //

#if 0
    if (CrashDump) {
        SetEvent( hEventContinue );
    } else 
#endif
	{
        AddQueue( QT_CONTINUE_DEBUG_EVENT,
                  hthd->hprc->pid,
                  hthd->tid,
                  (DWORD)cs,
                  0);
    }
}                               /* ProcessContinueCmd() */

void
MethodContinueSS(
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    METHOD *method
    )
{
    PBREAKPOINT         bp = (BREAKPOINT*) method->lparam2;

    Unreferenced( pde );

    /* Keep the breakpoint around while we're using it */
    EnterCriticalSection(&csThreadProcList);
    /* Only restore the bp if it's still in use */
    if(bp->instances) {
        if (bp != EMBEDDED_BP && !bp->hWalk) {
            WriteBreakPoint( bp );
        }
    }
    ReleaseBP(bp);
    LeaveCriticalSection(&csThreadProcList);

    MHFree(method->lparam);

    //
    //  Have the Expression BP manager know that we are continuing
    //
    ExprBPContinue( hthd->hprc, hthd );

    SetDebugEventThreadState (hthd->hprc, ts_running);

    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              DBG_CONTINUE,
              0);

    return;
}



DWORD
ProcessFreezeThreadCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
{

#ifdef KERNEL

    XOSD   xosd = xosdNone;
    hthd->tstate |= ts_frozen;
    Reply(0, &xosd, lpdbb->hpid);
    return( xosd );

#else   // KERNEL

    XOSD   xosd = xosdNone;

    Unreferenced( hprc );

    DEBUG_PRINT("ProcessFreezeThreadCmd called.\n\r");
	
    if (!(hthd->tstate & ts_frozen)) {

        if (hthd->tstate & ts_stopped) {
            //
            // If the thread is at a debug event, don't suspend it -
            // let it suspend itself later when we continue it.
            //
            hthd->tstate |= ts_frozen;
        } else 
		if (SUCCEEDED(DmSuspendThread(hthd->tid))) {
            hthd->tstate |= ts_frozen;
        } else {
            xosd = xosdBadThread;
        }
	}

    Reply(0, &xosd, lpdbb->hpid);
    return( xosd );

#endif  // KERNEL
}


#define efdDefault efdNotify

EXCEPTION_DESCRIPTION ExceptionList[] = {
                // DBG_CONTROL_C and DBG_CONTROL_BREAK are *only*
                // raised if the app is being debugged.  The system
                // remotely creates a thread in the debuggee and then
                // raises one of these exceptions; the debugger must
                // respond to the first-chance exception if it wants
                // to trap it at all, because it will never see a
                // last-chance notification.
    {(DWORD)DBG_CONTROL_C,                    efdStop,   "Control-C"},
    {(DWORD)DBG_CONTROL_BREAK,                efdStop,   "Control-Break"},
    {(DWORD)EXCEPTION_DATATYPE_MISALIGNMENT,  efdDefault, "Datatype Misalignment"},
    {(DWORD)EXCEPTION_ACCESS_VIOLATION,       efdDefault, "Access Violation"},
    {(DWORD)EXCEPTION_IN_PAGE_ERROR,          efdDefault, "In Page Error"},
    {(DWORD)STATUS_ILLEGAL_INSTRUCTION,       efdDefault, "Illegal Instruction"},
    {(DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED,  efdDefault, "Array Bounds Exceeded"},
                // Floating point exceptions will only be raised if
                // the user calls _controlfp() to turn them on.
    {(DWORD)EXCEPTION_FLT_DENORMAL_OPERAND,   efdDefault, "Float Denormal Operand"},
    {(DWORD)EXCEPTION_FLT_DIVIDE_BY_ZERO,     efdDefault, "Float Divide by Zero"},
    {(DWORD)EXCEPTION_FLT_INEXACT_RESULT,     efdDefault, "Float Inexact Result"},
    {(DWORD)EXCEPTION_FLT_INVALID_OPERATION,  efdDefault, "Float Invalid Operation"},
    {(DWORD)EXCEPTION_FLT_OVERFLOW,           efdDefault, "Float Overflow"},
    {(DWORD)EXCEPTION_FLT_STACK_CHECK,        efdDefault, "Float Stack Check"},
    {(DWORD)EXCEPTION_FLT_UNDERFLOW,          efdDefault, "Float Underflow"},
                // STATUS_NO_MEMORY can be raised by HeapAlloc and
                // HeapRealloc.
    {(DWORD)STATUS_NO_MEMORY,                 efdDefault, "No Memory"},
                // STATUS_NONCONTINUABLE_EXCEPTION is raised if a
                // noncontinuable exception happens and an exception
                // filter return -1, meaning to resume execution.
    {(DWORD)STATUS_NONCONTINUABLE_EXCEPTION,  efdDefault, "Noncontinuable Exception"},
                // STATUS_INVALID_DISPOSITION means an NT exception
                // filter (which is slightly different from an MS C
                // exception filter) returned some value other than
                // 0 or 1 to the system.
    {(DWORD)STATUS_INVALID_DISPOSITION,       efdDefault, "Invalid Disposition"},
    {(DWORD)EXCEPTION_INT_DIVIDE_BY_ZERO,     efdDefault, "Integer Divide by Zero"},
    {(DWORD)EXCEPTION_INT_OVERFLOW,           efdDefault, "Integer Overflow"},
    {(DWORD)EXCEPTION_PRIV_INSTRUCTION,       efdDefault, "Privileged Instruction"},
    {(DWORD)STATUS_STACK_OVERFLOW,            efdDefault, "Stack Overflow"},
    {(DWORD)STATUS_DLL_NOT_FOUND,             efdDefault, "DLL Not Found"},
    {(DWORD)STATUS_DLL_INIT_FAILED,           efdDefault, "DLL Initialization Failed"},
	{(DWORD)VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
	                                          efdDefault, "Module Not Found"},
	{(DWORD)VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
	                                          efdDefault, "Procedure Not Found"},
	{(DWORD)STATUS_INVALID_HANDLE,			  efdStop,	  "Invalid Handle"},
    {(DWORD)(0xE0000000 | 'msc'),             efdNotify, "Microsoft C++ Exception"},
};

#define SIZEOFELIST ( sizeof(ExceptionList) / sizeof(ExceptionList[0]) )

void
ProcessGetExceptionState(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This function is used to query the dm about exception handling.

Arguments:

    hprc        - Supplies process handle

    hthd        - Supplies thread handle

    lpdbb       - Supplies info about the command

Return Value:

    None.

--*/

{
    LPEXCMD lpexcmd = (LPEXCMD)lpdbb->rgbVar;
    LPEXCEPTION_DESCRIPTION lpexdesc = (LPEXCEPTION_DESCRIPTION)LpDmMsg->rgb;
    EXCEPTION_LIST  *eList;
    XOSD           xosd = xosdNone;
    int i = 0;

    Unreferenced     (hthd);

    DEBUG_PRINT("ProcessGetExceptionStateCmd");

#if 0
    if (!hprc) {
		xosd = xosdUnknown;
        Reply(0, &xosd, lpdbb->hpid);
        return;
    }
#endif

    switch( lpexcmd->exc ) {

        case exfFirst:

            if (!hprc || !hprc->exceptionList) {
                *lpexdesc = ExceptionList[0];
            } else {
                *lpexdesc = hprc->exceptionList->excp;
            }
            break;

        case exfNext:

            xosd = xosdEndOfStack;
            if (hprc && hprc->exceptionList) {
                for (eList=hprc->exceptionList; eList; eList=eList->next) {
                    if (eList->excp.dwExceptionCode ==
                                                   lpexdesc->dwExceptionCode) {
                        eList = eList->next;
                        if (eList) {
                            *lpexdesc = eList->excp;
                            xosd = xosdNone;
                        } else {
                            lpexdesc->dwExceptionCode = 0;
                        }
                        break;
                    }
                }
            } else {
                for (i = 0; i < SIZEOFELIST; i++) {
                    if (ExceptionList[i].dwExceptionCode ==
                                                   lpexdesc->dwExceptionCode) {
                        if (i+1 < SIZEOFELIST) {
                            *lpexdesc = ExceptionList[i+1];
                            xosd = xosdNone;
                        } else {
                            lpexdesc->dwExceptionCode = 0;
                        }
                        break;
                    }
                }
            }

            break;

        case exfSpecified:

            xosd = xosdEndOfStack;
            if (hprc && hprc->exceptionList) {
                for (eList = hprc->exceptionList; eList; eList = eList->next) {
                    if (eList->excp.dwExceptionCode ==
                                                   lpexdesc->dwExceptionCode) {
                        *lpexdesc = eList->excp;
                        xosd = xosdNone;
                        break;
                    }
                }
            } else {
                for (i = 0; i < SIZEOFELIST; i++) {
                    if (ExceptionList[i].dwExceptionCode ==
                                                   lpexdesc->dwExceptionCode) {
                        *lpexdesc = ExceptionList[i+1];
                        xosd = xosdNone;
                        break;
                    }
                }
            }

            break;

        default:
           assert(!"Invalid exf to ProcessGetExceptionState");
           xosd = xosdUnknown;
           break;
    }

    LpDmMsg->xosdRet = xosd;
    Reply(sizeof(EXCEPTION_DESCRIPTION), LpDmMsg, lpdbb->hpid);
    return;
}


VOID
ProcessSetExceptionState(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    This function is used to change how the debugger will handle exceptions.

Arguments:

    hprc        - Supplies process handle

    hthd        - Supplies thread handle

    lpdbb       - Supplies info about the command

Return Value:

    None.

--*/

{
    LPEXCEPTION_DESCRIPTION lpexdesc = (LPEXCEPTION_DESCRIPTION)lpdbb->rgbVar;
    EXCEPTION_LIST  *eList;
    XOSD           xosd = xosdNone;

    Unreferenced     (hthd);

    DEBUG_PRINT("ProcessSetExceptionStateCmd");

    if (!hprc) {
        WaitForSingleObject(hEventCreateProcess, INFINITE);
        hprc = HPRCFromHPID(lpdbb->hpid);
        if (!hprc) {
            xosd = xosdUnknown;
            Reply(0, &xosd, lpdbb->hpid);
            return;
        }
    }

    for (eList=hprc->exceptionList; eList; eList=eList->next) {
        if (eList->excp.dwExceptionCode==lpexdesc->dwExceptionCode) {
            break;
        }
    }

    if (eList) {
        // update it:
        eList->excp = *lpexdesc;
    } else {
        // add it:
        InsertException(&(hprc->exceptionList), lpexdesc);
    }

    Reply(0, &xosd, lpdbb->hpid);
    return;
}


EXCEPTION_FILTER_DEFAULT
ExceptionAction(
    HPRCX hprc,
    DWORD dwExceptionCode
    )
{
    EXCEPTION_LIST   *eList;

    for (eList=hprc->exceptionList; eList; eList=eList->next) {
        if (eList->excp.dwExceptionCode==dwExceptionCode ) {
            break;
        }
    }

    if (eList != NULL) {
        return eList->excp.efd;
    } else {
        return efdDefault;
    }
}


void
RemoveExceptionList(
    HPRCX hprc
    )
{
    EXCEPTION_LIST *el, *elt;
    for(el = hprc->exceptionList; el; el = elt) {
        elt = el->next;
        MHFree(el);
    }
    hprc->exceptionList = NULL;
}


EXCEPTION_LIST *
InsertException(
    EXCEPTION_LIST ** ppeList,
    LPEXCEPTION_DESCRIPTION lpexc
    )
{
    LPEXCEPTION_LIST pnew;
    while ((*ppeList) &&
             (*ppeList)->excp.dwExceptionCode < lpexc->dwExceptionCode) {
        ppeList = &((*ppeList)->next);
    }
    pnew = (LPEXCEPTION_LIST)MHAlloc(sizeof(EXCEPTION_LIST));
    pnew->next = *ppeList;
    *ppeList = pnew;
    pnew->excp = *lpexc;
    return pnew;
}


void
InitExceptionList(
    HPRCX hprc
    )
{
    int i;
    for (i = 0; i < SIZEOFELIST; i++) {
        InsertException(&(hprc->exceptionList), ExceptionList + i);
    }
}



VOID
ProcessSystemServiceCmd(
    HPRCX   hprc,
    HTHDX   hthd,
    LPDBB   lpdbb
    )

/*++

Routine Description:

    This function is called in response to a SystemService command from
    the shell.  It is used as a catch all to get and set strange information
    which is not covered elsewhere.  The set of SystemServices is OS and
    implemenation dependent.

Arguments:

    hprc        - Supplies a process handle

    hthd        - Supplies a thread handle

    lpdbb       - Supplies the command information packet

Return Value:

    None.

--*/

{
    LPSSS lpsss =  (LPSSS) lpdbb->rgbVar;

    switch( lpsss->ssvc ) {
        case ssvcGeneric:
            ProcessIoctlGenericCmd( hprc, hthd, lpdbb );
            return;

        case ssvcCustomCommand:
            ProcessSSVCCustomCmd( hprc, hthd, lpdbb );
            return;

        default:
            LocalProcessSystemServiceCmd( hprc, hthd, lpdbb );
            return;
    }
}                               /* ProcessSystemServiceCmd() */


VOID
ProcessSetPathCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    )
/*++

Routine Description:

    Sets the search path;

Arguments:

    hprc   -

    hthd   -

    lpdbb  -

Return Value:

    None.

--*/

{
    SETPTH *SetPath = (SETPTH *)lpdbb->rgbVar;

	_asm int 3

    SearchPathSet = SetPath->Set;
    if ( SearchPathSet ) {
        _tcscpy(SearchPathString, SetPath->Path );
    } else {
        SearchPathString[0] = '\0';
    }

    LpDmMsg->xosdRet = xosdNone;
    Reply(0, LpDmMsg, lpdbb->hpid);
}

#if 0
ULONG
ProcessGetTimeStamp(
    HPRCX   hprc,
    HTHDX   hthd,
    LPDBB   lpdbb
    )
/*++

Routine Description:

    This routine gets the TimeStamp and CheckSum from the specified image
    file and returns them.

--*/
{
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    IMAGE_DOS_HEADER    dosHdr;
    IMAGE_NT_HEADERS    ntHdr;
    BOOL                fSucc;
    ULONG               rSize = 0;
    LPTSTR              ImageName = (LPTSTR) lpdbb->rgbVar;
    LPTCSR              lpReply = (LPTCSR) LpDmMsg->rgb;
    ULONG               cbRead;

    LpDmMsg->xosdRet = xosdFileNotFound;

    hFile = CreateFile (ImageName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE) {
        goto Return;
    }

    LpDmMsg->xosdRet = xosdBadFormat ;

    fSucc = ReadFile (hFile, &dosHdr,  sizeof (dosHdr), &cbRead, NULL);

    if (!fSucc || dosHdr.e_magic != IMAGE_DOS_SIGNATURE) {
        goto Return;
    }

    if (!SetFilePointer (hFile, dosHdr.e_lfanew, NULL, FILE_BEGIN)) {
        goto Return;
    }

    if (!ReadFile (hFile, &ntHdr, sizeof (ntHdr), &cbRead, NULL) ||
        ntHdr.Signature != IMAGE_NT_SIGNATURE) {
        goto Return;
    }

    rSize = sizeof (*lpReply);
    LpDmMsg->xosdRet = xosdNone;

    lpReply->TimeStamp = ntHdr.FileHeader.TimeDateStamp ;
    lpReply->CheckSum = ntHdr.OptionalHeader.CheckSum ;

Return:

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile);
    }

    return rSize;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\precomp.h ===
/*--

Copyright (c) 1992  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Header file that is pre-compiled into a .pch file

Author:

    Wesley Witt (wesw) 21-Sep-1993

Environment:

    Win32, User Mode

--*/
#undef UNICODE
#undef _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdbg.h>
#include <windows.h>
#ifdef XBOX
#include <windbapi.h>
#include <xbdm.h>
#include <ctx386.h>
#else
#include <winsock.h>
#define DMSOCKETS
#include <xboxdbg.h>
#endif

#if 0
#undef DBG
#undef NDEBUG
#ifdef VCDBG
#define DBG 1
#else
#define NDEBUG
#endif // VCDBG
#endif

#if !defined(DBG) && !defined(NDEBUG)
#define NDEBUG
#endif

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <od.h>
#include <odp.h>
#include <cvinfo.h>
#include <emdm.h>
#include <win32dm.h>

#ifdef XBOX
#include <xbdm.h>
#else
#include <winsock.h>
#define DMSOCKETS
#include <xboxdbg.h>
#endif

#include "dm.h"
#include "list.h"
#include "bp.h"
#include "funccall.h"
#include "debug.h"
#include "dbgver.h"
#ifndef XBOX
#include "resource.h"
#endif

/* Here are the functions we want to prevent from working */
#define NOWIN32
#ifdef NOWIN32
#define WaitForDebugEvent()
#define ContinueDebugEvent()
#define CreateProcessA()
#define CreateProcessW()
#define OpenProcess()
#define GetExitCodeThread()
#define DebugActiveProcess()
#define GetThreadContext()
#define GetThreadSelectorEntry()
#define ReadProcessMemory()
#define SetThreadContext()
#define SuspendThread()
#define ResumeThread()
#endif

#ifdef XBOX
#define malloc(cb) ExAllocatePoolWithTag(PagedPool, cb, 'cvsm')
#define free(p) ExFreePoolWithTag(p, 'cvsm')
#define GetTickCount NtGetTickCount

#define assert(f) ASSERT(f)
// no spew until we have spew functions
#define OutputDebugStringA(str)
#endif

extern LPDM_MSG LpDmMsg;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\resource.h ===
// item ID values for setup dialog

#include "rescommon.h"

#define IDNAME  101
#define IDPW    103
#define IDFORCE 104
#define IDC_CHECK_SELF_DEBUG        105

#define IDS_ERR_STARTUP				100
#define IDS_ERR_CONNECT				101
#define IDS_ERR_NOT_FOUND			102
#define IDS_ERR_RESOLVE				103
#define IDS_ERR_GENERIC				104
#define IDS_ERR_VERSION				105
#define IDS_ERR_PASSWORD			106
#define IDS_ERR_SOCKET				107
#define IDS_ERR_SETTINGS			108
#define IDS_ERR_SERVER_IN_USE		111

#define IDS_ERR_CANNOT_INITIALIZE   121
#define IDS_ERR_CANNOT_CONNECT      122
#define IDS_ERR_NOT_AUTHORIZED      123

#define IDS_ERR_BOOTTIMEOUT         130

#define IDS_HELP					109	
#define IDS_MSGBOX_TITLE			110	


//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by DM.RC
//
#define IDS_STATUS_DLL_NOT_FOUND			1
//#define IDS_tstRunnable						2
//#define IDS_tstStopped						3
//#define IDS_tstRunning						4
//#define IDS_tstExiting						5
//#define IDS_tstDead							6
// These strings are currently hard-coded in PROCEM.C
//#define IDS_DBG_CONTROL_C					7
//#define IDS_DBG_CONTROL_BREAK 				8
//#define IDS_EXCEPTION_DATATYPE_MISALIGNMENT 9
//#define IDS_EXCEPTION_ACCESS_VIOLATION		10
//#define IDS_EXCEPTION_IN_PAGE_ERROR			11
//#define IDS_STATUS_ILLEGAL_INSTRUCTION		12
//#define IDS_EXCEPTION_ARRAY_BOUNDS_EXCEEDED 13	
//#define IDS_EXCEPTION_FLT_DENORMAL_OPERAND	14
//#define IDS_EXCEPTION_FLT_DIVIDE_BY_ZERO	15
//#define IDS_EXCEPTION_FLT_INEXACT_RESULT	16
//#define IDS_EXCEPTION_FLT_INVALID_OPERATION 17
//#define IDS_EXCEPTION_FLT_OVERFLOW			18
//#define IDS_EXCEPTION_FLT_STACK_CHECK		19
//#define IDS_EXCEPTION_FLT_UNDERFLOW			20
//#define IDS_STATUS_NO_MEMORY				21
//#define IDS_STATUS_NONCONTINUABLE_EXCEPTION 22
//#define IDS_STATUS_INVALID_DISPOSITION		23
//#define IDS_EXCEPTION_INT_DIVIDE_BY_ZERO	24
//#define IDS_EXCEPTION_INT_OVERFLOW			25
//#define IDS_EXCEPTION_PRIV_INSTRUCTION		26
//#define IDS_STATUS_STACK_OVERFLOW			27
//#define IDS_STATUS_DLL_INIT_FAILED			28
//#define IDS_EXCEPTION_MSC_THROW				29
//#define IDS_EXCEPTION_UNKNOWN				30
//#define IDS_pstRunning						31
//#define IDS_pstStopped						32
//#define IDS_pstExited						33
//#define IDS_pstDead							34
// end of PROCEM.C strings
#define IDS_CANT_TRACE						35
#define IDS_CannotEnableORPC				36
#define IDS_FILE_NOT_FOUND					37
#define IDS_PATH_NOT_FOUND					38
#define IDS_INVALID_HANDLE					39
#define IDS_INVALID_DRIVE					40
#define IDS_INVALID_PARAMETER				41
#define IDS_INVALID_NAME					42
#define IDS_BAD_PATHNAME					43
#define IDS_FILENAME_EXCED_RANGE			44
#define IDS_OUTOFMEMORY						45
#define IDS_NOT_ENOUGH_MEMORY				46
#define IDS_ACCESS_DENIED					47
#define IDS_SHARING_VIOLATION				48
#define IDS_OPEN_FAILED						49
#define IDS_BAD_FORMAT						50
#define IDS_CHILD_NOT_COMPLETE				51
#define IDS_INVALID_MODULETYPE				52
#define IDS_INVALID_EXE_SIGNATURE			53
#define IDS_EXE_MARKED_INVALID				54
#define IDS_BAD_EXE_FORMAT					55
#define IDS_DIRECTORY						56
#define IDS_UNKNOWN_ERROR					57
#define IDS_COULD_NOT_LOAD_DEBUGGEE			58
#define IDS_EXECUTE_FAILED					59
#define IDS_EXECUTE_OK						60
#define IDS_NTError							61
#define IDS_UnknownExe						62
#define IDS_NOSQLDEBUG						63
#define	IDS_BREAK_FAILED					64
#define IDS_DEADLOCK						65
#define IDS_NO_THREAD						66

#define IDS_ERR_NOSTART                     70

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           130
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tllp.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tllp.c

Abstract:

    This implements the local transport layer for OSDebug versions
    2 and 4 on Win32.

Author:

    Jim Schaad (jimsch)
    Kent Forschmiedt (kentf)


--*/
#ifdef WIN32
#include <windows.h>
#endif

#include <stdlib.h>

#include <string.h>
#include <memory.h>



#include "odtypes.h"
#include "od.h"
#include "odp.h"
#include "odassert.h"
#include "emdm.h"

extern "C" LPDBF lpdbf = (LPDBF)0;         // the debugger helper functions

#include "tllp.h"
#include "tlutil.h"
#include <xboxdbg.h>
#include "resource.h"

extern "C" extern HINSTANCE hInstance;

#include "dbgver.h"
extern AVS Avs;

#ifndef CVWS
int _acrtused = 0;
#endif

int fReplyDM = FALSE;
int fReplyEM = FALSE;

HANDLE hevtReboot;
PDMN_SESSION psessTl;

char szLastError[512];

DWORD TlNotify(DWORD dwNotification, DWORD dwParam)
{
	if((dwNotification & DM_NOTIFICATIONMASK) == DM_EXEC)
		if(dwParam == DMN_EXEC_REBOOT)
			ResetEvent(hevtReboot);
		else
			SetEvent(hevtReboot);
	return 0;
}

#if DBG

ULONG
TEvent::Wait(
	ULONG	TimeOut	// = INFINITE
	)
/*++

Routine Description:

	Wait for the event to be signaled.  In the debug version, we do some
	deadlock checking (when waiting forever).  If we wait for longer than
	DEBUG_DEADLOCK_TIMEOUT we will assert.

--*/
{
	ULONG	ret;
	
	if (TimeOut == INFINITE)
	{
		ret = WaitForSingleObject (m_Event, DEBUG_DEADLOCK_TIMEOUT);

		assert (ret == WAIT_OBJECT_0);
	}

	return ret;
}


ULONG
TMutex::Wait(
	ULONG	TimeOut // = INFINITE
	)
/*++

Routine Description:

	See comments under TEvent::Wait ().

--*/
{
	ULONG	ret;

	if (TimeOut == INFINITE)
	{
		ret = WaitForSingleObject (m_hMutex, DEBUG_DEADLOCK_TIMEOUT);

		assert (ret == WAIT_OBJECT_0);
	}

	return ret;
}

#else

ULONG
TEvent::Wait(
	ULONG	TimeOut // = INFINITE
	)
{
	return WaitForSingleObject (m_Event, TimeOut);
}

ULONG
TMutex::Wait(
	ULONG	TimeOut // = INFINITE
	)
{
	return WaitForSingleObject (m_hMutex, TimeOut);
}

#endif

// debug monitor function definitions.

extern "C" {
void FAR PASCAL LOADDS DMInit (DMTLFUNCTYPE, LPVOID);
XOSD FAR PASCAL LOADDS TLFunc ( TLF, HPID, LPARAM, LPARAM);
XOSD FAR PASCAL LOADDS DMTLFunc ( TLF, HPID, LPARAM, LPARAM);
BOOL FAR PASCAL LOADDS DmDllInit (LPDBF);
VOID FAR PASCAL LOADDS DMFunc (DWORD, LPDBB);
}

LOCAL TLCALLBACKTYPE TLCallBack;    // central osdebug callback function

TEvent*	DmReplyEvent = NULL;
TMutex*	DmRequestMutex = NULL;
TEvent*	EmReplyEvent = NULL;
TMutex*	EmRequestMutex = NULL;


// these variables are static to prevent collisions with other TL's

static BOOL fConDM = FALSE;
static BOOL fConEM = FALSE;
static BOOL fConnected = FALSE;

static LPBYTE  	lpbDM;
static LONG 	ibMaxDM;
static DWORD	ibDM;

static LPBYTE 	lpbEM;
static LONG		ibMaxEM;
static DWORD	ibEM;


TLIS Tlis = {
    FALSE,                // fCanSetup
    0xffffffff,           // dwMaxPacket
    0xffffffff,           // dwOptPacket
    TLISINFOSIZE,         // dwInfoSize ?? what is this for ??
    FALSE,                // fRemote
#if defined(_M_IX86)
    mptix86,              // mpt
    mptix86,              // mptRemote
#elif defined(_M_MRX000)
    mptmips,              // mpt
    mptmips,              // mptRemote
#elif defined(_M_ALPHA)
    mptdaxp,              // mpt
    mptdaxp,              // mptRemote
#else
#error( "unknown target machine" );
#endif
    {  "Local Transport Layer (LOCAL:)" } // rgchInfo
};



/**** DBGVersionCheck                                                   ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *                                                                         *
 *      To export our version information to the debugger.                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *      NONE.                                                              *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Returns - A pointer to the standard version information.           *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *      Just returns a pointer to a static structure.                      *
 *                                                                         *
 ***************************************************************************/

#ifdef DEBUGVER
DEBUG_VERSION('T','L',"TCP/IP Xbox Transport Layer (Debug)")
#else
RELEASE_VERSION('T','L',"TCP/IP Xbox Transport Layer")
#endif

DBGVERSIONCHECK()



BOOL
DllVersionMatch(
    HANDLE hMod,
    LPSTR pType
    )
{
    DBGVERSIONPROC  pVerProc;
    LPAVS           pavs;

    pVerProc = (DBGVERSIONPROC)GetProcAddress((HINSTANCE)hMod, DBGVERSIONPROCNAME);
    if (!pVerProc) {
        return(FALSE);  // no version entry point
    } else {
        pavs = (*pVerProc)();

        if ((pType[0] != pavs->rgchType[0] || pType[1] != pavs->rgchType[1]) ||
          (Avs.iApiVer != pavs->iApiVer) ||
          (Avs.iApiSubVer != pavs->iApiSubVer)) {
            return(FALSE);
        }
    }

    return(TRUE);
}



XOSD
WINAPI
TLFunc (
    TLF		wCommand,
    HPID	hpid,
    LPARAM	wParam,
    LPARAM	lParam
    )

/*++

Routine Description:

    This function contains the dispatch loop for commands comming into
    the transport layer.  The address of this procedure is exported to
    users of the DLL.

Arguments:

    wCommand    - Supplies the command to be executed.
    hpid        - Supplies the hpid for which the command is to be executed.
    wParam      - Supplies information about the command.
    lParam      - Supplies information about the command.

Return Value:

    XOSD error code.  xosdNone means that no errors occured.  Other error
    codes are defined in osdebug\include\od.h.

--*/

{
    XOSD xosd = xosdNone;

    Unreferenced( hpid );

    switch ( wCommand ) {

    case tlfInit:

        lpdbf = (LPDBF) wParam;
        TLCallBack = (TLCALLBACKTYPE) lParam;
        xosd = xosdNone;
        break;

    case tlfLoadDM:

        if (DmDllInit(lpdbf) == FALSE) {
            xosd = xosdUnknown;
            break;
        }

        DMInit (DMTLFunc, (LPVOID) ((LPLOADDMSTRUCT)lParam)->lpDmParams);

        break;

    case tlfDestroy:
        break;

    case tlfGetProc:
        *((TLFUNCTYPE FAR *) lParam) = TLFunc;
        break;

    case tlfConnect:
		/* Make sure we can connect to the Xbox */
		{
			HRESULT hr;
			char szHostName[256];


			if(GetHostName(mptUnknown, szHostName, sizeof szHostName,
					lpdbf->lpfnGetSet))
				DmSetXboxName(szHostName);
			DmUseSharedConnection(TRUE);
            /* Set our conversation timeout to 60 seconds */
            DmSetConnectionTimeout(0, 60000);
			/* Get a couple of things squared away */
			if(!hevtReboot)
				hevtReboot = CreateEvent(NULL, TRUE, FALSE, NULL);
			if(!psessTl)
                /* Pass in the secret VC flag to avoid leaks */
				hr = DmOpenNotificationSession(DM_PERSISTENT | 0x20000,
                    &psessTl);
			else
				hr = XBDM_NOERR;
			if(SUCCEEDED(hr))
				hr = DmNotify(psessTl, DM_EXEC, TlNotify);
			if(FAILED(hr))
			{
				hr = DmTranslateError(hr, szLastError, sizeof(szLastError));
                if(FAILED(hr) && hr != XBDM_NOERRORSTRING)
                {
                    szLastError[0]=0;
                }
				
				xosd = xosdGeneral;
				break;
			}
			/* If a reboot in progress, wait until it's complete */
			if(WaitForSingleObject(hevtReboot, 120000) == WAIT_TIMEOUT) {
				if(!LoadString(hInstance, IDS_ERR_BOOTTIMEOUT, szLastError,
						sizeof szLastError))
					szLastError[0] = 0;
				xosd = xosdGeneral;
				break;
			}
		}

        fConEM = TRUE;
        fConnected = fConDM;
        break;

    case tlfDisconnect:
		/* You'd think we need to close our notification session here -- or
		 * in DLL_PROCESS_DETACH -- but VC unloads and reloads the tl every
		 * time a new connection is initiated, and we need to keep persistent
		 * notifications alive.  Instead, we just disconnect the tl's
		 * notification functions and keep the session open (which means the
		 * notifier's resources will stay around forever, though this is
		 * apparently not anathema to the VC resource usage scheme) */
        DmNotify(psessTl, DM_NONE, NULL);
        DmUseSharedConnection(FALSE);

        fConDM = fConnected = FALSE;
        break;

	case tlfGetLastError:
		strncpy((char *)lParam, szLastError, wParam);
		break;

    case tlfSetBuffer:

        lpbDM = (LPBYTE) lParam;
        ibMaxDM = wParam;
        break;

    case tlfReply:

        if (!fConnected)
		{
			xosd = xosdLineNotConnected;
        }
		else
		{
            if (wParam <= ibMaxEM)
			{
                _fmemcpy ( lpbEM, (LPBYTE) lParam, wParam );
                ibEM = wParam;
            }
			else
			{
                ibEM = 0;
                xosd = xosdInvalidParameter;
            }

			EmReplyEvent->Set ();
        }
        break;


    case tlfDebugPacket:

        if ( !fConnected )
		{
            xosd = xosdLineNotConnected;
        }
        else
		{
            DMFunc ( wParam, (LPDBB) lParam );
        }
        break;

    case tlfRequest:

        if ( !fConnected )
		{
			xosd = xosdLineNotConnected;
        }
		else
		{
			EmRequestMutex->Wait ();
            ibDM = 0;
			DMFunc (wParam, (LPDBB) lParam);
			DmReplyEvent->Wait ();
			EmRequestMutex->Release ();

		}
        break;

    case tlfGetVersion:     // don't need to do remote version check
        *((AVS*)lParam) = Avs;
        xosd = xosdNotRemote;
        break;


    case tlfGetInfo:

        _fmemcpy((LPTLIS)lParam, &Tlis, sizeof(TLIS));
        break;

    case tlfSetup:
        break;

    default:

        assert ( FALSE );
        break;
    }

    return xosd;
}                               /* TLFunc() */

//
// DMTLFunc is what the debug monitor will call when it has something
// to do.
//

XOSD
WINAPI
DMTLFunc (
    TLF 	wCommand,
    HPID	hpid,
    LPARAM	wParam,
    LPARAM	lParam
    )
{
    XOSD xosd = xosdNone;

    switch ( wCommand ) {

        case tlfInit:

            break;

        case tlfDestroy:

            break;

        case tlfConnect:

            fConDM = TRUE;
            fConnected = fConEM;
            break;

        case tlfDisconnect:

            fConEM = fConnected = FALSE;
            break;

        case tlfSetBuffer:

            lpbEM = (LPBYTE) lParam;
            ibMaxEM = wParam;
            break;

        case tlfReply:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
             }
			 else
			 {
                if ( wParam <= ibMaxDM )
				{
                    ibDM = wParam;
                    _fmemcpy ( lpbDM, (LPBYTE) lParam, wParam );
                }
				else
				{
                    ibDM = 0;
                }

				DmReplyEvent->Set ();
				
            }
            break;

        case tlfDebugPacket:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
            }
			else
			{
                TLCallBack ( hpid, wParam, lParam );
            }
            break;

        case tlfRequest:
		
            if (!fConnected)
			{
                xosd = xosdLineNotConnected;
            }
			else
			{

				DmRequestMutex->Wait ();
                TLCallBack (hpid, wParam, lParam );
				EmReplyEvent->Wait ();
				DmRequestMutex->Release ();

                if (ibEM == 0)
				{
                    xosd = xosdInvalidParameter;
                }
            }
            break;

        default:

            assert ( FALSE );
            break;
    }

    return xosd;

}

extern "C"
int
WINAPI
TlDllMain(
    HINSTANCE	hModule,
    DWORD 		dwReason,
    DWORD 		dwReserved
    )
{
	switch (dwReason)
	{
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
                break;

        case DLL_PROCESS_ATTACH:

			DisableThreadLibraryCalls (hModule);

			DmReplyEvent = new TEvent;
			DmReplyEvent->Create ();
			
			DmRequestMutex = new TMutex;
			DmRequestMutex->Create ();
			
			EmReplyEvent = new TEvent ;
			EmReplyEvent->Create ();
			
			EmRequestMutex = new TMutex;
			EmRequestMutex->Create ();
			
            break;

        case DLL_PROCESS_DETACH:

			delete DmReplyEvent;
			delete DmRequestMutex;
			delete EmReplyEvent;
			delete EmRequestMutex;
            break;
    }
		
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\step.c ===
#include "precomp.h"
#pragma hdrstop

extern DMTLFUNCTYPE DmTlFunc;

extern DEBUG_EVENT  falseSSEvent;
extern METHOD       EMNotifyMethod;

extern BYTE abEMReplyBuf[];
extern HINSTANCE hInstance; // The DM DLLs hInstance

extern CRITICAL_SECTION csThreadProcList;

BOOL
IsPassingException(
    HPRCX   hprc
    )
/*++

Routine Description:

    TRUE if there is an exception and we are passing it on to the app.  This
    routine looks at the exception status of the thread we got the debug event
    on.  It doesn't make sense to look at any other thread.

--*/
{
    HTHDX   hthd = HTHDXFromPIDTID (hprc->pid, hprc->lastTidDebugEvent);

	if (hthd == NULL) {
		return FALSE;
	}
	
    return ((hthd->tstate & (ts_first | ts_second)) && !hthd->fExceptionHandled);
}

void
ThreadContinueDebugEventEx(
    HTHDX   hthd,
    ULONG   QtContinue
    )
/*++

Routine Description:

    This function marks the thread as running again and queues the correct
    continue event (depending on if we are processing exceptions or not).

--*/
{
    ULONG   ContinueCmd;
    HTHDX   hthdT;

    if (IsPassingException (hthd->hprc)) {
        ContinueCmd = (ULONG)DBG_EXCEPTION_NOT_HANDLED;
    } else {
        ContinueCmd = (ULONG)DBG_CONTINUE;
    }

    SetDebugEventThreadState (hthd->hprc, ts_running);

    for (hthdT = hthd->hprc->hthdChild; hthdT; hthdT = hthdT->next)
        hthdT->fExceptionHandled = FALSE;

    AddQueue (QtContinue,
              hthd->hprc->pid,
              hthd->tid,
              ContinueCmd,
              0);
}


void
ThreadContinueDebugEvent(
    HTHDX   hthd
    )
{
    ThreadContinueDebugEventEx (hthd, QT_CONTINUE_DEBUG_EVENT);
}


VOID
SendDBCErrorStep(
    HPRCX hprc
    )
/*++

Routine Description:

    This function notifies the user when an invalid step command is
    attempted

Arguments:

    hprc        - Supplies the thread handle to be stepped.

Return Value:

    None.

--*/
{
    char buf[1000];
#ifndef XBOX //LOCBUG
    if (!LoadString(hInstance, IDS_CANT_TRACE, buf, sizeof(buf))) {
        assert(FALSE);
    }
#else
	strcpy(buf, "can't trace");
#endif

    SendDBCError(hprc, xosdCannotStep, buf);
} // SendDBCErrorStep



VOID
SingleStep(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval
    )
/*++

Routine Description:

    This function is used to do a single step operation on the specified
    thread.

Arguments:

    hthd        - Supplies the thread handle to be stepped.

    notify      -

    stopOnBp    - Supplies TRUE if a bp at current PC should cause a stop

    fInFuncEval - Supplies TRUE if called by the fucntion evaluation code

Return Value:

    None.

--*/
{
    ReturnStepEx( hthd, notify, stopOnBP, fInFuncEval, NULL, NULL, TRUE, TRUE);
}


VOID
SingleStepEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    BOOL fDoContinue
    )
/*++

Routine Description:

    This function is used to do a single step operation on the specified
    thread.

Arguments:

    hthd        - Supplies the thread handle to be stepped.

    notify      -

    stopOnBp    - Supplies TRUE if a bp at current PC should cause a stop

    fInFuncEval - Supplies TRUE if called by the fucntion evaluation code

    fDoContinue - Supplies TRUE if thread should be continued

Return Value:

    None.

--*/
{
    ReturnStepEx( hthd, notify, stopOnBP, fInFuncEval, NULL, NULL, fDoContinue,
                  TRUE);
}


VOID
ReturnStep(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    LPADDR addrRA,
    LPADDR addrStack
    )
/*++

Routine Description:

    This function is used to do a single step operation on the specified
    thread.

Arguments:

    hthd        - Supplies the thread handle to be stepped.

    notify      -

    stopOnBp    - Supplies TRUE if a bp at current PC should cause a stop

    fInFuncEval - Supplies TRUE if called by the fucntion evaluation code

    addrRA      -

    addrStack    -

Return Value:

    None.

--*/
{
    ReturnStepEx( hthd, notify, stopOnBP, fInFuncEval, addrRA, addrStack, TRUE, TRUE);
}


UOFFSET
GetReturnDestination(
    HTHDX   hthd
    )
/*++

Routine Description:

    Gets the destination of the return address from the current PC.

Arguments:


Return Value:


--*/
{
    ADDR    CurrentAddress;
    UOFFSET ReturnAddress   = 0;


    AddrFromHthdx (&CurrentAddress, hthd);

    assert (IsRet (hthd, &CurrentAddress));

    if (IsRet (hthd, &CurrentAddress)) {
#ifdef TARGET_i386

        ULONG   cb;

        DbgReadMemory (hthd->hprc,
                       (LPCVOID) STACK_POINTER (hthd),
                       &ReturnAddress,
                       sizeof (ReturnAddress),
                       &cb
                       );

#else

        ReturnAddress = GetNextOffset (hthd, FALSE);

#endif
    }

    return ReturnAddress;
}



VOID
ReturnStepEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    LPADDR addrRA,
    LPADDR addrStack,
    BOOL fDoContinue,
    BOOL fCheckOrpc
    )
/*++

Routine Description:

    This function is used to do a single step operation on the specified
    thread.

Arguments:

    hthd        - Supplies the thread handle to be stepped.

    notify      -

    stopOnBp    - Supplies TRUE if a bp at current PC should cause a stop

    fInFuncEval - Supplies TRUE if called by the fucntion evaluation code

    addrRA      - Supplies address to step to

    addrStack    - Supplies

    fDoContinue - Supplies TRUE if thread should be continued now

    fCheckOrpc  - Supplies TRUE if we should check for ORPC sections (and do
                  the appropiate thing if found), and FALSE to ignore ORPC
                  sections.

Return Value:

    None.

--*/
{
    ADDR                currAddr;
    ADDR                currAddrActual;
    int                 lpf = 0;
    BREAKPOINT*         bp;
    ULONG               ContinueCmd;
	BOOL                fTraceOn = TRUE;

#if 0
    //
    //  If we are stepping into an ORPC section, CheckAndSetup ... will take
    //  care of everything for us.  Just return.
    //

    if (fCheckOrpc && CheckAndSetupForOrpcSection (hthd)) {
        return;
    }
    
#endif

    //
    //  Get the current IP of the thread
    //

    AddrFromHthdx(&currAddr, hthd);
    currAddrActual = currAddr;

    bp = AtBP(hthd);

    if (!stopOnBP && !bp) {
        bp = FindBP(hthd->hprc, hthd, bptpExec, (BPNS)-1, &currAddr, FALSE);
        SetBPFlag(hthd, bp);
    }

    //
    //  Check if we are on a BP
    //
    if (bp == EMBEDDED_BP) {

        DPRINT(3, ("-- At embedded BP, skipping it.\n"));

        //
        //  If it isnt a BP we set then just increment past it
        //  & pretend that a single step actually took place
        //


        ClearBPFlag(hthd);
        hthd->fIsCallDone = FALSE;
        if (addrRA == NULL) {
            IncrementIP(hthd);
            NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);
        } else {
            AddrFromHthdx(&hthd->addrFrom, hthd);
            IncrementIP(hthd);
            hthd->fReturning = TRUE;
            SetupReturnStep(hthd, fDoContinue, addrRA, addrStack);
        }

    } else if (bp) {

        RestoreInstrBP(hthd, bp);
        /* Need to keep this bp alive until we're done */
        ++bp->cthd;
        ClearBPFlag(hthd);

        //
        // Issue the single step command
        //

        if (!addrRA) {
            RegisterExpectedEvent(hthd->hprc,
                                  hthd,
                                  EXCEPTION_DEBUG_EVENT,
                                  (DWORD)EXCEPTION_SINGLE_STEP,
                                  notify,
                                  SSActionReplaceByte,
                                  FALSE,
                                  bp);

            SetupSingleStep(hthd, TRUE, TRUE);
        } else {
            // Step over the bp and then continue.
            RegisterExpectedEvent(hthd->hprc,
                                    hthd,
                                    EXCEPTION_DEBUG_EVENT,
                                    (DWORD)EXCEPTION_SINGLE_STEP,
                                    DONT_NOTIFY,
                                    (ACVECTOR) SSActionRBAndContinue,
                                    FALSE,
                                    bp);

            SetupSingleStep(hthd, FALSE, TRUE);
            AddrFromHthdx(&hthd->addrFrom, hthd);
            hthd->fReturning = TRUE;
            SetupReturnStep(hthd, fDoContinue, addrRA, addrStack);
        }

    } else {    // bp == NULL

        //
        // Determine if the current instruction is a breakpoint
        //  instruction.  If it is then based on the stopOnBP flag we either
        //  execute to hit the breakpoint or skip over it and create a
        //  single step event
        //

        IsCall(hthd, &currAddr, &lpf, FALSE);

        if (lpf == INSTR_CANNOT_STEP) {
            SendDBCErrorStep(hthd->hprc);
            return;
        }

        if (lpf == INSTR_BREAKPOINT) {

            if (stopOnBP) {
                /*
                 * We were instructed to stop on breakpoints
                 * Just issue an execute command and execute
                 * the breakpoint.
                 */

                ThreadContinueDebugEvent (hthd);
            } else {
                /*
                 * else just increment past it
                 * & pretend that a single step actually took place
                 */

                DPRINT(3, ("    At an embedded bp -- ignoring\n\r"));

                IncrementIP(hthd);

                hthd->fIsCallDone = FALSE;
                ClearBPFlag(hthd);
                if (notify) {
                    (notify->notifyFunction)(&falseSSEvent,
                                             hthd,
                                             0,
                                             notify->lparam);
                } else {
                    NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);
                }
            }

        } else {


            if (lpf == INSTR_CANNOT_TRACE) {

				if (!addrRA) {
                     bp = SetBP( hthd->hprc,
                                 hthd,
                                 bptpExec,
                                 bpnsStop,
                                 &currAddr,
                                 (HPID) INVALID);
                     bp->isStep = TRUE;
					 fTraceOn   = FALSE;
				}

            }


            //
            // Place this on our list of expected events
            //

            RegisterExpectedEvent(hthd->hprc,
                                  hthd,
                                  EXCEPTION_DEBUG_EVENT,
                                  (DWORD)EXCEPTION_SINGLE_STEP,
                                  notify,
                                  NO_ACTION,
                                  FALSE,
                                  NULL);

            //
            // Issue the single step command
            //

            if (!addrRA) {
                if (hthd->fDisplayReturnValues && 
                    IsRet (hthd, &currAddrActual) 
                    // && !CheckNLG (hthd -> hprc, hthd, NLG_RETURN, &currAddrActual)
                    ) {
                    //
                    // If we're supposed to be fetching the return value,
                    // Record the current address in hthd -> addrFrom and 
                    // NotifyEM will get it displayed.
                    //

                    AddrFromHthdx(&hthd->addrFrom, hthd);
                    NotifyEM(&FuncExitEvent, hthd, 0, &currAddrActual);
                }

                SetupSingleStep(hthd, TRUE, fTraceOn);
            } else {
                AddrFromHthdx(&hthd->addrFrom, hthd);
                hthd->fReturning = TRUE;
                SetupReturnStep(hthd, fDoContinue, addrRA, addrStack);
            }
        }
    }

    return;
}                               /* ReturnStepEx() */



void
IncrementIP(
    HTHDX hthd
    )
{
    PC(hthd) += BP_SIZE;
    assert(hthd->tstate & ts_stopped);
    hthd->fContextDirty = TRUE;

    return;
}                               /* IncrementIP() */




void
DecrementIP(
    HTHDX hthd
    )
{
    // M00BUG -- two byte version of int 3

    PC(hthd) -= BP_SIZE;
    assert(hthd->tstate & ts_stopped);
    hthd->fContextDirty = TRUE;

    return;
}                               /* DecrementIP() */


VOID
MoveIPToException(
    HTHDX hthd,
    LPDEBUG_EVENT pde
    )
/*++

Routine Description:

    This function moves the EIP for a thread to where an exception occurred.
    This is primarily used for breakpoints.  There are two advantages of
    this over simply decrementing the IP: (1) its CPU-independent, and
    (2) it helps work around an NT bug.  The NT bug is, if an app which is
    NOT being debugged has a hard-coded INT 3, and the user starts post-
    mortem debugging, then when NT gives us the INT 3 exception, it will
    give us the wrong EIP: it gives us the address of the INT 3, rather
    than one byte past that.  But it gives us the correct ExceptionAddress.

Arguments:


Return Value:

    None

--*/

{
    PC(hthd) = (DWORD) EXADDR(pde);
    assert(hthd->tstate & ts_stopped);
    hthd->fContextDirty = TRUE;
}




VOID
StepOver(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval
    )
{
    StepOverEx (hthd, notify, stopOnBP, fInFuncEval, TRUE);
}



VOID
StepOverEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    BOOL fCheckOrpc
    )
/*++

Routine Desription:


Arguments:

    fCheckOrpc - Supplies TRUE if we should check for ORPC sections; FALSE if
                 the step function should ignore ORPC sections (treat them as
                 normal code).

Return Value:


--*/
{
    ADDR        currAddr;
    int         lpf = 0;
    BREAKPOINT  *bp, *atbp;
    HPRCX       hprc=hthd->hprc;
    METHOD      *method;

    DPRINT(3, ("** SINGLE STEP OVER  "));

#if 0
    //
    //      if we are stepping into an ORPC section, the following function will
    //      take care of everythging for us and return TRUE.  Just return.
    //

    if (fCheckOrpc && CheckAndSetupForOrpcSection (hthd)) {
        return;
    }
#endif // !KERNEL

    //
    //  Get the current IP of the thread
    //

    AddrFromHthdx(&currAddr, hthd);

    //
    //  Determine what type of instruction we are presently on
    //

    IsCall(hthd, &currAddr, &lpf, TRUE);

    //
    //  If the instruction is not a call or an intrpt then do a SS
    //

    if (lpf == INSTR_TRACE_BIT) {

        ReturnStepEx (hthd,
                      notify,
                      stopOnBP,
                      fInFuncEval,
                      NULL,
                      NULL,
                      TRUE,
                      fCheckOrpc);

        return;
    } else if (lpf == INSTR_CANNOT_STEP) {
        SendDBCErrorStep(hthd->hprc);
        return;
    }

        ExprBPContinue(hthd->hprc, hthd);

    //
    //  If the instruction is a BP then "uncover" it
    //

    if (lpf == INSTR_BREAKPOINT) {

        DPRINT(5, ("  We have hit a breakpoint instruction\n\r"));

        if (stopOnBP) {
            /*
            **  We were instructed to stop on breakpoints
            **  Just issue an execute command and execute
            **  the breakpoint.
            */

            ThreadContinueDebugEvent (hthd);

        } else {

            IncrementIP(hthd);
            hthd->fIsCallDone = FALSE;
            ClearBPFlag(hthd);
            if (notify) {
                (notify->notifyFunction)(&falseSSEvent, hthd, 0, notify->lparam);
            } else {
                NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);
            }
        }

    } else {

        /*
        **  If control gets to this point, then the instruction
        **  that we are at is either a call or an interrupt.
        */
        BOOL fDisplayReturnValues = hthd->fDisplayReturnValues && notify->lparam;

        atbp = AtBP(hthd);
        if (!stopOnBP && !atbp) {
            ADDR AddrPC;

            AddrFromHthdx(&AddrPC, hthd);
            atbp = FindBP(hthd->hprc, hthd, bptpExec, (BPNS)-1, &AddrPC, FALSE);
            SetBPFlag(hthd, atbp);
        }

        if (atbp) {
            /*
            ** Put the single step on our list of expected
            ** events and set the action to "Replace Byte and Continue"
            ** without notifying the EM
            */


            RestoreInstrBP(hthd, atbp);
            ClearBPFlag(hthd);

            //
            // We don't want to Continue automatically when return values are
            // being displayed because we need to note the addr the Call is
            // going to after all the thunk walking is done.
            //
            if (!fDisplayReturnValues) {
                RegisterExpectedEvent(hthd->hprc,
                                        hthd,
                                        EXCEPTION_DEBUG_EVENT,
                                        (DWORD)EXCEPTION_SINGLE_STEP,
                                        DONT_NOTIFY,
                                        (ACVECTOR) SSActionRBAndContinue,
                                        FALSE,
					atbp);
                /*
                **  Issue the single step
                */

                if (lpf != INSTR_CANNOT_TRACE) {
                    SetupSingleStep(hthd, FALSE, TRUE);
                }
            }
        }

        if (lpf == INSTR_IS_CALL || lpf == INSTR_CANNOT_TRACE) {

			RANGESTEP *rs = NULL;
			
			//
            // Set a BP after this call instruction.
            //

            bp = SetBP (hprc, hthd, bptpExec, bpnsStop, &currAddr, (HPID)INVALID);

			assert(bp);

            //
            //  Make a copy of the notification method.
            //

            method  = (METHOD*)MHAlloc(sizeof(METHOD));
            *method = *notify;

            //
            //  Store the breakpoint with this notification method
            //

            method->lparam2 = (LPVOID)bp;


			//
            // On a step over, we want to get back to the same frame.
            // The EBP is saved across functions (even if it's not the FP)
            // So it will be the same when the safety BP is hit - if not
            // we are defintely on the wrong frame
            // ALPHA NOTE: If you set SavedEBP to 0 then this will default
            // to the old behavior.
			//

			//
			// BUGBUG: by casting method->lparam to a RANGESTEP* you assume
			// this is being called by MethodRangeStep or RangeStep.  This
			// IS NOT IN GENERAL TRUE. WE MUST FIX THIS.
			//


			//
			// NOTE: in addition we only use the frame-based BP when we are not
			// in a prolog.  This allows EBP-modifying helper functions to get
			// called in the prolog.  The EH_prolog function, which is called
			// when using C++ exceptions and optimizing /Os is an example of
			// this.
			//
			
			rs = (RANGESTEP*) method->lparam;

			if (rs) {
				ADDR	EIP = {0};
				CANSTEP	CanStep = {0};

				AddrFromHthdx (&EIP, hthd);
				
				GetCanStep (hprc->hpid, hthd->htid, &EIP, &CanStep);

				if (CanStep.Flags == CANSTEP_YES && CanStep.PrologOffset) {
					rs->SavedEBP = 0;
				} else {
					rs->SavedEBP = FRAME_POINTER (hthd);
				}
			}

            if (fDisplayReturnValues && lpf == INSTR_IS_CALL) {

                ACVECTOR action = NO_ACTION;
                LPVOID lParam = NULL;
                RANGESTEP* rs = method->lparam;   // ??? OK?

                rs->fGetReturnValue = TRUE;
                rs->safetyBP = bp;

                if ( atbp ) {
                    ++atbp->cthd;
                    action = SSActionReplaceByte;
                    lParam = atbp;
                }

                assert (!hthd->fReturning);

                RegisterExpectedEvent(
                    hthd->hprc,
                    hthd,
                    EXCEPTION_DEBUG_EVENT,
                    (DWORD)EXCEPTION_SINGLE_STEP,
                    method,
                    action,
                    FALSE,
                    lParam);

                RegisterExpectedEvent(hthd->hprc,
                        hthd,
                        BREAKPOINT_DEBUG_EVENT,
                        (DWORD)bp,
                        method,
                        action,
                        FALSE,
                        lParam);
                
                SetupSingleStep (hthd, TRUE, TRUE);

                return;
            }

            /*
            ** Place this on our list of expected events
            ** (Let the action function do the notification, other-
            ** wise the EM will receive a breakpoint notification,
            ** rather than a single step notification).NOTE:
            ** This is the reason why we make a copy of the notif-
            ** ication method -- because the action function must
            ** know which notification method to use, in addition
            ** to the breakpoint that was created.
            */
			

            RegisterExpectedEvent(hthd->hprc,
                    hthd,
                    BREAKPOINT_DEBUG_EVENT,
                    (DWORD)bp,
                    DONT_NOTIFY,
                    (ACVECTOR) SSActionStepOver,
                    FALSE,
                    method);


            DPRINT(7, ("PID= %lx  TID= %lx\n", hprc->pid, hthd->tid));

        }


        /*
        **  Issue the execute command
        */

        ThreadContinueDebugEvent (hthd);

        //
        // If we hit a DIFFERENT BP while we are in the called routine we
        // must clear this (and ALL other consumable events) from the
        // expected event queue.
        //

    }
    return;
}                               /* StepOver() */



void
SSActionRemoveBP(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    METHOD* method
    )
/*++

Routine Description:

    This action function is called upon the receipt of a breakpoint
    event in order to remove the breakpoint and fake a single step event.
    Note that the lparam to this action function must be a METHOD* and
    the BREAKPOINT* to remove must be stored in the lparam2 field of the
    method.

Arguments:


Return Value:


--*/
{
    BREAKPOINT* bp = (BREAKPOINT*)method->lparam2;

    Unreferenced( de );

    DEBUG_PRINT("** SS Action Remove BP called\n");

	// Remove the temporary breakpoint
    RemoveBP(bp);

    // Notify whoever is concerned, that a SS event has occured
    (method->notifyFunction)(&falseSSEvent, hthd, 0, method->lparam);

    // Free the temporary notification method.
    MHFree(method);
}

void
SSActionStepOver(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    METHOD* method
    )
/*++

Routine Description:

    This action function is called upon the receipt of a breakpoint
    event in order to remove the breakpoint and fake a single step event.

  	This version has been modified to make stepover work.
	In the case of a step over - if the function is recursive we want to stop on
	the correct frame.

    Note that the lparam to this action function must be a METHOD* and
    the BREAKPOINT* to remove must be stored in the lparam2 field of the
    method.

Arguments:


Return Value:


--*/
{
    BREAKPOINT* bp = (BREAKPOINT*)method->lparam2;
	RANGESTEP *rs= (RANGESTEP *)method->lparam;

    Unreferenced( de );

	//
    // What if SavedEBP is not the frame pointer? Retail? Retail w/o FPO?
    // OK here goes the thinking:
    // EBP may not be the frame pointer - but it is guaranteed across
    // function calls - even in retail - so when we hit the safety BP
    // it must be equal to the SavedEBP
	//
    // Use of the FRAME_POINTER macro is to allow this to compile on Alpha
    // however I'm not convinced this algorithm will work for the Alpha.
	//
    // If there is no rs structure we are stepping in disassembly
    // we still use the old algorithm.
	//

	if (!rs || rs->SavedEBP <= FRAME_POINTER(hthd)) {

		DbgTrace ((TR_RANGESTEP, "SSActionStepOver: hit BP.  Notifying.\n"));
		
		DEBUG_PRINT("** SS Action Remove BP called\n");

		RemoveBP(bp);
		(method->notifyFunction)(&falseSSEvent, hthd, 0, method->lparam);
		MHFree(method);

	} else {

		//
        // We have hit the safety BP in a recursive instance of a call
        // Therefore we are not really at the end of the rangestep.
        // restore the bp, do a step, then run.
        //

		METHOD*	ContinueSOMethod = NULL;

		DbgTrace ((TR_RANGESTEP,
				   "SSActionStepOver: hit BP in recursive instance\n"
				   ));
		
        ContinueSOMethod = (METHOD*) MHAlloc(sizeof(METHOD));
        ContinueSOMethod->notifyFunction = (ACVECTOR)MethodContinueSS;
        ContinueSOMethod->lparam = ContinueSOMethod;
        ContinueSOMethod->lparam2 = bp;
        if(bp && bp != EMBEDDED_BP)
            ++bp->cthd;
        ClearBPFlag(hthd);
		RestoreInstrBP(hthd, bp);

		//
		// Reenable
		
        RegisterExpectedEvent(hthd->hprc, hthd,
                              BREAKPOINT_DEBUG_EVENT,
                              (DWORD) bp,
                              DONT_NOTIFY,
                              (ACVECTOR) SSActionStepOver,
                              FALSE,
                              method);

		SingleStepEx(hthd, ContinueSOMethod, FALSE, FALSE, TRUE);
	}
}


void
SSActionReplaceByte(
    DEBUG_EVENT *de,
    HTHDX hthd,
    DWORD unused,
    BREAKPOINT *bp
    )
/*++

Routine Description:

    This action function is called upon the receipt of a single step
    event in order to replace the breakpoint instruction (INT 3, 0xCC)
    that was written over.

Arguments:


Return Value:


--*/
{
    Unreferenced( de );
    Unreferenced( unused );

    /* Keep this breakpoint around */
    EnterCriticalSection(&csThreadProcList);
    /* We're only going to restore the BP if it's still in use */
    if(bp->instances) {
        if (bp->hWalk) {
            DPRINT(5, ("** SS Action Replace Byte is really a data BP\n"));
            ExprBPResetBP(hthd, bp);
        } else {
            DPRINT(5, ("** SS Action Replace Byte at %d:%04x:%08x with %x\n",
                       ADDR_IS_FLAT(bp->addr), bp->addr.addr.seg, bp->addr.addr.off, BP_OPCODE));
            WriteBreakPoint( bp );
        }
    }
    ReleaseBP(bp);
    LeaveCriticalSection(&csThreadProcList);

    return;
}



void
SSActionRBAndContinue(
    DEBUG_EVENT *de,
    HTHDX hthd,
    DWORD unused,
    BREAKPOINT *bp
    )
/*++

Routine Description:

    This action function is called upon the receipt of a single step
    event in order to replace the breakpoint instruction (INT 3, 0xCC)
    that was written over, and then continuing execution.

Arguments:


Return Value:


--*/
{
    Unreferenced( de );
    Unreferenced( unused );

    if (bp->hWalk) {
        //
        // Really a hardware BP, let walk manager fix it.
        //
        DPRINT(5, ("** SS Action RB and continue is really a data BP\n"));
        ExprBPResetBP(hthd, bp);
    } else {
        DPRINT(5, ("** SS Action RB and Continue: Replace byte @ %d:%04x:%08x with %x\n",
                    ADDR_IS_FLAT(bp->addr), bp->addr.addr.seg, bp->addr.addr.off, BP_OPCODE));

        WriteBreakPoint( bp );
    }

    ThreadContinueDebugEvent (hthd);
}


BOOL InsideRange( HTHDX, ADDR*, ADDR*, ADDR* );
BRANCH_LIST * GetBranchList ( HTHDX, ADDR*, ADDR* );
RANGESTRUCT * SetupRange ( HTHDX, ADDR*, ADDR*, BRANCH_LIST *, BOOL, BOOL, METHOD* );
VOID AddRangeBp( RANGESTRUCT*, ADDR*, BOOL );
VOID SetRangeBp( RANGESTRUCT* );
VOID RemoveRangeBp( RANGESTRUCT* );
BOOL GetThunkTarget( HTHDX, RANGESTRUCT*, ADDR*, ADDR* );

VOID RecoverFromSingleStep( ADDR*, RANGESTRUCT*);
BOOL ContinueFromInsideRange( ADDR*, RANGESTRUCT*);
BOOL ContinueFromOutsideRange( ADDR*, RANGESTRUCT*);


#if 0

BOOL
SmartRangeStep(
    HTHDX       hthd,
    UOFF32      offStart,
    UOFF32      offEnd,
    BOOL        fStopOnBP,
    BOOL        fStepOver
    )

/*++

Routine Description:

    This function is used to implement range stepping the the DM.  Range
    stepping is used to cause all instructions between a pair of addresses
    to be executed.

    The segment is implied to be the current segment.  This is validated
    in the EM.

Arguments:

    hthd      - Supplies the thread to be stepped.

    offStart  - Supplies the initial offset in the range

    offEnd    - Supplies the final offset in the range

    fStopOnBP - Supplies TRUE if stop on an initial breakpoint

    fStepOver - Supplies TRUE if to step over call type instructions

Return Value:

    TRUE if successful.  If the disassembler fails, a breakpoint cannot
    be set or other problems, FALSE will be returned, and the caller will
    fall back to the slow range step method.

--*/

{
    BRANCH_LIST  *BranchList;
    METHOD       *Method;
    RANGESTRUCT  *RangeStruct;
    ADDR         AddrStart;
    ADDR         AddrEnd;

    //
    //  Initialize start and end addresses
    //

    AddrInit(&AddrStart, 0, PcSegOfHthdx(hthd), offStart,
                hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal);

    AddrInit(&AddrEnd, 0, PcSegOfHthdx(hthd), offEnd,
                hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal);



    //
    //  Locate all the branch instructions inside the range (and their
    //  targets if available) and obtain a branch list.
    //
    BranchList  = GetBranchList( hthd, &AddrStart, &AddrEnd );

    if (!BranchList) {
        return FALSE;
    }

    //
    //  Setup range step method
    //
    Method = (METHOD*)MHAlloc(sizeof(METHOD));
    assert( Method );

    Method->notifyFunction  = (ACVECTOR)MethodSmartRangeStep;

    //
    //  Set up the range structure (this will set all safety breakpoints).
    //
    RangeStruct = SetupRange( hthd, &AddrStart, &AddrEnd, BranchList,
                                             fStopOnBP, fStepOver, Method );
    if (!RangeStruct) {
        MHFree(BranchList);
        return FALSE;
    }

    //
    //  Now let the thread run.
    //

    ThreadContinueDebugEvent (hthd);

#ifdef KERNEL
    hthd->tstate |= ts_stepping;
#endif

    return TRUE;
}
#endif


BOOL
InsideRange(
    HTHDX   hthd,
    ADDR   *AddrStart,
    ADDR   *AddrEnd,
    ADDR   *Addr
    )
{
    ADDR    AddrS;
    ADDR    AddrE;
    ADDR    AddrC;

    assert( AddrStart );
    assert( AddrEnd );
    assert( Addr );

    if ( ADDR_IS_LI(*Addr) ) {
        return FALSE;
    }

    AddrS = *AddrStart;
    AddrE = *AddrEnd;
    AddrC = *Addr;

    if (!ADDR_IS_FLAT(AddrS)) {
        if ( !TranslateAddress(hthd->hprc, hthd, &AddrS, TRUE) ) {
            return FALSE;
        }
    }

    if (!ADDR_IS_FLAT(AddrE)) {
        if ( !TranslateAddress(hthd->hprc, hthd, &AddrE, TRUE) ) {
            return FALSE;
        }
    }

    if (!ADDR_IS_FLAT(AddrC)) {
        if ( !TranslateAddress(hthd->hprc, hthd, &AddrC, TRUE) ) {
            return FALSE;
        }
    }

    if ( GetAddrOff( AddrC ) >= GetAddrOff( AddrS ) &&
                            GetAddrOff( AddrC ) <= GetAddrOff( AddrE ) ) {

        return TRUE;
    }

    return FALSE;
}


#if 0
BRANCH_LIST *
GetBranchList (
    HTHDX   hthd,
    ADDR   *AddrStart,
    ADDR   *AddrEnd
    )
/*++

Routine Description:

    Locates all the branch instructions within a range and builds a
    branch list.

Arguments:

    hthd        -   Supplies thread

    AddrStart   -   Supplies start of range

    AddrEnd     -   Supplies end of range

Return Value:

    BRANCH_LIST *   -   Pointer to branch list.

--*/
{
    void        *Memory;
    BRANCH_LIST *BranchList = NULL;
    BRANCH_LIST *BranchListTmp;
    DWORD        RangeSize;
    LONG         Length;
    BYTE        *Instr;
    DWORD        ListSize;
    DWORD        i;
    ADDR         Addr;

    assert( AddrStart );
    assert( AddrEnd );

    RangeSize  =  GetAddrOff(*AddrEnd) - GetAddrOff(*AddrStart) + 1;

    //
    //  Read the code.
    //
    Memory = MHAlloc( RangeSize );
    assert( Memory );

    if (!Memory) {
        return NULL;
    }

    //
    //  Allocate and initialize the branch list structure
    //
    ListSize   = sizeof( BRANCH_LIST );
    BranchList = (BRANCH_LIST *)MHAlloc( ListSize );

    assert( BranchList );

    if (!BranchList) {
        MHFree(Memory);
        return NULL;
    }

    BranchList->AddrStart = *AddrStart;
    BranchList->AddrEnd   = *AddrEnd;
    BranchList->Count     = 0;


    Addr = *AddrStart;

    AddrReadMemory(hthd->hprc, hthd, &Addr, Memory, RangeSize, &Length );
#ifndef KERNEL
    assert(Length==(LONG)RangeSize);
#endif
    //
    // If the code crosses a page boundary and the second
    // page is not present, the read will be short.
    // Fail, and we will fall back to the slow step code.
    //

    if (Length != (LONG)RangeSize) {
        MHFree(BranchList);
        MHFree(Memory);
        return NULL;
    }


    //
    //  Unassemble the code and determine where all branches are.
    //
    Instr  = (BYTE *)Memory;

    while ( Length > 0 ) {

        BOOL    IsBranch;
        BOOL    TargetKnown;
        BOOL    IsCall;
        BOOL    IsTable;
        ADDR    Target;
        DWORD   Consumed;

        //
        //  Unassemble one instruction
        //
        Consumed = BranchUnassemble(hthd,
                                    (void *)Instr,
                                    Length,
                                    &Addr,
                                    &IsBranch,
                                    &TargetKnown,
                                    &IsCall,
                                    &IsTable,
                                    &Target );

        assert( Consumed > 0 );
        if ( Consumed == 0 ) {

            //
            //  Could not unassemble the instruction, give up.
            //

            MHFree(BranchList);
            BranchList = NULL;
            Length = 0;

        } else {

            if (IsBranch && IsTable &&
                    InsideRange(hthd, AddrStart, AddrEnd, &Target)) {

                //
                // this is a vectored jump with the table included
                // in the source range.  Rather than try to figure
                // out what we can and cannot disassemble, punt
                // here and let the slow step code catch it.
                //

                MHFree(BranchList);
                BranchList = NULL;
                Length = 0;

            } else if ( IsBranch ) {

                //
                //  If instruction is a branch, and the branch falls outside
                //  of the range, add a branch node to the list.
                //

                BOOLEAN fAdded = FALSE;

                if ( TargetKnown ) {
                    if ( ADDR_IS_FLAT(Target) ) {
                        if ( GetAddrOff(Target) != 0 ) {
                            GetAddrSeg(Target) = PcSegOfHthdx(hthd);
                        }
                    } else {
                        ADDR_IS_REAL(Target) = (BYTE)hthd->fAddrIsReal;
                    }
                }

                if ( !InsideRange( hthd, AddrStart, AddrEnd, &Target ) ||
                                                            !TargetKnown ) {

                    //
                    // this loop is to ensure that we dont get duplicate
                    // breapoints set
                    //
                    for (i=0; i<BranchList->Count; i++) {

                        if ( TargetKnown &&
                        FAddrsEq( BranchList->BranchNode[i].Target, Target ) ) {
                            break;
                        }
                    }

                    if (i == BranchList->Count) {
                        ListSize += sizeof( BRANCH_NODE );
                        BranchListTmp = (BRANCH_LIST *)MHRealloc( BranchList,
                                                                ListSize );
                        assert( BranchListTmp );
                        BranchList = BranchListTmp;

                        BranchList->BranchNode[ BranchList->Count ].TargetKnown=
                                                                   TargetKnown;
                        BranchList->BranchNode[ BranchList->Count ].IsCall =
                                                                   IsCall;
                        BranchList->BranchNode[ BranchList->Count ].Addr   =
                                                                   Addr;
                        BranchList->BranchNode[ BranchList->Count ].Target =
                                                                   Target;

                        BranchList->Count++;

                        fAdded = TRUE;
                    }
                }

#if defined(TARGET_MIPS)
                //
                //  If the delay slot falls outside the range, add
                //  the branch to the list no matter what the target.
                //
                if ( !fAdded && GetAddrOff(Addr) + 4 > GetAddrOff(*AddrEnd) ) {
                    ListSize += sizeof( BRANCH_NODE );
                    BranchListTmp = (BRANCH_LIST *)MHRealloc( BranchList,
                                                            ListSize );
                    assert( BranchListTmp );
                    BranchList = BranchListTmp;

                    BranchList->BranchNode[ BranchList->Count ].TargetKnown =
                                                                   TargetKnown;
                    BranchList->BranchNode[ BranchList->Count ].IsCall      =
                                                                   IsCall;
                    BranchList->BranchNode[ BranchList->Count ].Addr        =
                                                                   Addr;
                    BranchList->BranchNode[ BranchList->Count ].Target      =
                                                                   Target;

                    BranchList->Count++;
                }
#endif
            }

            Instr            += Consumed;
            GetAddrOff(Addr) += Consumed;
            Length           -= Consumed;
        }
    }

    MHFree( Memory );

    return BranchList;
}
#endif


RANGESTRUCT *
SetupRange (
    HTHDX        hthd,
    ADDR        *AddrStart,
    ADDR        *AddrEnd,
    BRANCH_LIST *BranchList,
    BOOL         fStopOnBP,
    BOOL         fStepOver,
    METHOD      *Method
    )
/*++

Routine Description:

    Helper function for RangeStep.

Arguments:

    hthd        -   Supplies thread

    AddrStart   -   Supplies start of range

    AddrEnd     -   Supplies end of range

    BranchList  -   Supplies branch list

    fStopOnBP   -   Supplies fStopOnBP flag

    fStepOver   -   Supplies fStepOver flag

Return Value:

    RANGESTRUCT *   -   Pointer to range structure

--*/
{
    RANGESTRUCT *RangeStruct;
    BREAKPOINT  *Bp;
    DWORD        i;
    BOOLEAN      fAddedAtEndOfRange = FALSE;
    ADDR         Addr;
    CANSTEP      CanStep;
    DWORD        dwOffset;
    DWORD        dwSize;
    DWORD        dwPC;


    assert( AddrStart );
    assert( AddrEnd );
    assert( BranchList );
    assert( Method );

    //
    //  Allocate and initialize the range structure
    //
    RangeStruct = (RANGESTRUCT *)MHAlloc( sizeof(RANGESTRUCT) );
    assert( RangeStruct );

    RangeStruct->hthd        = hthd;
    RangeStruct->BranchList  = BranchList;
    RangeStruct->fStepOver   = fStepOver;
    RangeStruct->fStopOnBP   = fStopOnBP;
    RangeStruct->BpCount     = 0;
    RangeStruct->BpAddrs     = NULL;
    RangeStruct->BpList      = NULL;
    RangeStruct->fSingleStep = FALSE;
    RangeStruct->fInCall     = FALSE;
    RangeStruct->Method      = Method;

    Method->lparam           = RangeStruct;


    //
    //  If the given range has branches, set branch breakpoints according to
    //  the fStepOver flag.
    //
    if ( BranchList->Count > 0 ) {

        if ( fStepOver ) {

            //
            //  Ignore calls (Were stepping over them), set BPs in all
            //  known target (if outside of range) and all branch instructions
            //  with unknown targets.
            //
            for ( i=0; i < BranchList->Count; i++ ) {

#if defined(TARGET_MIPS)
                //
                //  If delay slot is outside range, set breakpoint at next
                //  instruction after delay slot (i.e. the return address)
                //
                if ( GetAddrOff(BranchList->BranchNode[i].Addr) + 4 > GetAddrOff(*AddrEnd) ) {
                    ADDR Addr = BranchList->BranchNode[i].Addr;
                    GetAddrOff(Addr) += 8;
                    AddRangeBp( RangeStruct, &Addr, FALSE );
                    fAddedAtEndOfRange = TRUE;
                }
#endif
                if ( !BranchList->BranchNode[i].IsCall ) {
                    if ( !BranchList->BranchNode[i].TargetKnown ) {

                        AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Addr, FALSE );

                    } else if ( !InsideRange( hthd, AddrStart, AddrEnd, &BranchList->BranchNode[i].Target ) ) {

                        AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Target, FALSE );
                    }
                }
            }

        } else {

            //
            //  Set BPs in all branches/calls with unknown targets, all
            //  branch targets (if outside of range) and all  call targets
            //  for which we have source.
            //
            for ( i=0; i < BranchList->Count; i++ ) {

#if defined(TARGET_MIPS)
                //
                //  If delay slot is outside range, set breakpoint at next
                //  instruction after delay slot (i.e. the return address)
                //
                if ( GetAddrOff(BranchList->BranchNode[i].Addr) + 4 > GetAddrOff(*AddrEnd) ) {
                    ADDR Addr = BranchList->BranchNode[i].Addr;
                    GetAddrOff(Addr) += 8;
                    AddRangeBp( RangeStruct, &Addr, FALSE );
                    fAddedAtEndOfRange = TRUE;
                }
#endif
                if ( !BranchList->BranchNode[i].TargetKnown ) {

                    AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Addr, FALSE );

                } else if ( !InsideRange( hthd, AddrStart, AddrEnd, &BranchList->BranchNode[i].Target ) ) {

                    if ( !BranchList->BranchNode[i].IsCall ) {

                        AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Target, FALSE );

                    } else {

                        //
                        //  BUGBUG - If debugging WOW, we dont set a
                        //  breakpoint in a function prolog, instead we set the
                        //  breakpoint in the call instruction and single step
                        //  to the function.
                        //
                        if (!ADDR_IS_FLAT(BranchList->BranchNode[i].Addr) ) {

                            AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Addr, FALSE );

                        } else {

                            //
                            // Dont look for source lines until we hit the call target.
                            //
                            // If the call target is a thunk, we might not be able to interpret
                            // it until the thread is sitting on it.  Therefore, we always have
                            // to stop at the call target, so there is no point in looking now
                            // to see whether there is source data for it until we get there.
                            //

                            //
                            // Walk thunks, as far as we can.
                            //

                            dwPC = GetAddrOff(BranchList->BranchNode[i].Target);
                            while (IsThunk(hthd, dwPC, NULL, &dwPC, NULL )) {
                                GetAddrOff(BranchList->BranchNode[i].Target) = dwPC;
                            }

                            AddRangeBp( RangeStruct, &BranchList->BranchNode[i].Target, FALSE );

                        }
                    }
                }
            }
        }
    }

    if ( !fAddedAtEndOfRange ) {
        //
        //  We always set a safety breakpoint at the instruction past the end
        //  of the range.
        //
        ADDR Addr = *AddrEnd;
        GetAddrOff(Addr) += 1;
        AddRangeBp( RangeStruct, &Addr, FALSE );
    }

    //
    //  If we currently are at a BP and the address is not already in the
    //  list, then we must setup a single step for the instruction.
    //
    Bp = AtBP(hthd);

    if ( Bp == EMBEDDED_BP ) {

        //
        // we must step off the harcoded bp
        //

        ClearBPFlag( hthd );
        IncrementIP( hthd );
        hthd->fIsCallDone = FALSE;

    } else if ( Bp ) {

        //
        //  Make sure that the BP is not in the list
        //
        for ( i=0; i<RangeStruct->BpCount; i++ ) {
            if ( FAddrsEq( RangeStruct->BpAddrs[i], Bp->addr )) {
                break;
            }
        }

        if ( i >= RangeStruct->BpCount ) {
            //
            //  We have to single step the breakpoint.
            //
            ClearBPFlag( hthd );
            RestoreInstrBP( RangeStruct->hthd, Bp );
            RangeStruct->PrevAddr  = Bp->addr;
            RangeStruct->fSingleStep = TRUE;

            //
            //  Set the fInCall flag so that the stepping method knows whether
            //  or not it should stop stepping in case we get out of the range.
            //
            for ( i=0; i < RangeStruct->BranchList->Count; i++ ) {
                if ( FAddrsEq( Bp->addr,
                               RangeStruct->BranchList->BranchNode[i].Addr ) ) {
                    RangeStruct->fInCall =
                                 RangeStruct->BranchList->BranchNode[i].IsCall;
                    break;
                }
            }

#ifdef TARGET_i386

#ifndef KERNEL
            HthdReg(RangeStruct->hthd,EFlags) |= TF_BIT_MASK;
            RangeStruct->hthd->fContextDirty = TRUE;
#endif

#else   // i386
            {
                ADDR         Addr;
                UOFF32       NextOffset;

                NextOffset = GetNextOffset( hthd, RangeStruct->fStepOver );

#ifndef KERNEL
                if ( NextOffset != 0x00000000 ) {
                    AddrInit( &Addr, 0, 0, NextOffset, TRUE, TRUE, FALSE, FALSE );
                    RangeStruct->TmpAddr = Addr;
                    RangeStruct->TmpBp = SetBP( RangeStruct->hthd->hprc,
                                                RangeStruct->hthd,
                                                bptpExec,
                                                bpnsStop,
                                                &Addr,
                                                (HPID) INVALID);
                }
                assert( RangeStruct->TmpBp );

#else   // KERNEL


                AddrInit( &Addr, 0, 0, NextOffset, TRUE, TRUE, FALSE, FALSE );

                GetCanStep(RangeStruct->hthd->hprc->hpid,
                           RangeStruct->hthd->htid,
                           &Addr,
                           &CanStep);

                if (CanStep.Flags == CANSTEP_YES) {
                    GetAddrOff(Addr) += CanStep.PrologOffset;
                }

                RangeStruct->TmpAddr = Addr;
                RangeStruct->TmpBp = SetBP( RangeStruct->hthd->hprc,
                                            RangeStruct->hthd,
                                            bptpExec,
                                            bpnsStop,
                                            &Addr,
                                            (HPID) INVALID);
                assert( RangeStruct->TmpBp );
#endif   // KERNEL

            }
#endif   // i386
        }
    }

    SetRangeBp( RangeStruct );

    return RangeStruct;
}

VOID
AddRangeBp(
    RANGESTRUCT *RangeStruct,
    ADDR        *Addr,
    BOOL         fSet
    )
/*++

Routine Description:

    Sets a breakpoint at a particular address and adds it to the breakpoint
    list in a RANGESTRUCT

Arguments:

    RangeStruct -   Supplies pointer to range structure

    Offset      -   Supplies flat address of breakpoint

    fSet        -   Supplies flag which if true causes the BP to be set

Return Value:

    None

--*/
{
    BREAKPOINT      **BpList;
    ADDR            *BpAddrs;
    DWORD           i;

    assert( RangeStruct );
    assert( Addr );

    //
    //  Add the breakpoint to the list in the range structure
    //
    if ( RangeStruct->BpList ) {
        assert( RangeStruct->BpCount > 0 );
        assert( RangeStruct->BpAddrs );

        //
        //  Do not add duplicates
        //
        for ( i=0; i<RangeStruct->BpCount; i++ ) {
            if ( FAddrsEq( RangeStruct->BpAddrs[i], *Addr ) ) {
                return;
            }
        }

        BpList  = ( BREAKPOINT** )MHRealloc( RangeStruct->BpList, sizeof( BREAKPOINT *) * (RangeStruct->BpCount + 1) );
        BpAddrs = ( ADDR* )MHRealloc( RangeStruct->BpAddrs, sizeof( ADDR ) * (RangeStruct->BpCount + 1) );
    } else {
        assert( RangeStruct->BpCount == 0 );
        assert( RangeStruct->BpAddrs == NULL );
        BpList  = ( BREAKPOINT** )MHAlloc( sizeof( BREAKPOINT * ) );
        BpAddrs = ( ADDR* )MHAlloc( sizeof( ADDR ) );
    }

    assert( BpList );
    assert( BpAddrs );

    BpList[RangeStruct->BpCount]   = NULL;
    BpAddrs[ RangeStruct->BpCount] = *Addr;

    if ( fSet ) {

        BpList[ RangeStruct->BpCount ] =
            SetBP( RangeStruct->hthd->hprc,
                    RangeStruct->hthd,
                    bptpExec,
                    bpnsStop,
                    Addr,
                    (HPID) INVALID
                    );

        assert( BpList[ RangeStruct->BpCount ] );
    }

    RangeStruct->BpCount++;
    RangeStruct->BpList     = BpList;
    RangeStruct->BpAddrs    = BpAddrs;
}


VOID
SetRangeBp(
    RANGESTRUCT *RangeStruct
    )
/*++

Routine Description:

    Sets the breakpoints in the range

Arguments:

    RangeStruct -   Supplies pointer to range structure

Return Value:

    None

--*/

{
    BOOL    BpSet;
    DWORD   Class;
    DWORD   SubClass;

    assert( RangeStruct );

    if ( RangeStruct->fSingleStep ) {
#ifdef TARGET_i386
        Class    =  EXCEPTION_DEBUG_EVENT;
        SubClass =  (DWORD)STATUS_SINGLE_STEP;
#else
        Class    =  BREAKPOINT_DEBUG_EVENT;
        SubClass =  NO_SUBCLASS;
#endif
    } else {
        Class    =  BREAKPOINT_DEBUG_EVENT;
        SubClass =  NO_SUBCLASS;
    }

    //
    //  Register the expected breakpoint event.
    //
    RegisterExpectedEvent(
                          RangeStruct->hthd->hprc,
                          RangeStruct->hthd,
                          Class,
                          SubClass,
                          RangeStruct->Method,
                          NO_ACTION,
                          FALSE,
                          NULL);

    if ( RangeStruct->BpCount ) {

        assert( RangeStruct->BpList );
        assert( RangeStruct->BpAddrs );

        //
        //  Set all the breakpoints at once
        //
        BpSet = SetBPEx( RangeStruct->hthd->hprc,
                        RangeStruct->hthd,
                        (HPID) INVALID,
                        RangeStruct->BpCount,
                        RangeStruct->BpAddrs,
                        RangeStruct->BpList,
                        0
                        //DBG_CONTINUE
                        );

        assert( BpSet );
    }
}

VOID
RemoveRangeBp(
    RANGESTRUCT *RangeStruct
    )
/*++

Routine Description:

    Sets the breakpoints in the range

Arguments:

    RangeStruct -   Supplies pointer to range structure

Return Value:

    None

--*/

{
    BOOL        BpRemoved;

    assert( RangeStruct );

    if ( RangeStruct->BpCount ) {

        assert( RangeStruct->BpList );
        assert( RangeStruct->BpAddrs );

        //
        //  Reset all the breakpoints at once
        //
        BpRemoved = RemoveBPEx( RangeStruct->BpCount,
                                RangeStruct->BpList
                                );
    }
}


#if 0
BOOL
GetThunkTarget(
    HTHDX       hthd,
    RANGESTRUCT *RangeStruct,
    ADDR        *AddrThunk,
    ADDR        *AddrTarget
    )
{
    BOOL    fGotTarget = FALSE;
    BYTE   *Buffer;
    DWORD   BufferSize;
    LONG    Length;
    BYTE   *Instr;
    ADDR    Addr;

    assert( RangeStruct );
    assert( AddrThunk );
    assert( AddrTarget );

#define PADDINGSIZE 4

    BufferSize = 16;
    Buffer     = (BYTE *)MHAlloc( BufferSize + PADDINGSIZE );
    assert( Buffer );
    memset( Buffer + BufferSize, 0, PADDINGSIZE);

    //
    //  Disassemble instructions until a branch is found.
    //
    if ( Buffer ) {

        Addr   = *AddrThunk;

        while ( TRUE ) {

            AddrReadMemory(RangeStruct->hthd->hprc,
                           RangeStruct->hthd,
                           &Addr,
                           Buffer,
                           BufferSize,
                           &Length );
            assert(Length==(LONG)BufferSize);

            //
            //  Unassemble the code and determine where all branches are.
            //
            Instr  = (BYTE *)Buffer;

            while ( Length > 0 ) {

                BOOL    IsBranch;
                BOOL    TargetKnown;
                BOOL    IsCall;
                BOOL    IsTable;
                ADDR    Target;
                DWORD   Consumed;

                //
                //  Unassemble one instruction
                //
                Consumed = BranchUnassemble(hthd,
                                            (void *)Instr,
                                            Length,
                                            &Addr,
                                            &IsBranch,
                                            &TargetKnown,
                                            &IsCall,
                                            &IsTable,
                                            &Target );

                if ( Consumed == 0 ) {
                    //
                    //  Could not unassemble the instruction.
                    //
                    Length = 0;

                } else {

                    //
                    //  If instruction is a branch, this is our guy.
                    //
                    if ( IsBranch ) {

                        if ( ADDR_IS_FLAT(Target) ) {
                            if ( GetAddrOff(Target) != 0 ) {
                                GetAddrSeg(Target) = PcSegOfHthdx(RangeStruct->hthd);
                            }
                        } else {
                            ADDR_IS_REAL(Target) = RangeStruct->hthd->fAddrIsReal;
                        }

                        if ( TargetKnown ) {

                            *AddrTarget = Target;

                        } else
                        if ( FAddrsEq( *AddrThunk, Addr ) ) {

                            UOFF32  NextOffset;

#ifdef TARGET_i386
                            UNREFERENCED_PARAMETER( NextOffset );

                            //
                            //  Dont have the target but we are at
                            //  the jump/call instruction. Will set the
                            //  target to the current address and let
                            //  the caller decide what to do.
                            //

#else
                            //
                            //  We are at the branch instruction, so the
                            //  target can be determined.
                            //
                            NextOffset = GetNextOffset( RangeStruct->hthd, RangeStruct->fStepOver );

                            GetAddrOff( Addr ) = NextOffset;
#endif

                            *AddrTarget = Addr;

                        } else {

                            *AddrTarget = Addr;

                        }

                        fGotTarget = TRUE;
                        goto GetOut;
                    }

                    Instr            += Consumed;
                    GetAddrOff(Addr) += Consumed;
                    Length           -= Consumed;
                }
            }
        }

    GetOut:
        MHFree( Buffer );
    }

    return fGotTarget;
}
#endif // 0




#if 0
void
MethodSmartRangeStep(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    RANGESTRUCT* RangeStruct
    )
{
    ADDR    AddrCurrent;
    BOOL    fSingleStep = FALSE;

    assert( de );
    assert( RangeStruct );

    //
    //  Get the current address
    //
    AddrFromHthdx( &AddrCurrent, hthd );

    if ( RangeStruct->fSingleStep ) {
        //
        //  Recover from single step
        //
        RecoverFromSingleStep( &AddrCurrent, RangeStruct );
        fSingleStep = TRUE;
    }

    //
    //  See what we must do now.
    //
    if ( InsideRange( hthd,
                    &RangeStruct->BranchList->AddrStart,
                    &RangeStruct->BranchList->AddrEnd,
                    &AddrCurrent ) ) {


        //
        //  Still inside the range.
        //
        if ( ContinueFromInsideRange( &AddrCurrent, RangeStruct ) ) {
            return;
        }

    } else {

        //
        //  Outside the range
        //
        if ( fSingleStep && RangeStruct->fStepOver && RangeStruct->fInCall ) {
            //
            //  Recovering from a single step, continue.
            //
            RangeStruct->fInCall = FALSE;
            RegisterExpectedEvent(  RangeStruct->hthd->hprc,
                                    RangeStruct->hthd,
                                    BREAKPOINT_DEBUG_EVENT,
                                    NO_SUBCLASS,
                                    RangeStruct->Method,
                                    NO_ACTION,
                                    FALSE,
                                    NULL);

            ThreadContinueDebugEventEx (hthd,
                                      RangeStruct->fSingleStep ?
                                            QT_TRACE_DEBUG_EVENT :
                                            QT_CONTINUE_DEBUG_EVENT
                                    );

            return;
        }
        if ( ContinueFromOutsideRange( &AddrCurrent, RangeStruct ) ) {
            return;
        }
    }

    //
    //  If we get here then we must clean up all the allocated resources
    //  and notify the EM.
    //

    if ( RangeStruct->BpCount > 0 ) {

        assert( RangeStruct->BpList );
        assert( RangeStruct->BpAddrs );

        RemoveRangeBp( RangeStruct );

        MHFree( RangeStruct->BpList );
        MHFree( RangeStruct->BpAddrs );
    }

    assert( RangeStruct->BranchList );
    MHFree( RangeStruct->BranchList );

    assert( RangeStruct->Method );
    MHFree( RangeStruct->Method );

    MHFree( RangeStruct );

    //
    //  Notify the EM that this thread has stopped.
    //
#ifdef KERNEL
    hthd->tstate &= ~ts_stepping;
#endif
    hthd->tstate &= ~ts_running;
    hthd->tstate |=  ts_stopped;
    NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);
}
#endif


VOID
RecoverFromSingleStep(
    ADDR        *AddrCurrent,
    RANGESTRUCT* RangeStruct
    )
{
    BREAKPOINT *Bp;
    DWORD       i;

    assert( AddrCurrent );
    assert( RangeStruct );
    assert( RangeStruct->fSingleStep );



    //
    //  Recovering from a single step.
    //  Reset previous BP
    //

    Bp = FindBP( RangeStruct->hthd->hprc,
                 RangeStruct->hthd,
                 bptpExec,
                 (BPNS)-1,
                 &RangeStruct->PrevAddr,
                 FALSE );

    assert( Bp );

    if ( Bp ) {
        WriteBreakPoint( Bp );
    }



#ifdef TARGET_i386

#ifndef KERNEL
    //
    //  Clear trace flag
    //
    //
    HthdReg(RangeStruct->hthd,EFlags) &= ~(TF_BIT_MASK);
    RangeStruct->hthd->fContextDirty = TRUE;

#endif  // KERNEL


#else   // TARGET_i386

    //
    //  Remove temporary breakpoint
    //
    assert( FAddrsEq( RangeStruct->TmpBp->addr, *AddrCurrent ) );

    assert( RangeStruct->TmpBp );
    RemoveBP( RangeStruct->TmpBp );
    RangeStruct->TmpBp = NULL;

#endif  // TARGET_i386

    RangeStruct->fSingleStep = FALSE;
}


BOOL
ContinueFromInsideRange(
    ADDR        *AddrCurrent,
    RANGESTRUCT *RangeStruct
    )
/*++

Routine Description:

Return Value:

Comments:

    ORPC debugging has not yet been implemented for smart range stepping.

--*/
{

    DWORD       i;
    BREAKPOINT *Bp;
    UOFF32      NextOffset;
    ADDR        NextAddr;
    BOOL        fContinue   = FALSE;

    assert( AddrCurrent );
    assert( RangeStruct );
        assert( !RangeStruct -> hthd -> fDisplayReturnValues); // AutoDisplay of return values code should be added to this routine.  See RAID 2914

    Bp = AtBP(RangeStruct->hthd);

    if ( RangeStruct->BranchList->Count > 0 && Bp ) {

        if ( Bp != EMBEDDED_BP ) {

            //
            //  Look for the branch node corresponding to this address.
            //  When found, determine the target address and set a
            //  safety breakpoint there if necessary. Then let the
            //  thread continue.
            //
            for ( i=0; i < RangeStruct->BranchList->Count; i++ ) {

                if ( FAddrsEq( RangeStruct->BranchList->BranchNode[i].Addr,
                                                            *AddrCurrent ) ) {

                    //
                    //  This is our guy.
                    //

                    //
                    //  Determine the next address
                    //
                    RangeStruct->fInCall = RangeStruct->BranchList->BranchNode[i].IsCall;
#ifdef TARGET_i386
                    UNREFERENCED_PARAMETER( NextOffset );
                    UNREFERENCED_PARAMETER( NextAddr );
#else   // TARGET_i386
                    NextOffset = GetNextOffset( RangeStruct->hthd, RangeStruct->fStepOver );
                    AddrInit(&NextAddr, 0, 0, NextOffset, TRUE, TRUE, FALSE, FALSE );
#endif  // TARGET_i386


                    //
                    //  We have to single step the current instruction.
                    //  We set a temporary breakpoint at the next offset,
                    //  recover the current breakpoint and set the flags to
                    //  reset the breakpoint when we hit the temporary
                    //  breakpoint.
                    //
                    ClearBPFlag( RangeStruct->hthd );
                    RestoreInstrBP( RangeStruct->hthd, Bp );
                    RangeStruct->PrevAddr = *AddrCurrent;

                    RangeStruct->fSingleStep = TRUE;
#ifdef TARGET_i386
#ifndef KERNEL
                    HthdReg(RangeStruct->hthd,EFlags) |= TF_BIT_MASK;
                    RangeStruct->hthd->fContextDirty = TRUE;
#endif // KERNEL
#else   // TARGET_i386
                    RangeStruct->TmpAddr  = NextAddr;
                    RangeStruct->TmpBp = SetBP( RangeStruct->hthd->hprc,
                                                RangeStruct->hthd,
                                                bptpExec,
                                                bpnsStop,
                                                &NextAddr,
                                                (HPID) INVALID);
                    assert( RangeStruct->TmpBp );
#endif  // TARGET_i386

                    //
                    //  Register the expected event.
                    //
                    RegisterExpectedEvent(
                                        RangeStruct->hthd->hprc,
                                        RangeStruct->hthd,
#ifdef TARGET_i386
                                        EXCEPTION_DEBUG_EVENT,
                                        (DWORD)STATUS_SINGLE_STEP,
#else   // TARGET_i386
                                        BREAKPOINT_DEBUG_EVENT,
                                        NO_SUBCLASS,
#endif  // TARGET_i386
                                        RangeStruct->Method,
                                        NO_ACTION,
                                        FALSE,
                                        NULL);

                    ThreadContinueDebugEventEx (RangeStruct->hthd,
                                                RangeStruct->fSingleStep ?
                                                    QT_TRACE_DEBUG_EVENT :
                                                    QT_CONTINUE_DEBUG_EVENT
                                                );
                    fContinue = TRUE;
                    break;
                }
            }
        }

    } else {

        //
        //  We might end up here if continuing from a single step.
        //
        RegisterExpectedEvent(
                                RangeStruct->hthd->hprc,
                                RangeStruct->hthd,
                                BREAKPOINT_DEBUG_EVENT,
                                NO_SUBCLASS,
                                RangeStruct->Method,
                                NO_ACTION,
                                FALSE,
                                NULL);

        ThreadContinueDebugEventEx (RangeStruct->hthd,
                                    RangeStruct->fSingleStep ?
                                        QT_TRACE_DEBUG_EVENT :
                                        QT_CONTINUE_DEBUG_EVENT
                                    );

        fContinue = TRUE;
    }

    return fContinue;
}


BOOL
ContinueFromOutsideRange(
    ADDR        *AddrCurrent,
    RANGESTRUCT *RangeStruct
    )
{

    BOOL        fContinue = FALSE;
    ADDR        Addr;
    CANSTEP     CanStep;
    BREAKPOINT *Bp;

    assert( AddrCurrent );
    assert( RangeStruct );
        assert( !RangeStruct -> hthd -> fDisplayReturnValues); // AutoDisplay of return values code should be added to this routine.  See RAID 2914

    Bp = AtBP(RangeStruct->hthd);

    if (Bp == EMBEDDED_BP) {

        //
        // always stop.
        //

    } else if (!RangeStruct->fInCall) {

        //
        // if we werent in a call, this should just be some other line
        // of code in the same function (or the parent function?), so stop.
        //

    } else {

        //
        // stopping after a call instruction.
        // this might actually not be a new function; we just know
        // that there was a call instruction in the source line.
        //

        GetCanStep(RangeStruct->hthd->hprc->hpid,
                   RangeStruct->hthd->htid,
                   AddrCurrent,
                   &CanStep
                   );

        switch ( CanStep.Flags ) {

        case CANSTEP_YES:

            //
            // if there is a known prolog, run ahead to the end
            //
            if ( CanStep.PrologOffset > 0 ) {

                Addr = *AddrCurrent;
                GetAddrOff(Addr) += CanStep.PrologOffset;
                AddRangeBp( RangeStruct, &Addr, TRUE );

                RegisterExpectedEvent(
                    RangeStruct->hthd->hprc,
                    RangeStruct->hthd,
                    BREAKPOINT_DEBUG_EVENT,
                    NO_SUBCLASS,
                    RangeStruct->Method,
                    NO_ACTION,
                    FALSE,
                    NULL);

                ClearBPFlag( RangeStruct->hthd );
                if ( Bp ) {
                    RestoreInstrBP( RangeStruct->hthd, Bp );
                }

                ThreadContinueDebugEvent (RangeStruct->hthd);
                fContinue = TRUE;
            }
            break;

#if 0
        case CANSTEP_THUNK:

            if ( GetThunkTarget( RangeStruct->hthd, RangeStruct, AddrCurrent, &Addr ) ) {

                DWORD   Class;
                DWORD   SubClass;

                if ( FAddrsEq( *AddrCurrent, Addr ) ) {

                    //
                    //  Could not determine target address. Set a single
                    //  step and continue.
                    //

                    RangeStruct->PrevAddr = *AddrCurrent;

#ifdef TARGET_i386
#ifndef KERNEL
                    RangeStruct->hthd->context.EFlags |= TF_BIT_MASK;
                    RangeStruct->hthd->fContextDirty = TRUE;
#endif  // KERNEL
                    Class    = EXCEPTION_DEBUG_EVENT;
                    SubClass = (DWORD)STATUS_SINGLE_STEP;

#else   // TARGET_i386
                    {
                        ADDR         Addr;
                        UOFF32       NextOffset;
                        NextOffset = GetNextOffset( RangeStruct->hthd,
                                                   RangeStruct->fStepOver );
                        if ( NextOffset != 0x00000000 ) {
                            AddrInit( &Addr, 0, 0, NextOffset, TRUE, TRUE, FALSE, FALSE );
                            RangeStruct->TmpAddr = Addr;
                            RangeStruct->TmpBp = SetBP( RangeStruct->hthd->hprc,
                                                        RangeStruct->hthd,
                                                        bptpExec,
                                                        bpnsStop,
                                                        &Addr,
                                                        (HPID) INVALID);
                            assert( RangeStruct->TmpBp );
                        }
                        Class    = BREAKPOINT_DEBUG_EVENT;
                        SubClass = NO_SUBCLASS;
                    }
#endif  // TARGET_i386

                    RegisterExpectedEvent(
                                            RangeStruct->hthd->hprc,
                                            RangeStruct->hthd,
                                            Class,
                                            SubClass,
                                            RangeStruct->Method,
                                            NO_ACTION,
                                            FALSE,
                                            NULL);

                } else {

                    //
                    //  Set breakpoint at target address and continue
                    //
                    AddRangeBp( RangeStruct, &Addr, TRUE );

                    RegisterExpectedEvent(
                                            RangeStruct->hthd->hprc,
                                            RangeStruct->hthd,
                                            BREAKPOINT_DEBUG_EVENT,
                                            NO_SUBCLASS,
                                            RangeStruct->Method,
                                            NO_ACTION,
                                            FALSE,
                                            NULL);
                }

                //
                //  Remove current breakpoint
                //
                ClearBPFlag( RangeStruct->hthd );
                if ( Bp ) {
                    RestoreInstrBP( RangeStruct->hthd, Bp );
                }

                ThreadContinueDebugEventEx (hthd,
                                            RangeStruct->fSingleStep ?
                                                QT_TRACE_DEBUG_EVENT :
                                                QT_CONTINUE_DEBUG_EVENT);
                fContinue = TRUE;
            }

            break;
#endif  // 0

        case CANSTEP_NO:

            //
            // no source here.
            // step some more...
            // what is going to happen here? do we just keep stepping
            // until we get somewhere that has source?
            //

            //
            //  Register the expected event.
            //
            RegisterExpectedEvent(
                RangeStruct->hthd->hprc,
                RangeStruct->hthd,
                BREAKPOINT_DEBUG_EVENT,
                NO_SUBCLASS,
                RangeStruct->Method,
                NO_ACTION,
                FALSE,
                NULL);

            ClearBPFlag( RangeStruct->hthd );
            if ( Bp ) {
                RestoreInstrBP( RangeStruct->hthd, Bp );
            }

            ThreadContinueDebugEventEx (RangeStruct->hthd,
                                        RangeStruct->fSingleStep ?
                                            QT_TRACE_DEBUG_EVENT :
                                            QT_CONTINUE_DEBUG_EVENT);
            fContinue = TRUE;
            break;
        }
    }

    return fContinue;
}

VOID
RangeStepContinue(
        HTHDX   hthd,
        LPVOID  Args
        );


typedef struct _RANGE_STEP_CONTINUE_ARGS
{
        UOFF32  offStart;
        UOFF32  offEnd;
        BOOL    fStopOnBP;
        BOOL    fstepOver;

} RANGE_STEP_CONTINUE_ARGS;

VOID
RangeStep(
    HTHDX       hthd,
    UOFF32      offStart,
    UOFF32      offEnd,
    BOOL        fStopOnBP,
    BOOL        fstepOver
    )
/*++

Routine Description:

    This function is used to implement range stepping the the DM.  Range
    stepping is used to cause all instructions between a pair of addresses
    to be executed.

    The segment is implied to be the current segment.  This is validated
    in the EM.

    Range stepping is done by registering an expected debug event at the
    end of a step and seeing if the current program counter is still in
    the correct range.  If it is not then the range step is over, if it
    is then a new event is register and we loop.

Arguments:

    hthd      - Supplies the thread to be stepped.

    offStart  - Supplies the initial offset in the range

    offEnd    - Supplies the final offset in the range

    fStopOnBP - Supplies TRUE if stop on an initial breakpoint

    fStepOver - Supplies TRUE if to step over call type instructions

Return Value:

    None.

Comments:

    This function has been broken into two.  RangeStep and RangeStepContinue.
    See RangeStepContinue for most of the functionality.

--*/
{
    RANGE_STEP_CONTINUE_ARGS*       Args;

    Args = (RANGE_STEP_CONTINUE_ARGS*) MHAlloc (sizeof (*Args));

    Args->offStart = offStart;
    Args->offEnd = offEnd;
    Args->fStopOnBP = fStopOnBP;
    Args->fstepOver = fstepOver;

    EnsureOleRpcStatus (hthd, RangeStepContinue, Args);
}


VOID
RangeStepContinue(
    HTHDX   hthd,
    LPVOID  Args
    )
/*++

Routine Description:

    See the function RangeStep for a description of the Args fields.  In the
    normal case -- where we are not changing our OLE debugging state -- this
    function is just caled from EnsureOleRpcStatus ().

--*/
{
    RANGE_STEP_CONTINUE_ARGS*   rscArgs = (RANGE_STEP_CONTINUE_ARGS*) Args;

    UOFF32  offStart = rscArgs->offStart;
    UOFF32  offEnd   = rscArgs->offEnd;
    BOOL    fStopOnBP= rscArgs->fStopOnBP;
    BOOL    fstepOver= rscArgs->fstepOver;

    RANGESTEP * rs;
    METHOD *    method;
    HPRCX       hprc = hthd->hprc;
    int         lpf  = 0;
    ADDR        addr;


    MHFree (rscArgs);
    rscArgs = NULL;

    //
    //  Create and fill a range step structure
    //

    rs = (RANGESTEP*) MHAlloc(sizeof(RANGESTEP));
    rs->hthd        = hthd;
    rs->addrStart   = offStart;
    rs->addrEnd     = offEnd;
    rs->segCur      = PcSegOfHthdx(hthd);
    rs->fInThunk    = FALSE;
    rs->safetyBP    = NULL;
    rs->SavedSeg    = 0;
    rs->SavedAddrStart = 0;
    rs->SavedAddrEnd = 0;
    rs->fSkipProlog = FALSE;
    rs->fGetReturnValue = FALSE;
    rs->SavedEBP = 0;

    //
    //  Create a notification method for this range step
    //

    method  = (METHOD*) MHAlloc(sizeof(METHOD));
    method->notifyFunction  = (ACVECTOR)MethodRangeStep;
    method->lparam          = rs;
    rs->method              = method;

    if ( fstepOver ) {
        rs->stepFunction = StepOver;
    } else {
        rs->stepFunction = SingleStep;

       /*
        *  Check to see if we are currently at a call instruction.  If we
        *      are then we need to set a breakpoint at the end of the call
        *      instruction as the "safety" breakpoint.
        *
        *      This will allow us to recover back to the current level
        *      if the call we are just about to step into does not have
        *      any source information (in which case the range step
        *      is defined to continue).
        */

        AddrInit(&addr, 0, rs->segCur, offStart,
                hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal);
        IsCall( hthd, &addr, &lpf, FALSE);
        if ( lpf == INSTR_IS_CALL ) {
            rs->safetyBP = SetBP(hprc, hthd, bptpExec, bpnsStop, &addr, (HPID)INVALID);
        } else if (lpf == INSTR_CANNOT_STEP) {
            SendDBCErrorStep(hthd->hprc);
            return;
        }
    }

    //
    //  Call the step over function to send notifications
    //  to the RangeStepper (NOT THE EM!)
    //

    (rs->stepFunction)(hthd, method, fStopOnBP, FALSE);

}                               /* RangeStep() */

//#include <simpldis.h>

ULONGLONG
QwGetreg(
	PVOID	pv,
	int		reg
	);

ULONG
GetInstructionSize(
	HTHDX	hthd,
	UOFF32	validAddr,
	UOFF32	destAddr,
	UOFF32*	lpOffset
	);

#if 0
ULONG
GetInstructionSize(
	HTHDX	hthd,
	UOFF32	validAddr,
	UOFF32	destAddr,
	UOFF32*	lpOffset
	)
/*++

Routine Description:

	Get the size of the instruction thisAddr is pointing to.
	
Arguments:

	validAddr - some valid address <= thisAddr.  On x86 we will disasm
				from validAddr to thisAddr to try to get the instruction.

	destAddr - the address we want the size of.  This can be either at
			   the beginning of the instruction or within the instruction.
	

Return Value:

	The size of the instruction.  Zero on failure.

--*/
{

	int			bytes = 0;
	BYTE		buffer [20];
	SIMPLEDIS	sdis;
	UOFF32		disasmAddr = 0;
	ULONG		cb = 0;
	BOOL		fSucc = FALSE;
	

	if (validAddr > destAddr) {
		assert (FALSE);
		return 0;
	}


	
	for (bytes = 0, disasmAddr = validAddr;
		 disasmAddr <= destAddr;
		 disasmAddr += bytes) {
		 

		cb = 0;
		
		fSucc = DbgReadMemory (hthd->hprc,
							   (PVOID) disasmAddr,
							   buffer,
							   sizeof (buffer),
							   &cb);

		assert (fSucc);

		bytes = SimplyDisassemble (buffer,
								   cb,
								   disasmAddr,
								   Simple_Arch_X86,
								   &sdis,
								   NULL,
								   NULL,
								   NULL,
								   QwGetreg,
								   (PVOID) hthd
								   );

		if (bytes <= 0) {

			//
			// Invalid address or instruction.
			//
			
			assert (FALSE);
			return 0;
		}
	}
		

	if (lpOffset) {
		*lpOffset = destAddr - (disasmAddr - bytes);
	}
	
	return bytes;
}
#endif		
	
	
	


VOID
MethodRangeStep(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    RANGESTEP* rs
    )
/*++

Routine Description:

    This is the range step method for the "stupid" or single stepping range
    step method.  This is called for every instruction executed during a range
    step, except when it has decided to run free to the safety breakpoint.  It
    does that when the destination code has no source line information.

Arguments:

    de - Supplies the single step or breakpoint debug event

    hthd - Supplies the thread

    unused -

    rs - Supplies a structure containing state information for the step

Return Value:

    none

--*/
{
    DWORD       currAddr    = PC(hthd);
    int         lpf         = 0;
    HPRCX       hprc        = hthd->hprc;
    METHOD *    method;
    ADDR        AddrPC;
    CANSTEP     CanStep;
    PBREAKPOINT bp;
    DWORD       dwSize;
    EXPECTED_EVENT *ee;


    DEBUG_PRINT_3("** MethodRangeStep called: %08x-%08x  PC=%08x",
                    rs->addrStart, rs->addrEnd, currAddr);

	DbgTrace ((TR_RANGESTEP,
			  "MethodRangeStep\n"
			  "\tPC:%#x\n\tStart: %#x\n"
			  "\tEnd:%#x\n",
			  currAddr,
			  rs->addrStart,
			  rs->addrEnd));

    AddrFromHthdx(&AddrPC, hthd);

    //
    //  auto return value

    if (hthd->fReturning) {
        //
        // Out of a call.
        //
        
        hthd->fReturning = FALSE;

        assert (rs->fGetReturnValue);

        //
        // Got it!
        //

        rs->fGetReturnValue = FALSE;

        NotifyEM (&FuncExitEvent, hthd, 0, &hthd->addrFrom);
    }


    //
    //  see if we ran past a call or hit a BP.
    //

    bp = AtBP(hthd);

    if (bp && bp == rs->safetyBP) {

        //
        // We stepped over the function.  continue the range step...
        //

        //
        // Note: we only get here if we did not stop in the called function.
        // In the usual case, the safety BP has been changed into an expected
        // event and is gone by the time we get here.
        //

		//
		// If there is an expected event already dependent on this bp remove
		// it.
		//
		
        ee = PeeIsEventExpected (hthd,
								 BREAKPOINT_DEBUG_EVENT,
								 (DWORD) rs->safetyBP,
								 TRUE);

		if (ee) {
            MHFree (ee);
			ee = NULL;
        }
        RemoveBP(bp);
        rs->safetyBP = NULL;

    } else if (bp) {

        //
        // always stop on a real bp.
        //

        goto EndStep;

    }


    //
    //  Check if we are still within the range
    //

    if ((rs->addrStart > currAddr) ||
            (currAddr > rs->addrEnd) ||
            (PcSegOfHthdx(hthd) != rs->segCur)) {

		//
		// For thunking.
		//

		if (rs->SavedAddrStart) {

			DbgTrace ((TR_RANGESTEP,
					  "MethodRagneStep: [Exited Thunk]\n"
					  "\taddrStart = %#x, setting to %#x\n"
					  "\taddrEnd = %#x, setting to %#x\n",
					  rs->addrStart,
					  rs->SavedAddrStart,
					  rs->addrEnd,
					  rs->SavedAddrEnd));
				  
            rs->addrStart = rs->SavedAddrStart;
            rs->addrEnd = rs->SavedAddrEnd;
            rs->segCur = rs->SavedSeg;
            rs->SavedAddrStart = 0;
            rs->SavedAddrEnd = 0;
            rs->SavedSeg = 0;
			rs->fInThunk = FALSE;
        }
    }

    if ((rs->addrStart <= currAddr) &&
            (currAddr <= rs->addrEnd) &&
            (PcSegOfHthdx(hthd) == rs->segCur)) {

        //
        //  We still are in the range, continue stepping
        //

        //
        //  On Win95 if we try to step into a system call, the system
        //  forces execution to the instruction after the call and sends
        //  a single step.  This is because it doesnt want user-mode
        //  debuggers to step into system code.  In that case we are
        //  already at the safety bp and we should consume it.
        //

#if 0
        if (IsChicago() && rs->safetyBP &&
            (rs->stepFunction != (STEPPER)StepOver || rs->fGetReturnValue))
        {
            bp = FindBP(hprc, hthd, bptpExec, (BPNS)-1, &AddrPC, FALSE);
            if (bp == rs->safetyBP) {
                ee = PeeIsEventExpected(hthd, BREAKPOINT_DEBUG_EVENT,(DWORD) rs->safetyBP, TRUE);
                if(ee) {
                    MHFree(ee);
                }
                RemoveBP(rs->safetyBP);
                rs->safetyBP = NULL;
                if (rs->fGetReturnValue)
                    rs->fGetReturnValue = FALSE;
            }


        }
#endif



        if (rs->stepFunction != (STEPPER)StepOver) {

            //
            //    If we are doing a "Step Into" we must check for "CALL"
            //
            IsCall(hthd, &AddrPC, &lpf, FALSE);
            if (lpf == INSTR_IS_CALL) {

                //
                // Before we step into this function, lets
                // put a "safety-net" breakpoint on the instruction
                // after this call. This way if we dont have
                // source for this function, we can always continue
                // and break at this safety-net breakpoint.
                //

                // this should have been cleared
                assert(!rs->safetyBP);

                rs->safetyBP = SetBP (hprc,
                                      hthd,
                                      bptpExec,
                                      bpnsStop,
                                      &AddrPC,
                                      (HPID)INVALID);

                RegisterExpectedEvent(hprc,
                                  hthd,
                                  BREAKPOINT_DEBUG_EVENT,
                                  (DWORD) rs->safetyBP,
                                  rs->method,
                                  NO_ACTION,
                                  FALSE,
                                  NULL);

				
#if 0
                //
                // If we are doing a step into, we may end up receiving
                // the ORPC ActionOrpcClientGetBufferSize event.
                

                if (hthd->hprc->OrpcDebugging == ORPC_DEBUGGING) {

                    RegisterExpectedEvent (hthd->hprc,
                                           hthd,
                                           OLE_DEBUG_EVENT,
                                           orpcClientGetBufferSize,
                                           DONT_NOTIFY,
                                           ActionOrpcClientGetBufferSize,
                                           FALSE,
                                           (LPVOID) AddrPC.addr.off
                                           );
                }
                
#endif // !KERNEL

            }


        }

        (rs->stepFunction)(hthd, rs->method, TRUE, FALSE);

    } else {

        //
        // we have left the range.
        //
        // If we are at the safety bp && chicago && return values,
        //    we have attempted to step over a system call, failed,
        //    and ended up here.  Remove the safety bp and continue on.
        //
        // If we are at an NLG_RETURN label, we need to continue on.
        //
        // If there is source here,
        //   if we are in a prolog
        //      run to the end of the prolog
        //   else
        //      stop.
        //
        // If we were in a thunk or a call was pending,
        // we have either hit a thunk or a new function.
        //
        //  if we hit a thunk
        //      set the range to cover the thunk,
        //      set the thunk flag
        //      and continue stepping.
        //  else
        //      run to the safety bp
        //
        // if there is no source and no safety bp, stop.
        //

        //
        // Ask the debugger if we can step on this instruction
        //

		DbgTrace ((TR_RANGESTEP,
				  "MethodRangeStep:\n"
				  "\tLeft range at %#x\n", currAddr));
		
        GetCanStep (hthd->hprc->hpid, hthd->htid, &AddrPC, &CanStep);

        if (CanStep.Flags == CANSTEP_YES && !rs->fGetReturnValue) {

			if (rs->safetyBP) {
                ee = PeeIsEventExpected (hthd,
										BREAKPOINT_DEBUG_EVENT,
									    (DWORD) rs->safetyBP,
										TRUE);
                if (ee) {
                    MHFree(ee);
                }
                RemoveBP(rs->safetyBP);
                rs->safetyBP = NULL;
            }
        }

#if 0
        if (IsChicago () && rs->safetyBP && rs->fGetReturnValue) {

			//
            // If this assert fires, you probably want to add
            // its condition to the above conditional.
			//
			
            assert (rs->stepFunction == StepOver);

            bp = FindBP (hprc, hthd, bptpExec, (BPNS)-1, &AddrPC, FALSE);
			
            if (bp == rs->safetyBP) {

				ee = PeeIsEventExpected (hthd,
										BREAKPOINT_DEBUG_EVENT,
										(DWORD) rs->safetyBP,
										TRUE);

				if (ee) {
                    MHFree(ee);
                }
                RemoveBP (rs->safetyBP);
                rs->safetyBP = NULL;
                rs->fGetReturnValue = FALSE;
                goto EndStep;
            }
        }
#endif


        if (CheckNLG(hthd->hprc, hthd, NLG_RETURN, &AddrPC)) {

			//
            // We should have just stepped over a ret instruction,
            // there should be no safety BP's.
			//
			
            assert(rs->safetyBP == NULL);
            SetupNLG(hthd, NULL);
            ThreadContinueDebugEvent (hthd);

        } else if ((CanStep.Flags == CANSTEP_YES) && (rs->fSkipProlog) &&
				   (CanStep.PrologOffset > 0) && !rs->fGetReturnValue ) {

            //
            // If there is a known prolog, run ahead to the end.
            //

            ADDR Addr = AddrPC;

			DbgTrace ((TR_RANGESTEP,
					  "MethodRangeStep:\n"
					  "\tFound a prolog: start %#x end %#x.  Skipping.\n",
					  Addr.addr.off,
					  Addr.addr.off + CanStep.PrologOffset
					  ));
			
            GetAddrOff(Addr) += CanStep.PrologOffset;
            bp = SetBP(hprc, hthd, bptpExec, bpnsStop, &Addr, (HPID)INVALID);
            assert(bp);

            method = (METHOD*)MHAlloc(sizeof(METHOD));
            *method = *rs->method;

            method->lparam2 = (LPVOID)bp;

            RegisterExpectedEvent(
                    hthd->hprc,
                    hthd,
                    BREAKPOINT_DEBUG_EVENT,
                    NO_SUBCLASS,
                    DONT_NOTIFY,
                    (ACVECTOR) SSActionRemoveBP,
                    FALSE,
                    method);

            ThreadContinueDebugEvent (hthd);

        } else if ((CanStep.Flags != CANSTEP_YES) &&
				   (rs->safetyBP || rs->fInThunk) || rs->fGetReturnValue) {

			DbgTrace ((TR_RANGESTEP,
					   "MethodRangeStep: [Came from call or thunk and found no source]\n"));
			
            //
            // We came from a call or thunk, and found no source.
            //

			if (CanStep.Flags == CANSTEP_THUNK_OVER) {


				//
				// There are two cases here:
				//
				// 1) that we are not at the end of the thunk (most likely
				//    at the beginning).  In this case, we set a BP on the
				//	  last instruction of the thunk and GO.
				//
				// 2) we have come back and are now on the last instruction
				//    of the thunk.  We need to treat this like a normal
				//	  thunk step.
				//
				
				ADDR	Addr = AddrPC;
				ULONG	Size = 0;
				UOFF32	Dest = 0;
				UOFF32	Offset = 0;

				_asm int 3
				DbgTrace ((TR_RANGESTEP, "MethodRangeStep: [Thunk Over]\n"));

				Dest = GetAddrOff (AddrPC);
				
				Dest += CanStep.ThunkSize;

				Dest--;		// So we are on the previous instruction

#if 0
				Size = GetInstructionSize (hthd,
										   PC (hthd),
										   Dest,
										   &Offset);
#endif
				Size = 1;

				Dest -= Size - Offset;

				if (Dest <= PC (hthd)) {

					//
					// Normal thunk step
					//
					
					dwSize = Size;
					
					rs->fInThunk = TRUE;
					
					//
					// set new range and continue.
					//

					rs->SavedAddrStart = rs->addrStart;
					rs->SavedAddrEnd = rs->addrEnd;
					rs->SavedSeg = rs->segCur;
					rs->addrStart = currAddr;
					rs->addrEnd = currAddr + dwSize;
					rs->segCur = PcSegOfHthdx(hthd);

					(rs->stepFunction)(hthd, rs->method, TRUE, FALSE);

				} else {

					//
					// Run over this region.
					//

					GetAddrOff (Addr) = Dest;
					bp = SetBP(hprc, hthd,  bptpExec, bpnsStop, &Addr, (HPID)INVALID);
					assert(bp);

					method = (METHOD*)MHAlloc(sizeof(METHOD));
					*method = *rs->method;

					method->lparam2 = (LPVOID)bp;

					RegisterExpectedEvent(
							hthd->hprc,
							hthd,
							BREAKPOINT_DEBUG_EVENT,
							NO_SUBCLASS,
							DONT_NOTIFY,
							(ACVECTOR) SSActionRemoveBP,
							FALSE,
							method);

					ThreadContinueDebugEvent (hthd);
				}

			} else if (IsThunk (hthd, PC(hthd), NULL, NULL, &dwSize) ||
					   CanStep.Flags == CANSTEP_THUNK) {


				if (CanStep.Flags == CANSTEP_THUNK) {

					//
					// The ThunkSize provided by the shell is the actual size
					// of the thunk.  But the range stepper needs an inclusive
					// size.  Subtract one will due.
					//
					
					dwSize = CanStep.ThunkSize - 1;
				}


				rs->fInThunk = TRUE;
				
				//
                // set new range and continue.
                //

                rs->SavedAddrStart = rs->addrStart;
                rs->SavedAddrEnd = rs->addrEnd;
                rs->SavedSeg = rs->segCur;
                rs->addrStart = currAddr;
                rs->addrEnd = currAddr + dwSize;
                rs->segCur = PcSegOfHthdx(hthd);

				DbgTrace ((TR_RANGESTEP,
						  "MethodRangeStep: [Entering Thunk]\n"
						  "\tthunkStart %#x\n"
						  "\tthunkEnd %#x\n"
						  "\tcurRangeStart %#x\n"
						  "\tcurRangeEnd %#x\n"
						  "\tPC %#x\n",
						  rs->addrStart,
						  rs->addrEnd,
						  rs->SavedAddrStart,
						  rs->SavedAddrEnd,
						  currAddr));
						  
                (rs->stepFunction)(hthd, rs->method, TRUE, FALSE);

            } else if (!rs->safetyBP) {

				//
                // came from a thunk, but there was no BP
                //
				
                assert(0);
				
            } else {

				assert (rs->safetyBP);
				DbgTrace ((TR_RANGESTEP,
						   "MetodRangeStep: [Came from call or thunk, no source, safety bp set]\n"
				           "\tMake the safety BP an expected event and run free\n"
						   "\tSafetyBP dest: %#x\n",
						   rs->safetyBP->addr.addr.off));
				
                if (rs->fGetReturnValue) {
					hthd->fReturning = TRUE;
                    SetAddrOff (&hthd->addrFrom, currAddr);
                }

                //
                // Make the safety BP an expected event and run free.
                //

                method = (METHOD*)MHAlloc(sizeof(METHOD));
                *method = *rs->method;

                method->lparam2 = (LPVOID)rs->safetyBP;

				//
                // If there is an expected event already dependent on this bp
				// remove it.
				//
				
                ee = PeeIsEventExpected (hthd,
										 BREAKPOINT_DEBUG_EVENT,
										 (DWORD) rs->safetyBP,
										 TRUE);

				if (ee) {
                   MHFree(ee);
                }

				//
				// SSActionStepOver - does the remove BP when it reaches the
				// right frame
				//
				
                RegisterExpectedEvent(
                                hthd->hprc,
                                hthd,
                                BREAKPOINT_DEBUG_EVENT,
                                (DWORD)rs->safetyBP,
                                DONT_NOTIFY,
                                (ACVECTOR) SSActionStepOver,
                                FALSE,
                                method);

                //
                // The safety is the expected event now, so the rs struct
                // can forget about it.
                //

                rs->safetyBP = NULL;

                ThreadContinueDebugEvent (hthd);
            }
        } else {

EndStep:

            DEBUG_PRINT("  Ending range step\n");

            //
            // We are no longer in the range, free all consumable
            // events on the queue for this thread
            //
            ConsumeAllThreadEvents(hthd, FALSE);

            //
            //  Free the structures created for range-stepping
            //
            if (rs->safetyBP) {
                ee = PeeIsEventExpected(hthd, BREAKPOINT_DEBUG_EVENT,(DWORD) rs->safetyBP, TRUE);
                if(ee) {
                    MHFree(ee);
                }
                RemoveBP(rs->safetyBP);
            }
            MHFree(rs->method);
            MHFree(rs);

            //
            //  Notify the EM that this thread has stopped on a SS
            //
            hthd->tstate &= ~ts_running;
            hthd->tstate |=  ts_stopped;
            NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);

        }
    }

    return;
}                   /* MethodRangeStep */


void
WtPrintCallNode(
    LPWTNODE wt
    )
{
    DWORD i;
    static CHAR margin[] =
"                                                                                ";
    i = wt->lex*3;
    if (i > 60) {
        i = 60;
    }
    DMPrintShellMsg( "%4d  %4d  %*.*s%s\r\n",
        wt->icnt,
        wt->scnt,
        i, i, margin,
        wt->fname );
}

void
WtGetSymbolName(
    HTHDX    hthd,
    LPADDR   lpaddr,
    LPSTR   *lpFname,
    LPDWORD  lpdwSymAddress,
    LPDWORD  lpdwReturnAddress
    )
/*++

Routine Description:



Arguments:


Return Value:


--*/
{
    DMSYM   DmSym;

    __try {

        DMSendRequestReply(dbceGetSymbolFromOffset,
                           hthd->hprc->hpid,
                           hthd->htid,
                           sizeof(ADDR),
                           lpaddr,
                           sizeof(DMSYM),
                           &DmSym
                           );

        *lpFname = MHStrdup( DmSym.fname );
        *lpdwSymAddress = GetAddrOff(DmSym.AddrSym);
        *lpdwReturnAddress = DmSym.Ra;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        *lpFname = NULL;
        *lpdwReturnAddress = 0;
        *lpdwSymAddress = 0;

    }
}


/***    WtMethodRangeStep
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**      This method is called upon the receipt of a single step event
**      while inside of a range step. It checks if the IP is still in the
**      specified range, if it isnt then the EM is notified that the
**      process has stopped outside the range, and all the RS structs and
**      notification method are freed.
*/

void
WtMethodRangeStep(
    DEBUG_EVENT  *de,
    HTHDX        hthd,
    DWORD        unused,
    RANGESTEP    *rs
    )
{
    DWORD       currAddr    = (DWORD)PC(hthd);
    ADDR        addr;
    LPWTNODE    wt;
    LPWTNODE    wt1;
    DWORD       ra;
    DWORD       symaddr;


    AddrInit( &addr, 0, PcSegOfHthdx(hthd), currAddr,
              hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal );

    hthd->wtcurr->icnt++;

    if (rs->fIsRet) {
        rs->fIsRet = FALSE;
        WtPrintCallNode( hthd->wtcurr );
        if (hthd->wtcurr->caller) {
            wt1 = hthd->wtcurr;
            wt = wt1->caller;
            wt->scnt += wt1->icnt + wt1->scnt;
            wt->callee = NULL;
            hthd->wtcurr = wt;
            MHFree(wt1);
        }
    }


    if (rs->addrEnd == 0 || currAddr == rs->addrEnd || hthd->wtmode == 2) {

        //
        // unwind the stack, print totals
        //

        wt = hthd->wtcurr;
        while (wt) {
            WtPrintCallNode( wt );
            if (wt1 = wt->caller ) {
                wt1->scnt += wt->icnt + wt->scnt;
                MHFree(wt);
            }
            wt = wt1;
        }

    finished:
        hthd->wtmode = 0;
        ConsumeAllThreadEvents(hthd, FALSE);
        MHFree(rs->method);
        MHFree(rs);
        hthd->tstate &= ~ts_running;
        hthd->tstate |=  ts_stopped;
        NotifyEM(&falseSSEvent, hthd, 0, (LPVOID)0);
        return;
    }

    if (rs->fIsCall) {
        LPSTR p;
        //
        // we just completed a call instruction
        // the pc is the first instruction of a new function
        //
        wt = MHAlloc( sizeof(WTNODE) );
        ZeroMemory( wt, sizeof(WTNODE) );

        hthd->wtcurr->callee = wt;
        wt->caller = hthd->wtcurr;
        wt->lex = hthd->wtcurr->lex + 1;
        wt->offset = currAddr;
        wt->sp = (DWORD)STACK_POINTER(hthd);

        WtGetSymbolName( hthd, &addr, &p, &symaddr, &ra );

        if (!p) {
            p = MHAlloc( 16 );
            sprintf( p, "0x%08x", currAddr );
        } else if (symaddr != currAddr) {
            DWORD l = _tcslen(p);
            p = MHRealloc(p, l + 12);
            sprintf(p + l, "+0x%x", currAddr - symaddr);
        }
        wt->fname = p;

        //
        // put new node at head of chain.
        //

        hthd->wtcurr = wt;
    }

    if (STACK_POINTER(hthd) > hthd->wtcurr->sp) {

        //
        // attempt to compensate for unwinds and longjumps.
        // also catches cases that miss the target address.
        //

        //
        // unwind the stack, print totals
        //

        wt = hthd->wtcurr;
        while (wt && STACK_POINTER(hthd) > wt->sp) {
            WtPrintCallNode( wt );
            if (wt1 = wt->caller ) {
                wt1->scnt += wt->icnt + wt->scnt;
                MHFree(wt);
            }
            wt = wt1;
        }
        if (wt) {
            hthd->wtcurr = wt;
        } else {
            hthd->wtcurr = &hthd->wthead;
            goto finished;
        }

    }

    rs->fIsCall = FALSE;

    rs->fIsRet = IsRet(hthd, &addr);

    if (!rs->fIsRet) {
        int CallFlag;
        IsCall( hthd, &addr, &CallFlag, FALSE );
        if (CallFlag == INSTR_IS_CALL) {
            //
            // we are about to trace a call instruction
            //
            rs->fIsCall = TRUE;
            WtPrintCallNode( hthd->wtcurr );
        }
    }

    SingleStep( hthd, rs->method, TRUE, FALSE );

    return;
}                               /* WtMethodRangeStep() */



void
WtRangeStep(
    HTHDX       hthd
    )

/*++

Routine Description:

    This function is used to implement the watch trace feature in the DM.  Range
    stepping is used to cause all instructions between a pair of addresses
    to be executed.

    The segment is implied to be the current segment.  This is validated
    in the EM.

    Range stepping is done by registering an expected debug event at the
    end of a step and seeing if the current program counter is still in
    the correct range.  If it is not then the range step is over, if it
    is then a new event is register and we loop.

Arguments:

    hthd      - Supplies the thread to be stepped.

Return Value:

    None.

--*/

{
    RANGESTEP   *rs;
    METHOD      *method;
    int         CallFlag  = 0;
    ADDR        addr;
    LPSTR       fname;
    DWORD       ra;
    DWORD       symaddr;
    DWORD       instrOff;


    if (hthd->wtmode != 0) {
        DMPrintShellMsg( "wt command already running for this thread\r\n" );
        return;
    }

    AddrInit( &addr, 0, PcSegOfHthdx(hthd), (DWORD)PC(hthd),
              hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal );
    WtGetSymbolName( hthd, &addr, &fname, &symaddr, &ra );


    //
    //  Create and fill a range step structure
    //
    rs = (RANGESTEP*) MHAlloc(sizeof(RANGESTEP));
    ZeroMemory( rs, sizeof(RANGESTEP) );

    //
    //  Create a notification method for this range step
    //
    method  = (METHOD*) MHAlloc(sizeof(METHOD));
    method->notifyFunction  = (ACVECTOR)WtMethodRangeStep;
    method->lparam          = rs;

    rs->hthd             = hthd;
    rs->segCur           = PcSegOfHthdx(hthd);
    rs->method           = method;
    rs->safetyBP         = NULL;
    rs->stepFunction     = NULL;
    rs->addrStart        = (DWORD)PC(hthd);

    //
    // always tell the watch stepper that the first instruction
    // was a call.  that way, it makes a frame for the place that
    // we are returning to.
    //
    rs->fIsCall          = TRUE;

    hthd->wtcurr         = &hthd->wthead;
    ZeroMemory( hthd->wtcurr, sizeof(WTNODE) );
    hthd->wtcurr->offset = (DWORD)PC(hthd);
    hthd->wtcurr->sp     = (DWORD)STACK_POINTER(hthd);
    hthd->wtcurr->fname  = fname;
    hthd->wtmode         = 1;


    IsCall( hthd, &addr, &CallFlag, FALSE);
    if (CallFlag == INSTR_IS_CALL) {
        ra = GetAddrOff(addr);
    }

    rs->addrEnd = ra;
    DMPrintShellMsg( "Tracing %s to return address %08x\r\n", fname, ra );

    if (CallFlag == INSTR_IS_CALL) {

        //
        // This is a call instruction.  Assume that we
        // want to trace the function that is about to
        // be called.  The call instruction will be the
        // only instruction counted in the current frame.
        //

        //
        //  Call the step over function to send notifications
        //  to the RangeStepper (NOT THE EM!)
        //

        SingleStep(hthd, method, TRUE, FALSE);

    } else {

        //
        // tracing to return address.
        //
        // tell it that we just did a call so that a new
        // frame will be pushed, leaving the current frame
        // to contain this functions caller.
        //

        hthd->wtcurr->icnt = -1;
        WtMethodRangeStep(&falseSSEvent, hthd, 0, rs);
    }

    return;
}                               /* WtRangeStep() */


BOOL
SetupNLG(
    HTHDX hthd,
    LPADDR lpaddr
    )
{
    HNLG hnlg = hnlgNull;
    BOOL fRetVal = FALSE;

    hthd->fStopOnNLG = TRUE;
    while (NULL != (hnlg = LLNext ( hthd->hprc->llnlg, hnlg ))) {

		LPNLG lpnlg = LLLock ( hnlg );

        PBREAKPOINT bp = SetBP( hthd->hprc,
                                hthd,
                                bptpExec,
                                bpnsStop,
                                &lpnlg->addrNLGDispatch,
                                (HPID)INVALID);

		if (bp) {
		
			RegisterExpectedEvent (hthd->hprc,
								   hthd,
								   BREAKPOINT_DEBUG_EVENT,
								   (DWORD)bp,
								   DONT_NOTIFY,
								   ActionNLGDispatch,
								   FALSE,
								   bp);
			fRetVal = TRUE;
		}
								 
        LLUnlock ( hnlg );
    }
	
    if (lpaddr == NULL) {
        SetAddrOff ( &hthd->addrStack, STACK_POINTER(hthd));
    } else {
        SetAddrOff ( &hthd->addrStack, GetAddrOff(*lpaddr) );
    }

	return fRetVal;
}

void
ActionExceptionDuringStep(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    )
/*++

Routine Description:

    If an exception is hit while stepping then ask the EM for the addresses
    of all possible catches and set SS breakpoints thereat.

    Dolphin V3 may go to a new method that does not involve disassembly EH
    registration nodes. See Dolphin 9036 and 8510 for details.

Arguments:

    de       - Current debug event

    hthd     - Thread where debug event occurred

Return Value:

    none

--*/
{
    DWORD subclass = de->u.Exception.ExceptionRecord.ExceptionCode;
    DWORD firstChance = de->u.Exception.dwFirstChance;
    XOSD xosd;
#if !defined(TARGET_i386)
    EXHDLR ExHdlr;
#endif
    EXHDLR *pExHdlr = NULL;

    Unreferenced(lpv);

    if ((subclass == STATUS_SINGLE_STEP) || !firstChance) {
        ProcessExceptionEvent(de, hthd);
        return;
    }
    switch (ExceptionAction(hthd->hprc, subclass)) {
        case efdNotify:
            NotifyEM(de, hthd, 0, NULL);
            break;
        // Dont bother asking for handler addresses
        case efdStop:
        case efdCommand:
            ProcessExceptionEvent(de, hthd);
            return;
    }


#if defined(TARGET_i386)
        assert(lpv != NULL);

    /* Walk the exception registration stack and get the catch locations */

    if ((pExHdlr = GetExceptionCatchLocations(hthd, lpv)) != NULL) {
        xosd = xosdNone;
    } else {
        xosd = xosdGeneral;  /* so we dont instantiate bps below*/
    }

#else   // TARGET_i386
    /* Ask the EM for catch locations */
    xosd = DMSendRequestReply(dbceExceptionDuringStep,
                       hthd->hprc->hpid,
                       hthd->htid,
                       0,
                       NULL,
                       sizeof(EXHDLR),
                       &ExHdlr
                       );
    pExHdlr = &ExHdlr;
#endif  // TARGET_i386


    if (xosd == xosdNone) {
        DWORD i;
        for (i=0; i<pExHdlr->count; i++) {
            PBREAKPOINT bp = SetBP(hthd->hprc,
                                   hthd,
                                   bptpExec,
                                   bpnsStop,
                                   pExHdlr->addr+i,
                                   0);

            if (bp != NULL) {
                METHOD * method = (METHOD *)MHAlloc(sizeof(METHOD));
                method->lparam2 = (LPVOID) bp;
                method->notifyFunction = ConsumeThreadEventsAndNotifyEM;

                RegisterExpectedEvent(hthd->hprc, hthd,
                                      BREAKPOINT_DEBUG_EVENT,
                                      (DWORD)bp,
                                      DONT_NOTIFY,
                                      (ACVECTOR) SSActionRemoveBP,
                                      FALSE,
                                      method);
            }
        }
    }

#if defined(TARGET_i386)
    if (pExHdlr) {
        MHFree(pExHdlr);
    }
#endif  // TARGET_i386

    /* Re-enable myself */
    RegisterExpectedEvent(hthd->hprc, (HTHDX)hthd,
                          EXCEPTION_DEBUG_EVENT,
                          (DWORD)NO_SUBCLASS,
                          DONT_NOTIFY,
                          ActionExceptionDuringStep,
                          FALSE,
                          lpv);
    SetDebugEventThreadState (hthd->hprc, ts_running);

    AddQueue( QT_CONTINUE_DEBUG_EVENT,
              hthd->hprc->pid,
              hthd->tid,
              (DWORD)DBG_EXCEPTION_NOT_HANDLED,
              0);
}

/*** ISINSYSTEMDLL
 *
 * PURPOSE:
 *      Determine if the given uoffDest is in a system DLL
 * INPUT:
 *
 * OUTPUT:
 *     Returns TRUE if uoffDest is in a system dll otherwise FALSE
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *      This function takes a uoffset and determines if it is in the range of
 *      one of the system DLLs by examining the LPIAL list ( Pointer to
 *      invalid address List) that was built up in LoadDll.
 *
 ****************************************************************************/

//extern SYSTEM_INFO SystemInfo;

BOOL
IsInSystemDll (
    UOFFSET uoffDest
    )
{
	return FALSE;
} /* ISINSYSTEMDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tlsetup.h ===
#define HOST_NAME_LEN	255

class TSetupDialog
{
	HWND	m_hWnd;

  private:

	static TSetupDialog*	_this;

  public:

  	TCHAR	m_hostName [HOST_NAME_LEN];
	MPT		m_mpt;
	
  public:

	BOOL OnInitDialog ();

	BOOL OnCommand (WPARAM command);
	BOOL OnCommand_OK ();
	BOOL OnCommand_Cancel ();
	BOOL OnCommand_Help ();

	int DoModal (HWND hWndParent);

  private:

  	static BOOL APIENTRY
	DialogProc(
		HWND	hWnd,
		UINT	msg,
		WPARAM	wParam,
		LPARAM	lParam
		);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tlutil.cpp ===
#include "precomp.h"
#include "tlutil.h"

#define TRANSPORT_NAME _T("TLXBOX")
#define HOST_KEY_NAME _T("HostName")
#define REG_KEY_PREFIX	_T("Build System\\Components\\Platforms\\")
#define REG_KEY_SUFFIX	_T("\\Transports\\" TRANSPORT_NAME)
#define POLL_PORT_KEY_NAME _T("PollPort")
#define MAIN_PORT_KEY_NAME _T("MainPort")

#if 0
typedef struct _PLATFORM_INFO
{
	LPCTSTR	szRegistryKey ;
	LPCTSTR	szDialogTitle ;

} PLATFORM_INFO;


PLATFORM_INFO	rgPlatformInfo [] =
{
	{ NULL, NULL },							// nothing

	{	// mptix86
		_T (REG_KEY_PREFIX "Win32 (x86)" REG_KEY_SUFFIX),
		_T ("Win32 Network (TCP/IP) Settings")
	},
	
	{ NULL, NULL },							// mptm68k -- no more 68k debugging
	{ NULL, NULL },							// mptdaxp
	{ NULL, NULL },							// mptmips

	{	// mptmppc
		_T (REG_KEY_PREFIX "Power Macintosh" REG_KEY_SUFFIX),
		_T ("Power Macintosh Network (TCP/IP) Settings")
	},
	
	{ NULL, NULL },							// mptntppc
	{ NULL, NULL }							// mptUnknown
};
#endif
	

LPCTSTR
GetRegistryKey(
	MPT		mpt
	)
{
    return REG_KEY_PREFIX "Xbox" REG_KEY_SUFFIX;
}


LPCTSTR
GetDialogTitle(
	MPT	mpt
	)
{
	return "Xbox Network (TCP/IP) Settings";
}


BOOL
GetHostName(
	MPT		mpt,
	LPTSTR	buffer,
	ULONG	bufferLen,
	LPGETSETPROFILEPROC	profileProc
	)
{
    //_asm int 3
	BOOL	fSuccess;
	LPCTSTR	key;

	key = GetRegistryKey (mpt);

	if (!key)
		return FALSE;
	
	fSuccess = GetRegistryValue (key,
								 HOST_KEY_NAME,
								 buffer,
								 bufferLen,
								 profileProc
								 );

	return fSuccess;
}

BOOL
SetHostName(
	MPT		mpt,
	LPCTSTR	buffer,
	ULONG	bufferLen,
	LPGETSETPROFILEPROC	profileProc
	)
{
	BOOL	fSuccess;
	LPCTSTR	key;

	key = GetRegistryKey (mpt);

	if (!key)
		return FALSE;
	
	fSuccess = SetRegistryValue (key,
								 HOST_KEY_NAME,
								 buffer,
								 profileProc
								 );

	return fSuccess;
}


BOOL
GetRegistryValue(
	LPCTSTR				szKey,
	LPCTSTR				szValue,
	LPTCH				buffer,
	ULONG				bufferLen,
	LPGETSETPROFILEPROC	GetSetProfile
	)
{
	ULONG	size;
	ULONG	dwType = REG_SZ;
	
	assert (GetSetProfile);

	size = GetSetProfile ((LPTSTR) szKey,
						  (LPTSTR) szValue,
						  &dwType,
						  (BYTE*) buffer,
						  bufferLen,
						  FALSE
						  );

	if (size)
		return TRUE;

	return FALSE;
}

BOOL
GetRegistryValue(
	LPCTSTR				szKey,
	LPCTSTR				szValue,
	DWORD*				lpDword,
	LPGETSETPROFILEPROC	GetSetProfile
	)
{

	ULONG	size;
	ULONG	dwType = REG_DWORD;

	assert (GetSetProfile);

	size = GetSetProfile ((LPTSTR) szKey,
						  (LPTSTR) szValue,
						  &dwType,
						  (BYTE*) lpDword,
						  sizeof (*lpDword),
						  FALSE
						  );

	if (size) {
		return TRUE;
	}

	return FALSE;
}					  
	
	

BOOL
SetRegistryValue(
	LPCSTR				szKey,
	LPCSTR				szValue,
	LPCSTR				szStr,
	LPGETSETPROFILEPROC	GetSetProfile
	)
{
	ULONG	size = _tcslen (szStr);
	ULONG	rSize;
	ULONG	type = REG_SZ;

	rSize = GetSetProfile ( (LPTSTR) szKey,
							(LPTSTR) szValue,
							&type,
							(LPBYTE) szStr,
							size,
							TRUE
							);

	if (rSize == size)
		return TRUE;

	return FALSE;
}


#if 0
void
_Assert(
    const char*     cond,
    const char*     file,
    int             line
    )
{
	DbgPrint ("Assert failed: \"%s\", %s %d\n", cond, file, line);

	if (!_transport.AssertFailed (cond, file, line))
	{
		DbgBreakPoint ();
	}
}


ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	BOOL	fWaitAll,
	ULONG	timeout
	)
{
	HANDLE	rg [2];

	rg[0] = h1;
	rg[1] = h2;

	return WaitForMultipleObjects (2, rg, fWaitAll, timeout);
}


ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	HANDLE	h3,
	BOOL	fWaitAll,
	ULONG	timeout
	)
{
	HANDLE	rg [3];

	rg[0] = h1;
	rg[1] = h2;
	rg[2] = h3;

	return WaitForMultipleObjects (3, rg, fWaitAll, timeout);
}

ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	HANDLE	h3,
	HANDLE	h4,
	BOOL	fWaitAll,
	ULONG	timeout
	)
{
	HANDLE	rg [4];

	rg[0] = h1;
	rg[1] = h2;
	rg[2] = h3;
	rg[3] = h4;

	return WaitForMultipleObjects (4, rg, fWaitAll, timeout);
}	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tlsetup.cpp ===
#include "precomp.h"
#include "resource.h"
#include "tlsetup.h"
#include "tlutil.h"

TSetupDialog*	TSetupDialog::_this	= NULL;


BOOL APIENTRY
TSetupDialog::DialogProc(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
	if (msg == WM_INITDIALOG)
	{
		_this = (TSetupDialog*) lParam;
		_this->m_hWnd = hWnd;
	}
	
    switch (msg)
    {
		case WM_INITDIALOG: return _this->OnInitDialog ();
		case WM_COMMAND: return _this->OnCommand (wParam);
		default: return FALSE;
	}

	return FALSE;
}


BOOL
TSetupDialog::OnCommand(
	WPARAM	cmd
	)
{
	switch (cmd)
	{
		case IDHELP: return OnCommand_Help ();
		case IDOK: return OnCommand_OK ();
		case IDCANCEL: return OnCommand_Cancel ();
		default: return FALSE;
	}

	return FALSE;
}

		
BOOL
TSetupDialog::OnInitDialog(
	)
{
	SetDlgItemText (m_hWnd, IDNAME, m_hostName);
//	SetDlgItemText (m_hWnd, IDPW, lptlctl->szATPassword);
//	SetWindowText (m_hWnd, GetDialogTitle (m_mpt));

#if 0			
		   
	//
	//  The new spec doesn't seem to have anything in the TLSS about
	//  help.  Investigate this.
	
	hCtrl = GetDlgItem (hdlg, IDHELP);
	Assert (hCtrl != NULL);
	EnableWindow (hCtrl, !!(ptlui->lpfnInvokeHelp));
#endif

	return TRUE;
}

#if 0

BOOL
TSetupDialog::OnCommandHelp(
	)
{
	return TRUE;

	if (ptlui->lpfnInvokeHelp != NULL)
	{
		ptlui->lpfnInvokeHelp (IDD_TL_HELP);
		SetWindowLong (hdlg, DWL_MSGRESULT, TRUE);
		return TRUE;
	}
}
#endif


BOOL
TSetupDialog::OnCommand_Help(
	)
{

#if 0
	// can only display help from dev studio, not remote monitor.

	if(glptlssSav->fRMAttached)
	{
		TCHAR tchMsgTitle[MAX_MSG_TITLE];
		if(LoadString(hInstance, IDS_MSGBOX_TITLE, tchMsgTitle, MAX_MSG_TITLE))
		{
			TCHAR tchMsgText[MAX_MSG_TEXT];
			if(LoadString(hInstance, IDS_HELP, tchMsgText, MAX_MSG_TEXT))
				MessageBox(NULL, tchMsgText, tchMsgTitle, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);
		}
	}
	
	// else

	// TODO(michma): TL help needs to be plugged in for dev studio.
#endif

	return TRUE;

}

BOOL
TSetupDialog::OnCommand_OK(
	)
{
	UINT iRet;

	iRet = GetDlgItemText (m_hWnd, IDNAME, m_hostName, HOST_NAME_LEN);
//	iRet = GetDlgItemText ( hdlg, IDPW, szTmp, _MAX_PATH );

	EndDialog (m_hWnd, IDOK);
	return TRUE;
}


BOOL
TSetupDialog::OnCommand_Cancel(
	)
{
	*m_hostName = '\000';
	EndDialog (m_hWnd, IDCANCEL);
	return TRUE;
}


int
TSetupDialog::DoModal(
	HWND	hWndParent
	)
{
	return DialogBoxParam (hInstance, _T ("SETUP"), hWndParent, DialogProc,
						   (LPARAM) this);
}


extern "C" __declspec(dllexport)
VOID WINAPI
TLSetup(
    const TLSS* tlss
    )
{
    TSetupDialog    dlg;

    if (tlss->fInteractive)
    {
        if (!GetHostName (tlss->mpt, dlg.m_hostName, HOST_NAME_LEN,
                          tlss->lpfnGetSet))
        {
            *dlg.m_hostName = '\000';
        }

        dlg.m_mpt = tlss->mpt;

        if (dlg.DoModal ((HWND) tlss->lpvPrivate) == IDOK)
        {
            SetHostName (tlss->mpt, dlg.m_hostName, HOST_NAME_LEN,
                         tlss->lpfnGetSet);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\tlutil.h ===
BOOL
GetHostName(
	MPT		mpt,
	LPTSTR	buffer,
	ULONG	bufferLen,
	LPGETSETPROFILEPROC	profileProc
	);

LPCTSTR
GetDialogTitle(
	MPT	mpt
	);

BOOL
GetRegistryValue(
	LPCTSTR				szKey,
	LPCTSTR				szValue,
	LPSTR				buffer,
	ULONG				bufferLen,
	LPGETSETPROFILEPROC	GetSetProfile
	);

BOOL
SetRegistryValue(
	LPCTSTR				szKey,
	LPCTSTR				szValue,
	LPCTSTR				szStr,
	LPGETSETPROFILEPROC	GetSetProfile
	);

BOOL
SetHostName(
	MPT		mpt,
	LPCTSTR	buffer,
	ULONG	bufferLen,
	LPGETSETPROFILEPROC	profileProc
	);


ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	BOOL	fWaitAll,
	ULONG	timeout
	);

ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	HANDLE	h3,
	BOOL	fWaitAll,
	ULONG	timeout
	);

ULONG
WaitForMultiple(
	HANDLE	h1,
	HANDLE	h2,
	HANDLE	h3,
	HANDLE	h4,
	BOOL	fWaitAll,
	ULONG	timeout
	);



USHORT
GetPollPort(
	MPT					mpt,
	LPGETSETPROFILEPROC	profileProc
	);


USHORT
GetMainPort(
	MPT					mpt,
	LPGETSETPROFILEPROC	profileProc
	);

BOOL
GetRegistryValue(
	LPCTSTR				szKey,
	LPCTSTR				szValue,
	DWORD*				lpDword,
	LPGETSETPROFILEPROC	GetSetProfile
	);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\walk.c ===
/*++

Copyright(c) 1992  Microsoft Corporation

Module Name:

    Walk.c

Abstract:

    This module contains the support for "Walking".


Author:

    Kent Forschmiedt (kentf) January 1, 1996

Environment:

    Win32, User Mode

--*/

#include "precomp.h"
#pragma hdrstop


//
//  Externals
//

extern DMTLFUNCTYPE DmTlFunc;
extern char         abEMReplyBuf[];
extern DEBUG_EVENT  falseBPEvent;


extern CRITICAL_SECTION csWalk;
extern CRITICAL_SECTION csThreadProcList;


#ifdef HAS_DEBUG_REGS
//
// Initializer defined in dm.h
//
DWORD DebugRegDataSizes [] = DEBUG_REG_DATA_SIZES;
#define NDEBUG_REG_DATA_SIZES  (sizeof(DebugRegDataSizes) / sizeof(*DebugRegDataSizes))

#endif


#define IsDataBp(_bptp) ((_bptp) == bptpDataC || (_bptp) == bptpDataR || \
                         (_bptp) == bptpDataW || (_bptp) == bptpDataW)
                         
//
//  Walk Structure.
//
//  Contains information to perform a walk on a thread.
//
typedef struct _WALK {
    LIST_ENTRY  AllWalkEntry;   //  Member of AllWalkList
    LIST_ENTRY  ThreadWalkEntry;//  Member of hthd->WalkList

    LIST_ENTRY  GroupWalkList;  //  Binding to breakpoints

    HTHDX       hthd;           //  thread
    BPTP        BpType;         //  Breakpoint type
    BOOL        Active;         //  Active flag
    DWORD       GlobalCount;    //  All thread ref count
    DWORD       LocalCount;     //  per-thread ref count

    union {
        struct {
            DWORD       AddrStart;      // Range Begin
            DWORD       AddrEnd;        // Range End
            PBREAKPOINT StartBP;        // BP on range entry
            DWORD       SavedSP;        // Saved Stack Pointer
            BOOL        fInRange;       // Whether we were in range (last step)
        } Range;

        struct {
            DWORD       DataAddr;       // Data Address
            DWORD       DataSize;       // Data Size
            PVOID       DataContents;   // For change detection
        } Data;
    } u;

    METHOD      Method;         //  Walk method
    int         Register;

} WALK;
typedef struct _WALK      *PWALK;

//
// This node binds a walk structure to one or more breakpoints.
//
// One of these nodes will be allocated for each binding of
// a WALK to a breakpoint.
//
typedef struct _WALK_GROUP_ENTRY {

    //
    // Here is the list of walks that belongs to a breakpoint.
    // This is a list of WALK_GROUP_ENTRY nodes; all nodes on
    // this list represent the same breakpoint, each represents
    // a different WALK.
    //
    
    LIST_ENTRY  WalksInGroup;

    //
    // Here is the list of breakpoints which are using this walk.
    // All WALK_GROUP_ENTRY nodes in this list refer to the same
    // WALK, while each refers to a different breakpoint.
    //

    LIST_ENTRY  GroupsUsingWalk;

    //
    // Here is the walk associated with this node:
    //

    PWALK Walk;

} WALK_GROUP_ENTRY, *PWALK_GROUP_ENTRY;


//
// This is the data that gets propigated through MethodWalk.
//

typedef struct _WALK_INFO {
    BREAKPOINT*     SafetyBP;
} WALK_INFO, *PWALK_INFO;



//
//  Local variables
//
LIST_ENTRY  AllWalkList;


PWALK
SetWalkForThread(
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    BPTP    BpType,
    BOOL    Global,
    BOOL    fEmulate
    );

BOOL
RemoveWalkThread (
    HPRCX hprc,
    HTHDX hthd,
    DWORD Addr,
    DWORD Size,
    BPTP  BpType,
    BOOL
    );

BOOL
SetupWalk(
    PWALK Walk,
    BOOL Continuing
    );

PWALK
AllocateWalk(
    HTHDX hthd,
    DWORD Addr,
    DWORD Size,
    BPTP BpType,
    BOOL fEmulate
    );

BOOL
DeallocateWalk(
    PWALK
    );

BOOL
RemoveWalkEntry(
    PWALK Walk,
    BOOL Global
    );

PWALK
FindWalk (
    HTHDX hthd,
    DWORD Addr,
    DWORD Size,
    BPTP BpType
    );

PWALK
FindWalkForHthd(
    HANDLE hWalk,
    HTHDX hthd
    );

PBREAKPOINT
FindBpForWalk(
    PVOID pWalk
    );

int
MethodWalk(
    DEBUG_EVENT*,
    HTHDX,
    DWORD,
    PWALK_INFO
    );

VOID
AddWalkToGroupList(
    PLIST_ENTRY GroupList,
    PWALK Walk
    );

VOID
RemoveWalkBindings(
    PWALK Walk
    );

VOID
DuplicateWalkBindings(
    PWALK OldWalk,
    PWALK NewWalk
    );

BOOL
InRange(
    UOFFSET LowRange,
    UOFFSET HighRange,
    UOFFSET Pc
    );

BOOL
KuFreezeThread(
    HTHDX   hthd,
    BOOL*   Froze
    );

BOOL
KuThawThread(
    HTHDX   hthd
    );

int
DrAllocateDebugRegister(
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    DWORD   BpType
    );

BOOL
DrDeallocateDebugRegister(
    HTHDX   hthd,
    int     Register
    );

BOOL
DrIsDebugRegisterInUse(
    HTHDX   hthd,
    int     Register
    );

BOOL
DrSetupDebugRegister(
    HTHDX   hthd,
    int     Register
    );

VOID
DrClearDebugRegister(
    HTHDX   hthd,
    int     Register
    );

VOID
DrSetDebugRegisterInUse(
    HTHDX   hthd,
    int     Register,
    BOOL    InUse
    );

ULONG
DrGetDebugRegisterDataSize(
    HTHDX   hthd,
    int     Register
    );


BREAKPOINT*
SetupSafetyBp(
    HTHDX       hthd,
    METHOD*     Mehtod
    );


//*******************************************************************
//
//                      Exported Functions
//
//******************************************************************


VOID
ExprBPInitialize(
    VOID
    )
{
    InitializeListHead (&AllWalkList);
}


VOID
ExprBPCreateThread(
    HPRCX   hprc,
    HTHDX   hthd
    )
/*++

Routine Description:

    If global walking, adds walk to new thread. Called when a
    new thread is created.

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

Return Value:

    None
--*/

{
    PWALK       Walk;
    PLIST_ENTRY List;
    HTHDX       hthdT;
    PWALK       twalk;
    DWORD       Addr;
    DWORD       Count;
    BOOL        fEmulate = FALSE;

    //
    //  If there are global walks, set them in this thread
    //

    //
    //  Get a walk list from any thread in this process and
    //  traverse it, copying any global walks.  Note that we
    //  can use any walk list because global walks are common
    //  to all threads.
    //

    EnterCriticalSection (&csWalk);

    EnterCriticalSection (&csThreadProcList);
    hthdT = hprc->hthdChild;

    while (hthdT && hthdT == hthd) {
        hthdT = hthdT->nextSibling;
    }

    LeaveCriticalSection (&csThreadProcList);

    if (hthdT) {

        List = hthdT->WalkList.Flink;

        while (List != &hthdT->WalkList) {
            Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
            List = List->Flink;

            if ( Walk->GlobalCount > 0 ) {

                if (Walk->BpType == bptpRange) {

                    Addr = Walk->u.Range.AddrStart ;
                    Count = Walk->u.Range.AddrEnd - Addr;

                } else {

                    Addr = Walk->u.Data.DataAddr;
                    Count = Walk->u.Data.DataSize;

                    // If the one we are duping is eumlated, emulate this
                    // one also
                    
                    if (Walk->Register == -1) {
                        fEmulate = TRUE;
                    }
                }
                    

                    
                twalk = SetWalkForThread (hprc,
                                          hthd,
                                          Addr,
                                          Count,
                                          Walk->BpType,
                                          TRUE,
                                          fEmulate
                                          );
                //
                // bind the new walk record the same as the old:
                //
                //
                
                DuplicateWalkBindings (Walk, twalk);

            }
        }
    }

    LeaveCriticalSection(&csWalk);
}


VOID
ExprBPExitThread (
    HPRCX   hprc,
    HTHDX   hthd
    )
/*++

Routine Description:

    Removes walk in a thread, called when the thread is gone.

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

Return Value:

    None

--*/

{
    PLIST_ENTRY List;
    PWALK       Walk;
    DWORD       GlobalCount;
    DWORD       LocalCount;

    EnterCriticalSection (&csWalk);

    List = hthd->WalkList.Flink;

    while ( List != &hthd->WalkList ) {

        Walk = CONTAINING_RECORD(List, WALK, ThreadWalkEntry);
        List = List->Flink;

        GlobalCount = Walk->GlobalCount;
        LocalCount  = Walk->LocalCount;
        while ( GlobalCount-- ) {
            RemoveWalkEntry (Walk, TRUE);
        }
        while ( LocalCount-- ) {
            RemoveWalkEntry (Walk, FALSE);
        }
    }

    LeaveCriticalSection (&csWalk);
}


VOID
ExprBPContinue(
    HPRCX   hprc,
    HTHDX   hthd
    )
/*++

Routine Description:

    Continues walking. Called as a result of a continue command.

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

Return Value:

    None

--*/

{
    PWALK       Walk;
    PLIST_ENTRY List;


    if (!hthd) {
        return;
    }
    
    //
    //  See if we have a walk on the thread
    //

    EnterCriticalSection (&csWalk);

    List = hthd->WalkList.Flink;
    while (List != &hthd->WalkList) {

        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
        List = List->Flink;

        if (!Walk->Active) {
            SetupWalk (Walk, TRUE);
        }
    }
    
    LeaveCriticalSection (&csWalk);
}



VOID
ExprBPResetBP(
    HTHDX hthd,
    PBREAKPOINT bp
    )
/*++

Routine Description:

    After stepping off of a hardware BP, reset debug register(s)
    before continuing.

Arguments:

    hthd - Supplies the thread which has been stepped.

    bp - Supplies the BREAKPOINT

Return Value:

    none

--*/
{
    PWALK   Walk;

    Walk = FindWalkForHthd (bp->hWalk, hthd);
    
    if (Walk->Register >= 0) {
        assert (DrIsDebugRegisterInUse (hthd, Walk->Register));
        DrSetupDebugRegister (hthd, Walk->Register);
    }

}



VOID
ExprBPClearBPForStep(
    HTHDX hthd
    )
/*++

Routine Description:

    Turn off a hardware breakpoint to allow a single step to occur.
    This is necessary for x86 exec breakpoints, but not for data read/write.

Arguments:

    hthd - Supplies the thread which is going to be stepped.

Return Value:

    none

--*/
{
    BREAKPOINT* bp;
    PWALK       Walk;

    bp = AtBP (hthd);
    assert (bp);

    assert (bp->hWalk);

    Walk = FindWalkForHthd (bp->hWalk, hthd);

    if (Walk->Register >= 0) {
        assert (DrIsDebugRegisterInUse (hthd, Walk->Register));
        DrClearDebugRegister (hthd, Walk->Register);
    }
}


void
ExprBPRestoreDebugRegs(
    HTHDX   hthd
    )
/*++

Routine Description:

    Restore the CPU debug registers to the state that we last put
    them in.  This routine is needed because the system trashes
    the debug registers after initializing the DLLs and before the
    app entry point is executed.

Arguments:

    hthd    - Supplies descriptor for thread whose registers need fixing.

Return Value:

    None

--*/
{
#ifndef HAS_DEBUG_REGS

    Unreferenced (hthd);

#else

    PWALK       Walk;
    PLIST_ENTRY List;

    EnterCriticalSection (&csWalk);

    List = hthd->WalkList.Flink;

    while (List != &hthd->WalkList) {

        Walk = CONTAINING_RECORD(List, WALK, ThreadWalkEntry);
        List = List->Flink;

        if (Walk->Active && Walk->Register >= 0 &&
            DrIsDebugRegisterInUse (hthd, Walk->Register)) {

            DrSetupDebugRegister (hthd, Walk->Register);
        }
    }
    LeaveCriticalSection (&csWalk);

#endif
}



HANDLE
GetNewWalk(
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    DWORD   BpType,
    BOOL    fEmulate
    )
/*++

Routine Description:

    Sets up a walk.  Returns a handle which may be used to associate this
    walk with a breakpoint structure.

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

    Addr    -   Supplies address

    Size    -   Supplies size of memory to watch

    BpType  -   Supplies type of breakpoint

Return Value:

    A handle to the new list of walks

--*/

{

    PWALK       Walk;
    PLIST_ENTRY GroupList = NULL;

    if ( !hprc ) {
        return NULL;
    }

    //
    // If a thread is specified, we use that specific thread,
    // otherwise we must set the walk in all existing threads,
    // plus we must set things up so that we walk all future
    // threads too (while this walk is active).
    //
    
    if (hthd) {

        //
        // This is for a per-thread walk.
        //
        
        Walk = SetWalkForThread (hprc,
                                 hthd,
                                 Addr,
                                 Size,
                                 BpType,
                                 FALSE,
                                 fEmulate);

        if (Walk) {
            GroupList = MHAlloc (sizeof (LIST_ENTRY));
            InitializeListHead (GroupList);
            AddWalkToGroupList (GroupList, Walk);
        }

    } else {

        //
        // This is for a walk in all thread (Global walk); the more normal
        // case.
        //
        
        GroupList = MHAlloc (sizeof (LIST_ENTRY));
        InitializeListHead (GroupList);

        EnterCriticalSection (&csThreadProcList);

        for ( hthd = (HTHDX)hprc->hthdChild;
              hthd;
              hthd = hthd->nextSibling ) {

            Walk = SetWalkForThread (hprc,
                                     hthd,
                                     Addr,
                                     Size,
                                     BpType,
                                     TRUE,
                                     fEmulate);

            if (Walk) {
                AddWalkToGroupList (GroupList, Walk);
            }
        }

        LeaveCriticalSection (&csThreadProcList);

        if (IsListEmpty (GroupList)) {
            MHFree (GroupList);
            GroupList = NULL;
        }
    }

    return (HANDLE) GroupList;
}


BOOL
RemoveWalk(
    HANDLE hWalk,
    BOOL Global
    )

/*++

Routine Description:

    Remove a group of walks.

Arguments:


Return Value:


--*/

{
    PLIST_ENTRY GroupListHead = (PLIST_ENTRY)hWalk;
    PLIST_ENTRY List;
    PWALK_GROUP_ENTRY Entry;
    PWALK Walk;

    List = GroupListHead->Flink;

    while (List != GroupListHead) {
        Entry = CONTAINING_RECORD(List, WALK_GROUP_ENTRY, WalksInGroup);
        List = List->Flink;
        Walk = Entry->Walk;

        RemoveWalkEntry(Walk, Global);
    }

    //
    // The list head pointed to by GroupList will be freed
    // when the last entry is deleted by DeallocateWalk.
    //

    return TRUE;
}



BOOL
RemoveWalkEntry(
    PWALK   Walk,
    BOOL    fGlobal
    )
{
    HTHDX   hthd = Walk->hthd;
    BOOL    Froze = FALSE;
    BOOL    Ok;

    Ok = KuFreezeThread (hthd, &Froze);

    //
    //  Remove the walk
    //

    fGlobal ? Walk->GlobalCount-- : Walk->LocalCount--;

    if (Walk->GlobalCount == 0 && Walk->LocalCount  == 0) {

        //
        //  If the walk is active, the method will eventually
        //  be called. Otherwise we must call the method
        //  ourselves.
        //

        if (!Walk->Active) {
            MethodWalk (NULL, hthd, 0, hthd->WalkData);
        }
    }

    if (Froze) {
        KuThawThread (hthd);
    }

    return TRUE;
}


PBREAKPOINT
GetWalkBPFromBits(
    HTHDX   hthd,
    DWORD   bits
    )
{
    //
    // NOTE: this function is x86 only.
    //
    
#ifndef HAS_DEBUG_REGS
    return NULL;
#else

    PWALK       Walk;
    PLIST_ENTRY List;
    PBREAKPOINT bp = NULL;

    EnterCriticalSection (&csWalk);

    //
    // This only finds the first match.  If more than one BP was
    // matched by the CPU, we won't notice.
    //

    List = hthd->WalkList.Flink;

    while (List != &hthd->WalkList) {
        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
        List = List->Flink;

        if ( Walk->Register >= 0 &&
             DrIsDebugRegisterInUse (hthd, Walk->Register)) {

            if (bits & (1 << Walk->Register)) {
                // hit!
                bp = FindBpForWalk (Walk);
                break;
            }
        }
    }

    LeaveCriticalSection (&csWalk);

    return bp;
#endif
}


BOOL
InRange(
    UOFFSET LowRange,
    UOFFSET HighRange,
    UOFFSET Pc
    )
{
    return (LowRange <= Pc && Pc < HighRange);
}



BOOL
CheckWalk(
    PWALK Walk
    )
/*++

Routine Description:

    This decides whether a data or range breakpoint should fire.

    Current implementation handles:

        Data change, emulated or implemented on hardware write BP
        Range BP

    Not handled:

        Emulated data read/write BP

Arguments:

    Walk - Supplies the thread and breakpoint info

Return Value:

    TRUE if the breakpoint should fire, FALSE if it should be ignored.
    This implementation is conservative; unhandled cases always return TRUE.

--*/
{
    PVOID Data;
    DWORD dwSize;
    BOOL ret = TRUE;

    if (Walk->BpType == bptpDataC) {
        if (Walk->u.Data.DataContents && (Data = MHAlloc(Walk->u.Data.DataSize))) {
            if (DbgReadMemory(Walk->hthd->hprc,
                              (PVOID)Walk->u.Data.DataAddr,
                              Data,
                              Walk->u.Data.DataSize,
                              &dwSize)) {
                ret = (memcmp(Data, Walk->u.Data.DataContents, Walk->u.Data.DataSize) != 0);
            }
            MHFree(Data);
        }
    }
    else if (Walk->BpType == bptpRange) {

        ret = !InRange (Walk->u.Range.AddrStart,
                        Walk->u.Range.AddrEnd,
                        PC (Walk->hthd));
    }

    return ret;
}


BOOL
CheckDataBP(
    HTHDX hthd,
    PBREAKPOINT Bp
    )
/*++

Routine Description:

    This decides whether a breakpoint should fire.  If it is not
    a data breakpoint, it should fire.  If it is a data breakpoint,
    decide whether it has been satisfied.

Arguments:

    hthd - Supplies the thread that stopped

    Bp   - Supplies the breakpoint that was hit

Return Value:

    TRUE if the breakpoint has really fired, FALSE if it should be ignored.

--*/
{
    PWALK Walk;

    assert (hthd);
    assert (Bp);

    if (!Bp->hWalk) {
        return TRUE;
    }

    Walk = FindWalkForHthd (Bp->hWalk, hthd);

    assert (Walk);

    if (!Walk) {
        return TRUE;
    }

    return CheckWalk(Walk);
}

//*******************************************************************
//
//                      Local Functions
//
//******************************************************************

BOOL
KuFreezeThread(
    HTHDX   hthd,
    BOOL*   Froze
    )
{
	return TRUE;
#if 0
#ifdef KERNEL
    return TRUE;
#else

    if ( !(hthd->tstate & ts_running) || (hthd->tstate & ts_frozen) ) {
        return TRUE;
    } else if (SuspendThread (hthd->rwHand) != -1L) {
        if (Froze) {
            *Froze = TRUE;
        }

        hthd->tstate |= ts_frozen;
        hthd->context.ContextFlags = CONTEXT_CONTROL;
        DbgGetThreadContext (hthd, &hthd->context);
    } else {
        return FALSE;
    }

    return TRUE;

#endif
#endif
}

BOOL
KuThawThread(
    HTHDX   hthd
    )
{
	return TRUE;
#if 0
#ifdef KERNEL
    return TRUE;
#else

    assert (hthd->tstate & ts_frozen);
    
    if (!ResumeThread (hthd->rwHand)) {
        return FALSE;
    }

    hthd->tstate &= ~ts_frozen;
    return TRUE;

#endif
#endif
}


PWALK
SetWalkForThread(
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    DWORD   BpType,
    BOOL    Global,
    BOOL    fEmulate
    )
/*++

Routine Description:

    Sets up a walk in a specific thread

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

    Addr    -   Supplies address

    Size    -   Supplies Size

    BpType  -   Supplies type (read, read/write, change, exec, range)

    Global  -   Supplies global flag

Return Value:

    BOOL    -   TRUE if Walk set

--*/

{
    PWALK   Walk            = NULL;
    BOOL    AllocatedWalk   = FALSE;    
    BOOL    Ok              = FALSE;
    BOOL    Froze           = FALSE;


    Walk = FindWalk (hthd, Addr, Size, BpType);

    if (Walk) {

        //
        //  If the walk is already active, just increment the
        //  reference count and we're done.
        //

        //
        // If it is not active, fall through and activate it
        //

        if (Walk->Active) {
            Global ? Walk->GlobalCount++ : Walk->LocalCount++;
            Ok = TRUE;
            goto Done;
        }

    } else {

        //
        //  Allocate a walk for this thread.
        //

        if ( Walk = AllocateWalk( hthd, Addr, Size, BpType, fEmulate) ) {
            AllocatedWalk = TRUE;
        } else {
            goto Done;
        }
    }

    //
    //  We have to freeze the specified thread in order to get
    //  the current address.
    //
    
    Ok = KuFreezeThread (hthd, &Froze);
    
    if (Ok) {

        //
        //  Increment reference count
        //

        Global ? Walk->GlobalCount++ : Walk->LocalCount++;

        Ok = SetupWalk (Walk, FALSE);

        
        //
        //  Resume the thread if we froze it.
        //
        
        if (Froze) {
            KuThawThread (hthd);
        }
    }

Done:

    if (!Ok) {
        if (Walk && AllocatedWalk) {
            DeallocateWalk (Walk);
        }
        Walk = NULL;
    }

    return Walk;
}




BOOL
RemoveWalkThread (
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    BPTP    BpType,
    BOOL    Global
    )
/*++

Routine Description:

    Removes a walk in a specific thread

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

    Addr    -   Supplies address

    Size    -   Supplies Size

    BpType  -   Supplies breakpoint type

    Global  -   Supplies global flag

Return Value:

    BOOL    -   TRUE if Walk removed

--*/

{
    PWALK       Walk;

    if (Walk = FindWalk (hthd, Addr, Size, BpType)) {
        return RemoveWalkEntry (Walk, Global);
    } else {
        return FALSE;
    }
}



BOOL
SetupWalk(
    PWALK   Walk,
    BOOL    Continuing
    )
/*++

Routine Description:

    Starts walking.

Arguments:

    Walk    -   Supplies the walk sructure

    Continuing - Supplies a flag saying that the thread is being continued

Return Value:

    BOOL    -   TRUE if done

--*/
{
    BREAKPOINT* bp;
    ACVECTOR    action  = NO_ACTION;
    HTHDX       hthd = Walk->hthd;
    DWORD       dwSize;
    BOOL        fSucc;
    PWALK_INFO  WalkInfo = (PWALK_INFO) hthd->WalkData;

    if (!(hthd->tstate & ts_stopped) || Continuing) {

        if (Walk->BpType == bptpDataC) {

            //
            // Remember contents for change detection.
            //

            if (Walk->u.Data.DataContents) {
                MHFree (Walk->u.Data.DataContents);
            }
            
            Walk->u.Data.DataContents = MHAlloc (Walk->u.Data.DataSize);

            //
            // If we can not read the data, just fire on any write
            //

            fSucc = DbgReadMemory (hthd->hprc,
                                   (PVOID)Walk->u.Data.DataAddr,
                                   Walk->u.Data.DataContents,
                                   Walk->u.Data.DataSize,
                                   &dwSize);

            if (!fSucc) {
                MHFree (Walk->u.Data.DataContents);
                Walk->u.Data.DataContents = NULL;
            }
        }

        if (Walk->Register >= 0) {

            // check whether the register is currently being used ?? ?
            
            fSucc = DrSetupDebugRegister (hthd, Walk->Register);
            assert (fSucc);
            Walk->Active = TRUE;
            DrSetDebugRegisterInUse (hthd, Walk->Register, TRUE);

        } else {


            //
            // RangeBP within range or an emulated DataBP.
            //

            if (Walk->BpType == bptpRange) {


                if (Walk->u.Range.SavedSP == 0) {
                        //
                        // This really should not happen, but sometimes
                        // if we start on a call instruction
                        // ProcessContinueCmd () gives us control only after
                        // the call.  Hence we may potentially have not
                        // initialized SP.  If we note the SP here, it will
                        // do.
                        //

                        Walk->u.Range.SavedSP = STACK_POINTER (hthd);
                    }
                    


                if (InRange (Walk->u.Range.AddrStart,
                             Walk->u.Range.AddrEnd,
                             PC (hthd))) {

                    //
                    // We are currently in Range.
                    //

                    //
                    // Setup the safety BP in case we run too far.
                    //
                
                    if (WalkInfo->SafetyBP == NULL) {
                        WalkInfo->SafetyBP = SetupSafetyBp (hthd,
                                                            &Walk->Method);
                    }
                
                }
            }
                    

            //
            // If the thread is sitting on a BP, the step off of BP code
            // does its thing first, then the walk method gets control.
            //


            bp = AtBP (hthd);

            if (!bp) {

                Walk->Active = TRUE;

                //
                //  Setup a single step
                //
                
                if (!SetupSingleStep (hthd, FALSE,TRUE)) {
                    return FALSE;
                }

                //
                //  Place a single step on our list of expected events.
                //
                
                if (!(hthd->tstate & ts_stopped) || Continuing) {
                    RegisterExpectedEvent (hthd->hprc,
                                           hthd,
                                           EXCEPTION_DEBUG_EVENT,
                                           (DWORD)EXCEPTION_SINGLE_STEP,
                                           &(Walk->Method),
                                           action,
                                           FALSE,
                                           NULL);
                }
            }

        }

        //
        // This code is unnecessary (wrong?) because the shell does the
        // gating breakpoint stuff.
        //
        
#if 0
        else {

            //
            // Range BP, current IP is out of range.
            //

            //
            // This implementation only works reliably for function
            // scoped range BPs.  If a range has an entry point other
            // than its lowest address, it will fail to activate the
            // range stepper on entry.
            //

            ADDR        bpAddr;
            BREAKPOINT* pbp;

            WalkInfo->fInRange = FALSE;
            WalkInfo->oldSP = STACK_POINTER (hthd);
            WalkInfo->SafetyBP = NULL;
            
            AddrFromHthdx (&bpAddr, hthd);
            bpAddr.addr.off = Walk->u.Range.AddrStart;

            pbp = FindBP (Walk->hthd->hprc,
                          Walk->hthd,
                          bptpExec,
                          bpnsStop,
                          &bpAddr,
                          TRUE);


            if (!pbp) {
                METHOD* method;

                method = (METHOD*) MHAlloc (sizeof (METHOD));
                
                *method = Walk->Method;
                
                Walk->u.Range.StartBP = SetBP (Walk->hthd->hprc,
                                               Walk->hthd,
                                               bptpExec,
                                               bpnsStop,
                                               &bpAddr,
                                               (HPID)INVALID);
                                      
                method->lparam2 = (LPVOID) Walk->u.Range.StartBP;

                RegisterExpectedEvent (Walk->hthd->hprc,
                                       Walk->hthd,
                                       BREAKPOINT_DEBUG_EVENT,
                                       (DWORD) Walk->u.Range.StartBP,
                                       DONT_NOTIFY,
                                       SSActionRemoveBP,
                                       FALSE,
                                       method);
            }
        }
#endif
    }

    return TRUE;
}


//*******************************************************************
//
//                      WALK Stuff
//
//******************************************************************


PWALK
AllocateWalk (
    HTHDX       hthd,
    DWORD       Addr,
    DWORD       Size,
    BPTP        BpType,
    BOOL        fEmulate
    )
/*++

Routine Description:

    Allocates new Walk structure and adds it to the list

Arguments:

    hthd    -   Supplies thread

    Addr    -   Supplies address

    Size    -   Supplies Size

    BpType  -   Read, write, change, exec

    fEmulate-   Suggestion to the DM to eumlate this walk.

Return Value:

    PWALK   -   Walk created

--*/
{
    PWALK   Walk;
    DWORD   i;

    EnterCriticalSection(&csWalk);

    if ( Walk = (PWALK)MHAlloc( sizeof( WALK ) ) ) {

        Walk->hthd          = hthd;
        Walk->GlobalCount   = 0;
        Walk->LocalCount    = 0;
        Walk->Active        = FALSE;
        Walk->BpType        = BpType;
        Walk->Register      = -1;

        Walk->u.Data.DataContents  = NULL;
        Walk->u.Range.StartBP       = NULL;

        if (hthd->WalkData == NULL) {
            hthd->WalkData = MHAlloc (sizeof (WALK_INFO));
            memset (hthd->WalkData, 0, sizeof (WALK_INFO));
        }

        Walk->Method.notifyFunction     = (ACVECTOR)MethodWalk;
        Walk->Method.lparam             = hthd->WalkData;

        InitializeListHead (&Walk->GroupWalkList);
        InsertTailList (&AllWalkList, &Walk->AllWalkEntry);
        InsertTailList (&hthd->WalkList, &Walk->ThreadWalkEntry);

        if (BpType == bptpRange) {

            Walk->Register          = -1;
            Walk->u.Range.AddrStart = Addr;
            Walk->u.Range.AddrEnd   = Addr + Size;
            Walk->u.Range.SavedSP   = 0;
            Walk->u.Range.fInRange  = FALSE;

        } else if (Addr == 0) {

            Walk->u.Data.DataAddr   = 0;
            Walk->u.Data.DataSize   = 0;
            Walk->Register          = -1;
            Walk->u.Range.AddrStart = 0;
            Walk->u.Range.AddrEnd   = 0;

        } else if (IsDataBp (BpType)) {

            Walk->u.Data.DataAddr      = Addr;
            Walk->u.Data.DataSize      = Size;

            if (!fEmulate) {
                Walk->Register = DrAllocateDebugRegister (hthd,
                                                          Addr,
                                                          Size,
                                                          BpType);
            } else {
                Walk->Register = -1;
            }

         } else {

            assert (FALSE); // the BpType was invalid
         }
    }

    LeaveCriticalSection (&csWalk);

    return Walk;
}




BOOL
DeallocateWalk (
    PWALK   Walk
    )
/*++

Routine Description:

    Takes a walk out of the list and frees its memory.

Arguments:

    Walk    -   Supplies Walk to deallocate

Return Value:


    BOOLEAN -   TRUE if deallocated

--*/
{
    EnterCriticalSection(&csWalk);

    RemoveEntryList (&Walk->AllWalkEntry);
    RemoveEntryList (&Walk->ThreadWalkEntry);

    RemoveWalkBindings (Walk);

    if (Walk->Register >= 0) {
        DrDeallocateDebugRegister (Walk->hthd, Walk->Register);
    }
    
    if (IsDataBp (Walk->BpType) && Walk->u.Data.DataContents) {
        MHFree (Walk->u.Data.DataContents);
    }

    MHFree (Walk);

    LeaveCriticalSection (&csWalk);

    return TRUE;
}




PWALK
FindWalk(
    HTHDX       hthd,
    DWORD       Addr,
    DWORD       Size,
    BPTP        BpType
    )
/*++

Routine Description:

    Finds a walk

Arguments:

    hthd        -   Supplies thread

    Addr        -   Supplies Address

    Size        -   Supplies Size

    BpType      -   Supplies type of BP

Return Value:

    PWALK       -   Found Walk

--*/

{
    PWALK   Walk;
    PWALK   FoundWalk = NULL;
    PLIST_ENTRY List;

    EnterCriticalSection (&csWalk);

    List = hthd->WalkList.Flink;

    while ( List != &hthd->WalkList ) {

        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
        List = List->Flink;

        if ( Walk->BpType == BpType ) {
        
            if (BpType == bptpRange) {

                if (Walk->u.Range.AddrStart == Addr &&
                    Walk->u.Range.AddrEnd == Addr + Size) {
                    FoundWalk = Walk;
                    break;
                }

            } else {
            
                if ((Walk->u.Data.DataAddr == 0) ||
                    (Walk->u.Data.DataAddr == Addr) ) {

                    if ( Walk->Register == -1 ) {

                        FoundWalk = Walk;
                        break;

                    } else if (Size <= DrGetDebugRegisterDataSize (hthd,
                                          Walk->Register)) {
                                          
                        FoundWalk = Walk;
                        break;
                    }
                }
            }
        }
    }

    LeaveCriticalSection (&csWalk);

    return FoundWalk;
}


PWALK
FindWalkForHthd(
    HANDLE  hWalk,
    HTHDX   hthd
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PLIST_ENTRY         GroupList = (PLIST_ENTRY)hWalk;
    PWALK_GROUP_ENTRY   Entry;
    PLIST_ENTRY         List;
    PWALK               Walk;

    List = GroupList->Flink;

    while (List != GroupList) {
        Entry = CONTAINING_RECORD (List, WALK_GROUP_ENTRY, WalksInGroup);
        List = List->Flink;
        Walk = Entry->Walk;

        if (Walk->hthd == hthd) {
            return Walk;
        }
    }
    return NULL;
}



BOOL
IsWalkInGroup(
    HANDLE hWalk,
    PVOID  pWalk
    )
/*++

Routine Description:

    Tells if a specific WALK* is in a group of walks.

--*/
{
    PLIST_ENTRY         GroupList = (PLIST_ENTRY)hWalk;
    PWALK_GROUP_ENTRY   Entry;
    PLIST_ENTRY         List;
    PWALK               Walk;

    List = GroupList->Flink;
    
    while (List != GroupList) {

        Entry = CONTAINING_RECORD (List, WALK_GROUP_ENTRY, WalksInGroup);
        
        if ((PWALK)pWalk == Entry->Walk) {
            return TRUE;
        }
        
        List = List->Flink;
    }
    return FALSE;
}



PBREAKPOINT
FindBpForWalk(
    PVOID pWalk
    )
/*++

Routine Description:

    Walk through all the BPs in the system and find one with pWalk in it's
    group list (hWalk).  Note: if two BPs both had the same walk in their
    group list, this function would fail to work properly.

--*/
{

    PBREAKPOINT pbp;

    EnterCriticalSection (&csThreadProcList);

    pbp = bpList;
    while (pbp) {
        if (pbp->hWalk && IsWalkInGroup (pbp->hWalk, pWalk)) {
            break;
        }
        pbp = pbp->next;
    }

    LeaveCriticalSection (&csThreadProcList);

    return pbp;
}


int
MethodWalk(
    DEBUG_EVENT*    de,
    HTHDX           hthd,
    DWORD           unused,
    PWALK_INFO      WalkInfo
    )
/*++

Routine Description:

    When we enter the walk method, we must check whether any of the Walks
    on this thread have fired.  The first one that we find that fired, we
    will send to the EM and any other's that would've fired are lost.

Arguments:

    de      -   Supplies debug event

    hthd    -   Supplies thread

    unused  -



Return Value:

    Nothing meaningful.


Comments:

    NOTE: the CheckBpt () function is not a very nice function.
    It can Set and Remove BPs EVEN WHEN IT RETURNS FALSE, which
    means it can wreak havoc with our Walk list.  Be extra careful
    if we call CheckBpt ().
    
--*/
{
    HPRCX       hprc = hthd->hprc;
    WALK*       Walk;
    BOOL        fDoContinue = FALSE;
    BOOL        fDeactivateWalks = FALSE;
    LIST_ENTRY* List;

    Unreferenced (unused);
    Unreferenced (WalkInfo);

    assert (WalkInfo);

    //
    // However we got here, we do not need this BP anymore.
    //

    if (WalkInfo->SafetyBP) {

        //
        // If the expected event for the safety bp is not on the expected
        // events list then the safety bp was removed as part of that event.
        //

        EXPECTED_EVENT* ee;

        ee = PeeIsEventExpected (hthd,
                                 BREAKPOINT_DEBUG_EVENT,
                                 (DWORD) WalkInfo->SafetyBP,
                                 TRUE);
        
        if (ee) {
            MHFree (ee);
            RemoveBP (WalkInfo->SafetyBP);
        }
        
        WalkInfo->SafetyBP = NULL;
    }

    //
    // Iterate through all walks on this thread.  In each iteration we must
    // setup for the next walk and check if we have an event to fire.
    //

    for (List = hthd->WalkList.Flink; List != &hthd->WalkList;
         List = List->Flink) {
        
        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);

            
        if (Walk->Active && (Walk->GlobalCount || Walk->LocalCount)) {

            BOOL    fPotentialHit = FALSE;
            
            if (Walk->BpType == bptpRange) {

                if (InRange (Walk->u.Range.AddrStart,
                             Walk->u.Range.AddrEnd,
                             PC (hthd))) {

                    //
                    // We are currently in Range
                    //
                                        
                    Walk->u.Range.fInRange = TRUE;
                    Walk->u.Range.SavedSP = STACK_POINTER (hthd);

                    fPotentialHit = FALSE;

                } else {

                    //
                    // We are not currently in Range
                    //

                    if (Walk->u.Range.fInRange &&
                        STACK_POINTER (hthd) >= Walk->u.Range.SavedSP) {

                        //
                        // If we were in Range on the last step, we
                        // have a potential hit.
                        //

                        fPotentialHit = TRUE;
                    }

                    Walk->u.Range.fInRange = FALSE;

                    //
                    // NB: should we have an "emergency" check; i.e.:
                    // if (STACK_POINTER (hthd) > Walk->u.Range.SavedSP) {
                    //    fPotentialHit = TRUE;
                    //
                    //  for the case that we somehow miss the transition and
                    //  still have Walk->fInRange == FALSE ? ? ?
                    //
                    //  Are there any potential problems with this?
                    //
                }

            } else {
                fPotentialHit = TRUE;
            }
            

            if (fPotentialHit && CheckWalk (Walk) &&
                CheckBpt (hthd, FindBpForWalk (Walk))) {

                //
                // Tell the EM it stopped.
                //

                fDeactivateWalks = TRUE;
                Walk->Active = FALSE;
                ConsumeAllThreadEvents (hthd, FALSE);

                SetExceptionAddress (&falseBPEvent, PC (hthd));

                NotifyEM (&falseBPEvent,
                          hthd,
                          0,
                          (LPVOID)FindBpForWalk (Walk));
                break;
            }

        }
    }

    //
    // Some of the walks could have been marked for deletion while looking
    // at them.  Delete them now.
    //

    List = hthd->WalkList.Flink;

    while (List != &hthd->WalkList) {
    
        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
        List = List->Flink;

        if (fDeactivateWalks) {
            Walk->Active = FALSE;
        }

        if (Walk->Active) {
            fDoContinue = TRUE;
        }
        
        if (Walk->GlobalCount == 0 && Walk->LocalCount == 0) {

            //
            // If this walk was marked for deletion, delete it now.
            //
        
            DeallocateWalk (Walk);

        } else if (Walk->Active) {

            //
            // If this walk is still active, setup for continuing the walk.
            //
            
            SetupWalk (Walk, TRUE);

        }

    }
    
    if (fDoContinue) {
        SetDebugEventThreadState (hthd->hprc, ts_running);
        AddQueue (QT_CONTINUE_DEBUG_EVENT,
                  hprc->pid,
                  hthd->tid,
                  DBG_CONTINUE,
                  0);
    }

    return TRUE;
}



BREAKPOINT*
SetupSafetyBp(
    HTHDX       hthd,
    METHOD*     Method
    )
{
    ADDR        currAddr;
    int         lpf;
    BREAKPOINT* SafetyBp = NULL;


    AddrFromHthdx (&currAddr, hthd);
    IsCall (hthd, &currAddr, &lpf, FALSE);

    if (lpf == INSTR_IS_CALL) {
    
        //
        // Set a safety breakpoint on the return site to prevent
        // running free over system calls and other mysterious
        // cases.
        //

        //NB: this code needs to be moved out of the loop.
        //It deals with all walks on a thread, not just one.
        
        SafetyBp = SetBP (hthd->hprc,
                          hthd,
                          bptpExec,
                          bpnsStop,
                          &currAddr,
                          (HPID)INVALID);

        //
        // Register an expected event in case this mystery BP is
        // hit.
        //

        RegisterExpectedEvent (hthd->hprc,
                               hthd,
                               BREAKPOINT_DEBUG_EVENT,
                               (DWORD) SafetyBp,
                               Method,
                               NO_ACTION,
                               FALSE,
                               NULL);
    }

    return SafetyBp;
}



VOID
DuplicateWalkBindings(
    PWALK OldWalk,
    PWALK NewWalk
    )
/*++

Routine Description:

    Copy the breakpoint bindings for a walk into another walk.
    This is used for duplicationg global watchpoints.

Arguments:

    OldWalk - Supplies a WALK which is bound to one or more breakpoints.

    NewWalk - Supplies a WALK which is to be bound to the same breakpoints
            as OldWalk.

Return Value:

    None

--*/
{
    PLIST_ENTRY OldList;
    PWALK_GROUP_ENTRY OldEntry;
    PWALK_GROUP_ENTRY NewEntry;

    //
    // Run down the list of breakpoints that OldWalk is bound to,
    // and create equivalent bindings for NewWalk.
    //

    OldList = OldWalk->GroupWalkList.Flink;

    while (OldList != &OldWalk->GroupWalkList) {

        //
        // Find each breakpoint
        //

        OldEntry = CONTAINING_RECORD(OldList, WALK_GROUP_ENTRY, GroupsUsingWalk);

        NewEntry = MHAlloc(sizeof(WALK_GROUP_ENTRY));

        NewEntry->Walk = NewWalk;

        //
        // add this to the Walk's list of BP bindings:
        //

        InsertTailList (&NewWalk->GroupWalkList, &NewEntry->GroupsUsingWalk);

        //
        // And add it to the BP's list of walks:
        //

        InsertTailList(&OldEntry->WalksInGroup, &NewEntry->WalksInGroup);
        OldList = OldList->Flink;

    }
}


VOID
RemoveWalkBindings(
    PWALK Walk
    )
/*++

Routine Description:

    Delete all of the bindings from a WALK to breakpoints (Group lists).
    The GROUP_LIST_ENTRY binding nodes will be freed.

Arguments:

    Walk - Supplies the WALK which is to be unbound.

Return Value:

    None

--*/
{
    //
    // remove all GROUP_LIST_ENTRY bindings for a walk
    //

    PLIST_ENTRY List;
    PLIST_ENTRY PossibleGroupListHead;
    PWALK_GROUP_ENTRY Entry;

    List = Walk->GroupWalkList.Flink;

    while (List != &Walk->GroupWalkList) {

        Entry = CONTAINING_RECORD(List, WALK_GROUP_ENTRY, GroupsUsingWalk);
        List = List->Flink;

        // clean this entry out of the lists...
        PossibleGroupListHead = Entry->WalksInGroup.Flink;
        RemoveEntryList(&Entry->WalksInGroup);
        if (IsListEmpty(PossibleGroupListHead)) {
            MHFree(PossibleGroupListHead);
        }

        RemoveEntryList(&Entry->GroupsUsingWalk);

        MHFree(Entry);
    }
}


VOID
AddWalkToGroupList(
    PLIST_ENTRY GroupList,
    PWALK Walk
    )
/*++

Routine Description:

    Bind a WALK to a breakpoint's walk group list.

Arguments:

    GroupList - Supplies the list header for a breakpoint's group list

    Walk - Supplies a WALK structure which is to be added to the group list.

Return Value:

    None

--*/
{
    PWALK_GROUP_ENTRY Entry;

    Entry = MHAlloc(sizeof(WALK_GROUP_ENTRY));

    Entry->Walk = Walk;
    InsertTailList (GroupList, &Entry->WalksInGroup);
    InsertTailList (&Walk->GroupWalkList, &Entry->GroupsUsingWalk);
}



VOID
ClearProcessWalkFlags(
    HPRCX   hprc
    )
{
    HTHDX   hthd;

    for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
        ClearThreadWalkFlags (hthd);
    }
}

    
VOID
ClearThreadWalkFlags(
    HTHDX   hthd
    )
{
    PWALK       walk;
    PLIST_ENTRY list;
    

    EnterCriticalSection (&csWalk);
    
    for (list = hthd->WalkList.Flink;
         list != &hthd->WalkList;
         list = list->Flink) {

        walk = CONTAINING_RECORD (list, WALK, ThreadWalkEntry);

        walk->Active = FALSE;
    }

    LeaveCriticalSection (&csWalk);
}

//
//  Virtualized debug register Functions.
//


BOOL
DrDeallocateDebugRegister(
    HTHDX   hthd,
    int     Register
    )
{
#ifndef HAS_DEBUG_REGS
    return TRUE;
#else

    PDEBUGREG Dr = &hthd->DebugRegs [Register];

    if (--Dr->ReferenceCount <= 0) {
        Dr->InUse = FALSE;
        ClearDebugRegister (hthd, Register);
    }

    return TRUE;
#endif
}



BOOL
DrIsDebugRegisterInUse(
    HTHDX   hthd,
    int     Register
    )
{
#ifndef HAS_DEBUG_REGS
    assert (FALSE);
    return FALSE;
#else
    return hthd->DebugRegs [Register].InUse;
#endif
}

BOOL
DrSetupDebugRegister(
    HTHDX   hthd,
    int     Register
    )
{
#ifndef HAS_DEBUG_REGS
    return TRUE;
#else

    DEBUGREG*   Dr;

    Dr = &hthd->DebugRegs [Register];

    return SetupDebugRegister (hthd,
                               Register,
                               Dr->DataSize,
                               Dr->DataAddr,
                               Dr->BpType
                               );
#endif
}

VOID
DrClearDebugRegister(
    HTHDX   hthd,
    int     Register
    )
{
#ifdef HAS_DEBUG_REGS
    ClearDebugRegister (hthd, Register);
#endif
}
    
                        
    
    
int
DrAllocateDebugRegister(
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    DWORD   BpType
    )
{
#ifndef HAS_DEBUG_REGS
    return -1;
#else

    int     Register = -1;
    int     i;

    for (i = 0; i < NDEBUG_REG_DATA_SIZES; i++) {
        if (Size == DebugRegDataSizes [i]) {
            break;
        }
    }

    if (i == NDEBUG_REG_DATA_SIZES) {

        // Not a supported size.
        
        return -1;
    }

    //
    // Look for an exact match preferablly, or an open register.
    
    
    for (i = 0; i < NUMBER_OF_DEBUG_REGISTERS; i++) {

        if (hthd->DebugRegs [i].ReferenceCount == 0) {
                Register = i;
            } else if ( (hthd->DebugRegs [i].DataAddr == Addr) &&
                        (hthd->DebugRegs [i].DataSize >= Size) &&
                        (hthd->DebugRegs [i].BpType == BpType) ) {
                Register = i;
                break;
            }
    }

    if (Register >= 0) {

        if (hthd->DebugRegs [Register].ReferenceCount == 0) {

            hthd->DebugRegs [Register].DataSize = Size;
            hthd->DebugRegs [Register].DataAddr = Addr;
            hthd->DebugRegs [Register].BpType = BpType;
            hthd->DebugRegs [Register].InUse = FALSE;
        }
        hthd->DebugRegs [Register].ReferenceCount++;
    }

    return Register;

#endif
}


ULONG
DrGetDebugRegisterDataSize(
    HTHDX   hthd,
    int     Register
    )
{
#ifdef HAS_DEBUG_REGS
    return hthd->DebugRegs [Register].DataSize;
#else
    return 0;
#endif
}

VOID
DrSetDebugRegisterInUse(
    HTHDX   hthd,
    int     Register,
    BOOL    InUse
    )
{
#ifdef HAS_DEBUG_REGS

    hthd->DebugRegs [Register].InUse = InUse;

#endif
}




//
// Debug Dumping functions
//

// *12345678  0f55abff  DataC  11   0   54564FF          1   -1       100 
//  00102020  0bff8888  Range   0   1   5555555      55555    0         0


#if DBG

#define XX(_x) case bptp##_x: return #_x


char*
BpTypeToStr(
    BPTP    BpType
    )
{
    switch (BpType)
    {
        XX (Exec);
        XX (DataC);
        XX (DataW);
        XX (DataR);
        XX (DataExec);
        XX (RegC);
        XX (RegW);
        XX (RegR);
        XX (Message);
        XX (MClass);
        XX (Int);
        XX (Range);
    }

    return "ERR";
}

#undef XX

VOID
DumpWalkHeader(
    )
{
    DebugPrint ("\n  Addr      hthd      Type   GC  LC  Strt/Adr"
                "  Stop/Cnt  Reg  Contents\n");
}



VOID
DumpWalk(
    WALK*   Walk
    )
{
    DWORD   Contents = 0;
    BPTP    BpType = Walk->BpType;
    int     Prec = 0;
    
    
    if (BpType == bptpDataC && Walk->u.Data.DataContents) {
        Prec = 1;
        memcpy (&Contents,
                Walk->u.Data.DataContents,
                min (4, Walk->u.Data.DataSize)
                );
    }

    DebugPrint (" %c%08x  %08x  %5.5s  %2d  %2d  %8x  %8x  %3d %8.*d\n",
                Walk->Active ? '*' : ' ',
                Walk,
                Walk->hthd,
                BpTypeToStr (BpType),
                Walk->GlobalCount,
                Walk->LocalCount,
                IsDataBp (BpType) ? Walk->u.Data.DataAddr : Walk->u.Range.AddrStart,
                IsDataBp (BpType) ? Walk->u.Data.DataSize : Walk->u.Range.AddrEnd,
                IsDataBp (BpType) ? Walk->Register : 0,
                Prec,
                IsDataBp (BpType) ? Contents : 0
                );

}
        

VOID
DumpWalks(
    )
{
    PLIST_ENTRY List;
    PWALK       Walk;

    DumpWalkHeader ();

    List = AllWalkList.Flink;
    
    while (List != &AllWalkList) {
        Walk = CONTAINING_RECORD (List, WALK, AllWalkEntry);
        DumpWalk (Walk);
        List = List->Flink;
    }

}

VOID
DumpThreadWalks(
    HTHDX   hthd
    )
{
    PLIST_ENTRY List;
    PWALK       Walk;

    if (hthd == NULL) {
        DebugPrint ("<Invalid hthd == NULL>\n");
        return;
    }
    
    DumpWalkHeader ();
    
    List = hthd->WalkList.Flink;

    while (List != &hthd->WalkList) {
        Walk = CONTAINING_RECORD (List, WALK, ThreadWalkEntry);
        DumpWalk (Walk);
        List = List->Flink;
    }
}

VOID
DumpGroupWalks(
    HANDLE  hWalk
    )
{
    PLIST_ENTRY         GroupListHead = (PLIST_ENTRY) hWalk;
    PLIST_ENTRY         List;
    PWALK_GROUP_ENTRY   Entry;

    if (hWalk == NULL) {
        DebugPrint ("<Invalid hWalk == NULL>\n");
        return;
    }
    
    DumpWalkHeader ();
    
    List = GroupListHead->Flink;

    while (List != GroupListHead) {
        Entry = CONTAINING_RECORD (List, WALK_GROUP_ENTRY, WalksInGroup);
        DumpWalk (Entry->Walk);
        List = List->Flink;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains a set of general utility routines for the
    Debug Monitor module

Author:

    Jim Schaad (jimsch) 9-12-92

Environment:

    Win32 user mode

--*/

#include "precomp.h"
#pragma hdrstop



extern EXPECTED_EVENT   masterEE, *eeList;

extern HTHDX        thdList;
extern HPRCX        prcList;
extern CRITICAL_SECTION csThreadProcList;
extern char  abEMReplyBuf[];      // Buffer for EM to reply to us in


static  HPRCX   HprcRead;
static  HANDLE  HFileRead = 0;          // Read File handle
static  LPB     LpbMemory = 0;          // Read File Address
static  ULONG   CbOffset = 0;           // Offset of read address





BOOL
AddrWriteMemory(
    HPRCX       hprc,
    HTHDX       hthd,
    LPADDR      paddr,
    LPVOID      lpv,
    DWORD       cb,
    LPDWORD     pcbWritten
    )
/*++

Routine Description:

    This function is used to do a verified write to memory.  Most of the
    time it will just do a simple call to WriteMemory but some times
    it will do validations of writes.

Arguments:

    hprc - Supplies the handle to the process

    paddr  - Supplies the address to be written at

    lpv    - Supplies a pointer to the bytes to be written

    cb     - Supplies the count of bytes to be written

    pcbWritten - Returns the number of bytes actually written

Return Value:

    TRUE if successful and FALSE otherwise

--*/

{
    BOOL        fRet;
    ADDR        addr;

    /*
     * Can't resolve linker indices from here.
     */

    assert(!(ADDR_IS_LI(*paddr)));
    if (ADDR_IS_LI(*paddr)) {
        return FALSE;
    }

    /*
     * Make a local copy to mess with
     */

    addr = *paddr;
    if (!ADDR_IS_FLAT(addr)) {
        fRet = TranslateAddress(hprc, hthd, &addr, TRUE);
        assert(fRet);
        if (!fRet) {
            return fRet;
        }
    }

    return DbgWriteMemory(hprc, (LPVOID) GetAddrOff(addr),
                              lpv, cb, pcbWritten);

}                               /* AddrWriteMemory() */


BOOL
AddrReadMemory(
    HPRCX       hprc,
    HTHDX       hthd,
    LPADDR      paddr,
    LPVOID      lpv,
    DWORD       cb,
    LPDWORD     lpRead
    )
/*++

Routine Description:

    Read data from a process, using a full ADDR packet.

Arguments:

    hprc - Supplies the process structure

    hthd - Supplies the thread structure.  This must be valid if the
            address is not flat; otherwise the thread is not used.

    paddr  - Supplies the address to read from

    lpv    - Supplies a pointer to the local buffer

    cb     - supplies the count of bytes to read

    lpRead - Returns the number of bytes actually read

Return Value:

    TRUE if successful and FALSE otherwise

--*/

{
    BOOL        fRet;
    ADDR        addr;
#ifndef KERNEL
    PBREAKPOINT bp;
    DWORD       offset;
    BP_UNIT     instr;
#endif

    /*
     * We can't resolve linker indices from here.
     */

    assert(!(ADDR_IS_LI(*paddr)));
    if (ADDR_IS_LI(*paddr)) {
        return FALSE;
    }

    /*
     * Make a local copy to mess with
     */

    addr = *paddr;
    if (!ADDR_IS_FLAT(addr)) {
        fRet = TranslateAddress(hprc, hthd, &addr, TRUE);
        assert(fRet);
        if (!fRet) {
            return fRet;
        }
    }

    if (!DbgReadMemory(hprc, (LPVOID) GetAddrOff(addr), lpv, cb, lpRead)) {
        return FALSE;
    }

#if 0
#ifndef KERNEL
    /* The memory has been read into the buffer now sanitize it : */
    /* (go through the entire list of breakpoints and see if any  */
    /* are in the range. If a breakpoint is in the range then an  */
    /* offset relative to the start address and the original inst */
    /* ruction is returned and put into the return buffer)        */

    for (bp=bpList->next; bp; bp=bp->next) {
        if (BPInRange(hprc, hthd, bp, &addr, *lpRead, &offset, &instr)) {
            if (offset < 0) {
                memcpy(lpv, ((char *) &instr) - offset,
                       sizeof(BP_UNIT) + offset);
            } else if (offset + sizeof(BP_UNIT) > *lpRead) {
                memcpy(((char *)lpv)+offset, &instr, *lpRead - offset);
            } else {
                *((BP_UNIT UNALIGNED *)((char *)lpv+offset)) = instr;
            }
        }
    }
#endif  // !KERNEL
#endif

    return TRUE;
}                               /* AddrReadMemory() */


#if 0
BOOL
SanitizedMemoryRead(
    HPRCX      hprc,
    HTHDX      hthd,
    LPADDR     paddr,
    LPVOID     lpb,
    DWORD      cb,
    LPDWORD    lpcb
    )

/*++

Routine Description:

    This routine is provided to do the actual read of memory.  This allows
    multiple routines in the DM to do the read through a single common
    interface.  This routine will correct the read memory for any breakpoints
    currently set in memory.

Arguments:

    hprc        - Supplies the process handle for the read

    hthd        - Supplies the thread handle for the read

    paddr       - Supplies the address to read memory from

    lpb         - Supplies the buffer to do the read into

    cb          - Supplies the number of bytes to be read

    lpcb        - Returns the number of bytes actually read

Return Value:

    TRUE on success and FALSE on failure

--*/

{
    DWORD       offset;
    BP_UNIT     instr;
    BREAKPOINT  *bp;

    if (!AddrReadMemory(hprc, hthd, paddr, lpb, cb, lpcb)) {
        return FALSE;
    }

#ifndef KERNEL
    /* The memory has been read into the buffer now sanitize it : */
    /* (go through the entire list of breakpoints and see if any  */
    /* are in the range. If a breakpoint is in the range then an  */
    /* offset relative to the start address and the original inst */
    /* ruction is returned and put into the return buffer)        */

    for (bp=bpList->next; bp; bp=bp->next) {
        if (BPInRange(hprc, hthd, bp, paddr, *lpcb, &offset, &instr)) {
            if (offset < 0) {
                memcpy(lpb, ((char *) &instr) - offset,
                       sizeof(BP_UNIT) + offset);
            } else if (offset + sizeof(BP_UNIT) > *lpcb) {
                memcpy(((char *)lpb)+offset, &instr, *lpcb - offset);
            } else {
                *((BP_UNIT UNALIGNED *)((char *)lpb+offset)) = instr;
            }
        }
    }
#endif  // !KERNEL

    return TRUE;
}

#endif

#if 0

ULONG
SetReadPointer(
    ULONG    cbOffset,
    int      iFrom
    )

/*++

Routine Description:

    This routine is used to deal with changing the location of where
    the next read should occur.  This will take effect on the current
    file pointer or debuggee memory pointer address.

Arguments:

    cbOffset    - Supplies the offset to set the file pointer at

    iFrom       - Supplies the type of set to be preformed.

Return Value:

    The new file offset

--*/

{
    if (LpbMemory == NULL) {
        CbOffset = SetFilePointer(HFileRead, cbOffset, NULL, iFrom);
    } else {
        switch( iFrom ) {
        case FILE_BEGIN:
            CbOffset = cbOffset;
            break;

        case FILE_CURRENT:
            CbOffset += cbOffset;
            break;

        default:
            assert(FALSE);
            break;
        }
    }

    return CbOffset;
}                               /* SetReadPointer() */


VOID
SetPointerToFile(
    HANDLE   hFile
    )

/*++

Routine Description:

    This routine is called to specify which file handle should be used for
    doing reads from

Arguments:

    hFile - Supplies the file handle to do future reads from

Return Value:

    None.

--*/

{
    HFileRead = hFile;
    HprcRead = NULL;
    LpbMemory = NULL;

    return;
}                               /* SetPointerToFile() */



VOID
SetPointerToMemory(
    HPRCX       hprc,
    LPVOID      lpv
    )

/*++

Routine Description:

    This routine is called to specify where in debuggee memory reads should
    be done from.

Arguments:

    hProc - Supplies the handle to the process to read memory from

    lpv   - Supplies the base address of the dll to read memory at.

Return Value:

    None.

--*/

{
    HprcRead = hprc;
    LpbMemory = lpv;
    HFileRead = NULL;

    return;
}                               /* SetPointerToMemory() */


BOOL
DoRead(
    LPVOID           lpv,
    DWORD            cb
    )

/*++

Routine Description:

    This routine is used to preform the actual read operation from either
    a file handle or from the dlls memory.

Arguments:

    lpv - Supplies the pointer to read memory into

    cb  - Supplies the count of bytes to be read

Return Value:

    TRUE If read was fully successful and FALSE otherwise

--*/

{
    DWORD       cbRead;

    if (LpbMemory) {
        if ( !DbgReadMemory( HprcRead, LpbMemory+CbOffset, lpv, cb, &cbRead ) ||
                (cb != cbRead) ) {
            return FALSE;
        }
        CbOffset += cb;
    } else if ((ReadFile(HFileRead, lpv, cb, &cbRead, NULL) == 0) ||
            (cb != cbRead)) {
        return FALSE;
    }
    return TRUE;
}                               /* DoRead() */
#endif // 0


BOOL
AreAddrsEqual(
    HPRCX     hprc,
    HTHDX     hthd,
    LPADDR    paddr1,
    LPADDR    paddr2
    )

/*++

Routine Description:

    This function is used to compare to addresses for equality

Arguments:

    hprc    - Supplies process for address context

    hthd    - Supplies thread for address context

    paddr1  - Supplies a pointer to an ADDR structure

    paddr2  - Supplies a pointer to an ADDR structure

Return Value:

    TRUE if the addresses are equivalent

--*/

{
    ADDR        addr1;
    ADDR        addr2;

    /*
     *  Step 1.  Addresses are equal if
     *          - Both addresses are flat
     *          - The two offsets are the same
     */

    if ((ADDR_IS_FLAT(*paddr1) == TRUE) &&
        (ADDR_IS_FLAT(*paddr1) == ADDR_IS_FLAT(*paddr2)) &&
        (paddr1->addr.off == paddr2->addr.off)) {
        return TRUE;
    }

    /*
     * Step 2.  Address are equal if the linear address are the same
     */

    addr1 = *paddr1;
    addr2 = *paddr2;

    if (addr1.addr.off == addr2.addr.off) {
        return TRUE;
    }

    return FALSE;
}                               /* AreAddrsEqual() */




HTHDX
HTHDXFromPIDTID(
    PID pid,
    TID tid
    )
{
    HTHDX hthd;

    EnterCriticalSection(&csThreadProcList);
    for ( hthd = thdList->next; hthd; hthd = hthd->next ) {
        if (hthd->tid == tid && hthd->hprc->pid == pid ) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);
    return hthd;
}



HTHDX
HTHDXFromHPIDHTID(
    HPID hpid,
    HTID htid
    )
{
    HTHDX hthd;

    EnterCriticalSection(&csThreadProcList);
    for(hthd = thdList->next; hthd; hthd = hthd->next) {
        if (hthd->htid == htid && hthd->hprc->hpid == hpid ) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);
    return hthd;
}




HPRCX
HPRCFromPID(
    PID pid
    )
{
    HPRCX hprc;

    EnterCriticalSection(&csThreadProcList);
    for( hprc = prcList->next; hprc; hprc = hprc->next) {
        if (hprc->pid == pid) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);
    return hprc;
}



HPRCX
HPRCFromHPID(
    HPID hpid
    )
{
    HPRCX hprc;

    EnterCriticalSection(&csThreadProcList);
    for ( hprc = prcList->next; hprc; hprc = hprc->next ) {
        if (hprc->hpid == hpid) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);
    return hprc;
}



HPRCX
HPRCFromRwhand(
    HANDLE rwHand
    )
{
    HPRCX hprc;

    EnterCriticalSection(&csThreadProcList);
    for ( hprc=prcList->next; hprc; hprc=hprc->next ) {
        if (hprc->rwHand==rwHand) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);
    return hprc;
}


void
FreeHthdx(
    HTHDX hthd
    )
{
    HTHDX *             ppht;
    BREAKPOINT *        pbp;
    BREAKPOINT *        pbpT;

    EnterCriticalSection(&csThreadProcList);

    /*
     *  Free all breakpoints unique to thread
     */

    ClearBPFlag(hthd);
    for (pbp = BPNextHthdPbp(hthd, NULL); pbp; pbp = pbpT) {
        pbpT = BPNextHthdPbp(hthd, pbp);
        RemoveBP(pbp);
    }


    for (ppht = &(hthd->hprc->hthdChild); *ppht; ppht = & ( (*ppht)->nextSibling ) ) {
        if (*ppht == hthd) {
            *ppht = (*ppht)->nextSibling;
            break;
        }
    }

    for (ppht = &(thdList->next); *ppht; ppht = & ( (*ppht)->next ) ) {
        if (*ppht == hthd) {
            *ppht = (*ppht)->next;
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);

    MHFree(hthd);
}


VOID
ClearContextPointers(
    PKNONVOLATILE_CONTEXT_POINTERS ctxptrs
    )
/*++

  Routine -  Clear Context Pointers

  Purpose - clears the context pointer structure.

  Argument - lpvoid - pointer to context pointers structure;
             void on on architectures that don't have such.

--*/

{
    memset(ctxptrs, 0, sizeof (KNONVOLATILE_CONTEXT_POINTERS));
}

#if 0
/*** FGETEXPORT
 *
 * PURPOSE:
 *        Given the base address of a DLL in the debuggee's memory space, find
 *        the value (if any) of a specified export in that DLL.
 *
 * INPUT:
 *        pdi        DLLLOAD_ITEM structure for module
 *        hfile      Handle to disk file of DLL
 *        szExport   Name of symbol to search for in its export table
 *
 * OUPTUT:
 *        *plpvValue Address of the symbol, from the export table.
 *                        plpvValue may be NULL if caller doesn't care.
 *        return code        TRUE if symbol was found, FALSE if not
 */


BOOL
FGetExport(
    PDLLLOAD_ITEM pdi,
    HFILE       hfile,
    LPCTSTR     szExport,
    LPVOID*     plpvValue
    )
{
    IMAGE_DOS_HEADER        doshdr;
    IMAGE_NT_HEADERS        nthdr;
    IMAGE_EXPORT_DIRECTORY  exphdr;
    LONG                    inameFirst, inameLast, iname;    // must be signed
    UOFFSET                 uoffExpTable;
    UOFFSET                 uoffNameTable;
    UOFFSET                 uoffFuncTable;
    UOFFSET                 uoffOrdinalTable;
    UOFFSET                 uoffString;
    INT                     iRet;
    size_t                  cbValueRead;
    LPTSTR                  szValueRead;
    UOFFSET                 uoffBasePE;

    /*
    ** Check for both initial MZ (oldheader) or initial PE header.
    */

    VERIFY(CbReadDllHdr(hfile, 0, &doshdr, sizeof(doshdr)) == sizeof(doshdr));

    if ( doshdr.e_magic != IMAGE_DOS_SIGNATURE ) {
        return FALSE;
    }

    uoffBasePE = ( doshdr.e_lfanew );

    VERIFY(CbReadDllHdr(hfile, uoffBasePE, &nthdr, sizeof(nthdr)) ==
        sizeof(nthdr));

    uoffExpTable = nthdr.OptionalHeader.DataDirectory[
        IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

    if (uoffExpTable == 0) {
        return FALSE;
    }

    uoffExpTable = FileOffFromVA(pdi, hfile, uoffBasePE, &nthdr, uoffExpTable);

    VERIFY(CbReadDllHdr(hfile, uoffExpTable, &exphdr, sizeof(exphdr)) ==
        sizeof(exphdr));

    if ( exphdr.NumberOfNames == 0L ) {
        return FALSE;
    }

    uoffNameTable = FileOffFromVA(pdi, hfile, uoffBasePE, &nthdr,
        (UOFFSET)exphdr.AddressOfNames);

    cbValueRead = _ftcslen(szExport) + 1;
    szValueRead = MHAlloc( cbValueRead * sizeof(TCHAR));
	iRet = 1;

    // Do a binary search through the export table
    inameFirst = 0;
    inameLast = exphdr.NumberOfNames - 1;
    while (inameFirst <= inameLast) {
        iname = (inameFirst + inameLast) / 2;

        VERIFY(CbReadDllHdr(hfile, uoffNameTable + (iname * sizeof(OFFSET)),
            &uoffString, sizeof(UOFFSET)) == sizeof(UOFFSET));

        uoffString = FileOffFromVA(pdi, hfile, uoffBasePE, &nthdr,
            uoffString);

        VERIFY(CbReadDllHdr(hfile, uoffString, szValueRead, cbValueRead) ==
            cbValueRead);

        iRet = _ftcsncmp( szValueRead, szExport, cbValueRead );

        if (iRet < 0) {
            inameFirst = iname + 1;
        } else if (iRet > 0) {
            inameLast = iname - 1;
        } else /* iRet == 0: match */ {
            /* if caller wants its value, get value */
            if (plpvValue) {
                USHORT            usOrdinal;

                /* read symbol value from export table */
                uoffOrdinalTable = FileOffFromVA(pdi, hfile, uoffBasePE,
                    &nthdr, (UOFFSET)exphdr.AddressOfNameOrdinals);
                VERIFY(CbReadDllHdr(hfile,
                    uoffOrdinalTable + (iname * sizeof(USHORT)),
                    &usOrdinal, sizeof(usOrdinal)) == sizeof(usOrdinal));

                uoffFuncTable = FileOffFromVA(pdi, hfile, uoffBasePE,
                    &nthdr, (UOFFSET)exphdr.AddressOfFunctions);
                VERIFY(CbReadDllHdr(hfile,
                    uoffFuncTable + (usOrdinal * sizeof(UOFFSET)),
                    plpvValue, sizeof(*plpvValue)) == sizeof(*plpvValue));
                *plpvValue = (LPVOID) ((UOFFSET)*plpvValue + pdi->offBaseOfImage);
            }
            break;
        }
    }
    MHFree( szValueRead );
    return !iRet;

}


UOFFSET
FileOffFromVA(
    PDLLLOAD_ITEM           pdi,
    HFILE                   hfile,
    UOFFSET                 uoffBasePE,
    const IMAGE_NT_HEADERS *pnthdr,
    UOFFSET                 va
    )

/*++

Routine Description:

    Given a virtual address, calculate the file offset at which it
    can be found in an EXE/DLL.

Arguments:

    pdi - Supplies the DLLLOAD_ITEM structure for this exe/dll

    hfile - Supplies a read handle to the exe/dll file

    uoffBasePE - Supplies offset of beginning of PE header in exe/dll

    pnthdr - Supplies ptr to NTHDR for the exe/dll

    va - Supplies virtual address to convert

Return Value:

    the file offset for the given va, 0 for failure

--*/

{
    UOFFSET                 uoffObjs;
    WORD                    iobj, cobj;
    IMAGE_SECTION_HEADER    isecthdr;
    PIMAGE_SECTION_HEADER   psect;
    UOFFSET                 uoffFile = 0;

    uoffObjs = uoffBasePE +
               FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) +
               pnthdr->FileHeader.SizeOfOptionalHeader;

    cobj = pnthdr->FileHeader.NumberOfSections;

    /*
     * If we have not yet read the section headers into the DLLINFO, do
     * so now.
     */
    if (pdi->Sections == NULL) {
        pdi->Sections = MHAlloc(cobj * sizeof(IMAGE_SECTION_HEADER));

        VERIFY(
        CbReadDllHdr(hfile, uoffObjs, pdi->Sections, cobj * sizeof(IMAGE_SECTION_HEADER))
        );
    }

    /*
     * Look for the address.
     */
    for (iobj=0; iobj<cobj; iobj++) {
        DWORD    offset, cbObject;

        offset = pdi->Sections[iobj].VirtualAddress;
        cbObject = pdi->Sections[iobj].Misc.VirtualSize;
        if (cbObject == 0) {
            cbObject = pdi->Sections[iobj].SizeOfRawData;
        }

        if (va >= offset && va < offset + cbObject) {
            // found it
            uoffFile = pdi->Sections[iobj].PointerToRawData + va - offset;
            break;
        }
    }
    assert(uoffFile);    // caller shouldn't have called with a bogus VA
    return uoffFile;
}


DWORD
CbReadDllHdr(
    HFILE hfile,
    UOFFSET uoff,
    LPVOID lpvBuf,
    DWORD cb
    )
{
    VERIFY(_llseek(hfile, uoff, 0) != HFILE_ERROR);
    assert((UINT)cb == cb);    // make sure we don't truncate value
    return _lread(hfile, lpvBuf, (UINT)cb);
}
#endif // 0


XOSD
DMSendRequestReply (
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD cbInput,
    LPVOID lpInput,
    DWORD cbOutput,
    LPVOID lpOutput
    )
/*++

Routine Description:


Arguments:

    dbc - Supplies command to send to EM

    hpid - Supplies process handle

    htis - Supplies thread handle

    cbInput - Supplies size of packet to send

    lpInput - Supplies packet to send

    cbOutput - Supplies size of packet to receive

    lpOutput - Returns data from reply

Return Value:

    xosdNone or xosd error value

--*/
{
    XOSD xosd = xosdNone;

    if ( cbInput == 0 ) {
        RTP rtp;

        rtp.dbc  = dbc;
        rtp.hpid = hpid;
        rtp.htid = htid;
        rtp.cb   = 0;
        xosd = DmTlFunc
            ( tlfRequest, hpid, FIELD_OFFSET( RTP, rgbVar ), (LONG) (LPV) &rtp );
    }
    else {
        LPRTP lprtp = MHAlloc ( FIELD_OFFSET( RTP, rgbVar ) + cbInput );

        lprtp->dbc  = dbc;
        lprtp->hpid = hpid;
        lprtp->htid = htid;
        lprtp->cb   = cbInput;

        _fmemcpy ( lprtp->rgbVar, lpInput, cbInput );

        xosd = DmTlFunc
            ( tlfRequest, hpid, FIELD_OFFSET( RTP, rgbVar ) + cbInput, (LONG) lprtp );

        MHFree ( lprtp );

    }

    if (xosd == xosdNone && cbOutput != 0) {
        _fmemcpy(lpOutput, abEMReplyBuf, cbOutput);
    }

    return xosd;

} /* DMSendRequestReply */



XOSD
DMSendDebugPacket (
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD cbInput,
    LPVOID lpInput
    )
/*++

Routine Description:


Arguments:

    dbc - Supplies command to send to EM

    hpid - Supplies process handle

    htid - Supplies thread handle

    cbInput - Supplies size of packet to send

    lpInput - Supplies packet to send

Return Value:

    xosdNone or xosd error value

--*/
{
    XOSD xosd = xosdNone;

    if ( cbInput == 0 ) {
        RTP rtp;

        rtp.dbc  = dbc;
        rtp.hpid = hpid;
        rtp.htid = htid;
        rtp.cb   = 0;
        xosd = DmTlFunc
            ( tlfDebugPacket, hpid, FIELD_OFFSET( RTP, rgbVar ), (LONG) (LPV) &rtp );
    }
    else {
        LPRTP lprtp = MHAlloc ( FIELD_OFFSET( RTP, rgbVar ) + cbInput );

        lprtp->dbc  = dbc;
        lprtp->hpid = hpid;
        lprtp->htid = htid;
        lprtp->cb   = cbInput;

        _fmemcpy ( lprtp->rgbVar, lpInput, cbInput );

        xosd = DmTlFunc
            ( tlfDebugPacket, hpid, FIELD_OFFSET( RTP, rgbVar ) + cbInput, (LONG) lprtp );

        MHFree ( lprtp );

    }

    return xosd;

} /* DMSendRequestReply */



DWORD
GetEndOfRange (
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr
    )
/*++

Routine Description:

    Given an address, gets the end of the range for that address.

Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

    Addr    -   Supplies the address

Return Value:

    DWORD   -   End of range

--*/

{
    ADDR AddrPC;

    AddrFromHthdx(&AddrPC, hthd);
    SetAddrOff( &AddrPC, Addr );

    DMSendRequestReply(
        dbcLastAddr,
        hprc->hpid,
        hthd->htid,
        sizeof(ADDR),
        &AddrPC,
        sizeof(DWORD),
        &Addr
        );

    Addr =  (*(DWORD *)abEMReplyBuf);

    // NOTENOTE : jimsch --- Is this correct?
    return (DWORD) Addr;
}




DWORD
GetCanStep (
    HPID    hpid,
    HTID    htid,
    LPADDR  Addr,
    LPCANSTEP CanStep
    )
/*++

Routine Description:


Arguments:

    hprc    -   Supplies process

    hthd    -   Supplies thread

    Addr    -   Supplies Address

Return Value:

    CANSTEP_YES or CANSTEP_NO (or CANSTEP_THUNK?)

--*/

{
    return DMSendRequestReply(
        dbcCanStep,
        hpid,
        htid,
        sizeof(ADDR),
        Addr,
        sizeof(CANSTEP),
        CanStep
        );
}


BOOL
CheckBpt(
    HTHDX       hthd,
    PBREAKPOINT pbp
    )
{
    DEBUG_EVENT de;

    if (pbp->bpNotify == bpnsStop) {
        return TRUE;
    } else if (pbp->bpNotify == bpnsCheck) {
        de.dwDebugEventCode = CHECK_BREAKPOINT_DEBUG_EVENT;
        de.dwProcessId = hthd->hprc->pid;
        de.dwThreadId  = hthd->tid;
        de.u.Exception.ExceptionRecord.ExceptionCode = EXCEPTION_BREAKPOINT;

        NotifyEM(&de, hthd, 0, pbp);

        return *(DWORD *)abEMReplyBuf;
    }
    return FALSE;
}


LPTSTR
MHStrdup(
    LPCTSTR s
    )
{
    int l = _tcslen(s);
    LPTSTR p = MHAlloc(l + sizeof(TCHAR));
    _tcscpy(p, s);
    return p;
}

/*** ISTHUNK
 *
 * PURPOSE:
 *      Determine if we are in a thunk
 *
 * INPUT:
 *      hthd            - Handle to thread
 *      uoffEIP         - address to check for a thunk
 *      lpf             - Type of thunk
 *      lpuoffThunkDest - Where the thunk is going to
 *
 * OUTPUT:
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 ****************************************************************************/

BOOL
IsThunk (
    HTHDX       hthd,
    UOFFSET     uoffset,
    LPINT       lpfThunkType,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    )
{
    BYTE        rgbBuffer[CB_THUNK_MAX];
    DWORD       dwLength = CB_THUNK_MAX;
    INT         ThunkType = THUNK_NONE;
    UOFFSET     ThunkDest = 0;
    DWORD       ThunkSize = 0;
    BOOL        Is = FALSE;

    // Read until a read succeeds or there's no room left to read
    if (DbgReadMemory ( hthd->hprc, (LPVOID)uoffset, rgbBuffer, dwLength, &dwLength)) {

        // System or ilink thunks
        if (FIsDirectJump( rgbBuffer, dwLength, hthd, uoffset, &ThunkDest, &ThunkSize ) ||
            FIsIndirectJump( rgbBuffer, dwLength, hthd, uoffset, &ThunkDest, &ThunkSize )
        ) {
            Is = TRUE;
            if (IsInSystemDll(ThunkDest))
            	ThunkType = THUNK_SYSTEM;
            else 
            	ThunkType = THUNK_USER;
        } else {

            // Note: it is possible that the offset passed in is NOT the PC
            // for the current thread.  Some of the thunk checks below
            // may require valid registers.  The following thunks require
            // valid registers to determine the destination address for a
            // thunk.  If uoffset is NOT the PC, then do not check for
            // these thunks.  These thunks are actually C++ thunks.


            if ( PC(hthd) == uoffset &&
                ( FIsVCallThunk( rgbBuffer, dwLength, hthd, uoffset, &ThunkDest, &ThunkSize ) ||
                  FIsVTDispAdjustorThunk( rgbBuffer, dwLength, hthd, uoffset, &ThunkDest, &ThunkSize ) ||
                  FIsAdjustorThunk( rgbBuffer, dwLength, hthd, uoffset, &ThunkDest, &ThunkSize ) )
            ) {
                Is = TRUE;
                ThunkType = THUNK_USER;
            }
        }
    }

    if (lpuoffThunkDest) {
        *lpuoffThunkDest = ThunkDest;
    }
    if (lpdwThunkSize) {
        *lpdwThunkSize = ThunkSize;
    }
    if (lpfThunkType) {
        *lpfThunkType = ThunkType;
    }
    return Is;
}



DWORD
InterlockedSetFlag(
	LONG*	lpFlag
	)
/*++

Routine Description:

	This function implements a thread-safe test-and-set primitive.

Return Values:

	FLAG_ALREADY_SET - The flag had already been set.

	FLAG_SET - The flag was successfully set.

--*/
{
	DWORD	status;
	
	if (InterlockedIncrement (lpFlag) > 1) {
		InterlockedDecrement (lpFlag);

		status = FLAG_ALREADY_SET;
	} else {
		status = FLAG_SET;
	}

	return status;
}


DWORD
InterlockedClearFlag(
	LONG*	lpFlag
	)
/*++

Routine Description:

	This function implements a thread-safe test-and-clear primitive.

Return Values:

	FLAG_ALREADY_CLEARED - The flag had already been cleared.

	FLAG_CLEARED - The flag was successfully cleared.

--*/
{
	DWORD	status;
	
	if (InterlockedDecrement (lpFlag) < 0) {
		InterlockedIncrement (lpFlag);

		status = FLAG_ALREADY_CLEARED;
	} else {
		status = FLAG_CLEARED;
	}

	return status;
}



//
// Timer Event Queue package
//

void
_AddWaitingTimerEvent(
	HPRCX			hprc,
	TIMER_EVENT*	event
	)
{
	EnterCriticalSection (&hprc->TimerQueue.cs);

	event->next = hprc->TimerQueue.waitlist;
	hprc->TimerQueue.waitlist = event;

	LeaveCriticalSection (&hprc->TimerQueue.cs);
}
	
void
_AddToTimerEventQueue(
	HPRCX			hprc,
	TIMER_EVENT*	event
	)
/*++

Routine Description:

	Private function that adds an event to the event queue.

--*/
{
	TIMER_EVENT*	prev = NULL;
	TIMER_EVENT*	cur = NULL;

	event->ticks += GetTickCount ();
	EnterCriticalSection (&hprc->TimerQueue.cs);
	
	prev = NULL;
	cur = hprc->TimerQueue.head;

	do {
		if (cur == NULL || cur->ticks >= event->ticks) {
	
			if (prev) {
				prev->next = event;
			} else {
				hprc->TimerQueue.head = event;
			}
			event->next = cur;
			break;
		}

		prev = cur;
		if (cur) {
			cur = cur->next;
		}

	} while (cur);

	LeaveCriticalSection (&hprc->TimerQueue.cs);
}


TIMER_EVENT*
_RemoveFromQueue(
	HPRCX			hprc,
	TIMER_EVENT**	head,
	HANDLE			hEvent
	)
{
	TIMER_EVENT*	prev = NULL;
	TIMER_EVENT*	cur = NULL;

	EnterCriticalSection (&hprc->TimerQueue.cs);
	
	prev = NULL;
	cur = *head;

	while (cur && cur->handle != hEvent) {
		prev = cur;
		cur = cur->next;
	}

	if (cur) {
		if (prev) {
			prev->next = cur->next;
		} else {
			*head = cur->next;
			cur->next = NULL;
		}
	}

	LeaveCriticalSection (&hprc->TimerQueue.cs);

	return cur;
}

BOOL
CreateTimerEventQueue(
	TIMER_EVENT_QUEUE*	queue
	)
{
	queue->head = NULL;
	queue->waitlist = NULL;
	InitializeCriticalSection (&queue->cs);
	queue->count = 1;

	return TRUE;
}

BOOL
DeleteTimerEventQueue(
	TIMER_EVENT_QUEUE*	queue
	)
{
	//
	// Remove remaining items

	DeleteCriticalSection (&queue->cs);
	return TRUE;
}


HANDLE
CreateTimerEvent(
	HPRCX					hprc,
	TIMER_EVENT_CALLBACK	callback,
	LPVOID					param,
	DWORD					ticks,
	BOOL					fQueueEvent
	)
/*++

Routine Description:

	Create a timer event and place it on the queue.

Arguments:

	hprc - The process to create the timer event for.

	callback - The callback to call when the timer event fires.

	param - A param to pass to the callback.

	ticks - How long in milliseconds to wait before firing the timer event.

	fQueueEvent - If true, the event should be placed on the queue,
		otherwise, the even is not placed on the queue and the caller must
		manually place it on the queue.  Note that the number of ticks is
		from the time the event is placed on the queue -- not from when it
		was created.

--*/
{
	HANDLE			h = NULL;
	TIMER_EVENT*	event = NULL;
	

	event = (TIMER_EVENT*) MHAlloc (sizeof (TIMER_EVENT));

	event->callback = callback;
	event->param = param;
	event->ticks = ticks;


	h = (HANDLE) InterlockedIncrement (&hprc->TimerQueue.count);
	event->handle = h;

	if (fQueueEvent) {
		_AddToTimerEventQueue (hprc, event);
	} else {
		_AddWaitingTimerEvent (hprc, event);
	}

	return h;
}

BOOL
EnqueueTimerEvent(
	HPRCX			hprc,
	HANDLE			hEvent
	)
{
	TIMER_EVENT*	event = NULL;
	
	EnterCriticalSection (&hprc->TimerQueue.cs);

	event = _RemoveFromQueue (hprc, &hprc->TimerQueue.waitlist, hEvent);

	if (event) {
		_AddToTimerEventQueue (hprc, event);
	}
	
	LeaveCriticalSection (&hprc->TimerQueue.cs);

	return event ? TRUE : FALSE;
}


BOOL
RemoveTimerEvent(
	HPRCX	hprc,
	HANDLE	hEvent
	)
{
	BOOL			succ = FALSE;
	TIMER_EVENT*	event = NULL;
	
	if (hprc->TimerQueue.head == NULL) {
		return FALSE;
	}

	event = _RemoveFromQueue (hprc, &hprc->TimerQueue.head, hEvent);

	if (!event) {
		event = _RemoveFromQueue (hprc, &hprc->TimerQueue.waitlist, hEvent);
	}

	if (event) {
		MHFree (event);
		succ = TRUE;
	}

	return succ;
	
}

BOOL
FireOutstandingTimerEvents(
	HPRCX	hprc
	)
{
	BOOL			succ = FALSE;
	TIMER_EVENT*	cur = NULL;
	TIMER_EVENT*	nextT = NULL;
	DWORD			ticks;

	
	if (hprc->TimerQueue.head == NULL) {
		return FALSE;
	}

	EnterCriticalSection (&hprc->TimerQueue.cs);

	ticks = GetTickCount ();

	cur = hprc->TimerQueue.head ;
	
	while (cur && cur->ticks <= ticks) {
		hprc->TimerQueue.head = cur->next;
		nextT = cur->next;
		cur->next = NULL;

		cur->callback (hprc, cur->param);
		MHFree (cur);
		cur = nextT;
		succ = TRUE;
	}

	LeaveCriticalSection (&hprc->TimerQueue.cs);

	return succ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\xassert.c ===
/*
 *
 * xassert.c
 *
 * Pop up an assert message
 *
 */

#include "precomp.h"

char XboxAssert(PDMN_DEBUGSTR pdmds)
{
	int id;
	TCHAR szTitle[64];
	char szAssert[1024];
	int cch = pdmds->Length;

	if(cch > sizeof szAssert - 1)
		cch = sizeof szAssert - 1;

	memcpy(szAssert, pdmds->String, cch);
	szAssert[cch] = 0;
	LoadString(hInstance, IDS_ASSERT_ARI, szAssert + cch, sizeof szAssert -
		cch);
	szTitle[0] = 0;
	LoadString(hInstance, IDS_ASSERT_TITLE, szTitle, sizeof szTitle);

	id = MessageBox(NULL, szAssert, szTitle, MB_ABORTRETRYIGNORE);
	switch(id) {
	case IDABORT:
		return 't';
	case IDRETRY:
		return 'b';
	case IDIGNORE:
		return 'i';
	}
	assert(FALSE);
	return 0;
}

void XboxRip(LPCSTR psz)
{
	char szRip[256];

	szRip[0] = 0;
	LoadString(hInstance, IDS_RIP, szRip, sizeof szRip);
	MessageBox(NULL, psz, szRip, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\idl\HELPSYS.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Wed Sep 24 14:58:41 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HELPSYS.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HELPSYS_h__
#define __HELPSYS_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IVsHelpSystem_FWD_DEFINED__
#define __IVsHelpSystem_FWD_DEFINED__
typedef interface IVsHelpSystem IVsHelpSystem;
#endif 	/* __IVsHelpSystem_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_HELPSYS_0000
 * at Wed Sep 24 14:58:41 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


typedef /* [v1_enum] */ 
enum _VHS_COMMANDS
    {	VHS_Default	= 0,
	VHS_UseBrowser	= 0x1,
	VHS_UseHelp	= 0x2,
	VHS_Localize	= 0x4
    }	VHS_COMMAND;



extern RPC_IF_HANDLE __MIDL_itf_HELPSYS_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HELPSYS_0000_v0_0_s_ifspec;

#ifndef __IVsHelpSystem_INTERFACE_DEFINED__
#define __IVsHelpSystem_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVsHelpSystem
 * at Wed Sep 24 14:58:41 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IVsHelpSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("854d7ac0-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearch( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ALinkSearch( 
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearchDlg( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FullTextSearchDlg( 
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentURL( 
            /* [out] */ BSTR __RPC_FAR *ppszURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURL( 
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromIdentifier( 
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ActivateHelpSystem( 
            /* [in] */ const DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVsHelpSystem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVsHelpSystem __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ALinkSearch )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeywordSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FullTextSearchDlg )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *ppszURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromURL )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayTopicFromIdentifier )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD Id,
            /* [in] */ const DWORD Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivateHelpSystem )( 
            IVsHelpSystem __RPC_FAR * This,
            /* [in] */ const DWORD dwFlags);
        
        END_INTERFACE
    } IVsHelpSystemVtbl;

    interface IVsHelpSystem
    {
        CONST_VTBL struct IVsHelpSystemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpSystem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpSystem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpSystem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpSystem_KeywordSearch(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearch(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_ALinkSearch(This,pszALink,dwFlags,dwReserved)	\
    (This)->lpVtbl -> ALinkSearch(This,pszALink,dwFlags,dwReserved)

#define IVsHelpSystem_KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)	\
    (This)->lpVtbl -> FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)

#define IVsHelpSystem_GetCurrentURL(This,ppszURL)	\
    (This)->lpVtbl -> GetCurrentURL(This,ppszURL)

#define IVsHelpSystem_DisplayTopicFromURL(This,pszURL,Command)	\
    (This)->lpVtbl -> DisplayTopicFromURL(This,pszURL,Command)

#define IVsHelpSystem_DisplayTopicFromIdentifier(This,pszFile,Id,Command)	\
    (This)->lpVtbl -> DisplayTopicFromIdentifier(This,pszFile,Id,Command)

#define IVsHelpSystem_ActivateHelpSystem(This,dwFlags)	\
    (This)->lpVtbl -> ActivateHelpSystem(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ALinkSearch_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszALink,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_ALinkSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_FullTextSearchDlg_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszQuery,
    /* [in] */ const DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IVsHelpSystem_FullTextSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_GetCurrentURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *ppszURL);


void __RPC_STUB IVsHelpSystem_GetCurrentURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromURL_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszURL,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromIdentifier_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFile,
    /* [in] */ const DWORD Id,
    /* [in] */ const DWORD Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ActivateHelpSystem_Proxy( 
    IVsHelpSystem __RPC_FAR * This,
    /* [in] */ const DWORD dwFlags);


void __RPC_STUB IVsHelpSystem_ActivateHelpSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpSystem_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_HELPSYS_0136
 * at Wed Sep 24 14:58:41 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define SID_SVsHelpService IID_IVsHelpSystem
#define SID_SHelpService IID_IVsHelpSystem


extern RPC_IF_HANDLE __MIDL_itf_HELPSYS_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HELPSYS_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\idl\HELPSYSid.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.02.88 */
/* at Wed Sep 24 14:58:41 1997
 */
/* Compiler settings for x:\dev-vs\devbin\htmlhelp\v6\idl\HELPSYS.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IVsHelpSystem = {0x854d7ac0,0xbc3d,0x11d0,{0xb4,0x21,0x00,0xa0,0xc9,0x0f,0x9d,0xc4}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\cmdtable.h ===
// cmdtable.h : Headers for writing command tables
//

#ifndef __CMDTABLE_H__
#define __CMDTABLE_H__ 

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

// Flags used for individual commands in command tables.
#define CT_NONE       	0x0000
#define CT_TOP        	0x0001
#define CT_NOKEY        0x0002
#define CT_NOMENU     	0x0004
#define CT_QUERYMENU  	0x0008	// Hides menuitem.
#define CT_HWND			0x0010
#define CT_HWNDSIZE		0x0020
#define CT_HWNDENABLE	0x0040
#define CT_REPEATABLE	0x0080
// Normally, a command can be added to a toolbar provided it doesn't have the
// CT_NOKEY bit set (which indicates that the command isn't customisable). This
// flag should only be used for commands which can be assigned to custom keystrokes,
// but shouldn't be assigned to buttons. Examples of this are keystrokes used to enter
// or affect toolbars.
#define CT_NOBUTTON		0x0100

// When this is present, the command will be shown textually if placed on a toolbar. Note that
// there is (by design) no combination of flags that puts text plus glyph on a toolbar. It
// would be trivial to add, but text+glyph is not being encouraged.
#define CT_TEXTBUTTON   0x0200

// When this is present, the command represents a pulldown menu. This is *not* the opposite
// of CT_NOMENU; in fact, the two flags can be used together. CT_NOMENU implies that the
// command won't be placed on a menu. CT_MENU implies that the command represents a (SUB)
// menu
#define CT_MENU         0x0400

// When this is present, the command is a placeholder for dynamic menu items. These items
// will be requested just before the menu is shown, and can be filled with, for example,
// a window list, MRU, etc.
#define CT_DYNAMIC      0x0800

// When this is present, the command string may be replaced dynamically at the
// package level. The package GetCommandStrings will be called, and it
// may change the string, or default to the command table entry (by returning NULL).
#define CT_DYNAMIC_CMD_STRING     0x1000

// When this is present, the command should be shown or hidden depending on projects
// currently loaded in the workspace.
#define CT_PROJECT_DEPENDENT	0x2000

// Not in CMDCOMP.EXE
#define CT_NOUI			0x8000

// Command string indices.
#define STRING_COMMAND		0
#define STRING_MENUTEXT		1
#define STRING_PROMPT		2
#define STRING_TIP			3
#define STRING_MAX_INDEX	3

/////////////////////////////////////////////////////////////////////////////
#undef AFX_DATA
#define AFX_DATA NEAR

#endif  // __CMDTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\afxdllxx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXDLLX.H: Extra header for building an MFC Extension DLL
//
// This file is really a source file that you should include in the
// main source file of your DLL.  It must only be included once, and
// not multiple times (you will get linker errors if it is included
// multiple times).  If you do not use _AFXEXT, it is not required
// but you may want the feature it provides.
//
// Previous versions of 32-bit MFC did not require this file.  This version
// requires this file to support dynamic loading of extension DLLs.  In
// other words, if your application does LoadLibrary on any extension
// DLL (instead of binding to the DLL at link time), this file is
// required.

#ifndef VERSION_CHECK_ONLY
#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

// The following symbol used to force inclusion of this module for _AFXEXT
#if defined(_X86_) || defined(_MAC)
extern "C" { int _afxForceEXTDLL; }
#else
extern "C" { int __afxForceEXTDLL; }
#endif

/////////////////////////////////////////////////////////////////////////////
// RawDllMain that saves current app class list and factory list

extern "C" BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID);

// modification from original: below line commented out so package RawDllMain called
// extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &ExtRawDllMain;

extern "C"
BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// save critical data pointers before running the constructors
		AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
		pModuleState->m_pClassInit = pModuleState->m_classList;
		pModuleState->m_pFactoryInit = pModuleState->m_factoryList;
		pModuleState->m_classList.m_pHead = NULL;
		pModuleState->m_factoryList.m_pHead = NULL;
	}
	return TRUE;    // ok
}

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif
#endif // !VERSION_CHECK_ONLY

/////////////////////////////////////////////////////////////////////////////
// Package version checking

#ifdef _M_IX86
#ifdef _DEBUG
#define PACKVFILENAME "i386\pkgverd.h"      // Generated at shell compile-time
#else
#define PACKVFILENAME "i386\pkgver.h"       // Generated at shell compile-time
#endif
#elif defined(_M_MRX000)
#ifdef _DEBUG
#define PACKVFILENAME "mips\pkgverd.h"
#else
#define PACKVFILENAME "mips\pkgver.h"
#endif
#elif defined(_M_PPC)
#ifdef _DEBUG
#define PACKVFILENAME "ppc\pkgverd.h"
#else
#define PACKVFILENAME "ppc\pkgver.h"
#endif
#elif defined(_M_ALPHA)
#ifdef _DEBUG
#define PACKVFILENAME "alpha\pkgverd.h"
#else
#define PACKVFILENAME "alpha\pkgver.h"
#endif
#else
#error Unsupported Platform
#endif

#include PACKVFILENAME

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\fmtinfo.h ===
//	REVIEW(DavidGa):  This needs to be drastically simplified and moved
//                    into shlsrvc.h.

//								FMTINFO.H
//
//	Classes defined:
//
//		CFormatInfo
//		CFormatInfoArray
//
//	Structures defined:
//
//		FMT_ELEMENT
//		FMT_WINDOW
//		FMT_WINGROUP
//		LOGFONTSEARCH
//		AUTO_COLOR
//
///////////////////////////
//
//	This provides font and color support for packages.  The FMT_* structures can be used by
//	the packages to statically define the default values.  CFormatInfo manages a single
//	FMT_WINGROUP structure and all it points to.  CFormatInfoArray is used by the dialog to manage
//	the CFormatInfo instances supplied by the packages.
//
/////

class CFormatInfo;
class CFmtIterator;
class CFmtGroupIterator;
class CFmtWindowIterator;
class CFmtElementIterator;
class CFCDialogState;
class CFontColorDlg;	// Define in fcdialog.h

class CPackage;

#ifndef __FMTINFO_H__
#define __FMTINFO_H__

_TCHAR * NewString (const _TCHAR * sz);

#define RGB_BLACK		RGB(0x00, 0x00, 0x00)
#define RGB_WHITE		RGB(0xFF, 0xFF, 0xFF)
#define RGB_RED			RGB(0xFF, 0x00, 0x00)
#define RGB_GREEN		RGB(0x00, 0xFF, 0x00)
#define RGB_BLUE		RGB(0x00, 0x00, 0xFF)
#define RGB_YELLOW		RGB(0xFF, 0xFF, 0x00)
#define RGB_MAGENTA		RGB(0xFF, 0x00, 0xFF)
#define RGB_CYAN		RGB(0x00, 0xFF, 0xFF)
#define RGB_LIGHTGRAY	RGB(0xC0, 0xC0, 0xC0)
#define RGB_GRAY		RGB(0x80, 0x80, 0x80)
#define RGB_DARKRED		RGB(0x80, 0x00, 0x00)
#define RGB_DARKGREEN	RGB(0x00, 0x80, 0x00)
#define RGB_DARKBLUE	RGB(0x00, 0x00, 0x80)
#define RGB_LIGHTBROWN	RGB(0x80, 0x80, 0x00)
#define RGB_DARKMAGENTA	RGB(0x80, 0x00, 0x80)
#define RGB_DARKCYAN	RGB(0x00, 0x80, 0x80)

// IMPORTANT: These macros depend heavily on the order of things in colors.cpp.
//    1) The order of colors in window must be Source Text, Text Selection, Text Highlight.
#define AUTO_TEXT			{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define AUTO_SELECTION		{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 },					{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define AUTO_HIGHLIGHT 		{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define AUTO_REF(n) 		{ TRUE, FALSE, FALSE, FALSE, FALSE, n }, 	{ TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define AUTO_REF_SRC(n) 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }, 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define BACKAUTO_TEXT			{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define BACKAUTO_SELECTION		{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 },					{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define BACKAUTO_HIGHLIGHT 		{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define BACKAUTO_REF(n) 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }, 	{ TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define BACKAUTO_REF_SRC(n) 	{ FALSE, FALSE, TRUE, FALSE, FALSE, n }, 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define NOTAUTO_TEXT		{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define NOTAUTO_SELECTION	{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 },	{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 }
#define NOTAUTO_HIGHLIGHT	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define NOTAUTO_REF(n) 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }, 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }
#define NOTAUTO_REF_SRC(n) 	{ FALSE, FALSE, TRUE, FALSE, FALSE, n }, 		{ FALSE, FALSE, TRUE, FALSE, FALSE, n }


struct AUTO_COLOR
{
	WORD	bOn:1;		// Is auto color being used now?
	WORD	bSys:1;		// Get the color from the system(1) or from a window(0)?
	WORD	bSrc:1;		// If bSys == 0, use this window(0) or the Source Window(1)?
	WORD	bRev:1;		// If from this window, reverse fore/background(1)?
	WORD	bUpd:1;		// Used by UpdateAutoColors().
	WORD	index:5;	// Index into element list(bSys==0) or COLOR_* value (bSys==1).
};

// This structure is used to translate between a Windows LOGFONT
// structure and name/size/flags combination.
//
struct LOGFONTSEARCH
{
	LOGFONT		LogFont;
	TCHAR *		szFontFace;
	BYTE		nFontSize;
	BYTE		nCharSet;
	int			nPixPerInchY;
	BOOL		bMonospace:1;
	BOOL		bTrueType:1;
};


struct FMT_ELEMENT
{
	TCHAR *		szElement;
	COLORREF	rgbText;
	COLORREF	rgbBackground;
	AUTO_COLOR	autoFore;
	AUTO_COLOR	autoBack;
};

struct FMT_WINDOW
{
	TCHAR *			szWindow;
	TCHAR *			szRegEntry;
	BOOL			bChanged:1;
	BOOL			bMonospace:1;
	TCHAR *			szFontFace;
	UINT			nFontSize;
	PLOGFONT		pLogFont;
	int				nElements;
	FMT_ELEMENT *	rgElements;
};

struct FMT_WINGROUP
{
	int				nWindows;
	BOOL			bSingleGroup:1;	// If this is a singleton, do we show the group name?
	_TCHAR *		szName;		// Name of Windows group
	FMT_WINDOW *	rgWindows;
};


#define FMT_ELEMENTS(x)		(sizeof(x) / sizeof(FMT_ELEMENT))
#define FMT_WINDOWS(x)		(sizeof(x) / sizeof(FMT_WINDOW))

enum DialogState { PreDialog, SelAll, SelGroup, SelWindow, PostDialog };

//////////////////////////////////////////////////////////////////////////////
//																			//
//							class CFormatInfo								//
//																			//
//	This class handles one instance of FMT_WINGROUP data.					//
//																			//
//////////////////////////////////////////////////////////////////////////////


class CFormatInfo : public CObject
{
// Iterators are friends.
friend CFmtIterator;
friend CFmtGroupIterator;
friend CFmtWindowIterator;
friend CFmtElementIterator;
friend CFCDialogState;

DECLARE_DYNAMIC (CFormatInfo);

private:
	CPackage * 		m_pPackage;		// Package info belongs to
	FMT_WINGROUP *	m_pWinGroup;
	int				m_nWinGroups;
	CFormatInfo *	m_pFormatInfoFromPackage;

	// These are used by the Registry code
	//
	static _TCHAR	m_szRegKey[];
	static _TCHAR	m_szFontFace[];
	static _TCHAR	m_szFontSize[];
	static _TCHAR	m_szCharSet[];

	// This is useful to know
	//
	static int		m_nPixPerInchY;

	// These are useful tools

	void SetForeColor ( UINT iFmtInfo, UINT iGroup, UINT iElement, COLORREF rgb );
	void SetBackColor ( UINT iFmtInfo, UINT iGroup, UINT iElement, COLORREF rgb );

public:
	CFormatInfo ( CPackage * pPackage = NULL);
	~CFormatInfo ();

	void Clear ();	// Remove and free all data

	BOOL IsEmpty () const { return m_nWinGroups == 0; }

	void SaveToRegistry () const;
	void UpdateFromRegistry ();

	BOOL GetFormatInfo ( CPackage * pPackage = NULL);

	const CFormatInfo& operator= (const FMT_WINGROUP&);
	const CFormatInfo& operator= (const CFormatInfo&);
	const CFormatInfo& operator+= (const FMT_WINGROUP&);

	FMT_ELEMENT * GetElementList ( const _TCHAR * szWindow ) const;
	FMT_WINDOW *  GetWindow ( const _TCHAR * szWindow ) const;

	int GetWindowCount () const;

	void UpdateAutoColors (FMT_WINDOW * pWindow);
	void UpdateAllAutoColors ();

	void Update (const CFormatInfo& fmtInfo, int iWinGroup = -1, int iWindow = -1);

	void UpdateAllLogFonts ();

	static int GetLogFont (LOGFONTSEARCH * pSearchLogFont);
	static void UpdateLogFont (FMT_WINDOW * pWindow);

	// This is used as an EnumLogFont callack to get the LOGFONT struct for
	// a given set of name/size/flags.  LPARAM is a pointer to a
	// LOGFONTSEARCH.
	static int CALLBACK SearchCallBack(CONST ENUMLOGFONT *, CONST NEWTEXTMETRIC *, int, LPARAM);


	//
	// Support for Fonts and Colors dialog
	//
	BOOL Commit () const;
	BOOL IsDirty () const;

	void Clean ();
};


//////////////////////////////////////////////////////////////////////////////
//						class CFmtIterator									//
//						class CFmtGroupIterator								//
//						class CFmtWindowIterator							//
//						class CFmtElementIterator							//
//																			//
//	Iteration classes for CFormatInfo.										//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CFmtIterator
{
protected:

	const CObArray&	m_rgFmtInfo;
	int		m_iFmtInfo;

public:
	CFmtIterator ( const CObArray& rgFmtInfo);

	CFormatInfo * Get ();
	CFormatInfo * Peek () const;

	inline void Inc ();

	inline UINT	GetIndex () const;
	inline void	Set (int iFmtInfo);
};

class CFmtGroupIterator : public CFmtIterator
{
protected:

	int	m_iGroup;

public:
	CFmtGroupIterator ( const CObArray& rgFmtInfo);

	FMT_WINGROUP * Get ();
	FMT_WINGROUP * Peek () const;

	inline void Inc ();

	void	SetLinear (UINT iGroupLinear);
	void	Set (FMT_WINGROUP * pWindow);
	inline void	Set (int iFmtInfo, int iWinGroup);
	FMT_WINGROUP *  GetLinear ();
	FMT_WINGROUP * PeekLinear ();
	
	inline UINT	GetIndex () const;
};

class CFmtWindowIterator : public CFmtGroupIterator
{
protected:

	int		m_iWindow;


public:
	CFmtWindowIterator ( const CObArray& rgFmtInfo);

	FMT_WINDOW * Get ();
	FMT_WINDOW * Peek () const;

	inline void Inc ();

	void	SetLinear (UINT iWinLinear);
	void	Set (FMT_WINDOW * pWindow);
	FMT_WINDOW * GetLinear ();
	FMT_WINDOW * PeekLinear ();

	inline UINT	GetIndex () const;
};

class CFmtElementIterator : public CFmtWindowIterator
{
protected:

	int		m_iElement;

public:
	CFmtElementIterator ( const CObArray& rgFmtInfo);

	FMT_ELEMENT * Get ();
	FMT_ELEMENT * Peek () const;

	inline void Inc ();
	inline void Dec ();	// HACK!

	void	SetLinear (UINT iElementLinear);
	FMT_ELEMENT * GetLinear ();
	FMT_ELEMENT * PeekLinear ();

	inline UINT	GetIndex () const;

};

inline UINT	CFmtIterator::GetIndex () const { return m_iFmtInfo; }
inline UINT	CFmtGroupIterator::GetIndex () const { return m_iGroup; }
inline UINT	CFmtWindowIterator::GetIndex () const { return m_iWindow; }
inline UINT	CFmtElementIterator::GetIndex () const { return m_iElement; }

inline void CFmtIterator::Inc () { m_iFmtInfo++; }
inline void CFmtGroupIterator::Inc () { m_iGroup++; }
inline void CFmtWindowIterator::Inc () { m_iWindow++; }
inline void CFmtElementIterator::Inc () { m_iElement++; }

inline void CFmtElementIterator::Dec () { m_iElement--; }

inline void	CFmtGroupIterator::Set (int iFmtInfo, int iWinGroup)
{
	m_iGroup = iWinGroup;
	CFmtIterator::Set (iFmtInfo);
}

inline void	CFmtIterator::Set (int iFmtInfo)
{
	m_iFmtInfo = iFmtInfo;
}

//////////////////////////////////////////////////////////////////////////////
//							class CElList									//
//																			//
// A list of unique element names.  Uniqueness is enforced.  Will also		//
// iterate a given name - i.e. will sequentially find all elements with		//
// the given name.															//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CElList
{
	UINT		m_inc;	// Allocation increment
	CPtrArray	m_rgStrings;

	CString		m_strSearch;
public:
	CElList (UINT inc = 4);
	CElList::~CElList ();

	BOOL AddString (const CString& str);	// FALSE -> String was already there

	FMT_ELEMENT * GetFirst (_TCHAR * szName, CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);
	FMT_ELEMENT * GetFirst (UINT iEl, CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);
	FMT_ELEMENT * GetNext (CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);

	void Fill (CListBox& lbox) const;
	void Clear ();

	BOOL IsForeColorTheSame (UINT iEl, CFmtElementIterator& it, int iFormat, int iGroup, COLORREF& rgb);
	BOOL IsBackColorTheSame (UINT iEl, CFmtElementIterator& it, int iFormat, int iGroup, COLORREF& rgb);

	inline int	GetSize () const;
};

inline int	CElList::GetSize () const
{
	return m_rgStrings.GetSize ();
}
	
//////////////////////////////////////////////////////////////////////////////
//							class CWinList									//
//																			//
//	A list of FMT_WINDOW and FMT_WINGROUP.  Used for the list of windows	//
//	under "Category" in the Fonts dialogs.									//
//																			//
//////////////////////////////////////////////////////////////////////////////


class CWinList
{
	CPtrArray	m_rgGroups;
	CPtrArray	m_rgWindows;

public:
	CWinList (UINT inc = 4);
	~CWinList ();

	void Add (FMT_WINGROUP * pGroup);

	void Fill (CListBox& lbox) const;

	BOOL GetName (int index, CString& strName) const;
	BOOL GetPtr (int index, void * &p) const;

	int FirstWindowIndex () const;
};

//////////////////////////////////////////////////////////////////////////////
//							class FCDialogState								//
//																			//
//	This class acts as an intermediary between a CFontColorDlg and the		//
//	CFormatInfo objects underlying it.  It locates and manages the data		//
//	from the packages, it keeps track of the state of the dialog and		//
//  propogates changes to the underlying data.  It also propogates state	//
//	changes in one part of the dialog to the rest of the dialog.			//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CFCDialogState
{
	DialogState		m_state;

	// As an intermediary, an instance of this class must have access
	// to the CFontColorDlg object that it is working with
	CFontColorDlg *	m_pDialog;

	CObArray		m_rgFmtInfo;

	// In the Group and All states, a list of unique element names from
	// the group(s) in question is maintained:
	CElList			m_elList;

	// This holds the list of windows and window groups that is shown
	// in the dialog
	CWinList		m_winList;
	UINT			m_iCurWin;

	// These describe the current Window/Element selection in terms of
	// CFormatInfo array element / Windows Group / Window / Element.
	// 
	UINT			m_nFmtInfoCur;
	UINT			m_nWinGroupCur;
	UINT			m_nWindowCur;
	UINT			m_nElementCur;

	// Enabled flags. Which parts of the dialog are enabled?

	BOOL	m_benFontName:1;
	BOOL	m_benFontSize:1;
	BOOL	m_benElements:1;
	BOOL	m_benForeColor:1;
	BOOL	m_benBackColor:1;

public:

	CFCDialogState ( CFontColorDlg * pDialog = NULL );
	~CFCDialogState ();

	// State retrievers
	inline operator DialogState () const;

	FMT_WINDOW * GetWinCur (BOOL bReturnNull = TRUE, BOOL bMustHaveFont = FALSE) const;

	COLORREF GetForeColor ();
	COLORREF GetBackColor ();
	PLOGFONT GetCurrentLogFont () const;

	// Talk a walk over 
	enum WW_ACTION { FontEquality, FontPitch };
	enum WW_RESULT { SameFont, FontsDiffer, NoFont, PitchFixed, PitchProportional, PitchMixed, NoWindows };
	WW_RESULT WindowWalk (WW_ACTION act) const;

	// State modifiers.
	void InitDialog ();
	void SetCurrentWindow (int iWindow);
	void SetCurrentElement  (int iElement);
	void SetCurrentFont (const CString& strFontName, int size, BOOL bTrueType);
	void SetCurrentFontSize (int nFontSize);

	void SetForeColor ( COLORREF rgb );
	void SetBackColor ( COLORREF rgb );

	void RestoreDefaults ();

	void UpdateAllAutoColors ();

	// Other stuff
	void Commit();

};

inline CFCDialogState::operator DialogState () const
{
	return m_state;
}



#endif  // __FMTINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\gmap.h ===
#ifndef INCLUDED_GMAP_H
#define INCLUDED_GMAP_H

#include <afx.h> // CObject
#include <afxtempl.h> // CMap
#include <limits.h> // INT_MAX

/* these are typedef's, not types.

	// GrowingMaps (aka Dictionaries)
	class CGrowingMapWordToOb;         // map from WORD to CObject*
	class CGrowingMapWordToPtr;        // map from WORD to void*
	class CGrowingMapPtrToWord;        // map from void* to WORD
	class CGrowingMapPtrToPtr;         // map from void* to void*

	// Special String variants
	class CGrowingMapStringToPtr;      // map from CString to void*
	class CGrowingMapStringToOb;       // map from CString to CObject*
	class CGrowingMapStringToString;   // map from CString to CString

*/

class CGrowingMapNonTemplate
{
public:
/*inline just to live in header*/
	inline static unsigned PickSize(int nElements);
};

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CGrowingMap :
	public CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>,
	public CGrowingMapNonTemplate
{
private:
	typedef CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> Inherited;
protected:
	typedef KEY BASE_KEY; // for CTypedPtrMap
	typedef ARG_KEY BASE_ARG_KEY; // for CTypedPtrMap
	typedef VALUE BASE_VALUE; // for CTypedPtrMap
	typedef ARG_VALUE BASE_ARG_VALUE; // for CTypedPtrMap
public:
	CGrowingMap();
	CGrowingMap(int nBlockSize);
	void Rehash(int nBuckets);
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);
	VALUE& operator[](ARG_KEY key); // override
	void SetAt(ARG_KEY key, ARG_VALUE newValue)
	{
		(*this)[key] = newValue;
	}
	void GrowMaxLoad(float);
	// rehash when GetCount() > when GetHashTableSize() * growMaxLoad
	// presently assumed > 1

	void GrowMinLoad(float);
	// rehash so that GetCount() ~ when GetHashTableSize() * growMinLoad
	// but don't actually shrink to meet it.
	// presently assumed ~ 1 by PickSize

	void GrowDoubling()
	{ // not good with multiplicative hash functions that favor prime hash sizes
		ASSERT(!"NYI");
	}
	void GrowInSteps()
	{ // sort of assumed (vague meaning, pretty much tied to PickSize)
	}
	void GrowPreferPrimes(BOOL)
	{ // assumed
		ASSERT(!"NYI");
	}

	void Lock();
	void Unlock();
	int GetLock() const;
protected:
	int m_nLock;
	unsigned m_nRehashThreshold; // nBuckets * m_fMaxGrowLoad
	float m_fMaxGrowLoad; // might not need to keep this around, presently assumed > 1
	float m_fMinGrowLoad; // presently assumed == 1
};

// These typedefs probably cause actual repeated compile time instantiation followed
// by link time dead stripping. They should probably be removed, or changed
// back to declarations with one time instantiation in a .cpp.

//typedef
//	CGrowingMap<CMapWordToOb, WORD, WORD, CObject*, CObject*>
//	CGrowingMapWordToOb;
typedef
	CGrowingMap<WORD, WORD, void*, void*>
	CGrowingMapWordToPtr;
typedef
	CGrowingMap<void*, void*, WORD, WORD>
	CGrowingMapPtrToWord;
typedef
	CGrowingMap<void*, void*, void*, void*>
	CGrowingMapPtrToPtr;
typedef
	CGrowingMap<CString, LPCTSTR, void*, void*>
	CGrowingMapStringToPtr;
//typedef
//	CGrowingMap<CString, LPCTSTR, CObject*, CObject*>
//	CGrowingMapStringToOb;
typedef
	CGrowingMap<CString, LPCTSTR, CString, LPCTSTR>
	CGrowingMapStringToString;

// REVIEW, why does MFC use LPCTSTR instead of const CString&?
// Just to avoid CString construction and destruction?

// constructors
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CGrowingMap(int nBlockSize)
	: Inherited(nBlockSize)
{
	ASSERT(nBlockSize > 0);
	m_nLock = 0;
	GrowInSteps();
	GrowMaxLoad(2);
	GrowMinLoad(1);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CGrowingMap()
{
	m_nLock = 0;
	GrowInSteps();
	GrowMaxLoad(2);
	GrowMinLoad(1);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
// This rehashes
	ASSERT_VALID(this);
//	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (GetCount() == 0) {
		Inherited::InitHashTable(nHashSize, bAllocNow);
	} else { // rehash
		Rehash(nHashSize);
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Rehash(int nBuckets)
{
// new "relinking" version
#ifdef _DEBUG
#ifdef _IOSTREAM_
	// output to console if it's being used
	std::cerr
			<< "std::cerr: "
			<< "rehashing "
			<< GetCount()
			<< " elements from "
			<< m_nHashTableSize 
			<< " buckets to "
			<< nBuckets
			<< " buckets.\n";
#endif
	// output to debugger
	afxDump
			<< "afxDump: "
			<< "rehashing "
			<< GetCount()
			<< " elements from "
			<< m_nHashTableSize 
			<< " buckets to "
			<< nBuckets
			<< " buckets.\n";
#endif
	if (m_pHashTable == NULL || GetCount() == 0)
	{
		return;
	}
	ASSERT(nBuckets > 0);

	// first, stash pointers to all Assocs, based on RemoveAll
	CAssoc** aryAssocs = new CAssoc* [GetCount()];
	CAssoc** iter = aryAssocs;
	UINT nHash;
	for (nHash = 0; nHash < m_nHashTableSize; nHash++)
	{
		CAssoc* pAssoc;
		for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
		{
			*iter++ = pAssoc;
		}
	}
	ASSERT(iter == aryAssocs + GetCount());

	m_nHashTableSize = nBuckets;
	// now rehash and relink in new m_pHashTable
	delete [] m_pHashTable;
	m_pHashTable = new CAssoc* [m_nHashTableSize];
	memset(m_pHashTable, 0, sizeof(CAssoc*) * m_nHashTableSize);
	UINT n;
	for (n = 0 ; n < GetCount() ; n++)
	{
		// compute hash
		UINT nHash = HashKey<ARG_KEY>(aryAssocs[n]->key) % m_nHashTableSize;
		aryAssocs[n]->nHashValue = nHash; // cache for iteration
// map from WORD, DWORD, void*, CObject* cheaply rehash instead during interation
// instead of caching the hash. So far, CGrowingMap loses here on size (double!).

		// put into hash table
		aryAssocs[n]->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = aryAssocs[n];
	}
	delete[] aryAssocs;
	m_nRehashThreshold = GetHashTableSize() * m_fMaxGrowLoad;
}


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);
	const int sizeBefore = GetCount();
	VALUE& resultIfWeDontRehash = Inherited::operator[](key);
	const int sizeAfter = GetCount();
	ASSERT(sizeBefore == sizeAfter || sizeBefore+1 == sizeAfter);
// OPTIMIZE
// If we dig into CMap, we can optimize the check for growth.
	if (sizeBefore != sizeAfter && sizeAfter > m_nRehashThreshold && m_nLock == 0)
	{
		int next_number_of_buckets;
// FUTURE : support more sizing strategies
//		if (m_bGrowDoubling)
//		{
//			ASSERT(!m_bPreferPrimes);
//			ASSERT(m_bGrowInSteps);
		//			next_size = nBlockSize+nBlockSize;
//		}
//		if (m_bGrowInSteps)
//		{
			next_number_of_buckets = PickSize(GetCount());
			if (next_number_of_buckets <= GetHashTableSize())
			{
				// primes table has been maxed out, either pin the size
				// or double it. Currently we just pin it.
				m_nRehashThreshold = INT_MAX; // no more rehashing.
				return resultIfWeDontRehash;
			}
			else
			{
				Rehash(next_number_of_buckets);
			}
//		}
	}
	// we can return the nonRehash result because Rehash is now in place.
	return resultIfWeDontRehash;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GrowMaxLoad(float load)
{
	m_fMaxGrowLoad = load;
	m_nRehashThreshold = GetHashTableSize() * m_fMaxGrowLoad;
	ASSERT(load > 1 || !"NYI");
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GrowMinLoad(float load)
{
	ASSERT(load == 1 || !"NYI");
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lock()
{
	m_nLock++;
	ASSERT(m_nLock >= 0); // leak
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Unlock()
{
	m_nLock--;
	ASSERT(m_nLock >= 0); // underflow.
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int CGrowingMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetLock() const
{
	return m_nLock;
}

/*static*/ inline /*inline just to live in header*/
unsigned CGrowingMapNonTemplate::PickSize(int nElements)
{
	unsigned x = nElements;
	static const unsigned primes[] = { 47, 251, 509, 1021, 1531, 2039, 2557, 3067, 3583, 4093, 4603, 5119 };
	const unsigned MAX_PRIME_INDEX = sizeof(primes)/sizeof(primes[0]) - 1;
// TODO have this pay attention to m_nMinLoad
	if (x < 50)
		x = 0;
	else if (x < 256)
		x = 1;
	else
	{
		x = (x / 512) + 2;
		if (x > MAX_PRIME_INDEX)
			x = MAX_PRIME_INDEX;
	}
	return primes[x];
}

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

// Some changes compared to CTypedPtrMap
// extra two ARG_ parameters allow CString's to work, cast through LPCTSTR

template<class BASE_CLASS, class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CTypedPtrGrowingMap :
	public BASE_CLASS
{
public:

// Construction
	CTypedPtrGrowingMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize)
	{
	}

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const
	{
		return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue);
	}

	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key)
	{
		return (VALUE&)BASE_CLASS::operator[](key);
	}

	// add a new key (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue)
	{
		BASE_CLASS::SetAt(key, newValue);
	}
// REVIEW might need cast newValue BASE_CLASS::BASE_ARG_VALUE for CStrings
// Nope, CANNOT map to CString as if it is a CObject* or void*

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key)
	{
		return BASE_CLASS::RemoveKey(key);
	}

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
	{
		BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue);
	}
};

typedef CTypedPtrGrowingMap
<
	CGrowingMapStringToPtr,//CGrowingMap<CString, LPCTSTR, void*, void*>,
	CString, LPCTSTR,
	CObject*, CObject*
>
CGrowingMapStringToOb;

typedef CTypedPtrGrowingMap
<
	CGrowingMapWordToPtr,//CGrowingMap<WORD, WORD, void*, void*>,
	WORD, WORD,
	CObject*, CObject*
>
CGrowingMapWordToOb;

// TODO specialize some maps to not waste 4 bytes to cache a cheaply computed
// hash and recompute it while iterating, like MFC does.

// TODO reintroduce the optimizations of gmap3 and gmap4 that preinstantiated
// common maps in one place and inhibited instantiation otherwise.

#endif // the whole file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\dlgbase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DLGBASE.H
//		Declarations for the sushi dialog base classes.
//
#ifndef __DLGBASE_H__
#define __DLGBASE_H__

#ifndef __MAIN_H__
#include "main.h"
#endif

#ifndef __PATH_H__
#include "path.h"
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

// This class is for pre-loading and munging dialog tempalates.
// For now, it is only used to change the font of a dialog...
//
class C3dDialogTemplate : public CDialogTemplate
{
public:
	void SetStdFont();
	HGLOBAL GetTemplate() const { return m_hTemplate; }
};

// Switch to enable on-the-fly dialog font changing...
#define MUNGE_DLG_FONTS

// Set standard fonts in dialog template
void SetStdFont(C3dDialogTemplate & dt);

// All Sushi dialog boxes should derive from this class...
//
class C3dDialog : public CDialog
{
public:
	C3dDialog(LPCSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	C3dDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	virtual int DoModal();
	virtual BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	
	afx_msg void OnRobustOK();
	afx_msg virtual void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg virtual BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnTestMenu(WPARAM wParam, LPARAM lParam);

	DECLARE_MESSAGE_MAP()
};

extern BOOL FindAccel( LPCTSTR lpstr, MSG *pMsg );

class C3dFileDialog : public CFileDialog
{
public:
	C3dFileDialog(BOOL bOpenFileDialog, // TRUE for Open, FALSE for SaveAs
		LPCSTR lpszDefExt = NULL,
		LPCSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		UINT nHelpID = 0, UINT nExplorerDlg = (UINT)-1);
	~C3dFileDialog();

	LPCTSTR GetFilterExtension(int n);
	void UpdateType(LPCTSTR lpszExt = NULL);
	void ApplyDefaultExtension(void);
	void SetOkButtonText(UINT ids);

	virtual int DoModal();

	afx_msg void OnRobustOK();
	afx_msg virtual void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg virtual BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnNameKillFocus();
	afx_msg void OnFileListSelChange();
	afx_msg void OnScc();

	void UpdateMultiSelectOnNT(void);

	virtual void OnOK();
	virtual void OnCancel ();
	virtual BOOL OnFileNameOK();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnInitDialog();

	BOOL IsExplorer()
		{ return m_ofn.Flags & OFN_EXPLORER; }

	// essentially overrides for MFC's GetStartPosition and GetNextPathName,
	// but which help us deal with limitations on multiple-selection handling.
	POSITION GetFullFileStartPosition();
	CString GetNextFullFileName(POSITION pos);

	DECLARE_MESSAGE_MAP()

protected:
	CDir m_dirCurBefore;	// Current dir before dialog goes up
	CDir m_dirCurAfter;		// Current dir after dismissal

public:
	CStringArray* m_psaFileNames;
	UINT m_iddWin95;
	UINT m_iddWinNT;
	BOOL m_bMultiSelectOnNT;
	BOOL m_bSccEnabled;
};

extern void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	const CString& strFilterName, BOOL bSetDefExt = FALSE);

extern void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	UINT idFilter, BOOL bSetDefExt = FALSE);

extern BOOL AddRegistryFilters(CString& strFilter, int nDesiredType, OPENFILENAME& ofn);

extern void AddWildFilter(CString& strFilter, OPENFILENAME& ofn);

extern void SetFileFilters(CString& strFilter, OPENFILENAME& ofn, int nDesiredType, 
	UINT* rgidDefaults, int nDefaults, const TCHAR* szCommon = NULL);

#define FLT_OPEN			1	// The File Open dialog
#define FLT_PROJECTFILES	2	// The Project Files dialog
#define FLT_TEXTFILES		4	// The Find in Files dialog

/////////////////////////////////////////////////////////////////////////////
//	CDirChooser
//			The semantics for dismissing the dialog are as follows:
//			It will be dismissed when the user selects a directory and then 
//			presses Enter a second time without changing the directory string
//			eg  - Type a name, hit Enter, hit Enter again
//				- Type a name, hit Enter, click OK
//				- Double-click on a directory name, click OK
//			Directories are not checked for existance.
//		Parameters
//			strOpenDir - Directory name that should be initially placed in 
//				the edit box. Default is the current directory.
//			strTitle - Window title. Default is "Choose Directory"
//			strPrompt - prompt to place just above the dialog's edit box.
//				It's recommended that this string contain an accelerator (&)
//				so the user can go to the edit box via the mouse.  (Make
//				sure the accelerator doesn't conflict with the others in
//				the dialog!). Default is Directory &Name:
class CDirChooser
{
	public:
		CDirChooser(LPCTSTR lpszOpenDir = NULL, LPCTSTR lpszTitle = NULL,
			LPCTSTR lpszPrompt = NULL, UINT nDlgID = 0);

		// GetPathName returns the path name the user selected
		CString GetPathName() const;

		// DoModal allows the user to perform the selection. Returns IDOK/IDCANCEL.
		// Returns 0 on error.
		virtual int DoModal();

		void SetMustExist(BOOL bMustExist);

	protected:
		// fDismissOpenDir returns TRUE if the dialog can be dismissed:
		//		szNew is the path when OK is hit or the directory list box selection
		//		is chosen.
		// This function *must* update m_strCurDir to be a copy of szNew.
		virtual BOOL	fDismissOpenDir(const LPCSTR szNew){return fDismissOpenDir (szNew, NULL);}
		virtual BOOL	fDismissOpenDir(const LPCSTR szNew, HWND hStatus);

		// m_dwHelpContext gives the help ID to link to the button.
		// CDirChooser supplies a default context, which is the directory picker description.
		DWORD	m_dwHelpContext;
		CString	m_strCurDir;
		CString	m_strPrompt;
		CString	m_strTitle;

	 	OPENFILENAME	m_ofn;
 		static UINT APIENTRY DirOpenHookProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
		static CDirChooser *pCurrentChooser;	// Only one chooser open at a time.

	public:
		BOOL m_bMustExist;

	private:
		char m_szFileName[_MAX_PATH];			// Common dialog proc fills this
};


typedef BOOL (FAR *LPFNFILEFINDVALIDATOR)(LPCTSTR szPath, LPCTSTR strFilename,	
	LONG lParam);


/////////////////////////////////////////////////////////////////////////////
//	CFileFindDlg
//			The semantics for dismissing the dialog are as follows:
//			The dialog will dismiss as soon as the user selects a directory in 
//			which a file with the name passed in to the constructor exists.
//		Parameters
//			strFileToFind - the filename for which we're searching.
//				DoModal won't return until the user specifies a directory in 
//				which this file can be found.
//			strOpenDir - Directory name that should be initially placed in 
//				the edit box. Default is the current working directory.
//			strTitle - Window title. Default is "Choose Directory"
//			strPrompt - prompt to place just above the dialog's edit box.
//				It's recommended that this string contain an accelerator (&)
//				so the user can go to the edit box via the mouse.  (Make
//				sure the accelerator doesn't conflict with the others in
//				the dialog!). Default is Directory &Name:

// Use the DoModal function to invoke the chooser. It returns IDOK / IDCANCEL,
// or 0 if there was an error.

class CFileFindDlg : public CDirChooser
{
	public:
		CFileFindDlg(LPCTSTR lpszFileToFind, LPCTSTR lpszOpenDir = NULL, 
					 LPCTSTR lpszTitle = NULL, LPCTSTR lpszPrompt = NULL);

		void SetValidator(LPFNFILEFINDVALIDATOR pfnValidator, LONG lparam);
		void ClearValidator (void) { SetValidator(NULL, 0);}

	protected:
		// fDismissOpenDir returns TRUE if the dialog can be dismissed:
		//		szNew is the path when OK is hit or the directory list box selection
		//		is chosen.
		// This function *must* update m_strCurDir to be a copy of szNew.
		virtual BOOL fDismissOpenDir(const LPCSTR szNew){return fDismissOpenDir (szNew, NULL);}
		virtual BOOL fDismissOpenDir(const LPCSTR szNew, HWND hStatus);

		CString m_strFileToFind;

		// Validation stuff
		CString m_strStatusMessage;
		LPFNFILEFINDVALIDATOR m_pfnValidator;
		LONG m_lValidatorParam;
	
};

////////////////////////////////////////////////////////////////////////////
// CDlgTab -- one page of a tabbed dialog

class CTabbedDialog;	// A tabbed "dialog" (really a modal popup window)

class CDlgTab : public CDialog
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CDlgTab)
	
// Construction
public:
	CDlgTab(UINT nIDTemplate, UINT nIDCaption);
	CDlgTab(LPCSTR lpszTemplateName, UINT nIDCaption);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

protected:
// Implementation
	CDlgTab();

	virtual void OnContextMenu(CWnd* pWnd, CPoint point);
	virtual BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	virtual UINT GetHelpID() { return m_nIDHelp; }

	// always call this to enable or disable a button in a dialog tab
	// it will ensure that the default button is passed correctly to the 
	// appropriate button in the parent dialog.  martynl 15Mar96
	virtual BOOL EnableButton(CWnd *button, BOOL bEnable);

public:
	virtual BOOL ValidateTab();

	virtual void CommitTab();
	virtual void CancelTab();

protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifdef _DEBUG	
	void EndDialog(int nEndID);
#endif

	CString m_strCaption;
	
	friend class CTabbedDialog;

private:
	// Derived classes should use CommitTab() and CancelTab()
	virtual void OnOK();
	virtual void OnCancel();

// Attributes
public:
	int m_nOrder;
};

extern BOOL IsTabNextFocus(CDialog* pDlg, UINT nCmd);

////////////////////////////////////////////////////////////////////////////
// CTabs -- implementation for a generic row of tabs along the top of dialog

class CTabRecord : public CObject
{
public:
	CTabRecord(const char* szCaption, int nWidth, int nOrder, DWORD dw);

	CString	m_strCaption;
	CRect	m_rect;
	int 	m_nWidth;
	BOOL	m_bClipped;
	int     m_nOrder;
	DWORD	m_dw;
};

class CTabRow : public CObject
{
public:
	enum {
		SCROLL_LEFT = -5,		// all the SCROLL_ items must be less
		SCROLL_RIGHT = -6,		// than -1 to avoid ID conflict
		SCROLL_NULL = -7,

		cxScrollSize = 31,		// size of the scroll button bitmap
		cyScrollSize = 17,
		cxScrollMargin = 10,	// blank margin between scroll buttons and tabs

		cxSelectedTab = 2,		// amount to inflate the selected tab
		cySelectedTab = 2,
		cxTabTextMargin = 10,	// extra width for a tab past text width
		cyTabTextMargin = 3,	// extra height for a tab past text height

		TIMER_ID = 15,
		TIMER_DELAY = 500
	};

	// Construction
	CTabRow();
	~CTabRow();

	void	ResetContent();
	void	AddTab(CString& szCaption, CDC* pDC, int nOrder, DWORD dw = 0);
	void	SetPos(CRect rect);		// set position of tab row within window
	int 	DesiredHeight(CDC* pDC);	// how much space does tab row need?
	void	SetParent(CWnd* pWndOwner)
	    		{ m_pWndOwner = pWndOwner; }

	// Operations
	int		SetActiveTab(int nTab);
	int		SetActiveTab(const CString& str);
	int 	GetActiveTab()
	    		{ return m_curTab; }

	void	PutFocus(BOOL bTabsHaveFocus);
	BOOL	HasFocus()
	    		{ return m_bHasFocus; }

	void	Scroll(int nDirection);
	void	ScrollIntoView(int nTab);

	// Drawing stuff
	void	Draw(CDC* pDC);
	void	DrawFocusRect(CDC* pDC);
	void	DrawPageRect(CDC* pDC, const CRect& rectPage);
	void	InvalidateTab(int nTab, BOOL bInflate = TRUE);
	CRect	GetRect() const
				{ return m_rowRect; }

	// Mouse stuff
	int 	TabFromPoint(CPoint pt);
	void	OnMouseMove(CPoint pt);
	void	OnLButtonUp(CPoint pt);
	void	OnTimer();
	void	Capture(int nDirection);
	BOOL	HasCapture()
	    		{ return m_nScrollState != SCROLL_NULL; }

	// Misc
	DWORD	GetTabDWord(int nTab)
				{ return GetTab(nTab)->m_dw; }
	LPCTSTR GetTabString(int nTab)
				{ return GetTab(nTab)->m_strCaption; }
	int 	MaxTab()
	    		{ return m_tabs.GetSize() - 1; }

private:
	void	DrawTab(CDC* pDC, int nTab, BOOL bCurTab);
	void	DrawScrollers(CDC* pDC);

	BOOL	CanScroll();
	void	SetFirstTab(int nTab);
	CTabRecord*	GetTab(int nTab)
				{ return (CTabRecord*)m_tabs[nTab]; }
	BOOL	IsTabVisible(int nTab, BOOL bPartials = TRUE);

	// Member variables
	CRect	m_rowRect;		// location of entire tab row within owning window
	CRect	m_scrollRect;	// location of scroll buttons
	int 	m_curTab;		// index of current selected tab
	int 	m_firstTab;		// index of leftmost visible tab
	BOOL	m_bHasFocus;	// whether tab row has the focus
	int 	m_nScrollState;	// shows whether left or right scroll btn is down
	BOOL	m_bScrollPause;	// if we have capture, has the mouse wandered off btn?

	CWnd*	m_pWndOwner;	// pointer to owning window (used for InvalidateRect)
	CObArray	m_tabs;		// list of CTabRecords, in order
};


////////////////////////////////////////////////////////////////////////////
// CTabbedDialog -- a tabbed "dialog" (really a popup-window)
class CLastTabMap : public CMapWordToOb
{
	public:
		~CLastTabMap();
		__inline void RememberTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	pStr = new CString;
			*pStr = strCaption; SetAt(wCaptionID, (CObject *&)pStr);
		}
		__inline BOOL LookupTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	return FALSE;
			strCaption = *pStr; return TRUE;
		}
};

class CTabbedDialog : public CWnd
{
// Construction
public:
	enum COMMIT_MODEL { commitOnOk, commitOnTheFly };
	enum FC { FC_THIS, FC_NEXT, FC_PREVIOUS, FC_FIRST };
	enum DLGPOSITION { POS_APPCENTER, POS_AVOIDBARS };

	CTabbedDialog(UINT nIDCaption, CWnd* pParentWnd = NULL,
			UINT iSelectTab = -1, COMMIT_MODEL = commitOnOk, DLGPOSITION pos=POS_APPCENTER);
	
	// Modeless operation
	BOOL Create();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Modal operation
	int DoModal();
	void EndDialog(int nEndID);


// Operations
public:
	virtual void OnOK();
	virtual void OnCancel();
	virtual void OnHelp();

	virtual void OnSelectTab(int nTab) {};

	void AddTab(CDlgTab* pDlgTab);
	// may return failure (FALSE) if the tabs cannot be
	// cleared (most likely because the current one
	// failed the validation check)
	BOOL ClearAllTabs();
	// nTab == -1 will de-select the current tab
	// and not re-select any other
	void SelectTab(int nTab, BOOL bGoToControl = FALSE);
	void SelectTab(const CString& strCaption, BOOL bGoToControl = FALSE);
	void SelectNextTab();
	void SelectPreviousTab();
	int GetTabCount() const
		{ return m_tabs.GetSize(); }
	void SetCaption( const char *szCaption )
		{ m_strCaption = szCaption; }
	int GetCurrentTab() const
		{ return m_nTabCur; }

	// PreTranslate processing
	BOOL MessageStolenByTabbedDialog(MSG* pMsg);
	void HandleTab(BOOL bShift, BOOL bControl);
	BOOL HandleAcceleratorKey(char ch);
	BOOL HandleTabRowKey(char ch);
	BOOL IsDone() { return m_nID != -1; }	// HACK:  This is to fix ClassWiz bug 14201

// Implementation
protected:
	CDlgTab* GetTab(int nTab) {return 0 <= nTab && nTab < GetTabCount() ? (CDlgTab*)m_tabs[nTab] : (CDlgTab *)NULL;}
	void DrawFocusRect();
	BOOL ActivateTab(int nTab, BOOL bGoToControl);
	void BuildTabItemList(CObList& list, CMapWordToOb& map, CWnd* pWndCur = NULL);
	CWnd* FindControl(CWnd* pWndGoal, CObList& list, FC fc = FC_NEXT);
	void SetFocusToControl(CWnd* pControl, CObList* list = NULL, BOOL bSetSel = TRUE);


	// Sizing
	CPoint GetDlgTabPos();
	virtual void GetTabSize(CRect& rect);
	virtual void GetMargins(CRect& rect);

	// Buttons
	BOOL IsButton(HWND hWnd);
	virtual void CreateButtons();
	virtual void GetButtonExtent(CSize& size);
	virtual void MoveButtons(int nLeft, int nCenter);
	virtual CButton* GetButtonFromIndex(int index);
	void SetDefButtonIndex(int index);

	enum {
		cyBottomMargin = 6,	// plus button height, of course
		duButtonWidth = 45,
		duButtonHeight = 14,
		duBetweenButtons = 6
	};

	CSize m_buttonSize;
	int   m_cxBetweenButtons;

	CObArray m_tabs;	// array of CDlgTab pointers
	int m_nTabCur;  	// which is the current tab
	//CWnd* m_pFocusWnd; // focus when we lost activation
	HWND m_hFocusWnd;	// focus when we lost activation
	CWnd* m_pParentWnd; // owner of the tabbed dialog
	int m_nID;      	// ID passed to EndDialog and returned from DoModal
	CString m_strCaption; // caption of the pseudo-dialog
	UINT nCaptionID;
	static CLastTabMap m_DialogMap;	// Used to remember the last used page in all tabbed dialogs
	COMMIT_MODEL	m_commitModel;
	DLGPOSITION m_position;

	CTabRow	m_tabRow;		// entire row of tabs at top of dialog

	CButton m_btnOk;
	CButton m_btnCancel;
 	int m_iDefBtnIndex;

	// Generated message map functions
	//{{AFX_MSG(CTabbedDialog)
	afx_msg void OnPaint();
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nTimerID);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnClose();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	virtual void OnContextMenu(CWnd* pWnd, CPoint point);
	virtual BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CTabbedDialog);
};

#define cxTabMargin		6	// margins between non-client and outlines
#define cyTabMargin		6	//                  ''

/////////////////////////////////////////////////////////////////////////////
// CAddFilesDialog

#include <prjapi.h>
#include <prjguid.h>

// Note: does not derive from CWnd.  Dialog is created through call to
// GetOpenFileName instead of the usual MFC process.

class CAddFilesDialog : public C3dFileDialog
{
public:
	CAddFilesDialog();
	CAddFilesDialog(IPkgProject *pProject, const CString &strFolderName);
	virtual ~CAddFilesDialog();
	virtual int DoModal();

	IPkgProject *GetProject() const { return(m_pProject); }

	static void ResetCurrentDir();

	CStringArray m_saFileNames;

protected:
	// Generated message map functions
	//{{AFX_MSG(CAddProjectDialog)
	virtual BOOL OnInitDialog();
	virtual BOOL OnFileNameOK();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP();

private:
	BOOL m_fSuccess;

	IPkgProject *m_pProject;
	CString m_strFolderName;

	const static UINT msgValidateFileMessage;
	static CDir c_dirInitial;
};

/////////////////////////////////////////////////////////////////////////////

extern void PreModalWindow();
extern void PostModalWindow();
        
#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// __DLGBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\filechng.h ===
//	REVIEW(DavidGa):  This needs to be drastically simplified and moved
//                    into shlsrvc.h.
//-----------------------------------------------------------------------------
//  filechng.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:    define the various supporting classes and the class CFileChange
//              for use in watching when files are touched or otherwise
//              modified.
//
//  Revision History:
//
//  []      14-Jan-1994 Dans    Created
//
//-----------------------------------------------------------------------------
#if !defined(_filechng_h) /* { */
#define _filechng_h

#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

typedef unsigned __int64	QWORD;
const unsigned				cIdleMsecs = 5000;
const unsigned				cIdleMsecsCumulative = 120 * 1000;

union FCFT {	// FileChange FileTime
	FILETIME	filetime;
	QWORD		qwFiletime;
	};

struct StatBuf {
	enum {	// file attributes, mimic long names from Win32 headers.
		fattrDir = FILE_ATTRIBUTE_DIRECTORY,
		fattrNormal = FILE_ATTRIBUTE_NORMAL,
		fattrReadOnly = FILE_ATTRIBUTE_READONLY,
		fattrSystem = FILE_ATTRIBUTE_SYSTEM,
		fattrHidden = FILE_ATTRIBUTE_HIDDEN,
		fattrArchive = FILE_ATTRIBUTE_ARCHIVE
		};

	void
	clear() {
		fcft.qwFiletime = cbFile = dwAttrs = 0;
		}

	StatBuf() {
		clear();
		}

	BOOL
	FGetFileInfo ( LPCTSTR szFile );

	FCFT	fcft;
	QWORD	cbFile;
	DWORD	dwAttrs;
	};

inline DWORD
FattrFileMask() {
	return 
		StatBuf::fattrNormal |
		StatBuf::fattrReadOnly |
		StatBuf::fattrSystem |
		StatBuf::fattrHidden |
		StatBuf::fattrArchive;

	}

// depends upon windows.h, afx.h, and afxcoll.h to be included

#if !defined (fTrue)
	#define fTrue   TRUE
#endif
#if !defined (fFalse)
	#define fFalse  FALSE
#endif

inline DWORD DwStdFileChange() {
	return
		FILE_NOTIFY_CHANGE_FILE_NAME |
		FILE_NOTIFY_CHANGE_ATTRIBUTES |
		FILE_NOTIFY_CHANGE_SIZE |
		FILE_NOTIFY_CHANGE_LAST_WRITE
		;
	}

union FCBits {  // File Change Bits, what really changed
	UINT        fAll;
	struct {
		UINT    fAttrs:1;
		UINT    fTime:1;
		UINT    fSize:1;
		UINT    fDel:1;
		UINT    fType:1;
		UINT	fDirDel:1;
		};
	};

//
// Callback function, called from secondary thread, cannot do SendMessage, must
//  use PostMessage or another form of IPC.
//
class FCItem;
typedef void (*PfnFCCallBack)( const FCItem *, DWORD dwUser );  // call back function
typedef void (*PfnAsyncReturn)( const FCItem * );
typedef void *		PV;

class FCItem {  // File Change Item
public:
	enum Op {   // File Change Operation
		opNull,
		opAdd,          // in, add file
		opDel,          // in, delete file
		opIgnore,       // in, ignore file (counting!)
		opUnignore,     // in, unignore file (counting!)
		opSyncFile,     // in, force file data to be synced to file system
		opQuit,         // in, tell thread to quit
		opFileChanged   // out, a file changed
		};

	CString     _strFileName;       // name of affected file
	Op          _op;                // what this all means
	BOOL        _fSilent;           // whether to update silently or not (changed by us!)
	StatBuf     _statNew;           // keeps the new info around
	FCBits      _fcb;
	PfnFCCallBack
				_pfnFCCallBack;		// The callback function
	BOOL		_fCallAlways;       // whether this callback function wants calling even when we
									// are ignoring the file.

	BOOL		_fAsyncReturn;		// async return code
	PfnAsyncReturn
				_pfnAsyncReturn;	// async callback with result
	PV			_pvUser1;			// async user info
	PV			_pvUser2;			// async user info

				FCItem() {
					_op = opNull;
					_fSilent = fFalse;
					_fcb.fAll = fFalse;
					_pfnFCCallBack = 0;
					_fCallAlways = fFalse;
					_fAsyncReturn = fFalse;
					_pfnAsyncReturn = 0;
					_pvUser1 = _pvUser2 = 0;
					}
	};

#pragma warning(disable:4097)
class   CSection : public CRITICAL_SECTION {
public:
	CSection() {
		::InitializeCriticalSection ( this );
		}
	~CSection() {
		::DeleteCriticalSection ( this );
		}
	void Enter() {
		::EnterCriticalSection ( this );
		}
	void Leave() {
		::LeaveCriticalSection ( this );
		}
	};
#pragma warning(default:4097)

// CTestableSection
//
// This is like a CSection but it supports an extra method FOwned(), which tests
// whether or not the current thread has entered (and not left) the critical section.
//
// This is a debugging facility only, so calls to FOwned() must always be in an
// ASSERT or equivalent.  In the ship version, a CTestableSection is the same as a
// CSection.
#ifndef _DEBUG

class CTestableSection : public CSection
{
};

#else	// _DEBUG

class   CTestableSection
{
private:
	CSection m_csBase;			// the "real" c.s. we are wrapping
	LONG m_cLocks;				// conceptually "inside" m_csBase

	DWORD m_idThread;			// thread identifier outside the base CSection
	CSection m_csIdThread;		// guards access to m_idThread
public:
	CTestableSection()
	{
		m_cLocks = 0;
		m_idThread = 0;
	}
	void Enter()
	{
		m_csBase.Enter();
		if (m_cLocks++ == 0)
		{
			// initialize m_idThread
			DWORD idThread = GetCurrentThreadId();

			m_csIdThread.Enter();
			m_idThread = idThread;
			m_csIdThread.Leave();
		}
	}
	void Leave() {
		ASSERT(m_cLocks > 0);	// underflow test
		if (--m_cLocks == 0)
		{
			// clear m_idThread
			m_csIdThread.Enter();
			m_idThread = 0;
			m_csIdThread.Leave();
		}
		m_csBase.Leave();
	}
	BOOL FOwned()
	{
		DWORD idThread = GetCurrentThreadId();

		m_csIdThread.Enter();
		BOOL fOwned = idThread == m_idThread;
		m_csIdThread.Leave();
		
		return fOwned;
	}
};

#endif	// _DEBUG

// ease-of-use of a critical section...
class CritSection {
	CSection *	pcs;
public:
	CritSection ( CSection & cs ) {
		cs.Enter();
		pcs = &cs;
		}
	~CritSection() {
		pcs->Leave();
		}
	};

// same as CritSection but for the "testable" variety
class CritSectionT {
	CTestableSection *	pcs;
public:
	CritSectionT ( CTestableSection & cs ) {
		cs.Enter();
		pcs = &cs;
		}
	~CritSectionT() {
		pcs->Leave();
		}
	};


typedef SECURITY_ATTRIBUTES     SA;
typedef SA *                    PSA;

class CW32Event {
	HANDLE  _hEvent;
public:
	CW32Event (
		BOOL    fInitialState = FALSE,  // not signalled
		BOOL    fManualReset = FALSE,   // auto reset on
		LPCTSTR szName = NULL,          // no name
		PSA     psa = NULL ) {          // std security

		_hEvent = CreateEvent ( psa, fManualReset, fInitialState, szName );
		}

	~CW32Event () {
		::CloseHandle ( _hEvent );
		}
	operator HANDLE() {
		return _hEvent;
		}

	BOOL    Set() {
		return ::SetEvent ( _hEvent );
		}
	BOOL    Pulse() {
		return ::PulseEvent ( _hEvent );
		}
	BOOL    Reset() {
		return ::ResetEvent ( _hEvent );
		}

	DWORD   Wait ( DWORD dwWait = INFINITE) {
		return ::WaitForSingleObject ( _hEvent, dwWait );
		}
	};

class CSafeMapStringToOb : public CMapStringToOb {  // &*#$% safe map, dtors called!
public:
	void RemoveAllAssoc() {
		POSITION    pos = GetStartPosition();
		CObject *   pObj;
		CString     str;

		while ( pos ) {
			GetNextAssoc ( pos, str, pObj );
			RemoveKey ( str );
			delete pObj;
			}
		}

	~CSafeMapStringToOb() {
		RemoveAllAssoc();
		}

	};

class CFileData : public CString {      // keep extra info about a file
	StatBuf     	_statBuf;
	unsigned        _cIgnore;
	BOOL    	    _fValid;
	CPtrList        _listPfnAlwaysCall;		// List of callbacks that are always called.
	CPtrList        _listPfnCallNotIgnore;	// List of callbacks only called if file changes
											// are not being ignored
	PfnFCCallBack _pfnSpecificIgnore;		// major HACK to tide us over for now (davidga)

public:
				CFileData ( const char * szFile ) : CString ( szFile ) {
					_cIgnore = 0;
					_pfnSpecificIgnore = NULL;
					FSetCachedStatBuf();
					}

	BOOL        FValid() { return _fValid; }

	void        Reinit() {
					_statBuf.clear();
					_fValid = FALSE;
					}

				CFileData() {
					_cIgnore = 0;
					Reinit();
					}

	BOOL        FGetCachedStatBuf ( StatBuf & statbuf ) {
					statbuf = _statBuf;
					return FValid();
					}

	BOOL        FSetCachedStatBuf () {
					_fValid = _statBuf.FGetFileInfo ( *this );
					return FValid();
					}

	BOOL        FSetCachedStatBuf ( StatBuf & statBuf) {
					_fValid = _statBuf.FGetFileInfo ( *this );
					statBuf = _statBuf;
					return FValid();
					}

	BOOL        FIgnore ( PfnFCCallBack pfn = NULL ) {
					ASSERT ( _cIgnore + 1 );  // must not wrap
					if( (_pfnSpecificIgnore != NULL) && (_pfnSpecificIgnore != pfn) )
					{
						ASSERT( pfn == NULL );		// can't specifically ignore two callbacks
						_pfnSpecificIgnore = NULL;
					}
					else
						_pfnSpecificIgnore = pfn;
					return (_cIgnore = max ( _cIgnore, _cIgnore + 1 ) );
					}

	BOOL        FUnignore( PfnFCCallBack pfn = NULL ) {
					ASSERT ( _cIgnore );      // must not wrap
					ASSERT( (pfn == NULL) || (pfn == _pfnSpecificIgnore) );
					if( (_cIgnore = min ( _cIgnore, _cIgnore - 1 )) == 0 )
						_pfnSpecificIgnore = NULL;
					return _cIgnore;
					}
	unsigned    CIgnores() {
					return _cIgnore;
					}

	BOOL		FSpecificIgnore() {
					// should not have specific ignore if cIgnore is 0
					ASSERT( (_cIgnore != 0) || (_pfnSpecificIgnore == NULL) );
					return _pfnSpecificIgnore != NULL;
					}

	void        DoCallAlways ( const FCItem * fc, DWORD dwUser ) {
					POSITION pos = _listPfnAlwaysCall.GetHeadPosition();
					while ( pos != NULL ) {
						PfnFCCallBack pfn = PfnFCCallBack(_listPfnAlwaysCall.GetNext(pos));
						(pfn)(fc, dwUser);
						}
					}

	void        DoCallIfNotIgnore ( const FCItem* fc, DWORD dwUser ) {
					POSITION pos = _listPfnCallNotIgnore.GetHeadPosition();
					while ( pos != NULL ) {
						PfnFCCallBack pfn = PfnFCCallBack(_listPfnCallNotIgnore.GetNext(pos));
						(pfn)(fc, dwUser);
						}
					}

	void        DoCallIfNotSpecificIgnore ( const FCItem* fc, DWORD dwUser ) {
					POSITION pos = _listPfnCallNotIgnore.GetHeadPosition();
					while ( pos != NULL ) {
						PfnFCCallBack pfn = PfnFCCallBack(_listPfnCallNotIgnore.GetNext(pos));
						if( pfn == _pfnSpecificIgnore )
							continue;
						(pfn)(fc, dwUser);
						}
					}

	void		MergeFileData ( CFileData * pfile ) {
					POSITION	pos = pfile->_listPfnAlwaysCall.GetHeadPosition();
					while ( pos ) {
						PfnFCCallBack pfn = PfnFCCallBack(pfile->_listPfnAlwaysCall.GetNext ( pos ) );
						if ( !_listPfnAlwaysCall.Find ( pfn ) ) {
							_listPfnAlwaysCall.AddTail ( pfn );
							}
						}

					pos = pfile->_listPfnCallNotIgnore.GetHeadPosition();
					while ( pos ) {
						PfnFCCallBack pfn = PfnFCCallBack(pfile->_listPfnCallNotIgnore.GetNext ( pos ) );
						if ( !_listPfnCallNotIgnore.Find ( pfn ) ) {
							_listPfnCallNotIgnore.AddTail ( pfn );
							}
						}
					}
					

	BOOL        FAddCallBack ( PfnFCCallBack pfn, BOOL fCallAlways = fFalse ) {
					CPtrList *	pList;

					if ( fCallAlways )
						pList = &_listPfnAlwaysCall;
					else
						pList = &_listPfnCallNotIgnore;

					if ( !pList->Find ( pfn ) ) {
						pList->AddTail ( pfn );
						return fTrue;
						}
					return fFalse;
					}

	BOOL        FDelCallBack ( PfnFCCallBack pfn ) {
					POSITION pos = _listPfnAlwaysCall.Find ( pfn );
					if ( pos ) {
						_listPfnAlwaysCall.RemoveAt ( pos );
						return fTrue;
						}
					pos = _listPfnCallNotIgnore.Find ( pfn );
					if ( pos ) {
						_listPfnCallNotIgnore.RemoveAt ( pos );
						return fTrue;
						}
					return fFalse;
					}

	UINT		CCallBacks() {
					return _listPfnAlwaysCall.GetCount() + _listPfnCallNotIgnore.GetCount();
					}

	BOOL        FLastCallBack() {
					return 1 == CCallBacks();
					}
	};

class CSafePFileDataList : public CPtrList {    // *&)*(*% safe list, dtors called!
public:
	DWORD   _dwAux;                 // some extra info (currently the index in the HtoStr)

	CSafePFileDataList() {
		_dwAux = 0;
		}
	~CSafePFileDataList() {
		while ( !IsEmpty() ) {
			CFileData * pstr = (CFileData *) GetHead();
			delete pstr;
			RemoveHead();
			}
		}
	};

//
// message to send has a FCItem * in lparam
//
#define WU_FILECHANGE   (WM_USER + 0x2112)

#define iHandleITC  0       // index of event that is our inter-thread comm event.
#define iHandleMax  MAXIMUM_WAIT_OBJECTS     // allows us watch iHandleMax - 1 directories
#define cDirMax     (iHandleMax - 1)

struct HtoStr {
	HANDLE      rgh[ iHandleMax ];
	CString *   rgpstr[ iHandleMax ];
	};

//
// templated queue for asynchronous calls
//
typedef unsigned	IDEL;

template <class T, class ARG_T>
class CQueue {

	CSection	_critSec;
	unsigned	_ielFront;
	unsigned	_ielBack;
	unsigned	_celAlloc;
	unsigned	_celQueued;
	IDEL		_idEl;
	T *			_rgel;

protected:
	
	unsigned
	celGrowTo() {
		// grow by 50% (multiply by 1.5)
		return _celAlloc + _celAlloc / 2 + 1;
		}
			
	BOOL
	grow();

	void
	advance ( unsigned & iel ) {
		iel = (iel + 1) % _celAlloc;
		}

	void
	init ( unsigned cInitial );
	

public:
	enum { cInitialDefault = 64 };

	CQueue() {
		init ( cInitialDefault );
		}
	CQueue ( unsigned cInitial ) {
		init ( cInitial ? cInitial : cInitialDefault );
		}
	~CQueue() {
		if ( _rgel ) {
			delete [] _rgel;
			}
		_rgel = 0;
		_celAlloc = _celQueued = _ielFront = _ielBack = 0;
		}

	BOOL
	get ( T &, IDEL & );

	BOOL
	put ( ARG_T, IDEL & );

	unsigned
	size() {
		CritSection	cs(_critSec);
		return _celQueued;
		}
	};



template <class T, class ARG_T>
BOOL CQueue<T, ARG_T>::get ( T & el, IDEL & idel ) {
	CritSection	cs(_critSec);
	BOOL		fRet = fFalse;

	if ( _celQueued ) {
		fRet = fTrue;
		el = _rgel[ _ielBack ];
		advance ( _ielBack );
		idel = _idEl - _celQueued;
		_celQueued--;
		}
	return fRet;
	}

template <class T, class ARG_T>
BOOL CQueue<T, ARG_T>::put ( ARG_T el, IDEL & idel ) {
	CritSection	cs(_critSec);
	BOOL		fRet = fFalse;

	if ( grow() ) {
		fRet = fTrue;
		_rgel[ _ielFront ] = el;
		advance ( _ielFront );
		_celQueued++;
		idel = ++_idEl;
		}
	return fRet;
	}

template <class T, class ARG_T>
BOOL CQueue<T, ARG_T>::grow() {
	// note that this routine does NOT gain the crit sec.  it relies
	// upon the caller to do so.
	BOOL	fRet = _celQueued < _celAlloc;

	if ( !fRet ) {
		// grow the array and remap the indices
		unsigned	celNew = celGrowTo();
		T *			rgelNew = new T[ celNew ];

		if ( rgelNew ) {
			fRet = fTrue;
			// copy over elements
			unsigned	iel;
			unsigned	ielNew = 0;
			unsigned	cel;
			for (
				iel = _ielBack, cel = _celQueued;
				cel != 0;
				advance(iel), cel--
				) {
				rgelNew[ ielNew++ ] = _rgel[ iel ];
				}
			delete [] _rgel;
			_rgel = rgelNew;
			_celAlloc = celNew;
			_ielBack = 0;
			_ielFront = _celQueued;
			}
		}
	return fRet;
	}

template <class T, class ARG_T>
void CQueue<T, ARG_T>::init ( unsigned cel ) {
	_celAlloc = _celQueued = _ielFront = _ielBack = _idEl = 0;
	_rgel = new T[ cel ];
	if ( _rgel ) {
		_celAlloc = cel;
		}
	}


//
// main work horse of the file change system
//

class CFileChange {

public:
	CFileChange();
	~CFileChange();
	
	BOOL
	FInit ( DWORD dwUser = 0 );

	void
	Terminate();                                        // close things down (still
														//  can be re-initialized)
	// add a file to be watched
	BOOL
	FAddFile ( LPCTSTR szFile, PfnFCCallBack pfn, BOOL fCallAlways = fFalse );
	
	// remove a file from the list
	BOOL
	FDelFile ( LPCTSTR szFile, PfnFCCallBack pfn );
	
	// sync data to file system
	BOOL
	FSyncFile ( LPCTSTR szFile );
	
	// ignore changes to this file
	BOOL FIgnoreFile ( LPCTSTR szFile, BOOL fIgnore = fTrue, 
		PfnFCCallBack pfn = NULL );

	// async add file, returns true if queued successfully
	BOOL
	FAddFileAsync (
		LPCTSTR	szFile,
		PfnFCCallBack,
		PfnAsyncReturn,
		PV pvUser1 = NULL,
		PV pvUser2 = NULL,
		BOOL fCallAlways = fFalse
		);

	// async del file, returns true if queued successfully
	BOOL
	FDelFileAsync (
		LPCTSTR szFile,
		PfnFCCallBack,
		PfnAsyncReturn,
		PV pvUser1 = NULL,
		PV pvUser2 = NULL
		);

	// set the priority of the thread to normal or idle, returns
	// the count of idle requests
	unsigned
	SetIdleMode ( BOOL fIdle );

protected:
	// 2nd thread entry point, always pass in a CFileChange*
	static UINT
	ThreadEntry ( void * );

	// our call back for making the synchronous calls out of an async api
	static void
	SyncCallback ( const FCItem * );

	// where the 2nd thread spends most of its time
	void
	WaitAndHandleIt();

	// handle the requests in 2nd thread
	BOOL
	FThreadDoRequest();
	
	// handle add file in 2nd thread
	BOOL
	FThreadAddFile ( FCItem & );

	// handle del file in 2nd thread
	BOOL
	FThreadDelFile ( FCItem & );
	
	// handle ignore file in 2nd thread
	BOOL
	FThreadIgnoreFile ( FCItem & );
	
	// handle sync file in 2nd thread
	BOOL
	FThreadSyncFile ( FCItem & );
	
	// check a file for a change and send notification
	void
	DoCheckFile ( CFileData * pFileData );
	
	// handle the file change event in 2nd thread
	void
	DoFileChange ( unsigned iHandle );
	
	// delete a whole directory entry
	void
	ThreadDeleteDirectory ( unsigned iHandle );

	void
	ThreadCleanup();

	// used by 2nd thread to return vals
	void
	ThreadReturn ( BOOL f ) {
		_fThreadRetCode = f;
		_eventOut.Set();
		}

	// used by 1st thread to call 2nd thread to do something
	BOOL
	ThreadCall ( LPCTSTR szFile, PfnFCCallBack pfn, FCItem::Op op, BOOL fCallAlways = TRUE );

	// utility function to search for filelists and filedata
	//  returns partial info
	BOOL
	FFilelistEtcFromFilename (
		LPCTSTR                 szFilename,
		CSafePFileDataList * &  pFilelist,
		CFileData * &           pFiledata,
		POSITION &              pos
		);

	// function to tell us how much time to wait in WaitForMultipleObjects...
	DWORD
	DwTimeout() {
		if ( !_cIdles && _listPFileDataEx.IsEmpty() ) {
			return INFINITE;
			}
		else {
			// we timeout every 5 seconds for the manual detect
			// cases on the overflow files or while idling.
			return cIdleMsecs;
			}
		}

	// check all the files in the overspill list
	void
	DoCheckOverspillFiles();

	// add file to overspill list returns fFalse if file already in list
	BOOL
	FAddOverspillFile ( CFileData * );

	// check to see if a file is already in the list, returning the CFileData *
	CFileData *
	PFileDataOverspill ( LPCTSTR szFile, POSITION & pos );

	// delete a file from the overspill list
	void
	DeleteOverspillFile ( CFileData * );

	void
	BoostPriority();

	void
	RestorePriority();

private:
	DWORD               _fThreadRunning;    // used as a flag, but contains thread id
	HANDLE              _hThread;           // handle to the thread we create.
	FCItem				_fcitemThread;		// for our synchronous calls
	CW32Event           _eventIn;           // our inter-thread event
	CW32Event           _eventOut;          // our inter-thread event for sync calls
	BOOL                _fThreadRetCode;    // thread return code
	CSection            _critSection;       // critical section for accessing lists
	CSafeMapStringToOb  _mpDirsFilelist;    // map the directories to file lists
	DWORD               _dwUser;
	HtoStr              _hts;               // array of handles to events to wait on
	CSafePFileDataList	_listPFileDataEx;	// handle the overspill when/if we run out
											// of directory handles that we can watch
											// (currently WaitForMultipleObjects has
											// the limit of 64) or on Chicago where
											// ABSOLUTELY NONE of the file change
											// notifications work.

	CSection			_critsecCall;		// used to serialize calls to the filechange thread
	CQueue<FCItem, FCItem&>
						_queueFCItem;		// queue for async calls
	unsigned			_cIdles;			// count of idle requests
	unsigned			_cBoosts;			// count of priority boosts
	CSection			_critsecPrty;		// serialize access to the idle/priority setting
	BOOL				_fDupThreadHandle;	// Do we have a duplicated thread handle.

	enum {
		prtyIdle = THREAD_PRIORITY_IDLE,
		prtyLowest = THREAD_PRIORITY_LOWEST,
		prtyBelowNormal = THREAD_PRIORITY_BELOW_NORMAL,
		prtyNormal = THREAD_PRIORITY_NORMAL,
		prtyAboveNormal = THREAD_PRIORITY_ABOVE_NORMAL,
		prtyStandard = prtyBelowNormal		// priority we normally run at, one tick below main thread
		};
	};

CFileChange * GetFileChange();

// CIgnoreFile...used as an object to automatically ignore changes to
// a file while doing something with it.  Automatically unignores
// when object is destroyed.
//
class CIgnoreFile {
	CFileChange *	_pfc;
	_TCHAR			_szFile[ _MAX_PATH ];
	BOOL			_fIgnoreSuccess;
	PfnFCCallBack	_pfnSpecificIgnore;
	
	// private default ctor--must use parametered version
	CIgnoreFile();

public:
	CIgnoreFile ( CFileChange * pfc, LPCTSTR sz, PfnFCCallBack pfn = NULL ) {
		_tcsncpy ( _szFile, sz, _MAX_PATH );
		_szFile[ _MAX_PATH - 1 ] = 0;
		_pfc = pfc;
		_pfnSpecificIgnore = pfn;
		_fIgnoreSuccess = pfc->FIgnoreFile ( _szFile, fTrue, _pfnSpecificIgnore );
		}
	~CIgnoreFile() {
		if ( _fIgnoreSuccess )
			_pfc->FIgnoreFile ( _szFile, fFalse, _pfnSpecificIgnore );
		}
	};

#endif /* } */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\msf.h ===
// msf.h: see "The Multistream File API" for more information

#ifndef __MSF__H
#define __MSF__H

#ifndef TRUE

#define TRUE	1
#define FALSE	0
typedef int BOOL;

#ifdef _DEBUG
#define verify(x)	assert(x)
#else
#define verify(x) (x)
#endif

#endif

typedef unsigned short	SN;		// stream number
typedef long			CB;	

#ifdef MSF_PAGE_SIZE
#define cbPg	MSF_PAGE_SIZE
#else
#define cbPg	4096
#endif

#ifndef cbNil
#define cbNil	((CB)-1)
#endif
#define snNil	((SN)-1)

#if defined(__cplusplus)
extern "C" {
#endif

// MSFOpen		-- open MSF; return MSF* or NULL if error.  Create a temp msf if 
//			   supplied name is null.
// MSFGetCbStream	-- return size of stream or -1 if stream does not exist
// MSFReadStream	-- read stream into pvBuf; return TRUE if successful
// MSFWriteStream	-- overwrite stream with pvBuf; return TRUE if successful
// MSFCommit		-- commit all pending changes; return TRUE if successful
// MSFPack		-- pack MSF on disk; return TRUE if successful
// MSFClose		-- close MSF; return TRUE if successful
// MSFCreateCopy	-- create a new MSF with the same contents.
#define MSF_EXPORT 

class MSF;
MSF_EXPORT MSF*	MSFOpen(const char *name, BOOL fWrite);
MSF_EXPORT CB	MSFGetCbStream(MSF* pmsf, SN sn);
MSF_EXPORT BOOL	MSFReadStream(MSF* pmsf, SN sn, void* pvBuf, long cbBuf);
MSF_EXPORT BOOL	MSFWriteStream(MSF* pmsf, SN sn, void* pvBuf, long cbBuf);
MSF_EXPORT BOOL	MSFCommit(MSF* pmsf);
MSF_EXPORT BOOL	MSFPack(MSF* pmsf);
MSF_EXPORT BOOL	MSFClose(MSF* pmsf);
MSF_EXPORT MSF*	MSFCreateCopy (MSF* pmsf,const char *pCopyName);
#if defined(__cplusplus)
};
#endif

#endif // __MSF__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\ids.h ===
/////////////////////////////////////////////////////////////////////////////
//  IDS.H
//      Header files containing all shared ID spaces.  These are 16 or 32-bit
//      IDs which used by packages with no methodology to guarantee uniqueness
//      other than ID or range allocation.

#ifndef __IDS_H__
#define __IDS_H__

//  Contains:
//      Package IDs
//      Resource and string ID ranges
//      Command ID ranges
//      Status Bar Indicator IDs
//      Command group IDs
//      Help IDs
//      Package notification IDs.   *Fix for v5.0*
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Package IDs

#define PACKAGE_SUSHI            1   // DEVSHL Must be first
#define PACKAGE_VCPP             2   // DEVSRC
#define PACKAGE_VRES             3   // DEVRES
#define PACKAGE_VPROJ            4   // DEVBLD
#define PACKAGE_PRJSYS           5   // DEVPRJ
#define PACKAGE_MSIN             6   // DEVMSIN
#define PACKAGE_LANGCPP          7   // DEVCPP
#define PACKAGE_LANGFOR          8   // DEVFOR
#define PACKAGE_GALLERY         10   // DEVGAL
#define PACKAGE_LANGMST         11   // DEVTEST
#define PACKAGE_CLASSVIEW       12   // DEVCLS
#define PACKAGE_ENT             13   // DEVENT
#define PACKAGE_LANGHTML        14
#define PACKAGE_BIN             15   // DEVBIN
#define PACKAGE_IMG             16   // DEVIMG
#define PACKAGE_NUMEGA          17
#define PACKAGE_HTMLEX          18   // DEVHTMX
#define PACKAGE_IATOOL          19  // Interactive Authoring Tool Package
#define PACKAGE_NCB             20
#define PACKAGE_IST             21  // Internet Studio
#define PACKAGE_LANGJVA         22  // Java Language Package
#define PACKAGE_JVA             23  // Java Build Package 
#define PACKAGE_AUT1            24   // DEVAUT1
#define PACKAGE_DEBUG           25   // DEVDBG
#define PACKAGE_ODL             26   // DEVODL.PKG
#define PACKAGE_AUT2            27   // DEVAUT2
#define PACKAGE_HTM             28   // DEVHTM
#define PACKAGE_DTG             29   // DEVDTG
#define PACKAGE_DDK             30   // DEVDDK
#define PACKAGE_IV              31   // DEVIV (eventual replacement for devmsin)

#define PACKAGE_ESPRESSO_PRJ    51
#define PACKAGE_ESPRESSO_RESTBL 52

#define PACKAGE_PARTNER        100   // Package wizard initial ID.
#define PACKAGE_SIMPLE         101   // DEVPKG (Sample package)

// Package Partners package IDs
#define PACKAGE_BLUESKY        102
#define PACKAGE_RST            103
#define PACKAGE_RATIONAL       104
#define PACKAGE_STINGRAY       105
#define PACKAGE_NUMEGA2		   106
#define PACKAGE_NUMEGA3		   107

#define PACKET_NIL      UINT(-1)    // For dockable windows with no command ui.

// This is for internal use by the system only
#define PACKET_SHARED   UINT(-2)    // the command is shared by more than one packet

// REVIEW(davidga): move these into Espresso?
// Packet IDs for Espresso
//
#define RESTBL_PACKET           2
#define PROJECT_PACKET          3

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Resource and string ID ranges
//

//  Sample Package
#define MIN_SAMPLE_RESOURCE_ID     0        // 0000
#define MAX_SAMPLE_RESOURCE_ID   399        // 018f
//  Espresso
#define MIN_ESPRESSO_RESOURCE_ID 12000       // 2EE0
#define MAX_ESPRESSO_RESOURCE_ID 12999       // 32C7
//  Test
#define MIN_TEST_RESOURCE_ID    2000        // 07d0
#define MAX_TEST_RESOURCE_ID    2991        // 0baf
//  Fortran
#define MIN_FORTRAN_RESOURCE_ID 2992        // 0bb0
#define MAX_FORTRAN_RESOURCE_ID 3999        // 0f9f
//  Intel x86 for Fortran
#define MIN_X86FOR_RESOURCE_ID  4000        // 0fa0
#define MAX_X86FOR_RESOURCE_ID  4999        // 1387

// SPACE 5000-5999  (0x1388 - 0x176f)

//  Package Partner Package (define one min/max set per partner--0x200 IDs)
//  Partners use 'PARTNER' IDs until a specific range is established for them.
#define MIN_PARTNER_RESOURCE_ID 6000        // 1770
#define MAX_PARTNER_RESOURCE_ID 6495        // 195f
// IATOOL (Interactive Authoring Tool Package)
#define MIN_IATOOL_RESOURCE_ID  6496        // 1960
#define MAX_IATOOL_RESOURCE_ID  6687        // 101f
// IST  (Internet Studio) 
#define MIN_IST_RESOURCE_ID     6688        // 1a20
#define MAX_IST_RESOURCE_ID     6895        // 1aef
// LANGJVA  (Java Language package)
#define MIN_LANGJVA_RESOURCE_ID 6896        // 1af0
#define MAX_LANGJVA_RESOURCE_ID 6959        // 1b2f
// JVA  (Java Build Package)
#define MIN_JVA_RESOURCE_ID     6960        // 1b30
#define MAX_JVA_RESOURCE_ID     7023        // 1b6f
// HTMLEX (HTML lexer)
#define MIN_HTMLEX_RESOURCE_ID  7024        // 1b70 
#define MAX_HTMLEX_RESOURCE_ID  7039        // 1b7f
// DEVAUT1 (OLE Automation 1)
#define MIN_AUT1_RESOURCE_ID    7040        // 1b80 
#define MAX_AUT1_RESOURCE_ID    7535        // 1d6f
// DEVAUT2 (OLE Automation 2)
#define MIN_AUT2_RESOURCE_ID    7536        // 1d70 
#define MAX_AUT2_RESOURCE_ID    7631        // 1dcf
// DEVHTM
#define MIN_HTM_RESOURCE_ID     7632        // 1dd0 
#define MAX_HTM_RESOURCE_ID     7679        // 1dff
// DEVDTG
#define MIN_DTG_RESOURCE_ID     7680        // 1e00 
#define MAX_DTG_RESOURCE_ID     7759        // 1e4f
// DEVDDK
#define MIN_DDK_RESOURCE_ID     7760        // 1e50 
#define MAX_DDK_RESOURCE_ID     7807        // 1e7f

//  SPACE 7776-9999  (0x1e60 - 0x270f)

// Helpstring IDs (intentionally not contiguous to allow neighbors room
//  to grow)--stored in DEVBLD.PKG, DEVEDIT.PKG, DEVSHL.DLL, DEVDBG.PKG, etc
// These IDs are shared by packages exposing a type library.  Each such package
//  stores its helpstrings in its string table, with IDs in this range.
//  Multiple packages reuse this range, but conflict isn't a problem, since
//  the helpstrings are loaded (by DevTLDc.dll) explicitly from the package.
// Strings shared across type libraries (e.g., helpstring for Application
//  properties) are stored in DevTLDc.dll's string table, with IDs in the range
//  between MIN_SHARED_HELPSTRING_ID and MAX_SHARED_HELPSTRING_ID (see below).
//  This range must not conflict with the SHARED_HELPSTRING_ID range.
#define MIN_HELPSTRING_ID               10000           // 0x2710
#define MAX_HELPSTRING_ID               11000           // 0x2af8

//  NuMega Package
#define MIN_NUMEGA_RESOURCE_ID    11001       // 2af9
#define MAX_NUMEGA_RESOURCE_ID    12500       // 30d4
//  BlueSky Package
#define MIN_BLUESKY_RESOURCE_ID   12501       // 30d5
#define MAX_BLUESKY_RESOURCE_ID   13500       // 34bc
//  Rational Package
#define MIN_RATIONAL_RESOURCE_ID  13501       // 34bd
#define MAX_RATIONAL_RESOURCE_ID  14500       // 38a4
// StingRay Package
#define MIN_STINGRAY_RESOURCE_ID  14501       // 38a5
#define MAX_STINGRAY_RESOURCE_ID  15200       // 3b60
// RST Package
#define MIN_RST_RESOURCE_ID       15201       // 3b61
#define MAX_RST_RESOURCE_ID       15583       // 3cdf

//  PowerPC
#define MIN_POWERPC_RESOURCE_ID 15584       // 3ce0
#define MAX_POWERPC_RESOURCE_ID 15615       // 3cff
//  PowerMac
#define MIN_POWERMAC_RESOURCE_ID    15616   // 3d00
#define MAX_POWERMAC_RESOURCE_ID    15711   // 3d5f
//  Mips
#define MIN_MIPS_RESOURCE_ID    15712       // 3d60
#define MAX_MIPS_RESOURCE_ID    15775       // 3d9f
//  Alpha
#define MIN_ALPHA_RESOURCE_ID   15776       // 3da0
#define MAX_ALPHA_RESOURCE_ID   15839       // 3ddf
//  Mac68K
#define MIN_68K_RESOURCE_ID     15840       // 3de0
#define MAX_68K_RESOURCE_ID     15919       // 3e2f
//  Intel x86
#define MIN_X86_RESOURCE_ID     15920       // 3e30
#define MAX_X86_RESOURCE_ID     15999       // 3e7f
//  Build package
#define MIN_BUILD_RESOURCE_ID   16000       // 3e80
#define MAX_BUILD_RESOURCE_ID   16991       // 425f
// App wizard
#define MIN_APP_WIZARD_ID       16992       // 4260
#define MAX_APP_WIZARD_ID       17487       // 444f
// Class wizard
#define MIN_CLASS_WIZARD_ID     17488       // 4450
#define MAX_CLASS_WIZARD_ID     17999       // 464f

#define MIN_NUMEGA2_ID			18000		// 4650
#define MAX_NUMEGA2_ID			19999		// 4e1f

//  Shell
#define MIN_SHARED_RESOURCE_ID  20000       // 4e20
#define MAX_SHARED_RESOURCE_ID  20207       // 4eef
#define MIN_EXE_RESOURCE_ID     20208       // 4f00
#define MAX_EXE_RESOURCE_ID     20287       // 4f3f
#define MIN_EXE_STRING_ID       57344               // e000
#define MAX_EXE_STRING_ID       57359               // e00f
#define MIN_SHELL_RESOURCE_ID   20288       // 4f40
#define MAX_SHELL_RESOURCE_ID   21999       // 55ef

//  Object Gallery
#define MIN_GALLERY_RESOURCE_ID 22000       // 55f0
#define MAX_GALLERY_RESOURCE_ID 22495       // 57df
// HTML
#define MIN_HTML_RESOURCE_ID    22496       // 57e0
#define MAX_HTML_RESOURCE_ID    22591       // 583f

//  SPACE 22592-22991  (0x5840 - 0x59ef)

//  Debug
#define MIN_DEBUG_RESOURCE_ID   24000       // 5dc0
#define MAX_DEBUG_RESOURCE_ID   25951       // 655f
//  CPP LangPackage
#define MIN_CPP_RESOURCE_ID     25952       // 6560
#define MAX_CPP_RESOURCE_ID     25999       // 658f
//  Resource package
#define MIN_RES_RESOURCE_ID     26000       // 6590
#define MAX_RES_RESOURCE_ID     27951       // 6d2f
//  BIN (Binary Editor)
#define MIN_BIN_RESOURCE_ID     27952       // 6d30
#define MAX_BIN_RESOURCE_ID     27967       // 6d3f
//  IMG (Image Editor)
#define MIN_IMG_RESOURCE_ID     27968       // 6d40
#define MAX_IMG_RESOURCE_ID     27999       // 6d5f
//  Edit package
#define MIN_EDIT_RESOURCE_ID    28000       // 6d60
#define MAX_EDIT_RESOURCE_ID    28527       // 6f6f
//  Odl package
#define MIN_ODL_RESOURCE_ID     28528       // 6f70
#define MAX_ODL_RESOURCE_ID     28591       // 6faf

//  SPACE 28591-28991  (0x6faf - 0x713f)

//  MSIN
#define MIN_MSIN_RESOURCE_ID    28992       // 7140
#define MAX_MSIN_RESOURCE_ID    29999       // 752f

//  IV
#define MIN_IV_RESOURCE_ID      30000       // 7530
#define MAX_IV_RESOURCE_ID      30499       // 7723

//  SPACE 30500-30992

//  Proj
#define MIN_WORKSPACE_RESOURCE_ID   30992   // 7910
#define MAX_WORKSPACE_RESOURCE_ID   31999   // 7cff
//  ClsView
#define MIN_CLSVIEW_RESOURCE_ID 32000       // 7d00
#define MAX_CLSVIEW_RESOURCE_ID 32095       // 7d5f
//  ENT (Galileo)  
#define MIN_ENT_RESOURCE_ID     32096       // 7d60
#define MAX_ENT_RESOURCE_ID     32511       // 7eff
// NCB (No Compile Browser)  
#define MIN_NCB_RESOURCE_ID     32512       // 7f00
#define MAX_NCB_RESOURCE_ID     32543       // 7f1f

//  String IDs  (Range 32k to 64k) 
//  These ranges can ONLY be used by string resource types

// IV (InfoViewer)
#define MIN_IV_STRING_ID        30200               // 75f8
#define MAX_IV_STRING_ID        30326               // 7676

//  HTMLEX (HTML Lexer)
#define MIN_HTMLEX_STRING_ID    32768               // 8000
#define MAX_HTMLEX_STRING_ID    32831               // 803f
// NCB (No Compile Browser)
#define MIN_NCB_STRING_ID       32832               // 8040
#define MAX_NCB_STRING_ID       32895               // 807f
//  IATool (Interactive Authoring Tool Package)
#define MIN_IATOOL_STRING_ID    32896               // 8080
#define MAX_IATOOL_STRING_ID    33951               // 849f

// SPACE 33952 - 34463 (84a0 - 869f)

// LANGJVA (Java Language Package)
#define MIN_LANGJVA_STRING_ID   34464               // 86a0
#define MAX_LANGJVA_STRING_ID   34671               // 876f
//  Odl package
#define MIN_ODL_STRING_ID       34672               // 8770
#define MAX_ODL_STRING_ID       34719               // 879f

//  SPACE 34719-35007  (0x879f - 0x88bf)

// CLASSVIEW
#define MIN_CLASSVIEW_STRING_ID 35008               // 88c0
#define MAX_CLASSVIEW_STRING_ID 35103               // 891f
// HTM
#define MIN_HTM_STRING_ID       35104               // 8920
#define MAX_HTM_STRING_ID       35295               // 89df
// DTG
#define MIN_DTG_STRING_ID       35296               // 89e0
#define MAX_DTG_STRING_ID       35839               // 8bff
// DDK
#define MIN_DDK_STRING_ID       35840               // 8c00
#define MAX_DDK_STRING_ID       35935               // 8c5f
// POWERPC
#define MIN_POWERPC_STRING_ID   35936               // 8c60
#define MAX_POWERPC_STRING_ID   35999               // 8c9f
// LANGCPP
#define MIN_LANGCPP_STRING_ID   36000               // 8ca0
#define MAX_LANGCPP_STRING_ID   36255               // 8d9f
// IST  (Internet Studio) 
#define MIN_IST_STRING_ID       36256               // 8dA0
#define MAX_IST_STRING_ID       37503               // 927F

//  NuMega Package
#define MIN_NUMEGA_STRING_ID    37632               // 9300
#define MAX_NUMEGA_STRING_ID    37887               // 93ff
//  BlueSky Package
#define MIN_BLUESKY_STRING_ID   37888               // 9400
#define MAX_BLUESKY_STRING_ID   38143               // 94ff
//  Rational Package
#define MIN_RATIONAL_STRING_ID  38144               // 9500
#define MAX_RATIONAL_STRING_ID  38399               // 95ff
// StingRay Package
#define MIN_STINGRAY_STRING_ID  38400               // 9600
#define MAX_STINGRAY_STRING_ID  38655               // 96ff
// RST Package
#define MIN_RST_STRING_ID       38656               // 9700
#define MAX_RST_STRING_ID       38911               // 97ff

// NUMEGA2 
#define MIN_NUMEGA2_STRING_ID	38912				// 9800
#define MAX_NUMEGA2_STRING_ID	41216				// a100

/////////////////////////////////////////////////////////////////////////////
// Shared resource IDs
//

// resource type ids
// The numbering of these types has been modified to fit with the 
// shared resource numbering scheme. This allows any package
// to use its own resource types in safety. martynl 13May96

// This one is used in entry.rc and the shell package for the default UI layout
#define IDRT_LAYOUT          20000
// Used in various packages (*.rc2 files) to store their encrypted package id information
#define IDRT_PID             20001

// The actual product ID resource number
#define ID_PID               20000

// command table stored in the main executable file
#define IDCT_MAINEXE                    20397

// Dialog controls
#define IDC_CAPTION                     102
#define IDC_ID_CAP                      221
#define IDC_ID                          222
#define IDC_SCC_STATUS                  16830
#define IDC_SCC_STATUS_TEXT             16831

#define IDC_SCC                         21094
#define IDC_SCC_HELPERTEXT              21101
#define IDC_SCC_SEPARATOR               21102

// Resources
#define IDC_CURSOR_RECORD               7066    // Stored in DevAut1.pkg
#define IDR_MAINFRAME                   20000
#define IDR_FIND_SPECIAL                21093 // stored in devshl.dll

#define IDB_VC256                       20001
#define IDB_VC16                        20002
#define IDB_ABOUT                       20003

#define IDB_DROP                        20508
#define IDB_DROP95                      21086
#define IDB_DROPLARGE                   21182
#define IDB_DROP95LARGE                 21183

#define IDB_DROPFLAT                    21200
#define IDB_DROP95FLAT                  21201
#define IDB_DROP95LARGEFLAT             21204
#define IDB_DROPLARGEFLAT               21205

#define IDB_DROPCL                      20544
#define IDB_DROPCL95                    21083
#define IDB_DROPCLLARGE                 21184
#define IDB_DROPCL95LARGE               21185

#define IDB_DROPCR                      20545
#define IDB_DROPCR95                    21084
#define IDB_DROPCRLARGE                 21186
#define IDB_DROPCR95LARGE               21187

#define IDB_DROPDISABLED                20547
#define IDB_DROPDISABLED95              21085
#define IDB_DROPDISABLEDLARGE           21188
#define IDB_DROPDISABLED95LARGE         21189

#define IDC_RIGHT_ARROW                 20001
#define IDC_SIZE_BAR_HORZ               20002
#define IDCUR_VSIZE                     20003
#define IDCUR_COPY                      20004

#define IDD_ABOUTBOX                    20001
#define IDD_GOTODIALOG                  20002
#define IDD_PUSHPIN_DIALOGBAR           20003
#define IDD_SUSHI_FILEOPEN              20522
#define IDD_OPTIONS_FONTCOLOR           21080

// Strings
#define IDS_DEBUG_CONFIG                20001
#define IDS_RELEASE_CONFIG              20002
#define IDS_UNDO_PROPEDIT               20003
#define IDS_UNDO_MOVE                   20004
#define IDS_UNDO_COPY                   20005
#define IDS_UNDO_PASTE                  20006
#define IDS_UNDO_CUT                    20007
#define IDS_UNDO_DELETE                 20008
#define IDS_ABOUTTITLE                  20009
#define IDS_COPYRIGHT                   20010
#define IDS_PRODUCTLICENSEDTO           20011
#define IDS_SERIALNUMBER                20012
#define IDS_ADDITIONS                   20013
#define IDS_PID                         20014
#define IDS_WARNING1                    20015
#define IDS_WARNING2                    20016
#define IDS_WARNING3                    20017
#define IDS_WARNING4                    20018
#define IDS_WARNING5                    20019
#define IDS_WARNING6                    20020
#define IDS_WARNING7                    20021
#define IDS_NOMATHCHIP                  20022
#define IDS_HASMATHCHIP                 20023
#define IDS_FMTFREESPACE                20024
#define IDS_UNAVAILABLE                 20025
#define IDS_FMTAVAILMEM                 20026
#define IDS_CANT_LOAD_PACKAGE           20027
#define IDS_CANT_LOAD_MAC               20028
#define IDS_LICENSEDTO                  20029
#define IDS_GENERAL                     20030
#define IDS_STYLES                      20031
#define IDS_EXSTYLES                    20032
#define IDS_UNNAMED                     20033
#define IDS_ABOUTTITLEPADDING           20034
#define IDS_DSPROJ_SIG_STRING           20035
#define IDS_PACKAGE_OWNER               20036
#define IDS_KEYBOARD                    20037
#define IDS_COMMANDS                    20038
#define IDS_DSPROJ_NAME                 20039

// Shared Help String Context IDs--strings stored in DEVTLDC.DLL
// These are IDs used in the string table of DevTLDc.dll and are referenced
//  by type libraries via helpstringcontext attribute.  These strings are
//  NOT stored in devshl.dll-- they're in DevTLDc.dll.  As long as these IDs
//  don't collide with the HELPSTRING_ID range (see above) no conflicts can
//  arise.
#define MIN_SHARED_HELPSTRING_ID                1000
#define MAX_SHARED_HELPSTRING_ID                2000
// The following strings are all between the above two ranges.

// Misc. Shared help strings.
#define MIN_HS_SHARED                                                   MIN_SHARED_HELPSTRING_ID
#define IDS_HS_SHARED_APPLICATION                               MIN_HS_SHARED
#define IDS_HS_SHARED_PARENT                                    (IDS_HS_SHARED_APPLICATION+1)
#define MAX_HS_SHARED                                                   (IDS_HS_SHARED_PARENT+1)

// Help strings for IGenericDocument.
#define IDS_HS_GENERICDOCUMENT                                  MAX_HS_SHARED
#define IDS_HS_GENERICDOCUMENT_NAME                             (IDS_HS_GENERICDOCUMENT+1)
#define IDS_HS_GENERICDOCUMENT_FULLNAME                 (IDS_HS_GENERICDOCUMENT+2)
#define IDS_HS_GENERICDOCUMENT_PATH                             (IDS_HS_GENERICDOCUMENT+3)
#define IDS_HS_GENERICDOCUMENT_SAVED                    (IDS_HS_GENERICDOCUMENT+4)
#define IDS_HS_GENERICDOCUMENT_ACTIVEWINDOW             (IDS_HS_GENERICDOCUMENT+5)
#define IDS_HS_GENERICDOCUMENT_READONLY                 (IDS_HS_GENERICDOCUMENT+6)
#define IDS_HS_GENERICDOCUMENT_TYPE                             (IDS_HS_GENERICDOCUMENT+7)
#define IDS_HS_GENERICDOCUMENT_WINDOWS                  (IDS_HS_GENERICDOCUMENT+8)
#define IDS_HS_GENERICDOCUMENT_NEWWINDOW                (IDS_HS_GENERICDOCUMENT+9)
#define IDS_HS_GENERICDOCUMENT_SAVE                             (IDS_HS_GENERICDOCUMENT+10)
#define IDS_HS_GENERICDOCUMENT_CLOSE                    (IDS_HS_GENERICDOCUMENT+11)
#define IDS_HS_GENERICDOCUMENT_UNDO                             (IDS_HS_GENERICDOCUMENT+12)
#define IDS_HS_GENERICDOCUMENT_REDO                             (IDS_HS_GENERICDOCUMENT+13)
#define IDS_HS_GENERICDOCUMENT_PRINTOUT                 (IDS_HS_GENERICDOCUMENT+14)
#define IDS_HS_GENERICDOCUMENT_ACTIVE                   (IDS_HS_GENERICDOCUMENT+15)
#define IDS_HS_GENERICDOCUMENT_max                              (IDS_HS_GENERICDOCUMENT+17)

// Help strings for IGenericWindow
#define IDS_HS_GENERICWINDOW                                    IDS_HS_GENERICDOCUMENT_max
#define IDS_HS_GENERICWINDOW_CAPTION                    (IDS_HS_GENERICWINDOW+1)
#define IDS_HS_GENERICWINDOW_TYPE                               (IDS_HS_GENERICWINDOW+2)
#define IDS_HS_GENERICWINDOW_ACTIVE                     (IDS_HS_GENERICWINDOW+3)
#define IDS_HS_GENERICWINDOW_LEFT                               (IDS_HS_GENERICWINDOW+4)
#define IDS_HS_GENERICWINDOW_TOP                                (IDS_HS_GENERICWINDOW+5)
#define IDS_HS_GENERICWINDOW_WIDTH                              (IDS_HS_GENERICWINDOW+6)
#define IDS_HS_GENERICWINDOW_HEIGHT                     (IDS_HS_GENERICWINDOW+7)
#define IDS_HS_GENERICWINDOW_INDEX                              (IDS_HS_GENERICWINDOW+8)
#define IDS_HS_GENERICWINDOW_NEXT                               (IDS_HS_GENERICWINDOW+9)
#define IDS_HS_GENERICWINDOW_PREVIOUS                   (IDS_HS_GENERICWINDOW+10)
#define IDS_HS_GENERICWINDOW_WINDOWSTATE                (IDS_HS_GENERICWINDOW+11)
#define IDS_HS_GENERICWINDOW_CLOSE                              (IDS_HS_GENERICWINDOW+12)
#define IDS_HS_GENERICWINDOW_PARENT                     (IDS_HS_GENERICWINDOW+13)
#define IDS_HS_GENERICWINDOW_max                                (IDS_HS_GENERICWINDOW+14)


// Help strings for IGenericProject
#define IDS_HS_GENERICPROJECT                                   IDS_HS_GENERICWINDOW_max
#define IDS_HS_GENERICPROJECT_NAME                              (IDS_HS_GENERICPROJECT+1)
#define IDS_HS_GENERICPROJECT_FULLNAME                  (IDS_HS_GENERICPROJECT+2)
#define IDS_HS_GENERICPROJECT_TYPE                              (IDS_HS_GENERICPROJECT+3)
#define IDS_HS_GENERICPROJECT_max                               (IDS_HS_GENERICPROJECT+4)

// Help strings for enums and other constants

// Help strings for DsWindowState
#define IDS_HS_DSWINDOWSTATE                                    IDS_HS_GENERICPROJECT_max
#define IDS_HS_DSWINDOWSTATE_MAXIMIZED                  (IDS_HS_DSWINDOWSTATE+1)
#define IDS_HS_DSWINDOWSTATE_MINIMIZED                  (IDS_HS_DSWINDOWSTATE+2)
#define IDS_HS_DSWINDOWSTATE_NORMAL                     (IDS_HS_DSWINDOWSTATE+3)
#define IDS_HS_DSWINDOWSTATE_max                                (IDS_HS_DSWINDOWSTATE+4)


// Help strings for DsArrangeStyle
#define IDS_HS_DSARRANGESTYE                                    IDS_HS_DSWINDOWSTATE_max
#define IDS_HS_DSARRANGESTYE_MINIMIZE                   (IDS_HS_DSARRANGESTYE+1)
#define IDS_HS_DSARRANGESTYE_TILEHORIZONTAL     (IDS_HS_DSARRANGESTYE+2)
#define IDS_HS_DSARRANGESTYE_TILEVERTICAL               (IDS_HS_DSARRANGESTYE+3)
#define IDS_HS_DSARRANGESTYE_CASCADE                    (IDS_HS_DSARRANGESTYE+4)
#define IDS_HS_DSARRANGESTYE_max                                (IDS_HS_DSARRANGESTYE+5)


// Help strings for DsButtonType 
#define IDS_HS_DSBUTTONTYPE                                     IDS_HS_DSARRANGESTYE_max
#define IDS_HS_DSBUTTONTYPE_GLYPH                               (IDS_HS_DSBUTTONTYPE+1)
#define IDS_HS_DSBUTTONTYPE_TEXT                                (IDS_HS_DSBUTTONTYPE+2)
#define IDS_HS_DSBUTTONTYPE_max                                 (IDS_HS_DSBUTTONTYPE+3)

// Help string for DsSaveChanges
#define IDS_HS_DSSAVECHANGES                                    IDS_HS_DSBUTTONTYPE_max
#define IDS_HS_DSSAVECHANGES_YES                                (IDS_HS_DSSAVECHANGES+1)
#define IDS_HS_DSSAVECHANGES_NO                                 (IDS_HS_DSSAVECHANGES+2)
#define IDS_HS_DSSAVECHANGES_PROMPT                     (IDS_HS_DSSAVECHANGES+3)
#define IDS_HS_DSSAVECHANGES_max                                (IDS_HS_DSSAVECHANGES+4)

// Help string for DsSaveStatus
#define IDS_HS_DSAVESTATUS                                              IDS_HS_DSSAVECHANGES_max
#define IDS_HS_DSAVESTATUS_SUCCEEDED                    (IDS_HS_DSAVESTATUS+1)
#define IDS_HS_DSAVESTATUS_CANCELED                     (IDS_HS_DSAVESTATUS+2)
#define IDS_HS_DSAVESTATUS_max                                  (IDS_HS_DSAVESTATUS+3)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Command ID ranges

//  Shell
#define MIN_SHELL_COMMAND_ID    0x8000
#define MAX_SHELL_COMMAND_ID    0x83FF
//  Build package
#define MIN_BUILD_COMMAND_ID    0x8400
#define MAX_BUILD_COMMAND_ID    0x85FF
//  Res package
#define MIN_RES_COMMAND_ID      0x8600
#define MAX_RES_COMMAND_ID      0x86FF
//  Src
#define MIN_SOURCE_COMMAND_ID   0x8700
#define MAX_SOURCE_COMMAND_ID   0x88FF
//  ClassView/Wizards
#define MIN_CLASSVIEW_COMMAND_ID   0x8900
#define MAX_CLASSVIEW_COMMAND_ID   0x89FF
//  MSIN
#define MIN_MSIN_COMMAND_ID     0x8A00
#define MAX_MSIN_COMMAND_ID     0x8BFF
//  Proj
#define MIN_WORKSPACE_COMMAND_ID 0x8C00
#define MAX_WORKSPACE_COMMAND_ID 0x8FFF
//  HTML
#define MIN_HTML_COMMAND_ID  0x9000
#define MAX_HTML_COMMAND_ID  0x900F
//  BIN
#define MIN_BIN_COMMAND_ID  0x9010
#define MAX_BIN_COMMAND_ID  0x901F
//  IMG
#define MIN_IMG_COMMAND_ID  0x9020
#define MAX_IMG_COMMAND_ID  0x907F
//  ODL
#define MIN_ODL_COMMAND_ID  0x9080
#define MAX_ODL_COMMAND_ID  0x909F
// IV
#define MIN_IV_COMMAND_ID   0x90A0
#define MAX_IV_COMMAND_ID   0x9FFF
//  Fortran
#define MIN_FORTRAN_COMMAND_ID  0xA000
#define MAX_FORTRAN_COMMAND_ID  0xA1FF
//  Test
#define MIN_TEST_COMMAND_ID     0xA200
#define MAX_TEST_COMMAND_ID     0xA3FF
//  Espresso
#define MIN_ESPRESSO_COMMAND_ID 0xA400
#define MAX_ESPRESSO_COMMAND_ID 0xA5FF
//  Enterprise Edition (Galileo)
#define MIN_ENT_COMMAND_ID      0xA600
#define MAX_ENT_COMMAND_ID      0xA67F
// Jakarta
#define MIN_JAVA_COMMAND_ID     0xA681
#define MAX_JAVA_COMMAND_ID     0xA6FF
//  Jakarta Image Editor
#define MIN_IMAGE_COMMAND_ID    0xA700
#define MAX_IMAGE_COMMAND_ID    0xA7FF
//  LangCPP
#define MIN_LANGCPP_COMMAND_ID  0xA800
#define MAX_LANGCPP_COMMAND_ID  0xA8FF

#define MIN_ADD_TO_PROJECT		0xA900
#define MAX_ADD_TO_PROJECT		0xA9FF
#define ID_ADD_TO_PROJECT_FIRST	0xA900
#define ID_ADD_TO_PROJECT_LAST	0xA9FF

//  SPACE 0xAA00-0xAEFF

//  Sample Package
#define MIN_SAMPLE_COMMAND_ID   0xAF00
#define MAX_SAMPLE_COMMAND_ID   0xAFFF
//  NuMega Package
#define MIN_NUMEGA_COMMAND_ID   0xB000
#define MAX_NUMEGA_COMMAND_ID   0xB1FF
//  Package Partner Package (define one min/max set per partner--512 IDs)
//  Partners use 'PARTNER' IDs until a specific range is established for them.
#define MIN_PARTNER_COMMAND_ID  0xB200
#define MAX_PARTNER_COMMAND_ID  0xB3FF

//  SPACE 0xB400-0xB78F 

// IATOOL (Interactive Authoring Tool Package)
#define MIN_IATOOL_COMMAND_ID   0xB400
#define MAX_IATOOL_COMMAND_ID   0xB5FF
// NCB (No Compile Browser)
// !!!!!This is an internal package.
#define MIN_NCB_COMMAND_ID      0xB600
#define MAX_NCB_COMMAND_ID      0xB625
// IST (Internet Studio)    
#define MIN_IST_COMMAND_ID      0xB650
#define MAX_IST_COMMAND_ID      0xB6FF
// LANGJVA (Java Language Package)
#define MIN_LANGJVA_COMMAND_ID  0xB700
#define MAX_LANGJVA_COMMAND_ID  0xB78F
// OLE Automation 1 (DevAUT1.pkg)
#define MIN_AUT1_COMMAND_ID     0xB790
#define MAX_AUT1_COMMAND_ID     0xC78F
// OLE Automation 2 (DevAUT2.pkg)
#define MIN_AUT2_COMMAND_ID     0xC790
#define MAX_AUT2_COMMAND_ID     0xC8EF
// HTM
#define MIN_HTM_COMMAND_ID      0xC8F0
#define MAX_HTM_COMMAND_ID      0xCAEF
// DTG
#define MIN_DTG_COMMAND_ID      0xCAF0
#define MAX_DTG_COMMAND_ID      0xCCEF
// DDK
#define MIN_DDK_COMMAND_ID      0xCCF0
#define MAX_DDK_COMMAND_ID      0xCCFF

//  BlueSky Package
#define MIN_BLUESKY_COMMAND_ID  0xCD00
#define MAX_BLUESKY_COMMAND_ID  0xCDFF
//  Rational Package
#define MIN_RATIONAL_COMMAND_ID 0xCE00
#define MAX_RATIONAL_COMMAND_ID 0xCEFF
//  RST Package
#define MIN_RST_COMMAND_ID      0xCF00
#define MAX_RST_COMMAND_ID      0xCFFF
//  StingRay Package
#define MIN_STINGRAY_COMMAND_ID 0xD000
#define MAX_STINGRAY_COMMAND_ID 0xD0FF


//  SPACE 0xD100-0xDFFF

// MFC
#define MIN_MFC_COMMAND_ID      0xE000
#define MAX_MFC_COMMAND_ID      0xFFFF

/////////////////////////////////////////////////////////////////////
// Shell Commands
//
#define IDM_TOOLBAR_EDIT                0x8000
#define IDM_CUSTOMIZE                   0x8001
#define ID_WINDOW_CLOSE_ALL             0x8002
#define IDM_OPTIONS                     0x8003
#define IDM_TOGGLE_MDI                  0x8004
#define IDM_TOOLBAR_CUSTOMIZE           0x8005
#define ID_WINDOW_FULLSCREEN            0x8006
#define ID_FILE_SAVE_ALL_EXIT           0x8007
#define IDM_CONTEXT_SEPARATOR           0x8008
#define IDM_TOOLBARS_LIST               0x8009
#define IDM_TOOLBARS_CUSTOMIZE          0x800a

// These two only used for tooltips
#define IDM_BUTTON_DOCK_CLOSE           0x800b
#define IDM_BUTTON_DOCK_MAX             0x800c
#define IDM_BUTTON_DOCK_RESTORE         0x800d

// Window commands
#define IDM_WINDOW_CLOSE                                0x800e
#define IDM_WINDOW_NEXT                                 0x800f
#define IDM_WINDOW_PREVIOUS                             0x8010

#define IDM_REFRESH                                             0x8011
#define IDM_FILE_NEW_IN_PROJ            0x8012

// This command group is special becuase it is enabled even when the toolbar
// customisation window is visible. martynl 25Mar96
#define IDM_BUTTON_BASE                 0x8080
#define IDM_BUTTON_COPYIMAGE                    0x8080
#define IDM_BUTTON_PASTEIMAGE                   0x8081
#define IDM_BUTTON_RESETIMAGE           0x8082
#define IDM_BUTTON_CHOOSEAPPEARANCE     0x8083
#define IDM_BUTTON_RESET                                0x8084
#define IDM_BUTTON_DELETE                               0x8085
#define IDM_BUTTON_IMAGEONLY                    0x8086
#define IDM_BUTTON_TEXTONLY                             0x8088
#define IDM_BUTTON_IMAGETEXT                    0x8089
#define IDM_BUTTON_GROUPSTART                   0x808a
#define IDM_BUTTON_LAST                 0x808a

// READ THIS IF YOU ARE MODIFYING MENU IDS:
// Menus are now commands, and as such, have command ids like everything else in the world.
// Code elsewhere (entry.cpp) relies on the order of these, and the fact that they increase 
// monotonically, so change with caution.
// THIS MEANS THAT EACH OF THESE SHOULD BE ONE MORE THAN THE PREVIOUS ONE. NO SPACES ALLOWED

#define IDM_MENU_FIRSTMAIN                              0x8100
#define IDM_MENU_BAR                                    0x8100
#define IDM_MENU_FILE                                   0x8101
#define IDM_MENU_EDIT                                   0x8102
#define IDM_MENU_VIEW                                   0x8103
#define IDM_MENU_INSERT                                 0x8104
#define IDM_MENU_BUILD_DEBUG            0x8105
#define IDM_MENU_BUILD                                  0x8106
#define IDM_MENU_IMAGE                  0x8107
#define IDM_MENU_LAYOUT_ALIGN                   0x8108
#define IDM_MENU_LAYOUT_SPACE           0x8109
#define IDM_MENU_LAYOUT_CENTER          0x810a
#define IDM_MENU_LAYOUT_ARRANGE         0x810b
#define IDM_MENU_LAYOUT_SAMESIZE        0x810c
#define IDM_MENU_LAYOUT_AUTO                    0x810d
#define IDM_MENU_LAYOUT                                 0x810e
#define IDM_MENU_TEST                                   0x810f
#define IDM_MENU_CODECOVERAGE                   0x8110
#define IDM_MENU_DEBUG                  0x8111
#define IDM_MENU_TOOLS_SCC              0x8112
#define IDM_MENU_TOOLS                                  0x8113
#define IDM_MENU_WINDOW                 0x8114
#define IDM_MENU_HELP                   0x8115
#define IDM_MENU_INTERNAL_DEBUG         0x8116
#define IDM_MENU_INTERNAL_PERF          0x8117
#define IDM_MENU_VIEW_TOOLBARS                          0x8118
#define IDM_MENU_OLEBAR                          0x8119
#define IDM_MENU_HELP_MSONTHEWEB                0x811a
#define IDM_MENU_FILEMRU                                0x811b
#define IDM_MENU_WKSMRU                                 0x811c
#define IDM_MENU_DEBUG_WINDOWS                  0x811d
#define IDM_MENU_PROJECT                                0x811e
#define IDM_MENU_PROJECT_LIST                           0x811f
#define IDM_MENU_PROJECT_ADD                            0x8120
#define IDM_MENU_LASTMAIN                               0x8120

#define IDM_DOCKSHOW_BASE               0x8200
#define IDM_DOCKSHOW_LAST               0x8218  //24 possible show commands for all dockable windows.

// Custom menu ids for 'new' menus generated and managed by the shell
#define IDM_CUSTOMMENU_BASE                             0x8240

#define IDM_CUSTOMMENU_0                (IDM_CUSTOMMENU_BASE + 0)
#define IDM_CUSTOMMENU_1                (IDM_CUSTOMMENU_BASE + 1)
#define IDM_CUSTOMMENU_2                (IDM_CUSTOMMENU_BASE + 2)
#define IDM_CUSTOMMENU_3                (IDM_CUSTOMMENU_BASE + 3)
#define IDM_CUSTOMMENU_4                (IDM_CUSTOMMENU_BASE + 4)
#define IDM_CUSTOMMENU_5                (IDM_CUSTOMMENU_BASE + 5)
#define IDM_CUSTOMMENU_6                (IDM_CUSTOMMENU_BASE + 6)
#define IDM_CUSTOMMENU_7                (IDM_CUSTOMMENU_BASE + 7)
#define IDM_CUSTOMMENU_8                (IDM_CUSTOMMENU_BASE + 8)
#define IDM_CUSTOMMENU_9                (IDM_CUSTOMMENU_BASE + 9)
#define IDM_CUSTOMMENU_10               (IDM_CUSTOMMENU_BASE + 10)
#define IDM_CUSTOMMENU_11               (IDM_CUSTOMMENU_BASE + 11)
#define IDM_CUSTOMMENU_12               (IDM_CUSTOMMENU_BASE + 12)
#define IDM_CUSTOMMENU_13               (IDM_CUSTOMMENU_BASE + 13)
#define IDM_CUSTOMMENU_14               (IDM_CUSTOMMENU_BASE + 14)
#define IDM_CUSTOMMENU_15               (IDM_CUSTOMMENU_BASE + 15)
#define IDM_CUSTOMMENU_LAST                             0x824f

#define IDM_ACTIVATE_PROJECT_WORKSPACE  0x8280
#define IDM_TOGGLE_PROJECT_WORKSPACE    0x8281

#define IDMX_IDPROP                     0x8290
#define IDMX_PROPGENERAL                0x8291
#define IDMX_PROPSTYLES                 0x8292
#define ID_FASTHELP                     0x8298

#define IDM_USERTOOLS_BASE              0x82A0
#define IDM_USERTOOLS_0                 (IDM_USERTOOLS_BASE + 0)
#define IDM_USERTOOLS_1                 (IDM_USERTOOLS_BASE + 1)
#define IDM_USERTOOLS_2                 (IDM_USERTOOLS_BASE + 2)
#define IDM_USERTOOLS_3                 (IDM_USERTOOLS_BASE + 3)
#define IDM_USERTOOLS_4                 (IDM_USERTOOLS_BASE + 4)
#define IDM_USERTOOLS_5                 (IDM_USERTOOLS_BASE + 5)
#define IDM_USERTOOLS_6                 (IDM_USERTOOLS_BASE + 6)
#define IDM_USERTOOLS_7                 (IDM_USERTOOLS_BASE + 7)
#define IDM_USERTOOLS_8                 (IDM_USERTOOLS_BASE + 8)
#define IDM_USERTOOLS_9                 (IDM_USERTOOLS_BASE + 9)
#define IDM_USERTOOLS_10                (IDM_USERTOOLS_BASE + 10)
#define IDM_USERTOOLS_11                (IDM_USERTOOLS_BASE + 11)
#define IDM_USERTOOLS_12                (IDM_USERTOOLS_BASE + 12)
#define IDM_USERTOOLS_13                (IDM_USERTOOLS_BASE + 13)
#define IDM_USERTOOLS_14                (IDM_USERTOOLS_BASE + 14)
#define IDM_USERTOOLS_15                (IDM_USERTOOLS_BASE + 15)
#define IDM_USERTOOLS_LAST              0x82AF  //16 user tools on Tools menu

#define IDM_WINDOWS_BASE              0x82B0
#define IDM_WINDOWS_0                 (IDM_WINDOWS_BASE + 0)
#define IDM_WINDOWS_1                 (IDM_WINDOWS_BASE + 1)
#define IDM_WINDOWS_2                 (IDM_WINDOWS_BASE + 2)
#define IDM_WINDOWS_3                 (IDM_WINDOWS_BASE + 3)
#define IDM_WINDOWS_4                 (IDM_WINDOWS_BASE + 4)
#define IDM_WINDOWS_5                 (IDM_WINDOWS_BASE + 5)
#define IDM_WINDOWS_6                 (IDM_WINDOWS_BASE + 6)
#define IDM_WINDOWS_7                 (IDM_WINDOWS_BASE + 7)
#define IDM_WINDOWS_8                 (IDM_WINDOWS_BASE + 8)
#define IDM_WINDOWS_9                 (IDM_WINDOWS_BASE + 9)
#define IDM_WINDOWS_10                (IDM_WINDOWS_BASE + 10)
#define IDM_WINDOWS_11                (IDM_WINDOWS_BASE + 11)
#define IDM_WINDOWS_12                (IDM_WINDOWS_BASE + 12)
#define IDM_WINDOWS_13                (IDM_WINDOWS_BASE + 13)
#define IDM_WINDOWS_14                (IDM_WINDOWS_BASE + 14)
#define IDM_WINDOWS_15                (IDM_WINDOWS_BASE + 15)
#define IDM_WINDOWS_16                (IDM_WINDOWS_BASE + 16)
#define IDM_WINDOWS_17                (IDM_WINDOWS_BASE + 17)
#define IDM_WINDOWS_18                (IDM_WINDOWS_BASE + 18)
#define IDM_WINDOWS_19                (IDM_WINDOWS_BASE + 19)
#define IDM_WINDOWS_20                (IDM_WINDOWS_BASE + 20)
#define IDM_WINDOWS_21                (IDM_WINDOWS_BASE + 21)
#define IDM_WINDOWS_22                (IDM_WINDOWS_BASE + 22)
#define IDM_WINDOWS_23                (IDM_WINDOWS_BASE + 23)
#define IDM_WINDOWS_24                (IDM_WINDOWS_BASE + 24)
#define IDM_WINDOWS_25                (IDM_WINDOWS_BASE + 25)
#define IDM_WINDOWS_26                (IDM_WINDOWS_BASE + 26)
#define IDM_WINDOWS_27                (IDM_WINDOWS_BASE + 27)
#define IDM_WINDOWS_28                (IDM_WINDOWS_BASE + 28)
#define IDM_WINDOWS_29                (IDM_WINDOWS_BASE + 29)
#define IDM_WINDOWS_30                (IDM_WINDOWS_BASE + 30)
#define IDM_WINDOWS_31                (IDM_WINDOWS_BASE + 31)
#define IDM_WINDOWS_LAST              0x82CF  //32 items max on windows menu
#define ID_WINDOW_LIST_DOCS           0x82D0

#define ID_PROJ_MRU_FIRST                               0x82E0
#define ID_PROJ_MRU_FILE1               (ID_PROJ_MRU_FIRST)
#define ID_PROJ_MRU_FILE2               (ID_PROJ_MRU_FIRST + 1)
#define ID_PROJ_MRU_FILE3               (ID_PROJ_MRU_FIRST + 2)
#define ID_PROJ_MRU_FILE4               (ID_PROJ_MRU_FIRST + 3)
#define ID_PROJ_MRU_FILE5               (ID_PROJ_MRU_FIRST + 4)
#define ID_PROJ_MRU_FILE6               (ID_PROJ_MRU_FIRST + 5)
#define ID_PROJ_MRU_FILE7               (ID_PROJ_MRU_FIRST + 6)
#define ID_PROJ_MRU_FILE8               (ID_PROJ_MRU_FIRST + 7)
#define ID_PROJ_MRU_FILE9               (ID_PROJ_MRU_FIRST + 8)
#define ID_PROJ_MRU_FILE10              (ID_PROJ_MRU_FIRST + 9)
#define ID_PROJ_MRU_FILE11              (ID_PROJ_MRU_FIRST + 10)
#define ID_PROJ_MRU_FILE12              (ID_PROJ_MRU_FIRST + 11)
#define ID_PROJ_MRU_FILE13              (ID_PROJ_MRU_FIRST + 12)
#define ID_PROJ_MRU_FILE14              (ID_PROJ_MRU_FIRST + 13)
#define ID_PROJ_MRU_FILE15              (ID_PROJ_MRU_FIRST + 14)
#define ID_PROJ_MRU_FILE16              (ID_PROJ_MRU_FIRST + 15)
#define ID_PROJ_MRU_LAST                                0x82EF

#ifdef _DEBUG
#define IDM_OPENLAYOUT                  0x8300
#endif

#define IDM_INSERT_FILES                0x8301
#define ID_TOOLS_RECORD                 0x8302
#define ID_TOOLS_PLAYBACK               0x8303
#define ID_FILE_NEW_SOURCE              0x8304
#define ID_FILE_NEW_RC                  0x8305
#define IDM_WINDOW_SHOWPROPERTIES       0x8306
#define IDM_WINDOW_HSPROPERTIES         0x8307
#define ID_WINDOW_HIDE                  0x8308
#define ID_WINDOW_POPUP_HIDE            0x8309

#define ID_PROP_PUSHPIN                 0x4edf
#define MIN_ID_REPEAT_CMD               0x8321
#define ID_REPEAT_CMD                   0x8321
#define ID_REPEAT_CMD0                  0x8322
#define ID_REPEAT_CMD1                  0x8323
#define ID_REPEAT_CMD2                  0x8324
#define ID_REPEAT_CMD3                  0x8325
#define ID_REPEAT_CMD4                  0x8326
#define ID_REPEAT_CMD5                  0x8327
#define ID_REPEAT_CMD6                  0x8328
#define ID_REPEAT_CMD7                  0x8329
#define ID_REPEAT_CMD8                  0x832A
#define ID_REPEAT_CMD9                  0x832B
#define MAX_ID_REPEAT_CMD               0x832B

#define ID_DRAG_MOVE                    0x8330
#define ID_DRAG_COPY                    0x8331
#define ID_DRAG_CANCEL                  0x8332

#define ID_CANCEL                       0x8333
#define ID_MDI_CYCLE_FORWARD            0x8334
#define ID_PROJECT_COMBO                0x8335

#define ID_GRD_NEW                      0x4ed0
#define ID_GRD_DELETE                   0x4ed1
#define ID_GRD_MOVEUP                   0x4ed2
#define ID_GRD_MOVEDOWN                 0x4ed3

// IDs reserved for internal developer utilities
#define ID_INTERNAL_FIRST               0x8350
#ifdef  PERF_MEASUREMENTS
#define ID_DUMP_MEM                     (ID_INTERNAL_FIRST+0)
#endif
#define ID_INTERNAL_LAST                0x835f

// Shell groups

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Command Group IDs

// Below are groups that commands may go in.  (These used to be called "minor
//  groups"-- note that the IDs relating to "major groups" have been removed.)
//  Each command or menu is a member of one of the following groups. If the command 
//  or menu appears on a menu, its location is determined by the group's location (on 
//  which menu, and where in that menu).  See ide\exes\dev\entry.cpp.
// The Tools.Customize dialog lists commands by "category".  The category
//  is determined by which of the following groups the command is a member of,
//  and then what main menu that group is a part of.  Note that you can
//  have hidden menus, which allow you to group your commands in the
//  Tools.Customize.Keyboard dialog any way you like, without affecting the
//  visible menu structure.  To have a hidden menu, simply make sure that
//  all commands in all groups on that menu have the CT_NOMENU flag.
//  (See ide\include\cmdtable.h.)  This is set in your .cmd file, or
//  as an argument to CTheApp::AddCommand.

// Packages are free to create their own groups. The group ids should be in the same range as
// the packages command ids, though the two sets of numbers may overlap.

// If a group has its low bit set, then no separator will appear after it. Otherwise, a 
// separator will be inserted

// Currently groups for all packages appear here. Gradually, some of these group ids can be
// exported to other places

#define IDG_FILEOPS                  0x8000
#define IDG_FILESAVE                 0x8002
#define IDG_PRINT                    0x8005
#define IDG_MRU                      0x8006
#define IDG_EXIT                     0x8008
#define IDG_PROJ_MRU_MENU            0x800c
#define IDG_MSINOPEN                 0x8010
#define IDG_PRINTMAIN                        0x8012
#define IDG_MRU_MENU                             0x8014
#define IDG_PROJ_MRU                 0x8016
#define IDG_FILE_RENAME                          0x8018
#define IDG_FILE_NEW                 0x8019

#define IDG_UNDO                     0x8020
#define IDG_FILE_NEW_IN_PROJ         0x8021
#define IDG_CLIPBOARD                0x8023
#define IDG_FIND_1                   0x8025
#define IDG_FIND_COMBO               0x8026
#define IDG_GOTO                     0x8029
#define IDG_BOOKMARK                 0x802a
#define IDG_EDITPROPS                0x802c
#define IDG_BREAKPOINTS              0x8030
#define IDG_FORMATEDITOR             0x8032
#define IDG_SELECTALL                            0x8034
#define IDG_FIND_2                   0x8036
#define IDG_CLIPBOARD_2                          0x8038
#define IDG_GOTO_2                                   0x803b

#define IDG_PROJECTOPS               0x8040
#define IDG_BUILD                    0x8042
#define IDG_ERROR                    0x8044
#define IDG_DEPENDENCIES             0x8046
#define IDG_PROJECTCLOSE             0x8048
#define IDG_PROJECTOPS_STD           0x804a
#define IDG_PROJECT_ADD              0x804c
#define IDG_PROJECTOPS_ADD           0x804e
#define IDG_PROJECTOPS_SCAN          0x8050
#define IDG_PROJECTOPS_SCHM          0x8052

#define IDG_RESOURCENEW			     0x8060
#define IDG_RESOURCEIMPORTEXPORT     0x8062
#define IDG_SYMBOLS					 0x8064
#define IDG_VIEW_AS_POPUP            0x8066
#define IDG_NEWRES                   0x8068
#define IDG_CLASSWIZARD              0x806a
#define IDG_LAYOUTOPT                0x806c
#define IDG_WORKSPACEOPS             0x806e

#define IDG_DEBUGRUN                 0x8080
#define IDG_DEBUGSHOW                0x8082
#define IDG_DEBUGTHREADS             0x8084
#define IDG_CODECOVER                0x8086
#define IDG_COVERITEMS               0x8088
#define IDG_DEBUGOPTS                0x808a
#define IDG_DEBUGACTIVE              0x808c
// This group id is deliberately odd, because it is a no-break group
#define IDG_DEBUGSTEP1               0x808f 
#define IDG_DEBUGSTEP2               0x8090

#define IDG_TOOLOPS                  0x80a0
#define IDG_TOOLS_PROFILE                        0x80a1         // WinslowF Adding profiler
#define IDG_TOOLS_PACKAGES           0x80a2
#define IDG_OPTIONS                  0x80a4
#define IDG_TOOLS_SEARCH             0x80a6
#define IDG_USERTOOLS                0x80a8
#define IDG_MACROS                   0x80aa
#define IDG_BUTTONOPS                0x80ac     // Button customize context menu.
#define IDG_TOOLS_RUN                            0x80ae
#define IDG_TOOLS_RESOURCE                       0x80b0
#define IDG_TOOLS_WEB_1              0x80b3
#define IDG_TOOLS_WEB_2              0x80b4

#define IDG_WINDOWOPS                0x80c0
#define IDG_WINDOWALL                0x80c3
#define IDG_WINDOW_WINDOWS           0x80c4
#define IDG_WINDOWLIST               0x80c6
#define IDG_WINDOWNEXT                           0x80c8

#define IDG_HELPGENERAL              0x80e0
#define IDG_HELPDOCS                 0x80e1
#define IDG_MSONTHEWEB               0x80e4
#define IDG_HELPINSTALLED            0x80e6
#define IDG_HELP_SUBSETCOMBO         0x80e8
#define IDG_HELPABOUT                0x80ea
#define IDG_HELP_OPENCOMBO           0x80ec
#define IDG_HELP_CONTENTS            0x80f0
#define IDG_HELP_BROWSE              0x80f2
#define IDG_HELP_MSONTHEWEB_NEWS         0x80f4         // Items on the mow submenu
#define IDG_HELP_MSONTHEWEB_INFO         0x80f6
#define IDG_HELP_MSONTHEWEB_HOME         0x80f8
#define IDG_HELP_KEYBOARD            0x80fa
#define IDG_HELP_TOPLEVEL                0x80fc

#define IDG_IMAGEOPS                 0x8100
#define IDG_IMAGECOLORS              0x8102
#define IDG_IMAGEGRID                0x8104
#define IDG_IMAGETOOLS               0x8106
#define IDG_IMAGE_DEVICE             0x8108

#define IDG_LAYOUTOPS_1              0x8121
#define IDG_LAYOUTGRID               0x8122
#define IDG_LAYOUTTAB                0x8124
#define IDG_RULER_CONTEXT            0x8126
#define IDG_ALIGNEDGE                0x8128
#define IDG_ALIGNCENTER              0x812a
#define IDG_SPACEEVENLY              0x812c
#define IDG_CENTERDIALOG             0x812e
#define IDG_ARRANGEBUTTONS           0x8130
#define IDG_SAMESIZE                 0x8132
#define IDG_LAYOUTGROUP                          0x8134
#define IDG_LAYOUTZORDER             0x8136
#define IDG_LAYOUTGUIDES             0x8138
#define IDG_LAYOUTTEST               0x813a
#define IDG_LAYOUTAUTO               0x813c
#define IDG_LAYOUTOPS_2                          0x813e

#define IDG_BROWSE                  0x8140
#define IDG_KEY                     0x8142

// InfoViewer Groups 0x815x to 0x817F

#define IDG_IV_FILE_OPS             0x8150
#define IDG_IV_FILE_NEW_NOSEP       0x8151
#define IDG_IV_FILE_SAVE            0x8152
#define IDG_IV_FILE_PRINT           0x8154
#define IDG_IV_FILE_MISC            0x8156
#define IDG_IV_FILE_LAST            0x8157
#define IDG_IV_EDIT_OPS             0x815a
#define IDG_IV_EDIT_FIND            0x815c
#define IDG_IV_EDIT_BOOKMARKS       0x815c
#define IDG_IV_EDIT_BOOKMARKS_NOSEP 0x815d
#define IDG_IV_EDIT_LAST            0x815f
#define IDG_IV_VIEW_HOME            0x8160
#define IDG_IV_VIEW_LISTS           0x8162
#define IDG_IV_VIEW_LIST_OPS        0x8164
#define IDG_IV_VIEW_LAST            0x8167
#define IDG_IV_VIEW_WINDOWS         0x8169
#define IDG_IV_TOOLS_SEARCH         0x816a
#define IDG_IV_TOOLS_SYNC           0x816c
#define IDG_IV_TOOLS_SYNC_NOSEP     0x816d
#define IDG_IV_TOOLS_SUBSETS        0x816e
#define IDG_IV_TOOLS_LAST           0x816f
#define IDG_IV_WINDOW_MISC          0x8170
#define IDG_IV_WINDOW_CONTENTS      0x8172
#define IDG_IV_WINDOW_TOPIC         0x8174
#define IDG_IV_WINDOW_LAST          0x8177
#define IDG_IV_HELP_FIRST           0x817a
#define IDG_IV_HELP_CONTENTS        0x817a
#define IDG_IV_HELP_MISC            0x817c
#define IDG_IV_HELP_ABOUT           0x817f

#define IDG_PROJECT                 0x8180
#define IDG_PRJSYS_OPS              0x8182
#define IDG_BLDSYS_TOOL             0x8184
#define IDG_TARGET_COMBO            0x8186
#define IDG_BUILD_1                 0x8188
#define IDG_BUILD_DEBUGMENU         0x818a
#define IDG_BUILD_2                 0x818c
#define IDG_CONFIG_COMBO            0x818e

#define IDG_VIEW_WINDOWS            0x81a1
#define IDG_VIEW_MSIN1              0x81a2
#define IDG_VIEW_MSIN2              0x81a4
#define IDG_VIEW_MSIN3              0x81a6
#define IDG_MSIN_PRINT              0x81a8
#define IDG_VIEW_WINDOWS_2                      0x81aa
#define IDG_VIEW_WEB                0x81ad
#define IDG_VIEW_WEB_2              0x81ae
#define IDG_VIEW_DB                                 0x81b1
#define IDG_VIEW_DB_2               0x81b3
#define IDG_VIEW_DB_3               0x81b4
#define IDG_VIEW_REFRESH            0x81b6
#define IDG_VIEW_DEBUG_WINDOWS          0x81ba

#define IDG_SCC_POPUP               0x81c0
#define IDG_SCC_OPS1                0x81c2
#define IDG_SCC_OPS2                0x81c4
#define IDG_SCC_OPS3                0x81c6
#define IDG_SCC_RUN                 0x81c8

#define IDG_BROWSE_OPS              0x81e0
#define IDG_WIZBARU                 0x81e4
#define IDG_WIZBARU_CTL             0x81e6
#define IDG_WIZBARU_CMDS            0x81e8
#define IDG_AUTO_COMPLETE			0x81eA

#define IDG_INTERNAL_UTILS          0x8202
// the edit advanced submenu
#define IDG_MENU_EDIT_ADVANCED      0x8204
// Items on the edit advanced submenu
#define IDG_EDIT_ADVANCED           0x8206

#define IDG_TOOLBARS_LIST           0x8220
#define IDG_TOOLBARS_CUSTOMIZE      0x8222

#define IDG_VIEW_FULLSCREEN         0x8240
#define IDG_INSERT_0                0x8241
#define IDG_INSERT_1                0x8243
#define IDG_INSERT_2                0x8244
#define IDG_INSERT_3                0x8246
#define IDG_INSERT_4                0x8248
#define IDG_BUILD_SETTINGS          0x824a
#define IDG_VIEW_TOOLBARS           0x824c
#define IDG_TOOLS_REMOTE            0x824e
#define IDG_INSERT_FILE                         0x8250
#define IDG_DEBUG_GO                0x8251
#define IDG_DEBUG_STEPINTO          0x8253
#define IDG_DEBUG_RUNTOCURSOR       0x8255
#define IDG_DEBUG_ATTACH            0x8257
#define IDG_INSERT_RESOURCE			0x8258

// These groups dictate the ordering of the menus within the main menu bar
// Keep them numerically adjacent, so the popup main menu bar is drawn without separators
#define IDG_MENUBAR_FILE            0x8261
#define IDG_MENUBAR_EDIT            0x8263
#define IDG_MENUBAR_VIEW            0x8265
#define IDG_MENUBAR_INSERT          0x8267
#define IDG_MENUBAR_BUILD           0x8269     // includes build and debug
#define IDG_MENUBAR_TEST            0x826b
#define IDG_MENUBAR_RESOURCE        0x826d
#define IDG_MENUBAR_TOOLS           0x826f
#define IDG_MENUBAR_WINDOW          0x8271
#define IDG_MENUBAR_HELP            0x8273
#define IDG_MENUBAR_INTERNAL        0x8275
#define IDG_MENUBAR_PROJECT         0x8277

// Special kinds of menus
#define IDG_CUSTOMMENU              0x8280
#define IDG_MENUBAR_BAR             0x8282      // group containing the main menu bar. Shouldn't be used outside of shell

#define IDG_DEBUG_1                 0x82a0
#define IDG_DEBUG_2                 0x82a2
#define IDG_DEBUG_3                 0x82a4
#define IDG_DEBUG_4                 0x82a6
#define IDG_DEBUG_5                 0x82a8
#define IDG_DEBUG_6                 0x82aa
#define IDG_DEBUG_7                 0x82ac
#define IDG_DEBUG_8                 0x82ae
#define IDG_DEBUG_PERF              0x82b0

#define IDG_PROJECT_MODIFY                      0x82c0
#define IDG_PROJECT_WEB                         0x82c2
#define IDG_PROJECT_SCCS                        0x82c4
#define IDG_PROJECT_SETTINGS            0x82c6
#define IDG_PROJECT_INSERT                      0x82c8
#define IDG_PROJECT_LIST                        0x82ca
#define IDG_PROJECT_ADD_NEW         0x82cc
#define IDG_PROJECT_ADD_INSERT          0x82ce
#define IDG_PROJECT_ADD_DB                      0x82d0
#define IDG_PROJECT_ADD_COMPONENT   0x82d2
#define IDG_PROJECT_ADD_PROJECT                 0x82d4


// Espresso special command groups
// REVIEW(BrendanX): Better location for non-DevStudio EXE commands.
// Martynl: Can now move out to packages, since they can own their own menus.
#define IDG_GLOSSARY_MISC_OPS               0x8300
#define IDG_GLOSSARY_OPS                    0x8302
#define IDG_TRANSLATE_APPROVALSTATEFAILED   0x8304
#define IDG_TRANSLATE_APPROVALSTATE         0x8306
#define IDG_TRANSLATE_USERFLAG              0x8308
#define IDG_TRANSLATE_TESTWHAT              0x830a
#define IDG_TRANSLATE_ITEM                  0x830c
#define IDG_TRANSLATE_STATE                 0x830e
#define IDG_TRANSLATE_AUTO                  0x8310
#define IDG_TRANSLATE_TEST                  0x8312
#define IDG_DATABASEOPS                     0x8314
#define IDG_VIEW_EDITORS                    0x8316
#define IDG_VIEW_REPORTS                    0x8318
#define IDG_VIEW_REPORT_FILES               0x8320
#define IDG_HELPESPRESSOABOUT               0x8322
#define IDG_ESPRESSO_LAYOUT                 0x8324
#define IDG_ESPRESSO_TOOLS                  0x8326
#define IDG_ESPRESSO_MISC1                  0x8328
#define IDG_ESPRESSO_MISC2                  0x832a
#define IDG_ESPRESSO_MISC3                  0x832c
#define IDG_IMPORT_PROJECT                  0x832e
#define IDG_ESPESSO_DB                      0x8330
#define IDG_AUTOLAYOUT                      0x8332
#define IDG_REVERT                          0x8334
#define IDG_DIALOGLAYOUT                    0x8336
#define IDG_HELPESPRESSO                    0x8338
#define IDG_VIEW_EDITORWALK                 0x833a

#define IDG_TEST_DEBUG              0x8380
#define IDG_TEST_RECORD             0x8382
#define IDG_TEST_SCREENS            0x8384
#define IDG_TEST_DIALOGS            0x8386
#define IDG_TEST_DRIVER             0x8388

// HTM Insert.Html group
#define IDG_INSERTHTML                                          0x8389

/////////////////////////////////////////////////////////////////////
// VPROJ Commands
//
#define IDM_PROJITEM_FIRST              0x8400
#define IDM_PROJITEM_NEW                0x8400
#define IDM_PROJITEM_MOVE               0x8401
#define IDM_PROJITEM_COPY               0x8402
#define IDM_PROJITEM_DELETE             0x8403
#define IDM_PROJITEM_OPEN               0x8404
#define IDM_PROJITEM_ADD_RC             0x8416
#define IDM_PROJITEM_ADD_GROUP          0x8407
#define IDM_PROJITEM_ADD_SUBPROJ        0x8408
#define IDM_PROJITEM_SCAN               0x8409
#define IDM_PROJECT_SCAN_ALL            0x840a
#define IDM_PROJITEM_BUILD              0x840b
#define IDM_PROJITEM_COMPILE            0x840c
#define IDM_PROJITEM_PRINT              0x840d
#define IDM_PROJITEM_REBUILD_ALL        0x840e
#define IDM_PROJECT_EXECUTE             0x840f
#define IDM_PROJITEM_BATCH_BUILD        0x8410
#define IDM_PROJITEM_BUILD_NO_DEPS      0x8411
#define IDM_PROJITEM_CBUILD             0x841c
#define IDM_PROJITEM_CBUILD_NO_DEPS     0x841d
#define IDM_PROJITEM_CCOMPILE           0x841f
#define IDM_PROJECT_SET_AS_DEFAULT      0x8420
#define IDM_PROJECT_OPENDIALOG          0x8221
#define IDM_PROJITEM_LAST               0x84ff
#define IDM_PROJ_FIRST                  0x8500
#define IDM_PROJECT_SETTINGS            0x8500
#define IDM_PROJECT_STOP_BUILD          0x8501
#define IDM_PROJECT_CLOSEBSC            0x8502
#define IDM_PROJECT_TOOL_MECR           0x8503
#define IDM_PROJECT_CONFIGURATIONS      0x8504
#define IDM_PROJECT_TOOL_CMD_FIRST      0x8510
#define IDM_PROJECT_TOOL_CMD0           0x8510
#define IDM_PROJECT_TOOL_CMD1           0x8511
#define IDM_PROJECT_TOOL_CMD2           0x8512
#define IDM_PROJECT_TOOL_CMD3           0x8513
#define IDM_PROJECT_TOOL_CMD4           0x8514
#define IDM_PROJECT_TOOL_CMD5           0x8515
#define IDM_PROJECT_TOOL_CMD6           0x8516
#define IDM_PROJECT_TOOL_CMD_LAST       0x8516
#define IDM_PROJECT_CLEAN_ACTIVE        0x8518
#define IDM_PROJECT_TOOLS               0x8519
#define IDM_PROJECT_SETTINGS_POP        0x851a
#define IDM_PROJECT_BUILDGRAPH          0x851b
#define IDM_PROJECT_CLEAN               0x851c
#define IDM_DEBUG_SETTINGS              0x851d

// adding user-defined messages for PostMessage()
// this is to avoid buttons being depressed during duration of the cmd.
#define ID_PROJITEM_COMPILE             0x851e
#define ID_PROJITEM_BUILD               0x851f 
#define ID_PROJITEM_REBUILD_ALL         0x8520
#define ID_PROJITEM_BATCH_BUILD         0x8521

#define ID_TARGET_COMBO                 0x8522
#define IDM_PROJECT_SUBPROJECTS         0x8523
#define IDM_PROJECT_EXPORT              0x8524
#define IDM_PROJECT_WRITE               0x8525
#define ID_CONFIG_COMBO                 0x8526

#define IDM_PROJECT_LOAD                0x8527
#define IDM_PROJECT_UNLOAD              0x8528
#define IDM_BUILD_TOGGLE                                0x8529
#define ID_PROJITEM_CLEAN               0x852a
#define IDM_PROJITEM_CLEAN              0x852b
#define IDM_PROJECT_DEFAULT_PROJ        0x852c
#define IDM_PROJECT_SCC_GET             0x852D
#define IDM_DUMP_HEAP               	0x852E

#define IDM_PROJECT_EDIT               	0x852f

// Menu ids for exe finder tool in debug general page
#define IDM_BROWSE_FOR_DEBUG_EXE		0x8530
#define IDM_USE_TESTCONTAINER			0x8531
#define IDM_USE_WEBBROWSER				0x8532

// -> custom build tool output specification macros ->
#define IDM_BLDTOOL_DIRMACRO1           0x8550
#define IDM_BLDTOOL_DIRMACRO2           0x8551
#define IDM_BLDTOOL_DIRMACRO3           0x8552
#define IDM_BLDTOOL_DIRMACRO4           0x8553
#define IDM_BLDTOOL_DIRMACRO5           0x8554
#define IDM_BLDTOOL_DIRMACRO6           0x8555
#define IDM_BLDTOOL_DIRMACRO7           0x8556
#define IDM_BLDTOOL_DIRMACRO8           0x8557
#define IDM_BLDTOOL_FILEMACRO1          0x8558
#define IDM_BLDTOOL_FILEMACRO2          0x8559
#define IDM_BLDTOOL_FILEMACRO3          0x855a
#define IDM_BLDTOOL_FILEMACRO4          0x855b
#define IDM_BLDTOOL_FILEMACRO5          0x855c
#define IDM_BLDTOOL_FILEMACRO6          0x855d

#define IDM_BLDTOOL_FIRSTMACRO          IDM_BLDTOOL_DIRMACRO1
#define IDM_BLDTOOL_LASTMACRO           IDM_BLDTOOL_FILEMACRO6
// <- custom build tool output specification macros <-

#define IDM_INSERT_FILES_POP                    0x855e
#define IDM_CTL_PROJ_TARGET                     0x85F0
#define IDM_PROJ_LAST                           0x85FF

/////////////////////////////////////////////////////////////////////
// VRES Commands
//
#define IDM_FILE_SETINCLUDES        0x8600
#define IDM_FILE_INSTALLCONTROLS    0x8601
#define IDM_EDIT_SYMBOLS            0x8602
#define IDM_RESOURCE_NEW            0x8603
#define IDM_RESOURCE_OPEN           0x8604
#define IDM_RESOURCE_OPENBINARY     0x8605
#define IDM_RESOURCE_IMPORT         0x8606
#define IDM_RESOURCE_EXPORT         0x8607
#define IDMB_NEW_DIALOG             0x860A
#define IDMB_NEW_CURSOR             0x860B
#define IDMB_NEW_ICON               0x860C
#define IDMB_NEW_BITMAP             0x860D
#define IDMB_NEW_MENUBAR            0x860E
#define IDMB_NEW_STRINGTABLE        0x860F
#define IDMB_NEW_ACCTABLE           0x8610
#define IDMB_NEWRC                  0x8611
#define IDMB_NEW_VERSION            0x8612
#define ID_CANCEL_EDIT              0x8613
#define IDM_RESOURCE_ADD            0x8614
#define IDM_RESOURCE_NEWCOPY        0x8615
#define IDMB_NEW_TOOLBAR            0x8616
#define IDM_RESOURCENODE_SAVE       0x8617

// special commands for specific VRES resource types
#define IDM_FIND_STRING             0x8650
#define IDM_FIND_NEXT               0x8651
#define IDM_NEW_STRING              0x8652
#define IDM_NEW_ACCELERATOR         0x8653
#define IDM_NEW_STRINGBLOCK         0x8654
#define IDM_DELETE_STRINGBLOCK      0x8655
#define IDMY_TEST                   0x8656
#define IDM_SETTABORDER             0x8657
#define IDMY_ALIGNLEFT              0x8658
#define IDMY_ALIGNRIGHT             0x8659
#define IDMY_ALIGNTOP               0x865A
#define IDMY_ALIGNBOTTOM            0x865B
#define IDMY_SPACEACROSS            0x865C
#define IDMY_SPACEDOWN              0x865D
#define IDM_BUTTONRIGHT             0x865E
#define IDM_BUTTONBOTTOM            0x865F
#define IDMY_MAKESAMEWIDTH          0x8660
#define IDMY_MAKESAMEHEIGHT         0x8661
#define IDMY_MAKESAMEBOTH           0x8662
#define IDM_SIZETOTEXT              0x8663
#define IDM_GRIDSETTINGS            0x8664
#define IDMB_SHOWGRID               0x8665
#define IDM_VIEWASPOPUP             0x8666

#ifndef IMAGE_EDITOR_BROKEN_OUT
#define ID_FILE_NEW_BITMAP                      0x830A
#define IDM_TOOLBAR_WIZARD                      0x8608
#define IDMY_PICKCOLOR              0x8667
#define IDM_FLIPBSHH                0x8668
#define IDM_FLIPBSHV                0x8669
#define IDM_MAGNIFY                 0x866A
#define IDM_NEWDEVIMG               0x866B
#define IDM_OPENDEVIMG              0x866C
#define IDM_DELDEVIMG               0x866D
#define IDM_INVERTCOLORS            0x866E
#define IDM_TGLOPAQUE               0x866F
#define IDM_EDITCOLORS              0x8670
#define IDM_LOADCOLORS              0x8671
#define IDM_SAVECOLORS              0x8672
#define IDM_SETHOTSPOT              0x8673
#define IDM_ALIGNCVERT              0x8674
#define IDM_ALIGNCHORZ              0x8675
#define IDMY_CENTERVERT             0x8676
#define IDMY_CENTERHORZ             0x8677
#define IDM_INSTALLCONTROLS         0x8678
#define IDMY_CHECKHOTKEYS           0x8679
#define IDMZ_IMGSEPARATOR           0x8680
#define IDMX_ZOOMIN                 0x8681
#define IDMX_ZOOMOUT                0x8682
#define IDMX_SMALLERBRUSH           0x8683
#define IDMX_LARGERBRUSH            0x8684
#define IDMB_RECTTOOL               0x8685
#define IDMB_FRECTTOOL              0x8686
#define IDMB_ELLIPSETOOL            0x8687
#define IDMB_FELLIPSETOOL           0x8688
#define IDMZ_BRUSHTOOL              0x8689
#define IDMB_FILLTOOL               0x868A
#define IDMB_LINETOOL               0x868B
#define IDMB_PICKTOOL               0x868C
#define IDMX_PREVCOLOR              0x868D
#define IDMX_NEXTCOLOR              0x868E
#define IDMX_PREVECOLOR             0x868F
#define IDMB_3DRECTTOOL             0x8690
#define IDMX_NEXTECOLOR             0x8691
#define IDMX_TEXTTOOL               0x8692
#define IDMB_CURVETOOL              0x8693
#define IDMB_ORECTTOOL              0x8694
#define IDMB_ORNDRECTTOOL           0x8695
#define IDMB_OELLIPSETOOL           0x8696
#define IDMB_POLYGONTOOL            0x8697
#define IDMB_FPOLYGONTOOL           0x8698
#define IDMB_OPOLYGONTOOL           0x8699
#define IDMB_PICKRGNTOOL            0x869A
#define IDMX_OUTLINEBSH             0x869B
#define IDMB_AIRBSHTOOL             0x869C
#define IDMX_SMALLBRUSH             0x869D
#define IDMX_SEL2BSH                0x869E
#define IDMB_RNDRECTTOOL            0x869F
#define IDMB_FRNDRECTTOOL           0x86A1
#define IDMB_PENCILTOOL             0x86A2
#define IDMB_ERASERTOOL             0x86A3
#define IDMB_ZOOMTOOL               0x86A4
#define IDMB_CBRUSHTOOL             0x86A5
#define IDM_GRIDOPT                 0x86A6
#define IDMX_SHOWTILEGRID           0x86A7
#define IDM_ROT90                   0x86A8
#define IDMX_OTHERPANE              0x86A9
#define IDM_SHOWIMAGEGRID           0x86AA
#define IDM_WINDOWRECTTOOL          0x86B3
#endif  // IMAGE_EDITOR_BROKEN_OUT

#define IDMB_SHOWRULER              0x86AB
#define IDMB_TOGGLEGUIDES           0x86AC
#define IDM_GUIDE_ATTACH_LEFT       0x86AD
#define IDM_GUIDE_ATTACH_RIGHT      0x86AE
#define IDM_GUIDE_ATTACH_PROPORTIONAL 0x86AF
#define IDM_GUIDE_CLEAR             0x86B0
#define IDM_GUIDE_CLEAR_ALL         0x86B1
#define IDMY_FLIPDIALOG             0x86B4

#define IDM_CTL_POSFIRST                        0x86B5
    #define IDM_CTL_MOVELEFT                        0x86B5
    #define IDM_CTL_MOVEUP                          0x86B6
    #define IDM_CTL_MOVERIGHT                       0x86B7
    #define IDM_CTL_MOVEDOWN                        0x86B8
#define IDM_CTL_SIZEFIRST                       0x86B9
    #define IDM_CTL_SIZELEFT                        0x86B9
    #define IDM_CTL_SIZEUP                          0x86BA
    #define IDM_CTL_SIZERIGHT                       0x86BB
    #define IDM_CTL_SIZEDOWN                        0x86BC
#define IDM_CTL_POSLAST                         0x86BC

#define IDM_CTL_HOTSPOT_LOC         0x86F0
#define IDM_CTL_INSERT              0x86F1

// Espresso commands for dialog editor
#define IDM_REVERT_SIZES            0x86F2
#define IDM_REVERT_COORDINATES      0x86F3
#define IDM_REVERT_STYLES           0x86F4
#define IDMY_AUTOLAYOUT_GROW        0x86F5
#define IDMY_AUTOLAYOUT_OPTIMIZE    0x86F6
#define IDMY_AUTOLAYOUT_NORESIZE    0x86F7

// Wizard Bar New Event Handler command for Dialog controls
#define IDM_WIZBARU_EVENTS                      0x86F8
// Wizard Bar Help Id (Generic) here because makehm needs non-releaive hex number bobz
#define IDM_WIZBARU_HELP                        0x86F9

// insert Activex control w/out wrapper class - dialog editor only
#define IDM_CTL_INSERT_RES           0x86FA

/////////////////////////////////////////////////////////////////////
// VCPP Commands
//
// Many of the standard ones (FileOpen, etc) now use the MFC
// predefined IDs.
//
// REVIEW: This block is a hodge-podge of Edit, Debug, Browse,
//         Shell, Output window, obsolete, and shared commands.
//
#define IDM_FILE_SAVE_ALL               0x8700
#define ID_EDIT_FIND_DLG        0x8701 // invoke find dialog
#define IDM_EDIT_GREP                   0x8702
//#define IDM_EDIT_FINDMATCH              0x8703  note: now in pkgs\edit\resource.h
#define IDM_EDIT_READONLY               0x8704
#define ID_CUT_LINE             0x8705
#define ID_EDIT_FIND_NEXT       0x8706
#define ID_EDIT_FIND_PREV       0x8707
#define ID_EDIT_FIND_COMBO      0x8708 // activate find combo
#define IDM_ADDTOPROJECT                0x8709
#define IDM_EDIT_CLEAR_OUTPUT   0x870A
#define IDM_FILE_SEND                   0x870B
#define IDM_FILE_REVERT                 0x870C
#define IDM_FILE_LIST_DOCS              0x870D
#define IDM_EDIT_TOGGLE_CASE            0x870E
#define IDM_EDIT_TOGGLE_RE              0x870F
#define IDM_EDIT_TOGGLE_WORD            0x8710
#define IDM_EDIT_TOGGLE_SEARCH_ALL_DOCS 0x872E

// DEBUG
#define IDM_GOTO_LINE                   0x8711
#define IDM_VIEW_MIXEDMODE              0x8712
#define IDM_GOTO_DISASSY                0x8713
#define IDM_GOTO_SOURCE                 0x8714

// OUTPUT
#define IDM_GOTO_CURRENTERROR   0x8715
#define IDM_VIEW_NEXTERROR              0x8716
#define IDM_VIEW_PREVIOUSERROR  0x8717

// EDIT
#define IDM_VIEW_TOGGLETAG              0x8718
#define IDM_VIEW_NEXTTAG                0x8719
#define IDM_VIEW_PREVIOUSTAG    0x871A
#define IDM_VIEW_CLEARALLTAGS   0x871B
#define IDM_GOTO_FILE                   0x871C

// OUTPUT
#define IDM_VIEW_OUTTOOLS               0x871D

// EDIT (for now)
#define IDM_BOOKMARKS                   0x871E

// ??
#define IDM_GOTO_CODE                   0x871F

// BROWSE
#define IDM_BROWSE_GOTOREF              0x8720
#define IDM_BROWSE_GOTODEF              0x8721
#define IDM_BROWSE_NEXT                 0x8722
#define IDM_BROWSE_PREVIOUS             0x8723
#define IDM_BROWSE_OPEN                 0x8724
#define IDM_BROWSE_POP                  0x8725
#define IDM_BROWSE_SYM                  0x8726
#define IDM_BROWSE_OUTLINE              0x8727
#define IDM_BROWSE_FGRAPH               0x8728
#define IDM_BROWSE_CGRAPH               0x8729
#define IDM_BROWSE_FGRAPH_R             0x872A
#define IDM_BROWSE_CGRAPH_R             0x872B
#define IDM_BROWSE_QUERY                0x872C
#define IDM_BROWSE_FILES                0x872D
// note: 0x872E is used above by the shell

// DEBUG
#define IDM_DEBUG_RADIX                 0x872F
#define IDM_RUN_GO                      0x8730
#define IDM_RUN_RESTART                 0x8731
#define IDM_RUN_STOPDEBUGGING           0x8732
#define IDM_RUN_BREAK                   0x8733
#define IDM_RUN_TOCURSOR                0x8734
#define IDM_RUN_TRACEINTO               0x8735
#define IDM_RUN_STEPOVER                0x8736
#define IDM_RUN_STOPAFTERRETURN         0x8737
#define IDM_RUN_CALLS                   0x8738
#define IDM_RUN_SETBREAK                0x8739
#define IDM_RUN_QUICKWATCH              0x873A
#define IDM_RUN_EXCEPTIONS              0x873B
#define IDM_RUN_THREADS                 0x873C
//      IDM_RUN_FIBERS                          0x876B
#define IDM_RUN_ATTACH_TO_ACTIVE        0x873D
#define IDM_RUN_COVER_TOGGLE            0x873E
#define IDM_RUN_COVER_CLEAR             0x873F
#define IDM_RUN_SETNEXTSTMT             0x8740
#define IDM_RUN_CLEARALLBREAK           0x8741
#define IDM_RUN_SRC_TRACEINTO           0x8742
#define IDM_RUN_SRC_STEPOVER            0x8743
#define IDM_RUN_FLIPHACK                0x8744 // not used in release build
#define IDM_RUN_REMOTEDEBUGGER          0x8745
#define IDM_RUN_JIT_GO                  0x8746
#define IDM_DEBUG_ACTIVE                0x8747
#define IDM_DEBUG_UPDATEIMAGE			0x8748
#define IDM_RUN_TRACEFUNCTION           0x8749
#define IDM_RUN_SRC_TRACEFUNCTION       0x874A
#define IDM_RUN_ENABLEBREAK             0x874B
#define IDM_RUN_TOGGLEBREAK             0x874C
#define IDM_RUN_DISABLEALLBREAK         0x874D
#define IDM_MEMORY_NEXTFORMAT           0x874E
#define IDM_MEMORY_PREVFORMAT           0x874F
#define IDM_RUN_PROFILE                 0x8750  // WinslowF Adding profiler

// OUTPUT
#define IDM_OUTPUT_EXECTOOL             0x8750
#define IDM_OUTPUT_CLEAR                0x8751
#define IDM_OUTPUT_GOTO_TAG             0x8752

// DEBUG
#define IDM_DEBUG_SHOWIP                0x8753
#define IDM_DEBUG_GOTOSOURCE    0x8754
#define IDM_DBGSHOW_FLOAT               0x8755
#define IDM_DBGSHOW_STACKTYPES  0x8756
#define IDM_DBGSHOW_STACKVALUES 0x8757
#define IDM_DBGSHOW_SOURCE              0x8758
#define IDM_DBGSHOW_MEMBYTE             0x8759
#define IDM_DBGSHOW_MEMSHORT    0x875A
#define IDM_DBGSHOW_MEMLONG             0x875B
#define IDM_DBGSHOW_CODEBYTES           0x875C
#define IDM_DBGSHOW_MEMORY_BAR          0x875F

// EDIT
#define IDM_INDENT              0x8760
#define IDM_UNINDENT            0x8761

// DEBUG
#define IDM_DBGSHOW_VARS_BAR    0x8762

// EDIT
#define IDM_KEYBOARDINDENT      0x8763
#define IDM_KEYBOARDUNINDENT    0x8764

// SHELL
#define IDM_TOOL_STOP           0x8765
#define IDM_FIRST_TOOL          0x8766

// EDIT
#define IDM_MACRO_RECORD                0x8767
#define IDM_MACRO_PLAY                  0x8768
#define IDM_MACRO_PAUSE                 0x8769
#define IDM_MACRO_STOP                  0x876A

#define IDM_RUN_FIBERS                                  0x876B
// OUTPUT
//#define IDM_WINDOW_ERRORS               0x876C // AXE(CFlaat) doesn't appear to be needed

// ??
#define IDM_WINDOWCHILD         0x876D

// SHELL
#define IDM_HELP_MSPROD                         0x8774
#define IDM_HELP_CONTENTS                       0x8776
#define IDM_HELP_INDEX                          0x8777
#define IDM_HELP_SEARCH                         0x8778
#define IDM_HELP_EXTHELP                        0x8779
#define IDM_HELP_TIPOFTHEDAY            0x877b

// EDIT
#define IDM_REFORMAT                                    0x877f
#define IDM_UPPERCASE                   0x8780
#define IDM_NEWLINE                     0x8781
#define IDM_NEXTLINE                    0x8782
#define IDM_NEWLINEABOVE                0x8783
#define IDM_LOWERCASE                   0x8784
#define IDM_CLEARSELECTION              0x8785
#define IDM_SCROLL_LINEUP               0x8786
#define IDM_SCROLL_LINEDOWN             0x8787
#define ID_EDIT_FIND_NEXTCURRENTWORD    0x8788
#define ID_EDIT_FIND_PREVCURRENTWORD    0x8789
#define IDM_EDIT_DELETEWORDRIGHT        0x878a
#define IDM_EDIT_DELETELEFT             0x878b
#define IDM_FIND_IFDEF_UP               0x878c
#define IDM_FIND_IFDEF_DOWN             0x878d
#define IDM_EXTEND_FIND_IFDEF_UP        0x878e
#define IDM_EXTEND_FIND_IFDEF_DOWN      0x878f
#define IDM_CURSOR_STARTNEXTLINE        0x8790
#define ID_COL_SELECT                   0x8791
#define IDM_INSERT                                              0x8792

// DEBUG
#define ID_RUN_GO                               0x8793
#define ID_RUN_RESTART                          0x8794
#define ID_RUN_TOCURSOR                         0x8795
#define ID_RUN_TRACEINTO                        0x8796
#define ID_RUN_STEPOVER                         0x8797
#define ID_RUN_STOPAFTERRETURN                  0x8798
#define ID_RUN_SRC_TRACEINTO                    0x8799
#define ID_RUN_SRC_STEPOVER                     0x879a
#define ID_RUN_STOPDEBUGGING                    0x879b

// EDIT
#define IDM_VIEW_EPSDROPBOOKMARK                0x879c
#define IDM_VIEW_EPSNEXTBOOKMARK                0x879d
#define IDM_VIEW_BRF_DROPBOOKMARK1              0x879e
#define IDM_VIEW_BRF_DROPBOOKMARK2              0x879f
#define IDM_VIEW_BRF_DROPBOOKMARK3              0x87a0
#define IDM_VIEW_BRF_DROPBOOKMARK4              0x87a1
#define IDM_VIEW_BRF_DROPBOOKMARK5              0x87a2
#define IDM_VIEW_BRF_DROPBOOKMARK6              0x87a3
#define IDM_VIEW_BRF_DROPBOOKMARK7              0x87a4
#define IDM_VIEW_BRF_DROPBOOKMARK8              0x87a5
#define IDM_VIEW_BRF_DROPBOOKMARK9              0x87a6
#define IDM_VIEW_BRF_DROPBOOKMARK10             0x87a7
#define ID_RUN_TRACEFUNCTION                    0x87a8
#define ID_RUN_SRC_TRACEFUNCTION                0x87a9

// DEBUG
#define IDM_ACTIVATE_SRCFIRST                                   0x87B0
#define IDM_ACTIVATE_OUTPUT                     0x87B0
#define IDM_ACTIVATE_WATCH                      0x87B1
#define IDM_ACTIVATE_VARIABLES                  0x87B2
#define IDM_ACTIVATE_REGISTERS                  0x87B3
#define IDM_ACTIVATE_MEMORY                     0x87B4
#define IDM_ACTIVATE_CALLSTACK                  0x87B5
#define IDM_ACTIVATE_DISASSEMBLY                0x87B6
#define IDM_ACTIVATE_SRCLAST                                    0x87BF

#define IDM_TOGGLE_SRCFIRST                                             0x87B0
#define IDM_TOGGLE_OUTPUT                       0x87C0
#define IDM_TOGGLE_WATCH                        0x87C1
#define IDM_TOGGLE_VARIABLES                    0x87C2
#define IDM_TOGGLE_REGISTERS                    0x87C3
#define IDM_TOGGLE_MEMORY                       0x87C4
#define IDM_TOGGLE_CALLSTACK                    0x87C5
#define IDM_TOGGLE_DISASSEMBLY                  0x87C6
#define IDM_TOGGLE_SRCLAST                                              0x87CF

// Shell
#define IDM_HELP_MOW_FIRST                                              0x87D0
#define IDM_HELP_MOW_FREESTUFF                                  0x87D0
#define IDM_HELP_MOW_PRODUCTNEWS                                0x87D1
#define IDM_HELP_MOW_FAQ                                                0x87D2
#define IDM_HELP_MOW_ONLINESUPPORT                              0x87D3
#define IDM_HELP_MOW_DEVONLYHOMEPAGE                    0x87D4
#define IDM_HELP_MOW_SENDFEEDBACK                               0x87D5
#define IDM_HELP_MOW_BESTOFTHEWEB                               0x87D6
#define IDM_HELP_MOW_SEARCHTHEWEB                               0x87D7
#define IDM_HELP_MOW_WEBTUTORIAL                                0x87D8
#define IDM_HELP_MOW_MSHOMEPAGE                                 0x87D9
#define IDM_HELP_MOW_LAST                                               0x87DF

// DEBUG
#define IDM_CTL_LOCAL_FUNCS                     0x6400
#define IDM_CTL_WATCH_EDIT                      0x6401
#define IDM_CTL_WATCH_DELETE                    0x6402

// BROWSE
#define IDM_CTL_BROWSE_CLASS                    0x6403
#define IDM_CTL_BROWSE_FUNCMEM                  0x6404
#define IDM_CTL_BROWSE_DATAMEM                  0x6405
#define IDM_CTL_BROWSE_MACRO                    0x6406
#define IDM_CTL_BROWSE_TYPE                     0x6407
#define IDM_CTL_BROWSE_FUNCS                    0x6408
#define IDM_CTL_BROWSE_DATA                     0x6409
#define IDM_CTL_MEMORY_EDIT                     0x640A
#define IDM_CTL_VARS_FUNCS                      0x640B

// PARSER
#define IDM_PARSER_PARSE                0x87F0
#define IDM_PARSER_INFO                 0x87F1
#define IDM_PARSER_PARSEPROJ    0x87F2
#define IDM_PARSER_OPENDBASE    0x87F3
#define IDM_PARSER_CLOSEDBASE   0x87F4
#define IDM_PARSER_COPYTOFILE	0x87F5

// EDIT
#define ID_DELETE_LINE                  0x8800
#define ID_EDIT_REPLACE_DLG             0x8801
#define ID_NEXT_WINDOW          0x8802
#define ID_PREV_WINDOW          0x8803
#define ID_TOGGLE_RESTORE               0x8806
#define ID_SEARCH_AGAIN                 0x8807

#define IDM_CURSOR_CHARLEFT     0x8808
#define IDM_CURSOR_CHARRIGHT    0x8809
#define IDM_CURSOR_LINEUP               0x880A
#define IDM_CURSOR_LINEDOWN             0x880B
#define IDM_CURSOR_WORDLEFT             0x880C
#define IDM_CURSOR_WORDRIGHT    0x880D
#define IDM_CURSOR_SCREENUP             0x880E
#define IDM_CURSOR_SCREENDOWN   0x880F
#define IDM_EPSILON_ESCAPE              0x8810
#define IDM_CURSOR_LINESTART    0x8811
#define IDM_CURSOR_LINEEND              0x8812
#define IDM_CURSOR_FILESTART    0x8813
#define IDM_CURSOR_FILEEND              0x8814
#define IDM_CURSOR_BEGINPANE    0x8815
#define IDM_CURSOR_ENDPANE              0x8816
#define IDM_CURSOR_LEFTPANE             0x8817
#define IDM_CURSOR_RIGHTPANE    0x8818
#define IDM_CURSOR_BEGINLINE    0x8819
#define IDM_CURSOR_BRIEFHOME    0x881A
#define IDM_CURSOR_BRIEFEND             0x881B
#define IDM_TABIFYREGION        0x881C
#define IDM_UNTABIFYREGION      0x881D
#define IDM_HIGHLIGHTREGION             0x881E
#define IDM_EPSILON_INDENT_REGION       0x881F
#define IDM_EPSILON_KILLREGION  0x8820
#define IDM_EDIT_DELETEBRIEFEOLN        0x8821
#define IDM_EPSILON_FWDPARAGRAPH        0x8822
#define IDM_EPSILON_BCKPARAGRAPH        0x8823
#define IDM_EPSILON_FWDSENTENCE 0x8824
#define IDM_EPSILON_BCKSENTENCE 0x8825
#define IDM_EPSILON_DELSENTENCE 0x8826
#define IDM_EDIT_DELETEBRIEFBOLN        0x8827
#define IDM_EPSILON_TRANSPOSECH 0x8828
#define IDM_EPSILON_TRANSPOSEWD 0x8829
#define IDM_EPSILON_TRANSPOSELN 0x882A
#define IDM_EPSILON_CAPWORD             0x882B
#define IDM_EPSILON_LOWERWORD   0x882C
#define IDM_EPSILON_UPPERWORD   0x882D
#define ID_CMD_INVALID                  0x882E
#define IDM_NEWLINEBELOW                0x882F
#define ID_EDIT_REDOCHANGES             0x8830
#define ID_EDIT_UNDOCHANGES             0x8831
#define IDM_EPSILON_MARKPARAGRAPH       0x8832
#define IDM_EPSILON_CENTERWINDOW        0x8833
#define IDM_EPSILON_DELHORZSPACE        0x8834
#define IDM_EPSILON_DELBLANKLINES       0x8835
#define IDM_EPSILON_APPENDNEXTKILL      0x8839
#define IDM_EPSILON_TOINDENT    0x883A
#define IDM_FORMAT_REGION               0x883B
#define IDM_INDENT_UNDER                0x883C
#define IDM_REGEX_SRCH_FWD              0x883E
#define IDM_REGEX_SRCH_BCK              0x883F

// DEBUG
#define IDM_BP_CURRENT_ADDR                             0x8840
#define IDM_BP_CURRENT_LINE                             0x8841
#define IDM_BP_CURRENT_FUNC                             0x8842
#define IDM_BP_ADVANCED                                 0x8843

// EDIT
#define ID_EDIT_RE_REPLACE                              0x8844
#define IDM_SEARCH_ISEARCH_FWD                  0x8845
#define IDM_SEARCH_ISEARCH_BACK                 0x8846
#define IDM_SEARCH_ISEARCH_REFWD        0x8847
#define IDM_SEARCH_ISEARCH_REBACK       0x8848
#define IDM_ISEARCH_ISEARCH_FWD         0x8849
#define IDM_ISEARCH_ISEARCH_BACK        0x884A
#define IDM_ISEARCH_TOGGLE_CASE         0x884B
#define IDM_ISEARCH_TOGGLE_WORD         0x884C
#define IDM_ISEARCH_TOGGLE_REGEX        0x884D
#define ID_QUOTED_INSERT                                0x884E
#define ID_CHANGE_PANE_UP                               0x884F
#define ID_CHANGE_PANE_DOWN                             0x8850
#define ID_CHANGE_PANE_LEFT                             0x8851
#define ID_CHANGE_PANE_RIGHT                    0x8852
#define ID_DELETE_ROW_UP                                0x8853
#define ID_DELETE_ROW_DOWN                              0x8854
#define ID_DELETE_COL_LEFT                              0x8855
#define ID_DELETE_COL_RIGHT                             0x8856
#define ID_LINE_TO_TOP                                  0x8857
#define ID_LINE_TO_BOTTOM                               0x8858

// SHELL??
// UNUSED	0x8859 - 0x8868

// EDIT
#define ID_EDIT_BACKWARD_LEVEL                  0x8869
#define ID_EDIT_FORWARD_LEVEL                   0x8870
#define ID_EDIT_KILL_LEVEL                      0x8871
#define ID_EDIT_BACKWARD_KILL_LEVEL             0x8872

// RES??
#define IDM_STRING_TO_RESOURCE                  0x8873

// EDIT ("Advanced" menu)
#define IDM_MENU_EDIT_ADVANCED                                  0x8874

// HTM commands squatting in the edit package
#define IDM_HTMLX_SCUSEWIZARD                                   0x8875
#define IDM_HTMLX_SCINSERTCONTROL                               0x8876
#define IDM_HTMLX_SCINSERTHTMLLAYOUT                    0x8877
#define IDM_HTMLX_SCSCRIPTWIZARD                                0x8878
#define IDM_HTMLX_SCEDITCONTROL                         0x8879
#define IDM_HTMLX_SCEDITDESIGNCONTROL                   0x887a
#define IDM_HTMLX_SCEDITHTMLLAYOUT                              0x887b
#define IDM_HTMLX_INTOHTMLSUBMENU                               0x887c

// AUTO_COMPLETE command squatting in the edit package
#define ID_LIST_MEMBERS					0x8880
#define ID_PARAMETER_INFO				0x8881
#define ID_TYPE_INFO					0x8882
#define ID_COMPLETE_WORD				0x8883

// DEBUG (Edit and Continue)
#define IDM_DEBUG_UPDATEIMAGE_TOGGLE	0x8890

/////////////////////////////////////////////////////////////////////
// MSIN Commands
//
#define IDM_MSIN                        0x8a00
#define ID_SEARCH                       0x8a01
#define ID_QUERY_RESULTS                0x8a02
#define ID_SELECT_TITLE                 0x8a10
#define ID_SELECT_SUBSET                0x8a11
#define ID_FIND_FIND                    0x8a12
#define ID_FIND_KEYWORD                 0x8a13
#define ID_RESULTS_FIND                 0x8a14
#define ID_RESULTS_HISTORY              0x8a15
#define ID_BACK                         0x8a16
#define ID_NEXT                         0x8a17
#define ID_PREV                         0x8a18
#define ID_FIND_NEXT                    0x8a19
#define ID_BOOK_NEXT                    0x8a1a
#define ID_FIND_PREV                    0x8a1b
#define ID_BOOK_PREV                    0x8a1c
#define ID_PRINT_TOPIC                  0x8a1d
#define ID_PRINT_TOC                    0x8a1e
#define ID_SYNC                         0x8a1f
#define ID_TOGGLE_HIGHLIGHTS            0x8a20
#define ID_ADD_BOOKMARK                 0x8a21
#define ID_EDIT_BOOKMARK                0x8a22
#define ID_WHATSNEW                     0x8a24
#define ID_COPYTOPIC                    0x8a25
#define ID_SELECTION_RIGHT              0x8a26
#define ID_SELECTION_LEFT               0x8a27
#define ID_SELECTION_UP                 0x8a28
#define ID_SELECTION_DOWN               0x8a29
#define ID_SELECTION_ENTIRE             0x8a2a
#define ID_SEEALSO                      0x8a2b
#define ID_FIRST_TOPIC                  0x8a2c
#define ID_HOME_SCREEN                  0x8a2d
#define ID_EDIT_HELPBOOKMARKS           0x8a2e
#define ID_EDIT_ANNOTATION              0x8a30
#define ID_ADD_ANNOTATION               0x8a31
#define ID_NEXT_BOOKMARK                0x8a32
#define ID_PREV_BOOKMARK                0x8a33
#define ID_NEXT_LIST                    0x8a34
#define ID_PREV_LIST                    0x8a35
#define ID_SHOWBAR                      0x8a37
#define ID_SHOWNSR                      0x8a38
#define ID_DISPLAY_OPTIONS              0x8a39
#define ID_FIND_OPTIONS                 0x8a3a
#define ID_DEFINE_SUBSETS               0x8a3b
#define ID_SWITCHMVB                    0x8a3c
#define ID_NEXT_BOOKMARK_LIST           0x8a3d
#define ID_PREV_BOOKMARK_LIST           0x8a3e
#define ID_HELP_QUERY_RESULTS           0x8a3f
#define ID_HELP_BOOKMARK_LIST           0x8a40
#define ID_NEXT_JUMP                    0x8a41
#define ID_SEEALSOP                     0x8a42
#define ID_BACKP                        0x8a43
#define ID_HELPP                        0x8a44
#define ID_TOPIC                        0x8a45
#define ID_MSIN_OPEN                    0x8a46
#define ID_MSIN_ABOUT                   0x8a47
#define ID_NEXT_HIGHLIGHT               0x8b48
#define ID_PREV_HIGHLIGHT               0x8b49
#define ID_MSIN_PRINT_SETUP             0x8b4a
#define ID_HELP_KEYBOARD                0x8a4b
#define IDM_TOGGLE_TOPICWIN             0x8a4c
#define ID_SET_SUBSET                   0x8a4d
#define ID_EDIT_SELECTALL_POPUP         0x8a4e
#define ID_PREV_JUMP                    0x8a4f
#define ID_HELP_WEB                     0x8a50
#define ID_HELP_ESPRESSO                0x8a51

//////////////////////////////////////////////////////////
//
// New IV command defines here.
//
#define ID_IV_HOME                         MIN_IV_COMMAND_ID + 1
#define ID_IV_URL_SF                       MIN_IV_COMMAND_ID + 2
#define ID_IV_OPEN_URL                     MIN_IV_COMMAND_ID + 3 
#define ID_IV_SYNC                         MIN_IV_COMMAND_ID + 4 
#define ID_IV_BACK                         MIN_IV_COMMAND_ID + 5 
#define ID_IV_NEXT                         MIN_IV_COMMAND_ID + 6 
#define ID_IV_PREV                         MIN_IV_COMMAND_ID + 7
#define ID_IV_FORWARD                      MIN_IV_COMMAND_ID + 8
#define ID_IV_REFRESH                      MIN_IV_COMMAND_ID + 9
#define ID_IV_STOP_DOWNLOAD                MIN_IV_COMMAND_ID + 10
#define ID_IV_LIST_BOOKMARKS               MIN_IV_COMMAND_ID + 11
#define ID_IV_ADD_BOOKMARK                 MIN_IV_COMMAND_ID + 12
#define ID_IV_PREV_BOOKMARK                MIN_IV_COMMAND_ID + 13
#define ID_IV_NEXT_BOOKMARK                MIN_IV_COMMAND_ID + 14
#define ID_IV_DEF_SUBSET                   MIN_IV_COMMAND_ID + 15
#define ID_IV_SELECT_SUBSET                MIN_IV_COMMAND_ID + 16
#define ID_IV_SELECT_TOC_SUBSET_COMBO      MIN_IV_COMMAND_ID + 17
#define ID_IV_SEARCH                       MIN_IV_COMMAND_ID + 18
#define ID_IV_RESULTS_LIST                 MIN_IV_COMMAND_ID + 19
#define ID_IV_TOPIC_WINDOW                 MIN_IV_COMMAND_ID + 20
#define ID_IV_NEXT_LISTITEM                MIN_IV_COMMAND_ID + 21
#define ID_IV_PREV_LISTITEM                MIN_IV_COMMAND_ID + 22
#define ID_IV_QUERY                        MIN_IV_COMMAND_ID + 23
#define ID_IV_KEYWORD_INDEX                MIN_IV_COMMAND_ID + 24
#define ID_IV_SEARCH_LIST                  MIN_IV_COMMAND_ID + 25
#define ID_IV_NEXT_SEARCH                  MIN_IV_COMMAND_ID + 26
#define ID_IV_PREV_SEARCH                  MIN_IV_COMMAND_ID + 27
#define ID_IV_QUERY_LIST                   MIN_IV_COMMAND_ID + 28
#define ID_IV_NEXT_QUERY                   MIN_IV_COMMAND_ID + 29
#define ID_IV_PREV_QUERY                   MIN_IV_COMMAND_ID + 30
#define ID_IV_RESULTS_LIST_SHOWDETAIL      MIN_IV_COMMAND_ID + 31
#define ID_IV_RESULTS_LIST_SHOWLIST        MIN_IV_COMMAND_ID + 32
#define ID_IV_PRINT_TOC                    MIN_IV_COMMAND_ID + 33
#define ID_IV_HELP_CONTENTS                MIN_IV_COMMAND_ID + 34
#define ID_IV_HELP_ABOUT                   MIN_IV_COMMAND_ID + 35
#define ID_IV_DOWNLOADCOMPLETE             MIN_IV_COMMAND_ID + 36
#define ID_IV_FONT_SIZE                    MIN_IV_COMMAND_ID + 37
#ifdef __DEVHELP98__
#define ID_HELP98_KEYWORDS					MIN_IV_COMMAND_ID + 38
#endif

//////////////////////////////////////////////////////////////
//
// The following commands are handled by the MSIN macro system
//
#define IDM_MSIN_MACRO_FIRST    0x8b00  //ID of first one
#define IDM_NEXT_HIGHLIGHT              0x8b00
#define IDM_PREV_HIGHLIGHT              0x8b01
#define IDM_ANNOTATION                  0x8b02
#define IDM_MSIN_MACRO_LAST             0x8b02  //ID of last one

/////////////////////////////////////////////////////////////////////
// Classview/Wizard Commands
//
// TODO(davidga): reconcile this with the CLASSVIEW_COMMAND_ID range
// possible creating a CLASSVIEW_STRING_ID range
#define IDM_CLASSVIEW_FIRST             (MIN_CLASSVIEW_COMMAND_ID)
#define IDM_ADDCLASS                    (IDM_CLASSVIEW_FIRST+0)
#define IDM_ADDATLCOMP                  (IDM_CLASSVIEW_FIRST+1)
#define IDM_GALLERY                     (IDM_CLASSVIEW_FIRST+2)
#define IDMY_CLASSWIZARD                (IDM_CLASSVIEW_FIRST+3)
#define IDM_CLASSVIEW_LAST              (IDM_CLASSVIEW_FIRST+3)


#define IDM_WIZBARU_CLASS               (IDM_CLASSVIEW_LAST+1)
#define IDM_WIZBARU_OBJECT              (IDM_CLASSVIEW_LAST+2)
#define IDM_WIZBARU_TARGET              (IDM_CLASSVIEW_LAST+3)
#define IDM_WIZBARU_ACTION              (IDM_CLASSVIEW_LAST+4)

//  wizard bar commands that can be assigned to keys
#define ID_WIZBARU_COMBO_CLASS          (IDM_CLASSVIEW_LAST+5)  // activate the class combo
#define ID_WIZBARU_COMBO_OBJECT         (IDM_CLASSVIEW_LAST+6)
#define ID_WIZBARU_COMBO_TARGET         (IDM_CLASSVIEW_LAST+7)
#define ID_WIZBARU_CTL_ACTION           (IDM_CLASSVIEW_LAST+8)
 
#define IDM_WIZBARU_COMMANDS            (IDM_CLASSVIEW_LAST+9)  // menu entry for tools customize

#define IDM_WIZBARU_CMD_FIRST            (IDM_CLASSVIEW_LAST+10)    // first generic or shared WB command

#define IDM_WIZBARU_DEFAULT               (IDM_WIZBARU_CMD_FIRST)  // current appropriate default action for client

#define IDM_WIZBARNCB_GOFUNCIMPL          (IDM_WIZBARU_CMD_FIRST + 1)
#define IDM_WIZBARNCB_GOFUNCNEXT          (IDM_WIZBARU_CMD_FIRST + 2)
#define IDM_WIZBARNCB_GOFUNCPREV          (IDM_WIZBARU_CMD_FIRST + 3)
#define IDM_WIZBARNCB_DELETE              (IDM_WIZBARU_CMD_FIRST + 4)
#define IDM_WIZBARNCB_CREATE              (IDM_WIZBARU_CMD_FIRST + 5)
#define IDM_WIZBARNCB_NEW_FUNC            (IDM_WIZBARU_CMD_FIRST + 6)
#define IDM_WIZBARNCB_GOCLASSDEF          (IDM_WIZBARU_CMD_FIRST + 7)

#define IDM_WIZBARU_CMD_LAST              (IDM_WIZBARNCB_GOCLASSDEF)    // last generic or shared WB command 
// NOTE: non-default Wizard Bar command ids added by clients to menus  are defined in the client's package

// note: Gallery/Explorer uses MANY id's. It uses them for its context menu's which
//        it builds from the Explorer/Shell's menus.

#define IDM_CREATENEWCLASS              (IDM_WIZBARU_CMD_LAST + 1)
#define IDM_NEWATLCOMP                  (IDM_WIZBARU_CMD_LAST + 2)
#define IDM_CREATENEWFORM               (IDM_WIZBARU_CMD_LAST + 3)
#define IDM_ADDINTERFACE				(IDM_WIZBARU_CMD_LAST + 4)
#define IDM_ADDCONNECTPOINT				(IDM_WIZBARU_CMD_LAST + 5)
#define IDM_ADDEVENT					(IDM_WIZBARU_CMD_LAST + 6)
#define IDM_CLVW_PLACEHOLDER			(IDM_WIZBARU_CMD_LAST + 7)
#define IDM_CLVW_PLACEHOLDER2			(IDM_WIZBARU_CMD_LAST + 8)
#define IDM_ADDFORM                     (IDM_WIZBARU_CMD_LAST + 9)

#define IDM_GALLERY_FIRST               (IDM_ADDFORM + 1)
#define IDM_GAL_ADDTOPROJECT            (IDM_GALLERY_FIRST+ 1)
#define IDM_GAL_RUN                     (IDM_GAL_ADDTOPROJECT+ 1)
#define IDM_GAL_OPEN                    (IDM_GAL_RUN+ 1)
#define IDM_GAL_INSTALL                 (IDM_GAL_OPEN+ 1)
#define IDM_GAL_SETPATH                 (IDM_GAL_INSTALL+ 1)
#define IDM_GAL_NEWFOLDER               (IDM_GAL_SETPATH+ 1)
#define IDM_GAL_CUT                     (IDM_GAL_NEWFOLDER+ 1)
#define IDM_GAL_COPY                    (IDM_GAL_CUT+ 1)
#define IDM_GAL_PASTE                   (IDM_GAL_COPY+ 1)
#define IDM_GAL_DISCONNECT              (IDM_GAL_PASTE+ 1)
#define IDM_GAL_CREATESHORTCUT          (IDM_GAL_DISCONNECT+ 1)
#define IDM_GAL_DELETE                  (IDM_GAL_CREATESHORTCUT+ 1)
#define IDM_GAL_RENAME                  (IDM_GAL_DELETE+ 1)
#define IDM_GAL_HELP                    (IDM_GAL_RENAME+ 1)
#define IDM_GAL_SEARCH                  (IDM_GAL_HELP+ 1)
#define IDM_EXPLORERCONTEXTMENU_BASE    (IDM_GAL_SEARCH + 1)
#define IDM_EXPLORERCONTEXTMENU_0       (IDM_EXPLORERCONTEXTMENU_BASE + 0)

// ... go all the way to end
// stolen id's for gallery
#define IDM_GAL_LAST                    (MAX_CLASSVIEW_COMMAND_ID)
#define IDM_EXPLORERCONTEXTMENU_LAST    (MAX_CLASSVIEW_COMMAND_ID)

// Commands which are dynamically bound to actions via the CDynCT instance in CTheApp.
#define IDM_DYNAMIC_BASE                0x8d00
#define IDM_DYNAMIC_LAST                0x8eff

/////////////////////////////////////////////////////////////////////
// Project Window Commands
//
#define IDM_PROJECT_FIRST                               0x8c00
#define IDM_PROJECT_LAST                                0x8cff

#define IDM_PRJWIN_FIRST            0x8f00
#define IDM_ADDFOLDER               (IDM_PRJWIN_FIRST+0)
#define IDM_ADDSUBFOLDER            (IDM_PRJWIN_FIRST+1)
#define IDM_ADDMENU                 (IDM_PRJWIN_FIRST+2)
#define IDM_ADDSELECTEDNODE         (IDM_PRJWIN_FIRST+3)
#define IDM_ADDPANE                 (IDM_PRJWIN_FIRST+4)
#define IDM_DELETEPANE              (IDM_PRJWIN_FIRST+5)
#define IDM_ADDPROVIDEDNODE1        (IDM_PRJWIN_FIRST+6)
#define IDM_ADDPROVIDEDNODE2        (IDM_PRJWIN_FIRST+7)
#define IDM_ADDPROVIDEDNODE3        (IDM_PRJWIN_FIRST+8)
#define IDM_ADDPROVIDEDNODE4        (IDM_PRJWIN_FIRST+9)
#define IDM_ADDPROVIDEDNODE5        (IDM_PRJWIN_FIRST+10)
#define IDM_ADDPROVIDEDNODE6        (IDM_PRJWIN_FIRST+11)
#define IDM_ADDPROVIDEDNODE7        (IDM_PRJWIN_FIRST+12)
#define IDM_ADDPROVIDEDNODE8        (IDM_PRJWIN_FIRST+13)
#define IDM_ADDPROVIDEDNODE9        (IDM_PRJWIN_FIRST+14)
#define IDM_ADDPROVIDEDNODE10       (IDM_PRJWIN_FIRST+15)
#define IDM_ADDPROVIDEDNODE11       (IDM_PRJWIN_FIRST+16)
#define IDM_ADDPROVIDEDNODE12       (IDM_PRJWIN_FIRST+17)
#define IDM_ADDPROVIDEDNODE13       (IDM_PRJWIN_FIRST+18)
#define IDM_ADDPROVIDEDNODE14       (IDM_PRJWIN_FIRST+19)
#define IDM_ADDPROVIDEDNODE15       (IDM_PRJWIN_FIRST+20)
#define IDM_ADDPROVIDEDNODE16       (IDM_PRJWIN_FIRST+21)
#define IDM_SLOB_DEFAULTCMD         (IDM_PRJWIN_FIRST+22)
#define IDM_TOGGLE_TITLETIPS        (IDM_PRJWIN_FIRST+23)
#define IDM_OPEN_WORKSPACE          (IDM_PRJWIN_FIRST+24)
#define IDM_CLOSE_WORKSPACE         (IDM_PRJWIN_FIRST+25)
#define IDM_TOGGLE_SHOWTITLE        (IDM_PRJWIN_FIRST+26)
#define IDM_PANE1_VISIBLE           (IDM_PRJWIN_FIRST+27)
#define IDM_PANE2_VISIBLE           (IDM_PRJWIN_FIRST+28)
#define IDM_PANE3_VISIBLE           (IDM_PRJWIN_FIRST+29)
#define IDM_PANE4_VISIBLE           (IDM_PRJWIN_FIRST+30)
#define IDM_PANE5_VISIBLE           (IDM_PRJWIN_FIRST+31)
#define IDM_PANE6_VISIBLE           (IDM_PRJWIN_FIRST+32)
#define IDM_PANE7_VISIBLE           (IDM_PRJWIN_FIRST+33)
#define IDM_PANE8_VISIBLE           (IDM_PRJWIN_FIRST+34)
#define IDM_PANE9_VISIBLE           (IDM_PRJWIN_FIRST+35)
#define IDM_INSERT_PROJECTS         (IDM_PRJWIN_FIRST+36)
#define IDM_SAVE_WORKSPACE          (IDM_PRJWIN_FIRST+37)
#define IDM_FILE_RENAME             (IDM_PRJWIN_FIRST+38)       // Rename command
#define IDM_PROJECT_COMBO_ALIAS     (IDM_PRJWIN_FIRST+39)       // Activates Proj Combo
#define IDM_ADD_NEW_PROJECT         (IDM_PRJWIN_FIRST+40)

// Begin Class View specific
#define IDM_CLSVIEW_GOTO_DECL       (IDM_PRJWIN_FIRST+50)
#define IDM_CLSVIEW_DERIVED_CLASSES (IDM_PRJWIN_FIRST+51)
#define IDM_CLSVIEW_BASE_CLASSES    (IDM_PRJWIN_FIRST+52)
#define IDM_CLSVIEW_REFS            (IDM_PRJWIN_FIRST+53)
#define IDM_CLSVIEW_CALLED_FUNCS    (IDM_PRJWIN_FIRST+54)
#define IDM_CLSVIEW_CALLING_FUNCS   (IDM_PRJWIN_FIRST+55)
#define IDM_CLSVIEW_ADD_MF          (IDM_PRJWIN_FIRST+56)
#define IDM_CLSVIEW_ADD_MV          (IDM_PRJWIN_FIRST+57)
#define IDM_GROUPBYACCESS           (IDM_PRJWIN_FIRST+58)
#define IDM_CLSVIEW_ADD_TO_GALLERY  (IDM_PRJWIN_FIRST+59)
#define IDM_CLSVIEW_ADD_IPROP       (IDM_PRJWIN_FIRST+60)
#define IDM_CLSVIEW_ADD_IMETH       (IDM_PRJWIN_FIRST+61)
#define IDM_CLSVIEW_ADD_IEVENT      (IDM_PRJWIN_FIRST+62)
// End Class View specific
// Begin Source Control specific
#define IDM_SCC_FIRST               (IDM_PRJWIN_FIRST+80)
#define IDM_SCC_POP                 (IDM_SCC_FIRST+0)
#define IDM_SCC_GET                 (IDM_SCC_FIRST+1)
#define IDM_SCC_OUT                 (IDM_SCC_FIRST+2)
#define IDM_SCC_IN                  (IDM_SCC_FIRST+3)
#define IDM_SCC_UNOUT               (IDM_SCC_FIRST+4)
#define IDM_SCC_ADD                 (IDM_SCC_FIRST+5)
#define IDM_SCC_REMOVE              (IDM_SCC_FIRST+6)
#define IDM_SCC_HISTORY             (IDM_SCC_FIRST+7)
#define IDM_SCC_DIFF                (IDM_SCC_FIRST+8)
#define IDM_SCC_PROPS               (IDM_SCC_FIRST+9)
#define IDM_SCC_SHARE               (IDM_SCC_FIRST+10)
#define IDM_SCC_ADMIN               (IDM_SCC_FIRST+11)
#define IDM_SCC_REFRESH             (IDM_SCC_FIRST+12)
#define IDM_SCC_LAST                (IDM_SCC_FIRST+19) // (IDM_PRJWIN_FIRST+99)
// End Source Control specific
#define IDM_PRJWIN_LAST                 0x8FFF  // (IDM_PRJWIN_FIRST + 255)

// Fortran commands
#define ID_FORMAT_EDITOR            MIN_FORTRAN_COMMAND_ID

// LangCPP commands
#define IDM_WIZBARCPP_CMD_FIRST           (MIN_LANGCPP_COMMAND_ID)    // first in range of wizard bar actions

#define IDM_WIZBARCPP_GOFUNCDECL          (IDM_WIZBARCPP_CMD_FIRST+0)
#define IDM_WIZBARCPP_GOFUNCIMPLBASE      (IDM_WIZBARCPP_CMD_FIRST+1)
#define IDM_WIZBARCPP_GOFUNCDECLBASE      (IDM_WIZBARCPP_CMD_FIRST+2)
#define IDM_WIZBARCPP_NEW_WINMSG          (IDM_WIZBARCPP_CMD_FIRST+3)
#define IDM_WIZBARCPP_NEW_VIRT            (IDM_WIZBARCPP_CMD_FIRST+4)
#define IDM_WIZBARCPP_DELETE_FUNCDEF      (IDM_WIZBARCPP_CMD_FIRST+5)
#define IDM_WIZBARCPP_GODIALOG            (IDM_WIZBARCPP_CMD_FIRST+6) 

// editor specific commands
#define IDM_WIZBARCPP_OPEN_INCLUDE        (IDM_WIZBARCPP_CMD_FIRST+7)

#define IDM_WIZBARCPP_CMD_LAST            (IDM_WIZBARCPP_OPEN_INCLUDE + 1)    // last in range of wizard bar actions (plus buffer)

#define IDM_ADD_MF                        (IDM_WIZBARCPP_CMD_LAST+1)
#define IDM_ADD_MV                        (IDM_WIZBARCPP_CMD_LAST+2)
#define IDM_ADD_TO_GALLERY                (IDM_WIZBARCPP_CMD_LAST+3)

// Aut1 commands
// For Tools | Macro Dialog
#define IDM_TOOLS_MACRO						(MIN_AUT1_COMMAND_ID + 1)
// For Recording Macros
#define IDM_RECORD_STOP						(MIN_AUT1_COMMAND_ID + 2)
#define IDM_RECORD_PAUSE					(MIN_AUT1_COMMAND_ID + 3)
// For Context Menu editting Macro Files
#define IDM_ADD_MACRO						(MIN_AUT1_COMMAND_ID + 4)
#define IDM_RELOAD_MACRO_FILE				(MIN_AUT1_COMMAND_ID + 5)
#define IDM_RELOAD_MACROS					(MIN_AUT1_COMMAND_ID + 6)
#define IDM_REMOVE_MACRO_COMMANDS			(MIN_AUT1_COMMAND_ID + 7)

/////////////////////////////////////////////////////////////////////////////
// Dynamic commands added by macros and add-ins
// Submenu of file menu on which the two categories "Macros" and "Addins" reside
#define IDM_MACRO_DYNCMDS					(MIN_AUT1_COMMAND_ID + 8)
#define IDM_ADDIN_DYNCMDS					(MIN_AUT1_COMMAND_ID + 9)
#define IDG_MACRODYNCMDS					(MIN_AUT1_COMMAND_ID + 10)
#define IDG_ADDINDYNCMDS					(MIN_AUT1_COMMAND_ID + 11)

//For Temporary Macros
#define IDM_RECTEMPMACRO					(MIN_AUT1_COMMAND_ID + 12)
#define IDM_PLAYTEMPMACRO					(MIN_AUT1_COMMAND_ID + 13)


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//  Status Bar Indicator IDs
//      Note that several "standard" ones (ID_INDICATOR_OVR, ID_INDICATOR_CAPS,
//      ID_INDICATOR_NUM) are defined by MFC.

#define ID_INDICATOR_LNCOL              20192
#define ID_INDICATOR_READ               20193
#define ID_INDICATOR_POSITION           20194
#define ID_INDICATOR_SIZE               20195
#define ID_INDICATOR_ZOOM               20196
#define ID_INDICATOR_CLOCK              20197
#define ID_INDICATOR_OFFSET             20198
#define ID_INDICATOR_EXTENT             20199

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Help IDs and ranges

#ifndef HID_BASE_RESOURCE
#define HID_BASE_RESOURCE           0x20000 // Afx Standard
#endif

// SRC
#define HID_WND_TEXT                    0x28001
#define HID_WND_OUTPUT                  0x28002
#define HID_WND_MEMORY                  0x28003
#define HID_WND_VARS                    0x28004
#define HID_WND_WATCH                   0x28005
#define HID_WND_CALL_STACK              0x28006
#define HID_WND_REGISTERS               0x28007
#define HID_WND_DISASSEMBLY             0x28008
// SRC range
#define MIN_SOURCE_WINDOW_ID            HID_WND_TEXT
#define MAX_SOURCE_WINDOW_ID            HID_WND_DISASSEMBLY

// RES
#define HID_WND_RESOURCE_BROWSER        0x28010
#define HID_WND_DIALOG                  0x28011
#define HID_WND_MENU                    0x28012
#define HID_WND_BITMAP                  0x28013
#define HID_WND_CURSOR                  0x28014
#define HID_WND_ICON                    0x28015
#define HID_WND_STRING                  0x28016
#define HID_WND_ACCEL                   0x28017
#define HID_WND_VERSION                 0x28018
#define HID_WND_BINARY                  0x28019
#define HID_WND_IMAGE_TOOLS             0x2801a
#define HID_WND_DIALOG_TOOLS            0x2801b
#define HID_WND_BITMAP_TEXTTOOL         0x2801c
#define HID_WND_TOOLBAR_EDIT            0x2801d
#define HID_WND_RESOURCEVIEW            0x2801e
// RES range
#define MIN_RES_WINDOW_ID               HID_WND_RESOURCE_BROWSER
#define MAX_RES_WINDOW_ID               HID_WND_RESOURCEVIEW

// PRJ
#define HID_WND_PROJECT_WORKSPACE       0x28020
// PRJ range
#define MIN_WORKSPACE_WINDOW_ID         HID_WND_PROJECT_WORKSPACE
#define MAX_WORKSPACE_WINDOW_ID         HID_WND_PROJECT_WORKSPACE

// MSIN
#define HID_WND_TOPIC                   0x28030
// MSIN range
#define MIN_MSIN_WINDOW_ID              HID_WND_TOPIC
#define MAX_MSIN_WINDOW_ID              HID_WND_TOPIC

// IV
#define HID_WND_TOPIC2                  0x28035
#define HID_WND_INFOVIEW                0x28036
// IV range
#define MIN_IV_WINDOW_ID                HID_WND_TOPIC2
#define MAX_IV_WINDOW_ID                HID_WND_INFOVIEW

// MS-Test
#define HID_WND_TEST_LOCALS             0x28040
#define HID_WND_TEST_WATCH              0x28041
// MS-Test range
#define MIN_TEST_WINDOW_ID              HID_WND_TEST_LOCALS
#define MAX_TEST_WINDOW_ID              HID_WND_TEST_WATCH

// BLD
#define HID_WND_FILEVIEW                0x28050
// BLD range
#define MIN_BLD_WINDOW_ID               HID_WND_FILEVIEW
#define MAX_BLD_WINDOW_ID               HID_WND_FILEVIEW

// ClassView
#define HID_WND_CLASSVIEW               0x28060
// ClassView range
#define MIN_CLASSVIEW_WINDOW_ID         HID_WND_CLASSVIEW
#define MAX_CLASSVIEW_WINDOW_ID         HID_WND_CLASSVIEW

// DTG/ENT
#define HID_WND_DATAVIEW                0x28070
// DTG/ENT range
#define MIN_DTGENT_WINDOW_ID            HID_WND_DATAVIEW
#define MAX_DTGENT_WINDOW_ID            HID_WND_DATAVIEW

// In a number of places, several dialogs share a single dialog template.
// The following dialog IDs are used solely for generating separate help
// contexts for such cases, and do not actually have any dialog templates
// associated with them.
//
#define IDD_REGISTER_CONTROL        0x3990
#define IDD_PROFILE_BROWSE          0x2010
#define IDD_GOTOADDR                0x6978
#define IDD_FILE_SAVE_AS            0x7005
#define IDD_FILE_NEW                0x7801

#define IDD_IMAGE_NEWICONIMAGE      0x0F20
#define IDD_IMAGE_NEWCURSORIMAGE    0x0F21
#define IDD_IMAGE_OPENICONIMAGE     0x0F22
#define IDD_IMAGE_OPENCURSORIMAGE   0x0F23
#define IDD_IMAGE_COLOR             0x0F30
#define IDD_DIR_PICKER              0x0F50
#define IDD_DIR_FINDFILE            0x0F51
#define IDD_ADDTOOL_FILE_OPEN       0x0F60
#define IDD_PROJ_ADDDEP             0x0F70
#define IDD_PROJ_SELECT_TARGET      0x0F71

#define IDDP_BROWSE_DEFREF          0x8101
#define IDDP_BROWSE_FILEOUTLINE     0x8102
#define IDDP_BROWSE_BASEGRAPH       0x8103
#define IDDP_BROWSE_DERVGRAPH       0x8104
#define IDDP_BROWSE_CALLGRAPH       0x8105
#define IDDP_BROWSE_REVCALLGRAPH    0x8106

#define IDDP_RESOURCE_CURSOR        0x8121
#define IDDP_RESOURCE_ICON          0x8122

//  Needed for compatibility when converting 4.x .mdp files
//
//  Streams used in a project's MSF file.  Since we use 512 byte pages, these
//  numbers must be  between 0 and 256
//
#define PROJ_MSF_PROJINTINFO    0   // Internal project info
#define PROJ_MSF_PROJEXTINFO    1   // External project info
#define PROJ_MSF_WORKSPACE      2
#define PROJ_MSF_VCPPINFO       3
#define PROJ_MSF_BRSINFO        4
#define PROJ_MSF_PROJSYSINFO    5   // new project system info
#define PROJ_MSF_PROJSCCINFO    6   // project source control info
#define PROJ_MSF_HELPINFO       7   // help system info
#define PROJ_MSF_ENT                    9       // Enterprise package info
#define PROJ_MSF_DBASE          50  // no-compile browse info
				    // this must be the last one
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Package notification IDs.
//      REVIEW(BrendanX):  Use GUIDs.

#define PN_NEW_PROJECT          1
#define PN_OPEN_PROJECT         2
#define PN_CLOSE_PROJECT        3
#define PN_BEGIN_BUILD          4
#define PN_END_BUILD            5
#define PN_START_BSCMAKE        6
#define PN_END_BSCMAKE          7
#define PN_CHANGE_PROJECT       8
#define PN_CHANGE_BSC           9
#define PN_CHANGE_CONFIG        10
#define PN_CHANGE_PLATFORM      11
#define PN_FULL_SCREEN          12
#define PN_FULL_SCREEN_END      13
#define PN_ADD_FILE             14
#define PN_DEL_FILE             15
#define PN_ADD_TARGET           16
#define PN_DEL_TARGET           17
#define PN_DBASE_CHANGE         18
#define PN_WORKSPACE_INIT       19
#define PN_WORKSPACE_CLOSE      20
#define PN_BEGIN_MULTIOP        21
#define PN_END_MULTIOP          22
#define PN_ADD_FILESET          23
#define PN_DEL_FILESET          24
#define PN_ADD_RCFILE           25
#define PN_DEL_RCFILE           26
#define PN_EXTCHNG_PROJECT      27
#define PN_BLD_SETTINGS_CHANGED 29
#define PN_END_PARSEPROJECT     30
#define PN_BEGIN_SCCOP          31
#define PN_END_SCCOP            32
#define PN_DIRECTORIES_CHANGED  33
#define PN_RENAME_FILE          34
#define PN_DEL_PROJECTDEP       35
#define PN_DOCKMGR_LOADED       36

// Notifcatations after PN_FIRST_VETO are actaully queries to the 
// packages. If any package returns FALSE for these notfications,
// the sender should abort whatever its trying to do.  For example,
// the build systems sends PN_QUERY_BEGIN_BUILD before starting
// a build.  The debugger, when it gets this and debugging is active
// brings up its warning message box and returns false if the user
// hits cancel

#define PN_FIRST_VETO               100
#define PN_QUERY_NEW_PROJECT        100
#define PN_QUERY_OPEN_PROJECT       101
#define PN_QUERY_CLOSE_PROJECT      102
#define PN_QUERY_BEGIN_BUILD        103
#define PN_QUERY_CHANGE_CONFIG      104
#define PN_QUERY_NEW_WORKSPACE      105
#define PN_QUERY_OPEN_WORKSPACE     106
#define PN_QUERY_CLOSE_WORKSPACE    107
#define PN_QUERY_DEL_FILE           108
#define PN_QUERY_DEL_FILESET        109
#define PN_BLD_INIT_COMPLETE        110
#define PN_QUERY_RENAME_FILE        111

#endif  // __IDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\main.h ===
/////////////////////////////////////////////////////////////////////////////
//      MAIN.H
//              Developer Studio main application header file.
//

#ifndef __MAIN_H__
#define __MAIN_H__

#ifndef __AFXWIN_H__
        #error include 'afxwin.h' before including this file for PCH
#endif

#define PRE_MFC_IDLE_PROCESSING_COUNT 3

typedef UINT TYPE_FILTER;

// The types of options dialogs...
enum OPTDLG_TYPE { options, customize };

// EXE strings available from CTheApp::GetExeString
enum EXESTRING_INDEX {
        DefaultAppHelpFile = 0,
        DefaultRefHelpFile,
        DefaultRegKeyName,
        DefaultExtensionDir,
        DefaultControlHelpFile
};

// UI elements that can be disabled from CTheApp::IsUIElementEnabled
enum UIELEMENT_INDEX {
        UieToolbarCustomize = 0,
        UieToolsCustomize,
        UieKeyCustomize,
        UieWorkspaceOptions,
        UieFormatOptions,
};

// display types for CTheApp::HelpOnKeyword
enum REF_DISPLAY_TYPE { topicWindow, popupWindow };

// find types for CTheApp::HelpFind
enum HELP_FIND_PAGE { HF_Default, HF_Index, HF_Search };

// ANSI code page identifier (values for mbcodepage in CTheApp)
#define OEM_JAPAN                       932
#define OEM_PRC                         936
#define OEM_TAIWAN                      950
#define OEM_KOR_WANGSUNG        949
#define OEM_KOR_JOHAB           1361
#define OEM_US                          437

// Define different level of file dependency notification
#define FILEDEP_DISABLENCB  0
#define FILEDEP_DISABLE_ALL 1
#define FILEDEP_DISABLE_ONOPEN 2
#define FILEDEP_DISABLE_IFUPTODATE 3

// Help defines
#define HELPTYPE_DIALOG             0x4010
#define HELPTYPE_WINDOW             0x4020
#define HELPTYPE_COMMAND            0x4030
#define HELPTYPE_CONTROL            0x4040

#include <afxtempl.h>
#ifndef __IDS_H__
#include "ids.h"
#endif

#ifndef __PATH_H__
#include "path.h"
#endif

#ifndef __SLOB_H__
#include "slob.h"
#endif

#ifndef __PACKAGE_H__
#include "package.h"
#endif

#ifdef _DEBUG
#define _EXPORT_LAYOUT
#endif

#ifdef _SHIP
#pragma message("Using _SHIP switch")
#endif



#ifndef _SHIP
// Enable/Disable this if you want to build with the MTTF Dialog.
#define _MTTF
#pragma message("MTTF is turned ON.")

#pragma message("NOT Using _SHIP switch")

#ifdef _DEBUG
// Enable/Disable this if you want to build with command logging.
#define _CMDLOG

// Enable/Disable this if you want to build with IDE startup logging.
#define _IDELOG

// Enable/Disable this if you want to build with Edit and Continue success/failure logging
#define _ENCLOG
#endif
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CApplication;                     // Defined in ide\include\autoapp.h
class CInternalApp;
class CIPCompHostApp;
class CPartFrame;
class CPartTemplate;
class CPartDoc;
class CIPCompDoc;
class CBRecentFileList;
class CTypedRecentFileList;

struct BARPOPDESC;

interface IMsoStdComponentMgr;

/////////////////////////////////////////////////////////////////////////////
// CAppSlob

class CAppSlob : public CSlob
{
public:
        CAppSlob();
        ~CAppSlob();

        virtual BOOL SetSlobProp(UINT nID, CSlob* val);

        // the application global properties
        CSlob * m_pCurrentSlob;
        BOOL m_bPoppingProperties;

        DECLARE_SLOBPROP_MAP()

protected:
        // over-ride the SetStrProp() so that we can
        // trap setting of the current slob
        virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);
};

#ifdef  _CMDLOG
/////////////////////////////////////////////////////////////////////////////
// CCmdMap

class CCmdMap : public CMapWordToOb
{
        DECLARE_SERIAL(CCmdMap)
public:
        CCmdMap() {}
        virtual ~CCmdMap() {}

        void Update(WORD wKey, DWORD nCount = 1);
        void Serialize(CArchive& ar);
};
#endif  // _CMDLOG

/////////////////////////////////////////////////////////////////////////////
// Just in time debugging

class CJit      // Just in time debugging
{
public:
                        CJit() : m_fActive(FALSE), m_pid(0), m_hEvent(0),
                                m_fPathIsReal(FALSE)            { }
        VOID    SetActive(BOOL fActive)                 { m_fActive = fActive; }
        BOOL    GetActive()                                             { return m_fActive; }
        VOID    SetPid(DWORD pid)                               { m_pid = pid; }
        DWORD   GetPid()                                                { return m_pid; }
        VOID    SetEvent(HANDLE hEvent)                 { m_hEvent = hEvent; }
        HANDLE  GetEvent()                                              { return m_hEvent; }
        BOOL    FSetPath(const char *szPath, BOOL fPathIsReal)
                                                                                        { m_fPathIsReal = fPathIsReal;
                                                                                          return m_path.Create(szPath); }
        const CPath& GetPath()                                  { return m_path; }
        BOOL    FPathIsReal()                                   { return m_fPathIsReal; }

private:
        BOOL    m_fActive;
        DWORD   m_pid;
        HANDLE  m_hEvent;
        CPath   m_path;
        BOOL    m_fPathIsReal;  // whether m_path is the real mccoy or a dummy
};

///////////////////////////////////////////////////////////////////////////////
//      CCPLReg - Control panel stuff
//

enum FORMAT_TYPE {TIME_ALL, TIME_NO_SECONDS, DATE_ALL};

class CCPLReg
{
public:
        CCPLReg();
        ~CCPLReg();
        const CString Format(CTime& time, FORMAT_TYPE fType, DWORD dwFlags = DATE_SHORTDATE);
        BOOL IsMetric () const { return !m_bEnglishMeasure; }
        const CString & Decimal () const { return m_strDecimal; }
        void Update();

// Attributes
private:

        BOOL    m_bEnglishMeasure;
        CString m_strDecimal;

        // Kernel.dll handle, and pointers to date/time formatting functions
        // within it.
        HINSTANCE m_hKernel;
        int (FAR WINAPI *m_lpfnGetDateFormatW)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
        int (FAR WINAPI *m_lpfnGetDateFormatA)(LCID, DWORD, CONST SYSTEMTIME *, LPCSTR, LPSTR, int);

        int (FAR WINAPI *m_lpfnGetTimeFormatW)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
        int (FAR WINAPI *m_lpfnGetTimeFormatA)(LCID, DWORD, CONST SYSTEMTIME *, LPCSTR, LPSTR, int);

// Implementation
private:
        CString GetCPLString(LCTYPE lcType, LPCSTR szDefault);
        UINT GetCPLInt(LCTYPE lcType, int nDefault);
};

/////////////////////////////////////////////////////////////////////////////
// CTheApp

#define DHF_CENTER              0x0001
#define DHF_3DCONTROLS  0x0002

extern BOOL fVCPPIsActive;
class CVshellPackage;
class CHaltRecording;           // Defined in utilauto.h
class CDlgTab;

#ifndef __PRJAPI_H__
#include <prjapi.h>                             // for IPkgProject (used in BuildFilterList)
#endif

class CTheApp : public CWinApp
{
        friend class CVshellPackage;
        friend class CHaltRecording;
public:
        enum REPEAT_COUNT_STATE { FinishedAbsolute, FinishedMaybe, FinishedNot, DoneRepeating };
        enum RECORD_STATE { RecordOff, RecordOn, RecordPaused };

private:
        UINT                    m_cActiveFlashPumps;
        UINT                    m_nTimerID;
        INT                                             m_cCmdRepeat;                           // Repeat count to apply to next repeatable command
        REPEAT_COUNT_STATE      m_SettingRepeatCount;   // In the process of setting the count?
        CIPCompHostApp*                 m_pAppCmpHost;
        CInternalApp*                   m_pInternalApp;
        BOOL                                    m_bShouldRecordText;
        int                                             m_nRecordState;
                short                                   m_nAsyncCmdLevel;               // see inlines below


private:
        BOOL InitStdCompMgr();
        BOOL CmpMgrDoIdle();

public:

        CTheApp(const TCHAR** rgszPackages, int nPackages);
        ~CTheApp();
        BOOL ShouldRecordText() { return m_bShouldRecordText; }
        int GetRecordState() { return m_nRecordState; } // One of the RECORD_STATE enum values

        CPartTemplate* GetTemplate(REFCLSID clsid);
        CPartTemplate* GetTemplate(LPCTSTR szType);
        CPartTemplate* GetOpenTemplate(LPCTSTR lpszPathName, CDocument*& pDoc);
        CPartFrame* GetOpenFrame(LPCSTR szFileName,
                CDocTemplate*& pTemplate, CDocument*& pDoc);

        IMsoStdComponentMgr*    m_pMsoStdCompMgr;
        CMapWordToPtr   m_RepeatableCmds;               // Table of repeatable commands
        BOOL                    m_fReplaceRepeatCount;  // Should next arg replace the existing count?
        BOOL m_fVerbose;        // Set to FALSE to disable some message boxes

// Overrides
        virtual BOOL InitInstance();
        virtual int ExitInstance();
        virtual int Run();
        virtual BOOL PumpMessage();     // low level message pump
        virtual BOOL OnIdle(long lCount);
        virtual BOOL IsIdleMessage(MSG * pMsg);
        virtual CDocument* OpenDocumentFile(LPCSTR lpszFileName); // open named file
        virtual void AddToRecentFileList(const TCHAR* pszPathName);  // add to MRU
        void SetRecentFileListSize(int nSize);
        void SetRecentProjectListSize(int nSize);
        int GetRecentFileListSize();
        int GetRecentProjectListSize();
        void LockRecentFileList(BOOL bLock);    // Lock to disable MRU adding.
        void TermStdCompMgr();
                inline CIPCompHostApp *GetStdCompMgr(void) { return m_pAppCmpHost; };

// Like OpenDocumentFile, but has option to open file via ShellExecute. Function
// first tries registered templates to see if any can open the file in native mode.  If
// none can, the function calls ShellExecute to see if there is an association for the
// file.  If there's no association, the function lets the "best match" template open the file.
        CDocument* OpenDocumentFileEx(LPCSTR lpszFileName, BOOL bTryShellToo);

        inline const MSG* GetCurrentMsg() const { return &m_msgCur; }
        inline UINT GetCurrentMessage() const { return m_msgCur.message; }

        virtual BOOL PreTranslateMessage(MSG* pMsg);
        virtual BOOL OnDDECommand(char* pszCommand);
        virtual int DoMessageBox(LPCSTR lpszPrompt, UINT nType, UINT nIDPrompt);
        LPDISPATCH GetPackageExtension(LPCTSTR szExtensionName);

        HRESULT FindInterface(REFIID riid, LPVOID FAR* ppvObj);
        HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObj);
        HRESULT DoesIntrinsicBuilderExist(REFGUID rguidBuilder);
        HRESULT GetIntrinsicBuilder(REFGUID rguidBuilder, DWORD grfGetOpt,
                                                        HWND hwndPromptOwner, IDispatch **ppdispApp,
                                                        HWND *pwndBuilderOwner, REFIID riidBuilder,
                                                        IUnknown **ppunkBuilder);

        HRESULT GetIntrinsicBuilder(REFGUID guidService, REFIID riid, void **ppvObj);

        BOOL IdleAndPump(HANDLE hEventEarlyBreak =0);
        BOOL MainLoop(HANDLE hDummyEvent = 0, BOOL fPushed = FALSE, ULONG uReason = 0);

        void FlashStatePump();

// Implementation
        BOOL LoadPackages(int *pnPackagesLoaded);               // Returns FALSE on error, TRUE otherwise;
                                                                                                                // pnPackagesLoaded returns the count of loaded packages,
                                                                                                                // if return value is TRUE
        void UnloadPackages();
        BOOL RegisterPackage(CPackage* pPackage);
        BOOL RegisterPacket(CPacket* pPacket);
        HWND GetActiveView();
        void SetActiveView(HWND hwnd);
        void ReactivateView();

        void BuildFilterList(CString& rstrFilter, CPtrArray* ppaEditors,
                int nOpenDialog, IPkgProject *pContextProject = NULL);
        CDocTemplate* GetTemplateFromEditor(UINT idsEditor, const char* szFilename);

        BOOL DoPromptFileOpen(CStringArray& saFileNames, UINT nIDSTitle,
                        DWORD lFlags, CDocTemplate* pTemplate,
                        UINT* nOpenAsEditor = NULL, BOOL* pbOpenReadOnly = NULL);
        BOOL DoPromptFileSave(CString& fileName, UINT nIDSTitle,
                        DWORD lFlags, CPartDoc* pDocument, UINT* pnSaveType);

        BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
                AFX_CMDHANDLERINFO* pHandlerInfo);

        void OnDirChange();

        // The following function is used by OnFileOpen and the automation
        // Documents.Open to Openg a file.
        CDocument* OpenFile(CDocTemplate* pTemplate, // Pointer to the template which opens the file. Can be Null.
                                                CString strFilename,     // Filename to open.
                                                BOOL bReadOnly);                 // True if the file should be marked readonly.

        void OnFileNewProject(BOOL fAddToWks = FALSE);

        //{{AFX_MSG(CTheApp)
        afx_msg void OnAppAbout();
        afx_msg void OnFileNew();
        afx_msg void OnFileNewInProject();
        afx_msg void OnFileOpen();
        afx_msg void OnInsertFiles();
        afx_msg void OnUpdateRecentProjMenu(CCmdUI* pCmdUI);
        afx_msg BOOL OnOpenRecentFile(UINT nID);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()


public:
        CPackage*       GetPackage(UINT idPackage);
        CPacket*        GetPacket(UINT idPackage, UINT idPacket, BOOL bActivate = FALSE);
        BOOL            ActivatePacket(UINT idPackage, UINT idPacket)
                                        { return GetPacket(idPackage, idPacket, TRUE) != NULL; }
        BOOL            ActivatePacket(CPacket* pPacket)
                                        { SetActivePacket(pPacket); return TRUE; }
        BOOL            DeactivatePacket();
        void            SetActivePacket(CPacket* pPacket);

                // This tells all packages to lose their loaded bitmaps. We use this after startup is complete to lose these
                // bitmaps, which we no longer need anyway, as they'll have been copied into the toolbars/menus
        void            UnloadPackageBitmaps();

        void            PrintCommandTables();

        // For a given command, this determines the package and the flags associated with the button
        UINT            GetCommandBtnInfo(UINT nCommand, CPackage** ppPackage);

        // This function is used to find the bitmap and glyph index for a given command (nID), and button size
        // It returns true if the command could be found. If pCTE is non-null, it should point to the
        // the CTE of nID; this is a simple optimisation.
        BOOL            GetCommandBitmap(UINT nID, HBITMAP *hbmWell, int *iGlyph, BOOL bLarge, CTE *pCTE=NULL);
        BOOL            HasCommandBitmap(UINT nID) { return GetCommandBitmap(nID, NULL, FALSE, NULL); };

        void            DestroyAll(UINT nFlags = 0);
        BOOL            CanCloseAll(UINT nFlags = 0);
        BOOL            SaveAll(BOOL bQuery = FALSE, UINT nFlags = 0);
        BOOL            HasOpenDocument(UINT nFlags = 0);

        void            DoOptionsDialog(UINT nIDPageCaption = 0);
        void            DoCustomizeDialog(UINT nIDPageCaption = 0, LPCTSTR szMacroName = NULL);

        INT                     GetCmdArg() { return m_cCmdRepeat; }    // to use it as a numerical arg, not repeat count
        INT                     GetRepCount() { return m_cCmdRepeat; }
        void            ClearRepCount()
                                {
                                        m_cCmdRepeat = 1;
                                        if (m_SettingRepeatCount != DoneRepeating)
                                        {
                                                m_SettingRepeatCount = FinishedAbsolute;
                                                UpdateRepeatStatus();
                                        }
                                }

        void            SetRepCount(INT c) { m_cCmdRepeat = c; }
        void            UpdateRepCount(INT i);
        void            InitRepeatableCommands(void);
        BOOL            FSettingRepeatCount(void)
                                {
                                        if (m_SettingRepeatCount == DoneRepeating)
                                                return FALSE;

                                        if (m_SettingRepeatCount != FinishedAbsolute)
                                        {
                                                m_SettingRepeatCount = FinishedNot;
                                                return TRUE;
                                        }
                                        return FALSE;
                                }

        BOOL            FSettingRepeatCount(MSG *pMsg)
                                {
                                        if (m_SettingRepeatCount == FinishedAbsolute)
                                                return FALSE;

                                        if (m_SettingRepeatCount == FinishedNot)
                                                return TRUE;

                                        if (m_SettingRepeatCount == FinishedMaybe && pMsg->message == WM_CHAR &&
                                                        (((TCHAR)(pMsg->wParam) == '-') || _istdigit((TCHAR)(pMsg->wParam))))
                                        {
                                                m_SettingRepeatCount = FinishedNot;
                                                return TRUE;
                                        }
                                        return FALSE;
                                }
        void            BeginSetRepeatCount(INT cRpt = -1, BOOL fReplacable = FALSE);
        void            EndSetRepeatCount(REPEAT_COUNT_STATE);
        BOOL            FCmdRepeatPretranslate(MSG *);
        void            UpdateRepeatStatus();
        // Packages which have UI elements following the command bars style should call this function during
        // WM_MOUSEMOVE processing to decide whether they need to extrude themselves at this time.
        BOOL            ShouldExtrude(void);
        BOOL            IsCustomizing(void);

        void LoadMRUList();
        void CalculateRecentMnemonics();
        void LoadPrivateProfileSettings();
        void SavePrivateProfileSettings();
        UINT GetProfileInt(LPCTSTR szSection, LPCTSTR szKey, int nDefault);
        CString GetProfileString( LPCTSTR szSection, LPCTSTR szKey, LPCTSTR szDefault = NULL);

        // Tooltip implementation helpers. These were previously silently exported by having their declarations
        // hidden in the using packages. We now export them properly.
        static BOOL HandleToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult, LPCTSTR szKeyIn = NULL);
        static void AddKeyToToolTip(CString& rstrTextCmd, UINT nID, WORD flagsCmdCache, LPCTSTR szKeyIn);
        static void SetEmptyToolTip(NMHDR* pNMHDR);

        // Takes the name of the command and returns its command ID.
        //  This searches the entire list of commands so THIS IS VERY
        //  INEFFICIENT-- USE IT ONLY IF YOU HAVE TO
        // Returns BOOL indicating whether the ID was found.
        BOOL GetCommandID(LPCTSTR szCommandName, UINT* pnCmdID);

        // Packages may use this to check whether a command is currently bound to a key
        // This is used by devaut1 to remember to never change the cmdID of bound commands.
        BOOL IsCommandKeyBound(WORD id);

        // Packages may use this to add a command dynamically instead of using
        //  cmdcomp.  This is used by devaut1 to add commands for macros and DLL AddIns
        BOOL AddCommand(WORD id, WORD group, WORD flags, WORD glyph, CPack* pPack,
                                        LPCTSTR szCommand, int nCmdLength);

        // Packages can use this to replace a substring within the command string:
        //  either the menutext, prompt text, or tip text.  Devaut1 uses this to
        //  update the command's description when the user updates a macro's description
        //  in the macro file.  You may not use this to change the name of the command
        //  itself.  This will dirty the command cache.
        void ReplaceCommandString(UINT nID, UINT iString, LPCTSTR szNewSubString);

        // Packages may use this to create one-shot toolbars. The bar would not be owned by the package, and is
        // drawn from the users stock of custom bars. Bars should be created all at one time. If pPackage or dwCookie
        // are different from the last time this function was called, then a new bar will be created.
        //  nButtonType is either dsGlyph or dsText
        //  (see ide\pkgs\include\ObjModel\appdefs.h)
        BOOL AddCommandBarButton(CPackage *pPackage, DWORD dwCookie, UINT nId,
                long nButtonType);

        // Packages can use this to implement dragable areas in customization pages
        // call this in the page's Activate function
        void ActivateDraggableCustomizePage(CDlgTab *pTab);
        // Call this in LBUTTONDOWN. Note that this will eat LBUTTONUP, so you will need to fake one if
        // the drag source is something like a list box, which relies on the lbutton up.
        void DragCommandButton(CPoint ptSource, UINT nId);
        // call this in the page's Deactivate function
        void DeactivateDraggableCustomizePage(CWnd *pParentWnd);

        // Packages may use this to see if a command of this name already exists
        //  This is used by devaut1 to make sure macros/addin cmds don't clash
        //  with preexisting ones.
        BOOL DoesCommandNameExist(LPCTSTR szCmdName);
		LPCTSTR GetCommandName(WORD id);


        // Packages should use this to remove commands that are being permanently removed from the system.
        // UI elements related to the command will be irretrievably removed from the UI. If pPack is not
        // the owner of the command, then the command will not be removed. This stops most commands being removed
        // erroneously by confused packages.
        BOOL RemoveCommand(WORD id, CPack* pPack);

                // Asynchronous commands.  Automation calls to
                //  Application::ExecuteCommand must not return until the command is
                //  really finished.  For example, the ToolsCustomize command handler
                //  returns immediately, even though the tools customize dialog (actually
                //  a modeless window) is not dismissed yet.  Thus, that command must
                //  inform the shell of when it begins and ends, so that ExecuteCommand
                //  can know when it's truly safe to return.

                // Call this in your asynchronous command handler, before returning
                void BeginAsyncCmd() { m_nAsyncCmdLevel++; }

                // Call this when your command is fully completed.  (For example,
                //  the ToolsCustomize dialog will call this on destruction.)
                void EndAsyncCmd() { m_nAsyncCmdLevel--; ASSERT(m_nAsyncCmdLevel >= 0); }

                // This is used by Application::ExecuteCommand to detect when all
                //  asynchronous commands are finished.
                WORD GetCurrentAsyncCmdLevel() { return m_nAsyncCmdLevel; }

                // Start iteration thru filtered windows
                CPartFrame* MDITypedGetActive(TYPE_FILTER tf, BOOL bForwards=FALSE) { return MDITypedGetNext(NULL, tf, bForwards); };
                // iterate to next in filtered windows
                CPartFrame* MDITypedGetNext(CPartFrame* pFrame, TYPE_FILTER tf, BOOL bForwards=FALSE);



#ifdef _WIN32
        void LoadPrivateAutosaveSettings();
        void SavePrivateAutosaveSettings();
#endif


#ifdef _CMDLOG
        void InitCmdLog();
        void CmdLogOnExit();
        void UpdateCmdLog();
#endif

#ifdef _IDELOG
        void InitIDEstartupLog();
#endif

        void SetDialogBkColor()
                { CWinApp::SetDialogBkColor(::GetSysColor(COLOR_BTNFACE)); }

        void SetAppWizHwnd(HWND hWnd);

        //      Load and save vcp files and notify all interested parties:
        BOOL LoadLastProject();
        BOOL SaveLastProject();

        BOOL SerializeAllWorkspaceSettings(const CPath *pPath, DWORD dwFlags, BOOL bSave);
        BOOL LoadAllWorkspaceSettings(const CPath *pPath, DWORD dwFlags)
                { return SerializeAllWorkspaceSettings(pPath, dwFlags, FALSE); }
        BOOL SaveAllWorkspaceSettings(const CPath *pPath, DWORD dwFlags)
                { return SerializeAllWorkspaceSettings(pPath, dwFlags, TRUE); }

        BOOL NotifyPackages (UINT id, void *Hint = NULL, void *ReturnArea = NULL );
        void GetPackagesDefProvidedNodes(CPtrList &DefNodeList, BOOL bWorkspaceInit);
        UINT GetCP (void)
                { return m_codePage; }
        UINT GetCharSet (int * piFaceName = NULL) const;

        int IdsFromFerr(int ferr);

        // This must be overriden by the exe entry module to provide default menus
        virtual POPDESC *GetMenuDescriptor(UINT nId)=0;
        virtual LPCTSTR GetExeString(EXESTRING_INDEX i) = 0;
        virtual HGLOBAL GetStandardToolbarData() = 0;
        virtual BOOL IsUIElementEnabled(UIELEMENT_INDEX i) { return TRUE; }
        virtual void ShowSplashScreen(BOOL bShow);
                virtual UINT GetExecutableProperty(UINT nProperty);
	virtual BOOL WriteLog(LPCTSTR szOut, BOOL bAppendCRLF = FALSE);

        DWORD CurrentPromptContext()    { return m_dwPromptContext; }

        // MSIN Help support
        void HelpContents();
        void HelpFind(LPCTSTR szKeyword, HELP_FIND_PAGE hf = HF_Default);
        void HelpOnApplication(DWORD dwID, UINT type = HELPTYPE_DIALOG, LPCTSTR szFileName = NULL);
        void HelpOnKeyword(LPCTSTR szKeyword, BOOL bAlink = FALSE, REF_DISPLAY_TYPE dt = topicWindow);
        BOOL ScanCommandLine(const TCHAR* szSwitch, CString* pstrArg = NULL, BOOL bRemove = TRUE);

        const char* m_pszRegKeyName;

        int                     m_nLockRecentFileList;
        CPoint          m_ptPropPage;
#ifdef _WIN32
                // FUTURE: Perhaps this should be an enum for Chicago, NT/Intel, NT/Mips, etc.?
                BOOL                    m_bOnChicago;
                BOOL                    m_bWin4;    // Either Win95 or WinNT 4.0 or higher
				BOOL					m_bWin5;	// WinNT 5
                BOOL                    m_bWin95;   // Win95 (NOT WinNT 4.0)
#endif
                BOOL                    m_bMaximizeApp;
                BOOL                    m_bMaximizeDoc;
                BOOL                    m_bWorkspaceAuto;
                BOOL                    m_bToolTips;
                BOOL                    m_bToolTipKeys;
                BOOL                    m_bLargeToolBars;
                BOOL                    m_bCompressMak;
                BOOL                    m_bStatusbar;
                BOOL                    m_bMenuDirty;                           // TRUE if the menus need to be rebuilt on idle
                BOOL                    m_bProjectCommandsDirty;        // TRUE if the project commands need to be rebuilt on idle
                BOOL                    m_bMenuDead;
                BOOL                    m_bDeactByOtherApp;
                WORD                    m_wHookDialogs;
                BOOL                    m_fOEM_MBCS;
                BOOL                    m_bFastHelp;
                BOOL                    m_bOpenedFromMRU;
                BOOL                    m_bOpenedFromDrop;
                BOOL                    m_bOpenedFromLastLoad;
                BOOL                    m_fVCPPIsActive;
                BOOL                    m_bFirstInstance;
                BOOL                    m_bPinGoToDlg;  // if true, goto dialog stays up after goto
                BOOL                    m_bPkgChk;
                BOOL                    m_bWindowMenuSorted;  // true if the window menu is being sorted into MRU-first order.
                // m_bRestoreKey is a flag whether we use /RESTORE option
                // or not. If this flag is set, we will not prepend the default
                // environment (eg: path, include, and lib) for dolphin since
                // it should be already set in *.key file
                BOOL                    m_bRestoreKey;
                BOOL                    m_bEnableWorkspaceLoad; // load workspace during init?
                BOOL                    m_bDlgEdDblClickEditCode;  //compatibility option for double click in dialog editor
                BOOL                    m_bActivated;
                BOOL                    m_bRunInvisibly;        // RunAutomated or RunEmbedded (from automation controller, e.g.)
                BOOL                    m_bHideMicrosoftWebMenu;                // Hides the microsoft on the web menu
                BOOL                    m_bMRUOnFileMenu;
                BOOL                    m_fRunningMacro;
#ifndef NO_VBA
                BOOL                    m_fOleAutomation;       // expose programmable objects?
                                                                                                // (post-Olympus feature, currently disabled by default)
#endif  // NO_VBA

        UINT            m_codePage;
        CApplication*   m_pAutoApp;       // OLE Automation Applicationobject
        int             m_nWindowMenuItems; // total entries in the window menu
        HWND            m_hwndValidate;
        CAppSlob        m_theAppSlob;
        CObList         m_packages;
        CObList         m_packets;
        CStringList     m_argList;
        CString         m_strCurArg;
        CJit            m_jit;
        CCPLReg         m_CPLReg;
        CPacket*        m_pActivePacket;
        CPacket*        m_pMDIActivePacket;
#ifdef _CMDLOG
        CCmdMap         m_cmdTable;
        BOOL            m_bCmdLog;
        UINT            m_timerCmdLog;
#endif
#ifdef _IDELOG
        BOOL            m_bIDELog;
#endif
#ifdef _EXPORT_LAYOUT
        BOOL            m_bExportLayout;
        const char* m_pszLayoutFilePath;
#endif
        CBRecentFileList* m_pRecentProjectList;
        DWORD           m_dwMenuSelectTime;

/////////////////////////////////////////////////////////////////
// disabling NCB, FileDep Notification,
/////////////////////////////////////////////////////////////////
        UINT	        m_nDisableFileDep;

        BOOL            m_bInvokedCommandLine;
        BOOL            m_bQuitting;
		HANDLE		m_hLogFile;

        // Edit and Continue performance logging
        BOOL            m_bEncPerfLog;

#ifdef _ENCLOG
        // Edit and Continue success/failure logging
        BOOL            m_bEncLog;
#endif
        // WARNING!!!  Don't insert anything below this unless you're positive
        //  all the packages that use it are build with the same PERF_MEASUREMENTS
        //  setting as the shell is built with.  The shell *defaults* to building
        //  with PERF_MEASUREMENTS on, so your package better, too.  Or just
        //  don't insert anything below this.
#ifdef PERF_MEASUREMENTS
        ///////////////// Testing code for V4 perf release (fabriced)
        BOOL            m_bPerfQA_AutoRun;
        BOOL            m_bPerfQA_WorkSet;
        BOOL            m_bPerfQA_Workspace;  // Open and close Workspace
        char*           m_szPerfQA_Project;
        DWORD           dwWorkspaceTime;        // Times from project file part of open/close workspace
/////////////////////////////////////////////////////////////
#endif  // PERF_MEASUREMENTS

#ifdef _MTTF
        void InitMTTF();
        void MTTFOnExit();
        BOOL            m_bMTTF;
        UINT            m_timerMTTF;
#endif
};

#define theApp (*((CTheApp*) AfxGetApp()))

inline BOOL UseWin4Look()
        { return theApp.m_bWin4; }

inline BOOL NotOnNT()
        { return theApp.m_bWin95; }

void SetModeName(UINT nModeNameStringID);
void SetModeName(LPCTSTR szModeName);
void SetSubTitle(LPCTSTR szSubTitle);

////////////////////////////////////////////////////////////////////////////
// IME utility functions

void imeMoveConvertWin (HWND, int, int);
void imeChangeFont (HWND, HFONT);
BOOL imeEnableIME (HWND, BOOL);
void imeFlush( HWND hWnd );
BOOL imeIsOpen();
BOOL imeIsEnabled();
BOOL imeIsActive();

///////////////////////////////////////////////////////////////////////////
// DBCS utility functions

//      declarations of DBCS string functions in dbstr.cpp
//  These functions take the place of _str* functions that windows didn't
//  duplicate with lstr* functions. (DBCS enabled)

LPSTR dbstrchr( LPCSTR sz, int n );
LPSTR dbstrrchr( LPCSTR sz, int n );
LPCSTR dbstrstr( LPCSTR string1, LPCSTR string2 );
int dbstrnicmp( LPCSTR string1, LPCSTR string2, size_t count );

BOOL IsJapaneseSystem();
BOOL IsSBKatakana( unsigned char c );
BOOL IsDBCSTrailByte( LPCSTR string, LPCSTR pch );

////////////////////////////////////////////////////////////////////////////
//      Help

void GetHelpDir(CString & strHelpDir);
void DoHelpContextMenu(CWnd* pDialog, UINT idDlg, CPoint pt);
BOOL DoHelpInfo(CWnd* pDialog, UINT idDlg, HELPINFO* pInfo);
BOOL GetHID(HWND hwndDlg, HWND hwndCtrl, HWND * phwndHelp, DWORD* hid);

////////////////////////////////////////////////////////////////////////////
// Registry access helpers

const char chKeySep = '\\';

LPSTR   GetRegistryKeyName();
CString GetRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szDefault = NULL);
UINT    GetRegInt(LPCSTR szSection, LPCSTR szKey, int nDefault);
HGLOBAL GetRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobDefault);
IStream *GetRegIStream(LPCTSTR szSection, LPCTSTR szKey);
BOOL    WriteRegString(LPCTSTR szSection, LPCTSTR szKey, LPCTSTR szVal);
BOOL    WriteRegInt(LPCSTR szSection, LPCSTR szKey, int nValue);
BOOL    WriteRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobValue);
BOOL    WriteRegIStream(LPCTSTR szSection, LPCTSTR szKey, IStream *pIStream);
BOOL    DeleteRegData(LPCSTR szSection, LPCSTR szKey);

/////////////////////////////////////////////////////////////////////////////
//      Function to take an IUnknown, request an IPersistStream from it and
//      assuming it supports it, writes the stream to the registry.
extern HRESULT DevStudioPersistStreamToRegistry(IUnknown *pIUnknown, LPCTSTR szSection, LPCTSTR szKey);
extern HRESULT DevStudioLoadStreamFromRegistry(LPCTSTR szSection, LPCTSTR szKey, const CLSID &rclsid,
                                                                                           REFIID riid, LPVOID *ppvUnknown,
                                                                                           IUnknown *pIUnknownOuter = NULL, CLSCTX clsctx = CLSCTX_INPROC_SERVER);

/////////////////////////////////////////////////////////////////////////////
// CKeymap

class CKeymap : public CMapWordToPtr
{
public:
        CKeymap();
        virtual ~CKeymap();

        virtual BOOL LookupCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo, CKeymap* pOverride = NULL);
        virtual BOOL LookupKey(WORD kc, UINT& nCmdID, CKeymap*& pKeymap);

        void LoadAccelerators(HINSTANCE hInstance, LPCTSTR lpResourceID);
        void LoadAccelerators(HACCEL hAccelTable);
        virtual void LoadEditorAccelerators();

        void SetKey(WORD kc1, UINT nCmdID);
        void SetKey(WORD kc1, WORD kc2, UINT nCmdID);
        void SetKey(WORD kc, CKeymap* pKeymap);
        void RemoveKey(WORD kc1, WORD kc2 = 0);
        void RemoveAll();

        POSITION GetStartPosition()
                { return CMapWordToPtr::GetStartPosition(); }
        void GetNextKey(POSITION& pos, WORD& kc, UINT& nCmdID, CKeymap*& pKeymap);

        BOOL TranslateMessage(CWnd* pWnd, MSG* pMsg);

        void WriteReg(const TCHAR* szKey = NULL);
        BOOL GetReg(const TCHAR* szKey = NULL);

        CString m_strName;
        CPacket* m_pPacket;
        BOOL m_bDirty;

        static void GetKeyName(WORD kc1, WORD kc2, CString& str);
        static void CancelChord();

        static void SetEscIsAltPrefix(BOOL bSetEscIsAltPrefix);

        static CObList c_keymaps;
        static CKeymap* c_pChordKeymap;
        static WORD c_kcChordPrefix;
        static BOOL c_bDisableIME;
        static BOOL c_bEscIsAltPrefix;
        static BOOL c_bImplyAltForNextKey;
        static const TCHAR c_szCtrl [];
        static const TCHAR c_szAlt [];
        static const TCHAR c_szShift [];
};

class COverridingKeymap : public CKeymap
{
public:
        COverridingKeymap(CKeymap *pkeymapBase)
                {m_pkeymapBase = pkeymapBase; m_fOverrideActive = FALSE;}

        void Activate(void)
                {m_fOverrideActive = TRUE;}
        void Deactivate(void)
                {m_fOverrideActive = FALSE;}

        virtual BOOL LookupCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo, CKeymap* pOverride = NULL);
        virtual BOOL LookupKey(WORD kc, UINT& nCmdID, CKeymap*& pKeymap);

private:
        BOOL m_fOverrideActive;
        CKeymap *m_pkeymapBase;
};

#define KCF_CONTROL     0x0800
#define KCF_SHIFT       0x1000
#define KCF_ALT         0x2000
#define KCF_ASCII       0x4000
#define KCF_CHORD       0x8000

// from keymap.cpp
extern BOOL GetCmdKeyString(UINT nCmdID, CString& str); // Active binding
extern BOOL GetCmdKeyStringAll(UINT nCmdID, CString& str); // First binding in all maps -- NOT NECESSARILY ACTIVE

extern void AddGlobalAcceleratorTable(HACCEL hAccel, WORD kcPrefix = 0);
extern void AddGlobalAcceleratorTable(LPCTSTR lpAccelID, WORD kcPrefix = 0);

extern BOOL LookupGlobalCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo);

/////////////////////////////////////////////////////////////////////////////
//      CAddOn
//              One package from each product should sub-class this and create one
//              instance to provide information for the about box.

class CAddOn
{
public:
        CAddOn();
        virtual ~CAddOn();
        CAddOn(int nSplashImageIndex);
        virtual const TCHAR* GetAboutString();
        virtual HICON GetIcon();

public:
        static POSITION GetHeadPosition()
                { return c_addons.GetHeadPosition(); }

        static CAddOn* GetNext(POSITION& pos)
                { return (CAddOn*)c_addons.GetNext(pos); }

private:
        static CPtrList c_addons;
};

/////////////////////////////////////////////////////////////////////////////
//      CProductInfo
//              One of these per product (e.g. C++, Fortran, Mac add-on, Test, etc.)

// REVIEW(davidga): what's with the arbitrary lengths?
#define PI_CCHMAX_LICENSE_NAME          53
#define PI_CCHMAX_LICENSE_COMPANY       53
#define PI_CCHMAX_SERIAL_NUMBER         24

class CProductInfo
{
public:
        enum { PIDID = ID_PID, PIDTYPE = IDRT_PID };
        CProductInfo() : m_bValid(FALSE) {}
        BOOL Create(HMODULE hModule, UINT nId = PIDID, UINT nType = PIDTYPE);

        BOOL IsValid() { return m_bValid; }

        // copy info into your strings
        BOOL CopyInfo( LPTSTR szPID = NULL, LPTSTR szUserName = NULL, LPTSTR szOrganization = NULL ) const;

        LPCTSTR GetPID() const { return m_bValid ? m_szPID : _TEXT("xxxxxxxxxxxxxxxxxxxxxxx"); }
        LPCTSTR GetUserName() const { return m_bValid ? m_szUser : NULL; }
        LPCTSTR GetOrganizationName() const { return m_bValid ? m_szOrg : NULL; }

protected:
        BOOL m_bValid;
        _TCHAR m_szPID[PI_CCHMAX_SERIAL_NUMBER];
        _TCHAR m_szUser[PI_CCHMAX_LICENSE_NAME];
        _TCHAR m_szOrg[PI_CCHMAX_LICENSE_COMPANY];
};

// Main product info

struct PRODUCT_INFO
{
        TCHAR szLicenseName[PI_CCHMAX_LICENSE_NAME];
        TCHAR szLicenseCompany[PI_CCHMAX_LICENSE_COMPANY];
        TCHAR szSerialNumber[PI_CCHMAX_SERIAL_NUMBER];
};

extern PRODUCT_INFO AFX_EXT_DATA productInfo;

/////////////////////////////////////////////////////////////////////////////
//      Module loading help

enum SETUP_TYPE
{
        stStandard,
        stMacintosh,
        stPackageInit
};

// Use this to report a missing required file.  The setup type indicates which
// setup program the user will have to run in order to get the specific DLL.
//
void ReportMissingFile(const TCHAR* szFileName,
        SETUP_TYPE setupType = stStandard);


// Use this instead of LoadLibrary() to load DLL's.  It will prevent Windows
// from displaying its ugly DLL missing message.  If bRequired is TRUE, we
// will display our own message asking the user to re-install the development
// environment.  The setup type indicates which setup program the user will
// have to run in order to get the specific DLL.
//
HINSTANCE SushiLoadLibrary(const TCHAR* szName, BOOL bRequired,
        SETUP_TYPE setupType = stStandard);

/////////////////////////////////////////////////////////////////////////////
// Interface to CTL3D32.DLL

#define WM_DLGBORDER (WM_USER+3567)
/* WM_DLGBORDER *(int FAR *)lParam return codes */
#define CTL3D_NOBORDER          0
#define CTL3D_BORDER            1

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS        0
#define CTL3D_SUBCLASS          1

/////////////////////////////////////////////////////////////////////////////
// Random MFC helpers

#ifdef _DEBUG
extern UINT SushiRegisterWindowMessage(const char* szMsg);
#define RegisterMessage SushiRegisterWindowMessage
#else
#define RegisterMessage RegisterWindowMessage
#endif

inline void SetDlgCtrlID(HWND hWnd, int nID)
{
#ifdef _WIN32
        ::SetWindowLong(hWnd, GWL_ID, nID);
#else
        ::SetWindowWord(hWnd, GWW_ID, nID);
#endif
}

// This will search all packages and MFC for a cursor...
HCURSOR AfxLoadCursor(LPCTSTR lpResourceID);
inline HCURSOR AfxLoadCursor(UINT nResourceID)
        { return AfxLoadCursor(MAKEINTRESOURCE(nResourceID)); }

/////////////////////////////////////////////////////////////////////////////
// Random C++ helpers

// Macro to keep up with the compiler syntax for declaring template specializations.
// Example of using this macro:
//                      SPECIALIZE(UINT AFXAPI HashKey(GUID key));
#if _MSC_VER < 1100
        // what we used to use ... but this has no effect in ANSI C++
        #define SPECIALIZE(T) T
#elif _MSC_VER == 1100
        // a temporary hack in the M1 compiler
        #pragma warning(disable:4231)
        #define SPECIALIZE(T) extern template T
#elif _MSC_VER > 1100
        // The true ANSI C++ syntax, which our compiler will support post-M1.
        #define SPECIALIZE(T) template<> T
#else
        #error This Can't Happen
#endif

/////////////////////////////////////////////////////////////////////////////
// Platform alignment

#if defined ( _MIPS_ ) || defined ( _X86_ ) || defined (_ALPHA_) || defined (_PPC_)
#define PACKSIZE        8
#define ALIGNMASK       (PACKSIZE - 1)
#else
    /* Deal with others as we get them */
#error "Must define PACKSIZE for this platform"
#endif

#define ALIGN(x)  ( ( (x) + ALIGNMASK ) & ( ~ALIGNMASK ) )

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#define AfxMessageBox DsMessageBox
extern int DsMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0);
extern int DsMessageBox(UINT nIDPrompt, UINT nType = MB_OK);
extern int DsMessageBox(UINT nIDPrompt, UINT nType, UINT nIDHelp);

// We used to pick these warnings up via various places from the SC++L headers. MFC (or something) no longer includes the
// SC++L headers, so we need these ourselves. In the next version, we should go back and remove these and fix the issues they relate to.
// martynl 12/06/96
// Copied from yvals.h
#pragma warning(4: 4018 4114 4146 4244 4245)
#pragma warning(4: 4663 4664 4665)
#pragma warning(disable: 4237 4284 4290 4514 4242)

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\msgboxes.h ===
/* MsgBoxes.h
 *
 * Purpose:	Specification file for the Dolphin WADG compliant message box 
 *			interface.
 *
 * Created:	22 July 1993 -by- Andrew Milton [w-amilt]
 *
 * Notes:	To ensure WADG compliance,  all message boxes in Dolphin must be 
 *			posted with some flavour of the MsgBox() function or one of its 
 *			derivatives [InformationBox(), QuestionBox(), ErrorBox()].  
 *			The message	text it contains should be formatted using one of the  
 *			MsgText() functions.  
 *
 *			The essential points we're trying to ensure here are avoiding 
 *			focus-theft from other applications and the three-line COMMDLG
 *			format for file errors.
 *
 *			Through the magic of enum's and overloading, a wide variety of 
 *			options are available for message posting and formatting.
 *
 *			Five message box types are currently available, defined by the
 *			enum MsgBoxTypes:  Information, Question, Error, InternalError, 
 *			and FatalError.  All forms of the MsgBox() function take a 
 *			MsgBoxTypes as the first parameter.  The default style for each
 *			type of message box is:
 *				Information		=>	MB_ICONINFORMATION	| MB_OK
 *				Question		=>	MB_ICONQUESTION		| MB_YESNOCANCEL
 *				Error			=>	MB_ICONEXCLAMATION	| MB_OK
 *				InternalError	=>	MB_ICONSTOP			| MB_OK
 *				FatalError		=>	MB_ICONSTOP			| MB_OK
 *			All message boxes use the MB_APPLMODAL mode.  Except for 
 *			InternalError and FatalError, message boxes are posted silently 
 *
 *			The button styles on the Question, Error and InternalError
 *			message box types may be overridden.  However, neither the
 *			icon nor the mode may be changed.  See the MsgBox() prototypes
 *			for more details.
 *
 *			InternalError and FatalError do special processing when raised.
 *				InternalError	=>	The error text is substituted into the 
 *									string "Internal Errror.  Please contact
 *									Microsoft Product Support Services (%s)"
 *									before it is displayed.
 *				FatalError		=>	Causes a panic shutdown of Dolphin.
 *
 *			The MsgBox() functions take either a string ID or a string 
 *			pointer for the the message text.  They do not allow variable 
 *			substitution into the message text.  The MsgText() family is 
 *			provided for substitions.  All return a LPCTSTR so that the call
 *			may be imbedded into a MsgBox() call, as in:
 *				MsgBox(Error,	
 *						MsgText(strBuffer, IDS_STRING_NOT_FOUND, pszToFind));
 *
 *			The MsgBox() functions also allow an F1 help context to be 
 *			passed as the last parameter.  The default is 'No help'.  If
 *			several message boxes are going to be displayed in a function 
 *			that use a common help context, then the default help can changed
 *			by delcaring a CLocalHelpContext object on the stack & passing
 *			the new default help context to the constructor.  The destructor
 *			will reset the help context when the object goes out of scope.
 *			Lastly, to get default buttond & set a help context, you can use 
 *			the DEFAULT_BUTTONS symbol, as in:
 *				MsgBox(Error,	
 *						MsgText(strBuffer, IDS_STRING_NOT_FOUND, pszToFind),
 *						DEFAULT_BUTTONS,
 *						helpFind);
 *
 *			Observe that all calls to LoadString() occur inline.  This 
 *			guarantees that if you have a local resource context set up, then
 *			MFC will look in the right place first for your string.
 *
 *			Lastly, the InformationBox(), QuestionBox() and ErrorBox() 
 *			functions are provided as convenience to the IDE.  They are 
 *			remnants of 'the old way' of doing message boxes.  If at all 
 *			possible, please avoid using these functions.  They're only
 *			inline wrappers to a MsgBox() and MsgText() call.
 *
 * Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
 ****************************************************************************/

#ifndef MSGBOXES_H
#define MSGBOXES_H

#include <tchar.h>
#include <stdarg.h>	// for var args stuff.
#include "path.h"

#define IDT_WINDOW_FLASH		101
#define DEFAULT_BUTTONS			((UINT) -1)
#define DEFAULT_HELP			((UINT) -1)
#define MAX_SUBSTITUTION_BYTES	1024

#ifndef _WIN32
#define LPCTSTR LPCSTR
#define LPTSTR LPSTR
#endif

/* WARNING!!!	WARNING!!!	WARNING!!!	 
 *
 * The following enum defines the available styles of message boxes.
 * If you add a message box style, then you MUST alter the three style arrays
 * g_rnIconStyles, g_rnButtonStyles, and  g_rfBeepOnMessage to reflect the 
 * change.
 */ 

#define NUMBER_OF_MESSAGE_BOXES 5

typedef enum tagMsgBoxTypes {
	Information		= 0, 
	Question		= 1, 
	Error			= 2, 
	InternalError	= 3, 
	FatalError		= 4
} MsgBoxTypes;

/* Function Prototypes ******************************************************/


extern void
InitMsgBoxes();	// Private to the message box implementation.  


/*************************** Interface Definition ***************************\
 MsgBox()

 Purpose:	To display a message box that conforms to the WADG.

 Returns:	The ID of the button pressed to dismiss the message.

 Notes:		- No mode or icon flags are allowed to be set for the message 
 			box by the calling function.  If any are slipped in with the 
			button options, then we ASSERT.
			- No button options are allowed with Information or FatalError
			message box types
			- If Dolphin is not active, then the IDE main frame is set into 
 			a flash state & the message box is suppressed until Dolphin 
 			becomes active. 
			- The displayed icon & default buttons are determined by the
			g_rnDefaultButtons[] and g_rnIconStyles[] arrays.  See the 
			WARNING!!! above.

			The first version of this function displays the string pointed 
			to by <pszMessage>.  The second version loads its message from 
			the resource table (inline), and then calls the first version to
			display the message.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/
 
int 
MsgBox(
	const MsgBoxTypes MsgBoxType, 
	LPCTSTR pszMessage,
	UINT nButtonIDs		= DEFAULT_BUTTONS,
	UINT nHelpContext	= DEFAULT_HELP);

inline int 
MsgBox(
	const MsgBoxTypes BoxType,
	const int nMessageID,
	UINT nButtonIDs		= DEFAULT_BUTTONS,
	UINT nHelpContext	= DEFAULT_HELP);

/*************************** Interface Definition ***************************\
 MsgText()

 Purpose:	To format text for display in a message box.  

 Returns:	Constant pointer to the formatted text.

 Notes:		Each version of this function requires a CString reference as its
 			first parameter.  This allows MsgText() to allocate buffer space
			on the heap for the formatted text with the assurance that the 
			buffer space will go away when the CString goes out of scope in 
			the calling function.  Why do we want to do this?  Well, it 
			guarantees that there will be enough space to store a message
			in the event that it changes length under translation to 
			different languages.  This way, we don't have to worry about
			buffer overruns on the stack (which can be unpleasant to isolate!)

			The first two versions of MsgText() corrospond with wsprintf()
			and wvsprintf() -- only the format string is loaded from the 
			resource table.

			The other two versions take a CFileException pointer & a CPath
			reference to construct a file error message.  The file error
			is formatted into three lines:

				<Name of the file>
				<Operation that failed>
				<Why it failed>

			This code is shamelessly based on code in <vres\mytlab.cpp>.

			The SubstituteBytes() function is reserved for use by the 
			message text routines.  It contains the common functionality for 
			the inline versions of MsgText().

			*IMPORTANT*

			The formatted text is stored in <strBuffer> AND returned by 
			MsgText().  If the same text is going to be used in several 
			message boxes, then  using the 	appropriate cast, <strBuffer> 
			can be reused in a later call to MsgBox().  ie:

			{
				CString strFooError;
				MsgBox(Error, MsgText(strFooError, IDS_FOO, cFooActions));

				// Stuff Happens to cause the same error 

				MsgBox(Error, (LPCTSR)strFooError);
			
			}

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	...);

inline LPCTSTR
VMsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	va_list VarArguments);

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	const int idsFileOperation,
	const CFileException *peOffence);

LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	LPCTSTR pszFileOperation,
	const CFileException *peOffence);

LPCTSTR
SubstituteBytes(
	CString &strBuffer,
	LPCTSTR pszFormat,
	va_list VarArguments);	   // RESERVED.  Do not use.

/*************************** Interface Definition ***************************\
 InformationBox()
 QuestionBox()
 ErrorBox()

 Purpose:	Shortcut functions for the IDE's convenience.  Let's not be
 			using these, eh?

 Returns:	Information - Nada, Error - FALSE, Question - Button pressed.

 Notes:		Roughly speaking, we have <Foo>Box(ids, <stuff>) is the same as
 			MsgBox(<Foo>, MsgText(str, <stuff>))
			The exception is QuestionBox, which sets the available buttons.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline void
InformationBox(
	UINT idsMsgFormat,
	...);

inline int
QuestionBox(
	UINT idsMsgFormat,
	UINT nButtons,
	...);

inline BOOL
ErrorBox(
	UINT idsMsgFormat,
	...);

/*************************** Interface Definition ***************************\
 class CLocalHelpContext
 PushHelpContext()
 PopHelpContext()

 Purpose:	To set/reset the default message box F1-help context.
  
 Returns:	Push - Nada.  Pop - last help context

 Notes:		The push/pop functions should *not* be called directly.  The 
 			CLocalHelpContext constuctor/destructor call them to set up local
			help contexts, and using this class guarantees that help contexts
			will be reset at the end of a scope block.  See the comments at
			the top of the file for more details.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

void
PushHelpContext(             
	UINT nNewHelp);

UINT
PopHelpContext();

class CLocalHelpContext {
public:
	CLocalHelpContext(UINT nHelp) { PushHelpContext(nHelp);}
	~CLocalHelpContext() 		 { PopHelpContext();}
};

// Stolen out of the debugger headers for consistancy
void FAR PASCAL 
DebuggerMessage(
	MsgBoxTypes MsgType, 
	UINT idsErrorFormat,	
	LPSTR Msg,	
	int ShowType);

#include "msgboxes.inl"

/////////////////////////////////////////////////////////////////////////////
// CMessageBox dialog
//	Simulates a message box (by borrowing from Windows code)
//	but allows you to set your own buttons
//	Can either create an instance, and call DoModal(), 
//	or call the static DisplayMessageBox().

class CMessageBox : public CDialog
{
// Construction
public:
	CMessageBox(LPCSTR lpszText, LPCSTR lpszCaption, LPCSTR lpszButtons, 
		WORD wStyle, DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);
	~CMessageBox();

// Attributes
	CFont* m_pFont;
// Operations
	static int DoMessageBox(LPCSTR lpszText, LPCSTR lpszCaption, 
		LPCSTR lpszButtons, WORD wStyle, int nDef = 0, int nCancel = -1, 
		DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);

	void AddButton(CString& strButton) { m_strArray.Add(strButton);}
	void AddButtons(LPCSTR lpszButton);
	void SetCancel(int nCancel)
		{ ASSERT(nCancel < m_strArray.GetSize()); m_nCancel = nCancel;}
	void SetDefault(int nDef)
		{ ASSERT(nDef < m_strArray.GetSize()); m_nDefButton = nDef;}
	void FillInHeader(LPDLGTEMPLATE lpDlgTmp);

// Overridables
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual int DoModal();

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() {return m_pHelpIDs;}
	DWORD* m_pHelpIDs;
	int m_nDefButton;
	int m_nCancel;
	HGLOBAL m_hDlgTmp;
	UINT m_nBaseID;
	WORD m_wStyle;
	CButton* m_pButtons;
	CStatic m_staticIcon;
	CStatic m_staticText;
	CString m_strCaption;
	CString m_strText;
	CStringArray m_strArray;
	CSize GetBaseUnits();
	LPCSTR GetIconID(WORD wFlags);
	void PositionControls();

	// Generated message map functions
	//{{AFX_MSG(CMessageBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
//	File Error support
//		note that file error codes where the high word is 0 are 
//		CFileException::m_cause codes.

#ifndef __IDS_H__
#include "ids.h"
#endif

enum
{
	ferrShellPackageFirst = MAKELONG(1000, PACKAGE_SUSHI),
	ferrCantSaveReadOnly,
	ferrCantSaveTempFiles,
	ferrIllformedFile,
};

int GetFileError();
void SetFileError(int nCause);
void FileErrorMessageBox(UINT idsOperation, LPCTSTR szFileName);

#endif	// MSGBOXES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\oleref.h ===
// compview.h : interface of the CComponentView class
//

#ifndef __OLEREF_H__
#define __OLEREF_H__

#ifdef _DEBUG
#define TRACEOLE(sz)            (if (afxTraceFlags & traceOle) \
								::AfxTrace(_T("%s"), _T(sz)))	
#else   // _DEBUG
#define TRACEOLE(sz)
#endif

void FreeOlePtr(void * pv);

// OleRelease - Decrement an arbitrary OLE interface (if its not NULL) and set it
//             to NULL (NOTE: The call to Release is made through a temporary pointer)
template <class TYPE> inline unsigned long OleRelease
(
TYPE&	rpunk
)
	{
	if (rpunk)
		{
		TYPE	punkTemp = rpunk;
		rpunk = NULL;
		return punkTemp->Release();
		}
	return 0;
	}
	
/*-----------------------------------------------------------------------------
Name:	COleRef

Description:
This class performs automatic reference count decrementing (users must ensure
that AddRef has already been called)on interface pointers.
-----------------------------------------------------------------------------*/
template <class TYPE> class COleRef					// Hungarian:	srp
{
public:
	COleRef();					// Interface is initialized with NULL
	COleRef(TYPE* punk);		// Passed interface is saved
	COleRef(IUnknown *pIUnknown, REFIID riid); // QueryInterface() for riid
	~COleRef();

	operator TYPE*() const;

	TYPE *	operator->() const;
	TYPE**	operator&();		// Asserts emptiness, use InOut for passing as an IN/OUT parameter
	TYPE*	operator=(TYPE* punk);

	TYPE*			Disown();		// Set internal pointer to NULL (w/o calling Release on the interface)
	TYPE**			InOut();		// Same as address-of operator, use instead when passing as in IN/OUT parameter
	const TYPE*&	Reference();	// Return a const reference
	ULONG			SRelease();		// Release the interface and set internal pointer to NULL
	HRESULT			AssignFromQI(IUnknown *pIUnknown, REFIID riid); // Do QI on pIUnknown for riid and assign to this
	BOOL			IsNull() const;

protected:
	TYPE*	m_punk;
	
private:
	// Dis-allow copy and assignment
	COleRef(const COleRef<TYPE>& srp);
	COleRef<TYPE>& operator=(const COleRef<TYPE>& srp);
};

/*-----------------------------------------------------------------------------
Name:	COleMalloc

Description:
This class automatically releases the memory allocated by the OLE IMalloc
interface.
-----------------------------------------------------------------------------*/
template <class TYPE> class COleMalloc	
{
public:
	COleMalloc(TYPE* pItem = NULL);
	~COleMalloc();

	operator TYPE*() const;

//	TYPE *	operator->() const;
	TYPE&	operator*() const;
	TYPE**	operator&();
	TYPE*	operator=(TYPE* pItem);

	void	Delete();					// Delete the memory and set internal pointer to NULL
	TYPE*	Disown();					// Set the internal pointer to NULL (w/o deleting the memory)

private:
	TYPE*	m_pItem;

	// Dis-allow copy and assignment
	COleMalloc(const COleMalloc<TYPE>& smp);
	COleMalloc<TYPE>& operator=(const COleMalloc<TYPE>& smp);
};


/*-----------------------------------------------------------------------------
Name:	COleStrPtr 

Description:
This class automatically releases the string allocated by the OLE memory allocator
on destruction.
-----------------------------------------------------------------------------*/
class COleStrPtr : public COleMalloc<WCHAR>	// Hungarian:	smsz
{
public:
	COleStrPtr(WCHAR * pItem = NULL) : COleMalloc<WCHAR>(pItem) { };

private:
	// Dis-allow copy and assignment
	COleStrPtr(const COleStrPtr& sstr);
	COleStrPtr& operator=(const COleStrPtr& sstr);
};


/*-----------------------------------------------------------------------------
Name:	COleRef::COleRef

Description:
Construct a COleRef by taking ownership of the passed interface (if any)
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::COleRef()
 : m_punk(NULL)
	{
	return;
	}

template <class TYPE> inline COleRef<TYPE>::COleRef
(
TYPE*	punk		// IUnknown interface pointer to reference count
) :
m_punk(punk)
	{
	return;
	}

template <class TYPE> inline COleRef<TYPE>::COleRef
(
IUnknown *pIUnknown,
REFIID riid
) : m_punk(NULL)
{
	void *pvTemp = NULL;
	ASSERT(pIUnknown != NULL);
	HRESULT hr = pIUnknown->QueryInterface(riid, &pvTemp);
	if (SUCCEEDED(hr))
		m_punk = reinterpret_cast<TYPE *>(pvTemp);
}

/*-----------------------------------------------------------------------------
Name:	COleRef::~COleRef

Description:
Destroy a COleRef object by decrementing the reference count of the
saved interface.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::~COleRef()
	{
	OleRelease(m_punk);
	return;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator TYPE*

Description:
Convert a COleRef to a TYPE*
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::operator TYPE*() const
	{
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator->

Description:
Return interface pointer.
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::operator->() const
	{
	ASSERT(m_punk);
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator&

Description:
Return the address of the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleRef<TYPE>::operator&()
	{
	ASSERT(!m_punk);
	return &m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator=

Description:
Assign a new interface
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::operator=
(
TYPE*	punk
)
	{
	ASSERT(!m_punk);
	return (m_punk = punk);
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::Disown

Description:
Drop ownership of the interface (without calling Release)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::Disown()
	{
	TYPE*	punk = m_punk;
	m_punk = NULL;
	return punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::InOut

Description:
Return the address of the pointer (without asserting that it's empty)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleRef<TYPE>::InOut()
	{
	return &m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::Reference

Description:
Return a const reference to the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline const TYPE*& COleRef<TYPE>::Reference()
	{
	ASSERT(m_punk);
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::SRelease

Description:
Release the held resource and clear the internal pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline ULONG COleRef<TYPE>::SRelease()
	{
	return OleRelease(m_punk);
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::AssignFromQI

Description:
Queries a passed in IUnknown * for a given interface and assigns it to this.
-----------------------------------------------------------------------------*/
template <class TYPE> inline HRESULT COleRef<TYPE>::AssignFromQI
(
IUnknown *pIUnknown,
REFIID riid
)
{
	void *pvTemp = NULL;
	HRESULT hr;

	ASSERT(pIUnknown != NULL);
	ASSERT(m_punk == NULL);

	hr = pIUnknown->QueryInterface(riid, &pvTemp);
	if (SUCCEEDED(hr))
	{
		m_punk = reinterpret_cast<TYPE *>(pvTemp);
	}

	return hr;
}

/*-----------------------------------------------------------------------------
Name:	COleRef::IsNull

Description:
Returns TRUE if the COleRef does not reference an object currently.
-----------------------------------------------------------------------------*/
template <class TYPE> inline BOOL COleRef<TYPE>::IsNull() const
{
	return (m_punk == NULL);
}

/*-----------------------------------------------------------------------------
Name:	COleMalloc::COleMalloc

Description:
Construct a COleMalloc object by allocating on the heap an instance of the
associated object.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::COleMalloc
(
TYPE*	pItem
)	: m_pItem(pItem)
	{
	return;
	}

/*-----------------------------------------------------------------------------
Name:	COleMalloc::~COleMalloc

Description:
Construct a COleMalloc object by allocating on the heap an instance of the
associated object.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::~COleMalloc()
	{
	if (m_pItem != NULL)
		::FreeOlePtr(m_pItem);
	}
	

/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator TYPE*

Description:
Overload the "TYPE*" conversion operator so that instances of COleMalloc may
be treated exactly like instances of TYPE*.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::operator TYPE*() const
	{
	return m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator->

Description:
Overload the "->" operator so that instances of COleMalloc may be used as
real pointers.
-----------------------------------------------------------------------------*/
/*template <class TYPE> inline TYPE* COleMalloc<TYPE>::operator->() const
	{
	ASSERT(m_pItem);
	return m_pItem;
	}
*/

/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator*

Description:
Overload the "*" (indirection) operator so that instances of COleMalloc may
be used as real pointers.
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE& COleMalloc<TYPE>::operator*() const
	{
	ASSERT(m_pItem);
	return *m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator&

Description:
Overload the "&" operator so that instances may be passed to functions
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleMalloc<TYPE>::operator&()
	{
	ASSERT(!m_pItem);
	return &m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator=

Description:
Overload the "=" operator to allow replacement of the pointer (the existing
pointer, if any, is deleted)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleMalloc<TYPE>::operator=
(
TYPE*	pItem
)
	{
	ASSERT(!m_pItem);
	return (m_pItem = pItem);
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::Delete

Description:
Free the held resource and clear the internal pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline void COleMalloc<TYPE>::Delete()
	{
	if (m_pItem)
		{
		::FreeOlePtr(m_pItem);
		m_pItem = NULL;
		}
	return;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::Disown

Description:
Drop ownership of the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleMalloc<TYPE>::Disown()
	{
	TYPE*	pItem = m_pItem;
	m_pItem = NULL;
	return pItem;
	}

/////////////////////////////////////////////////////////////////////////////
// random useful stuff

#define IMPLEMENT_METHOD_(rettype, base, derived, method, defargs, useargs)		\
	rettype base::X##derived::method defargs									\
	{																			\
		METHOD_PROLOGUE(base, derived)											\
		return pThis->External##method useargs;									\
	}

#define IMPLEMENT_ADDREF(base, derived)						\
	IMPLEMENT_METHOD_(ULONG, base, derived, AddRef, (), ())
#define IMPLEMENT_RELEASE(base, derived)					\
	IMPLEMENT_METHOD_(ULONG, base, derived, Release, (), ())
#define IMPLEMENT_QUERYINTERFACE(base, derived)				\
	IMPLEMENT_METHOD_(HRESULT, base, derived, QueryInterface,		\
									 (REFIID iid, void FAR* FAR* ppvObj), (&iid, ppvObj))


#endif //__OLEREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\msgboxes.inl ===
/* MsgBoxes.inl
 *                                                    
 * Purpose:	Inline implementations for message boxes.
 *
 * Created:	28 July 1993 -by- Andrew Milton [w-amilt]
 *
 * Notes:	See <MsgBoxes.h> for details.
 *	
 * Copyright (c) 1993 Microsoft Corporation.  All rights reserved. 
 ****************************************************************************/

#ifndef MSGBOXES_H

#error Must #include 'msgboxes.h' before 'msgboxes.inl'

#else

#ifndef MSGBOXES_INL
#define MSGBOXES_INL

/***************************** Inline Function ******************************\
 MsgBox()

 Purpose:	Load a string from the resource table & display it in a message
 			box.

 Returns:	ID of the button pressed to dismiss the box.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/
 
inline int 
MsgBox(
	const MsgBoxTypes BoxType,
	const int nMessageID,
	UINT nButtonIDs, 	/* = DEFAULT_BUTTONS 	*/
	UINT nHelpContext)	/* = DEFAULT_HELP		*/
{
	CString strMsg;
	strMsg.LoadString(nMessageID);
	return(MsgBox(BoxType, strMsg, nButtonIDs, nHelpContext));
}

/***************************** Inline Function ******************************\
 [V]MsgText()

 Purpose:	To load strings from the resource table for formatting purposes.

 Returns:	Pointer to the formatted text.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR
VMsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	va_list VarArguments)
{
	CString strMsgFormat;
	VERIFY(strMsgFormat.LoadString(idsMsgFormat));
	return SubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	...)
{ 
	CString strMsgFormat;
	VERIFY(strMsgFormat.LoadString(idsMsgFormat));
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);
	return SubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	const int idsFileOperation,
	const CFileException *peOffence)
{
	CString strOperation;
	VERIFY(strOperation.LoadString(idsFileOperation));
	return MsgText(strBuffer, pathOffendingFile, strOperation, peOffence);
}

/***************************** Inline Function ******************************\
 InformationBox()
 QuestionBox()
 ErrorBox()

 Purpose:	Shortcut functions for the IDE's convenience.  Let's not be
 			using these, eh?

 Returns:	Information - Nada, Error - FALSE, Question - Button pressed.

 Notes:		Roughly speaking, we have <Foo>Box(ids, <stuff>) is the same as
 			MsgBox(<Foo>, MsgText(str, ids, <stuff>))
			The exception is QuestionBox, which sets the available buttons.

			These functions were ripped out of VCPP32\C\UTIL.C 

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline BOOL __cdecl 
ErrorBox(
	UINT idsMsgFormat,
	...)
{
	CString strErrText;
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);

	MsgBox(Error, VMsgText(strErrText, idsMsgFormat, VarArguments));

	return FALSE; //Keep it always FALSE please
}

inline void __cdecl
InformationBox(
	UINT idsMsgFormat,
	...)
{
	CString strInfoText;
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);

	MsgBox(Information, VMsgText(strInfoText, idsMsgFormat, VarArguments));

	return; 
}

inline int __cdecl 
QuestionBox(
	UINT idsMsgFormat,
	UINT nButtons,
	...)
{
	CString strQuestionText;
	va_list VarArguments;
	va_start(VarArguments, nButtons);

	return MsgBox(Question, 
					VMsgText(strQuestionText, idsMsgFormat, VarArguments),
					nButtons);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\proppage.h ===
/////////////////////////////////////////////////////////////////////////////
//	PROPPAGE.H
//		Defines classes which can be used to display a property page
//		to view a CSlob's property map

#ifndef __PROPPAGE_H__
#define __PROPPAGE_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CSlob;
class CSheetWnd;
class COleAllPage;

// CControlMap is a structure that maps control ids to property ids and
// control types.  An array of these is defined for each property dialog
// by using the macros below (DECLARE_IDE_CONTROL_MAP, BEGIN_IDE_CONTROL_MAP,
// END_IDE_CONTROL_MAP, etc.)

class CEnum;

struct CControlMap
{
	UINT m_nCtlID;		// dialog id for m_nCtlType == page
	UINT m_nLastCtlID;	// name string id for m_nCtlType == page

	UINT m_nProp;		// optional page help ID for m_nCtlType == page

	enum CTL_TYPE
	{
		null,
		check,
		list,
		checkList,
		comboList,
		comboText,
		autoComboList,
		edit,
		autoEdit,
		radio,
		page,
		editInt,		// FUTURE: some of these types could be removed,
		editNum,		// and achieved through flags.  But no hurry.
		thinText,
		thickText,
		icon,
		editStrCap,
		bitmap,
		listText,
		symbolCombo,
		pathText,
	} m_nCtlType;

	DWORD m_dwFlags;

	UINT m_nExtra;		// extra UINT, eg. used for offset in RADIO

//	union {
//		CEnum* m_pEnum; // for lists and combos
//	} u;
};

// flags for CControlMap::m_dwFlags:
enum
{
	CM_EXTRA_ENUM   = 0x001,	// m_nExtra is a CEnum*
	CM_EXTRA_LIMIT	= 0x002,	// m_nExtra is a limit value (UINT)
	CM_EXTRA_OFFSET = 0x003,	// m_nExtra is an offset
	CM_EXTRA_HELPID = 0x004,	// m_nExtra is a HelpID (of a page)
	CM_EXTRA_MASK   = 0x0ff,	// for (m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_*
	CM_NOAMBIGUOUS	= 0x100,	// disable control if value is ambiguous
	CM_NOMULTISEL   = 0x200,	// disable control for any multiple selection
};


// Include this inside a CSlobPage-derived class declaration.
#define DECLARE_IDE_CONTROL_MAP() \
	virtual CControlMap* GetControlMap(); \
	static CControlMap m_controlMap [];

// Include these with the implementation of a CSlobPage-derived class.
#define BEGIN_IDE_CONTROL_MAP(theClass, nDlgID, nNameID) \
	CControlMap* theClass::GetControlMap() \
		{ return &m_controlMap[0]; } \
	CControlMap theClass::m_controlMap [] = { \
		{ nDlgID, nNameID, 0, CControlMap::page, 0x0, NULL },

#define BEGIN_IDE_CONTROL_MAP_H(theClass, nDlgID, nNameID, nHelpID) \
	CControlMap* theClass::GetControlMap() \
		{ return &m_controlMap[0]; } \
	CControlMap theClass::m_controlMap [] = { \
		{ nDlgID, nNameID, 0, CControlMap::page, CM_EXTRA_HELPID, nHelpID },

#define END_IDE_CONTROL_MAP() { 0, 0, 0, CControlMap::null, 0x0, NULL } };


// These macros define CControlMap structures for inclusion between
// the BEGIN_IDE_CONTROL_MAP and END_IDE_CONTROL_MAP macros.
#define MAP_CHECK(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::check,      0x0,  NULL },
#define MAP_LIST(nCtlID, nProp, pEnum) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::list,       CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_LIST_TEXT(nCtlID, nProp, pEnum) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::listText,   CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_CHECK_LIST(nCtlID, pEnum) \
	{ nCtlID,  nCtlID,  0,      CControlMap::checkList,  CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_COMBO_LIST(nCtlID, nProp, pEnum) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::comboList,  CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_COMBO_TEXT(nCtlID, nProp, pEnum) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::comboText,  CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_AUTO_COMBO_LIST(nCtlID, nProp, pEnum) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::autoComboList, CM_EXTRA_ENUM, (UINT)&pEnum },
#define MAP_EDIT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::edit,       0x0,  NULL },
#define MAP_EDIT_LIMIT(nCtlID, nProp, nLimit) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_EXTRA_LIMIT, nLimit },
#define MAP_EDIT_INT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::editInt,    0x0,  NULL },
#define MAP_EDIT_NUM(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::editNum,    0x0,  NULL },
#define MAP_AUTO_EDIT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::autoEdit,   0x0,  NULL },
#define MAP_AUTO_EDIT_LIMIT(nCtlID, nProp, nLimit) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::autoEdit,   CM_EXTRA_LIMIT, nLimit },
#define MAP_RADIO(nFirstCtlID, nLastCtlID, nOffset, nProp) \
	{ nFirstCtlID, nLastCtlID, nProp, CControlMap::radio,  CM_EXTRA_OFFSET, nOffset },
#define MAP_THIN_TEXT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::thinText,   0x0,  NULL },
#define MAP_THICK_TEXT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::thickText,  0x0,  NULL },
#define MAP_ICON(nCtlID) \
	{ nCtlID,  nCtlID,  0,      CControlMap::icon,       0x0,  NULL },
#define MAP_EDIT_STRCAP(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::editStrCap, 0x0,  NULL },
#define MAP_BITMAP(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::bitmap,     CM_NOAMBIGUOUS,  NULL },
#define MAP_SYMBOL_COMBO(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::symbolCombo, 0x0, NULL },
#define MAP_PATH_TEXT(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::pathText,   0x0,  NULL },
#define MAP_EDIT_NOAMBIG(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_NOAMBIGUOUS,  NULL },
#define MAP_EDIT_NOMULTISEL(nCtlID, nProp) \
	{ nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_NOMULTISEL,  NULL },

class C3dPropertyPage : public CDialog
{
public:
	DECLARE_DYNAMIC(C3dPropertyPage)

public:
	C3dPropertyPage();

	virtual BOOL Create(UINT nIDSheet, CWnd* pWndOwner) = 0;

	virtual BOOL SetupPage(CSheetWnd* pSheetWnd, CSlob* pSlob);
	virtual void Activate(UINT nState, CSlob* pCurSlob);
	
	virtual void InitializePage();
	virtual void TermPage();
	virtual BOOL ShowPage(int nCmdShow);
	virtual void MovePage(const CRect& rect);

	virtual BOOL Validate() = 0;
	virtual BOOL UndoPendingValidate() = 0;

	virtual void OnActivate();
	virtual void OnDeactivate();
	virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam);

	virtual void GetPageName(CString& strName);
	virtual CSize GetPageSize();
	virtual BOOL IsPageActive() { return m_hWnd != NULL; }
	virtual BOOL IsPageDisabled() { return FALSE; }

	CSlob* GetSlob() { return m_pSlob; }

protected:
	CSlob* m_pSlob;
	CSheetWnd* m_pSheetWnd;

	friend class CSheetWnd;
	friend class CMultiSlob;
};

/////////////////////////////////////////////////////////////////////////////
//	COlePage property page

class COlePage : public C3dPropertyPage
{
public:
	DECLARE_DYNAMIC(COlePage)

public:
	// Page caching.
	static CObList s_listPages;
	static LPUNKNOWN *s_pObjectCurrent;
	static LPUNKNOWN s_pSingleObject;
	static ULONG s_nObjectCurrent;
	static UINT s_nPagesCurrent;
	static LPCLSID s_lpClsID;
	static BOOL s_bPossibleUnusedServers;
	static COleAllPage *s_pAllPage;


//$UNDONE HACK HACK HACK get rid of this when the resource package changes its
// data bound control handling
	static BOOL s_fShowAllPage;
	static BOOL GetShowAllPage();
	static void SetShowAllPage(BOOL fSet);

	static UINT LoadPages(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
	static UINT LoadAllPageOnly(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
	static BOOL InPageCache(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
	static UINT AddAllPageToList(UINT nPagesCurrent, CAUUID *pcaGUID);
	static HRESULT DoPageIntersection(ISpecifyPropertyPages *pSPP, CAUUID *pcaGUID);
	static C3dPropertyPage* GetPropPage(UINT iPage);
	static C3dPropertyPage* GetPropPage(REFCLSID clsid);
	static void Cleanup();
	static void SetUnusedServers(BOOL fUnused = TRUE);

protected:
	COlePage(REFCLSID clsid);	// Use GetPropPage()
	~COlePage();

public:
	BOOL IsUsable()
		{ return m_lpPropPage != NULL; }

	virtual BOOL Create(UINT nIDSheet, CWnd* hWndOwner);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void InitializePage();
	virtual void TermPage();
	virtual BOOL ShowPage(int nCmdShow);
	virtual void MovePage(const CRect& rect);
	virtual BOOL DestroyWindow();

	virtual BOOL Validate();
	virtual BOOL UndoPendingValidate();

	virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam);

	virtual void GetPageName(CString& strName);
	virtual CSize GetPageSize();
	virtual BOOL IsPageActive() { return m_bActive; }

	void EditProperty(DISPID dispid);
	inline void GetCLSID (CLSID * pClsID)
	{
		if (pClsID)
			*pClsID = m_clsid;
	}

// Attributes
protected:
	BOOL m_bActive:1;
	BOOL m_bVisible:1;
	BOOL m_bTranslatingAccel:1;

	CLSID m_clsid;
	CString m_strName;
	CSize m_size;

	LPPROPERTYPAGE m_lpPropPage;

// Interface Maps   
protected:
	// IPropertyPageSite
	BEGIN_INTERFACE_PART(PropertyPageSite, IPropertyPageSite)
		INIT_INTERFACE_PART(COlePage, PropertyPageSite)
		STDMETHOD(OnStatusChange)(DWORD);
		STDMETHOD(GetLocaleID)(LCID FAR*);
		STDMETHOD(GetPageContainer)(LPUNKNOWN FAR*);
		STDMETHOD(TranslateAccelerator)(LPMSG);
	END_INTERFACE_PART(PropertyPageSite)

	DECLARE_INTERFACE_MAP()

	friend COleAllPage;
};

// CSlobPages are CDialogs that use the CSlob property mechanism to
// automaticly handle the dialog.

class CSlobPage : public C3dPropertyPage
{
public:
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_DYNAMIC(CSlobPage)

public:
	CSlobPage();

	virtual BOOL Create(UINT nIDSheet, CWnd* pWndOwner);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void InitializePage();
	virtual void InitPage();

	BOOL EnablePage(BOOL bEnable = TRUE);
	virtual BOOL IsPageDisabled() { return !m_bEnabled; }

	virtual BOOL Validate();
	virtual BOOL UndoPendingValidate();

	virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam)
			{
				return C3dPropertyPage::OnPageHelp(wParam, lParam);
			}

	virtual BOOL OnPropChange(UINT nProp);
	virtual void GetPageName(CString& strName);

	CControlMap* FindControl(UINT nCtlID);
	CControlMap* FindProp(UINT nProp);

protected:
	// m_nValidateID is set to the ID of a control that will need to be validated
	// by Validate() as soon as that control has been changed.  It will
	// be NULL if nothing needs to be validated.  This will mainly be
	// used by edits and combos that are normally validated when they
	// loose the focus.  Needs to be in here for the Escape accelerator.

	int m_nValidateID;

	BOOL m_bIgnoreChange:1;
	BOOL m_bEnabled:1;

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);

	DECLARE_MESSAGE_MAP()
};

void StringEditorEditToProp(char* szBuf);
void StringEditorPropToEdit(CString& str);

/////////////////////////////////////////////////////////////////////////////
// List and Combo Box Enumerations...

// One entry in an enumeration
struct CEnumerator
{
	const char* szId;
	int val;
};

class CPropCheckList;

// An enumeration
class CEnum
{
public:
	virtual void FillListBox(CListBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
	virtual void FillCheckList(CPropCheckList* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
	virtual void FillComboBox(CComboBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);

	virtual BOOL ContainsVal(int val);
	virtual POSITION GetHeadPosition();
	virtual CEnumerator* GetNext(POSITION& pos);

	virtual CEnumerator* GetList()
		{ ASSERT(FALSE); return(NULL); };
};


// this is a enum designed to store its strings in the string table

// One entry in a localized enumeration
struct CLocalizedEnumerator
{
	CLocalizedEnumerator( UINT aId, int aVal );
	CString szId;
	UINT id;
	int val;
};

// A localized enumeration
class CLocalizedEnum : public CEnum
{
public:
	virtual void FillListBox(CListBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
	virtual void FillCheckList(CPropCheckList* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
	virtual void FillComboBox(CComboBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);

	virtual BOOL ContainsVal(int val);
	virtual POSITION GetHeadPosition();
	virtual CLocalizedEnumerator* GetNextL(POSITION& pos);
	virtual CEnumerator* GetNext(POSITION& pos)
		{ ASSERT( FALSE ); return (NULL); };	// You must use GetNextL()
	virtual CLocalizedEnumerator *GetListL()
		{ ASSERT( FALSE ); return (NULL); };
};


// Helper macros for making enumerations
#define DECLARE_ENUM_LIST() \
	public: \
	virtual CEnumerator* GetList() \
				{ return &c_list[0]; } \
	static CEnumerator c_list [];

// Define the enumerator identifiers and values in this table
#define BEGIN_ENUM_LIST(theClass) \
	CEnumerator theClass::c_list [] = {

#define END_ENUM_LIST() \
	{ NULL, 0 } };

// Define a simple CEnum derived class
#define DEFINE_ENUM(theEnum) \
	class C##theEnum : public CEnum { DECLARE_ENUM_LIST() }; \
	C##theEnum NEAR theEnum; \
	BEGIN_ENUM_LIST(C##theEnum)

#define DECLARE_ENUM(theEnum) \
	class C##theEnum : public CEnum { DECLARE_ENUM_LIST() }; \
	extern C##theEnum NEAR theEnum;

// Helper macros for making localized enumerations
#define DECLARE_LOCALIZED_ENUM_LIST() \
	public: \
	virtual CLocalizedEnumerator* GetListL() \
				{ return &c_list[0]; } \
	static CLocalizedEnumerator c_list [];

// Define the enumerator identifiers and values in this table
#define BEGIN_LOCALIZED_ENUM_LIST(theClass) \
	CLocalizedEnumerator theClass::c_list [] = {

// A localized enumeration entry
#define LOCALIZED_ENUM_ENTRY(id,val) \
	CLocalizedEnumerator( id, val ),

#define END_LOCALIZED_ENUM_LIST() \
	CLocalizedEnumerator( 0, 0 ) };

// Define a simple CLocalizedEnum derived class
#define DEFINE_LOCALIZED_ENUM(theEnum) \
	class C##theEnum : public CLocalizedEnum { DECLARE_LOCALIZED_ENUM_LIST() }; \
	C##theEnum NEAR theEnum; \
	BEGIN_LOCALIZED_ENUM_LIST(C##theEnum)

#define DECLARE_LOCALIZED_ENUM(theEnum) \
	class C##theEnum : public CLocalizedEnum { DECLARE_LOCALIZED_ENUM_LIST() }; \
	extern C##theEnum NEAR theEnum;

/////////////////////////////////////////////////////////////////////////////
// Property Browser API

#define WM_USER_VALIDATEREQ (WM_USER + 3)

void SetPropertyBrowserVisible(BOOL bVisible); // show/hide and set visible state
void ShowPropertyBrowser(BOOL bShow = TRUE);   // show/hide (temporary)
BOOL IsPropertyBrowserVisible();               // visibility test
void PinPropertyBrowser(BOOL bPin = TRUE);	   // toggles the pushpin when visible
BOOL IsPropertyBrowserPinned();				   // pinned test
void ResetPropertyBrowserSelectionSlob(CSlob* pSlob);

void InvalidatePropertyBrowser();	           // repaint property browser
void UpdatePropertyBrowser();                  // force page to reflect selection
BOOL ValidatePropertyBrowser();                // validate pending changes
void ActivatePropertyBrowser();                // activate and show
void DeactivatePropertyBrowser();              // return focus to the app
void CancelPropertyBrowser();                  // cancel changes
void ClosePropertyBrowser();                   // really just hides it and sets popping off
BOOL BeginPropertyBrowserEdit(UINT nProp,      // edit a specific property
	UINT nChar = 0, UINT nRepeat = 0, UINT nFlags = 0);
CWnd* GetPropertyBrowserControl(UINT nID);     // get a control on for the current object
C3dPropertyPage* GetNullPropertyPage();        // get null page (has ID controls)
C3dPropertyPage* GetCurrentPropertyPage();     // current propert page
void SetPropertyBrowserDefPage();              // make the currect page the default
BOOL IsPropertyBrowserInCancel();              // did the user just cancel
BOOL IsPropertyBrowserValidating();            // is the page being validated

// Methods used during CSlob::SetupPropertyPages()
int AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob);
void SetPropertyCaption(LPCTSTR sz);
BOOL AppendExtraPropertyPages(void);
BOOL InhibitExtraPropertyPages(BOOL bInhibit = TRUE);
int StartNewPropertyPageSet(void);
int MergePropertyPageSets(void);

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __PROPPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shlbar.h ===
/////////////////////////////////////////////////////////////////////////////
//      SHLBAR.H
//              All shell toolbar related classes.  For customizable docking
//              toolbars use the mechanism provided by the Dock API.

#ifndef __SHLBAR_H__
#define __SHLBAR_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//      COldToolBar
//              Toolbar class from MFC 3.0 before they switched to system toolbars.
//              We continue to draw our own toolbars.

// Warning, these structures are currently still shared with the res package toolbars.
#ifndef _AFX_TBBUTTON_DEFINED
struct AFX_TBBUTTON
{
	UINT nID;        // Command ID that this button sends
	UINT nStyle;    // TBBS_ styles
	int iImage;     // index into mondo bitmap of this button's picture
						// or size of this spacer
};
#define _AFX_TBBUTTON_DEFINED
#endif

#ifndef _ORIENTATION_DEFINED
enum ORIENTATION {
	orNil,
	orHorz,
	orVert };
#define _ORIENTATION_DEFINED
#endif

// ORIENTATION has been promoted from CCustomBar to CToolbar, so that GetItemRect can take an orientation
// parameter. This allows GetItemRect to depend on orientation directly, rather than through hacks, as
// previously. For CToolBars, ORIENTATION should always be orHorz
#if 0
#ifndef _MAC
HBITMAP AFXAPI AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc);
#else
HBITMAP AFXAPI AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc,
	HDC hDCGlyphs, BOOL bMonochrome);
#endif
#endif

class COldToolBar : public CControlBar
{
	DECLARE_DYNAMIC(COldToolBar)

// Construction
public:
	COldToolBar();
	BOOL Create(CWnd* pParentWnd,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP,
			UINT nID = AFX_IDW_TOOLBAR);

	void SetSizes(SIZE sizeButton, SIZE sizeImage);
				// button size should be bigger than image
	void SetHeight(int cyHeight);
				// call after SetSizes, height overrides bitmap size
	void SetDefaultSizes();
				// sets the sizes to their default UISG values
				// does not cause any redrawing
	static CSize GetDefaultBitmapSize();
				// returns the size of a standard toolbar bitmap
	static CSize GetDefaultButtonSize();
				// returns the size of a standard toolbar button
	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL SetButtons(const UINT* lpIDArray, int nIDCount);
				// lpIDArray can be NULL to allocate empty buttons

// Attributes
public: // standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	// this is provided for compatability with other clients. In subclasses it is overridden privately
	// and never implemented, to avoid problems
	inline void GetItemRect(int nIndex, LPRECT lpRect) const { GetItemRect(nIndex, lpRect, GetOrient()); };
	virtual void GetItemRect(int nIndex, LPRECT lpRect, ORIENTATION or) const;
	virtual ORIENTATION GetOrient() const;
	UINT GetButtonStyle(int nIndex) const;  //REVIEW: doc
	void SetButtonStyle(int nIndex, UINT nStyle);   //REVIEW: doc

public:
	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);

// Implementation
public:
	virtual ~COldToolBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// update the text of a button
	virtual void UpdateText(int nIndex, LPCTSTR newText) {};

	// get the image well
	HBITMAP GetImageWell(void) { return m_hbmImageWell; };

	// cmdui needs to know this
	int GetCaptureIndex(void) { return m_iButtonCapture; };
	// kills extrusion, capture, etc
	void CancelMode(void) { OnCancelMode(); };

protected:
	AFX_TBBUTTON* _GetButtonPtr(int nIndex) const;
	void InvalidateButton(int nIndex);
	virtual void UpdateButton(int nIndex);
	void CreateMask(int iImage, CPoint offset, 
		BOOL bHilite, BOOL bHiliteShadow);

	// for custom drawing
	struct DrawState
	{
		HBITMAP hbmMono;
		HBITMAP hbmMonoOld;
		HBITMAP hbmOldGlyphs;
	};
	BOOL PrepareDrawButton(DrawState& ds);
	BOOL DrawButton(CDC* pDC, int x, int y, int iImage, UINT nStyle, BOOL bOutlineOnly=FALSE, CRect *pImageBounds=NULL);
#ifdef _MAC
	BOOL DrawMonoButton(CDC* pDC, int x, int y, int dx, int dy,
		int iImage, UINT nStyle);
#endif
	void EndDrawButton(DrawState& ds);

protected:
	CSize m_sizeButton;         // size of button
	CSize m_sizeImage;          // size of glyph
	int m_cxSharedBorder;       // shared x border between buttons
	int m_cySharedBorder;       // shared y border between buttons
	HBITMAP m_hbmImageWell;     // glyphs only
	int m_iButtonCapture;       // index of button with capture (-1 => none)
	HRSRC m_hRsrcImageWell;     // handle to loaded resource for image well
	HINSTANCE m_hInstImageWell; // instance handle to load image well from

#ifdef _MAC
	// Macintosh toolbars need per-toolbar DCs in order to
	// work correctly in multiple-monitor environments

	HDC m_hDCGlyphs;            // per-toolbar DC for glyph images
	HDC m_hDCMono;              // per-toolbar DC for mono glyph masks
#else
public:
	static HDC s_hDCGlyphs;     // shared DC for glyph images
	static HDC s_hDCMono;		// shared DC for mono glyph masks
protected:
#endif

	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual int HitTest(CPoint point, BOOL bCheckWindow=TRUE) const;
	virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	// called when the button has been pressed; the graphic will be drawn in the pressed
	// state. Return TRUE to un-press the button, or FALSE to leave it pressed
	virtual BOOL OnButtonPressed(int iButton);
	// called when the system has detected the potential to apply the extruded style to a button
	// buttons which don't support this style should return FALSE
	virtual BOOL ShouldExtrude(int iButton);

	//{{AFX_MSG(COldToolBar)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

// define CToolBar to COldToolBar for convenience
#define CToolBar COldToolBar

#ifndef _DEBUG
inline AFX_TBBUTTON* CToolBar::_GetButtonPtr(int nIndex) const
{       return ((AFX_TBBUTTON*)m_pData) + nIndex; }
#endif

class COldToolCmdUI : public CCmdUI        // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

#define CToolCmdUI COldToolCmdUI

/////////////////////////////////////////////////////////////////////////////
//      C3dBitmapButton
//              Bitmap button for use in dialog bars.  Correctly returns focus,
//              and uses fewer bitmaps than MFC bitmap buttons.

class C3dBitmapButton : public CBitmapButton
{
public:
	C3dBitmapButton();

	BOOL AutoLoad(UINT nID, CWnd* pParent,
		BOOL bToggle = FALSE, LPCRECT lpRect = NULL);

protected:
	BOOL m_bToggle;

protected:
	BOOL DrawBitmaps(BOOL bToggle, LPCRECT lpRect);
	virtual HBITMAP CreateButtonBitmap(UINT nStyle,  LPCRECT lpRect,
		CBitmap* pbmGlyph = NULL, LPCTSTR lpszText = NULL);

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

	afx_msg void OnLButtonUp(UINT nFlags, CPoint);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint);
	afx_msg void OnSysColorChange();

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//      C3dToggleBitmapButton

class CToggleBitmapButton: public C3dBitmapButton
{
    DECLARE_MESSAGE_MAP()

protected:
	BOOL    m_fDown;

public:
	CToggleBitmapButton();
	BOOL    IsButtonDown()  { return m_fDown; }
	void    SetChecked(BOOL);

	afx_msg void OnLButtonUp(UINT nFlags, CPoint);
};

/////////////////////////////////////////////////////////////////////////////
//      C3dDialogBar
//              All Dev Studio dialog bars should derive from this class.
//              It can be used in MDI, modeless floating, as well as dockable
//              windows.

enum DOCKPOS;

class C3dDialogBar : public CDialogBar
{
public:
	C3dDialogBar();

	BOOL Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName,
			UINT nStyle, UINT nID);
	BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
			UINT nStyle, UINT nID);
			
	BOOL CreateIndirect(const void *lpDialogTemplate, CWnd* pParentWnd,
			UINT nStyle, UINT nID);

	virtual BOOL PreTranslateSysKey(MSG* pMsg);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

    //{{AFX_MSG(C3dDialogBar)
    afx_msg UINT OnNcHitTest(CPoint pt);
	//}}AFX_MSG

    DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(C3dDialogBar)

public:
	void SetDockableID(UINT nID);
	void RecalcBarLayout(DOCKPOS dp, BOOL bForceCenter = FALSE);

	void VertCenterControls(int cySize = 0);

protected:
	UINT m_nDockableID;
};

inline BOOL C3dDialogBar::Create(CWnd* pParentWnd, UINT nIDTemplate,
	UINT nStyle, UINT nID)
{       return Create(pParentWnd, MAKEINTRESOURCE(nIDTemplate), nStyle, nID); }
inline void C3dDialogBar::SetDockableID(UINT nID)
{       m_nDockableID = nID; }

/////////////////////////////////////////////////////////////////////////////
//      CFloatingFrameBar
//              This is the embedded toolbar for the CFloatingFrameWnd class.  It
//              contains a push-pin and a help button.  Since most of our floating
//              windows want more stuff on their toolbar, they derive from this
//              class and add additional buttons.

class CFloatingFrameBar : public C3dDialogBar
{
public:
	CFloatingFrameBar();
	BOOL Create(CWnd* pParentWnd, UINT nIDTemplate);

	CToggleBitmapButton     m_btnPushPin;
	C3dBitmapButton         m_btnHelp;

	virtual BOOL OnInitDialog();

	DECLARE_DYNAMIC(CFloatingFrameBar)
};

/////////////////////////////////////////////////////////////////////////////
//      CFloatingFrameWnd
//              A modeless window which floats above the main frame, and also
//              contains a toolbar with at least pushpin and help buttons.
//              The shell also uses this class to identify floating windows for
//              special message processing.  Since the shell uses IsKindOf() testing,
//              it is essential that all floating windows derive from this class.

class CFloatingFrameWnd : public CFrameWnd
{
public:
	CFloatingFrameWnd::CFloatingFrameWnd();
	CFloatingFrameWnd::~CFloatingFrameWnd();

	virtual BOOL OnCreateClient(LPCREATESTRUCT lpCreateStruct, CCreateContext* pCreateContext);
	virtual BOOL PreTranslateMessage(MSG *pmsg);

	virtual DWORD GetHelpID()       { return 0; }   // derived classes will override
	CFloatingFrameBar*      GetToolBar()    { return m_pToolBar; }

	BOOL    IsWindowPinned();
	void    SetPushPin(BOOL bPinned);

	afx_msg void OnHelp();                          // help button pressed
	afx_msg void OnPushPin();                       // pushpin pressed
	afx_msg void OnActivate(UINT nState, CWnd*, BOOL);
	afx_msg void OnActivateApp(BOOL, HTASK);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);

protected:
	CFloatingFrameBar* m_pToolBar;

	DECLARE_DYNAMIC(CFloatingFrameWnd)
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//      Toolbar controls for use in customizable dockable toolbars
//              Controls correctly call DkPreHandleMessage.

// Class declarations
class CDockEdit ;       // Dockable Edit control.
class CDockCombo ;      // Dockable Combo box.
class CToolbarCombo ;   // Combo box used as part of the toolbar.
class CDockComboEdit ;          // Used internally only.


class CDockEdit : public CEdit
{
public:
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
};

class CDockComboEdit : public CWnd
{
	// Construction
public:
	CDockComboEdit(BOOL fDockable = TRUE);

protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
	BOOL m_fDockable; // set false to use in a dialog
};

class CDockCombo : public CComboBox
{
// Construction
public:
	CDockCombo(BOOL fDockable = TRUE);

    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

	virtual CWnd* SubclassEdit();
    
protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();
	
protected:
	CWnd* m_pChildEdit;
	BOOL m_fDockable;       // set false to use in a dialog
};

class CToolbarCombo : public CDockCombo 
{
// Generated message map functions
protected:
	//{{AFX_MSG( CToolbarCombo )
	afx_msg UINT OnNcHitTest(CPoint point);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

#include "shlbar.h"

class CToolbarEditCombo;

HWND CreateToolbarEditCombo(CToolbarEditCombo *pCombo, DWORD dwStyle, RECT* lpRect, HWND hwndParent, UINT nID);

class CToolbarEditCombo : public CToolbarCombo
{
// Construction.
public:
	CToolbarEditCombo();
	~CToolbarEditCombo();

	Create(DWORD dwStyle, const RECT& rect, CWnd* pWnd, UINT nID);

	virtual CWnd* SubclassEdit();
	virtual void PostNcDestroy();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
	DECLARE_DYNAMIC(CToolbarEditCombo);

public:
	virtual void UpdateView()=0;
	virtual void OnEditSetFocus(void)=0;
	virtual void OnEditKillFocus(void)=0;
	virtual BOOL OnEditHelp(void)=0;

    DECLARE_MESSAGE_MAP()

// Attributes.
protected:
	UINT m_nId; // Help ID
};

class CToolbarEditComboEdit : public CWnd
{
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

public:
	DECLARE_DYNAMIC(CToolbarEditComboEdit);
};

BOOL DrawButtonGlyph(CDC* pDC,
					 int x, int y,
					 CPoint ptOffset,
					 int iImage,
					 UINT nStyle,
					 const SIZE& sizeButton,
					 const SIZE& sizeImage,
					 HDC hdcGlyphs,
					 HDC hdcMono);

#undef AFX_DATA
#define AFX_DATA NEAR

#endif  // !__SHLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\package.h ===
/////////////////////////////////////////////////////////////////////////////
//	PACKAGE.H
//		pack, package and packet objects

#ifndef __PACKAGE_H__
#define __PACKAGE_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CKeymap;
class CFormatInfo;
class CSushiBarInfo;
class CPackage;
class CBMenuPopup;

/////////////////////////////////////////////////////////////////////////////
//	CPack class

class CPack : public CCmdTarget
{
	DECLARE_DYNAMIC (CPack)
public:
	CPack(CPackage* pPackage, UINT nIDPackage, LPCTSTR lpAccelID);
	~CPack();

// Attributes
public:
	HINSTANCE HInstance();
	UINT PackageID();
	UINT PacketID();

	CPackage* GetPackage() { return m_pPackage; }
	LPCTSTR GetAcceleratorID() const { return m_lpAccelID; }

protected:
	CPackage* m_pPackage;
	UINT m_nIDPacket;

// REVIEW: Protect this.
public:
	LPCTSTR m_lpAccelID;
};

/////////////////////////////////////////////////////////////////////////////
//	CPacket class

class CPacket : public CPack
{
public:
	CPacket(CPackage* pPackage, UINT id,
		LPCTSTR lpCmdTableID = NULL, LPCTSTR lpAccelID = NULL,
		CSushiBarInfo* pSushiBarInfo = NULL);

	virtual DWORD GetHelpID() { return 0; }

//	CKeymap* GetKeymap() { return m_pKeyMap; }
//	CKeymap* m_pKeymap;

	CSushiBarInfo* m_pSushiBarInfo;
};

/////////////////////////////////////////////////////////////////////////////
//	CPackage class

class CStateSaver;
class CGoToDialog;

// Package style flags
#define PKS_IDLE            0x00000001  // OnIdle calls
#define PKS_PRETRANSLATE    0x00000002  // PreTranslateMessage calls
#define PKS_COMMANDS		0x00000004	// OnCmdMsg calls
#define PKS_NOTIFY          0x00000008  // OnNotify calls
#define PKS_INIT			0x00000010  // OnInit call
#define	PKS_QUERYEXIT       0x00000020  // CanExit call
#define PKS_SERIALIZE		0x00000040  // SerializeWorkspaceSettings, SerializeWkspcConvSettings calls
#define PKS_INTERFACES		0x00000080  // QueryInterface calls
#define PKS_HELPFILE        0x00000100  // GetHelpFileName calls
#define PKS_FILES			0x00000200  // Overrides GetAssociatedFiles
#define PKS_FORMAT          0x00000400  // Overrides GetFormatInfo
#define PKS_AUTOMATION		0x00000800  // Overrides GetPackageExtension, GetApplicationExtensions
#define PKS_PROJECTINFO		0x00001000  // Overrides [G|S]etProjectWorkspaceInfo
#define PKS_GLOBALINFO		0x00002000  // Overrides [G|S]etGlobalWorkspaceInfo
#define PKS_PREEXIT			0x00004000	// Overrides OnPreExit()

// OPT Serialization flags
#define OPT_DEFAULT_WRKSPC  0x01
#define OPT_NAMED_WRKSPC    0x02
#define OPT_DOCUMENTS_ONLY  0x04
#define OPT_UNLOAD			0x08
#define OPT_WORKSPACE_ONLY	0x10

struct SRankedStringID
{
	UINT ids;
	UINT nRank;
	const CLSID *pclsid;
	BOOL bIsID;
};

#define MAX_LENGTH_APPLICATION_EXTENSION_NAME 64
struct SApplicationExtension
{
	char szName[MAX_LENGTH_APPLICATION_EXTENSION_NAME];
	CLSID clsid;
};

interface ICommandProvider;
class CProjComponentMgr;
class CPackage : public CPack
{
	DECLARE_DYNAMIC (CPackage)
public:
	CPackage(HINSTANCE hInstance, UINT id, UINT flags,
		LPCTSTR lpCmdTableID = NULL,
		LPCTSTR lpBitmapID = NULL,
		LPCTSTR lpAccelID = NULL,
		LPCTSTR lpLargeBitmapID = NULL);
	~CPackage();

	virtual BOOL OnInit();

	// Why are there three exit routines, you ask?  Here's why, and the order:
	//  1) CanExit():
	//	First, all packages are asked whether it's OK to exit.  Any package
	//   can veto, and exit will be canceled.  This occurs toward the beginning
	//   of CMainFrame::OnClose().
	//  2) OnPreExit()
	//  After it's been determined that no one will veto the exit, this
	//   is called (toward the end of CMainFrame::OnClose()).  Any package
	//   which holds on to OLE objects that call AfxOleLockApp() must
	//   release those objects here.  If not, CMainFrame::DestroyWindow()
	//   will never be called, and it will appear like DevStudio is hanging
	//   even though it's frame window has been hidden.
	//  3) OnExit()
	//  Since all App-locking objects were released in 2), MFC will then call
	//   CMainFrame::DestroyWindow().  It's in this function that OnExit()
	//   is called.  This is where most package destruction should occur.
	virtual BOOL CanExit();			// PKS_QUERYEXIT
	virtual void OnPreExit() {}		// PKS_PREEXIT
	virtual void OnExit();

	virtual BOOL OnIdle(long lCount);
	virtual BOOL OnNotify (UINT id, void *Hint = NULL, void *ReturnArea = NULL );
	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
// Dockable window interface
	virtual HGLOBAL GetDockInfo();
	virtual HWND GetDockableWindow(UINT nID, HGLOBAL hglob);
	virtual HGLOBAL GetToolbarData(UINT nID);
	virtual HICON GetDockableIcon(UINT nID);
	virtual BOOL AskAvailable(UINT nID);
	// gets (and loads, if necessary) the appropriately sized bitmap
	virtual HBITMAP GetBitmap(BOOL bLarge);
	// unloads the bitmap, if loaded
	virtual void UnloadBitmap(void);

// Customization and Options interface
	virtual void AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type);

// Fonts/Colors interface
	virtual CFormatInfo* GetFormatInfo() { return NULL; }
	virtual void GetDefaultFormatInfo(CFormatInfo& fiDefault) {}
	virtual void OnFormatChanged() {}
	virtual void OnFontChange() {}
	virtual void OnColorChange() {}

// Help information (including legal resource, command, and window id ranges)
	enum RANGE_TYPE
	{
		MIN_RESOURCE, MAX_RESOURCE, 
		MIN_COMMAND, MAX_COMMAND, 
		MIN_WINDOW, MAX_WINDOW,
		MIN_STRING, MAX_STRING,
	};
	virtual DWORD GetIdRange(RANGE_TYPE rt);

	// Packages that supply commands known only at run-time, and
	//  which are transient (may come and go in the same session)
	//  must implement ICommandProvider and return it via this
	//  virtual.  See pkgs\include\commapi.h, commguid.h.
	// In keeping with good COM, the callee (package) addrefs the
	//  interface, and the caller (shell) releases it.
	virtual ICommandProvider* GetCommandProvider() { return NULL; }

	enum HELPFILE_TYPE { APPLICATION_HELP, REFERENCE_HELP, CONTROL_HELP };
	virtual LPCTSTR GetHelpFileName(HELPFILE_TYPE hft = APPLICATION_HELP);

// Build system
	// registration of build system components (used by platform add-ons)
	// blc_type	= component type, eg. platform
	// blc_id	= id of component 'hook', eg. a platform if blc_type is a tool
	virtual BOOL DoBldSysCompRegister(CProjComponentMgr *, DWORD blc_type, DWORD blc_id) {return FALSE;}

// Keymap support
	virtual void LoadGlobalAccelerators();

// CommDlg interface
	enum { GODI_FILEOPEN, GODI_RESIMPORT, GODI_ADDFILE, GODI_FINDINFILES, GODI_WORKSPACEOPEN, GODI_INSERTPROJECT };
	virtual void GetOpenDialogInfo(SRankedStringID** ppFilters, 
		SRankedStringID** ppEditors, int nOpenDialog);
	virtual CDocTemplate* GetTemplateFromEditor(UINT idsEditor, 
		const char* szFilename);

// GoTo support
	// Override this in packages that will add things to the Go To dialog. This
	// function is called whenever the Go To dialog is invoked. You should
	// dynamically create CGoToItem objects and add them to pDlg by calling its
	// AddItem() member function. Add a CGoToItem for each thing your package
	// will add to the Go To What listbox. The items will be deleted by the 
	// shell when the dialog is dismissed.
	virtual void AddGoToItems(CGoToDialog *pDlg) {};

// File saving errors
	// Override the following to provide an package specific file I/O
	// error string when using SetFileError.
	virtual int IdsFromFerr(int ferr);

// State serialization
	// Override SaveSettings to save information to the registry.
	virtual void SaveSettings();

// Project workspace interface
// REVIEW(PatBr):  This should be turned into a real innterface, and
//					moved into prjapi.h.
	virtual void GetDefProvidedNodes(CPtrList &DefNodeList, BOOL bWorkspaceInit);

	// Override the following function to save user-specific (non-sharable)
	// workspace specific data.
	virtual void SerializeWorkspaceSettings(CStateSaver& stateSave, DWORD dwFlags);
	virtual void SerializeWkspcConvSettings(CStateSaver& stateSave, DWORD dwFlags);

	// Override the following functions and define PKS_PROJECTINFO if your
	// package has project-specific information which should be saved to
	// and read from the workspace file.
	//
////// NOTE that the semantics of these changed recently./////////////
	// These calls used to occur after PN_OPEN_PROJECT.
	// Now, they occur before it. There is no valid open project when
	// the text is sent. A package can either act on the
	// text immediately, or store it away until PN_OPEN_PROJECT.
	// There's a new notification, PN_OPEN_PROJECT_FAILED, upon which
	// a package that had stored text and was waiting for PN_OPEN_PROJECT,
	// should free the text to avoid a memory leak because PN_OPEN_PROJECT
	// won't be coming. The "Hint" for failure is (const CString*)strProjName.
	// If it proves too difficult for packages to live with this change, there
	// are some other simple alternatives.
	virtual LPCTSTR GetProjectWorkspaceInfoText(LPCTSTR lpszProject);
	virtual void SetProjectWorkspaceInfoText(LPCTSTR lpszProject, LPCTSTR lpszInfo);

	// Override the following functions and define PKS_GLOBALINFO if your
	// package has global information which should be saved to
	// and read from the workspace file.
	virtual LPCTSTR GetGlobalWorkspaceInfoText();
	virtual void SetGlobalWorkspaceInfoText(LPCTSTR lpszInfo);

	// Override this function and define PKS_FILES if your package contributes
	// any files to the project workspace.  The main user of this is the bld
	// package, but other packages that contribute files (ms-test, etc.) should
	// also override this. This is primarily used by Source Control (CSccMgr).
	// Return the number of files added to the array.
	virtual int GetAssociatedFiles(CStringArray & saFiles, BOOL bSelected = FALSE) { return 0; }

	// To add new project types to the New Project Workspace dialog, override
	// this function and add new CProjTypeListItem objects to this list.  The
	// dialog box code will delete the objects for you.
	virtual void AddNewProjectTypes(CPtrList& projTypeListItems) { };

// OLE Automation
	// This is here so that the shell can query packages to get their additions
	//  to the DevStudio OLE Automation object model.  For more information,
	//  see extend.doc.  Must use PKS_AUTOMATION.
	virtual LPDISPATCH GetPackageExtension(LPCTSTR szExtensionName) { return NULL; }

	// A package overrides this to inform DevStudio on startup which OLE Automation
	//  package extensions it plans to provide.  These are objects that the package
	//  wishes to be available at the top level; the objects will appear to the macro
	//  writer as if they were properties of the Application object, since a macro
	//  can reference these objects directly by name like any other Application
	//  object.
	// The package fills in ppAppExts with an array of SApplicationExtension
	//  structs, each of which contains the name and the CLSID of the top-level
	//  object (or, "Named Item" as ActiveX Scripting calls it).  The package
	//  returns the number of elements in the array it's providing.  Like other
	//  similar package interfaces, the package allocates the space for this
	//  array, and destroys that space on shutdown.  So the array should be
	//  stored statically or globally.
	// DevStudio will later call CPackage::GetPackageExtension with these names
	//  when it needs the actual objects.
	// See the sample package for an example of how to override this virtual.
	// Must use PKS_AUTOMATION.
	virtual int GetApplicationExtensions(SApplicationExtension** ppAppExts) { return 0; }

// Property pages
	// Override the following function in order to append property pages
	// to someone else's selection.  Every time a property page is brought
	// up, all packages will be notified through this virtual.
	// guidView identifies the view that owns the object with the property page.
	// iUnk is an interface that a package can QI to get further interfaces
	// for determining the state of the active view.
	virtual BOOL AppendExtraPropertyPages(REFGUID guidView, IUnknown* piUnk);

	// OLE services support
	// This routine allows the package to participate in the 
	// IServiceProvider::QueryService routing scheme.  Any services that
	// are package specific should be exposed through this routine.  The 
	// current service routing scheme is as follows:
	// 1) CIPCompContainerItem, 2) IPCompDoc 3) CPackage 4) CTheApp 
	virtual HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObj)
		{ ASSERT(ppvObj); *ppvObj = NULL; return E_NOINTERFACE; }

// Utility functions
public:
	virtual LPCTSTR GetCommandString(UINT nID, UINT iString);
	virtual BSTR GetDynamicCmdString(UINT nID, UINT iString);
	virtual UINT CmdIDForToolTipKey(UINT nIDCmdOriginal);

	void SetVisibleMenuItem(UINT nID, BOOL bVisible = TRUE);
	void ShowCommandUI(UINT nID, BOOL bVisible = TRUE);
	void SetCommandUIFlags(UINT nID, UINT flags, BOOL bSet, UINT flagHidden);
	virtual BOOL IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount);

	// Override this if your package's command table includes any CT_MENU entries (used for
	// package specific submenus or toolbar menus)
	virtual POPDESC *GetMenuDescriptor(UINT nId) { return NULL; };
	// Override this to provide context-sensitive menu visibility. *Use this only when you wish
	// to emulate the behaviour of the Build/Debug menus, which disappear despite having active
	// items on them. Normally menus disappear automatically when all items are invisible (e.g.
	// Layout menu)
	virtual BOOL IsMenuVisible(UINT nId) { return TRUE; };
	// Override this to indicate that a category is textual rather than Graphical 
	virtual BOOL IsCategoryTextual(UINT nId) { return FALSE; };
	// Override this to indicate that a category should be always visible, even when empty
	virtual BOOL IsCategoryAlwaysVisible(UINT nId) { return FALSE; };

	// Override if your package has special unique properties
	virtual UINT GetPackageProperty(UINT nProperty);

protected:
	UINT m_id;
	HINSTANCE m_hInstance;

private:
	// even derived classes must use functions to access these
	LPCTSTR	m_lpBitmapID;				// id of the small bitmap
	LPCTSTR	m_lpLargeBitmapID;			// id of the large bitmap
	HBITMAP	m_hBitmap;					// HBITMAP of loaded bitmap (NULL if none loaded)
	BOOL m_bLoadedBitmapLarge;			// size of loaded bitmap
	
public:
	UINT m_flags;

	friend class CPack;
};

// Global func to determine if a specific package is loaded
BOOL IsPackageLoaded(UINT uiPackageId);

inline HINSTANCE CPack::HInstance() { return m_pPackage->m_hInstance; }
inline UINT CPack::PackageID() { return m_pPackage->m_id; }
inline UINT CPack::PacketID() { return m_nIDPacket; }

/////////////////////////////////////////////////////////////////////////////
//	CDefProvidedNode
//		this node type is added to the list of default node provider package
//		nodes which the project window asks for if there is no user-preference
//		information	for the project which is being opened/created.
//	REVIEW(PatBr):  This should be turned into an interface, and moved
//					into prjapi.h along with the package workspace interface.

typedef BOOL (CALLBACK *FILESAVECALLBACK)();

class CDefProvidedNode : public CObject
{
public:
	CDefProvidedNode();
	virtual ~CDefProvidedNode();

	enum SORT_TYPE { content_sort, alpha_sort };

	// packages must subclass the CDefProvidedNode class
	// in order to have meaningful node types. they should provide:

	// whether the default node should reside on its
	// own pane in the project window, and...
	virtual BOOL HasOwnPane() { return(TRUE); }

	// ...if the node has its own pane, whether the pane is 
	// workspace-independent (e.g., the HelpView pane is), and...
	virtual BOOL IsPaneIndependent() { return(FALSE); }

	// .. the type of sorting desired on the top-level nodes in the pane, and...
	virtual SORT_TYPE GetSortType() { return(alpha_sort); }

	// .. the help identifier used when user asks for help with this pane active...
	virtual UINT GetHelpID() { return((UINT)-1); }

	// ...a string to use as the name for the pane, and...
	virtual const TCHAR *GetPaneName() = 0;

	// ...a function which can be called to create the node,
	// which returns a pointer to a slob which will then be
	// inserted into the pane (this can be a CMultiSlob if the
	// node provider wants to insert more than one root node), and...
	virtual CSlob *CreateNode() = 0;

	// ...a function which returns the priority index of the pane.
	// currently: Classes=100, Resources=300, Build=500, Help=700, and...
	virtual int GetPriorityIndex() = 0;

	// ...a function which returns (if appropriate) a file-save callback
	// which the project window can use for command routing/enabling, and...
	virtual FILESAVECALLBACK GetFileSaveCallback() { return(NULL); }

	// ... a function to initialize the glyph bitmap for the pane.  the
	// bitmap should contain three bitmaps (12x12, 9x9, 4x4) in a 36x12
	// bitmap which can be used to initialize a CImageWell.  The three
	// different sizes are for varying sizes of scrollbars (16x16 on
	// WindowsNT but user-defined (default:13x13) on Windows'95).
	// caller of this function will perform DeleteObject() on HBITMAP.
	virtual HBITMAP GetPaneGlyph() = 0;

	//ugly hack.  The node is the only workspace-related thing that the 
	//res package seems to subclass.  So when we're initing the workspace 
	//window, the only way to know if we're dealing with ResourceView 
	//(which we don't want to expand for performance reasons), is to
	//ask the node.  So the res pkg overrides this to return FALSE.
	//All other packages should not need to override this.
	virtual	BOOL ShouldExpand() { return TRUE; }

};

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __PACKAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return ExistsOnDisk();

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
//	Path collections
//

class CPathList : public CObject
{

	DECLARE_DYNAMIC(CPathList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CPath* data;
	};
public:

// Construction
	CPathList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CPath*& GetHead();
	CPath* GetHead() const;
	CPath*& GetTail();
	CPath* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CPath* RemoveHead();
	CPath* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CPath* newElement);
	POSITION AddTail(CPath* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPathList* pNewList);
	void AddTail(CPathList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CPath*& GetNext(POSITION& rPosition); // return *Position++
	CPath* GetNext(POSITION& rPosition) const; // return *Position++
	CPath*& GetPrev(POSITION& rPosition); // return *Position--
	CPath* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CPath*& GetAt(POSITION position);
	CPath* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CPath* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CPath* newElement);
	POSITION InsertAfter(POSITION position, CPath* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CPath* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPathList();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CDirList : public CObject
{

	DECLARE_DYNAMIC(CDirList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CDir* data;
	};
public:

// Construction
	CDirList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CDir*& GetHead();
	CDir* GetHead() const;
	CDir*& GetTail();
	CDir* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CDir* RemoveHead();
	CDir* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CDir* newElement);
	POSITION AddTail(CDir* newElement);

	// add another list of elements before head or after tail
	void AddHead(CDirList* pNewList);
	void AddTail(CDirList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CDir*& GetNext(POSITION& rPosition); // return *Position++
	CDir* GetNext(POSITION& rPosition) const; // return *Position++
	CDir*& GetPrev(POSITION& rPosition); // return *Position--
	CDir* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CDir*& GetAt(POSITION position);
	CDir* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CDir* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CDir* newElement);
	POSITION InsertAfter(POSITION position, CDir* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CDir* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

	// Cool functions to convert to and from a semi-colon separated string
	BOOL FromString(LPCTSTR lpszString, BOOL bCheckExist = FALSE); // Note: first does a remove all
	BOOL ToString(CString& str);

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CDirList();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapPathToOb : public CObject
{

	DECLARE_DYNAMIC(CMapPathToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CPath key;
		CObject* value;
	};
public:

// Construction
	CMapPathToOb(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const CPath& key, CObject*& rValue) const;

	//	Function returns position of an item.  This is useful if you're trying
	//	to save the address of an item, say for a listbox.  If you save the 
	//	return POSITION, you can get the key back with GetNextAssoc.

	POSITION LookupPos(const CPath& key) const
	{
		UINT nHash;
		return (POSITION) GetAssocAt((CPath&) key, nHash);
	};

// Operations
	// Lookup and add if not there
	CObject*& operator[](const CPath& key);

	// add a new (key, value) pair
	void SetAt(CPath& key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(CPath& key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CPath& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(CPath& key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(CPath&, UINT&) const;


public:
	~CMapPathToOb();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapDirToOb : public CObject
{

	DECLARE_DYNAMIC(CMapDirToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CDir key;
		CObject* value;
	};
public:

// Construction
	CMapDirToOb(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const CDir& key, CObject*& rValue) const;

	//	Function returns position of an item.  This is useful if you're trying
	//	to save the address of an item, say for a listbox.  If you save the 
	//	return POSITION, you can get the key back with GetNextAssoc.
	POSITION LookupPos(const CDir& key) const
	{
		UINT nHash;
		return (POSITION) GetAssocAt((CDir&)key, nHash);
	};

// Operations
	// Lookup and add if not there
	CObject*& operator[](const CDir& key);

	// add a new (key, value) pair
	void SetAt(CDir& key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(CDir& key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CDir& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(CDir& key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(CDir&, UINT&) const;

public:
	~CMapDirToOb();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};
////////////////////////////////////////////////////////////////////////////
#ifndef _AFXCOLL_INLINE
#define _AFXCOLL_INLINE inline
#endif //ndef

_AFXCOLL_INLINE int CPathList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPathList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CPath*& CPathList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CPath* CPathList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE CPath* CPathList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CPathList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CPathList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CPath*& CPathList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void CPathList::SetAt(POSITION pos, CPath* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDirList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CDirList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CDir*& CDirList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CDir* CDirList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CDir*& CDirList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE CDir* CDirList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CDirList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CDirList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CDir*& CDirList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CDir* CDirList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CDir*& CDirList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CDir* CDirList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CDir*& CDirList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE CDir* CDirList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void CDirList::SetAt(POSITION pos, CDir* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapPathToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPathToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPathToOb::SetAt(CPath& key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPathToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPathToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapDirToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapDirToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapDirToOb::SetAt(CDir& key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapDirToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapDirToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shldocs.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLDOCS.H
//		Document and view base classes for packages.

#ifndef __SHLDOCS_H__
#define __SHLDOCS_H__

#include <ObjModel\appdefs.h> // Shell Automation Defines.

class FCItem;
class CAutoObj;
class CAutoWindowObj;
class CPack;
	class CPackage;
	class CPacket;
class CSlob;
class CUndoStack;
class CKeymap;
class C3dDialogBar;
class CShellRecorder;
extern CShellRecorder g_theShellRecorder;

interface IPkgProject;

struct POPDESC;
struct FINDREPLACEDISK;

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//	Classes defined in this header file

//	class CMultiDocTemplate;
		class CPartTemplate;
//	class COleDocument;
		class CPartDoc;
//	class CView;
		class CSlobWnd;
			class CPartView;
				class CDockablePartView;
//	class CMDIChildWnd;
		class CPartFrame;

      
/////////////////////////////////////////////////////////////////////////////
//	CPartTemplate
//		Base doc template class for packages.

class CPartTemplate : public CMultiDocTemplate
{
	DECLARE_DYNAMIC(CPartTemplate)

public:
   // File New Tab Type Enumeration
   enum FileNewTabType
   { 
      newnone, 
      newfile, 
      newtemplate, 
      newproject, 
      newworkspace, 
      newother 
   };
   
// Constructors
public:
	CPartTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass,
		CPackage* pPackage, CPacket* pPacket, REFCLSID clsid,
		LPCTSTR szAutoType = NULL);
	~CPartTemplate();
	
	// setup for OLE containers
	void SetContainerInfo();
	
	REFCLSID GetTemplateClsid() { return m_clsid; }
	LPCTSTR GetTemplateAutomationType() { return m_strAutoType; }

	virtual Confidence MatchDocType(LPCTSTR pszPathName,
					CDocument*& rpDocMatch);

	// Save all the templates docs.  If bQuery is true, then ask
	// fisrt.  nFlags allows the filters
	BOOL SaveAll(BOOL bQuery = FALSE, UINT nFlags = 0);

	virtual CDocument* OpenDocumentFile(const TCHAR* pszPathName,
		BOOL bMakeVisible = TRUE);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual CPackage *GetPackage() const { return m_pPackage; }
	virtual CPacket *GetPacket() const { return m_pPacket; }
	virtual UINT GetIconID() const { return m_nIconID; }

	virtual BOOL CanBeAddedToProject(IPkgProject *pProject);
	virtual CPartDoc *NewDocumentFile(LPCTSTR szFileName, 
					IPkgProject *pProject, LPCTSTR szFolder);
	// Override to validate path for file creation (called from File.New dialog)
	virtual BOOL CanCreateDocument(const TCHAR* pszPathName) { return(TRUE); }
   
   // Override to provide an alternate hIcon, 
   // Default implementaion returns LoadIcon(hInst, GetIconID());
   virtual HICON GetIcon();
   
   // GetTabType returns an enum that indicates which tab to go on.
   // default impl. returns newfile, iff GetDocString() returns valid string
   virtual FileNewTabType GetTabType();
	
// Attributes
public:
	enum FileNewTab { Files, Templates };
	FileNewTab	m_TabName;  // Tab name can be 'Files' or 'Templates', default is 'Files'

protected:
	CPackage*	m_pPackage;
	CPacket*	m_pPacket;

	CLSID		m_clsid;
	CString		m_strAutoType;
	UINT		m_nIconID;

	friend class CPartDoc;
};

#define FILTER_NONE        0x0000
#define FILTER_DEBUG       0x0001
#define FILTER_PROJECT     0x0002
#define FILTER_NON_PROJECT 0x0004
#define FILTER_NEW_FILE    0x0008
#define FILTER_PROJ_RC     0x0010
#define FILTER_DOCUMENT    0x0020

/////////////////////////////////////////////////////////////////////////////
//	CPartDoc
//		Base document class for packages.

class CPartDoc : public COleDocument
{
public:
	CPartDoc();
	DECLARE_DYNCREATE(CPartDoc)

	friend class CAutoDocumentDefault;

// Attributes
public:
	inline CPackage* GetPackage() const
			{ return ((CPartTemplate*)GetDocTemplate())->m_pPackage; }

	virtual BOOL IsReadOnly();
	virtual BOOL IsReadOnlyEx(BOOL bHandleError = TRUE);
	virtual void SetReadOnly(BOOL bReadOnly = TRUE);
	virtual BOOL IsReadOnlyOnDisk(void) const { return m_bReadOnlyOnDisk; }
	virtual void SetReadOnlyOnDisk(BOOL bReadOnlyOnDisk) { m_bReadOnlyOnDisk = bReadOnlyOnDisk; }
	
	void SetModifiedFlag(BOOL bModified = TRUE);
	virtual BOOL GetValidFilters(UINT** paIDS, UINT* pnInitial);

	virtual BOOL IsFiltered(UINT nFlags);
	virtual HRESULT GetLanguageName(BSTR *pbstrLangName)  // used by Wizard Bar. May generally be not implemented bobz
	{
		*pbstrLangName = NULL;	// OK to set a BSTR to NULL
		return E_NOTIMPL;
	}
	virtual BOOL FDisplayTitle()	{return FALSE;}
	
// Operations
public:
	virtual void ActivateDoc();
	virtual BOOL AttemptCloseDoc();
	virtual BOOL SaveModified();

// Implementation
public:
	virtual ~CPartDoc();
	virtual BOOL DoSave(const char* pszPathName, BOOL bReplace = TRUE);
	virtual BOOL Replace(const char* pszPathName, UINT nSaveType = 0);
	virtual void Serialize(CArchive& ar);	// overridden for document i/o
	virtual CSlob* GetSlob();
	virtual BOOL OnFileChange(int nPackage, FCItem* pFCItem); 


#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif
public:
	// The shell needs to be able to do processing either before or after
	// a document is created, opened, saved, or closed. 
	// This is required mainly so the shell can fire Ole Automation events.
	// Therefore, packages should not override the MFC virtual functions
	// On*Document. Instead the packages should override the functions
	// *Document. 

	// Packages should not override any of the following functions!
	// I repeat don't override these functions!
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(const char* pszPathName);
	virtual BOOL OnSaveDocument(const char* pszPathName, UINT nSaveType = 0);
	// Call this to close the document. In its default implementation it will call PreCloseDocument and OnCloseDocument.
	virtual void OnCloseDocument();

protected:
	// Packages should override the following functions.
	virtual BOOL NewDocumentHook();
	virtual BOOL OpenDocumentHook(const char* pszPathName);
	virtual BOOL SaveDocumentHook(const char* pszPathName, UINT nSaveType = 0);
	virtual void CloseDocumentHook();
	
	// The following functions are called by the shell after the
	// shell calls the functions above which actually does the real work.
	// These functions main purpose in life is to fire automation events.
	// BTW, we can change them to virtuals at a later date if neccessary.
	BOOL PostNewDocument(BOOL bResult) ;
	BOOL PostOpenDocument(BOOL bResult) ;
	BOOL PostSaveDocument(BOOL bResult) ;
	virtual void PreCloseDocument(); 	// called before closure, while document is still valid

	// If derived classes need to bypass the shell's implementations and
	// get to MFC's implementation, they should call the following functions.
	BOOL ParentNewDocumentHook();
	BOOL ParentOpenDocumentHook(const char* pszPathName);
	BOOL ParentSaveDocumentHook(const char* pszPathName, UINT nSaveType = 0);
	void ParentCloseDocumentHook();

	virtual BOOL CanCloseFrame(CFrameWnd *pFrame);
	virtual void SetDocString(UINT nID) { m_nIDString = nID; }
	virtual LPCTSTR GetDefaultTitle()
					{ return m_strTitle; }

public:
	virtual BOOL GetDocString(CString& rString,
		enum CDocTemplate::DocStringIndex index) const;
	virtual long GetDocLong(int nVar);
	virtual long SetDocLong(int nVar, long lData);

	// This function is used for firing the NewDocument and DocumentOpen events.
	// The event to fire is set in the Pre or Post function. Then when the
	// window is activated the following function is called. The event is then
	// fired.
	void FireCreationEvent() ;
	UINT m_FireCreationEvent ;

protected:
	BOOL m_bReadOnly;
	BOOL m_bReadOnlyOnDisk;

	UINT m_nIDString;
	CPartTemplate* m_pProxyTemplate;

// DER - added afx_msg to following...
// Generated message map functions
protected:
	//{{AFX_MSG(CPartDoc)
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileSave();
	afx_msg void OnUpdateIndicator(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	static BOOL CanSaveAll();
	static void UpdateSaveAll(BOOL bCreating);

private:
	static CPartDoc* s_pSavableDoc;

//
//
// OLE Automation Support.
//
//
public:
	// Overide: Returns the Automation Object for this document.
	virtual IDispatch* GetAutomationObject(BOOL bAddRef);

	// Called by Automation Object to signal when to null m_pAutoObj ;
	void AutomationObjectReleased() ;

protected:
	CAutoObj* m_pAutoObj;  // ptr to automation object

  // CPartDoc supports the Document properties & methods required by the OLE guidelines.
	// Stuff specific to a particular type of PartDoc (e.g. text) is handled by the derived
	// class's dispatch map.

	LPDISPATCH GetApplication();
	BSTR GetFullName();
	BSTR GetName();
	LPDISPATCH GetParent();
	BSTR GetPath();
	BOOL GetSaved();
	BOOL ReadOnly();
	IDispatch* ActiveWindow();
	void SetSaved(BOOL bNewValue);
	BOOL GetActive();
	void SetActive(BOOL bNewValue);
	DsSaveStatus Close(const VARIANT FAR& longSaveChanges);
	DsSaveStatus Save(const VARIANT FAR& bstrFilename, const VARIANT FAR& longSaveChanges);
	LPDISPATCH NewWindow(void); // may not be appropriate for all derived types
	IDispatch* GetWindows() ;

//	OLE Verbs in a command bar....
	void OnUpdateObjectVerbMenu(CCmdUI* pCmdUI);

};

//	GetDocLong enum
//		The shell reserves values less than 1000 for GetDocLong.
//		Packages may define values >= 1000 to allow other packages
//		to set values within their documents.  Useful for doc
//		template proxying.

enum
{
	GDL_PROXYTEMPLATE						= 100,
	GDL_CMP_CANCLOSE_CALLBACK				= 1001
};


/////////////////////////////////////////////////////////////////////////////
//	CSlobWnd
//		Base class for CPartView the package view base class.

class CSlobWnd : public CView
{
	DECLARE_DYNAMIC(CSlobWnd)
	
private:
    static CObList NEAR c_slobWnds;

public:
	static POSITION GetHeadSlobWndPosition();
	static CSlobWnd* GetNextSlobWnd(POSITION& pos);
		
public:
	CSlobWnd();
	~CSlobWnd();
	
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnDraw(CDC* pDC);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
		CView* pDeactiveView);
	virtual void PostNcDestroy();

	afx_msg void OnDestroy();
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);

	// property sheet for this CSlob window commands
	afx_msg void CmdShowProp();
	afx_msg void CmdIDProp();
	afx_msg void CmdGeneralPage();	// accel. for General prop page
	afx_msg void CmdStylesPage();	// accel. for Styles prop page

    virtual CSlob* GetSelection() = 0;
    virtual CSlob* GetEditSlob() = 0;

	virtual void ShowContextPopupMenu(CPoint pt);
	
	virtual CSlob* DropTargetFromPoint(const POINT& point);

	inline BOOL IsIconic()
		{ return GetParent()->IsIconic(); }

	// Selection Manipulation
	void Select(CSlob* pSlob, BOOL bAdd = FALSE);
	void Deselect(CSlob* pSlob);
	
	virtual void OnSelChange();
	
	virtual void ObscureSprites(BOOL bObscure = TRUE);
	virtual void ShowSprites(BOOL bShow = TRUE);
	void HideSprites()
			{ ShowSprites(FALSE); }

	virtual void EnsureValidSelection() { }
	virtual void EnableUpdates(BOOL bEnable) { }

	// Selection Information
	BOOL IsSelected(CSlob* pSlob);
	BOOL IsOnlySelected(CSlob* pSlob);
	BOOL IsDominantSelected(CSlob* pSlob);

	// Undo/Redo Buffer Management
	virtual BOOL EnableUndo();	// Return TRUE if undo/redo handling is
								// enabled, FALSE if not.  Default implementation
								// returns TRUE, so only override if you want to
								// return FALSE and *DISABLE* undo/redo.
	void BeginUndo(const char* szAction);
	void BeginUndo(UINT nID);
	void EndUndo(BOOL bAbort = FALSE);
	void FlushUndo();
	
	BOOL CanUndo();
	BOOL CanRedo();

	virtual void DoUndo();
	virtual void DoRedo();
	
	LRESULT OnGetRedoString(WPARAM, LPARAM);
	LRESULT OnGetUndoString(WPARAM, LPARAM);
	
	DECLARE_MESSAGE_MAP()

private:
	CUndoStack* m_pUndoStack;
	
	friend class CUndoSlob;
};

CSlobWnd* GetActiveSlobWnd();
void ActivateSlobWnd(CSlobWnd* pWnd);


/////////////////////////////////////////////////////////////////////////////
//	CPartView view
//		View base class for package documents.
//		(For dockable windows, see below.)

class CPartView : public CSlobWnd
{
protected: // create from serialization only
	CPartView();
	DECLARE_DYNCREATE(CPartView)

// Attributes
public:
	CPartDoc* GetDocument();
	CPacket* GetPacket() { return m_pPacket; }
	void SetPacket(CPacket * pPacket) { m_pPacket = pPacket; }
	
//	CKeymap* GetKeymap() { return m_pPacket->GetKeymap(); }
	virtual CKeymap* GetKeymap() { return NULL; }

	virtual CPartTemplate* GetDocTemplate();

    virtual CSlob* GetSelection() { return NULL; }
    virtual CSlob* GetEditSlob() { return NULL; }

	virtual BOOL IsDependent() { return FALSE; }
	virtual BYTE* GetInitData() { return NULL; }

	virtual DWORD GetHelpID() { return 0; }
	virtual BOOL GetHelpWord(CString& strHelp) { return FALSE; }
	virtual	BOOL SetDialogPos(BOOL fFirstTime, HWND hDlg);

	// Return FALSE from this virtual to disable the IME when a view of this type
	// gets focus.
	virtual BOOL UsesIME()
		{ return TRUE; }
	virtual void OnNewPalette()
		{ }

	virtual int GetAssociatedFiles(CStringArray & saFiles, BOOL bSelected = TRUE);

#ifndef NO_VBA
	virtual LPDISPATCH GetSelectionObject(LPDISPATCH pdisp = NULL);
#endif	// NO_VBA

// Operations
public:
	virtual ~CPartView();
	
	virtual BOOL CanClose();

	virtual void OnLoadWorkspace(); // called when loaded from workspace
	virtual void OnFindNext(BOOL* pbSuccess = NULL); // called for a find
	
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);
	
	virtual void RecalculateIME();

	// Find and Replace operations:
	// These should be overriden by the view.
	// FirstSearch means that this search will be the first
	// in a (possible) subsequent serie of searches. The view should
	// remember where it started so that it can stop searching when
	// all the document has been searched.
	// Return value: TRUE if the string is found,
	//      FALSE if the string is not found, or if SearchStyle is
	//		"ContinueSearch" and all the document has been searched once.
	virtual BOOL FindString(FINDREPLACEDISK *pfr);

	// MarkAll: marks all occurrences of the search string (for instance, 
	// the source editor puts a bookmark on each line)
	virtual BOOL MarkAll(FINDREPLACEDISK *pfr);
		
	// ReplaceString: If bReplaceAll is TRUE, the view should do that.
	// Otherwise, if the selection equals szFind, replace the text,
	// then call FindNext or FindPrev.
	virtual BOOL ReplaceString(FINDREPLACEDISK *pfr, BOOL bReplaceAll);

	// GetFindSelectionRect: Returns the rect (in screen coords) of the selection, 
	// so that the find dialog can move out of the way.
	virtual BOOL GetFindSelectionRect(CRect* prc);

	// GetFindString: Provides the string used to initialize the Find What field.
	// This is used in Edit.Find, Edit.Replace
	virtual BOOL GetFindString(CString& rstr);

	// GetFindReplaceFlags: Allows the view to disable find, replace, regular expressions, etc.
	virtual BOOL GetFindReplaceFlags(DWORD *pdwFlagsFind, DWORD *pdwFlagsReplace);

	// GetSelectionInterface: get the view's guid, and an interface for 
	// selection and state information.
	// REVIEW(davidga): I don't like the name.  How about GetStateInfoInterface
	// Note: bobz this will AddRef the piUnk
	virtual BOOL GetSelectionInterface(GUID* pguid, IUnknown** ppiUnk);

	// (bobz) for cases where we just want to identify the editor
	virtual BOOL GetEditorID(GUID* pguid)
	{
		IUnknown* piUnk = NULL;
		BOOL fRet = GetSelectionInterface(pguid, &piUnk);
		if (fRet)
		{
			ASSERT(piUnk != NULL);
			if (piUnk != NULL)	// overkill but defensive - bobz
				piUnk->Release();
		}
		return fRet;
	}
	
	// This is needed for views that support in place activation
	// so that activation needs to be executed immediately
	virtual BOOL DeferActivation()
	{
		return TRUE;
	}
protected:
	CPacket* m_pPacket;
	
// Generated message map functions
protected:
	//{{AFX_MSG(CPartView)
	afx_msg void OnEditFind();
	afx_msg void OnEditFindPrev();
	afx_msg void OnEditFindNext();
	afx_msg void OnToggleFindCase();
	afx_msg void OnToggleFindRE(void);
	afx_msg void OnToggleFindWord(void);
	afx_msg void OnToggleSearchAllDocs(void);
	afx_msg void OnUpdateFindReplace(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchCase(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchWord(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleSearchAllDocs(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchRegEx(CCmdUI* pCmdUI);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPartTemplate;

	friend class CPartFrame;

protected:
	// Find helper function
	BOOL DoFind();
};

#ifndef _DEBUG	// debug version in partvw.cpp
inline CPartDoc* CPartView::GetDocument()
   { return (CPartDoc*) m_pDocument; }
#endif

// FindInString: This function will use the FINDREPLACEDISK 
// variable to figure out if it should be using Reg Expressions, Case
// sensitivity and whole word matching, and to know what to search for.
BOOL FindInString(FINDREPLACEDISK *pfr, const char *szBuf,
	BOOL backwardsSearch,
	/* in/out */ const char **pszStart, /* out */ ULONG *pcbSize);


/////////////////////////////////////////////////////////////////////////////
//	CDockablePartView view
//		This class implements some of the functionality required by dockable
//		views. Overrides will still need to call DkPreHandleMessage though.

class CDockablePartView : public CPartView
{
protected:
	CDockablePartView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDockablePartView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDockablePartView)
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDockablePartView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CDockablePartView)
	afx_msg void OnFileClose();
	afx_msg void OnUpdateFileClose(CCmdUI* pCmdUI);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

inline BOOL IsPopupMessage(UINT nMessage)
{	return (nMessage == WM_NCRBUTTONDOWN || nMessage == WM_RBUTTONDOWN ||
		nMessage == WM_NCRBUTTONUP || nMessage == WM_RBUTTONUP); }


/////////////////////////////////////////////////////////////////////////////
//	CPartFrame
//		MDI child frame base class for packages.

struct WORKSPACE_INFO
{
	CPartFrame* pWnd;
	BYTE* pInitData;
	BYTE* pCurData;
};

class CPartFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CPartFrame)

// Static workspace variables.
protected:
	static WORKSPACE_INFO AFX_DATA* s_pwi;
	
public:
	static BOOL s_bLockFrame;

	static void LockFrame(BOOL bLock);
	static void LockFrame(HWND hwndAfter);
	static void LockWorkspace(BOOL bLock);
	static BOOL IsWorkspaceLocked() { return s_pwi != NULL; }

	static void SetInitData(BYTE* pData);
	static void IncCurData(int nIncrement)
		{ if (s_pwi != NULL) s_pwi->pCurData += nIncrement; }
	static BYTE* GetCurData()
		{ return (s_pwi == NULL) ? NULL : s_pwi->pCurData; }
	static CPartFrame* GetWorkspaceWnd()
		{ return (s_pwi == NULL) ? NULL : s_pwi->pWnd; }
	
	virtual void OnLoadWorkspace(); // called when loaded from workspace

// Construction
public:
	CPartFrame();
	virtual ~CPartFrame() ;	

// Attributes.
public:
	HWND m_hwndView;
	C3dDialogBar* m_pToolbar;

private:
	UINT m_nIMEState;

public:	
	void OnToolbarStatus();

	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd, 
		HMENU hMenuAlt);

	virtual BOOL IsInWorkspace();
	virtual BOOL IsDependent();
	virtual BYTE* GetInitData();
	virtual CString GetWorkspaceMoniker(BOOL bRelative);
	
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual void OnNewPalette();

	// Closes this window
	void CloseFrame() ;

// Message handlers	
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	//{{AFX_MSG(CPartFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnDocObjActivate(UINT, LONG);
	afx_msg void OnAutoObjActivate(UINT, LONG);
	afx_msg void OnEnterSizeMove(UINT, LONG);
	afx_msg void OnExitSizeMove(UINT, LONG);
	afx_msg void OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu );
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg void OnGetMinMaxInfo (MINMAXINFO * pMinMaxInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	afx_msg void OnMDICycleForward(void);
	//}}AFX_MSG

	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	// used for minimize tipping
	OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

	DECLARE_MESSAGE_MAP()

	// c_bFirstCtrlTab, MDINextWindow, PreTranslateMessage, and 
	// OnSysCommand are used to customize the way Ctrl+Tab switches 
	// between document windows.  The 'new' way works more like Alt+Tab 
	// in that alternative uses cause the top-most two windows to toggle 
	// positions, but continuous usage (without releasing the Ctrl key) 
	// cycles between all document windows.
	//
	// If bLinear is true, then it works like a normal next window command. This is what the window menu versions do,
	// and what would be useful for automation, etc.
	//
public:
	void MDINextWindow(BOOL bNext, BOOL bLinear=FALSE);

protected:
	static HWND s_hwndAfter;

	// DocObject support
	// We need these to group the activation process
	static BOOL s_bInActivation;
	static BOOL s_bInDocObjClose;

public:
	static COleFrameHook *s_pFrmHookActivate;
	static COleFrameHook *s_pFrmHookDeactivate;
	static CPartFrame *s_pLastActiveFrame;
	static void FinishActivation();

protected:
//
// OLE Automation Support.
//
//

	// Functions may not rely on this pointer being non-null until after GetAutomationObject has been
	// called for the first time. At that time, they may use this pointer. Any function that uses this
	// pointer should be added to the list below. Most functions should only need to use GetAutomationObject()
	CAutoWindowObj* m_pAutoFrameObj;

	// Most implementations will subclass CAutoWindowObj to force different or enhanced behaviour under automation.
	// Some CPartFrame subclasses may wish to not use m_pAutoFrame but provide their own IDispatch implementation.
	// They may do so by overriding all of the functions below, which are guaranteed to be the only ones which
	// directly use m_pAutoFrame. martynl 16Jul96

// BEGIN_FUNCTIONS_USING_m_pAutoFrame

	static CShellRecorder& GetShellRec(void) { return g_theShellRecorder; }

public:
	// Override to return assoicated automation object.
	virtual IDispatch* GetAutomationObject(BOOL bAddRef);

	// Called by Automation Object to signal when to null m_pAutoFrameObj ;
	void AutomationObjectReleased(); // REVIEW: !!! Virtual?

// END_FUNCTIONS_USING_m_pAutoFrame

	/*
	DER 12 Apr 96 - The following are default implementations for the OLE Automation
	Window Object properties and methods. DO NOT Override. See AutoFrm.cpp for the
	implementation.
	*/
	BSTR GetCaption();
	// Do not Implement - void SetCaption(LPCTSTR lpszNewValue);
	BOOL GetActive();
	void SetActive(BOOL bNewValue);
	long GetLeft();
	long GetTop();
	long GetHeight();
	long GetWidth();
	long GetIndex();
	LPDISPATCH GetNext();
	LPDISPATCH GetPrevious();
	void SetLeft(long nNewValue);
	void SetTop(long nNewValue);
	void SetHeight(long nNewValue);
	void SetWidth(long nNewValue);
	DsWindowState GetWindowState();
	void SetWindowState(DsWindowState nNewValue);
	DsSaveStatus AutomationClose(const VARIANT FAR& boolSaveChanges) ;

};

// Helper for GetWindow cycling of MDI.
extern BOOL IsValidMDICycleMember(CWnd* pWnd);
// Helper function that Activates an ExistingDoc
extern CPartDoc* ActivateExistingDoc(LPCTSTR lpszFileName,	CDocTemplate* pTemplate);

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SHLDOCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shlmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//      SHLMENU.H
//

#ifndef __SHLMENU_H__
#define __SHLMENU_H__

#ifndef NO_CMDBARS
#include <afxtempl.h>
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

struct MTM
{
    UINT id;
	UINT idString;
	struct POPDESC* ppop;
};

#pragma warning(disable:4200)
struct POPDESC
{
	UINT strID;
	UINT cmdID;
	MTM rgmtm [0];
};
#pragma warning(default:4200)

#define POP_NIL									0
#define POP_IDS_NIL								0
#define POP_SEPARATOR							UINT(-1)

#define MENU_CONTEXT_POPUP(name)				&pop##name

// We distinguish two types of menus. Command menus are the proper customisable ones that
// go on the bar. POPUP menus are the context ones
#define BEGIN_POPUP_MENU(name)					static POPDESC pop##name = { 0, 0,
#define BEGIN_POPUP_MENU_(name, id)				static POPDESC pop##name = { id, 0, 
#define BEGIN_COMMAND_MENU_(name, idm)			static POPDESC pop##name = { 0, idm, 
#define END_POPUP_MENU()						POP_NIL, POP_IDS_NIL, NULL };

#define MENU_GROUP(idg)							idg, POP_IDS_NIL, NULL,
#define MENU_POPUP(idg, name)					idg, POP_IDS_NIL, &pop##name,
#define MENU_ITEM(idm)							idm, POP_IDS_NIL, NULL,
#define MENU_ITEM_(idm, ids)					idm, ids, NULL,
#define MENU_SEPARATOR()						POP_SEPARATOR, POP_IDS_NIL, NULL,

// Use MenuFileText to correctly generate path text for use in menus.
// Ampersands in filenames must be doubled.

void MenuFileText(CString& str);

/////////////////////////////////////////////////////////////////////////////
//      CContextPopupMenu
//              Support for context popup menus

void ShowContextPopupMenu(POPDESC* ppop, CPoint pt);

struct CTE;

class CContextPopupMenu : public CMenu
{
public:
	static  CContextPopupMenu* CreateNewSubPopup(CContextPopupMenu* pParent);

public:
	CContextPopupMenu();
	~CContextPopupMenu();

	void Create(POPDESC* ppop = NULL);

	void AddItem(UINT id, LPCTSTR lpszText = NULL);
	void AddSubMenu(CContextPopupMenu*, LPCTSTR lpszText);
	BOOL TrackPopup(UINT flags, int x, int y, CWnd* pOwner);
	BOOL LoadMenu(UINT nID);

	void SetPos(int nPopupPos); // must have been loaded from resource

private:
	int m_idgPrev;
	CObList* m_pListSubMenus;
	BOOL m_bPopup;    // using menu resource
	int m_nPopupPos; // position of current popup submenu in the menu resource
};

#ifndef NO_CMDBARS
// REVIEW(DaleRo): Sure would be nice not to have to expose all this to
//                 package partners.  We should review why this is necessary
//                 and try to support it in some other way.

class CBMenuPopup ;

/////////////////////////////////////////////////////////////////////////////
/*
   Each menu item consists of four fields.
      Button   |  Name  |  Accel    |  Arrow
      (fixed)     (var)    (var)       (fixed)
			  2 Pixels      1 char          2 Pixels 
	 c_iButtonTextGap               e_FieldGap.
			  
   The menuitem and the menu communcate the widths and rects for
   these fields using arrays of values index by these enums.

   e_FieldAll is the index for the rectangle that covers the whole menu item.
   e_FieldGap is the width of the gap in between these fields.

  30 May 96 - The word command bars do not put the accelerators at the end of
  the longest menu item. Like windows. Instead they find the size of the longest
  menu item and then right justify the accelerator onto that.

  To support this style of menu, I added the e_FieldNameAccel field. This field is
  used to determine maximum width of a menu item treating the Name and Accel as
  one unit.

  This field is only used inside of CBMenuPopup. CBMenuItem does not know or care about
  this field.

  To go back to the old way #define _FIELD_ALIGN_ACCEL_.

  _FIELD_ALIGN_ACCEL is NOT defined currently! If you define it change this comment
  or else!.
  
	I added the e_FieldText to hold the 

*/
   const int c_iFieldWidthUnknown = -1 ;
   const int c_iNumFields = 7 ;
   enum FieldTypes { e_FieldAll = 0 ,
		     e_FieldButton = 1,
		     e_FieldName = 2,
		     e_FieldAccel = 3,
		     e_FieldArrow = 4,
		     e_FieldGap = 5, // The Gap is used for returns from GetWidths.
					 e_FieldNameAccel = 6 
		     }  ;


/////////////////////////////////////////////////////////////////////////////
//      CBMenuItem

class CBMenuItem 
{
	friend class CMenuPopupProxy;
public:
	enum MenuItemType 
	{
		MIT_Unknown		= 0,
		MIT_Command		= 1,
		MIT_Separator	= 2,
		MIT_Popup		= 3
	};



	// Contruction
	CBMenuItem() ;
	virtual ~CBMenuItem() ;

	// Creation
	BOOL Create(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName) ;
	// Creation
	BOOL CreatePopup(CBMenuPopup* pMenuWnd, CBMenuPopup* pMenuPopup, CString strName) ;
	// Creation for a menu item whose menu is in the global menu table
	BOOL CreatePopup(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName);
	// Creation for a menu item whose type is determined by the global command table
	BOOL CreateDynamic(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName,	BOOL bShowGlyph, HBITMAP hbmCustom);
	BOOL CreateSeparator() ;

	// Attributes
	void Check(BOOL bChecked); 
	BOOL IsChecked() {return m_bChecked;}
	BOOL IsVisible() {return m_bVisible;};
	void SetVisible(BOOL bVisible) { m_bNeedToCalculateSizes=TRUE; m_bVisible=bVisible; };

	UINT Enable(BOOL bEnable) ;
	BOOL Show(BOOL bShow) ;
	// Updates the text (item + accel, separated by tab), and recalcs menu
	void SetText(LPCTSTR lpszText) ;
	// updates accelerator, and optionally recalcs menu     
	void SetAccelerator(LPCTSTR lpszAccel, BOOL bRecalc=TRUE) ;

   // Operation

   //
   // This is the old IMenuItem Interface
   //
   int GetItemType() {return m_iItemType;}
   CBMenuPopup* Expand(BOOL bExpand) ;
   void Select(BOOL bSelect) ;
   void Draw(CDC* pDC, CRect rectFields[c_iNumFields]); 
   void DrawSeparator(CDC* pdc, const CRect* pRect);
   // determines a possible hit, given a scroll offset
   BOOL HitTest(CPoint pt, int cyOffset);
   UINT Click() ;

   UINT GetCmdID() {return m_nCmdID;}
   CString GetName() {return m_strName;}
   CBMenuPopup* GetPopup() {return m_pMenuPopup ;}

   void Release() ;

   BOOL ModifyItem(	UINT nNewCmdID,
					LPCTSTR lpszNewItem, 
					CBMenuPopup* pNewPopup, 
					int iNewItemType);

   void Sync() ;

   void GetWidths(CDC* pdc, /*out*/ int** pRect) ;
   int GetHeight(CDC* pdc) ;
   
   BOOL GetDefault(void) { return m_bDefault; };
   void SetDefault(BOOL bDefault);

   //
   //
   //
   //Members
   //
   //
   //
   int m_iItemType ;
   CString m_strName ;
   CString m_strAccel ;

   UINT m_nCmdID ;
   CBMenuPopup* m_pMenuWnd;						// Window of the menu that contains this item

   unsigned int m_bSelected : 1;
   unsigned int m_bChecked : 1;
   unsigned int m_bGrayed : 1;
   unsigned int m_bVisible : 1;
   unsigned int m_bCustomGlyph : 1;                         // true if the HBITMAP inside this item is not the default and should be saved
   unsigned int m_bCustomText : 1;							// true if the text inside this item is not the default and should be saved
   unsigned int m_bTransient : 1;                                     // true if the item has been temporarily added
   unsigned int m_bDefault : 1;								// true if the item is drawn in bold (default)
   unsigned int m_bExpanded : 1;
   unsigned int m_bNeedToCalculateSizes : 1;
   unsigned int m_bUpdated : 1;
   unsigned int m_bTextModified : 1;						// TRUE if the text of this item has been modified since it came from the command table

	static CBitmap s_bmpCheckMark;
	static CSize s_sizeCheckMark ;
	static CSize s_sizeCmdGlyph;

	// Popup
	static CBitmap s_bmpArrow ;
	static CSize s_sizeArrow ;

	// removed cached sizes
	static void FlushSizeCache();
	// and recalculate them
	static void EnsureSizeCache();


   // Glyph
   HBITMAP m_hbmCmdGlyph ;
   HBITMAP m_hbmOriginalGlyph;      // contains the original command glyph if the glyph had to be scaled to fit 
								   // the current button size

   // Popup Members
   CBMenuPopup* m_pMenuPopup ;
   CTE *m_pCTE;                                         // we are caching a copy of this here for efficiency reasons

   // Fields
   int m_iHeight ;
   int m_iFieldWidths[c_iNumFields] ; // Caches the widths desired for each field.
   CRect m_rectFields[c_iNumFields] ; // Holds the rects for each field from the last Draw.

   // OnCommandUpdate Menu handlers can do all sorts of nasty things like
   // delete menu items. We need to be able to track such changes to keep the menu
   // code in sink.
   void Updated(BOOL bUpdated)
	{ m_bUpdated = bUpdated; }

   BOOL Updated()
	{ return m_bUpdated ; }

	void UpdateGlyph() ;

	BOOL IsTextModified(void) { return m_bTextModified; };								// TRUE if text was modified since creation/command table update
	void SetTextModified(BOOL bTextModified) { m_bTextModified=bTextModified; };

protected:
	// helper function during creation
	// bCustom is TRUE if the glyph is custom (and a candidate for saving and resetting)
	void SetGlyph(HBITMAP hbmSource, int nIndex, BOOL bMustCopy, BOOL bCustom);

	// Other Helpers
	void CalcSizes(CDC* pdc) ;
	void ParseOutAccelerator(CString strWhole) ;

};


/////////////////////////////////////////////////////////////////////////////
// CBMenuPopup window

class CForwardMouseMessage ;

class CBMenuPopup : public CWnd
{
	friend CBMenuItem ;
	friend class CMenuPopupProxy;
// Construction
public:
	CBMenuPopup();

// Attributes
public:
   static BOOL IsCBMenuCmdUI(CCmdUI* pCmdUI) ;

   enum {
      HT_MISSED = -1,
      HT_HITSELECTEDITEM = -2
   };
// Operations
public:
	// xOffset and yOffset are the extra ammounts to move the menu by if it is to overflow
	// the screen from its current position. This allows menus that are dropping from 
	// command bar buttons to not be placed over their command bar button martynl 05May96
   // Der - TrackDropDownMenu replaces TrackPopupMenu for drop down menus.

	static CTypedPtrList<CObList, CBMenuPopup *> s_listMenus;

	// the screen coordinates point where the last MouseMove was processed. We skip if we've processed a move 
	// very close to this before - stabilizes joint keyboard and mouse usage.
	static CPoint s_ptLastMove;

	static CFont *GetMenuFont(BOOL bDefault);

	UINT TrackDropDownMenu(int x, int y, 
							CWnd* pWnd, 
							LPCRECT lpRect = 0 , 
							CRect rectAvoid=CRect(0,0,0,0),
							CWnd* pWndMenuBar = NULL,			// Pointer to window to a window to forward the mouse/keys.
							BOOL bSelectFirstItem =FALSE,		// Select the first menu item. Required for menu keyboard ui.
							BOOL *pbBarFocus=NULL,				// OUT parameter, explains whether the calling bar should be re-focussed after the menu
							BOOL bReturnCmd=FALSE				// IN param. If true, menu should return command without posting
							);
	
   UINT TrackPopupMenu( UINT nFlags, int x, int y, 
			CWnd* pWnd, LPCRECT lpRect = NULL);
   UINT TrackPopupMenuEx( UINT nFlags, int x, int y, 
			CWnd* pWnd, CRect rectAvoid, LPCRECT lpRect = NULL);
   
   // Internal Function...
   UINT TrackMenu( UINT nFlags, int x, int y, 
		   CWnd* pWnd, LPCRECT lpRect = 0 , CRect rectAvoid=CRect(0,0,0,0), BOOL bSelectFirstItem=FALSE);

   // possibly dubious way to handle the parenting issue with submenus. Temporary solution, hopefully.
   inline void SetParent(CWnd *pParent) { m_pParentWnd=pParent; };
   inline void SetAutoEnable(BOOL bAuto) { m_bAutoEnable=bAuto; };
   inline CWnd *GetParent() { return m_pParentWnd; };

   // DER! Add Reference Counting!
   void Release() {delete this;}

   // Array Access
   CBMenuItem* GetMenuItem(int index) ;
   void AddMenuItem(int index, CBMenuItem* pMenuItem) ;

   //
   // CMenu Simulation Functions
   //
   BOOL CreateMenu() ;
   BOOL CreatePopupMenu(CWnd* pParentWnd) ;
   BOOL DeleteMenu(UINT nPosition, UINT nFlags) ;
   void DeleteAll();
   BOOL AppendMenu(UINT nFlags, UINT nIDNewItem = 0, 
		   LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL);       
   int GetMenuString(UINT nIDItem, CString& rString, 
		     UINT nFlags) const;
   CBMenuPopup* GetSubMenu(int nPos) const;
   BOOL InsertMenu(UINT nPosition, UINT nFlgs, 
		   UINT nIDNewItem = 0, 
		   LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL, 
		   BOOL bTransient=FALSE);       
   // Note: MergeMenu empties pSection of items
   BOOL MergeMenu(UINT nPosition, UINT nFlags, CBMenuPopup* pSection);
   UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable) ;
   UINT ShowMenuItem(UINT nIDEnableItem, UINT nShow);

   BOOL ModifyMenu(UINT nPosition, UINT nFlags, 
		   UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL);       
   void RemoveCommandReferences(UINT id);

   HGLOBAL GetData();
   BOOL SetData(HGLOBAL hglob);

   UINT GetMenuItemCount( ) const { return m_nMaxIndex ; } // Used by CTypedRecentFileList::UpdateMenu

	UINT GetMenuItemID(int nPos) ;
	BOOL ContainsMenu(int nCmdID);

	// Determine if the menu is a dropdown menu or not. This has been used by packages.
	BOOL IsDropDown() {return m_bDropDown;};

   // Used to for cbverb.cpp
   BOOL IsSubPopup() {return m_bSubPopup;} // Returns true if menu is a subpopup.

	// Proxy handlers
	// When it is visible, a menu has a proxy. Or when the proxy is manually allocated
	void AllocateProxy();
	void FreeProxy();
	CMenuPopupProxy* GetProxy();

   inline int GetCount() { return m_nMaxIndex; };

   // this is the 'full height' of the menu
   int GetHeight();
   // this is the height of the window containing the menu
   int GetWindowHeight(void);
   int GetWidth();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBMenuPopup)
	public:
	//}}AFX_VIRTUAL
protected:
	virtual BOOL Create(CWnd* pParentWnd, POINT pt, BOOL bSubPopup = FALSE, CRect* prectAvoid =NULL);
   //virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) ;
	virtual void PostNcDestroy() ;

   DECLARE_DYNAMIC(CBMenuPopup)

//
// Implementation
//
public:
	void Initialize();
	virtual ~CBMenuPopup();

	//
	// Keybord UI
	//

	// Show Expanded
	// these act immediately
	void HideSubPopup() ;
	void ShowSubPopup(int nItem);
	void ScrollMenu(BOOL bForward, BOOL bEnd);
	// down one item
	void ScrollMenuDown();
	// up one item
	void ScrollMenuUp();
	// to first item at top
	void ScrollMenuTop();
	// to last item at bottom
	void ScrollMenuBottom();
	// make selected menu item scroll into view
	void EnsureSelectionScrolled();

	// these act after a timer fires
	void DeferHideSubPopup() ;
	void DeferShowSubPopup(int nItem);
	void DeferScrollMenuDown(BOOL bInitial);
	void DeferScrollMenuUp(BOOL bInitial);
	void EndDefer(void);
	void EndScrollDefer(void);
	// hittests the scrolling area and defers a scroll if appropriate. If bInitial is true, the delay is longer
	void DoScroll(CPoint pt, BOOL bInitial);

	// This synchronises the selection with the currently expanded item, and recurses upwards
	void SelectExpanded(void);

	// If TRUE is returned, the key should be passed to the menu bar
	BOOL ForwardRightKey() ;
	void ForwardUpKey() ;
	void ForwardDownKey() ;
	void ForwardHomeKey() ;
	void ForwardEndKey() ;
	UINT ForwardReturnKey() ;
	UINT ForwardCharKeyDown(TCHAR keychar, BOOL *bUseCmd);
	void KeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

   //
   // Subpopup Navigation
   //

   CBMenuPopup* FindNextToLastChild();
   CBMenuPopup* FindLastChild();

	// This is returned from DoMouseMove. These constants can be added.
	enum {
		cMoveUnhandled=0,               // Message needs to be handled by parent
		cMoveHandled=1,                 // Message Does not need to be handled elsewhere
		cMoveSelectExpanded=2   // Message requires parent to select the expanded item
	};

	int DoMouseMove(UINT nFlags, CPoint pt); // returns a combination of the above flags
	UINT DoLButtonUp(UINT nFlags, CPoint point) ;
	BOOL DoLButtonDown(UINT nFlags, CPoint point) ;

	void InitMenuPopup() ;
	void MainFrameInitMenuPopup() ; // Copied from MainFrame.

	// Modal Support...
	BOOL ContinueModal();
	void DoModal(int x, int y) ;
	void Done(UINT nCmdID = NULL) ;
	void MessageLoop();

	// Find the menu item corresponding to the point.
	int HitTest(CPoint pt) ;
	// Determine if the point is in any menu or the menu bar.
	BOOL PtInMenus(CPoint pt) ;

	// Helpers
	void CalcMenuSize() ;
	void VerifyMenuSize(BOOL bAlways) ; // Checks if toolbar glyphs have changed. 
	int GetMenuIndexForCommand(UINT nCmdId) const;
	void InvalidateItem(int nIndex);
	CRect GetItemRect(int nIndex);
	void GetItemsRect(CRect *pRect);

	// finds the next visible item after the one specified
	int FindNextVisibleItem(int nIndex, BOOL bForward);

	void AdjustMenuSize(CBMenuItem* pItem) ;

	void SelectFirstItem();      // TrackDropDownMenu uses this function to
							// select the first menu item when moving with the keyboard.
	inline BOOL IsDirty() { return m_bDirty; };
	inline BOOL IsPainted() { return m_bPainted; };

	// Number of visible non-separators, or -1 if unknown, -2 during calculation
	int m_nVisibleItems;

   // The menu can be modified in OnCommandUpdate handlers. We need some extra
   // information to determine if we have been changed or not.
   void ChangedByOnUpdate(BOOL bChanged)	// The menu has changed.
	{m_bChanged = bChanged ;}
   
   BOOL ChangedByOnUpdate()						// Has the menu changed?
	{return m_bChanged ; }
   
   BOOL m_bChanged ;							// Variable.

	// returns true if this menu is participating in customization
	BOOL IsCustomizing(void);

	// Use this to hide any submenu which has this id, or indirectly contains this id
	void HideInvalidMenuDestination(UINT nId);

	// returns TRUE if this menu, or one of its submenu, contains the specified command id
	BOOL ContainsMenu(UINT nId);

	// Flushes all cached menu size information
	void FlushSizeCache();

	// Sets whether the menu wants to see its cancellation
	void SetPassBackCancel(BOOL bPassBack) { m_bPassBackCancel=bPassBack; };

	// Call when a click could not be a system double click part 1
	static void ClearSystemClick(void);
	// call to tell a menu about the first part of a system click
	static void SetSystemClick(int nTime, CPoint ptScreen);

	// called when colours have been changed
	static void SysColorChange(void);

//Members
protected:
	static BOOL s_bCreateTransients;		// When true, all menu items created get their m_bTransient flag set

   typedef CTypedPtrArray <CPtrArray, CBMenuItem*> CMenuItems;
   CMenuItems m_MenuItems ;
   int m_nExpandedMenuItem; // index of the item whose subpopup is expanded. Subpopups only
							// contract when the mouse moves over another subpopup item, or when the
							// menu is closed
   int m_nExpandDeferredItem; // item to which deferred expand timer refers
   int m_nSelectedMenuItem; // Index of selected item.
   int m_nMaxIndex ;            // The index of the first empty slot.
   BOOL m_bPainted;				// TRUE if the menu has been painted. Set false by create
   BOOL m_bBarFocus;            // True if focus should be returned to the bar
   BOOL m_bAutoEnable;			// TRUE if the menu item should be enabled even if no command handler can be found
   CSize m_sizeDesired;         // The height of all the items and the width of the widest
   BOOL m_bSelectFirstItem;		// TRUE if the first item of the menu needs to be selected

   CWnd* m_pWndMenuBar;         // The window which acts like a menubar to the popup menu.
							// The popup forwards mouse and keyboard messages to this
							// window. This window is in charge of closing the menu.
   BOOL m_bSubPopup ;
   CWnd* m_pParentWnd ;
   CBMenuPopup* m_pChildPopup ;
   CRect m_rectAvoid;		// Screen coords rect to avoid when placing menu

   // Modal
   BOOL m_bContinueModal ;

   // This is the ID of the currently active timer, or 0 if there isn't one. Used for
   // delaying appearance of subpopups
   int m_nCurrentTimer;

   UINT m_nPostCmdID ; // Command ID to send to m_pParentWnd;
   BOOL m_bReturnCmdID; // If true, TrackXXX returns the command id, rather than posting the message. TPM_RETURNCMD

   BOOL m_bControl;

   // Large Toolbars
   BOOL m_bLargeToolbar ;

   BOOL m_bDirty;				// true if this has been modified since it was saved.

   // Field Widths
   int m_iHeight;
   int m_iFieldWidths[c_iNumFields] ;

   class CMenuPopupProxy* m_pProxy;

	// Drop Down Support
	BOOL m_bDropDown ; // True if TrackDropDownMenu Called False otherwise.

	// The following pointer is used to forward mouse messages on when the user
	// clicks outside of the window.
	CForwardMouseMessage* m_pForwardMsg;
	// TRUE if cancellation in the menu bar should still be forwarded
	BOOL m_bPassBackCancel;

	// Menus now support scrolling. 
	BOOL m_bScrolling;							// TRUE if this menu is required to scroll
	BOOL m_bHasTopScroll;						// TRUE if the top scroll area is present
	BOOL m_bHasBottomScroll;					// TRUE if the bottom scrolling area is present
	int m_nTopIndex;							// index of the top visible menu item, after the scroll area
	int m_cyTopOffset;							// Coordinate offset of items.

	static BOOL s_bLastWasKey;					// TRUE if the last proper input the menu processed was keyboard
	static BOOL s_bSuppressedMouseMove;			// TRUE when a single mouse move is suppressed just after dropping the menu
	static CBitmap s_bmpScrollDown;				// syscolour loaded bitmap of the scroll down arrow
	static CBitmap s_bmpScrollUp;				// syscolour loaded bitmap of the scroll up arrow
	static CSize s_sizeScroll;					// size of the scroll arrows (assumed to be same)

	// System click handling
	// This is the last time the MDI system icon was clicked
	static int s_nLastSystemClick;
	static CPoint s_ptLastSystemClick;

	// Generated message map functions
protected:
	//{{AFX_MSG(CBMenuPopup)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnPaint();
	afx_msg int OnCreate( LPCREATESTRUCT lpCreateStruct );
	afx_msg void OnDestroy( );
    afx_msg LRESULT OnTestMenu(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnKillFocus(CWnd *);
	//}}AFX_MSG
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

#ifdef _DEBUG
public:
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
//      CBContextPopupMenu
//              Command bar version of CContextPopupMenu

class CBContextPopupMenu : public CBMenuPopup
{
public:
			CBContextPopupMenu();
			~CBContextPopupMenu();

	void    Create(POPDESC* ppop = NULL);

	BOOL AddItem(UINT id, LPCTSTR lpszText = NULL);
	void    AddSubMenu(CBContextPopupMenu*, LPCTSTR lpszText);
	UINT    TrackPopup(UINT flags, int x, int y, CWnd* pOwner );
	UINT    TrackPopup(UINT flags, int x, int y, CWnd* pOwner, CRect rectAvoid );
	//BOOL  LoadMenu(UINT nID);
	//void  SetPos( int nPopupPos ); // must have been loaded from resource
	static  CBContextPopupMenu* CreateNewSubPopup(CBContextPopupMenu* pParent);

private:
	int             m_idgPrev;
	CObList*        m_pListSubMenus;
	BOOL    m_bPopup;    // using menu resource
	int             m_nPopupPos; // position of current popup submenu in the menu resource
};

extern void CBShowContextPopupMenu(POPDESC* ppop, CPoint pt, CWnd* pParent = NULL);

////////////////////////////////////////////////////////////////////////////////////
//
//OLD_MENU Backward compatibility menu mode support
// Grep for OLD_MENU.
// Menu is a namespace.
namespace Menu
{
void UseHMENU(BOOL bUseOldWindowsMenu) ;
BOOL IsInCmdBarMode() ;
BOOL IsShowingCmdBars() ;
void UpdateMode(BOOL bUpdateNow);
void UseOLE(BOOL bStart);
};

#endif // !NO_CMDBARS

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // !__SHLMENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shlfutr_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLFUTR_.H
//		Microsoft only header file with features we don't yet want to
//		expose to the rest of the world.  Right now, just autosave, which
//		was originally implemented in v2.0, but has not yet been supported
//		by more than the text editor.

#ifndef __SHLFUTR__H__
#define __SHLFUTR__H__

#include "path.h"
#include "msgboxes.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//	CAutosave

#define IDT_AUTOSAVE 100

class CAutosave
{
private:
	BOOL m_fEnabled;
	BOOL m_fInTick;	 			
	UINT m_nSaveInterval;
	HWND m_hWndTimerOwner;
	UINT m_nTimerID;
	CDir m_dirUntitled;
	CObList m_pathlistErrors;
	void GetUntitledDir();
public:
	CAutosave();
	~CAutosave();

// Public Enumerations

	enum DirAction { 
		DontCreateDir = FALSE, 
		CreateDir = TRUE 
	};

	enum AutosaveErrors {
		Success = TRUE, 
		NoSubdirectory,
		CantMakeSubdirectory,
		PathTooLong
	} m_ErrorStatus;

// Installation Method.  
// The autosaver must be installed on an HWND before it is enabled.

	inline void Install(HWND hWnd);

// Interface to the Options dialogue.

	BOOL IsEnabled()   	{ return(m_fEnabled); }
	UINT GetInterval() 	{ return(m_nSaveInterval); }
	BOOL Enable(UINT nInterval);
    BOOL Enable()	   	{ return(Enable(m_nSaveInterval)); }
	BOOL Disable();

// Interface to the HWND timer message.

	inline void EnterTick();
	BOOL InTick() 		{ return (m_fEnabled && m_fInTick);}
	inline void RegisterTickError(CPath &pathBadAutosave);
	void ExitTick();

// Autosave Services.  Virtual so we get pointers to the methods.

	virtual BOOL GetAutosaveName(BOOL fUntitled, const CPath &pathDirtyFile, 
						 CPath &pathAutosave, 
						 enum DirAction fCreateDir = CreateDir);
	virtual void RemoveAutosaveFile(BOOL fUntitled, const CPath &pathUserFile);
	virtual void RemoveAutosaveFile(const CPath &pathUserFile) {
		RemoveAutosaveFile(FALSE, pathUserFile);
	}
	virtual BOOL AutosaveFileExists(const CPath &pathUserFile, CPath &pathAutosave);
	virtual BOOL RecoverAutosaveFileCheck(const CPath &pathUserFile);
};

inline void CAutosave::Install(HWND hWnd) 
{
	if (!m_fEnabled) 
		m_hWndTimerOwner = hWnd;
	else
	{
		VERIFY(Disable());
		m_hWndTimerOwner = hWnd;
		VERIFY(Enable());
	}
}

inline void CAutosave::EnterTick()
{
	ASSERT(!m_fInTick);
	ASSERT(m_pathlistErrors.IsEmpty());
	m_fInTick = TRUE;
}

inline void CAutosave::RegisterTickError(CPath &pathError)
{
	CPath *ppathErrEntry = new CPath(pathError);
	m_pathlistErrors.AddTail(ppathErrEntry);
}

extern CAutosave AFX_EXT_DATA gAutosaver;	

#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// !__SHLFUTR__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shldocs_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLDOCS_.H
//		Microsoft only document and view base classes for packages.

#ifndef __SHLDOCS__H__
#define __SHLDOCS__H__

#ifndef __OLEREF_H__
#include "oleref.h"
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#ifndef _IPC_DOCUMENTS_DISABLED

/////////////////////////////////////////////////////////////////////////////
//	Classes defined in this header file

//	class CMultiDocTemplate;
//		class CPartTemplate;
			class CIPCompDocTemplate;
//	class COleDocument;
//		class CPartDoc;
			class CIPCompDoc;

/////////////////////////////////////////////////////////////////////////////
//	In-place component document classes
//		For Microsoft package use only.

class CIPCompContainerItem;
class CIPCompView;
class CIPCompSlob;
class COleUndoManager;
class COleParentUndoUnit;
interface IMsoCommandTarget;
interface IPropertyPageUndoString;
interface ISelectionContainer;

// These flag is an addition to the OLECMDROUTEFLAG set
// defined in oleipc.h.  They are returned in the pgrf
// parameter to OleCmdFromId with the routing flags.
//
// OLECMDROUTEFLAG_PACKAGEUPDATE indicates that the document
// wants to perform additional command UI updating if the in-place
// component responds that the command is enabled.
//
// OLECMDROUTEFLAG_SINGLESTATE indicates that this command is a single
// state button, i.e. that it is never checked or latched.

#define OLECMDROUTEFLAG_PACKAGEUPDATE 0x80000000
#define OLECMDROUTEFLAG_SINGLESTATE	  0x40000000

#define	ITS_STANDARD_SUPPORT	0x0001
#define	ITS_CUSTOM_SUPPORT		0x0002

static const DWORD MULTI_SELECT_COOKIE = 0x0001;

void ShowErrorForInterface(REFIID riid, IUnknown * pUnk, HRESULT hr);

/////////////////////////////////////////////////////////////////////////////
//	CIPCompDocTemplate
//		Document template base class for in-place component document support
//		in packages.

class CIPCompDocTemplate : public CPartTemplate
{
	DECLARE_DYNAMIC(CIPCompDocTemplate)

public:
	CIPCompDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CPackage* pPackage, CPacket* pPacket, REFCLSID clsid);

	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
};

/////////////////////////////////////////////////////////////////////////////
//	CIPCompDoc
//		Document base class for in-place component document support in
//		packages.

class CIPCompDoc : public CPartDoc
{
	DECLARE_DYNCREATE(CIPCompDoc)
	friend CIPCompView;

public:
	//{{AFX_VIRTUAL(CIPCompDoc)
	public:
	//}}AFX_VIRTUAL
	virtual BOOL NewDocumentHook();
	virtual BOOL OpenDocumentHook(LPCTSTR lpszPathName);
	virtual void CloseDocumentHook();

	virtual HRESULT OnAmbientInvoke(DISPID dispidMember,REFIID riid,LCID lcid,
	      				  unsigned short wFlags,DISPPARAMS *pdispparams,
	      				  VARIANT *pvarResult,EXCEPINFO *pexcepinfo,
	      				  unsigned int *puArgErr) 
						  {return NOERROR;}
						  
	//$CONSIDER -- do these methods logically belong on CPackage?
	//That would make it easier to eliminate the package's implementation
	//of a document class.  The drawback would be that it introduces
	//in-place component specific implementation into CPackage, which
	//doesn't know about in-place components.
	//
	virtual BOOL OleCmdFromId(UINT nID, GUID **ppguid, DWORD *pcmdid, DWORD *prgf);
	virtual POPDESC * PopupDescFromGuidId(REFGUID rguid, UINT nMenuId);
		
	CIPCompDoc ();
	virtual ~CIPCompDoc ();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	CIPCompContainerItem * GetCtnrItem()
		{return m_pItem;}
		
	IOleObject * GetOleObject();
	IStorage * GetStorage();

	CSlob*	GetSlob(); 
	void	SetSlob(CIPCompSlob *pIpCompSlob)
			{ m_pIpCompSlob = pIpCompSlob; }
	IUnknown *GetTrackSelection();
	IUnknown *GetUndoActionManager();
	LRESULT	GetUndoRedoString(WPARAM nLevel, LPARAM lpstr, UINT cchBuf, BOOL fUndo);

	// Override this to display Context menu if you component(forms96) doesnt 
	// display context menu in response to VK_F10.  
	virtual void ShowContextPopupMenu(CPoint pt) { };
	
	// Service Provider override
	virtual HRESULT	GetService(REFGUID guidService, REFIID riid, void **ppvObj);
	// allow the doc to disallow a request for a service
	// S_OK == disallow, S_FALSE == its OK to let them have it
	virtual HRESULT VetoService(REFGUID guidService, REFIID riid)
					{ return S_FALSE; }
	
	// Builder Wizard Manager overrides
    virtual HRESULT DoesBuilderExist(REFGUID rguidBuilder)
					{ return E_NOINTERFACE; }
	virtual HRESULT GetBuilder(REFGUID rguidBuilder, DWORD grfGetOpt, 
					HWND hwndPromptOwner, IDispatch **ppdispApp,
					HWND *pwndBuilderOwner, REFIID riidBuilder,
					IUnknown **ppunkBuilder)
					{ return E_NOINTERFACE; }

	virtual HRESULT ShowIPCHelp(DWORD dwCompRole, REFCLSID rclsidComp,
								POINT posMouse, DWORD dwHelpCmd,
								LPOLESTR pwszHelpFile, DWORD dwData);
	virtual void UpdateIPCToolbarControl(GUID * pguid, DWORD cmdid, DWORD rgf) {};

	void BeginUndo(LPCTSTR szDescription);
	BOOL SetUndoStringMgr(IPropertyPageUndoString *pPPUS);
	void EndUndo(BOOL bAbort = FALSE);

	virtual void OnDocActivate(BOOL bActivate)
		{ return; }
	void SetDocObjViewActivate(BOOL fActivate)
		{ m_fDocObjViewUIActive = fActivate; }
		
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual void DoesSupportInternalSelect(DWORD* pgrfSupport)
					{
						*pgrfSupport = 0;
					}
	virtual HRESULT GetInternalSelectList(ISelectionContainer* pISC,
						CALPOLESTR* pcaStringsOut, CADWORD* pcaCookiesOut)
					{
						ASSERT(pISC);
						ASSERT(pcaStringsOut);
						ASSERT(pcaCookiesOut);

						// be a good citizen, initialize out params
						if (pcaStringsOut != NULL)
						{
							pcaStringsOut->cElems = 0;
							pcaStringsOut->pElems = NULL;
						}
						if (pcaCookiesOut != NULL)
						{
							pcaCookiesOut->cElems = 0;
							pcaCookiesOut->pElems = NULL;
						}

						if (NULL == pISC || NULL == pcaStringsOut ||
							NULL == pcaCookiesOut)
							return E_INVALIDARG;

						return E_NOTIMPL;
					}

public:
	//
	//	HRESULT OnPosRectChange
	//
	//	Description:
	//		Allows Document to resize itself, before resizing the OleClientItem.  
	//		Called from CIPCompContainerItem::XMyOleIPSite::OnPosRectChange.
	//		Returning an error, prevents the OleClientItem from being resized.
	//		Document should modify the rect if invalid.  This modified rect
	//		will be used from now on.
	//
	//	Arguments:
	//		LPRECT pPosRect:	IN  - suggested new size.  
	//							OUT - actuall new size.  
	//
	//	Return (HRESULT): S_OK if resized, error otherwise
	//
	//
	virtual HRESULT OnPosRectChange(LPRECT pPosRect) { return S_OK; };

	//
	//	void GetMinMaxInfo
	//
	//	Description:
	//		Allows document to specify MinMax info for the frame.
	//
	//	Arguments:
	//		MINMAXINFO * pMinMaxInfo: MINMAXINFO for frame
	//
	//	Return (void): none
	//
	virtual void GetMinMaxInfo(MINMAXINFO * pMinMaxInfo) {  };

	//
	//
	//	void OnWindowPosChanged
	//
	//	Description:
	//		Routes OnWindowPosChanged message to IP document
	//
	//	Arguments:
	//		WINDOWPOS FAR* lpwndpos:
	//
	//	Return (void):
	//
	virtual void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) {};
	
protected:
	CLSID m_clsid;	// the CLSID of the thing we are hosting
	CIPCompSlob	* m_pIpCompSlob;
	CIPCompContainerItem * m_pItem;	// the OleClientItem which provides the container site

	BOOL m_fDocObjViewUIActive;		// whether we have succeeded in create the doc object view
	
	COleRef<COleUndoManager>	 m_srpUndoMgr;
	COleRef<IPropertyPageUndoString> m_srpUndoStrMgr;
	CTypedPtrList<CPtrList, COleParentUndoUnit *> m_UndoStack;

	virtual BOOL InitOrLoadPersistence(IStorage * pStg, BOOL fNew);
	virtual BOOL NewOrLoadStorage(LPCTSTR pszPathName, IStorage ** ppStg, BOOL fNew);
	virtual void DoClose();

	// These functions are simply wrappers to similar functions
	// provided by the CIPCompFrameHook.  They give derived classes
	// access to those functions.
	//
	IMsoCommandTarget * GetSupportingTarget(GUID * pguid, DWORD cmdid, DWORD rgf);
	void SetIPCComboEditText(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void FillIPCCombo(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void OnIPCComboSelect(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void OnIPCComboEnter(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	
protected:
	//{{AFX_MSG(CIPCompDoc)
	//}}AFX_MSG

	afx_msg void OnEditUndo();
	afx_msg void OnEditRedo();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);

	

	DECLARE_MESSAGE_MAP()
};
#endif

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SHLDOCS__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\slob.h ===
#ifndef __SLOB_H__
#define __SLOB_H__

#include "shlmenu.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CSlobDragger;
class CSlobWnd;
class CSlobSequence;
class CPropBag;
class C3dPropertyPage;

class CPath;
class CFileRegEntry;
typedef CFileRegEntry * FileRegHandle;

// Slobs (Selection Objects) provide a basis for CEditor and CSelection
// that includes a standard property access mechanism with change
// notifications.
//
// Using this standard property mechanism, editors are isolated from
// the user interface of the property sheet.
//
// By making CSelection derive from CSlob and having it mirror the
// properties of all selected objects as well as broadcast any property
// changes it receives to all of the selected objects, handling setting
// properties on multiple selections becomes much easier.


// Special property identifiers
//
#define P_BEGIN_MAP		             0	// Pseudo-prop for marking the start of a map
#define P_END_MAP		             1   // Pseudo-prop for marking the end of a map
#define P_Container		             2   // Container property supported by all slobs
#define P_ID                         3
#define P_Value                      4
#define P_QuoteName                  5

#define P_Title     	             6
#define P_FileName                   7
#define P_FileDisplay                8

#define P_CurrentSlob	             9
#define P_PoppingProperties         10
#define P_CurrentSlobRect			11

// Properties for workspace window folder slobs
#define P_IsExpanded		        32
#define P_IsExpandable		        33
#define P_IsInvisibleNode           34
#define P_HasGlyphTipText	        35
#define P_BoldWorkspaceText	        36
#define P_ProjWinTitle		        37
#define P_ProxyContainer	        38
#define P_SccStatus			        39
#define P_PanePriorityIndex         40
#define P_PaneIsIndependent         41
#define P_SortPaneRootNodes         42
#define P_FileSaveCallBack          43
#define P_PaneHelpIdentifier        44
#define P_IPkgProject               45

// Standard Slob Notifications
#define SN_DESTROY		             0   // Dependancy has been destroyed
#define SN_ALL			             1   // All properties of dependancy (may) have changed
#define SN_CONTENT		            64	 // The CSlob content has changed
#define SN_ADD                      65   // A CSlob was added to the content list
#define SN_REMOVE                   66   // A CSlob was removed from the content list
#define SN_CONTENT_SCC_UPDATE       67	 // The CSlob content has changed

// Actions
#define A_PostSel                  100
#define A_PreSel                   101

// Commands and Verbs
#define C_COMMAND                  126
#define V_VERB                     127

#define P_MinPackage               128	// Minimum safe package property ID.

enum PROP_TYPE { null, action, integer, booln, longint, number, string, 
				slob, rect, point, verb, command };

// Property Descriptor
struct PRD
{
	UINT nProp;
	const void* pbOffset;
	// Note correspondence with CUndoSlob
	enum PROP_TYPE { null, action, integer, booln, longint, number, string, 
		slob, rect, point, verb, command } nType;
	LPCTSTR szName;
};


#define BEGIN_SLOBPROP_MAP(thisClass, parentClass) \
	PRD AFX_EXT_DATADEF thisClass::m_rgprd [] = { \
		{ P_BEGIN_MAP, &parentClass::m_rgprd[0], PRD::null, #thisClass },

#define END_SLOBPROP_MAP() \
	{ P_END_MAP, NULL, PRD::null, NULL } };

#define ACTION_PROP(name, memberFxn) \
	{ P_##name, &((theClass*)0)->memberFxn, PRD::action, #name },

#define BOOL_PROP(name) \
	{ P_##name, &((theClass*)0)->m_b##name, PRD::booln, #name },

#define FAKE_BOOL_PROP(name) \
	{ P_##name, NULL, PRD::booln, #name },

#define INT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_n##name, PRD::integer, #name },

#define FAKE_INT_PROP(name) \
	{ P_##name, NULL, PRD::integer, #name },

#define LONG_PROP(name) \
	{ P_##name, &((theClass*)0)->m_l##name, PRD::longint, #name },

#define FAKE_LONG_PROP(name) \
	{ P_##name, NULL, PRD::longint, #name },

#define DBL_PROP(name) \
	{ P_##name, &((theClass*)0)->m_num##name, PRD::number, #name },

#define STR_PROP(name) \
	{ P_##name, &((theClass*)0)->m_str##name, PRD::string, #name },

#define FAKE_STR_PROP(name) \
	{ P_##name, NULL, PRD::string, #name },

#define RECT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_rc##name, PRD::rect, #name },

#define POINT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_pt##name, PRD::point, #name },

#define FAKE_POINT_PROP(name) \
	{ P_##name, NULL, PRD::point, #name },

#define SLOB_PROP(name) \
	{ P_##name, &((theClass*)0)->m_p##name, PRD::slob, #name },

#define VERB_PROP(verbID) \
	{ V_VERB, (const void*)(0x0000ffff & verbID), PRD::verb, _T("Verb") },

#define COMMAND_PROP(cmdID) \
	{ C_COMMAND, (const void*)(0x0000ffff & cmdID), PRD::command, _T("Command") },

#define DECLARE_SLOBPROP_MAP() \
	public: \
		static PRD AFX_DATA m_rgprd []; \
		virtual const PRD FAR* GetPropMap() const \
		{ return &m_rgprd[0]; }


// Get*Prop return type
//	In a multiple-selection, a lower code has precedence over a higher code.
//
enum GPT
{
	avoid = -1,		// Like invisible, but is overriding in multiple selections
	invalid = 0,	// Not a known property or disabled
	ambiguous,		// Multiple selection with different values
	valid,			// Value is correct
	invisible,		// Hide this property's UI on prop pages
};

//
//	Schema version for slob implemenetation.  Used in IMPLEMENT_SERIAL:
#define SLOB_SCHEMA_VERSION	1

//	Find a propery in a propery map:
const PRD* PrdFindProp(const PRD* propMap, UINT idProp);

enum SORT_TYPE { no_sort, alpha_sort, override_sort };

// act_insert_into_undo_slob: when the undo mechanism records the
// post-action selection it will only remember those slobs who return
// TRUE for this action type.

enum ACTION_TYPE { act_delete, act_cut, act_copy, act_paste, act_drag, act_drop, act_insert_into_undo_slob, act_rename};

#define S_ON_COMMAND(n, f) case (n): (f)(); return TRUE;
#define S_ON_UPDATE_COMMAND_UI(n, f) case (n): (f)(pCmdUI); return TRUE;

// Object of _many_ uses
//
class CSlob : public CObject
{
	DECLARE_SERIAL(CSlob)

public:
	CSlob();

	virtual ~CSlob();

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

	// Copy properties only for 'this', doesn't copy properties
	// of contained slobs, both map and bag properties are copied
	virtual void CopyProps(CSlob *);

	// Clone an existing property bag into 'this' property bag
	virtual void ClonePropBag(CPropBag * pBag, int nBag = -1, BOOL fEmpty = TRUE);

	// Standard MFC serialization:
	virtual void Serialize(CArchive& ar);

	void SerializePropMap (CArchive& ar);
	virtual BOOL SerializePropMapFilter (int nIdProp) {return TRUE;}

	// Dependant Management
	void AddDependant(CSlob* newDependant);
	void RemoveDependant(CSlob* oldDepentant);
	virtual void InformDependants(UINT idChange, DWORD dwHint = 0);

	// Container Access
	inline CSlob* GetContainer() const
			{ return m_pContainer; }
	CSlob *GetRootContainer();

	// Move 'this' into pNewContainer.
	inline BOOL MoveInto(CSlob* pNewContainer)
			{ return SetSlobProp(P_Container, pNewContainer); }
	
	// Command enabling
	virtual BOOL CanAct(ACTION_TYPE action) { return TRUE; }
	// NYI: A final chance to refuse before the action
	virtual BOOL PreAct(ACTION_TYPE action) { return TRUE; }

#ifdef _DEBUG
	// Intentionally changed from BOOL to void returning functions to cause
	// compile errors in any code that still uses these.  You need to override
	// CanAct instead.

	virtual void CanDelete() {}
	virtual void CanCut() {}
	virtual void CanCopy() {}
	virtual void CanPaste() {}
	virtual void CanDrag() {}
#endif

	// Content Access (only valid for compound slobs!)
	virtual CObList* GetContentList();
	inline POSITION GetHeadPosition()
				{ CObList* p = GetContentList();
				  ASSERT(p != NULL);
				  return p->GetHeadPosition(); }
	inline CSlob* GetNext(POSITION& pos)
				{ CObList* p = GetContentList();
				  ASSERT(p != NULL);
				  return (CSlob*)p->GetNext(pos); }

	virtual void PrepareAddList(class CMultiSlob* pAddList, BOOL fPasting);

	virtual void Add(CSlob* pSlob);
	virtual void Remove(CSlob* pSlob);

	virtual BOOL CanAdd(CSlob* pAddSlob);
	virtual BOOL CanRemove(CSlob* pRemoveSlob);

#ifdef SLOB_REFERENCING
	// routines for creating a 'short-cut' to a slob
	// REVIEW: [patbr] the default 'reference' to a slob is just the slob itself
	virtual void CanReference() { return TRUE; }
	virtual CSlob *Reference()					// create a 'short-cut' to the slob
		{ return(this); }
	virtual void RefSerialize(CArchive& ar)		// serialize the 'reference'
		{ Serialize(ar); }
#endif

	// Notification Callback
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	// Property Management
	virtual BOOL SetDoubleProp(UINT idProp, double val);
	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetLongProp(UINT idProp, long val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
	virtual BOOL SetRectProp(UINT idProp, const CRect& val);
	virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
	virtual GPT GetDoubleProp(UINT idProp, double& val);
	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual	GPT GetLongProp(UINT idProp, long& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
	virtual GPT GetRectProp(UINT idProp, CRect& val);
	virtual GPT GetPointProp(UINT idProp, CPoint& val);

	// Property Bag Management
	virtual int GetPropBagCount() const;
	virtual CPropBag* GetPropBag(int nBag = -1);

	// Custom undo support hooks
	virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void DeleteUndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void BeginUndo(UINT nID);
	virtual void EndUndo(BOOL bAbort = FALSE);

	// Return window viewing this slob if any
	virtual CSlobWnd* GetSlobWnd() const;

	// Property Window Interface...
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Drag and Drop
	static  CSlob*	DropTargetFromPoint (CPoint screenPoint);
	virtual int GetCursorIndex();

#define DDC_SINGLE		0
#define DDC_COPY_SINGLE	1
#define DDC_MULTI		2
#define DDC_COPY_MULTI	3

	virtual HCURSOR GetCursor(int ddcCursorStyle);

	virtual void PrepareDrop(class CDragNDrop* pInfo);

	virtual CSlobDragger* CreateDragger(CSlob *pDragObject, 
		CPoint screenPoint);
	virtual void DoDrop(CSlob* pSlob, CSlobDragger* pDragger);
	virtual void DoDrag(CSlob* pSlob, CSlobDragger* pDragger, 
		CPoint screenPoint);

#ifdef _DEBUG
public:
	virtual void AssertValid() const;
	virtual void GetSlobName(CString& strName) const;
#endif

	//  Get filename associated with this slob, if any:
	virtual const CPath *GetFilePath () const { return NULL; } 
	virtual FileRegHandle GetFileRegHandle () const { return NULL; }
	virtual int GetAssociatedFiles(CStringArray &);

protected:

	// CSlob data size is currently 16 bytes.

	// WARNING!!  Think twice before adding data to CSlob.  We use many,
	// many, many of these in the product.

	CSlob* m_pContainer;

	// NOTE:  Because of 4 byte alignment we have 3 unused bytes here,
	// that we might want to use in the future, perhaps we could add
	// a style word...

	// Dependencies optimized for the 99% case, 2 or fewer dependants.
	// We keep 2 dependencies on the CSlob, and if nDep gets bigger than 2,
	// then all dependencies are moved into a CObList, and assign it
	// to m_aDep[0].

	BYTE m_cDep;
	CObject* m_aDep[2];

public:		// properties

	DECLARE_SLOBPROP_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CProjSlob -- root project slob class 
// REVIEW(scotg)  if you move any functions from CSlob into this class,  you
// will need to verify that ALL classes that inherit from CProjSlob that provide
// and implementation of the function you just moved, call the correct base class
// member function.  Since a large number of classes already inherited from CSlob
// before we introduced CProjSlob, these classes call CSlob member functions when 
// looking for their base class implementation and not CProjSlob.  Only the member
// functions moved into CProjSlob have had their base class calls change to 
// call CProjSlob implementations and not CSlob implementations.

class CProjSlob : public CSlob
{
	DECLARE_DYNAMIC(CProjSlob)

public:
	CProjSlob();
	virtual ~CProjSlob();


	// allow slobs to override text displayed when mouse pauses on glyph.
	// only called if P_HasGlyphTipText property is set for the slob.
	virtual void GetGlyphTipText(CString &strTip);

	// routines related to visually sorting the slob's contents
	// REVIEW: [patbr] are default behaviors here appropriate?
	virtual SORT_TYPE GetSortType()				// get type of sorting slob desires on contents
		{ return(alpha_sort); }
	virtual int CompareSlob(CSlob *pCmpSlob);	// returns -1, 0, 1 for <, ==, >

	// Cmds that can be handled by this slob
	virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo) { return FALSE; }	// Override to handle commands

	// Standard Display routine
	virtual BOOL DrawGlyph(CDC* pDC, LPCRECT lpRect);

	virtual HRESULT GetService(REFGUID guidService, REFIID riid, void ** ppvObj)
		{ *ppvObj = NULL; return E_NOTIMPL;}

};


/////////////////////////////////////////////////////////////////////////////
// CMultiSlob -- selection manager

class CMultiSlob : public CSlob
{
	DECLARE_DYNCREATE(CMultiSlob)

public:
	CMultiSlob();
	virtual	~CMultiSlob();

// Selection manipulation

	void Single(CSlob*, BOOL bSolo = FALSE);  // replace selection
	virtual void Clear(); // clear selection, remove all items
	virtual void Add(CSlob* pSlob);
	virtual void Remove(CSlob* pSlob);
	virtual void EnsureValidSelection();
	
// Select information

	BOOL IsSelected(CSlob* pSlob) const;
	BOOL IsOnlySelected(CSlob* pSlob) const;
	BOOL IsDominantSelected(CSlob* pSlob) const;
	CSlob* GetDominant() const;
	
// Slob Overrides
	
	virtual CObList* GetContentList();
	virtual CSlobWnd* GetSlobWnd() const;
	virtual int GetCursorIndex();
	virtual HCURSOR GetCursor(int ddcCursorStyle);
	virtual BOOL CanAdd(CSlob* pAddSlob);
	virtual BOOL CanAct(ACTION_TYPE action);
	virtual BOOL PreAct(ACTION_TYPE action);
	virtual BOOL Delete(BOOL bClip = FALSE, CSlob** ppNextSlob = NULL);
	virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	virtual BOOL SetDoubleProp(UINT idProp, double val);
	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetLongProp(UINT idProp, long val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
	virtual BOOL SetRectProp(UINT idProp, const CRect& val);
	virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
	
	virtual GPT GetDoubleProp(UINT idProp, double& valReturn);
	virtual GPT GetIntProp(UINT idProp, int& valReturn);
	virtual GPT GetLongProp(UINT idProp, long& val);
	virtual GPT GetStrProp(UINT idProp, CString& valReturn);
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
	virtual GPT GetRectProp(UINT idProp, CRect& val);
	virtual GPT GetPointProp(UINT idProp, CPoint& val);

	// Property Window Interface...
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	CSlobWnd*	m_pSlobWnd;// the owner of this selection
	CObList m_objects;	// list of selected objects
	BOOL m_bSolo:1; // can the selected obj be part of a multiple selection?
	BOOL m_bAllowEmpty:1; // the this selection be empty?
	BOOL m_bAllowMultipleContainers:1; // can selection cross containers?
};


/////////////////////////////////////////////////////////////////////////////
// CSlobDragger -- base class for objects used to drag slobs around

class CSlobDragger : public CObject
{
public:
	virtual void Show(BOOL bShow = TRUE) = 0;
	void Hide()
		{ Show(FALSE); }
	virtual CRect GetRect() = 0;
	virtual void Move(const CRect& newRect, BOOL bForceShow = FALSE) = 0;
};

class CSlobDraggerEx : public CSlobDragger
{
public:
	virtual void AddItem(CSlob* pSlob) = 0;
};

// Initiate a drag of "dragSlob" with the mouse at "downPoint".  This will 
// use a default CDragNDrop object to handle the operation.  For a custom 
// handler, use the other version of this function (e.g. VRes must use a 
// CResDragNDrop object).
void BeginDragDrop(CPoint downPoint, CSlob* dragSlob);

// Initiate a drag using a custom CDragNDrop class.
void BeginDragDrop(CDragNDrop* pInfo);

// Cancel any pending drag operation.
void CancelDragDrop();

// Returns TRUE if a drag operation is in progress, FALSE otherwise.
BOOL IsDragDropInProgress();


////////////////////////////////////////////////////////////////////////////
// CDragNDrop

class CDragNDrop
{

public:
  	CDragNDrop(CPoint downPoint, CSlob *dragSlob);
	virtual	~CDragNDrop();

	virtual void OnLButtonUp(UINT nFlags, CPoint point);
	virtual void OnRButtonUp(UINT nFlags, CPoint point);
	virtual void OnMouseMove(UINT nFlags, CPoint point);
	virtual void AbortDrop();
	virtual void IdleUpdate();
	virtual void FixupSelections(CMultiSlob* pSource, CMultiSlob* pDest);
	virtual void ChangeCursor();
	virtual BOOL IsCopy();
	virtual void Drop(UINT nFlags, CPoint point);

	CSlob* m_dragSlob; // the slob being dragged
	CSlobDragger* m_dragInfo; // used to gather information about the drag and drop
	CSlob* m_target; // the last potential drop target
	WORD m_wLastKeyState; // last state of keys (DD_CTRL / DD_SHIFT)

	CPoint m_downPoint;
	CPoint m_lastPoint;

	UINT	m_flags;
	CPoint	m_point;

	// User's selection in right-button drop popup menu.  NotSet if this
	// hasn't been used.
	enum DragMoveCopy { dragNotSet, dragMove, dragCopy, dragCancel } m_MoveCopy;
};

// Flags for the m_wLastKeyState member of CDragNDrop
#define DD_CTRL		0x0001
#define DD_SHIFT	0x0002


// Initiate a drag of "dragSlob" with the mouse at "downPoint".  This will 
// use a default CDragNDrop object to handle the operation.  For a custom 
// handler, use the other version of this function (e.g. VRes must use a 
// CResDragNDrop object).
void BeginDragDrop(CPoint downPoint, CSlob* dragSlob);

// Initiate a drag using a custom CDragNDrop class.
void BeginDragDrop(CDragNDrop* pInfo);

// Cancel any pending drag operation.
void CancelDragDrop();

// Returns TRUE if a drag operation is in progress, FALSE otherwise.
BOOL IsDragDropInProgress();


/////////////////////////////////////////////////////////////////////////////
//	Properties

class CProp
{
public:
	static void DeleteCProp (CProp *pPRop);
	PROP_TYPE m_nType;
};

class CIntProp : public CProp
{
public:
	CIntProp(int val = 0)
		{ m_nVal = val; m_nType = integer; }

	int m_nVal;
};

class CBoolProp : public CProp
{
public:
	CBoolProp(int val = FALSE)
		{ m_bVal = val; m_nType = booln; }

	int m_bVal;
};

class CNumberProp : public CProp
{
public:
	CNumberProp(double val = 0.)
		{ m_numVal = val; m_nType = number; }

	double m_numVal;
};

class CStringProp : public CProp
{
public:
	CStringProp(const char* szVal = "")
		{ m_strVal = szVal; m_nType = string; }

	CString m_strVal;
};

inline void CProp::DeleteCProp (CProp *pPRop)
{
	switch (pPRop->m_nType)
	{
		case integer:
			delete ( (CIntProp *) pPRop );
			break;
		case booln:
			delete ( (CBoolProp *) pPRop );
			break;
		case number:
			delete ( (CNumberProp *) pPRop );
			break;
		case string:
			delete ( (CStringProp *) pPRop );
			break;
		default:
			ASSERT(FALSE);		 		
	}
}

class CPropBag
{
	friend class CSlob;

public:
	CPropBag () : m_props(11) {};		// Use small block size.
	CPropBag (UINT nHash) : m_props(11) {m_props.InitHashTable(nHash, FALSE);}
	~CPropBag () {Empty();}

	// Enumerate props -- same as CMapWordToPtr's methods
	__inline POSITION GetStartPosition() const
		{return m_props.GetStartPosition();}

	__inline void GetNextAssoc(POSITION & pos, UINT & nPropID, CProp * & pProp) const
		{nPropID = (UINT)0; m_props.GetNextAssoc(pos, (WORD &)nPropID, (void * &)pProp);}

	__inline int GetPropCount () const
		{return m_props.GetCount();}

	// Setting of prop values.
	void SetIntProp(CSlob* pSlob, UINT nPropID, int val);
	void SetStrProp(CSlob* pSlob, UINT nPropID, CString & str);

	// TODO: add SetProp functions for other types...
	__inline CProp * FindProp(UINT nPropID) const
		{CProp * pProp; // ASSERT(HIWORD(nPropID)==0); // PropIDs are 16 bits only!
			return m_props.Lookup((WORD)nPropID, (void*&)pProp) ? pProp : (CProp *)NULL;}
	__inline void AddProp(UINT nPropID, CProp* pProp)
		{// ASSERT(HIWORD(nPropID)==0); // PropIDs are 16 bits only!
			m_props[(WORD)nPropID] = pProp;}
	void RemoveProp(UINT nPropID);
	void RemovePropAndInform(UINT nPropID, CSlob * pSlob);

	void Empty();
	void Clone(CSlob * pSlob, CPropBag * pBag, BOOL fEmpty = TRUE);

	// Serialize the props in this bag.  If the slob pointer is provided
	// the slob's serialize SerializePropMapFilter filter is used:
	void Serialize(CArchive & ar, CSlob *pFilterSlob = NULL);

protected:
	CMapWordToPtr m_props;
};

__inline void CPropBag::RemovePropAndInform(UINT nPropID, CSlob * pSlob)
{
	CProp * pProp;
	// ASSERT(HIWORD(nPropID)==0); // PropIDs are 16 bits only!
	if (m_props.Lookup((WORD)nPropID, (void*&)pProp))
	{
		CProp::DeleteCProp(pProp);
		VERIFY(m_props.RemoveKey((WORD)nPropID));
		pSlob->InformDependants((WORD)nPropID);
	}
}

__inline void CPropBag::RemoveProp(UINT nPropID)
{
	// only do removal if we find it
	// N.B. we don't VERIFY this op. 'cos it is more efficient
	// for clients of this class to call
	//
	// 	pBag->RemoveProp(idProp);
	//
	// rather than
	//
	//  if (pBag->FindProp(idProp))
	// 		pBag->RemoveProp(idProp));
	//
	// , for the case where the client doesn't care about the prop
	// value, in order to prevent the VERIFY() firing
	CProp * pProp;
	// ASSERT(HIWORD(nPropID)==0); // PropIDs are 16 bits only!
	if (m_props.Lookup((WORD)nPropID, (void*&)pProp))
	{
		CProp::DeleteCProp(pProp);
		VERIFY(m_props.RemoveKey((WORD)nPropID));
	}
}


/////////////////////////////////////////////////////////////////////////////
// CClipboardSlob

class CClipboardSlob : public CSlob
{
  	DECLARE_DYNAMIC(CClipboardSlob)

public:
	CClipboardSlob();
	~CClipboardSlob();

	void Copy(CSlob *pCopySlob);
	void Paste(CSlob *pDestSlob, CMultiSlob* pSelection = NULL, BOOL bClearSelection = TRUE);
	void ClearContents();
	
	BOOL CanAct(ACTION_TYPE action);
	
	virtual CObList* GetContentList()
		{ return &m_objects; }

	CObList m_objects;
};

extern CClipboardSlob AFX_DATA theClipboardSlob;


/////////////////////////////////////////////////////////////////////////////
//  Undo slob
//		REVIEW:  This is much more than really needs to be exposed to the
//               package developer.  Using Find in Files, I found only
//               some 12 simple global functions necessary to support our
//               current usage.

class CUndoStack;           // A stack of undo/redo-able actions
// CByteArray
	class CSlobSequence;    // A sequence of changes for one action
class CUndoRecord;          // One change in a sequence
	class CIntUndoRecord;
	class CLongUndoRecord;
	class CDoubleUndoRecord;
	class CRectUndoRecord;
	class CPointUndoRecord;
	class CSlobUndoRecord;
// CSlob
	class CUndoSlob;        // The master undo/redo controller

#define DEFAULT_UNDO_LEVELS 100

#pragma pack(2)

class CUndoRecord
{
public:
	WORD m_op;
	WORD m_nPropID;
	CSlob* m_pSlob;
	CPropBag* m_pBag;
};

class CIntUndoRecord : public CUndoRecord
{
public:
	int m_nOldVal;
};

class CLongUndoRecord : public CUndoRecord
{
public:
	long m_nOldVal;
};

class CDoubleUndoRecord : public CUndoRecord
{
public:
	double m_numOldVal;
};

class CRectUndoRecord : public CUndoRecord
{
public:
	CRect m_rectOldVal;
};

class CPointUndoRecord : public CUndoRecord
{
public:
	CPoint m_ptOldVal;
};

class CSlobUndoRecord : public CUndoRecord
{
public:
	const CSlob* m_pOldVal;
};

#pragma pack()

///////////////////////////////////////////////////////////////////////////
//	CUndoStack
//		maintains a list of CSlobSequences, one for each action
//		that may be undone or redone.  Each CSlobWnd gets one of these.

class CUndoStack
{
public:
	CUndoStack();
	~CUndoStack();
	
private:
	void Truncate(); // chop seqs off at m_nMaxLevels in the undo part
	void Flush(); // delete seqs and objects
	void FlushRedo(); // delete redo seqs
	
	CObList m_seqs; // CSlobSequence's for actions
	CObList m_objects; // CSlob's that have been deleted
	int m_nRedoSeqs; // how many seqs at head are for redo?
	int m_nMaxLevels; // how many levels are allowed?
	
	friend class CUndoSlob;
	friend class CSlobWnd;
};

// A CSlobSequence holds the codes for one undo or redo operation.
//
class CSlobSequence : public CByteArray
{
public:
	CSlobSequence();
	~CSlobSequence();
	
	void Retrieve(BYTE* rgb, int cb);
	void RetrieveStr(CString& str);
	inline void RetrieveRecord(CUndoRecord& rec)
			{ Retrieve((BYTE*)&rec, sizeof (CUndoRecord)); }
	inline void RetrieveByte(BYTE& b)
			{ Retrieve(&b, 1); }
	inline void RetrieveWord(WORD& w)
			{ Retrieve((BYTE*)&w, 2); }
	inline void RetrieveInt(int& n)
			{ Retrieve((BYTE*)&n, sizeof (int)); }
	inline void RetrieveLong(long& n)
			{ Retrieve((BYTE*)&n, sizeof (long)); }
	inline void RetrieveNum(double& num)
			{ Retrieve((BYTE*)&num, sizeof (double)); }
	inline void RetrievePtr(CSlob*& ptr)
			{ Retrieve((BYTE*)&ptr, sizeof (CSlob*)); }
	inline void RetrievePtr(CPropBag*& ptr)
			{ Retrieve((BYTE*)&ptr, sizeof (CPropBag*)); }
	inline void RetrieveRect(CRect& rc)
			{ Retrieve((BYTE*)&rc, sizeof (rc)); }
	inline void RetrievePoint(CPoint& pt)
			{ Retrieve((BYTE*)&pt, sizeof (pt)); }
	
	void Cleanup();
	BOOL IsUseful(CSlob*&, int&);
	void Apply();
	
#ifdef _DEBUG
	void Dump();
#endif
	
	int m_nCursor;
	CString m_strDescription;
	long m_nSerial;
};


/////////////////////////////////////////////////////////////////////////////
//	CUndoSlob

class CUndoSlob : public CSlob
{
	DECLARE_DYNAMIC(CUndoSlob)

public:
	CUndoSlob();
	~CUndoSlob();

// User Interface control

	BOOL CanUndo() const;
	BOOL CanRedo() const;
			
	void GetUndoString(CString& strUndo, int nLevel = 0);
	void GetRedoString(CString& strRedo, int nLevel = 0);

	void DoUndo(CSlobWnd* pSlobWnd); // perform an undo command
	void DoRedo(CSlobWnd* pSlobWnd); // perform a redo command
	
	void SetMaxLevels(int nLevels);
	int GetMaxLevels() const;

	void Flush(); // empty the current undo and redo stacks
	void FlushLast(); // prevent action merging

	inline BOOL InUndoRedo() const
			{ return m_bPerformingUndoRedo; }
			
// Recording Control

	void BeginUndo(const char* szCmd, CSlobWnd* pSlobWnd = NULL,
		BOOL bResetCursor = TRUE);
	void BeginUndo(UINT nID, CSlobWnd* pSlobWnd = NULL,
		BOOL bResetCursor = TRUE);
	void EndUndo(BOOL bAbort = FALSE);

	inline BOOL IsRecording()
		{ return m_nRecording != 0 && m_nPauseLevel == 0; }

	inline void Pause()
		{ m_nPauseLevel += 1; }
		
	inline void Resume()
		{ ASSERT(m_nPauseLevel > 0); m_nPauseLevel -= 1; }
	
	// This is used to link undo operations in two separate stacks
	// together (only in drag&drop for now)...
	inline void Link()
			{ m_nSerial -= 1; }

// Property change recorders

	void OnSetIntProp(CSlob* pChangedSlob, UINT nPropID, 
		UINT nOldVal, CPropBag* pBag = NULL);
	void OnSetLongProp(CSlob* pChangedSlob, UINT nPropID, 
		long nOldVal, CPropBag* pBag = NULL);
	void OnSetDoubleProp(CSlob* pChangedSlob, UINT nPropID, 
		double numOldVal, CPropBag* pBag = NULL);
	void OnSetStrProp(CSlob* pChangedSlob, UINT nPropID,
		const CString* pStrOldVal, CPropBag* pBag = NULL);
	void OnSetSlobProp(CSlob* pChangedSlob, UINT nPropID,
		const CSlob* pOldSlob, CPropBag* pBag = NULL);
	void OnSetRectProp(CSlob* pChangedSlob, UINT nPropID,
		const CRect& rcOldVal, CPropBag* pBag = NULL);
	void OnSetPointProp(CSlob* pChangedSlob, UINT nPropID,
		const CPoint& rcOldVal, CPropBag* pBag = NULL);
	void OnAddProp(CSlob* pSlob, CPropBag* pBag, UINT nPropID);
	void OnRemoveIntProp(CSlob* pSlob, CPropBag* pBag, 
		UINT nPropID, int nOldVal);
	
// Selection change recorders...

	void OnMultiRemove(CMultiSlob* pMultiSlob, CSlob* pRemoveSlob);
	void InsertSel(UINT nAction, CMultiSlob* pSel, CObList* pItems = NULL);
	void OnPreSel(CMultiSlob* pSel);
	void OnPostSel(CMultiSlob* pSel);
	

// Really low-level recording stuff

	enum {
		// Note correspondence with PRD
		opStart,
		opEnd,
		opAction,
		opIntProp,
		opLongProp,
		opBoolProp,
		opDoubleProp,
		opStrProp,
		opSlobProp,
		opRectProp,
		opPointProp
	};

	UINT Insert(const void* rgb, int cb);
	UINT InsertStr(const char* sz);
	inline UINT InsertByte(BYTE b)
			{ return Insert(&b, 1); }
	inline UINT InsertInt(int n)
			{ return Insert((BYTE*)&n, sizeof (int)); }
	inline UINT InsertLong(long n)
			{ return Insert((BYTE*)&n, sizeof (long)); }
	inline UINT InsertNum(double num)
			{ return Insert((BYTE*)&num, sizeof (double)); }
	inline UINT InsertPtr(const void* ptr)
			{ if (ptr != NULL)
				{
					ASSERT(((CObject*)ptr)->IsKindOf(RUNTIME_CLASS(CSlob)));
					((CSlob*)ptr)->AddDependant(this);
				}
			return Insert((BYTE*)&ptr, sizeof (CSlob*)); }
	inline UINT InsertRect(const CRect& rc)
			{ return Insert((BYTE*)&rc, sizeof (CRect)); }
	inline UINT InsertPoint(const CPoint& pt)
			{ return Insert((BYTE*)&pt, sizeof (CPoint)); }
	inline UINT InsertRecord(const CUndoRecord* pRec)
			{ return Insert((BYTE*)pRec, sizeof (CUndoRecord)); }


// CSlob overrides
	CObList* GetContentList();
	
#ifdef _DEBUG
	void Dump();
#endif

private:
	void Truncate();
	BOOL DoUndoRedo(CSlobWnd* pSlobWnd);
	
	int m_nRecording; // BeginUndo() nesting count
	int m_nPauseLevel; // Pause() nesting count
	
	// These ?Last* variables are used to coalesce consecutive changes
	// to the same property...
	CSlob* m_pLastSlob;
	int m_nLastPropID;
	
	// Properties...
	int m_nMaxLevels;

	CSlobSequence* m_pCurSeq;
	CUndoStack* m_pStack;
	
	BOOL m_bPerformingUndoRedo;
	
	CMultiSlob* m_pSel;
	
	long m_nSerial;
	CSlob* m_pDragDropObject;
	
	BOOL m_bFlushAtEnd;
	
	friend class CSlobSequence;
	friend class CUndoStack;
};

extern CUndoSlob AFX_DATA theUndoSlob;

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\vshell.h ===
// Microsoft Visual C++ shell library.
// Copyright (C) 1994 Microsoft Corporation,
// All rights reserved.

#ifndef __VSHELL_H__
#define __VSHELL_H__

#pragma warning(disable:4200) // (C8) 'zero sized array in struct/union'
#pragma warning(disable:4062) // (C8) 'enumerate in switch not handled'
#pragma warning(disable:4065) // (C8) 'switch statement contains only default'
#pragma warning(disable:4165) // '__stdcall function can't take variable number of arguments'

#ifdef _DEBUG
#pragma comment(lib, "devshld.lib")
#else
#pragma comment(lib, "devshl.lib")
#endif

#define OEMRESOURCE
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#pragma warning(disable:4200) // (C8) 'zero sized array in struct/union'
#include <afxpriv.h>
#include <tchar.h>
#include <limits.h>

#include "oleref.h"

#include "ids.h"
#include "main.h"
#include "package.h"
#include "shldocs.h"
#include "shlmenu.h"
#include "shlsrvc.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA



#undef AFX_DATA
#define AFX_DATA

#endif // __VSHELL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\util.h ===
/////////////////////////////////////////////////////////////////////////////
//	UTIL.H
//		Mostly GDI and file utilities.

#ifndef __UTIL_H__
#define __UTIL_H__

#include <msf.h>

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//	CLockDC
//		A CDC which handles locking and unlocking of updates to its window.
//		Used during drag loops.

class CLockDC : public CDC
{
public:
	CLockDC(CWnd* pWnd);
	~CLockDC();

protected:
	BOOL m_bLock;
	HWND m_hWnd;
};

/////////////////////////////////////////////////////////////////////////////
//	CImageWell
//		class provides a convenient way to handle "tiled" bitmaps.

class CImageWell
{
public:
	CImageWell();
	CImageWell(UINT nBitmapID, CSize imageSize);
	~CImageWell();
	void SetBitmap (CBitmap *pBitmap, CSize imageSize);
	
	BOOL Open();
	BOOL IsOpen() { return m_dc.m_hDC != NULL; }
	void Close();
	BOOL Load(UINT nBitmapID, CSize imageSize);
	BOOL LoadSysColor(UINT nBitmapID, CSize imageSize);
	BOOL Attach(HBITMAP hBitmap, CSize imageSize);
	HBITMAP Detach();
	void Unload();
	
	BOOL CalculateMask();
	
	BOOL DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage, 
		DWORD rop = 0); // rop==0 means image is drawn through a mask

	BOOL DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage, CSize sizeOverride,
		DWORD rop = 0); // rop==0 means image is drawn through a mask

	BOOL DrawMask(CDC* pDestDC, CPoint destPoint, UINT nImage, DWORD rop = NOTSRCCOPY);

	void GetImageSize(CSize& csImage)
	{
		csImage = m_imageSize;
	}
	
protected:
		
	CSize m_imageSize;
	
	// We use either this pointer or our member bitmap:
	CBitmap *m_pbitmap;

	UINT m_nBitmapID;
	CBitmap m_bitmap;
	
	CDC m_dc;
	CBitmap m_mask;
	CDC m_maskDC;
};

// hard-coded colors to be used instead of COLOR_BTNFACE, _BTNTEXT, etc.
//  - these are for access via MyGetSysColor() - and GetSysBrush()
#define CMP_COLOR_HILITE    21  // RGB(255, 255, 255)
#define CMP_COLOR_LTGRAY    22  // RGB(192, 192, 192) - instead of BtnFace
#define CMP_COLOR_DKGRAY    23  // RGB(128, 128, 128)
#define CMP_COLOR_BLACK     24  // RGB(0, 0, 0) - instead of frame

// - these are for when all you need is a RGB value)
#define CMP_RGB_HILITE      RGB(255, 255, 255)
#define CMP_RGB_LTGRAY      RGB(192, 192, 192)  // instead of BtnFace
#define CMP_RGB_DKGRAY      RGB(128, 128, 128)
#define CMP_RGB_BLACK       RGB(0, 0, 0)        // instead of frame

extern CBrush* GetSysBrush(UINT nSysColor);
extern void ResetSysBrushes();
extern CPen* GetSysPen(UINT nSysColor);
extern COLORREF MyGetSysColor(UINT nSysColor);

#define DSx		0x00660046L		// BitBlt ROPs
#define DSna	0x00220326L

// Paint this button "out," closer to the user.
#ifndef TBBS_EXTRUDED
#define TBBS_EXTRUDED 0x100
#endif

extern void DrawSplitter(CDC *pdc, CRect rect, BOOL bVert);
// Creates a push-button style bitmap
extern HBITMAP CreateButtonBitmap(CWnd* pWnd, UINT nStyle,  LPCRECT lpRect,
	CBitmap* pbmGlyph = NULL, LPCTSTR lpszText = NULL, BOOL bAddArrow = FALSE);
// creates a command bar style bitmap
extern HBITMAP CreateBarBitmap(CWnd* pWnd, UINT nStyle,  LPCRECT lpRect, CSize sizeButton, CSize sizeImage);

extern void ForceRectOnScreen(CRect& rect);
extern void ForceRectBelowTop(CRect& rect);

// For single pixel borders that are not actually window borders.
// Window borders should use system calculated border dimensions.
//
#define CX_BORDER 1
#define CY_BORDER 1
#define CY_TOOLBAR 28	// Toolbar height without borders.

extern BOOL PollForMouseChange(CPoint& pt, BOOL bYield, BOOL& bCancel, BOOL bAllowPaint=FALSE);
extern void FlushKeys();

//
// Given a EXE filename determine it's executable type if any.
//
typedef enum {
    EXE_FAIL,
    EXE_NONE,
    EXE_DOS,
    EXE_WIN,
    EXE_NT,
    EXE_OS2_NE,
    EXE_OS2_LE
} EXT; /* EXecutable Type */

extern EXT GetExeType(LPCTSTR lpstrEXEFilename, WORD * pwSubsystem);
extern UINT GetExePlatform(LPCTSTR szExeName);
extern BOOL IsFileGUIExe(LPSTR szFileName);
extern BOOL IsExecutableFile(LPCTSTR pszFileName);

#include <mmsystem.h>
extern BOOL PlayDevSound(UINT idsEvent, DWORD dwFlags = SND_ASYNC | SND_NODEFAULT);
extern BOOL PlayDevSound(const char* szEvent, DWORD dwFlags = SND_ASYNC | SND_NODEFAULT);
extern BOOL RegisterDevSoundEvent(UINT idsEventName, UINT idsFriendlyName);
extern BOOL RegisterDevSoundEvent(const char* szEventName, const char* szFriendlyName);

BOOL InEmergencyState();

// TRUE if a CCmdui is any kind of context menu
extern BOOL IsContextMenu(CCmdUI* pCmdUI);
extern BOOL IsMenu(CCmdUI* pCmdUI);
// Enable the menu if it has any visible items
extern void UpdateMenuCommand(CCmdUI* pCmdUI);

#ifdef _DEBUG
BOOL GetLogUndoFlag();
#endif

///////////////////////////////////////////////////////////////////////////////
//	CFileSaver
//		This is a little helper class for writing things to temporary files
//		and giving them the correct name after the save suceeds.

class CFileSaver
{
public:
	CFileSaver(const char* szFileName); // setup and create temp names
	~CFileSaver();                      // make sure temp files are gone
	BOOL CanSave() const;				// checks for R/O
	BOOL MakeWriteable() const;			// forces status of file to NOT R/O
	const char* GetSafeName() const     // return name of file to create
		{ return m_strTempName; }
	const char* GetRealName() const		// return name of final file
		{ return m_strName; }
	BOOL Finish();                      // rename new file as original

private:
	CString m_strName;
	CString m_strBackupName;
	CString m_strTempName;
	
	static const char BASED_CODE c_szAps [];
};

/////////////////////////////////////////////////////////////////////////////
//	CInitFile

class CInitFile : public CMemFile
{
	DECLARE_DYNAMIC(CInitFile)

public:
	enum INIT_DATATYPE { dataNil, dataReg, dataResource, dataStorage, dataMSF };

// Constructors
public:
	CInitFile();
	~CInitFile();
	
// Operations
public:
	BOOL Open(LPCSTR szSection, LPCSTR szKey, UINT nOpenFlags,
		INIT_DATATYPE type = dataReg);
	BOOL Open(LPSTORAGE pStorage, CString strStream, UINT nOpenFlags);
	BOOL Open(MSF *pmsf, WORD sn, UINT nOpenFlags);

	void SetBuffer(HGLOBAL hglobMem, UINT nCountBytes = -1,
		INIT_DATATYPE type = dataReg);
	HGLOBAL GetInitData();

	virtual void Close();	  // throw (CFileException);
	virtual void Abort();

protected:
	BOOL LoadFromSource();
	BOOL WriteToDest();

// Attributes
protected:
	BOOL m_bWrite;
	INIT_DATATYPE m_type;

	MSF *m_pmsf;
	WORD m_sn;

	LPCSTR m_lpszSection;
	LPCSTR m_lpszKey;

	HGLOBAL m_hglobUserMem;

	CString  m_strStream;
	LPSTREAM m_lpStream;

#ifdef _DEBUG
	virtual void AssertValid() const;
#endif
};

///////////////////////////////////////////////////////////////////////////////
//	CStateSaver

#define szWorkspaceSection _T("Workspace")
#define chMonikerSep _T('\n')

class CStateSaver
{
public:
	CStateSaver(BOOL bSaving);
	~CStateSaver();

	BOOL OpenMSF(LPCTSTR szFilePath, BOOL bForceWriteable);
	BOOL OpenStorage(LPCTSTR szFilePath);
	BOOL OpenStream(CInitFile& fileInit, CString strStream);
	void CloseStorage();
	BOOL Finish();

    const TCHAR * GetFileName() const { return (const TCHAR *)m_strFileName; }

	BOOL IsStoring() const { return m_bSaving; }
	BOOL IsLoading() const { return !m_bSaving; }
	BOOL IsFileBased() const { return (m_lpStorage != NULL || m_pMSF != NULL); }
	BOOL OpenFile(CInitFile& fileInit, SN nStream, LPCSTR szSection, LPCSTR szKey);

// Attributes
protected:
	BOOL m_bSaving;
	CFileSaver* m_pSaver;
    CString m_strFileName;
	LPSTORAGE m_lpStorage;

	MSF *m_pMSF;
};

/////////////////////////////////////////////////////////////////////////////
//	COLEStorage

class COLEStorage : public CObject
{
// Construction
public:
	COLEStorage(BOOL bReadOnly = TRUE);
	~COLEStorage();

// Attributes
public:
	LPCTSTR GetName();

// Operations
public:
	void Open(LPCTSTR lpszPath);
	void Create(LPCTSTR lpszPath);

// Sub-storage & stream operations
public:
	void OpenStream(LPCTSTR lpszName, COleStreamFile* pStream);
	void CreateStream(LPCTSTR lpszName, COleStreamFile* pStream);

	void OpenStorage(LPCTSTR lpszName, COLEStorage* pStorage);
	void CreateStorage(LPCTSTR lpszName, COLEStorage* pStorage);

// Implementation
protected:
	void* m_pStorage;
	DWORD m_grfMode;
};

// convert the windows ansi code page to the iso code page
// used by the htmx and htm packages for the code page
// meta data html tag
BOOL AnsiCodePageToIsoCodePage(/*[in]*/ LPCTSTR szAnsi, /*[out]*/ CString *pstrIso);

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif  // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\spawner.h ===
//	REVIEW(PatBr):  This needs to be drastically simplified and moved
//                  into shlsrvc.h.

// spawner.h
//

#ifndef __SPAWNER_H__
#define __SPAWNER_H__

#include <process.h>

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

#define	KEYENTRY				long	nKEY;

#define	KEYSET(ptr, key) ((ptr) -> nKEY = key)
BOOL AuxPrintf(
	LPSTR text,
	...);

#define	KEYCHECKRET(ptr, key, ret)	\
if(!(ptr) || ((ptr) -> nKEY != key)) \
{ _KeyError(__FILE__, __LINE__); return ret;}

#define	KEY0CHECKRET(ptr, key, ret)	\
if((ptr) && ((ptr) -> nKEY != key)) \
{ _KeyError(__FILE__, __LINE__); return ret;}

#define	KEYCHECK(ptr, key)	\
if(!(ptr) || ((ptr) -> nKEY != key)) { _KeyError(__FILE__, __LINE__); }

#define	KEY0CHECK(ptr, key)	\
if((ptr) && ((ptr) -> nKEY != key)) { _KeyError(__FILE__, __LINE__); }

void	_KeyError(LPSTR pszFileName, UINT nLine);

#else	// !_DEBUG

#define	KEYENTRY
#define	KEYSET(ptr, key)

#define	KEYCHECKRET(ptr, key, ret)
#define	KEY0CHECKRET(ptr, key, ret)
#define	KEYCHECK(ptr, key)
#define	KEY0CHECK(ptr, key)

#endif	// _DEBUG

struct TERROR;
typedef TERROR* PTERROR;
typedef TERROR* LPTERROR;
class CErrorContext;
// Key for the queue structure
#define	ERRORKEY		((long)-857229)

// create and destroy and error context
LPTERROR CreateErrorContext(UINT nErrorDepth, UINT nErrorMin, UINT nErrorMax);
void DestroyErrorContext(LPTERROR);

BOOL PushError(LPTERROR lpterror, ULONG nError);
LONG PopError(LPTERROR lpterror);
BOOL ClearError(LPTERROR lpterror);
INT GetDepth(LPTERROR lpterror);
LONG IndexError(LPTERROR lpterror, UINT nIndex);
int LoadError(HANDLE hInst, UINT nErrorNum, LPSTR szBuffer, size_t nBufsize);

#define	SYSTEM_ERROR	0x10000000

/////////////////////////////////////////////////////////////////////////////

// define some shared data structures between the VC ide and VcSpawn
// in order to do batched commands via named shared memory (aka mapped files)
#define chMultipleCmdFlag	TEXT('m')
#define chEventFlag			TEXT('e')
#define chToolFlag			TEXT('t')
#define chPauseFlag			TEXT('p')
#define chCmdSep			TEXT('\n')
#define szVCSpawnCmd		TEXT("vcspawn")
#define szVCSpawnEchoCmd	TEXT("~vcecho!")
#define szVCSpawnTimeCmd	TEXT("~vctime!")
#define szVCSpawnSleepCmd   TEXT("~vcsleep!")
// for multiple commands to be spawned, use the following:
// 'vcspawn -e -m commands-separated-by-chCmdSep'
// is the format of a command line that should be used.
//
// The return code of vcspawn is formatted thusly:
//	DWORD	dwRet, where:
//		index of failing command is HIWORD(dwRet)
//		return code of failing command is LOWORD(dwRet)
//	dwRet == 0 implies all commands were successful.

#define CB_COMM_BUF     (2048+1)

#define SPAWN_ERROR_DEPTH 10	// Depth of the error context stack
#define cbThrdStack 32768		// thread stack size

// shared buffer size for communication between spawned process and us
#define cbProcOutputBuf 4096
#define cbPipeBuf       (1L * cbProcOutputBuf)

static const TCHAR szSpawnTool[] = "vcspawn -e %lu %s ";
static const TCHAR szMultCmd[] = { TEXT('-'), chMultipleCmdFlag, 0 };
#define cbSpawnExpanded	(sizeof(szSpawnTool) + sizeof(szMultCmd) + 5)

typedef enum CompileState
{
	CS_START,
	CS_CREATEALLOC,
	CS_CREATEEVENT,
	CS_CREATEPIPE,
	CS_DUPLICATEHANDLES,
	CS_CREATENULFILE,
	CS_CREATEPROCESS,
	CS_KILLEDPROCESS,
	CS_SUCCESSFUL
} COMPILESTATE;

// ReadFile for pipes handling is different on Win95 from NT due to bugs in Win95.
BOOL FWin95ReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop);
BOOL FWinNTReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop);
typedef BOOL (*PfnReadPipe)(HANDLE, LPVOID, DWORD, DWORD &, HANDLE);

///////////////////////////////////////////////////////////////////
// CConsoleSpawner

class CConsoleSpawner
{
// Construction
public:
	CConsoleSpawner(CConsoleSpawner **ppSpawner);
	~CConsoleSpawner();

// Implementation
	BOOL CanSpawn() { return(m_fEnableSpawn); }
	BOOL InitializeSpawn(LPTSTR lpszSpawnDir, UINT nOutputWindowID, BOOL bClearOutputWindow, BOOL bSaveAll = TRUE, CErrorContext *pEC = NULL);
	BOOL PerformSpawn(LPTSTR lpszCommandLine, BOOL bMultipleCommand);
	BOOL PerformSpawnMultiple(CStringList *plistCommands);
	void CancelSpawn();
	void DisplayOutputFromConsole(LPTSTR lpszText);
	BOOL IsItErrorOrWarning(char *pszString);
	void GetErrorWarningCount(DWORD *pdwErrors, DWORD *pdwWarnings);

public:
	CConsoleSpawner **m_ppSpawner;	// back pointer
	HANDLE m_hNotifyEvent;
	HANDLE m_hCleanEvent;
	HANDLE m_hSpawnThread;
	HANDLE m_hWaitThread;
	HANDLE m_hSpawnEvent;
	HANDLE m_hDoneEvent;
	HANDLE m_hCancelEvent;
	HANDLE m_hReadPipe;
	HANDLE m_hNulStdin;		// handle to null device for input
	BOOL   m_fThreadDie;
	BOOL   m_fCloseWindow;
	BOOL   m_fGUITool;
	BOOL   m_fReloadNoPrompt;
	BOOL   m_fEnableSpawn;
	PROCESS_INFORMATION m_procinfo;
	SECURITY_ATTRIBUTES m_sa;
	char   m_szOutput[CB_COMM_BUF+1];
	int    m_ichOutput;
	UINT   m_nOutputWindowID;
	DWORD  m_dwTermStatus;

	CString   m_strError;
	CString   m_strOutput;
	CString   m_strSpawnDir;
	CErrorContext *m_pEC;

private:
	BOOL InitializeInternal(BOOL bClearOutputWindow);
	BOOL PerformInternal(LPTSTR lpszCommandLine, BOOL bMultipleCommand);
	BOOL PerformExternal(LPTSTR lpszCommandLine, BOOL bMultipleCommand);

public:
	static void _cdecl ReadChildProcessOutput2(LPVOID lpv);
private:
	static void _cdecl ReadChildProcessOutput(LPVOID lpv);
	static void _cdecl WaitChildProcessFinish(LPVOID lpv);

	HANDLE m_hpipeWriteOut;	// stdout handle for child process
	HANDLE m_hpipeWriteErr;	// stderr handle for child process
	HANDLE m_hGeneric;
	int    m_nFileWarnings;
	int    m_nFileErrors;

	LPTERROR  m_hSpawnErrors;

	COMPILESTATE m_CompileState;
	STARTUPINFO m_startinfo;

	static BOOL m_fUserWarned;		// has user been warned about missing VCSPAWN.EXE?
	static CHAR m_szSpawnTool[];	// string with which CreateProcess string is generated
};

///////////////////////////////////////////////////////////////////

#endif	// __SPAWNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\utilauto.h ===
/*

	Copyright 1996, Microsoft Corp.

*/

#include <ObjModel\appdefs.h>
#include <ObjModel\appauto.h> // from pkgs\include\ObjModel
#include <ObjModel\appguid.h>	// Shell Automation Guids
#include <objext.h>
#include <aut1api.h>

/*
This header contains what was once:
	dualimpl.h
	autoapp.h
	autocol.h
	autowins.h
*/

// WARNING!!!  This file is now including GUIDs defined via
//  DEFINE_GUID.  This means that if you #include this file
//  anywhere from your package, you must also #include it in
//  exactly one of your package's other files with a 
//  "#include <initguid.h>" beforehand: i.e.,
//		#include <initguid.h>
//		#include <utilauto.h>

// {AE166B02-A9A0-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IDispApplicationEvents,
0xAE166B02L,0xA9A0,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {B3CF8E20-19B6-11cf-8E4D-00AA004254C4}
DEFINE_GUID(LIBID_Shell,
0xb3cf8e20, 0x19b6, 0x11cf, 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4);
#define LIBID_Shell_STRING "TypeLib\\{B3CF8E20-19B6-11cf-8E4D-00AA004254C4}\\6.0"

#ifndef __UTILAUTO_H__
#define __UTILAUTO_H__

// This macro is the same as IMPLEMENT_OLECREATE, except it passes TRUE
//  for the bMultiInstance parameter to the COleObjectFactory constructor.
//  We want a separate instance of this application to be launched for
//  each Application object requested by automation controllers.

#define DS_DECLARE_OLECREATE(objfactory_class_name, class_name) \
public: \
	static AFX_DATA objfactory_class_name factory; \
	static AFX_DATA const GUID guid; \

#define DS_IMPLEMENT_OLECREATE(objfactory_class_name, class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF objfactory_class_name class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

/////////////////////////////////////////////////////////////////////////////
//
//
/*
	The MsDev needs a different GUID for the debug build. This is handled inside
	of autoapp.cpp. You should use msdevD.Application to get the debug version
	and msdev.Application to use the retail version.
	
	Without separate GUIDs it is not possible to debug the debug build with VB.
	Because VB will connect to the debugger.

	Packages generally will not need the debug CLSID. However, if a package does
	need it. It is define below.

	The real CLSID_ApplicationDebug is in autoapp.cpp. Make sure that these two
	versions are in-sync!
*/
#ifdef DEBUG_CLSID

#if 0 
// {9FD2DF21-190D-11CF-8E4D-00AA004254C4}
static const GUID CLSID_ApplicationDebug =  
{ 0x9fd2df21, 0x190d, 0x11cf, { 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4 }};
#endif

// {E8BEA480-DDE4-11cf-9C4A-00A0C90A632C}
static const GUID CLSID_ApplicationDebug  = 
{ 0xe8bea480, 0xdde4, 0x11cf, { 0x9c, 0x4a, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };

#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
// dualimpl.h

// NOTE:  You must include afxctl.h (preferably in your .pch) before
//  including this file.

// This file declares the functions, classes, and preprocessor macros
//  you need to create OLE Automation / dual interface objects that
//  expose functionality FROM Developer Studio packages TO macros
//  and addins.  The code in this file was taken from MFC and the
//  ACDUAL samples, with revisions made.  Functions & macros revised
//  for use in Developer Studio are prefixed with "Ds" and "DS_",
//  respectively.
// All implementation of these functions & classes is in
//  shell\dualimpl.cpp.
// For examples of usage, see the sample package in
//  dev\ide\pkgs\pkg.  Check out auto*.*.
// For more info, see dualimpl.doc, checked in to the VBA subproject of
//  the V5Spec project.  There's a link to it on
//  http://devstudio/devstudio/automation.


// CONTENTS:
//  DsThrowOleDispatchException:
//		Use this instead of AfxThrowOleDispatchException for throwing
//		errors inside your dispatch handlers.
//  DsThrowShellOleDispatchException:
//		Use this instead of AfxThrowOleDispatchException for throwing
//		system-defined errors inside your dispatch handlers.
//  DsThrowCannedOleDispatchException:
//		Use this instead of AfxThrowOleDispatchException for throwing
//		system-defined errors inside your dispatch handlers.
//  CAutoObj:
//		Derive your OLE Automation / dual interface objects from this.
//  CAutoWindowObj:
//		Derive your IGenericWindow implementing automation objects from this.
//  CMyOleDispatchImpl:
//		Used in CAutoObj.
//	General macros used for implementing dual interfaces.
//		Stolen from ACDUAL
//  New macros for implementing dual interfaces.
//		Not stolen from ACDUAL, these are brand new.
//  New macros for firing events


// To throw an error, use this function, and NOT AfxThrowOleDispatchException.
void DsThrowOleDispatchException(HRESULT hr, UINT nDescriptionID, UINT nHelpID=-1);

// Use this when you construct the prompt string yourself
void DsThrowOleDispatchException(HRESULT hr, LPCTSTR szPrompt, UINT nHelpID=-1);

// This function grabs a system-defined HRESULT & returns the sys string for the current locale
void DsThrowShellOleDispatchException(HRESULT hr, UINT nHelpID=0);

// This function grabs a system-defined HRESULT & returns the sys string for the current locale
void DsThrowCannedOleDispatchException(HRESULT hr, UINT nHelpID=0);

/////////////////////////////////////////////////////////////////////////////
// CAutoObj command target

// All OLE Automation / dual interface objects in DevStudio packages
//  should be derived from CAutoObj instead of CCmdTarget.
// We can't just use CCmdTarget, since we have to create a special
//  CMyOleDispatchImpl class (for why, see the comment above its
//  declaration), and the CMyOleDispatchImpl requires a member variable
//  of some CCmdTarget-derived type which it uses to call some protected
//  members of CCmdTarget.  Thus, this "CCmdTarget-derived type" must
//  be a new class of which CMyOleDispatchImpl is a friend.  Thus,
//  we make a special CAutoObj to fill this role.

class CMyOleDispatchImpl;

class CAutoObj : public CCmdTarget
{
	friend class CMyOleDispatchImpl;
	DECLARE_DYNCREATE(CAutoObj)

public:
// Added by DER - Called by Associated Real object such as
// CPartDoc or CPartFrame to inform the Automation object
// to clear its back pointer. Override and clear the back pointer.
	virtual void AssociatedObjectReleased() {} // DYNACREATE doesn't like virtuals...

	// Override this if you actually want your object to be usable
	//  after the user shuts the mainfrm.  Typically, you don't override
	//  this.  If you do, you may simply return without throwing an
	//  exception.  Then, in the implementation of each of your
	//  object's members you must either 1) be sure your implementation
	//  will work even if the user has shut down the UI, or 2) manually
	//  throw an exception warning the user that that member can
	//  not be accessed since the UI was shut down.  (See the base class
	//  implementation for how to do this in ide\shell\dualimpl.cpp.)
	// If you choose not to override this, then your object will automatically
	//  throw an exception if any of its members are accessed after the user
	//  has shut down the UI.  This is accomplished through:
	//  1) Code in CMyOleDispatchImpl::Invoke, and
	//  2) Code in the TRY_DUAL macro you should be using in your dual
	//	   interface vtbl handler.
	virtual void ThrowZombifiedException();

// Implementation
protected:
	virtual ~CAutoObj();
};



/////////////////////////////////////////////////////////////////////////////
// COleDispatchImpl - IDispatch implementation

// This was stolen & modified from MFC.  The change is that this version
//  of the class receives a pThis pointer on initialization rather than
//  constructing it.  It can't construct it, since this class no longer
//  lives at CCmdTarget::m_xDispatch--the implementation
//  of the dual interface lives there instead.
// Another change is the removal of the virtual Disconnect

class CMyOleDispatchImpl : public IDispatch
{
public:
	CAutoObj* m_pThis;
	CMyOleDispatchImpl(CAutoObj* pThis)
	{ m_pThis = pThis; }

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(GetTypeInfoCount)(UINT*);
	STDMETHOD(GetTypeInfo)(UINT, LCID, LPTYPEINFO*);
	STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, UINT, LCID, DISPID*);
	STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, LPVARIANT,
		LPEXCEPINFO, UINT*);
};


/////////////////////////////////////////////////////////////////////////////
// CHaltRecording
//
// PROBLEM 1:
//  This class fixes the "recording reentrancy" problem:
//  1) You're recording macro A.
//  2) You manipulate DevStudio in such a way that package X calls
//     into package Y's dual interface.
//  3) Package Y thinks it might have been called by UI interaction,
//     and so it says, "hey, we're recording, so I'd better record
//     what I'm doing"
//    RESULT: Package Y records something it shouldn't have, because
//     package X likely already recorded what the user just did that caused
//     package X to call into package Y.
// SOLUTION 1:
//  1) If you're using CAutoObj and all the stuff in this file, YOU DON'T
//     HAVE TO WORRY about this.  The TRY_DUAL macro below will be in
//     all your vtbl handlers, and that macro takes care of instantiating
//     a CHaltRecording.
//  2) If you're using some other way to automate your objects, then
//     you'll want to put the line "CHaltRecording someCoolVariableName"
//     at the top of your vtbl handler.
//
// PROBLEM 2:
//  You're recording macro A, and while you're recording, you run macro B.
//  If we're not careful, all the things that macro B causes the IDE
//  to do will get recorded as well.
// SOLUTION 2:
//  This is handled elsewhere in the shell, and you need not worry about
//  this at all in your package.  Just make sure you check
//  theApp.ShouldRecordText() before recording text, and you'll be fine.


class CHaltRecording
{
public:
	// Constructor halts recording (CTheApp::ShouldRecordText returns FALSE,
	//  but CTheApp::GetRecordState remains unchanged, so UI is unaffected)
	CHaltRecording()
	{ m_bSaveShouldRecordText = theApp.m_bShouldRecordText;
	  theApp.m_bShouldRecordText = FALSE; }

	// Destructor resumes previous behavior of CTheApp::ShouldRecordText.
	~CHaltRecording() { theApp.m_bShouldRecordText = m_bSaveShouldRecordText; }

protected:
	BOOL m_bSaveShouldRecordText;
};

// the HALT_RECORDING() macro is nice for method prologues
#define HALT_RECORDING()	CHaltRecording _HaltRecordingTempFromQCQP_H;


/////////////////////////////////////////////////////////////////////////////
// Lots of fun macros.  The following was stolen and modified from the ACDUAL
//  sample's mfcdual.h.



/////////////////////////////////////////////////////////////////////
// TRY_DUAL and CATCH_ALL_DUAL are used to provide exception handling
// for your dual interface methods. CATCH_ALL_DUAL takes care of 
// returning the appropriate error code.

#define TRY_DUAL(iidSource) \
	CHaltRecording _haltRecording;	\
	HRESULT _hr = S_OK; \
    REFIID  _riidSource = iidSource; \
	TRY \
	{ \
		if (theApp.m_pAutoApp == NULL || theApp.m_pAutoApp->IsZombified()) \
			pThis->ThrowZombifiedException(); \


#define CATCH_ALL_DUAL \
	} \
	CATCH(COleException, e) \
	{ \
		_hr = e->m_sc; \
	} \
	AND_CATCH_ALL(e) \
	{ \
		AFX_MANAGE_STATE(pThis->m_pModuleState); \
		_hr = DsDualHandleException(_riidSource, e); \
	} \
	END_CATCH_ALL \
	return _hr; \

/////////////////////////////////////////////////////////////////////
// DsDualHandleException is a helper function used to set the system's 
// error object, so that container applications that call through 
// VTBLs can retrieve rich error information		
HRESULT DsDualHandleException(REFIID riidSource, const CException* pAnyException);

/////////////////////////////////////////////////////////////////////
// DECLARE_DUAL_ERRORINFO expands to declare the ISupportErrorInfo
// support class. It works together with DUAL_ERRORINFO_PART and
// IMPLEMENT_DUAL_ERRORINFO defined below.
#define DECLARE_DUAL_ERRORINFO() \
    BEGIN_INTERFACE_PART(SupportErrorInfo, ISupportErrorInfo) \
        STDMETHOD(InterfaceSupportsErrorInfo)(THIS_ REFIID riid); \
    END_INTERFACE_PART(SupportErrorInfo) \

/////////////////////////////////////////////////////////////////////
// DUAL_ERRORINFO_PART adds the appropriate entry to the interface map
// for ISupportErrorInfo, if you used DECLARE_DUAL_ERRORINFO.
#define DUAL_ERRORINFO_PART(objectClass) \
    INTERFACE_PART(objectClass, IID_ISupportErrorInfo, SupportErrorInfo) \

/////////////////////////////////////////////////////////////////////
// IMPLEMENT_DUAL_ERRORINFO expands to an implementation of 
// ISupportErrorInfo which matches the declaration in 
// DECLARE_DUAL_ERRORINFO.
#define IMPLEMENT_DUAL_ERRORINFO(objectClass, riidSource) \
    STDMETHODIMP_(ULONG) objectClass::XSupportErrorInfo::AddRef() \
    { \
        METHOD_PROLOGUE(objectClass, SupportErrorInfo) \
	    return pThis->ExternalAddRef(); \
    } \
    STDMETHODIMP_(ULONG) objectClass::XSupportErrorInfo::Release() \
    { \
	    METHOD_PROLOGUE(objectClass, SupportErrorInfo) \
	    return pThis->ExternalRelease(); \
    } \
    STDMETHODIMP objectClass::XSupportErrorInfo::QueryInterface( \
	    REFIID iid, LPVOID* ppvObj) \
    { \
	    METHOD_PROLOGUE(objectClass, SupportErrorInfo) \
	    return pThis->ExternalQueryInterface(&iid, ppvObj); \
    } \
    STDMETHODIMP objectClass::XSupportErrorInfo::InterfaceSupportsErrorInfo( \
        REFIID iid) \
    { \
        METHOD_PROLOGUE(objectClass, SupportErrorInfo) \
        return (iid == riidSource) ? S_OK : S_FALSE; \
    }



/////////////////////////////////////////////////////////////////////


// Added for DevStudio

#define DS_DELEGATE_DUAL_INTERFACE(objectClass, dualClass) \
	STDMETHODIMP objectClass::X##dualClass::QueryInterface (REFIID riid, LPVOID FAR* ppvObj) \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).QueryInterface (riid, ppvObj); \
	} \
	STDMETHODIMP_(ULONG) objectClass::X##dualClass::AddRef() \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).AddRef(); \
	} \
	STDMETHODIMP_(ULONG) objectClass::X##dualClass::Release() \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).Release(); \
	} \
	STDMETHODIMP objectClass::X##dualClass::GetTypeInfoCount(UINT FAR* pctinfo) \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).GetTypeInfoCount(pctinfo); \
	} \
	STDMETHODIMP objectClass::X##dualClass::GetTypeInfo( \
	  UINT itinfo, \
	  LCID lcid, \
	  ITypeInfo FAR* FAR* pptinfo) \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).GetTypeInfo(itinfo, lcid, pptinfo); \
	} \
	STDMETHODIMP objectClass::X##dualClass::GetIDsOfNames( \
	  REFIID riid, \
	  OLECHAR FAR* FAR* rgszNames, \
	  UINT cNames, \
	  LCID lcid, \
	  DISPID FAR* rgdispid) \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); \
	} \
	STDMETHODIMP objectClass::X##dualClass::Invoke( \
	  DISPID dispidMember, \
	  REFIID riid, \
	  LCID lcid, \
	  WORD wFlags, \
	  DISPPARAMS FAR* pdispparams, \
	  VARIANT FAR* pvarResult, \
	  EXCEPINFO FAR* pexcepinfo, \
	  UINT FAR* puArgErr) \
	{ \
		METHOD_PROLOGUE(objectClass, Dispatch) \
		return CMyOleDispatchImpl(pThis).Invoke(dispidMember, riid, lcid, wFlags, pdispparams, \
											pvarResult, pexcepinfo, puArgErr); \
	}


// This is brand new!!  This adjusts m_xDispatch so that it doesn't
//  point to a COleDispatchDriverImpl.  Instead, it points directly
//  to the dual interface implemented by this object.  Unlike the
//  ACDUAL sample, which maintains two separate vtbls (dual and
//  just dispatch), DevStudio saves an extra DWORD per object
//  instance by only maintaining one vtbl: the dual interface.
// This also corrects the problem reported in Tech Note 65 about
//  passing dual interface pointers to/from functions that expect
//  FromIDispatch and GetIDispatch to work right.  By having
//  m_xDispatch point to the full dual interface, everything
//  just works.

#define DS_IMPLEMENT_ENABLE_DUAL(objectClass, dualClass) \
	void objectClass::EnableDualAutomation() \
	{ \
		ASSERT(GetDispatchMap() != NULL); \
		X##dualClass dual; \
		ASSERT(m_xDispatch.m_vtbl == NULL|| \
			*(DWORD*)&dual == m_xDispatch.m_vtbl); \
		ASSERT(sizeof(m_xDispatch) == sizeof(X##dualClass)); \
		m_xDispatch.m_vtbl = *(DWORD*)&dual; \
		*(X##dualClass*)&m_xDispatch = dual; \
	} \
	objectClass* PASCAL objectClass::FromIDispatch(I##dualClass* lpDual) \
	{ \
		X##dualClass dual; \
		ASSERT(*(DWORD*)&dual != 0); \
		if (*(DWORD*)lpDual != *(DWORD*)&dual) \
			return NULL; \
		objectClass* pTarget = (objectClass*) \
			((BYTE*)lpDual - offsetof(objectClass, m_xDispatch)); \
		ASSERT_VALID(pTarget); \
		return pTarget; \
	}


#define DS_DECLARE_ENABLE_DUAL(objectClass, dualClass) \
		friend class CMyOleDispatchImpl; \
	protected: \
		void EnableDualAutomation(); \
	public: \
		static objectClass* PASCAL FromIDispatch(I##dualClass* lpDual);


#define DS_BEGIN_DUAL_INTERFACE_PART(dualClass) \
	class X##dualClass : I##dualClass \
	{ \
		STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj); \
		STDMETHOD_(ULONG, AddRef)(THIS); \
		STDMETHOD_(ULONG, Release)(THIS); \
		STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo); \
		STDMETHOD(GetTypeInfo)( \
		  THIS_ \
		  UINT itinfo, \
		  LCID lcid, \
		  ITypeInfo FAR* FAR* pptinfo); \
		STDMETHOD(GetIDsOfNames)( \
		  THIS_ \
		  REFIID riid, \
		  OLECHAR FAR* FAR* rgszNames, \
		  UINT cNames, \
		  LCID lcid, \
		  DISPID FAR* rgdispid); \
		STDMETHOD(Invoke)( \
		  THIS_ \
		  DISPID dispidMember, \
		  REFIID riid, \
		  LCID lcid, \
		  WORD wFlags, \
		  DISPPARAMS FAR* pdispparams, \
		  VARIANT FAR* pvarResult, \
		  EXCEPINFO FAR* pexcepinfo, \
		  UINT FAR* puArgErr);

// Note that we don't add a member variable of this type like MFC does.  We're
//  using m_xDispatch to store the implementation class, and don't want to waste
//  another DWORD inside the object class.
#define DS_END_DUAL_INTERFACE_PART(dualClass) \
	}; \
	friend class X##dualClass;



/////////////////////////////////////////////////////////////////////////////
// EVENTS, EVENTS, EVENTS!!
// These are brand new macros to fire dispatch, then dual interface events.

// This macro is not used directly.  Rather, it's used within other macros.
//  This iterates through all sinks attached to the DUAL connection point,
//  and fires them in turn.  If a cancelable event is canceled, the iteration
//  stops.  The code to do that is in the macro that uses this macro.
#define BEGIN_FIRE_DUAL_EVENT(connPt, interfaceType) \
	{ \
		const CPtrArray* _pConnections = (connPt)->GetConnections(); \
		ASSERT(_pConnections != NULL); \
		CPtrArray _ConnectionsCopy; \
		_ConnectionsCopy.Copy(*_pConnections); \
		int i; \
		int _cConnections = _ConnectionsCopy.GetSize(); \
		IUnknown *pUnk; \
		for(i = 0; i < _cConnections; i++) { \
			pUnk = (LPUNKNOWN)(_ConnectionsCopy.GetAt(i)); \
			ASSERT(pUnk != NULL); \
			pUnk->AddRef(); \
		} \
		for (i = 0; i < _cConnections; i++) \
		{ \
			interfaceType *_pEvents = (interfaceType *) (_ConnectionsCopy.GetAt(i)); \
			ASSERT(_pEvents != NULL);


#define END_FIRE_DUAL_EVENT } \
		for(i = 0; i < _cConnections; i++) { \
			pUnk = (LPUNKNOWN)(_ConnectionsCopy.GetAt(i)); \
			ASSERT(pUnk != NULL); \
			pUnk->Release(); \
		} } }

#define EVENT_PARAM(vtsParams) (BYTE*)(vtsParams)
BOOL FireDispatchEvent(BOOL bCancelable, CConnectionPoint* pCP,
	DISPID dispid, BYTE* pbParams, ...);

// Event queueing macros
#define DS_QUEUE_EVENT0(connPt, dualConnPt, interfaceType, eventName, dispid) \
	if (theApp.m_pAutoApp->ShouldQueueEvents()) \
		theApp.m_pAutoApp->EventQueueAdd((connPt), (dualConnPt), (HRESULT (_stdcall interfaceType::*)()) (&interfaceType::eventName), (dispid), EVENT_PARAM(VTS_NONE), NULL); \
	else \
	{

#define DS_QUEUE_EVENT1(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1) \
	if (theApp.m_pAutoApp->ShouldQueueEvents()) \
	{ \
		DWORD dwArgs[2] = { (DWORD) (param1), 0 }; \
		theApp.m_pAutoApp->EventQueueAdd((connPt), (dualConnPt), (HRESULT (_stdcall interfaceType::*)()) (&interfaceType::eventName), (dispid), (paramType), dwArgs); \
	} \
	else \
	{

#define DS_QUEUE_EVENT2(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1, param2) \
	if (theApp.m_pAutoApp->ShouldQueueEvents()) \
	{ \
		DWORD dwArgs[2] = { (DWORD) (param1), (DWORD) (param2) }; \
		theApp.m_pAutoApp->EventQueueAdd((connPt), (dualConnPt), (HRESULT (_stdcall interfaceType::*)()) (&interfaceType::eventName), (dispid), (paramType), dwArgs); \
	} \
	else \
	{


// Use THESE macros directly.  Note that the macros are named by whether the
//  event is cancelable, and by how many parameters the event takes.  If
//  an event is cancelable, the BOOL* parameter at the end IS COUNTED as
//  a parameter in naming these macros:
//		FIRE_(<cancelable?>)_EVENT(<# parameters, including Cancel Boolean>)
// PLEASE consult the documentation in dualimpl.doc (discussed at the top of this
//  file) before using these macros.  There are caveats.

// NOTE1!!! (11/26/96) DO NOT FIRE EVENTS WITH MORE THAN 2 PARAMETERS.
//  To fix DevStudio bug 16185, we need to queue events in certain
//  situations.  The queue is prepared only to store events which pass
//  0, 1, or 2 parameters.  Currently the devstudio events fall into
//  this range.  If a new event is added which passes >2 parameters, the
//  event queue code needs to change.  SIMILARLY, "CANCELABLE" EVENTS
//  ARE NOT SUPPORTED in the event queue in V5, since no devstudio
//  events are cancelable.
// NOTE2!!! (11/26/96) DO NOT FIRE EVENTS WHICH PASS A STRING AS A PARAMETER
//  (Same bug.)  The queue code doesn't yet know how to make local copies of string arguments
//  so that they're not destroyed by the event-firing code after the event is
//  queued but before the event is actually fired from the queue.  If an event
//  which passes a string argument is created, code needs to be added to copy and
//  destroy all string arguments.  See the FUTURE comments below in the definitions
//  of the event queue functions.

// 0 Parameters

#define DS_FIRE_EVENT0(connPt, dualConnPt, interfaceType, eventName, dispid) \
	DS_QUEUE_EVENT0(connPt, dualConnPt, interfaceType, eventName, dispid) \
	FireDispatchEvent(FALSE, connPt, dispid, EVENT_PARAM(VTS_NONE)); \
	BEGIN_FIRE_DUAL_EVENT(dualConnPt, interfaceType) \
	_pEvents->eventName(); \
	END_FIRE_DUAL_EVENT

// 1 Parameter

#define DS_FIRE_EVENT1(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1) \
	DS_QUEUE_EVENT1(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1) \
	FireDispatchEvent(FALSE, connPt, dispid, paramType, param1); \
	BEGIN_FIRE_DUAL_EVENT(dualConnPt, interfaceType) \
	_pEvents->eventName(param1); \
	END_FIRE_DUAL_EVENT

// 2 Parameters

#define DS_FIRE_EVENT2(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1, param2) \
	DS_QUEUE_EVENT2(connPt, dualConnPt, interfaceType, eventName, dispid, paramType, param1, param2) \
	FireDispatchEvent(FALSE, connPt, dispid, paramType, param1, param2); \
	BEGIN_FIRE_DUAL_EVENT(dualConnPt, interfaceType) \
	_pEvents->eventName(param1, param2); \
	END_FIRE_DUAL_EVENT

// These macros add 10 reserved spaces in the vtbl of the IGenericDocument,
//  IGenericWindow, and IGenericProject interfaces.
#define DS_DECLARE_VTBL_PAD_10() \
    STDMETHOD(Reserved1)(THIS); \
    STDMETHOD(Reserved2)(THIS); \
    STDMETHOD(Reserved3)(THIS); \
    STDMETHOD(Reserved4)(THIS); \
    STDMETHOD(Reserved5)(THIS); \
    STDMETHOD(Reserved6)(THIS); \
    STDMETHOD(Reserved7)(THIS); \
    STDMETHOD(Reserved8)(THIS); \
    STDMETHOD(Reserved9)(THIS); \
    STDMETHOD(Reserved10)(THIS);

// Reserved spots will intentionally cause a crash to prevent anyone from calling them.
//  4 is my lucky number.
#define DS_IMPLEMENT_VTBL_PAD_10(className, interfaceName) \
	STDMETHODIMP className::X##interfaceName::Reserved1(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved2(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved3(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved4(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved5(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved6(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved7(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved8(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved9(THIS) { *(char*)0=4; return E_NOTIMPL; } \
	STDMETHODIMP className::X##interfaceName::Reserved10(THIS) { *(char*)0=4; return E_NOTIMPL; }

////////////////////////////////////////////////////////////////////////////////////////
//
// AUTOAPP.H --- This header was called autoapp.h
//

// The Application object is so special, it gets its own factory class.
//  The only difference between this and COleObjectFactory is that this
//  overrides OnCreateObject, so it calls CApplication::Create(), rather
//  than going through the MFC DYNCREATE stuff.  Thus, we're assured of only
//  having only one instance of the application object around.
class CApplicationFactory : public COleObjectFactory
{
public:
	CApplicationFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, LPCTSTR lpszProgID)
			: COleObjectFactory(clsid, pRuntimeClass,
			bMultiInstance, lpszProgID) {}

	virtual CCmdTarget* OnCreateObject();
	virtual BOOL Register();
};

////////////////////////////////////////////////////////////////////////////////////////
// Event Queue

// [These structures should just be private types defined inside CApplication,
//  but that causes compiler ICEs since it's a template feature not yet
//  fully supported by our compiler.]

// Entries in the queue need to know the max # of args that an event
//  can pass.  If this number changes, some code needs to change as well
//  (see the MAX_EVENT_ARGS ASSERTs in dualimpl.cpp).
#define MAX_EVENT_ARGS 2

// Abstract base class of event queue entries
class CEventEntry
{
public:
	virtual void FireDispatchEvent() = 0;
	virtual void FireDualEvent() = 0;	// Type-dependent; defined in template derived class
	virtual void DestroyArgs() = 0;
};

// Class for each of the event queue's entries, templatized on the type of the
//  dual interface source (i.e., T=IApplicationEvents or IDebuggerEvents, etc.)
//  [This code needs to remain inlined, since the compiler support for templates
//  doesn't handle non-inlined member functions well.]
template <class T> class CTypedEventEntry : public CEventEntry
{
public:
	virtual void FireDispatchEvent()
	{
		if (m_cArgs == 0)
		{
			::FireDispatchEvent(FALSE, m_pDispCP, m_dispid,
				m_pbParams);
		}
		else if (m_cArgs == 1)
		{
			::FireDispatchEvent(FALSE, m_pDispCP, m_dispid,
				m_pbParams, m_dwArgs[0]);
		}
		else
		{
			ASSERT (m_cArgs == 2);
			ASSERT (MAX_EVENT_ARGS == 2);	// This code must change if MAX_EVENT_ARGS changes
			::FireDispatchEvent(FALSE, m_pDispCP, m_dispid,
				m_pbParams, m_dwArgs[0], m_dwArgs[1]);
		}
	}

	virtual void FireDualEvent()
	{
		const CPtrArray* pConnections = m_pDualCP->GetConnections();
		ASSERT(pConnections != NULL);
		int cConnections = pConnections->GetSize();

		for (int i = 0; i < cConnections; i++)
		{
			T *pEvents = (T*) (pConnections->GetAt(i)); \
			ASSERT(pEvents != NULL);
			
			typedef HRESULT (_stdcall T::*ONEARG) (DWORD);
			typedef HRESULT (_stdcall T::*TWOARGS) (DWORD, DWORD);

			if (m_cArgs == 0)
				(pEvents->*m_pDualFcn)();
			else if (m_cArgs == 1)
				(pEvents->* ((ONEARG) m_pDualFcn))(m_dwArgs[0]);
			else
			{
				ASSERT (m_cArgs == 2);
				ASSERT (MAX_EVENT_ARGS == 2);	// This code must change if MAX_EVENT_ARGS changes
				(pEvents->* ((TWOARGS) m_pDualFcn))(m_dwArgs[0], m_dwArgs[1]);
			}
		}
	}

	// FUTURE: We currently don't fire any events that pass strings.  If/when
	//  we do add such events, we must add code here to destroy a copy of the
	//  BSTR we made when we added the entry to the event queue.
	virtual void DestroyArgs()
	{
		if (m_pDispCP != NULL)
		{
			m_pDispCP->ExternalRelease();
			m_pDispCP = NULL;
		}
		if (m_pDualCP != NULL)
		{
			m_pDualCP->ExternalRelease();
			m_pDualCP = NULL;
		}

		for (int i=0; i < m_cArgs; i++)
		{
			if (m_pbParams[i] == VT_DISPATCH && m_dwArgs[i] != 0)
			{
				((LPDISPATCH) m_dwArgs[i])->Release();
				m_dwArgs[i] = 0;
			}
		}
	}

	// This is the actual information that's stored so we know how to
	//  fire the "event" that's stored in this structure.  These pieces
	//  describe what the arguments are, and how to fire both the dispatch
	//  and the dual events.
	CConnectionPoint* m_pDispCP;
	CConnectionPoint* m_pDualCP;
	HRESULT (_stdcall T::*m_pDualFcn)();	// Template-ized virtual function pointer member variable of an embedded template-ized class.  Say that four times fast.
	DISPID m_dispid;
	DWORD m_dwArgs[MAX_EVENT_ARGS];
	BYTE m_pbParams[MAX_EVENT_ARGS+1];
	unsigned char m_cArgs;
};

/////////////////////////////////////////////////////////////////////////////
// CApplication command target

interface IAddIn;
interface IAutoBld;

class CApplication : public CAutoObj
{
	DECLARE_DYNCREATE(CApplication)

	CApplication();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:
    DECLARE_DUAL_ERRORINFO()

	static CApplication* Create();
	void Zombify();
	void Destroy();
	BOOL IsZombified(void) { return m_bZombified; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApplication)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CApplication();

	// Memembers for PrintToOutputWindow
	static UINT s_idOutputWindow;
	static BOOL s_bOutputWindow;

	// Some Application method calls delegate down to devaut1.pkg
	//  We access through these.
	IAddIn* m_pAddIn;
	IAutoBld* m_pBld;
	IAddIn* GetAddInInterface();
	IAutoBld* GetBldInterface();

    static CApplication* m_pAppObj;
    static DWORD m_dwCookie;
	BOOL m_bZombified;
	UINT m_nEnableModelessLevels;

	DS_BEGIN_DUAL_INTERFACE_PART(Application)
		STDMETHOD(get_Height)(THIS_ long FAR* Height);
		STDMETHOD(put_Height)(THIS_ long Height);
		STDMETHOD(get_Width)(THIS_ long FAR* Width);
		STDMETHOD(put_Width)(THIS_ long Width);
		STDMETHOD(get_Top)(THIS_ long FAR* Top);
		STDMETHOD(put_Top)(THIS_ long Top);
		STDMETHOD(get_Left)(THIS_ long FAR* Left) ;
		STDMETHOD(put_Left)(THIS_ long Left) ;
		STDMETHOD(get_Name)(THIS_ BSTR FAR* Name) ;
		STDMETHOD(get_Debugger)(THIS_ IDispatch * FAR* texteditor);
		STDMETHOD(get_Version)(THIS_ BSTR FAR* Version) ;
		STDMETHOD(get_Path)(THIS_ BSTR FAR* Path) ;
		STDMETHOD(get_CurrentDirectory)(THIS_ BSTR FAR* CurrentDirectory) ;
		STDMETHOD(put_CurrentDirectory)(THIS_ BSTR CurrentDirectory) ;
		STDMETHOD(get_FullName)(THIS_ BSTR FAR* FullName) ;
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application) ;
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent) ;
		STDMETHOD(get_ActiveDocument)(THIS_ IDispatch * FAR* ActiveDocument) ;
		STDMETHOD(get_Windows)(THIS_ IDispatch * FAR* Windows) ;
		STDMETHOD(get_Documents)(THIS_ IDispatch * FAR* Documents) ;
		STDMETHOD(get_ActiveWindow)(THIS_ IDispatch * FAR* ActiveWindow) ;
		STDMETHOD(get_WindowState)(THIS_ DsWindowState FAR* windowstate);
		STDMETHOD(put_WindowState)(THIS_ DsWindowState windowstate);
		STDMETHOD(get_TextEditor)(THIS_ IDispatch * FAR* texteditor);
		STDMETHOD(get_Projects)(THIS_ IDispatch * FAR* Projects);
		STDMETHOD(get_ActiveConfiguration)(THIS_ IDispatch * FAR* ActiveConfiguration);
		STDMETHOD(put_ActiveConfiguration)(THIS_ IDispatch * ActiveConfiguration);
		STDMETHOD(get_ActiveProject)(THIS_ IDispatch * FAR* ActiveProject);
		STDMETHOD(put_ActiveProject)(THIS_ IDispatch * ActiveProject);
	    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* Visible);
	    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Visible);
		STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) ;
		STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) ;
		STDMETHOD(GetPackageExtension)(THIS_ BSTR szExtensionName, IDispatch * FAR* pExt);
		STDMETHOD(Quit)(THIS);
		STDMETHOD(PrintToOutputWindow)(THIS_ BSTR Message);
	    STDMETHOD(ExecuteCommand)(THIS_ BSTR szCommandName);
	    STDMETHOD(AddCommandBarButton)(THIS_ long nButtonType, BSTR szCmdName, long dwCookie);
	    STDMETHOD(AddKeyBinding)(THIS_ BSTR szKey, BSTR szCommandName, BSTR szEditor);
		STDMETHOD(Build)(THIS_ VARIANT configuration);
	    STDMETHOD(RebuildAll)(THIS_ VARIANT configuration);
	    STDMETHOD(ExecuteConfiguration)(THIS_ VARIANT Reserved);
		STDMETHOD(SetAddInInfo)(THIS_ long nInstanceHandle, IDispatch * pCmdDispatch, long nIDBitmapResourceMedium, long nIDBitmapResourceLarge, long dwCookie);
		STDMETHOD(AddCommand)(THIS_ BSTR szCmdName, BSTR szMethodName, long nBitmapOffset, long dwCookie, VARIANT_BOOL FAR* pbResult);
	    STDMETHOD(EnableModeless)(THIS_ VARIANT_BOOL bEnable);
		STDMETHOD(Clean)(THIS_ VARIANT configuration);
		STDMETHOD(get_Errors)(THIS_ long FAR* nErrors);
		STDMETHOD(get_Warnings)(THIS_ long FAR* nWarnings);
		STDMETHOD(AddProject)(THIS_ BSTR szName, BSTR szPath, BSTR szType, VARIANT_BOOL bAddDefaultFolders);
DS_END_DUAL_INTERFACE_PART(Application)

	DS_DECLARE_ENABLE_DUAL(CApplication, Application)

	// Generated message map functions
	//{{AFX_MSG(CApplication)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DS_DECLARE_OLECREATE(CApplicationFactory, CApplication)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CApplication)
	afx_msg long GetHeight();
	afx_msg void SetHeight(long nNewValue);
	afx_msg long GetWidth();
	afx_msg void SetWidth(long nNewValue);
	afx_msg long GetTop();
	afx_msg void SetTop(long nNewValue);
	afx_msg long GetLeft();
	afx_msg void SetLeft(long nNewValue);
	afx_msg BSTR GetName();
	afx_msg LPDISPATCH GetDebugger();
	afx_msg BSTR GetVersion();
	afx_msg BSTR GetPath();
	afx_msg BSTR GetCurrentDirectory();
	afx_msg void SetCurrentDirectory(LPCTSTR lpszNewValue);
	afx_msg BSTR GetFullName();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH GetActiveDocument();
	afx_msg LPDISPATCH GetWindows();
	afx_msg LPDISPATCH GetDocuments();
	afx_msg LPDISPATCH GetActiveWindow();
	//afx_msg long GetWindowState();
	//afx_msg void SetWindowState(long nNewValue);
	afx_msg LPDISPATCH GetTextEditor();
	afx_msg LPDISPATCH GetProjects();
	afx_msg LPDISPATCH GetActiveConfiguration();
	afx_msg void SetActiveConfiguration(LPDISPATCH newValue);
	afx_msg LPDISPATCH GetActiveProject();
	afx_msg void SetActiveProject(LPDISPATCH newValue);
	afx_msg BOOL GetVisible();
	afx_msg void SetVisible(BOOL bNewValue);
	afx_msg LPDISPATCH GetPackageExtension(LPCTSTR szExtensionName);
	afx_msg void Quit();
	afx_msg void PrintToOutputWindow(LPCTSTR Message);
	afx_msg void ExecuteCommand(LPCTSTR szCommandName);
	afx_msg void AddCommandBarButton(long nButtonType, LPCTSTR szCmdName, long dwCookie);
	afx_msg void AddKeyBinding(LPCTSTR szKey, LPCTSTR szCmdName, LPCTSTR szPrompt);
	afx_msg void Build(const VARIANT FAR& configuration);
	afx_msg void RebuildAll(const VARIANT FAR& configuration);
	afx_msg void ExecuteConfiguration(const VARIANT FAR& configuration);
	//}}AFX_DISPATCH
	afx_msg BOOL AddCommand(LPCTSTR szCommandName, LPCTSTR szMethodName, long nBitmapOffset, long dwCookie);
	afx_msg void SetAddInInfo(long nInstanceHandle, LPDISPATCH pCmdDispatch, long nIDBitmapResourceMedium, long nIDBitmapResourceLarge, long dwCookie);
	afx_msg void EnableModeless(BOOL bEnable);

	afx_msg BOOL GetActive();
	afx_msg void SetActive(BOOL bNewValue);

	afx_msg DsWindowState GetWindowState();
	afx_msg void SetWindowState(DsWindowState nNewValue);
	afx_msg void Clean(const VARIANT FAR& configuration);
	afx_msg long GetErrors();
	afx_msg long GetWarnings();
	afx_msg void AddProject(LPCTSTR szName, LPCTSTR szPath, LPCTSTR szType, VARIANT_BOOL bAddDefaultFolders);

	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	BEGIN_INTERFACE_PART(ServiceProvider, IServiceProvider)
		STDMETHOD(QueryService) (REFGUID guidService, REFIID iid, void ** ppvObj);
	END_INTERFACE_PART(ServiceProvider)

protected:
	// Event queue implementation
	
	// The event queue fixes devstudio bug 16185, which causes a msgbox in one
	//  event handler to allow processing of windows messages we posted to
	//  ourselves, which can result in another event being thrown.  In this
	//  situation, we should not fire the event immediately.  Instead we now add it
	//  to the EventQueue, which is emptied after all macro/add-in message boxes
	//  have been dismissed, and also if the queue gets filled up (which is
	//  usually because the macro/add-in didn't pair its calls to EnableModeless
	//  correctly--EnableModeless is our cue that a message box is being
	//  displayed or was dismissed).

	// Queue size
	#define MAX_EVENT_QUEUE_ENTRIES 16

	BOOL m_bEventQueueEmptying;		// Flag to remember if we're emptying the queue
	int m_nEventQueueHead;
	int m_nEventQueueTail;

	void EventQueueInit();
	void EventQueueDestroy();
	void EventQueueAdd(CEventEntry* pEventEntry);
	CEventEntry* EventQueueRemove();// Caller must delete the returned CEventEntry*
	void EventQueueRemoveAll();		// Fires each event entry and destroys it
	CEventEntry* m_pEventQueue[MAX_EVENT_QUEUE_ENTRIES];

public:
	// Events

	// This is how clients will add an event to the queue.  It's called from
	//  the DS_FIRE_EVENT macros.  Type T represents the event dual interface
	//  (i.e., T=IApplicationEvents, IDebuggerEvents, etc.)
	// [Rather than taking a DWORD*, this should be a vararg function, consistent with
	//  FireDispatchEvent, whose latter arguments represent the event's parameters.
	//  However, that causes ICEs (devstudio 96 bug 17808), and the fixed compiler is not
	//  yet dropped, so this takes an array of DWORD-casted arguments at the end.]
	template<class T>
		void EventQueueAdd(CConnectionPoint* pDispCP, CConnectionPoint* pDualCP,
		HRESULT (_stdcall T::*pDualFcn)(), DISPID dispid, BYTE* pbParams, DWORD* pdwArgs)
	{
		CTypedEventEntry<T>* pEventEntry = new CTypedEventEntry<T>;

		pDispCP->ExternalAddRef();
		pEventEntry->m_pDispCP = pDispCP;

		pDualCP->ExternalAddRef();
		pEventEntry->m_pDualCP = pDualCP;

		pEventEntry->m_pDualFcn = pDualFcn;
		pEventEntry->m_dispid = dispid;

		// Fill in arguments (may be 0, 1, or 2 arguments)
		pEventEntry->m_cArgs = 0;
		if (pbParams != NULL)
		{
			const BYTE* pb = pbParams;
			while (*pb != 0)
			{
				ASSERT (pEventEntry->m_cArgs < MAX_EVENT_ARGS);

				// AddRef any dispatch arguments to this event (they're released
				//  after the event entry is dequeued)
				// FUTURE: We currently don't fire any events that pass strings.  If/when
				//  we do add such events, we must add code here to set aside a copy
				//  of the string, which we'll destroy after the evetn entry
				//  is dequeued
				if (*pb == VT_DISPATCH)
					((LPDISPATCH) pdwArgs[pEventEntry->m_cArgs])->AddRef();

				pEventEntry->m_dwArgs[pEventEntry->m_cArgs] = pdwArgs[pEventEntry->m_cArgs];
				pEventEntry->m_pbParams[pEventEntry->m_cArgs++] = *pb;
				pb++;
			}
		}
		pEventEntry->m_pbParams[pEventEntry->m_cArgs] = 0;	// pbParams ends in 0

		EventQueueAdd(pEventEntry);
	}

	// Queue events, rather than fire events, if a macro or add-in has a message
	//  box up.  This occurs when m_nEnableModelessLevels is nonzero.
	BOOL ShouldQueueEvents() { return m_nEnableModelessLevels != 0; }
		
	// Events we fire

	// Connection point for the dual event interface
	BEGIN_CONNECTION_PART(CApplication, ApplicationCP)
        CONNECTION_IID(IID_IApplicationEvents)
    END_CONNECTION_PART(ApplicationCP)

	// Connection point for the dispatch event interface
	BEGIN_CONNECTION_PART(CApplication, DispApplicationCP)
        CONNECTION_IID(IID_IDispApplicationEvents)
    END_CONNECTION_PART(DispApplicationCP)

    DECLARE_CONNECTION_MAP()

public:
	BOOL m_bMaximizeApp;		// Initialized in InitInstance, maintained in SetVisible

public:
	// Event firing functions

	void FireBeforeBuildStart()
		{ DS_FIRE_EVENT0(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		BeforeBuildStart, 1); }
    void FireBuildFinish(long nNumErrors, long nNumWarnings)
		{ DS_FIRE_EVENT2(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		BuildFinish, 2, EVENT_PARAM(VTS_I4  VTS_I4), nNumErrors, nNumWarnings); }
	void FireBeforeApplicationShutDown()
		{ DS_FIRE_EVENT0(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		BeforeApplicationShutDown, 3); }
	void FireDocumentOpen(LPDISPATCH theDocument)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		DocumentOpen, 4, EVENT_PARAM(VTS_DISPATCH), theDocument); }
	void FireBeforeDocumentClose(LPDISPATCH theDocument)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		BeforeDocumentClose, 5, EVENT_PARAM(VTS_DISPATCH), theDocument); }
	void FireDocumentSave(LPDISPATCH theDocument)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		DocumentSave, 6, EVENT_PARAM(VTS_DISPATCH), theDocument); }
	void FireNewDocument(LPDISPATCH theDocument)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		NewDocument, 7, EVENT_PARAM(VTS_DISPATCH), theDocument); }
	void FireWindowActivate(LPDISPATCH theWindow)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		WindowActivate, 8, EVENT_PARAM(VTS_DISPATCH), theWindow); }
	void FireWindowDeactivate(LPDISPATCH theWindow)
		{ DS_FIRE_EVENT1(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		WindowDeactivate, 9, EVENT_PARAM(VTS_DISPATCH), theWindow); }
	void FireWorkspaceOpen()
		{ DS_FIRE_EVENT0(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		WorkspaceOpen, 10); }
	void FireWorkspaceClose()
		{ DS_FIRE_EVENT0(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		WorkspaceClose, 11); }
	void FireNewWorkspace()
		{ DS_FIRE_EVENT0(&m_xDispApplicationCP, &m_xApplicationCP, IApplicationEvents,
		NewWorkspace, 12); }
};

inline CCmdTarget* CApplicationFactory::OnCreateObject() { return CApplication::Create(); }

/////////////////////////////////////////////////////////////////////////////
// CAutoWindowObj command target

// This class is the abstract base class for automation objects that implement the 
// IGenericWindow interface and derived interfaces. When subclassing this object, you must 
// override the event firing functions to fire events as appropriate.

// CPartFrame contains a pointer to one of these objects, and uses it to fire events

class CAutoWindowObj : public CAutoObj
{
	friend class CMyOleDispatchImpl;
	DECLARE_DYNCREATE(CAutoWindowObj)

public:
	// Events we fire

	// Connection point for the dual event interface
	/* BEGIN_CONNECTION_PART(CAutoWindowObj, WindowCP)
        CONNECTION_IID(IID_IWindowEvents)
    END_CONNECTION_PART(WindowCP)

	// Connection point for the dispatch event interface
	BEGIN_CONNECTION_PART(CAutoWindowObj, DispWindowCP)
        CONNECTION_IID(IID_IDispWindowEvents)
    END_CONNECTION_PART(DispWindowCP)

    DECLARE_CONNECTION_MAP()*/

public:
	// Event firing functions
	void FireActivate()
		{ /*DS_FIRE_EVENT0(&m_xDispWindowCP, &m_xWindowCP, IWindowEvents,
		Activate, 1); */}
	void FireDeactivate()
		{ /*DS_FIRE_EVENT0(&m_xDispWindowCP, &m_xWindowCP, IWindowEvents,
		Deactivate, 2); */}

// Implementation
protected:
	virtual ~CAutoWindowObj();
public:
	static BOOL RemoveChangeIndicatorFromWindowCaption(CString &strCaption); // returns whether " *" was stripped or not
};

/////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
//
// AUTOCOL.H --- This header was called autocol.h
//
//DER: 12 Apr 96 - Changed IEnumVarient to store IDispatch*'s instead of
// CAutoObj pointers. The following typedef will keep you honest.
typedef CTypedPtrList<CPtrList, IDispatch*> CDispatchList;

/////////////////////////////////////////////////////////////////////////////
// PLEASE NOTE!!!
//
// This OLE automation collection is provided as an example collection.
//  Typically, you will need to copy the code that implements this collection
//  to implement your own collection class.  All code that is commented out
//  with the note "// UNCOMMENT IF COPYING" above it should be uncommented
//  in your copy.  After copying and uncommenting, you will have to modify
//  the class to implement your specific collection object's behavior.
// For an example of how this can be done, see the sample
//  package: pkgs\pkg\autoicol.*, which implements a collection of integers.
//
// IF the collection class you're implementing is a collection of objects,
//  AND you require no new members, AND no changes to any existing members
//  (e.g., such as changing the behavior of Index() to deal with strings
//  as indices as well as integers), then you may derive from this class
//  directly.
// For an example of how this can be done, see the sample
//  package: pkgs\pkg\autofoos.*.
//
// For information on how to implement an Automation Collection class,
//  please see dualimpl.doc, checked in to the VBA subproject of
//  the V5Spec project.  There's a link to it on
//  http://devstudio/devstudio/automation.



/////////////////////////////////////////////////////////////////////////////
// IDualAutoCollection interface

DECLARE_INTERFACE_(IDualObjs, IDispatch)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;

    /* IDualAutoCollection methods */
    STDMETHOD(get_Count)(THIS_ long FAR* Count) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) PURE;
    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item) PURE;
};

class CEnumVariantObjs : public CCmdTarget
{
	DECLARE_DYNAMIC(CEnumVariantObjs)

// Attributes
public:
	CEnumVariantObjs(CDispatchList* pPtrlData);

// Operations

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumVariantObjs)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

	// Implementation
public:
	BEGIN_INTERFACE_PART(EnumVariant, IEnumVARIANT)
		STDMETHOD(Next)(THIS_ unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
		STDMETHOD(Skip)(THIS_ unsigned long celt) ;
		STDMETHOD(Reset)(THIS) ;
		STDMETHOD(Clone)(THIS_ IEnumVARIANT FAR* FAR* ppenum) ;
	END_INTERFACE_PART(EnumVariant)    


protected:
	~CEnumVariantObjs();
	POSITION m_posCurrent;
	CDispatchList* m_pPtrlData;

	// Generated message map functions
	//{{AFX_MSG(CEnumVariantObjs)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	DECLARE_INTERFACE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CAutoCollection command target

class CAutoCollection : public CAutoObj
{
	friend class CEnumVariantObjs;

	DECLARE_DYNCREATE(CAutoCollection)

// Attributes
public:
	CAutoCollection(CDispatchList* pPtrlData);


// Operations
public:
	// UNCOMMENT IF COPYING
	// See note at the top of ide\include\autocol.h for info on how
	//  to use this collection class as an example
    //DECLARE_DUAL_ERRORINFO()


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoCollection)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlData;
	virtual ~CAutoCollection();

	DS_BEGIN_DUAL_INTERFACE_PART(DualObjs)
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
	    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item);
	DS_END_DUAL_INTERFACE_PART(DualObjs)

	DS_DECLARE_ENABLE_DUAL(CAutoCollection, DualObjs)

	// Generated message map functions
	//{{AFX_MSG(CAutoCollection)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoCollection)
	afx_msg long GetCount();
	afx_msg LPDISPATCH Item(const VARIANT FAR& index);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN _NewEnum();
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//
// AutoWins.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAutoWindows command target

class CAutoWindows : public CAutoObj
{
	friend CApplication ;	
	//DECLARE_DYNCREATE(CAutoWindows)
	DECLARE_DYNAMIC(CAutoWindows)

	// CAutoWindows can operate in two modes: MDI mode and Owned mode.
	// Owned mode is the only mode used by packages, such as the edit packae.
	// In owned mode, Arrange and CloseAll only affect the members actually
	// stored in the array which are the windows owned by a particular document.
	// In MDI mode, which is used only by Application.Windows, Arrange and 
	// CloseAll operator over all MDI child windows whether they are in the
	// collection or not.
	// MDI mode is determined by the status of pOwnerDoc. 
	// If m_pOwnerDoc is NULL, we will work with the entire MDI space.
	// If m_pOwnerDoc is non-NULL, it points to a document whose windows we will use.
	CAutoWindows(CPartDoc* pOwnerDoc);           // protected constructor used by dynamic creation

// Attributes
public:

protected:
	// See comment above.
	CPartDoc* m_pOwnerDoc ;

	void DeleteCollection() ; // Delete the collection.
	void Sync() ;	// Update the collection.

// Operations
public:
	DECLARE_DUAL_ERRORINFO()

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoWindows)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAutoWindows();

	CDispatchList* m_pPtrlData;

	DS_BEGIN_DUAL_INTERFACE_PART(Windows)
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) ;
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) ;
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum) ;
		STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item) ;
		STDMETHOD(Arrange)(THIS_ VARIANT vtArrangeStyle) ;
		STDMETHOD(CloseAll)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) ;
	DS_END_DUAL_INTERFACE_PART(Windows)

	DS_DECLARE_ENABLE_DUAL(CAutoWindows, Windows)

	// Generated message map functions
	//{{AFX_MSG(CAutoWindows)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// See DualImpl.doc -- DECLARE_OLECREATE(CAutoWindows)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoWindows)
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& index);
	afx_msg void Arrange(const VARIANT FAR& vtArrangeStyle) ;
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN _NewEnum();
	afx_msg DsSaveStatus CloseAll(const VARIANT FAR& vtSaveChanges);

	// Not In Spec -- Removed afx_msg LPDISPATCH Add(BSTR FAR* docType);

	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()


};

/////////////////////////////////////////////////////////////////////////////


/* begin dual interface implementation macros */

/*

	A note on the implementation strategy here.  Most of dual interface delegation methods are
	identical except for the handler & interface names, so instead of redundantly expanding every
	single delegation, we use macros to factor out much common functionality.  These could be
	factored even further, although that would probably obscure these macros further.

 DELEGATE_NO_PARAMS delegates methods with no parameters to pass on
 DELEGATE_NO_PARAMS_WITH_RETVAL delegates methods with no parameters but a return value
 DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL delegates methods with no parameters but a VARIANT_BOOL return value
 DELEGATE_ONE_PARAM delegates methods with a single parameter
 DELEGATE_ONE_PARAM_WITH_RETVAL delegates methods with one parameter and a return value
 DELEGATE_ONE_PARAM_WITH_BOOL_RETVAL delegates methods with one parameter and a VARIANT_BOOL return value
 DELEGATE_TWO_PARAMS delegates methods with two parameters
 DELEGATE_TWO_PARAMS_WITH_RETVAL
 DELEGATE_BSTR_PUT delegates the setting of a BSTR property.  Because we have both the
		_Text and Text methods, we allow for the prop name & handler name to be different.
		Also, BSTR's need additional BSTR->LPCTSTR mapping code, so different macros.
 DELEGATE_BSTR_GET delegates the getting of a BSTR property.  Because we have both the
		_Text and Text methods, we allow for the prop name & handler name to be different.
		Also, BSTR's need additional BSTR->LPCTSTR mapping code, so different macros.
 DELEGATE_BOOL_PUT delegates the setting for VARIANT_BOOLs
 DELEGATE_BOOL_GET delegate the getting for VARIANT_BOOLs
 DELEGATE_PUT delegates the setting of a non-BSTR property
 DELEGATE_GET delegates the getting of a non-BSTR property
 
	Sample macro usage:

DELEGATE_GET(CAutoTextSel,TextSelection,Parent,LPDISPATCH)
DELEGATE_NO_PARAMS(CAutoTextDoc,TextDocument,Activate)

*/



// DELEGATE_NO_PARAMS delegates methods with no parameters to pass on

#define DELEGATE_NO_PARAMS(CLASS, INTERFACE, NAME) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(void) {	METHOD_PROLOGUE(CLASS, Dispatch)	\
	TRY_DUAL(IID_I##INTERFACE##) \
	{	\
		pThis->NAME(); \
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL \
}

// DELEGATE_NO_PARAMS_WITH_RETVAL delegates methods with no parameters but a return value

#define DELEGATE_NO_PARAMS_WITH_RETVAL(CLASS, INTERFACE, NAME, RETVAL_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ RETVAL_TYPE *pRet) {	METHOD_PROLOGUE(CLASS, Dispatch)	\
	TRY_DUAL(IID_I##INTERFACE##) \
	{	\
		*pRet = pThis->NAME();	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL \
}

// DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL delegates methods with no parameters but a VARIANT_BOOL return value

#define DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL(CLASS, INTERFACE, NAME) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ VARIANT_BOOL *pRet) {	METHOD_PROLOGUE(CLASS, Dispatch)	\
	TRY_DUAL(IID_I##INTERFACE##) \
	{	\
		BOOL b = pThis->NAME();	\
		*pRet = ((b == TRUE) ? VARIANT_TRUE : VARIANT_FALSE) ;\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL \
}

// DELEGATE_ONE_PARAM delegates methods with a single parameter

#define DELEGATE_ONE_PARAM(CLASS, INTERFACE, NAME, PARAM_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ PARAM_TYPE Param) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		pThis->NAME(Param);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_ONE_PARAM_WITH_RETVAL delegates methods with a single parameter and a return value

#define DELEGATE_ONE_PARAM_WITH_RETVAL(CLASS, INTERFACE, NAME, PARAM_TYPE, RETVAL_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ PARAM_TYPE Param, RETVAL_TYPE *pRet) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		*pRet = pThis->NAME(Param);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}


// DELEGATE_ONE_PARAM_WITH_BOOL_RETVAL delegates methods with a single parameter and a BOOL return value

#define DELEGATE_ONE_PARAM_WITH_BOOL_RETVAL(CLASS, INTERFACE, NAME, PARAM_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ PARAM_TYPE Param, VARIANT_BOOL *plRet) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		BOOL b = pThis->NAME(Param);										\
		*plRet = ((b == TRUE) ? VARIANT_TRUE : VARIANT_FALSE) ;				\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}



// DELEGATE_TWO_PARAMS delegates methods with two parameters

#define DELEGATE_TWO_PARAMS(CLASS, INTERFACE, NAME, PARAM1_TYPE, PARAM2_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ PARAM1_TYPE Param1, PARAM2_TYPE Param2) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		pThis->NAME(Param1, Param2);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_TWO_PARAMS_WITH_RETVAL delegates methods with two parameters
#define DELEGATE_TWO_PARAMS_WITH_RETVAL(CLASS, INTERFACE, NAME, PARAM1_TYPE, PARAM2_TYPE, RETVAL_TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::NAME(THIS_ PARAM1_TYPE Param1, PARAM2_TYPE Param2, RETVAL_TYPE *pRet) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		*pRet = pThis->NAME(Param1, Param2);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_BSTR_PUT delegates the setting of a BSTR property.  Because we have both the
// _Text and Text methods, we allow for the prop name & handler name to be different.
// Also, BSTR's need additional BSTR->LPCTSTR mapping code, so different macros.

#define DELEGATE_BSTR_PUT(CLASS,INTERFACE,PROP,HANDLER) \
STDMETHODIMP CLASS::X##INTERFACE##::put_ ## PROP(THIS_ BSTR bstrText) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		CString strText(bstrText); \
		pThis->Set ## HANDLER(strText);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_BSTR_GET delegates the getting of a BSTR property.  Because we have both the
// _Text and Text methods, we allow for the prop name & handler name to be different.
// Also, BSTR's need additional BSTR->LPCTSTR mapping code, so different macros.

#define DELEGATE_BSTR_GET(CLASS,INTERFACE,PROP,HANDLER) \
STDMETHODIMP CLASS::X##INTERFACE##::get_ ## PROP(THIS_ BSTR *pbstrText) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		*pbstrText = pThis->Get ## HANDLER();	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_PUT delegates the setting of a non-BSTR property

#define DELEGATE_PUT(CLASS,INTERFACE,PROP,TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::put_ ## PROP(THIS_ TYPE lVal) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		pThis->Set ## PROP(lVal);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_GET delegates the getting of a non-BSTR property

#define DELEGATE_GET(CLASS,INTERFACE,PROP,TYPE) \
STDMETHODIMP CLASS::X##INTERFACE##::get_ ## PROP(THIS_ TYPE *plRet) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		*plRet = pThis->Get ## PROP();	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// DELEGATE_BOOL_GET delegates the getting of VARIANT_BOOL property.

#define DELEGATE_BOOL_GET(CLASS,INTERFACE,PROP)								\
STDMETHODIMP CLASS::X##INTERFACE##::get_ ## PROP(THIS_ VARIANT_BOOL* plRet) \
{ METHOD_PROLOGUE(CLASS, Dispatch)											\
	TRY_DUAL(IID_I##INTERFACE##)											\
	{																		\
		BOOL b = pThis->Get ## PROP();										\
		*plRet = ((b == TRUE) ? VARIANT_TRUE : VARIANT_FALSE) ;				\
		return NOERROR;														\
	}																		\
	CATCH_ALL_DUAL															\
}

// DELEGATE_BOOL_PUT delegates the setting of VARIANT_BOOL properties

#define DELEGATE_BOOL_PUT(CLASS,INTERFACE,PROP) \
STDMETHODIMP CLASS::X##INTERFACE##::put_ ## PROP(THIS_ VARIANT_BOOL bVal) { METHOD_PROLOGUE(CLASS, Dispatch) \
	TRY_DUAL(IID_I##INTERFACE##)	\
	{	\
		BOOL b = (bVal == VARIANT_TRUE) ? TRUE : FALSE ; \
		pThis->Set ## PROP(b);	\
		return NOERROR;	\
	}	\
	CATCH_ALL_DUAL	\
}

// old macros for backward compatibility

//#define DELEGATE_NO_PARAMS_BOOL_RETVAL(c,i,n) DELEGATE_NO_PARAMS_WITH_RETVAL(c,i,n,VARIANT_BOOL)
#define DELEGATE_NO_PARAMS_IDISPATCH_RETVAL(c,i,n) DELEGATE_NO_PARAMS_WITH_RETVAL(c,i,n,LPDISPATCH)
#define DELEGATE_VARIANT_PARAM(c,i,n) DELEGATE_ONE_PARAM(c,i,n,VARIANT)
#define DELEGATE_LONG_PUT(c,i,p) DELEGATE_PUT(c,i,n,long)
#define DELEGATE_LONG_GET(c,i,p) DELEGATE_PUT(c,i,n,long)
// Incorrect #define DELEGATE_BOOL_PUT(c,i,p) DELEGATE_PUT(c,i,n,VARIANT_BOOL)
// Incorrect #define DELEGATE_BOOL_GET(c,i,p) DELEGATE_PUT(c,i,n,VARIANT_BOOL)
#define DELEGATE_IDISPATCH_GET(c,i,p) DELEGATE_PUT(c,i,n,LPDISPATCH)

/* end dual interface implementation macros */

/////////////////////////////////////////////////////////////////////////////
//  ShellAutomationState Object
//
//
//
/*
If you were writing a macro for DevStudio, you wouldn't want to see errors 
pop up in message boxes. If would like to get errors back which you could handle 
programmatically, wouldn't you? Well, that's that this mail is about.
A macro calls a Shell Automation methods or properties which calls functions in the 
shell and in YOUR package. The functions which the shell call should NOT display UI, 
but instead return error messages to the Shell Automation code. This includes YOUR functions.

In addition, DevStudio should not display dialog boxes asking the user if they want 
to save changes, if the function was invoked from a macro.



Which functions are affected?
-----------------------------

Currently, the Shell Automation model directly calls the following functions:
	CPartDoc::DoSave
	CPartDoc::OnCloseDocument
	CMainFrame::OnWindowCloseAll
	CPartTemplate::OpenDocumentFile
	theApp.SaveAll
	theApp.OpenFile

This results in the following functions getting called indirectly:
	CPartDoc::OnSaveDocument
	CPartDoc::SaveModified

  

What you need to do.
--------------------

1) Any function reachable from the functions listed in the first section above should 
not display UI. I have already done the main ones, you are left with the esoteric ones.

2) In some cases, I returned DS_E_UNKNOWN for the error message. You might want to 
provide a more detailed error message.



When to display UI
------------------

The following code shows how to determine if you should display UI.

#include "utilauto.h"
.
.
.

if (g_pAutomationState->DisplayUI())
{
	AfxMessageBox("Its okay to display UI.") ;
}
else
{
	TRACE0("Don't display any ui.") ;
}

BONUS: If you use FileErrorMessageBox, MsgBox, or any of its cousins, I already 
correctly check the automation state.



When to discard changes
-----------------------

If g_pAutomationState->DisplayUI is FALSE, you should NOT ask the user if they 
want to save changes. Instead you should use the SaveChanges functions.

if (g_pAutomationState->DisplayUI())
{
	//Ask the user if they want to save changes.
}
else
{
	// Don't ask the user if the want to save changes.
	if (g_pAutomationState->SaveChanges())
	{
		//The macro wants changes saved.
	}
	else
	{
		//The macro wants changes discarded.
	}
}

This kind of code happens most often in SaveModified. I have modified all of these.



How to return errors
--------------------

There are three ways to return errors.

1) The first way is to use an HRESULT defined specifically for the Shell Automation
Model. This is not for random HRESULTs. It needs to be defined in one of the *.defs.h 
headers in pkgs\include\objmodel. See me if you want to add some HRESULTs. 

	g_pAutomationState->SetError(DS_E_UNKNOWN) ;

2) Use a CFileException type error.

	g_pAutomationState->SetFileError(CFileException::badPath) ;

3) Use the global SetFileError in msgboxes.h.

BONUS: If you use SetFileError and FileErrorMessageBox, everything is done for you!!!




*/

interface IDsAutomationState
{
	// If TRUE, you can display UI. If FALSE do not display any UI.
	virtual BOOL DisplayUI() = 0;

	// If TRUE, you should save changes, if FALSE you should discard changes.
	virtual BOOL SaveChanges()  = 0 ;

	// Use one of the the following functions to set the error code.
	//
	// Set the error with a CFileException::m_cause type error. 
	// Translates the error into an HRESULT for automation purposes.
	// Used by the global function SetError
	virtual void SetFileError(int FileExceptionError) = 0;

	// Set the return value of the current operation.
	virtual void SetError(HRESULT hResult) = 0;

	// Set Prompt Canceled ;
	virtual void SetSavePromptCanceled() = 0 ;
	
	virtual void EnableUI() = 0 ;
	virtual void DisableUI() = 0 ;
};

// Use this to access the global shell automation state.
extern AFX_DATA IDsAutomationState* g_pAutomationState;
/////////////////////////////////////////////////////////////////////////////
//  Variant Conversion template function.
//
// PARAMETERS:
//	vInput			- The variant that you want to convert.
//	tReturnValue	- The variable you want to hold the converted value.
//  tDefaultValue	- The default value for the variable if the user didn't set it.
//						You should be explicit for the compiler to resolve the function.
//	vt				- The type of the paramter. The following types are supported:
//						VT_BOOL, VT_I4, VT_BSTR
//
// RETURN VALUES:
//	S_OK	- Successful conversion.
//	S_FALSE	- The default value was used.
//	E_FAIL	- The conversion failed...only happens if bThrowException is FALSE.
//
// Class T is the type of the out value.
//
//

ConvertVariantToCString(/*in*/	const VARIANT &vInput, 
					   /*out*/	CString& tReturnValue, 
					   /*in*/	CString tDefaultValue, 
					   /*in*/	BOOL bThrowException = TRUE);


ConvertVariantToLong( /*in*/	const VARIANT &vInput, 
					   /*out*/	long& tReturnValue, 
					   /*in*/	long tDefaultValue, 
					   /*in*/	BOOL bThrowException = TRUE);

ConvertVariantToBOOL(/*in*/	const VARIANT &vInput, 
					   /*out*/	BOOL& tReturnValue, 
					   /*in*/	BOOL tDefaultValue, 
					   /*in*/	BOOL bThrowException = TRUE);

#undef AFX_DATA
#define AFX_DATA NEAR



/*

	The following section contains declarations for some general helpers that are
	useful for doing macro recording.  Created from pkgs\edit\genrec.h. [CFlaat]

*/


class CRecArg
{
public: // methods

	virtual ~CRecArg(void) {}

	virtual void GetText(CString &str) = 0;
	virtual CRecArg *Clone(void) = 0;
};

class CIntArg : public CRecArg
{
protected: // data

	int m_nData;

private: // unused ctor

	CIntArg(void) { ASSERT(FALSE); /* this ctor shouldn't be used!! */ }

public: // methods
	
	CIntArg(int nVal) { m_nData = nVal; }

	virtual void GetText(CString &str) { str.Format("%d", m_nData); }
	virtual CRecArg *Clone(void) { return new CIntArg(m_nData); }

	int GetValue(void) { return m_nData; }
	void SetValue(int n) { m_nData = n; }
};


#if 0
// this class isn't used yet, but probably will be down the line
class CRawStringArg : public CRecArg
{
protected: // data

	CString m_strData;

private: // unused ctor

	CRawStringArg(void) { ASSERT(FALSE); /* this ctor shouldn't be used!! */ }
	virtual ~CRawStringArg(void) {}

public: // methods

	CRawStringArg(LPCTSTR szData) : m_strData(szData) {}

	virtual void GetText(CString &str) { str = m_strData; }
	virtual CRecArg *Clone(void) { return new CRawStringArg(m_strData); }
};
#endif

class CQuotedStringArg : public CRecArg
{
protected: // data

	CString m_strData;

private: // unused ctor

	CQuotedStringArg(void) { ASSERT(FALSE); /* this ctor shouldn't be used!! */ }

protected: // internal methods
	void GetQuotedBasicString(CString &strOut, LPCTSTR szData);

public: // methods
	
	CQuotedStringArg(LPCTSTR szData) : m_strData(szData) {}
	virtual ~CQuotedStringArg(void) {}

	virtual void GetText(CString &str) { GetQuotedBasicString(str, m_strData); }
	//{ str = (_T('\"') + m_strData) + _T('\"'); }
	virtual CRecArg *Clone(void) { return new CQuotedStringArg(m_strData); }

	LPCTSTR GetValue(void) { return m_strData; }
	void SetValue(LPCTSTR sz) { m_strData = sz; }
};

/*
	CGeneralRecorder
	================

	Some notes are due on this class.  Its purpose is to be a base class to be
	inherited from by specialized recording classes.  It's not a base class with
	a specific vtable-defined interface for two reasons.  First, we want type
	safety with the enum param strategy we use here.  Second, we don't want the
	overhead of a virtual function, since these methods generally get called with
	every operation, not just when recording is on (since the code-emitting fn's
	test for recording internally).

	For the future we may want to make the interfaces be more uniform and then
	merge IMacroRecorder and this class to create a more handy-dandy recording
	utility for package partners.  But for now, the two will stand separately.
*/

class CGeneralRecorder
{
protected: // methods

	virtual void SetMacRec(IMacroRecorder *pMacRec) = 0;
	virtual IMacroRecorder *GetMacRec(void) const = 0;
	virtual LPCTSTR GetPkgName(void) const = 0;

public: // methods

	CGeneralRecorder(void) {}
	virtual ~CGeneralRecorder(void) {}

	BOOL ShouldEmitCode(void) const { return theApp.ShouldRecordText(); }
	BOOL InRecordingMode() const { return theApp.GetRecordState() == CTheApp::RecordOn; }
	void RecordNothing(void) { GetMacRec()->RecordText(0, GetPkgName()); }


};




#endif //__UTILAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\utilbld_.h ===
/////////////////////////////////////////////////////////////////////////////
//	UTILBLD_.H
//		Microsoft only utilities used mostly for the build system.

#ifndef __UTILBLD__H__
#define __UTILBLD__H__

#include "utilctrl.h"
#include "msgboxes.h"
#include "dlgbase.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

interface IPkgProjectProvider;

///////////////////////////////////////////////////////////////////////////////
//	CEnvironmentVariableList
//		Class to hold a list of enviroment variable pairs.  Handy because it
//		resets the variable to there old values on destructions:
	
class CEnvironmentVariableList : public CObject
{
	CStringArray m_VariableNames;
	CStringArray m_VariableValues;
	BOOL m_bHoldingOld;
public:
	CEnvironmentVariableList () { m_bHoldingOld = FALSE; };
	~CEnvironmentVariableList() { if (m_bHoldingOld) ResetVariables (); };

	void AddVariable ( const TCHAR *pName, const TCHAR *pValue );
	// Set the values of the pairs in to the enviroment.  The old values
	// are saved over the new settings according to the flag:
	virtual void SetVariables ( BOOL bSaveOldValues = TRUE );
	// Reset the values saved when SetVariables was called:
	inline void ResetVariables () 
				{ ASSERT (m_bHoldingOld); SetVariables(FALSE);};
	inline void Clear () {  m_VariableNames.RemoveAll ();
							m_VariableValues.RemoveAll (); };
};

/////////////////////////////////////////////////////////////////////////////
//	CErrorContext
//
//	Class for error contexts.  These are things you pass to a function to that
//	it can record any error messages it generates.  Thus a typiccal example is
//
//		BOOL SomeFunc ( argc ... , CErrorContext EC& = g_DummyEC );
//
//	The purpose of these things is to keep messages for the user, not to save
//	information for calling functions to examine.  Thus you should not examine
//	the contents of an EC to figure out what happened, rely on return codes or
//	whatever instead.

class CErrorContext : public CObject
{	 
	DECLARE_DYNCREATE (CErrorContext);
public:
	virtual ~CErrorContext() {};

	//	Add a string to the ErrorConext.  Depending on the context, the string
	//	may or may not be displayed at this point:
	virtual void AddString ( const TCHAR *pstr ) {};
	virtual void AddString ( UINT ResID ) {};

	// Fill a string with all the messages in the context in the order in which
	// they we're added.  This is for _display_ only.  Classes the diplay 
	// messages as they occur may not implement this:
	virtual void GetString ( CString &rstr ) {};
	
	// Fill a string with all the messages in the context in the opposite order 
	// in which they we're added.  This should give a message of increasing 
	// specificity. For example:
	//
	//					Could not load document.
	//					Could not open file "blix.doc."
	//					Disk CRC error in sector la-de-da.
	// This is for _display_ only.  Classes the diplay messages as they occur 
	// may not implement this:
	virtual void GetRevString ( CString &rstr ) {};

	// Bring up a message box with the contents of the context.  Also not 
	// implemented by classes that display imediatetly:
	virtual int DoMessageBox ( MsgBoxTypes MsgBoxType = Error,
								UINT nButtonIDs = DEFAULT_BUTTONS,
								UINT nHelpContext = DEFAULT_HELP )
				 { return MB_OK; };

	//	Clear the content of the context and prepared for a new, unrelated
	//	error:
	virtual void Reset () {};
};

// Global dummy context that can be used as a default argument:
extern CErrorContext AFX_DATA g_DummyEC;

//	Simple error context that just keeps a list of messages:
class CStorageEC : public CErrorContext 
{
	DECLARE_DYNCREATE (CStorageEC);
protected:
	CStringList m_StringList;
public:
	virtual ~CStorageEC() {};

	virtual void AddString ( const TCHAR *pstr ); 
	virtual void AddString ( UINT ResID ); 

	virtual void GetString ( CString &rstr );
	virtual void GetRevString ( CString &rstr );

	virtual int DoMessageBox ( const MsgBoxTypes MsgBoxType = Error,
								UINT nButtonIDs = DEFAULT_BUTTONS,
								UINT nHelpContext = DEFAULT_HELP );

	virtual void Reset ();
}; 

class CProjTypeItem
{
public:
	CProjTypeItem(HICON hIcon, LPCTSTR strName, LPCTSTR strExtension,
		LPCTSTR strTabName, BOOL bSupportDependency, BOOL bUseSubDirectories,
		DWORD dwProject_ID, IPkgProjectProvider *pProjectProvider)
	{
		m_hIcon = hIcon;
		m_strName = strName;
		m_strExtension = strExtension;
		m_strTabName = strTabName;
		m_bSupportDependency = bSupportDependency;
		m_bUseSubDirectories = bUseSubDirectories;
		m_dwProject_ID = dwProject_ID;
		m_pProjectProvider = pProjectProvider;
	}

	~CProjTypeItem() { }

public:
	HICON m_hIcon;
	CString m_strName;
	CString m_strExtension;
	CString m_strTabName;
	BOOL m_bSupportDependency;
	BOOL m_bUseSubDirectories;
	DWORD m_dwProject_ID;
	IPkgProjectProvider *m_pProjectProvider;
};


// Classification for items in the Project Type icon list box
enum TYPE_ITEM_CLASS { appWiz, customWiz, buildSys, test, makefile };

// This represents one item in the Project Type icon list box
class CProjTypeListItem
{
public:
	CProjTypeListItem(const TCHAR* szText, HICON hIcon, TYPE_ITEM_CLASS itemClass, int index=0);
	~CProjTypeListItem();

	const TCHAR* GetText() const
		{ return m_strText; }

	HICON GetIcon() const
		{ return m_hIcon; }

	TYPE_ITEM_CLASS GetClass() const
		{ return m_class; }

	BOOL IsAnAppWizard() const
		{ return m_class == appWiz || m_class == customWiz; }

	BOOL HasCreateDialog() const
		{ return IsAnAppWizard() || m_class == makefile; }

	int GetIndex() const { return m_index; }
	void SetIndex(int newIndex) { m_index = newIndex; }

protected:
	CString m_strText;
	TYPE_ITEM_CLASS m_class;
	HICON m_hIcon;
	int m_index;
};


// The Project Type icon list box  THIS CLASS IS TEMPORARY
class CProjTypeIconList : public CIconList
{
public:
	virtual void SetIcon(int nItem, HICON hIcon);
	virtual HICON GetIcon(int nItem);

	int AddItem(CProjTypeListItem* pItem);
	void InsertItem(int nInsertAt, CProjTypeListItem* pItem);

protected:
	afx_msg void OnDestroy();

	DECLARE_MESSAGE_MAP()
};


// The Project Type list
class CProjTypeList
{
public:
	virtual HICON GetIcon(int nItem);

	int AddItem(CProjTypeListItem* pItem);
	void InsertItem(int nInsertAt, CProjTypeListItem* pItem);

	int GetCount() { ASSERT(m_strings.GetSize() == m_dataPtrs.GetSize());
					return m_strings.GetSize(); }
	int AddString(LPCTSTR str);
	int InsertString(int nItem, LPCTSTR str);
	void GetText(int nItem, CString &str);
	void *GetItemDataPtr(int nItem);
	void SetItemDataPtr(int nItem, void *ptr);

	~CProjTypeList();
	CProjTypeList();

private:
	CStringArray m_strings;
	CPtrArray m_dataPtrs;
};

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// __UTILBLD__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\utilctrl.h ===
/////////////////////////////////////////////////////////////////////////////
//  UTILCTRL.H
//		Utility control extensions for use in packages:
//
//		-Grid control
//		-Tree control
//		-Check listbox
//		-Icon listbox
//		-Menu button
//		-Tabbed scrollbar

#ifndef __UTILCTRL_H__
#define __UTILCTRL_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#ifndef __SHLMENU_H__
#include "shlmenu.h"
#endif

#ifndef __SHLBAR_H__
#include "shlbar.h"
#endif

#ifndef __UTIL_H__
#include "util.h"
#endif

class CSlob;
class CPartFrame;

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

////////////////////////////////////////////////////////////////////////////
// Grid Classes

class CGridElement;
	class CGridCell;
	class CGridRow;
		class CGridControlRow;
//CWnd
	class CGridWnd;
		class CGridControlWnd;
			class CStringListGridWnd;
				class CStringListGlyphGridWnd;

/////////////////////////////////////////////////////////////////////////////
//	CGridToolBar
//		This is the grid's toolbar 

class CGridToolBar : public CToolBar
{
public:
	enum {
		sizeButtonX = 22,
		sizeButtonY = 20,
		sizeImageX = 14,
		sizeImageY = 12,
	};

	CGridToolBar();
	void SetSizes();
};


/////////////////////////////////////////////////////////////////////////////
//	CStaticVCenter
//		This is a static control that draws text (single line) vertically centered

class CStaticVCenter : public CStatic
{
public:
	afx_msg void OnPaint();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams);
	afx_msg void OnNcPaint();

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CGridElement -- common base class for things in grids

class CGridElement
{
public:
	virtual ~CGridElement();
	
	void SetCapture();
	void ReleaseCapture();

	void Invalidate(BOOL bErase = FALSE, BOOL bInflate = FALSE);
	
	virtual CGridWnd* GetGrid() const = 0;
	virtual void Draw(CDC* pDC, const CRect& rect) = 0;
	virtual void GetRect(CRect& rect) = 0;
	virtual void ResetSize(CDC* pDC);
	virtual void OnSelect(BOOL bSelected);
	
	virtual CGridElement* ElementFromPoint(const CPoint& point);

	virtual BOOL OnLButtonDown(UINT nFlags, CPoint point);
	virtual BOOL OnLButtonDblClk(UINT nFlags, CPoint point);
	virtual BOOL OnLButtonUp(UINT nFlags, CPoint point);
	virtual BOOL OnMouseMove(UINT nFlags, CPoint point);
	
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual void OnControlNotify(UINT nControlID, UINT nNotification);
	virtual CGridRow* GetRow() const;

	BOOL m_bIsCell;
	BOOL m_bWasSelected;
};

/////////////////////////////////////////////////////////////////////////////
// CGridRow -- a row in a grid

class CGridRow : public CGridElement
{
public:
	CGridRow(CGridWnd* pGrid);
	~CGridRow();
	
	CGridWnd* GetGrid() const
		{ return m_pGrid; }
	
	int GetRowHeight() const
		{ return m_cyHeight; }

	virtual void GetRect(CRect& rowRect);
	virtual int Compare(const CGridRow* pCompareRow) const;
	
	virtual CSize GetCellSize(CDC* pDC, int nColumn) const;
	
	virtual void Draw(CDC* pDC, const CRect& rect);
	virtual void DrawCell(CDC* pDC, const CRect& rect, int nColumn) = 0;
	
protected:	
	CGridWnd* m_pGrid;
	int m_cyHeight;
	
	friend class CGridWnd;
};

/////////////////////////////////////////////////////////////////////////////
// CGridCell -- once cell in the grid; often sub-classed

class CGridCell : public CGridElement
{
public:
	CGridCell();
	
	virtual void Draw(CDC* pDC, const CRect& cellRect);
	
	virtual CGridRow* GetRow() const;
	
	CGridWnd* GetGrid() const
		{ return m_pRow->GetGrid(); }
	
	int GetColumnIndex() const
		{ return m_nColumn; }
	
	void Invalidate(BOOL bErase = FALSE);
	void GetRect(CRect& cellRect);
	CSize GetSize() const
		{ return m_size; }
	
	virtual void SetText(const char* szText);
	virtual void ResetSize(CDC* pDC);
	
	CSize m_size;
	CString m_str;
	CGridRow* m_pRow;
	int m_nColumn;
	UINT m_dt; // DrawText() format
};

/////////////////////////////////////////////////////////////////////////////
// CGridControlRow -- a row that supports edit and combo controls

enum GRID_CONTROL_TYPE { none, edit, editCombo, listCombo };

class CGridControlRow : public CGridRow
{
public:
	CGridControlRow(CGridWnd* pGrid);
	~CGridControlRow();
	
	BOOL CreateControl(GRID_CONTROL_TYPE controlType, int nColumn, DWORD dwStyle = 0);

	// Override to create specialized controls.
	virtual CEdit*  NewEdit( );
	virtual CComboBox* NewCombo( ); 
	virtual void AdjustControlRect ( GRID_CONTROL_TYPE, int nColumn, CRect& textRect);
		
	void GetColumnRect(int nColumn, CRect& rect);
	
	virtual void OnChangeColumnText(int nColumn, const char* szNewText);
	virtual BOOL OnAccept(CWnd* pControlWnd);

	virtual void GetColumnText(int nColumn, CString& str) = 0;
	virtual void AdjustForMargins(CRect& rect, int nColumn);
	virtual int GetNextControlColumn(int nColumn);
	virtual int GetPrevControlColumn(int nColumn);
	virtual void DrawCell(CDC* pDC, const CRect& cellRect, int nColumn);
	virtual void AddListItems(int nColumn, CComboBox* pComboBox);

// Implementation
	void OnControlNotify(UINT nControlID, UINT nNotification);
};

#define cxDefaultGridCellMargin 8
#define cyDefaultGridCellMargin 2

/////////////////////////////////////////////////////////////////////////////
// CGridCellRow -- a row of cells in a grid; rarely sub-classed

class CGridCellRow : public CGridRow
{
public:
	CGridCellRow(CGridWnd* pGrid);
	~CGridCellRow();
	
	CGridCell* GetCell(int nColumn) const
		{ return (CGridCell*)m_cells[nColumn]; }
	
	CSize GetCellSize(int nColumn) const
		{ return GetCell(nColumn)->GetSize(); }
	
	virtual void ResetSize(CDC* pDC);
	
	virtual int Compare(const CGridRow* pCompareRow) const;
	
	virtual BOOL CreateCells();
	virtual CGridElement* ElementFromPoint(const CPoint& point);
	virtual void DrawCell(CDC* pDC, const CRect& rect, int nColumn);

protected:	
	CPtrArray m_cells;
};


////////////////////////////////////////////////////////////////////////////
// CGridCaptionCell -- special row at the top of a grid; rarely subclassed

class CGridCaptionCell : public CGridCell
{
public:


	CGridCaptionCell(BOOL bDisplay);
	
	virtual void Draw(CDC* pDC, const CRect& cellRect);

	virtual BOOL OnLButtonDown(UINT nFlags, CPoint point);
	virtual BOOL OnLButtonDblClk(UINT nFlags, CPoint point);
	virtual BOOL OnLButtonUp(UINT nFlags, CPoint point);
	virtual BOOL OnMouseMove(UINT nFlags, CPoint point);
	virtual void ResetSize(CDC* pDC);

	void InvertResizeTracker(CDC* pDC = NULL);
	void SizeFromTracker();

	enum HitZone
	{
		none,
		resizeLeft,
		select,
		resizeRight
	};
	
	HitZone GetHitZone(const CPoint& point);
	
	HitZone m_trackZone; // are we tracking the mouse? why?
    BOOL m_bPressed : 1; // does the caption have that "depressed" look?
	BOOL m_bFixedWidth : 1; // is this column fixed width.
    int m_xSizeTracker; // where is the resize tracking line?
};


////////////////////////////////////////////////////////////////////////////
// CGridCaption -- special row at the top of a grid; rarely subclassed

class CGridCaption : public CGridCellRow
{
public:
	CGridCaption(CGridWnd* pGrid, BOOL bDisplay = TRUE);
	
	void GetRect(CRect& rowRect);
	
	int GetColumnWidth(int nColumn) const
		{ return GetCell(nColumn)->m_size.cx; }

	// If column is fixed width, resizing using the mouse is disallowed.
	BOOL IsColumnFixedWidth(int nColumn) const
		{ return ((CGridCaptionCell *)GetCell(nColumn))->m_bFixedWidth; }

	void SetColumnFixedWidth(int nColumn, BOOL bFixed = TRUE)
		{ ((CGridCaptionCell *)GetCell(nColumn))->m_bFixedWidth = !!bFixed; }
		
	virtual void ResetSize(CDC* pDC);
	BOOL m_bDisplay;
};


/////////////////////////////////////////////////////////////////////////////
// CGridWnd window

// ReplaceControl toolbar flags. T
// You may OR these
#define GRIDWND_TB_NOTOOLBAR    (0)
#define GRIDWND_TB_NEW		(0x0001) // New  button
#define GRIDWND_TB_DELETE	(0x0002) // Delete button
#define GRIDWND_TB_MOVE		(0x0004) // Move Buttons

#define GRIDWND_TB_NEWDEL	(GRIDWND_TB_NEW | GRIDWND_TB_DELETE) // New and Delete buttons
#define GRIDWND_TB_ALL		(GRIDWND_TB_NEW | GRIDWND_TB_DELETE | GRIDWND_TB_MOVE) // New. Delete, Moveup, MoveDown

class CGridWnd : public CWnd
{
	DECLARE_DYNAMIC(CGridWnd)
// Construction
public:
	CGridWnd(int nColumns, BOOL bDisplayCaption = TRUE );
	~CGridWnd();
	
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	BOOL CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	BOOL ReplaceControl(CWnd* pWnd, UINT nIDTemp, UINT nIDGrid, 
		DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP, 
		DWORD dwExStyle = WS_EX_CLIENTEDGE,
		DWORD dwTBStyle = GRIDWND_TB_NOTOOLBAR,
		BOOL bRemovePlaceholder = TRUE);
	

// Attributes
public:
	int GetRowCount() const
		{ return m_rows.GetCount() - 1; }
	
	int GetColumnCount() const
		{ return m_nColumnCount; }
		
	int GetColumnWidth(int nColumn) const
		{ return GetCaptionRow()->GetColumnWidth(nColumn); }

	CFont* GetFont () const 
	{	return m_pFont; }

	CFont* GetCaptionFont() const  
	{ return m_pCaptionFont ; }
	
	COLORREF GetWindowTextColor() const
	{ return (m_bSysDefaultColors) ? GetSysColor(COLOR_WINDOWTEXT) : m_colorWindowText; }

	COLORREF GetWindowColor() const
	{ return (m_bSysDefaultColors) ? GetSysColor(COLOR_WINDOW) : m_colorWindow; }
	
	COLORREF GetHighlightColor() const
	{ return (m_bSysDefaultColors) ? GetSysColor(COLOR_HIGHLIGHT) : m_colorHighlight; }
	
	COLORREF GetHighlightTextColor() const
	{ return (m_bSysDefaultColors) ? GetSysColor(COLOR_HIGHLIGHTTEXT) : m_colorHighlightText; }
			
	int ColumnFromX(int x);

// Operations
public:
	void SetColumnCaption(int nColumn, const char* szCaption);
	void SetColumnWidth(int nColumn, int cxWidth);
	void InvalidateColumn(int nColumn, BOOL bErase = FALSE);
	virtual void SortColumn(int nColumn, BOOL bReverse = FALSE);
	void ReSort();
	void SizeColumnToFit(int nColumn);
	CGridElement* ElementFromPoint(const CPoint& point);
	CGridCellRow* AddCellRow();
	virtual void AddRow(CGridRow* pRow, BOOL bRedraw = TRUE );
	virtual void RemoveRow(CGridRow* pRow, BOOL bRedraw = TRUE );
	void SetFont(CFont * pFont, BOOL bRedraw = TRUE );
	void SetCaptionFont( CFont * pFont, BOOL bRedraw = TRUE );
	void SetColor(COLORREF colorText, COLORREF colorBk, COLORREF colorHighlight,
					COLORREF colorHighlightText); 
	void EnableMultiSelect( BOOL fEnable = TRUE );
	void EnableAutoSort( BOOL bEnable = TRUE );
	void EnableSort(BOOL bEnable = TRUE);

// Overridables
	virtual BOOL BeginDrag(UINT nFlags, const CPoint& point); // return FALSE to drag select, TRUE for D&D
	virtual void DoDragDrop(CPoint point);
	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	virtual void AdjustDropRow(CGridRow* &rpDropRow);
	
// Implementation
public:
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
	
	void ResetSize();
	void ResetScrollBars();

// Row access...
	POSITION GetHeadRowPosition() const;
	
	CGridRow* GetNextRow(POSITION& pos) const
		{ return (CGridRow*)m_rows.GetNext(pos); }
	
	CGridRow* GetPrevRow(POSITION& pos) const
		{ return (CGridRow*)m_rows.GetPrev(pos); }
	
	CGridRow* GetRowAt(POSITION pos) const
		{ return (CGridRow*)m_rows.GetAt(pos); }
		
	CGridCellRow* GetCellRowAt(POSITION pos) const
		{ ASSERT(m_bHasCells); return (CGridCellRow*)m_rows.GetAt(pos); }
		
	CGridRow* GetRow(int nRow) const
		{ return  nRow == -1 ? NULL : (CGridRow*)m_rows.GetAt(m_rows.FindIndex(nRow + 1)); }
	
	CGridCaption* GetCaptionRow() const
		{ return (CGridCaption*)m_rows.GetHead(); }
	
// Selection iteration
	POSITION GetHeadSelPosition() const
		{ return m_selection.GetHeadPosition(); }
	
	CGridElement* GetNextSel(POSITION& pos) const
		{ return (CGridElement*)m_selection.GetNext(pos); }

		
	virtual void VScroll(int cyScroll);
	
	void ClearSelection();
	void ShowSelection(BOOL bShow = TRUE);
	void Select(CGridElement* pElement, BOOL bAdd = FALSE);
	void Deselect(CGridElement* pElement);
	void SelectBetween(CGridElement* pElement1, CGridElement* pElement2);
	void InvalidateSelection(CGridElement* pElement = NULL);
	BOOL IsSelected(CGridElement* pElement) const
		{ return m_selection.Find(pElement) != NULL; }
	BOOL LooksSelected(CGridElement* pElement) const
		{ return m_bShowSelection && IsSelected(pElement); };
	BOOL IsPrimary(CGridElement* pElement) const
		{ return !m_selection.IsEmpty() && m_selection.GetHead() == pElement; }
		
	void ScrollIntoView(CGridRow* pRow);
	
	void SetActiveElement(CGridElement* pElement, int nColumn = -1);
	virtual BOOL CloseActiveElement();

	void AdjustTopVisible();
	
	CPtrList m_rows;
	int m_nColumnCount;
	
	POSITION m_posTopVisibleRow; // first visible row
	int m_cyScroll; // number of pixels of first row scrolled off top
	
	CGridElement* m_pCaptureElement;
	
	POSITION m_posCurRow;
	int m_nCurColumn;
	CPtrList m_selection;
	CGridElement* m_pActiveElement;
	BOOL m_bShowSelection;
	
	int m_nSortColumn;
	BOOL m_bReverseSort;
	
	BOOL m_bHasCells;
	
	CFont* m_pFont ;  // Font to display normal text.
	CFont* m_pCaptionFont ; 

	// Color handling.
	COLORREF m_colorWindowText;
	COLORREF m_colorWindow;
	COLORREF m_colorHighlightText;
	COLORREF m_colorHighlight;
	BOOL	 m_bSysDefaultColors;

	BOOL m_bDragSelecting;
	CGridElement* m_pFirstSelect; // where the mouse went down for a drag-select
	CGridElement* m_pLastSelect;
	CGridRow* m_pDropRow;
	CRect m_rcDropInvalidate;
	BOOL m_bEnableEllipse;
	CButton m_Ellipse;

	BOOL m_fMultiSelect;	// TRUE if grid should support multiselect
	BOOL m_bAutoSort:1;			// TRUE if grid should resort after accepting an entry
	BOOL m_bShowContextPopup:1;
	BOOL m_bShowProperties:1;
	BOOL m_bDestruct:1; // TRUE while in the dtor
	BOOL m_bSort:1; 	// TRUE if the grid should support any kind of sorting.	
	BOOL m_bEnableDragRow:1;
	BOOL m_bDragRow:1;
	BOOL m_bBtnDownValid:1; // turned off by killfocus during lbuttondown processing

	BOOL m_bParentIsDialog;

	int m_cxSelectMargin;
	static CPoint c_LastClick;

private:
	CStaticVCenter	m_cstatVCenter; // for subclassing toolbar label drawing
	CGridToolBar* m_pToolBar;
	
public:	
	CStaticVCenter*	GetPwndGridLabel()	{ return &m_cstatVCenter; }
	CGridToolBar*	GetToolBar()	{ return m_pToolBar; }

	// Message map functions
protected:
	//{{AFX_MSG(CGridWnd)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnEnable(BOOL bEnable);

//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CGridControlWnd

class CGridControlWnd : public CGridWnd
{
	DECLARE_DYNAMIC(CGridControlWnd)
public:
	CGridControlWnd(int nColumns, BOOL bDisplayCaption = TRUE);
	~CGridControlWnd();
	
	GRID_CONTROL_TYPE m_controlType;
	CWnd* m_pControlWnd;
	int m_nControlColumn;

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void CGridControlWnd::CancelDrag(void);

	// Control handling
	virtual void ActivatePrevControl();
	virtual void ActivateNextControl();
	virtual void CancelControl();
	virtual BOOL AcceptControl(BOOL bDeactivate = TRUE);
	virtual BOOL CloseActiveElement();
	virtual BOOL FGridToolBarCmd(UINT nID, int nCode);


	virtual BOOL OnCmdMsg( UINT nID, int nCode, void *pExtra, AFX_CMDHANDLERINFO *pHandlerInfo );


protected:
	afx_msg void OnGridNew();			//  New button pressed 
	afx_msg void OnGridDelete();		//  Delete button pressed 
	afx_msg void OnGridMoveUp();		//  Move Up button pressed 
	afx_msg void OnGridMoveDown();		//  Move Down button pressed 
	afx_msg void OnDestroy();

	// Message map functions
protected:
	//{{AFX_MSG(CGridWnd)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnCut();
	afx_msg void OnCopy();
	afx_msg void OnPaste();
	afx_msg void OnClear();
	afx_msg void OnUndo();
	void OnUpdateCut(CCmdUI *pCmdUI);
	void OnUpdateCopy(CCmdUI *pCmdUI);
	void OnUpdatePaste(CCmdUI *pCmdUI);
	void OnUpdateClear(CCmdUI *pCmdUI);
	void OnUpdateUndo(CCmdUI *pCmdUI);
	void OnUpdateRedo(CCmdUI *pCmdUI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CStringListGridWnd

// Mode flags
#define GRIDLIST_MARGIN			0x0000
#define GRIDLIST_NOMARGIN		0x0001
#define GRIDLIST_ORDER			0x0000
#define GRIDLIST_NOORDER		0x0002
#define GRIDLIST_ADD			0x0000
#define GRIDLIST_NOADD			0x0004
#define GRIDLIST_DELETE			0x0000
#define GRIDLIST_NODELETE		0x0008
#define GRIDLIST_CHANGE			0x0000
#define GRIDLIST_NOCHANGE		0x0010
#define GRIDLIST_SINGLESEL		0x0000
#define GRIDLIST_MULTISEL		0x0020
#define GRIDLIST_NOELLIPSE		0x0000
#define GRIDLIST_ELLIPSE		0x0040
#define GRIDLIST_NEWSELONADD	0x0000
#define GRIDLIST_NONEWSELONADD	0x0080


#define GLN_SELCHANGE (4)
#define ON_SELCHANGE(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_SELCHANGE, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_ELLIPSE (5)
#define ON_ELLIPSE(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_ELLIPSE, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_SETFOCUS (6)
#define ON_SETFOCUS(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_SETFOCUS, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_KILLFOCUS (7)
#define ON_KILLFOCUS(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_KILLFOCUS, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_ADDSTRING (8)
#define ON_ADDSTRING(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_ADDSTRING, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_DELETESTRING (9)
#define ON_DELETESTRING(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_DELETESTRING, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_ACTIVATE_CTL (10)
#define ON_ACTIVATE_CTL(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_ACTIVATE_CTL, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

#define GLN_ACCEPT_CTL (11)
#define ON_ACCEPT_CTL(id, memberFxn) \
	{ WM_COMMAND, (WORD)GLN_ACCEPT_CTL, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

class CStringListGridWnd : public CGridControlWnd
{
// Construction
public:
	CStringListGridWnd(UINT nModeFlags = 0);

protected:

// Attributes
public:
	UINT m_nFlags;
	CSize m_sizeGlyph;
	class CStringListGridRow* GetNewRow()
		{ return m_pNewRow; }

// Operations
public:
	// Single-Selection operations
	int GetCount() const;
	int GetCurSel() const;
	BOOL SetCurSel(int nSelect);

	// Multiple-Selection operations
/* FUTURE: NYI
	int GetCaretIndex() const;
	BOOL SetCaretIndex(int nIndex, BOOL bScroll = TRUE);
*/
	BOOL SetSel(int nIndex, BOOL bSelect = TRUE);
	int GetSelCount() const;
	int GetSelItems(int nMaxItems, LPINT rgIndex) const;

	// String operations
	int AddString(LPCTSTR lpszItem);
	int DeleteString(int nIndex);
	int InsertString(int nIndex, LPCTSTR lpszItem);
	void ResetContent();

	// General operations
	BOOL GetText(int nIndex, CString& rString) const;
	BOOL SetText(int nIndex, LPCTSTR lpszNew);
	DWORD GetItemData(int nIndex) const;
	BOOL SetItemData(int nIndex, DWORD dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	BOOL SetItemDataPtr(int nIndex, void* pData);
	int GetItemGlyph(int nIndex) const;
	BOOL SetItemGlyph(int nIndex, int nGlyph);
	void SetGlyphSize(LONG cx, LONG cy);
	void SetRedraw(BOOL bRedraw);

// Overrides
protected:

	virtual BOOL OnChange(int nIndex);
	virtual BOOL OnAddString(int nIndex);
	virtual BOOL OnDeleteString(int nIndex);
	virtual BOOL OnMove(int nSrcIndex, int nDestIndex);

	virtual void DrawGlyph(CDC *pDC, int nGlyph, CPoint ptGlyph, DWORD dwRop);
	virtual void NewRow(CStringListGridRow*& rpRow);

protected:
	afx_msg void OnGridNew();			//  New button pressed 
	afx_msg void OnGridDelete();		//  Delete button pressed 
	afx_msg void OnGridMoveUp();		//  Move Up button pressed 
	afx_msg void OnGridMoveDown();		//  Move Down button pressed 

	void MoveUpDown(BOOL fMoveUp);


// Implementation
public:
	virtual ~CStringListGridWnd();

	int GetRowIndex(const CGridRow* pRow) const;
	CStringListGridRow* GetRow(int nIndex);
	const CStringListGridRow* GetRow(int nIndex) const;

	BOOL IsFlag(int nFlag) const
		{ return (m_nFlags & nFlag); }
	class CStringListGridRow* m_pNewRow;

	virtual void AddNewRow(BOOL bSelect = TRUE);
	friend class CStringListGridRow;

	virtual void DoDelete();
	virtual void DoMove(int nToIndex);

	virtual BOOL AcceptControl(BOOL bDeactivate = TRUE);
	virtual void DoDragDrop(CPoint point);
	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	virtual void AdjustDropRow(CGridRow* &rpDropRow);

	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg UINT OnGetDlgCode();
	DECLARE_MESSAGE_MAP()

	BOOL m_bRedraw;
	static BOOL c_bSelChangeFromCode;
};

typedef struct tagSORTABLEROW
{
	int m_nRow;
	CStringListGridRow* m_pRow;
} SORTABLEROW;

extern int CompareRowIDs(const void* p1, const void* p2);

////////////////////////////////////////////////////////////////////////////
// CStringListGridRow

class CStringListGridRow : public CGridControlRow
{
// Construction
public:
	CStringListGridRow(CGridWnd* pGrid);
	virtual ~CStringListGridRow();

// Attributes
public:
	CString m_str;
	DWORD m_dwUser;
	int m_nGlyph;
	BOOL IsNewRow()	{return (((CStringListGridWnd* )GetGrid())->GetNewRow() == this);}

	static BOOL AFX_DATA c_bIsMove;

// Overrides
public:
	virtual void GetColumnText(int nColumn, CString& rStr);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual BOOL OnAccept(CWnd* pControlWnd);
	virtual void OnSelect(BOOL bSelected);
	virtual void DrawCell(CDC* pDC, const CRect& cellRect, int nColumn);
	virtual void ResetSize(CDC* pDC);
	virtual CEdit* NewEdit();
};

/////////////////////////////////////////////////////////////////////////////
// CStringListGlyphGridWnd
class CStringListGlyphGridWnd : public CStringListGridWnd
{
// Construction
public:
	CStringListGlyphGridWnd(LONG cxGlyph, LONG cyGlyph, UINT nModeFlags = 0);

// Attributes
public:
	class CImageWell* m_pGlyphWell;

// Operations
public:
	BOOL LoadGlyphWell(UINT nIDWell);
	BOOL AttachGlyphWell(HBITMAP hWell);

// Overrides
protected:
	virtual void DrawGlyph(CDC *pDC, int nGlyph, CPoint ptGlyph, DWORD dwRop);

// Implementation
public:
	virtual ~CStringListGlyphGridWnd();
};


/////////////////////////////////////////////////////////////////////////////
//	Tree control
/////////////////////////////////////////////////////////////////////////////
// Values for CNode::m_nFlags
// CNode -- one entry in a CTreeCtl

// Specify packing becuase this gets used accross DLL's:
#pragma pack(4)
class CNode
{
public:
	CNode(DWORD dwData);
	virtual ~CNode();
	
	virtual CFont* GetFont() const;
	virtual int GetGlyphWidth();
	virtual int GetGlyphHeight();

	CNode* m_pParent;
	int m_nLevels;
	DWORD m_dwData;
	WORD m_nFlags;
	TCHAR* m_szText;
	int  m_nWidth;
	static int m_nGlyphWidth;
};
#pragma pack()

#define TF_LASTLEVELENTRY		0x0001
#define TF_HASCHILDREN			0x0002
#define TF_EXPANDED				0x0004
#define TF_DISABLED				0x0008
#define TF_EXPANDABLE			0x0020
#define TF_NOT_EXPANDABLE		0x0040
#define TF_DIRTY_CONTENT		0x0080
#define TF_DIRTY_ITEM			0x0010
#define TF_DROPTARGET           0x0100
#define TF_DRAGSOURCE           0x0200
#define TF_CHILD_SORT_ALPHA     0x0400
#define TF_CHILD_SORT_OVERRIDE  0x0800
#define TF_CHILD_SORT_NONE      0x1000

#define LIST_ALPHA_SEARCH_DELAY (1)


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTreeListBox item

class CTreeListBox : public CListBox
{
	DECLARE_DYNCREATE(CTreeListBox)

	CTreeListBox();

private:
	int ItemFromPoint(const CPoint& point);

	class CTreeCtl* m_pTree;
	BOOL m_bGotMouseDown : 1;
	BOOL m_bDeferedDeselection : 1;
	BOOL m_bStdMouse : 1;
	int m_nDeferedItem;
	int m_nLastItem;

	static int iSlobPixels;
	static CPoint mouseDownPt;

	friend class CTreeCtl;

protected:
	virtual BOOL 	PreTranslateMessage(MSG *pMsg);

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeListBox)
	afx_msg void OnLButtonDown(UINT, CPoint);
	afx_msg void OnLButtonUp(UINT, CPoint);
	afx_msg void OnLButtonDblClk(UINT, CPoint);
	afx_msg void OnRButtonUp(UINT, CPoint);
	afx_msg void OnRButtonDown(UINT, CPoint);
	afx_msg void OnMouseMove(UINT, CPoint);
	afx_msg void OnChar(UINT nChar, UINT nRepCount, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl window

class CTreeCtl : public CWnd
{
	DECLARE_DYNCREATE(CTreeCtl)
	DECLARE_MESSAGE_MAP()

// Construction
public:
	CTreeCtl(BOOL bIsMultiSelection = FALSE, BOOL bKeepSelectionRect = FALSE);
	
	BOOL PreCreateWindow(CREATESTRUCT& cs);

// Attributes
public:
	virtual void SetContextHelpID(DWORD dwContextHelpId);

protected:
	BOOL m_bIsMultiSelection : 1;	// Allow multiple selections;
	BOOL m_bKeepSelectionRect : 1;	// keep the selecton rect when not focus
	BOOL m_bEnableDragDrop : 1;
	BOOL m_bShowContextPopup : 1;
	BOOL m_bShowProperties : 1;
	BOOL m_bSortRootNodes : 1;		// are root nodes to be sorted alphabetically?
	BOOL m_bVertLineAction : 1;		// is action taken when vertical line clicked on?
	BOOL m_bPopupClippedText : 1;		// pop up full node text when clicked on?

	CTreeListBox *m_pListBox;	// our only child

	CSize m_sizeM;				// size of an "M" in the current font
								// used to determine horiz/vert tree bar dimensions

	int m_cyNode;				// height of one node in the list
	int m_cxExtent;				// approximate width of the whole list
	int m_cxOffset;				// horizontal offset for paints (used when a widget
								// scrollbar is used for a horizontal scroll bar)
	
	int m_EnableUpdates;		// Reference count of update holding;

	CString m_strSearch;		// typomatic search string
	time_t	m_timeLastKey;		// time since last typomatic key stroke

	int m_nLastParentIndex;		// used for cacheing next insertion point in unsorted tree portions
	int m_nNextInsertIndex;		// used for cacheing next insertion point in unsorted tree portions

// Operations
public:
	// expansion/contraction

	// override this method so that containment can be determined
	virtual BOOL NodeIsExpandable(CNode *);
	
	// *must* override this method so that the text of a node can be
	// determined through means other than the passed 'sz' arg to InsertNode
	// N.B. generally this is for the a node that was set dirty
	virtual void GetNodeTitle(CNode *, CString &);

	// This can be overriden if you want to display text different to that
	// specified as the 'sz' text. Unlike GetNodeTitle this method does
	// NOT alter the 'sz' text of the node.
	virtual void GetDisplayText(CNode *, CString &);

	// expand/collapse a node (referenced by index)
	void Expand(int nIndex = -1, BOOL bWholeBranch = FALSE);
	void Collapse(int nIndex = -1);
	void Refresh(int nIndex = -1);
	void RefreshAllRoots();

	// expand all nodes (full-expansion)
	void ExpandAll();

	// is a particular node expanded?
	// override this if you want to determine expandedness another way.
	virtual BOOL IsExpanded(int nIndex = -1);
	
	// does a particular node have children?
	// override this if you want to determine child presence another way.
	virtual BOOL HasChildren(int nIndex = -1);

	// get/set the node dwData (referenced by index)
	DWORD GetData(int nIndex = -1);
	void SetData(int nIndex, DWORD dwData);

	// get/set the current selection
	int GetCurSel() { return m_pListBox->GetCurSel(); }
	void SetCurSel(int nIndex) { m_pListBox->SetCurSel(nIndex); }
	virtual void KeySetSel(int nIndex, BOOL bClearSearchBuffer = TRUE);

	// get/set the current selection if multi-select is on
	int GetCount() { return m_pListBox->GetCount(); }
	int GetSelCount() { return m_pListBox->GetSelCount(); }
	int GetSelItems(int nMaxItems, LPINT rgItems) { return m_pListBox->GetSelItems(nMaxItems, rgItems); }
	int SetSel(int nIndex, BOOL bSelect = TRUE) { return m_pListBox->SetSel(nIndex, bSelect); }
	void SelectAll()
		{ SetSel(-1, TRUE); }

	// our tree-control node modification functions
	int FindNode(DWORD dwData);
	int FindNode(const TCHAR * szText, DWORD & dwData, BOOL fMatchCase = FALSE);
	int InsertNode(int iParentNode, const char* szName, DWORD dwData);
	void DirtyNode(int iNode, WORD, BOOL bInvalItem = TRUE);	// where the 2nd arg. is TF_DIRTY_???
	void ClearNode(int iNode, WORD, BOOL bInvalItem = TRUE);	// where the 2nd arg. is TF_DIRTY_???
	void RemoveNode(int iNode, BOOL bUpdateSel = TRUE);

	virtual void RecalcHorizontalExtent();
	void ClearSearchBuffer();
	
	int ItemFromPoint(const CPoint& point)
		{ return m_pListBox->ItemFromPoint(point); }

	int GetItemRect(int nItem, LPRECT lpRect)
		{ return m_pListBox->GetItemRect(nItem, lpRect); }

	virtual void CreateListBox()
		{ m_pListBox = new CTreeListBox; }

	virtual CListBox* GetListBox()
		{ return m_pListBox; }
		
	int GetItemHeight() const
		{ return m_cyNode; }
		
	int GetHorzExtent() const
		{ return m_cxExtent; }
		
	void SetHorzExtent(int nExtent)
		{ m_cxExtent = nExtent; }
		
	int GetHorzOffset() const
		{ return m_cxOffset; }

	void SetHorzOffset(int nOffset)
		{ m_cxOffset = nOffset; }

	CSize GetSizeM() const
		{ return m_sizeM; }

	BOOL PopsUpClippedText()
		{ return m_bPopupClippedText; }

	enum HIT_ZONE { left, vertline, expand, glyph, text, right };
	
	HIT_ZONE HitTest(int nItem, int x);
	
	// override these methods to support your own actions for the user input

	virtual void DoOpenItem(int nIndex);			// called on click on +/- glyphs
	virtual void OnOpen(int nIndex);				// called on Enter key or double-click
	virtual void OnSelect(int nIndex);				// called on selection change

	virtual BOOL OnKeyDown(UINT nChar);				// called on any Keydown msg
	virtual BOOL OnChar(UINT nChar);					// called on any Char msg

	// specific key handlers
	void OnPrimary();
	void OnExpand();
	void OnExpandBranch();
	void OnExpandAll();
	void OnCollapse();
	
	virtual void OnRightButtonUp(UINT, CPoint);		// called on right mouse button up
	virtual void OnRightButtonDown(UINT, CPoint);	// called on right mouse button down
	
// Implementation
public:
	virtual ~CTreeCtl();
	void FreeAllTreeData();
	
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual BOOL InsertLevel(CNode* pNode, int nIndex, BOOL bExpandAll = FALSE);
	virtual void DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt);
	
	BOOL InsertNode(CNode* pParentNode, int iParentNode, const char* szName,
					DWORD dwData, CNode*& rpNodeRet, int& riNodeRet, BOOL bUseNodeRet = FALSE);
	virtual void Collapse(CNode* pNode, int nIndex);
	void Refresh(CNode* pNode, int nIndex);
    CNode* GetNode(int nIndex = -1);
    void ResetSizes(CDC* pDC);
    void InvalSelection();
    void InvalItem(int nItem);

	int  GetMaxItemExent () { return m_cxExtent; };

	// For save/loading expanded state:
	BYTE* GetInitData();
	void ReadInitData(CPartFrame *pFrame);
	void SizeViewToTree(CPartFrame *pFrame);

	void HoldUpdates ();
	void EnableUpdates ();

	virtual int CompareData(const CNode* pNode1, const CNode* pNode2);
	int CompareNodes(const CNode* pNode1, const CNode* pNode2);

	virtual CNode* CreateNode(DWORD dwData);
	virtual void DeleteNode(CNode* pNode);

	virtual void BeginDragDrop();

	// Generated message map functions

protected:
	//{{AFX_MSG(CTreeCtl)
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	afx_msg void OnLbDblClk();
	afx_msg void OnLbSelChange();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	
	static CImageWell c_imageWell;
	static int c_cyBorder;		// SM_CYBORDER
	static int c_cyBorderX2;	// SM_CYBORDER * 2
	
	friend class CTreeListBox;
};

#define IDCW_TREELISTBOX	1 // child id for listbox


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Check listbox
//
// A CCheckList is a listbox with a checkbox to the left of each item.
// The user interface is exactly the same as a listbox with these
// exceptions:
//
//     * Left mouse button clicks (or double clicks) on the checkbox
//       part of an item toggle the check state.
//     * Pressing the spacebar when an item is selected will toggle
//       the check state of that item.
//     * For multi-sel listbox's, the spacebar will cycle through the
//       four state combinations (unselected-unchecked, selected-unchecked,
//       unselected-checked, selected-checked).
//
// These controls may be created explicitly with Create(), or existing
// listbox windows may be "subclassed" with SubclassDlgItem().
//
// When creating one of these (or specifying one in a dialog template)
// make sure the LBS_OWNERDRAWFIXED and LBS_HASSTRINGS styles are set.
//
// The class supports different sized fonts and will ensure that items
// are tall enough to contain both the box and the text.  The font may
// be changed dynamically.
//
// The default implementation uses the item data to store the state
// of the checkbox.  If the item data is needed for some other purpose,
// the SetCheck() and GetCheck() functions should be overrided to
// use an alternate storage location.

#define CLN_CHKCHANGE (20)
#define ON_CLN_CHKCHANGE(id, memberFxn) \
	{ WM_COMMAND, (WORD)CLN_CHKCHANGE, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

class CCheckList : public CListBox
{
// Construction
public:
	CCheckList();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
public:
	virtual BOOL IsTriState(int nItem) {return FALSE;}
	// nCheck -
	// 0 = unchecked
	// 1 = checked
	// 2 = undeterminate
	virtual void SetCheck(int nItem, int nCheck);
	virtual int GetCheck(int nItem);

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);

// Implementation
protected:
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void MeasureItem(LPMEASUREITEMSTRUCT lpmis);
	void InvalidateCheck(int nItem);
	void ResetItemHeight();

	virtual void ItemStringOut (CDC * pDC, const CString& strOut, const CRect& rect);
	
	int m_cyItem;	// Height of item including check box
	int m_cyText;	// Height of text only
	static CBitmap c_checkBitmap;
	static CSize c_checkSize;

	// Message map functions
protected:
	//{{AFX_MSG(CCheckList)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

	virtual void GetDisplayText(int index, CDC *pDC, const CRect&, CString& strOut);
};

/////////////////////////////////////////////////////////////////////////////
// CPropCheckList window - a check-list that can show/set property values

class CPropCheckList : public CCheckList
{
public:
	virtual void OnPropChanged(UINT nIDProp);

	// add an association between item text and property to the list
	int AddItem(const char* szId, UINT nIDProp);

	// which CSlob do the properties in this list belong to?
	inline void SetSlob(CSlob* pSlob) {m_pSlob = pSlob;}

protected:
	// provide property processing
	virtual BOOL IsTriState(int);
	virtual void SetCheck(int, int);
	virtual int GetCheck(int);

private:
	CSlob * m_pSlob;
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Icon listbox

class CIconList : public CListBox
{
// Attributes
public:
	virtual void SetIcon(int nItem, HICON hIcon);
	virtual HICON GetIcon(int nItem);

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);

// Implementation
protected:
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void MeasureItem(LPMEASUREITEMSTRUCT lpmis);
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Menu button

class CMenuBtn : public C3dBitmapButton
{
// Construction
public:
	CMenuBtn();

	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
	void SetPopup(POPDESC* ppop);
	BOOL LoadMenu(UINT idMenuResource);
	void SetPos(int pos);

// Attributes
public:
	union
	{
		CContextPopupMenu *m_pTraditionalMenu;
		CBContextPopupMenu *m_pNewMenu;
	};
	BOOL m_bUseTraditional;

	// parent of menu for command routing purposes
	CWnd *m_pMenuParent;
	HWND m_hLastActive;

// Operations
public:
	void ShowMenu();
	void ShowMenu(CContextPopupMenu &menuPopup);
	void ShowMenu(CBContextPopupMenu &menuPopup);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMenuBtn)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMenuBtn();
protected:
	BOOL m_bMenuShown;
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	BOOL DrawBitmaps();

	// Generated message map functions
protected:
	virtual HBITMAP CreateButtonBitmap(UINT nStyle,  LPCRECT lpRect,
		CBitmap* pbmGlyph = NULL, LPCTSTR lpszText = NULL);

	//{{AFX_MSG(CMenuBtn)
		// NOTE - the ClassWizard will add and remove member functions here.
		afx_msg LRESULT OnShowMenu(WPARAM wParam, LPARAM lParam);
		afx_msg void OnClicked();
		afx_msg void OnSetFocus(CWnd *pOldWnd);
		afx_msg void OnLButtonUp(UINT n1, CPoint pt);
		afx_msg void OnSysColorChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Tabbed scrollbar

class CWidgetScrollBar : public CWnd
{
// Construction
public:
	CWidgetScrollBar(BOOL bAlwaysShowScrollBar = FALSE);

// Attributes
public:
	BOOL IsScrollBarVisible() const
	{
		return m_bShowScrollBar;
	}

	void AlwaysShowScrollBar(BOOL bShow)
	{
		if (m_bAlwaysShowScrollBar != bShow)
		{
			m_bAlwaysShowScrollBar = bShow;
			Invalidate();
		}
	}

protected:
	enum HIT_ZONE { none, left, right, splitter, firstTab };

	class CWidgetTab
	{
	public:
		CString m_str;
		DWORD m_dwUser;
		int m_cxWidth;
	};

	BOOL m_bShowScrollBar;
	BOOL m_bAlwaysShowScrollBar;
	int m_nWidgetWidth;
	CPtrList m_tabs;
	HIT_ZONE m_captureZone;
	BOOL m_bButtonIn;
	int m_xScrollPos;
	int m_cxScrollExtent;
	int m_nActiveTab;
	int m_nSplitterPref;

	CScrollBar m_scrollBar;

	static int c_cyBitmap;
	static CBitmap c_bmpArrows;
	static CBitmap c_bmpDividers;

// Operations
public:
	void SetSplitterPos(int xPos);
	void AddTab(const char* szCaption, DWORD dwUser = 0, BOOL bAdjustSplitter = FALSE);
	void AddTabAt(int nPosition, const char* szCaption, DWORD dwUser = 0, BOOL bAdjustSplitter = FALSE);
	void RemoveTab(int nTab);
	void ChangeTabCaption(int nTab, const char* szNewCaption);
	void ActivateTab(int nTab);
	int FindTab(DWORD dwUser);
	void ResetTabs();
	int GetActiveTab()
		{ return m_nActiveTab; }
	DWORD GetTabData(int nTab);
	void UpdateDividerBitmap(int cy, BOOL bForce = FALSE);
	void DrawDivider(CDC* pDC, int nImage, const CPoint& pt);

// Implementation
public:
	virtual ~CWidgetScrollBar();

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	void RecalcLayout();

	HIT_ZONE HitTest(CPoint point);
	void GetTabRect(int nTab, CRect& rect);
	void Scroll(int cxScroll);
	
	void SetSplitterPref(int nPos)
		{ m_nSplitterPref = nPos; }
	int GetSplitterPref() const
		{ return m_nSplitterPref; }

	// Generated message map functions
protected:
	//{{AFX_MSG(CWidgetScrollBar)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSysColorChange();
	afx_msg void OnWinIniChange(LPCSTR lpszSection);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// __UTILCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\shlsrvc.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLSRVC.H
//		Various services provided by the shell.

#ifndef __SHLSRVC_H__
#define __SHLSRVC_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#ifndef __SHLBAR_H__
#include "shlbar.h"
#endif

#ifndef __AFXCMN_H__
#include "afxcmn.h"
#endif

//////////////////////////////////////////////////////////////////////////
// Header files which need to be merged with shlsrvc.h

#include "filechng.h"
#include "fmtinfo.h"
#include "spawner.h"

//////////////////////////////////////////////////////////////////////////

class CPartView;

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

//////////////////////////////////////////////////////////////////////////
// Status Bar API

void ShowStatusBar(BOOL bShow = TRUE);
BOOL IsStatusBarVisible();
BOOL IsStatusBarIndicator(UINT nID);
int  GetStatusBarHeight();
void InvalidateStatusBar(BOOL bErase = FALSE);
void ClearStatusBarSize();
void ClearStatusBarPosition();
void ClearStatusBarPositionAndSize();
void ResetStatusBar();
void SetStatusBarPosition(const CPoint& pos);
void SetStatusBarSize(const CSize& size);
void SetStatusBarPositionAndSize(const CRect& rect);
void SetStatusBarZoom(int zoom);
void SetStatusBarLineColumn(int line, int column, BOOL fForce = FALSE);
void SetStatusBarOffsetExtent(long lOffset, long lExtent);
void SetStatusBarOverStrike(BOOL bOverStrike);
void SetPrompt(const char*, BOOL bRedrawNow = FALSE,
               COLORREF textColor = 0, COLORREF bkColor = 0);
void SetPrompt(UINT ids = AFX_IDS_IDLEMESSAGE, BOOL bRedrawNow = FALSE,
               COLORREF textColor = 0, COLORREF bkColor = 0);
void SetScrollingPrompt(const char*, BOOL bRedrawNow = FALSE,
               COLORREF textColor = 0, COLORREF bkColor = 0);
void SetIdlePrompt(const char*, BOOL bRedrawNow = FALSE);
void SetIdlePrompt(UINT ids = AFX_IDS_IDLEMESSAGE, BOOL bRedrawNow = FALSE);
void SetPromptUntilIdle(const char* szMessage, COLORREF textColor = 0, COLORREF bkColor = 0);
BOOL IsPromptSetUntilIdle(void);

void StatusBeginPercentDone(const char* szPrompt);
void StatusEndPercentDone();
void StatusPercentDone(int percentDone);
void StatusOnIdle();

/////////////////////////////////////////////////////////////////////////////
// CSushiBarInfo
//

typedef struct tagSTATINFO
{
	UINT nID;
	int nGroup;
	int nBitmap;
} STATINFO;

class CSushiBarInfo : public CObject
{
public:
	CSushiBarInfo(const UINT FAR* pIndicators = NULL, int cIndicators = 0,
	              STATINFO FAR* pBitmaps = NULL, int cBitmaps = 0);

	const UINT FAR* m_pIndicators;
	int m_cIndicators;

	STATINFO FAR* m_pBitmaps;
	int m_cBitmaps;
};


/////////////////////////////////////////////////////////////////////////////
// Standard font handling

enum FontType
{
	font_Normal,			// MS Sans Serif 8, MS SVbN 10, System 10
	font_Bold,
	font_Italic,
		
	font_Small,				// Small Fonts (-9), Terminal (-9), Terminal (-9)
	font_SmallBold,
	font_SmallItalic,
		
	font_Fixed,				// Courier (14), FixedSys (14), FixedSys (14)
	font_FixedBold,
	font_FixedItalic,
	
	font_Large,             // MS Sans Serif 14. MS Sans Serif 14, MS Sans Serif 14,
	font_LargeBold,
	font_LargeItalic,

	font_count				// Not a font, just provides a count
};

CFont* GetStdFont(const int iType);

// NOTE: The LOGFONT returned by this is temporary
const LOGFONT* GetStdLogfont(const int iType, CDC *pDC = NULL);
void GetStdFontInfo(int iType, CString& strFace, int& ptSize);

////////////////////////////////////////////////////////////////////////////
//	Help

enum EOpenURLOption{ eIVOnly = 0, eHonorIVOption, eExternalOnly };
void GetHelpDir(CString & strHelpDir);
void OpenURL( CString& strURL, EOpenURLOption eURLOpt = eHonorIVOption);

///////////////////////////////////////////////////////////////////////////////
//	Find  and replace

#define FDS_WHOLEWORD	0x00000001
#define FDS_MATCHCASE	0x00000002
#define FDS_REGEXP		0x00000004
#define FDS_MARKALL		0x00000008
#define FDS_SEARCHALL	0x00000010

#define LIMIT_FIND_COMBO_TEXT 250	// Magic number based on line length limit.

//Find/Replace : Type of pick list
typedef enum { reZibo, reUnix, reBrief, reEpsilon } reSyntax;

extern reSyntax g_reCurrentSyntax;

//Find/Replace : Structure Definition (saved on disk)
struct patType;

// TODO(CFlaat): split the cursed FINDREPLACEDISK structure into two parts, one for global
//    find options and another to represent options for an individual find operation

struct FINDREPLACEDISK
{
	patType *pat;					// Compiled regular expression
	BOOL regExpr;					//Regular expression

	void DisposeOfPattern(void);
	BOOL CompileRegEx(reSyntax syntax);

	BOOL matchCase;					//Match Upper/Lower case
	BOOL bWasLineMatch;  // whether the last regex search was a BOL or EOL match
	BOOL wholeWord;
	BOOL goUp;						// Search direction
	BOOL loop;						// Loop when reaches the end (equivalent to NOT search all open documents)
	BOOL startFromCursor;			// start from cursor or from the beginning
									// (or from the end if going backwards)

	char findWhat[LIMIT_FIND_COMBO_TEXT + 1];		//Input string
	char replaceWith[LIMIT_FIND_COMBO_TEXT + 1];	//Output string
	int nbReplaced;							//Actual number of replacements

	//Construction
	FINDREPLACEDISK();
	~FINDREPLACEDISK();
};

extern FINDREPLACEDISK AFX_DATA findReplace;

enum PickListType { FIND_PICK = 0, REPLACE_PICK = 1 };
enum { MAX_PICK_LIST = 16 };

// the CPickList class tracks previous search strings employed by the user (via both UI and automation)

class CPickList
{
protected:

	int nbInPick[REPLACE_PICK + 1];			//Number of strings in picklist
	LPTSTR aaszPickList[REPLACE_PICK + 1][MAX_PICK_LIST]; //PickList for old search strings

	void AllocateEntry(PickListType type, UINT iIndex);
	void DeallocateEntry(PickListType type, UINT iIndex);

public:

	CPickList(void);
	~CPickList(void);

	int GetEntryCount(PickListType type) { return nbInPick[type]; }

	BOOL InsertEntry(PickListType type, LPCTSTR szText);
	BOOL InsertEntry(PickListType type, FINDREPLACEDISK *pfr);
	void RemoveEntry(PickListType type);

	LPTSTR GetEntry(PickListType type, UINT iIndex)
		{
			ASSERT(iIndex >= 0); ASSERT(iIndex < MAX_PICK_LIST);
			return aaszPickList[type][iIndex]; 
		}

	void LoadFromRegistry(FINDREPLACEDISK *pfr);
	void SaveToRegistry(void);
};

CPickList &ShellPickList();

void SetFindFocus();
void UpdateFindCombos();
BOOL IsFindComboActive();

// SetRegExprSyntax: Allow a package to change the default syntax
//  for regular expression searches in response to user input.
//  Valid syntaxes are: reUnix, reBrief, reEpsilon
//  Default syntax is reUnix.
BOOL SetRegExprSyntax(reSyntax _reSyntax);

// GetRegExprSyntax: Allow a package to determine the default syntax
//  for regular expression searches in response to user input.
//  Valid syntaxes are: reUnix, reBrief, reEpsilon
reSyntax GetRegExprSyntax(void);

/*
	GetCurrentRegexHintTable

	This function returns an array of regex hint->string mappings for
	the current editor emulation.  In the future we should use a safer
	means for doing this.
*/
LPCTSTR *GetCurrentRegexHintTable(void);

typedef char flagType;
// RECompile: regular expression compiler. Returns a compiled expression
// that must be freed by the caller. The returned expression can
// then be used as an argument to RESearch or you can set the 'pat'
// member of a FINDREPLACEDISK struct that is passed to FindInString(...)
patType *RECompile(char *szRegExpr, flagType fCase, reSyntax);

// RESEarch: performs a Regular expression search
BOOL RESearch(
	LPCTSTR line,
	ULONG *ichStart,	// byte index into line
	ULONG *xEnd,
	patType *pat,		// pointer to reg expression
	LPCTSTR szString,
	/* out */ BOOL *pbLineMatch);
char			 RETranslate (struct patType *,char *,char *);
int			 RETranslateLength (struct patType *,char *);

/////////////////////////////////////////////////////////////////////////////
//
// Text pattern recognition routines
//

// don't hittest
#define NO_HITTEST ULONG_MAX

//////////////////////////////////////////////////////////////////////////
// FREMatchAt
//
// Find regular expression in sz, starting from ibStart
//

BOOL FREMatch(
	/* IN     */ LPCTSTR sz,       // string to search
	/* IN     */ LPCTSTR szPat,    // Regular expression to find
	/* IN/OUT */ ULONG & ibStart,  // starting index (IN) start of match (OUT)
	/*    OUT */ ULONG & ibEnd     // end of match (noninclusive)
	);

//////////////////////////////////////////////////////////////////////////
// FFindURL
//
// Find URL in sz, starting from ibStart, that contains position ibAt.
// When ibAt is NO_HITTEST, finds the first URL in sz, starting from ibStart
//
// Returns:
//
//   TRUE if [intersecting] URL found.
//
// Example:
//
//     0123456789_123456789_12345678
//    "  HTTP://www.microsoft.com  "
//
//   Returns (TRUE): 
//     ibStart       =  2
//     ibEndProtocol =  7
//     ibEnd         = 26

BOOL FFindURL(
	/* IN     */ LPCTSTR sz,              // string to search
	/* IN     */ ULONG   ibAt,            // index to intersect, or NO_HITTEST to find first match
	/* IN/OUT */ ULONG & ibStart,         // starting index (IN) start of URL (OUT)
	/*    OUT */ ULONG & ibEndProtocol,   // end of URL protocol/scheme
	/*    OUT */ ULONG & ibEnd            // end of URL (noninclusive)
	);

/////////////////////////////////////////////////////////////////////////////
//	Goto
//		The following two class definitions provide goto support, generally
//		available to all packages.

class CGoToItem;
class CGotoDialog;

enum GOTO_TYPE {goGoTo, goNext, goPrevious};
#define dwItemDataInvalid ((DWORD)(-1))

// CGoToDialog dialog

class CGoToDialog : public C3dDialog
{
	DECLARE_DYNAMIC(CGoToDialog)

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	// Construction
	CGoToDialog(UINT idHelp, LPCTSTR szItemInit, CWnd* pParent = NULL);   // constructor
    ~CGoToDialog();
	
	// call this from CPackage:AddGoToItems for each item to add (editor-
	// specific items should be added even if the right kind of editor 
	// is not currently added.
	void AddItem(CGoToItem *pItemNew);

	// call this from the CGoToItem callbacks to change the style of buttons
	// being used. (This must be called from CGoToItem::OnSelectWhat at the very least!)
	enum BUTTON_STYLE { bsGoTo, bsNextPrev };
	void SetButtonStyle (BUTTON_STYLE buttonstyle);

	// call this from the CGoToItem callbacks to change the style of selection control
	// being used. (This must be called from CGoToItem::OnSelectWhat at the very least!)
	enum CONTROL_STYLE { csUninit = -1, csEdit, csDropList, csDropCombo, csNone };
	void SetControlStyle (CONTROL_STYLE controlstyle);
	 
	// call this to change the selection prompt. (This must be called from 
	// CGoToItem::OnSelectWhat at the very least!)
	void SetPrompt (const TCHAR * szPrompt);
	 
	// call this to change the helper text. If not called from 
	// CGoToItem::OnSelectWhat it will be blank by default.
	void SetHelperText (const TCHAR * szHelperText);

	// call this to enable or disable dialog controls depending on whether the item
	// can be active besed on the active editor. This is called internally after
	// CGoToItem::CanGoViewActive is called. Ignored if pGoToItem is not the current
	// selection in the Go To What list.
	void SetItemEnabled(CGoToItem *pGoToItem, BOOL fEnabledItem);

	// call this to empty the selection list when csDropList or csDropCombo are used.
	void EmptyList ();

	// call this to add a string to the selection list
	void AddString (const TCHAR * szSelect, DWORD dwItemData = 0);

	// call this to lock/unlock the selection list when csDropList or csDropCombo are used.
	// while the control is being filled.
	void LockList (BOOL fLock = TRUE);

	// call this to get the dialog id of the "selection control" in the rara
	// case when the List and Select functions are not adequate
	// pcs will be set to the control style of the control, since it can be
	// either and edit control . a combo or a list box. Use GetDlgItem to 
	// get a pointer to the selection control.
	int IdCtlSelection (CONTROL_STYLE *pcs);

	// call one of these to initialize the current selection control
	void Select (const TCHAR * szSelect);
	void Select (int iSelect);

	// call this when a CGoToItem::OnSelectChange needs to change the button state
	// OR the msk values into grfButton to set the state of one or more buttons
	#define mskButtonGoToNext	(0x0001)
	#define mskButtonPrevious	(0x0002)
	#define mskButtonClose		(0x0004)
	#define mskButtonHelp		(0x0008)

	void EnableButton (WORD grfButton, BOOL fEnable = TRUE);

// Dialog Data
	//{{AFX_DATA(CGoToDialog)
	enum { IDD = IDD_GOTODIALOG };
	CComboBox	m_gotoCombo;
	CStatic	m_helpText;
	CStatic	m_gotoCaption;
	CListBox	m_gotoWhat;
	CListBox	m_gotoList;
	CEdit	m_gotoEdit;
	//}}AFX_DATA

public:
	CPartView* m_pActiveView;  // reset when gotowhat selection changes and after OnGoTo

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGoToDialog)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CToolTipCtrl m_tooltip;

//	void OnOK( void );
	void OnCancel( void );	

// Implementation
public:
	virtual void PostNcDestroy();
	virtual BOOL OnHelpInfo(HELPINFO* pInfo); 

public:
	// static member!
	static CGoToDialog * c_pGotodialog; // used to prevent multiple instances of modeless dialog
	static CGoToDialog * PGoToDialogCur();   // returns c_pGotodialog
	BOOL m_fInInitDialog;  // true only while initdialog processing. Some items behave differently in that case
	CToggleBitmapButton	m_btnPushPin;  // subclassed via Autoload call
	void GotoCtlSel();

private:
	CWnd * m_pctlSelection;  // pointer to current edit, list or combo used to select destination
	CONTROL_STYLE m_csSelection;
	CGoToItem * m_pGoToItemCur;
	BUTTON_STYLE m_bsCur;
	CString m_strItemInit;  // item string to select in goto what list at startup
	// cLock... is a sentinal so the modeless dialog can reset up itself when you click away from the dialog
	// but do not reselect when the dialog loses focus for errors/asserts etc
	int m_cLockSelectAtActivate; // counter (for nesting). If non-zero, do not reselect when dialog is activated.
	int m_cBusyNoClose; // counter (for nesting). If non-zero, disallow closing dialog since goto operation still in progress.
	BOOL m_fFirstMoveMsg;
	BOOL m_fForcePinForHelp;

private:
	void GetSelectData(CString &strData, 
			DWORD *pdwItemData, 
			int *pidSelect,
			BOOL *pfSelInList,
			BOOL fComboSelChanged); 

	void OnOKPrevious(GOTO_TYPE go); 
	BOOL DoInitDialog(void);
	void DoSelchangeGoToWhat(); 

protected:
	// Generated message map functions
	//{{AFX_MSG(CGoToDialog)
	afx_msg void OnSelchangeGoToList();
	afx_msg void OnSelchangeGoToWhat();
	afx_msg void OnSelchangeGoToCombo();
	afx_msg void OnPrevious();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeGoToEdit();
	afx_msg void OnEditchangeGoToCombo();
	afx_msg void OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized);
	afx_msg void OnMove(int cx, int cy);
	afx_msg void OnGotoGotoAndNext();
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// CGoToItem
//  subclassed in each package that adds an entry to the Go To What listbox
//  in a CGoToDialog dialog

class CGoToItem 
{
public:
	CGoToItem(CGoToDialog * pDlg);

	// ***Initialization. These functions are used to initialize the Go To 
	// dialog. THey will be called when the dialog is invoked but may
	// actually be called at any time.

	// REQUIRED: Return the string to show in the Go To What listbox

	virtual const TCHAR * GetItemString() = 0;

	// ***Callbacks. These functions are called as the user manipulates the Go To
	// dialog or active editor view

	// Called when the item is selected in the Go To What listbox,
	// and at CGoToDialog startup and reactivation.
	// CGoToDialog will call CanGoViewActive after returning from this
	// call, so let it handle situational enabling/disabling

	// Note that this function needs to be able to tolerate a NULL m_pDlg->m_pActiveView
	// or one of the incorrect type. It should set what it can and leave other controls empty.

	// Do not put up error messages or dialogs during this function, as it can be called when focus
	// is changing. If you need to check a state that might bring up such a message it would be better
	// to enable the goto button and check at CanGoTo or OnGoTo rather than doing it here

	virtual void OnSelectWhat();

	// Called when the active editor changes. A FALSE return indicates that the
	// item should not be enabled in the dialog for this editor, TRUE indicates
	// that the item may be active in this editor view.

	virtual BOOL CanGoViewActive(CPartView* pActiveView);

	// Called when the selection control changes (either the user changed
	// the text in the edit control or they selected something from the
	// drop list). For csEdit style selection controls, the fSelInList
	// and dwItemData parameters should be ignored (FALSE/-1 will always 
	// be passed here).
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// generally used for simple test like handling empty strings

	virtual void OnSelectChange	(const TCHAR * szSelect, 
								BOOL fSelInList,
								DWORD dwItemData);

	// Override this to indicate whether or not a go to operation can be
	// attempted. Done when an action button is hit.
	// For goNext and goPrevious operations, the szSelect 
	// and dwItemData items are not used.
	// For goGoTo operations, they describe the string and optional
	// user-data selected in the Go To dialog.
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// pDlg and idDlgItemError are used to return focus to in case of error

	virtual BOOL CanGoTo(int idDlgItemError, 
						GOTO_TYPE go, 
						const TCHAR * szSelect, 
						BOOL fSelInList,
						DWORD dwItemData);


	// Override this to handle a go to operation. For goNext and goPrevious
	// operations, the szSelect and iSelList, and dwItemData items are not used. For goGoTo
	// operations, they describe the string and optional listbox user-data
	// selected in the Go To dialog, and the list selection, if any.
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	virtual void OnGoTo(GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);

public:
	CGoToDialog *m_pDlg; // set during construction
};

void DoGoToDialog(int iddHelp, LPCTSTR szItemInit);

/////////////////////////////////////////////////////////////////////////////
//	Dockable Windows support

/////////////////////////////////////////////////////////////////////////////
// Dock IDs
#define IDDW_SHELL_BASE         0x7000
// This range reserved for shell.
#define IDDW_SHELL_MAX			(IDDW_SHELL_BASE + 0x00FF)

#define IDDW_PACKAGE_BASE		(IDDW_SHELL_MAX + 1)
// Package defines actually used in the shell for things like hiding the
// output and topic windows when the Esc key is pressed.  Do not add to these.
#define IDDW_OUTPUT				(IDDW_PACKAGE_BASE + 0x100)	// PACKAGE_VCPP
#define IDDW_PROJECT            (IDDW_PACKAGE_BASE + 0x210)	// PACKAGE_PRJSYS
#define IDDW_GLOBAL				(IDDW_PACKAGE_BASE + 0x211) // PACKAGE_PRJSYS
#define IDDW_MSIN               (IDDW_PACKAGE_BASE + 0x220)	// PACKAGE_MSIN

#define IDDW_IV_BASE          (IDDW_PACKAGE_BASE + 0x0240)
#define IDDW_IV                IDDW_IV_BASE
#define IDDW_IVTOPIC          (IDDW_IV_BASE+0)
#define IDDW_IVRESULTS        (IDDW_IV_BASE+1)


// Usable for packages.  IDs must be unique for each item in a package,
// since the ID will be used to retrieve the window from GetDockableWindow(),
// The IDs need not be unique across packages.  These IDs are also used to
// determine relative priority in ordering in the context pop-up.
#define IDDW_EXT_PACKAGE_BASE	(IDDW_PACKAGE_BASE + 0x0260)	// Default for package wizard.
#define IDDW_PACKAGE_MAX		(IDDW_PACKAGE_BASE + 0x02FF)

#define IDTB_SHELL_BASE         (IDDW_PACKAGE_MAX + 1)
// This range reserved for shell.
#define IDTB_MENUBAR			(IDTB_SHELL_BASE+0)	
#define IDTB_STANDARD			(IDTB_SHELL_BASE+1)
#define IDTB_PROJECT			(IDTB_SHELL_BASE+2)
#define IDTB_FULLSCREEN			(IDTB_SHELL_BASE+3)
#define IDTB_SHELL_MAX			(IDTB_SHELL_BASE + 0x00FF)

#define IDTB_PACKAGE_BASE		(IDTB_SHELL_MAX + 1)
// Usable for packages.  IDs must be unique for each item in a package,
// since the ID will be used to retrieve the window from GetToolbarData(),
// The IDs need not be unique across packages.  These IDs are also used to
// determine relative priority in ordering in the context pop-up.
#define IDTB_EXT_PACKAGE_BASE	(IDTB_PACKAGE_BASE + 0x0260)	// Default for package wizard.
#define IDTB_PACKAGE_MAX		(IDTB_PACKAGE_BASE + 0x02FF)
#define IDTB_CUSTOM_BASE        (IDTB_PACKAGE_MAX + 1)	// No base IDs greater than this!
/////////////////////////////////////////////////////////////////////////////

//	Dock states.
// _FS_ == Full Screen
// Bit 0 - Edit/Debug
// Bit 1 - Normal/FullScreen

#define STATE_EDIT		0
#define STATE_DEBUG 	1
#define STATE_FS_EDIT	2
#define STATE_FS_DEBUG	3

#define STATE_FULLSCREEN 2
#define MASK_FULLSCREEN  2

#define IS_STATE_DEBUG(x)		(x & 1)
#define IS_STATE_FULLSCREEN(x)	(x & 2)

//	Styles.

#define INIT_VISIBLE	   0x00000001L	// Make visible when registered.
#define INIT_CANHORZ 	   0x00000002L	// Can reside in horizontal dock.
#define INIT_CANVERT	   0x00000004L	// Can reside in vertical dock.
#define INIT_POSITION	   0x00000008L	// No floating position given.
#define INIT_ASKAVAILABLE  0x00000010L	// Hide/show on idle depending on availability.
#define INIT_AVAILABLE	   0x00000020L	// Internal use only for layout.
#define INIT_MDI		   0x00000040L	// MDI window.
#define INIT_DESKPLACE	   0x00000080L  // We have MDI window placement info.
#define INIT_DOCKPLACE	   0x00000100L  // We have CDockWnd placement info.
#define INIT_DOCKSERIAL    0x00000200L	// We have absolute CDockWnd placement info.
#define INIT_LASTAVAILABLE 0x00000400L	// Used for AskAvailable stretchy windows.
#define INIT_NODESTROY     0x00000800L  // Don't destroy window on Hide (dtEdit windows only).
#define INIT_STRETCHSIZE   0x00001000L	// Init struct has a size for stretching.
#define INIT_TRANSPOSE_SIZE 0x00002000L	// When docking use vertical size for horizontal dock.
#define INIT_REMOVE			0x00008000L	// To remove old workers from layout.
#define INIT_HOST			0x00010000L  // True if the window is the host of an embedded window (internal)

#define DWS_STRETCHY       0x00000001L	// Stretch to fit in dock.
#define DWS_SIZABLE		   0x00000002L	// Snap sizing when in palette.
#define DWS_8SIZABLE	   0x00000004L	// Snap sizing with corners.
#define DWS_MENUBAR        0x00000008L  // Stretches in top dock, wraps as needed, repels invaders

//	Messages.

// Window messages.  Handle for enhanced functionality.  You must register this
// yourself in your dll.  To do so, copy the following definitions.
//		UINT DWM_GETDATA = RegisterWindowMessage("DockGetWindowData");
//		UINT DWM_GETMOVESIZE = RegisterWindowMessage("DockWndMoveSize");
//		UINT DWM_GETTRACKSIZE = RegisterWindowMessage("DockWndTrackSize");
//		UINT DWM_ENABLECHILD = RegisterWindowMessage("DockEnableChild");
//		UINT DWM_SHOWWINDOW = RegisterWindowMessage("DockShowWindow");
//		UINT DWM_CLOSE = RegisterWindowMessage("DockWndClose");

extern UINT DWM_GETDATA;		// Sent to the window to get initialization data.
extern UINT DWM_GETMOVESIZE;	// Allows window to change size on dock position.
extern UINT DWM_GETTRACKSIZE;	// Allows window to control snap sizing.
extern UINT DWM_ENABLECHILD;	// Disable children for toolbar customizing.
extern UINT DWM_SHOWWINDOW;		// Notification of visibility state change.

// Datatypes.

enum DOCKPOS
{
    dpNil,
    dpTop,		// Top through Hide must be in order.
    dpBottom,
    dpLeft,
    dpRight,
    dpHide,
	dpMDI,
    dpCurrent,
	dpHorzInit,
	dpVertInit,
	dpEmbedded
};

#define dpFirst 1	// These refer to Top through Hide.
#define dpCount 5

enum DOCKTYPE
{
	dtNil,
	dtHwnd,
	dtWindow,
	dtToolbar,
	dtBorder,
	dtEdit,
	// a toolbar embedded in another window
	dtEmbeddedToolbar,
};

enum UPDATE_SHOW {
	updNow,
	updNoRecalc,
	updDelay
};

enum MAX_STATE {
	stateMaximize,
	stateRestore,
	stateDisabled,
};

#define _MAX_DOCK_CAPTION 63

#pragma pack(2)
struct DOCKINIT {
	UINT nIDWnd;
	UINT nIDPackage;
	UINT nIDPacket;
	char szCaption[_MAX_DOCK_CAPTION + 1];
	DWORD fInit;	// Initialization flags.
	DOCKTYPE dt;
    DOCKPOS dpInit, dpPrev;

    RECT rectFloat;		// Accessed only if !INIT_POSITION
	SIZE sizeStretch;	// Accessed only if INIT_STRETCHSIZE
};

struct TOOLBARINIT {
	UINT nIDWnd;        // full (MAKEDOCKID) docked window id - including package id and window id
	int nIDCount;
};
#pragma pack()

// Function prototypes.

HGLOBAL DkInfoData(UINT nInfoCount, DOCKINIT FAR* lpInfoArray);
HGLOBAL DkToolbarData(const TOOLBARINIT* ptbi, const UINT FAR* lpIDArray);
BOOL DkRegisterWnd(HWND hwnd, DOCKINIT* pDockInit);
BOOL DkRegisterToolbar(DOCKINIT* pdi, TOOLBARINIT* ptbi, UINT FAR* lpIDArray);
BOOL DkPreHandleMessage(HWND hwnd, UINT message,
	UINT wParam, LPARAM lParam, LRESULT* lResult);

#define MAKEDOCKID(pkg, id) MAKELONG(id, pkg)

DOCKPOS DkWGetDock(UINT nID);
void DkWShowWindow(UINT nID, BOOL bShow);
void DkWToggleMDIState(UINT nID);
void DkWMoveWindow(UINT nID, DOCKPOS dp, LPCRECT lpRect);
void DkWGetTitle(UINT nID, CString& str);
void DkWSetTitle(UINT nID, const CString& str);
void DkWRemove(UINT nID);
// call this to embed a bar in a docking window
HWND DkWEmbed(UINT nID, HWND hwndHost);
// Once the embedding host is created, it should call this to complete the association
void DkWAssociate(UINT nID, UINT nIDHost);
MAX_STATE DkWGetMaxState(UINT nID);
void DkWMaximizeRestore(UINT nID);

void DkWMapDockingCmd(UINT nID, UINT nCmd);
void DkWHandleDockingCmd(UINT nCmd, BOOL bToggle, CCmdUI* pCmdUI = NULL);

void DkRecalcBorders(CWnd* pWnd);

int DkGetDockState();
void DkSetDockState(int nState, int nMask = 1);
void DkShowManager(BOOL bShow, UPDATE_SHOW update = updNow);
BOOL DkDocObjectMode(BOOL bShow);
void DkUpdateAvailableWnds(BOOL bUpdateNow = FALSE);
void DkLockWorker(BOOL bLock);

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SHLSRVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\i386\pkgverd.h ===
// packvchk.h : shell/package compatibility check header file.
// DO NOT make changes to this file!
// This header file is generated when a new DEF file is generated for the shell.

extern BOOL IsShellDefFileVersion(DWORD dwVersion); 
 
#define SHELL_DEFFILE_VERSION      0x35888134
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\makefile.inc ===
$(O)\xbox.res: xbox.rc xbox.rc2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\include\i386\pkgver.h ===
// packvchk.h : shell/package compatibility check header file.
// DO NOT make changes to this file!
// This header file is generated when a new DEF file is generated for the shell.

extern BOOL IsShellDefFileVersion(DWORD dwVersion); 
 
#define SHELL_DEFFILE_VERSION      0x35888d5f
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\optnxbcp.cpp ===
// 
// Xbcp Tool Options
//
// [colint]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "optnxbcp.h"	// our local header file

#ifdef XBCP

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


BEGIN_OPTSTR_TABLE(Xbcp, P_XbcpUnknownOption, P_XbcpUnknownString, P_XbcpUnknownOption, P_XbcpUnknownString, FALSE)
	IDOPT_UNKNOWN_STRING,		"",		NO_OPTARGS,			single,
	IDOPT_UNKNOWN_OPTION,		"",		NO_OPTARGS,
	single,
	IDOPT_XBCP_NOLOGO,		"NOLOGO",	NO_OPTARGS,  			single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(Xbcp)
END_OPTDEF_MAP()

CRuntimeClass * g_XbcpTabs[] =
{
	(CRuntimeClass *)NULL,
};


void OPTION_HANDLER(Xbcp)::ResetPropsForConfig(ConfigurationRecord * pcr)
{
	// do the base-class thing first
	COptionHandler::ResetPropsForConfig(pcr);

	// reset our 'deferred' prop.
	pcr->BagCopy(BaseBag, CurrBag, P_DeferredMecr, P_DeferredMecr, TRUE);
}

BOOL OPTION_HANDLER(Xbcp)::CanResetPropsForConfig(ConfigurationRecord * pcr)
{
	// do the base-class thing first
	if (COptionHandler::CanResetPropsForConfig(pcr))
		return TRUE;	// no need to check anymore

	// check our 'deferred' prop.
	return !pcr->BagSame(BaseBag, CurrBag, P_DeferredMecr, P_DeferredMecr, TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include $(VCROOT)\ide\sources.inc

INCLUDES=$(IDE_ROOT)\pkgs\bld;$(IDE_ROOT)\pkgs\bld\src;$(IDE_ROOT)\pkgs\include;$(IDE_INCLUDES)

C_DEFINES=$(C_DEFINES) /D_BLD_ADD_ON

!if "$(BTLOG)" == "1"
C_DEFINES = $(C_DEFINES) /D_BTLOG
!endif

DLLENTRY=_DllMainCRTStartup

USE_MFC=1
USE_ATL=1

UMTYPE=windows

TARGETLIBS=   \
    $(IDE_ROOT)\lib\*\devshl$(D).lib         \
    $(IDE_ROOT)\lib\*\devbld$(D).lib \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\gdi32.lib       \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\shell32.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\comdlg32.lib    \
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\optnxbe.h ===
/*
 *
 * optnxbe.h
 *
 * Option handlers for the Xbe Builder tool
 *
 */

#include "projprop.h"
#include "prjoptn.h"

extern CRuntimeClass *g_XbeBuildTabs[]; 

DEFN_OPTHDLR_COMMON
(
	XbeBuilder, /* name */
	szAddOnXbox, BCID_OptHdlr_XbeBuilder, /* Xbox linker option handler */
	szAddOnXbox, BCID_Tool_XbeBuilder /* Xbox linker tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	virtual UINT GetNameID() {return IDS_XBEBUILD_TOOL_UI;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_XbeBuildTabs;}

	virtual BOOL IsFakeProp(UINT idProp);
	virtual void FormFakeStrProp(UINT idProp, CString &strVal);
	virtual GPT GetDefStrProp(UINT idProp, CString & val);
	virtual UINT GetFakePathDirProp(UINT idProp);

#ifdef XBCP
	virtual BOOL CanResetPropsForConfig(ConfigurationRecord * pcr);
	virtual void ResetPropsForConfig(ConfigurationRecord * pcr);
#endif

	int GetTabDlgOrder()
		{ return 41; }
END_OPTHDLR()

// P_XbeName MUST be first, and it MUST be zero!
#define P_XbeName	    0x0000
#define P_XbeDebug	    0x0001
#define P_XbeTitleId    0x0002
#define P_XbeTitleName  0x0003
#define P_XbePubName    0x0004  // removed
#define P_XbeStack	    0x0005
#define P_XbeLimitMem   0x0006
#define P_XbeTitleImage 0x0007
#define P_XbeTitleInfo  0x0008
#define P_XbeSaveImage  0x0009
#define P_XbeInitFlags  0x000a
#define P_XbeRegion     0x000b
#define P_XbeRating     0x000c
#define P_UnknownOption 0x003e
#define P_UnknownString 0x003f


#define IDOPT_XBENAME	    IDOPT_BASE + 0
#define IDOPT_XBEDEBUG	    IDOPT_BASE + 1
#define IDOPT_TITLEID	    IDOPT_BASE + 2
#define IDOPT_TITLENAME	    IDOPT_BASE + 3
#define IDOPT_PUBNAME	    IDOPT_BASE + 4
#define IDOPT_XESTACK	    IDOPT_BASE + 5
#define IDOPT_XBENOLOGO	    IDOPT_BASE + 6
#define IDOPT_LIMITMEM      IDOPT_BASE + 7
#define IDOPT_TITLEINFO     IDOPT_BASE + 8
#define IDOPT_SAVEIMAGE     IDOPT_BASE + 9
#define IDOPT_TITLEIMAGE    IDOPT_BASE + 10
#define IDOPT_XEFLAGS       IDOPT_BASE + 11
#define IDOPT_XBEREGION     IDOPT_BASE + 12
#define IDOPT_XBERATING     IDOPT_BASE + 13

class CXbeBuilderPageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CXbeBuilderPageTab)
public:
	// inherit validation for now
	virtual BOOL Validate();
};

class CXbeBuilderGeneralPage : public CXbeBuilderPageTab
{
	DECLARE_DYNCREATE(CXbeBuilderGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
};

class CXbeBuilderTitlePage : public CXbeBuilderPageTab
{
	DECLARE_DYNCREATE(CXbeBuilderTitlePage)
	DECLARE_IDE_CONTROL_MAP()
};

class CXbeBuilderCertificatePage : public CXbeBuilderPageTab
{
	DECLARE_DYNCREATE(CXbeBuilderCertificatePage)
	DECLARE_IDE_CONTROL_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\optnxbcp.h ===
//
// Macintosh Xbcp Tool Options
//
// [colint]
//

#ifndef _INCLUDE_OPTNXBCP_H
#define _INCLUDE_OPTNXBCP_H

#ifdef XBCP

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_XbcpTabs[];

//----------------------------------------------------------------
// our COMMON Macintosh Xbcp option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	Xbcp, /* name */
	szAddOnXbox, BCID_OptHdlr_Xbcp, /* Mac68k mecr option handler */
	szAddOnXbox, BCID_Tool_Xbcp /* Mac68k mecr tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual UINT GetNameID() {return IDS_XBCP_TOOL;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_XbcpTabs;}

 	// reset our 'deferred' props (eg. On demand remote file copy to host)
 	virtual void ResetPropsForConfig(ConfigurationRecord * pcr);
 	virtual BOOL CanResetPropsForConfig(ConfigurationRecord * pcr);

END_OPTHDLR()

// Xbcp Properties
#define P_XbcpUnknownOption			0x0000
#define P_XbcpUnknownString			0x0001

// Macintosh Xbcp options (option ids)
#define IDOPT_XBCP_NOLOGO			IDOPT_BASE + 0

#endif // XBCP

#endif // _INCLUDE_OPTNXBCP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\optnxbe.cpp ===
/*
 *
 * optnxbe.cpp
 *
 * Option handlers for the image builder tool
 *
 */

#include "stdafx.h"
#pragma hdrstop
#include "optnxbe.h"

BEGIN_OPTSTR_TABLE(XbeBuilder, P_UnknownOption, P_UnknownString, P_XbeName, P_UnknownString, FALSE)
	IDOPT_XBENOLOGO,	"nologo",					NO_OPTARGS,				single,
	IDOPT_TITLEID,		"testid:%1",				OPTARGS1(P_XbeTitleId),	single,
	IDOPT_TITLENAME,	"testname:%1",				OPTARGS1(P_XbeTitleName), single,
	IDOPT_XESTACK,		"stack:%1",					OPTARGS1(P_XbeStack),	single,
    IDOPT_XEFLAGS,      "initflags:%1",             OPTARGS1(P_XbeInitFlags),   single,
	IDOPT_XBEDEBUG,		"debug%T1",					OPTARGS1(P_XbeDebug),	single,
	IDOPT_XBENAME,		"out:%1",					OPTARGS1(P_XbeName),	single,
    IDOPT_LIMITMEM,     "limitmem%T1",              OPTARGS1(P_XbeLimitMem),    single,
    IDOPT_TITLEINFO,    "titleinfo:%1",             OPTARGS1(P_XbeTitleInfo),   single,
    IDOPT_TITLEIMAGE,   "titleimage:%1",            OPTARGS1(P_XbeTitleImage),  single,
    IDOPT_XBERATING,    "testratings:%{0xFFFFFFFF|0|1|2|3|4|5|6}1",  OPTARGS1(P_XbeRating),  single,
    IDOPT_XBEREGION,    "testregion:%1",            OPTARGS1(P_XbeRegion),  single,
    IDOPT_SAVEIMAGE,    "defaultsaveimage:%1",      OPTARGS1(P_XbeSaveImage),   single,
	IDOPT_UNKNOWN_OPTION, "", NO_OPTARGS, single,
	IDOPT_UNKNOWN_STRING, "", NO_OPTARGS, single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(XbeBuilder)
	OPTDEF_STRING(XbeName, "")
	OPTDEF_STRING(XbeTitleId, "")
	OPTDEF_STRING(XbeTitleName, "")
	OPTDEF_HEX(XbeStack, 0)
    OPTDEF_HEX(XbeInitFlags, 1)
	OPTDEF_BOOL(XbeDebug, FALSE);
    OPTDEF_STRING(XbeTitleImage, "")
    OPTDEF_STRING(XbeTitleInfo, "")
    OPTDEF_HEX(XbeRegion, 0xFFFFFFFF)
    OPTDEF_INT(XbeRating, 0)
    OPTDEF_STRING(XbeSaveImage, "")
    OPTDEF_BOOL(XbeLimitMem, FALSE)
END_OPTDEF_MAP()

DEFINE_LOCALIZED_ENUM(RatingEnum)
	LOCALIZED_ENUM_ENTRY(IDS_RatingNone /* (none) */, 1)
	LOCALIZED_ENUM_ENTRY(IDS_Rating0 /* RP */, 2)
	LOCALIZED_ENUM_ENTRY(IDS_Rating1 /* AO */, 3)
	LOCALIZED_ENUM_ENTRY(IDS_Rating2 /* M */, 4)
	LOCALIZED_ENUM_ENTRY(IDS_Rating3 /* T */, 5)
	LOCALIZED_ENUM_ENTRY(IDS_Rating4 /* E */, 6)
	LOCALIZED_ENUM_ENTRY(IDS_Rating5 /* K-A */, 7)
	LOCALIZED_ENUM_ENTRY(IDS_Rating6 /* EC */, 8)
END_LOCALIZED_ENUM_LIST()

IMPLEMENT_DYNCREATE(CXbeBuilderPageTab, COptionMiniPage);
IMPLEMENT_DYNCREATE(CXbeBuilderGeneralPage, CXbeBuilderPageTab);
IMPLEMENT_DYNCREATE(CXbeBuilderTitlePage, CXbeBuilderPageTab);
IMPLEMENT_DYNCREATE(CXbeBuilderCertificatePage, CXbeBuilderPageTab);

CRuntimeClass *g_XbeBuildTabs[] =
{
	RUNTIME_CLASS(CXbeBuilderGeneralPage),
	RUNTIME_CLASS(CXbeBuilderTitlePage),
	RUNTIME_CLASS(CXbeBuilderCertificatePage),
	NULL
};

BEGIN_IDE_CONTROL_MAP(CXbeBuilderGeneralPage, IDDP_XBEBLD_GENERAL, IDS_CAT_XBEBLD_GENERAL)
	MAP_EDIT(IDC_XBENAME, P_XbeName)
	MAP_EDIT(IDC_XESTACK, P_XbeStack)
    MAP_CHECK(IDC_LIMITMEM, P_XbeLimitMem)
	MAP_CHECK(IDC_XEDEBUG, P_XbeDebug)
    MAP_EDIT(IDC_XEFLAGS, P_XbeInitFlags)
#ifdef XBCP
	MAP_CHECK(IDC_XBCP_DEFERRED, P_DeferredMecr)
#endif
END_IDE_CONTROL_MAP()

BEGIN_IDE_CONTROL_MAP(CXbeBuilderTitlePage, IDDP_XBEBLD_TITLEINFO, IDS_CAT_XBEBLD_TITLEINFO)
	MAP_EDIT(IDC_TITLENAME, P_XbeTitleName)
    MAP_EDIT(IDC_TITLEINFO, P_XbeTitleInfo)
    MAP_EDIT(IDC_TITLEIMAGE, P_XbeTitleImage)
    MAP_EDIT(IDC_SAVEIMAGE, P_XbeSaveImage)
END_IDE_CONTROL_MAP()

BEGIN_IDE_CONTROL_MAP(CXbeBuilderCertificatePage, IDDP_XBEBLD_CERTIFICATE, IDS_CAT_XBEBLD_CERTIFICATE)
	MAP_EDIT(IDC_TITLEID, P_XbeTitleId)
    MAP_EDIT(IDC_XBEREGION, P_XbeRegion)
    MAP_COMBO_LIST(IDC_XBERATING, P_XbeRating, RatingEnum)
END_IDE_CONTROL_MAP()

BOOL OPTION_HANDLER(XbeBuilder)::IsFakeProp(UINT idProp)
{
	return MapActual(idProp) == P_XbeName;
}

void OPTION_HANDLER(XbeBuilder)::FormFakeStrProp(UINT idProp, CString &strVal)
{
	ASSERT(MapActual(idProp) == P_XbeName);

	/* Use the linker's logic */

    CProjItem * pItem = ((CProjItem *)m_pSlob);
	CDir dirWorkspace = pItem->GetProject()->GetWorkspaceDir();
	CDir dirProject = pItem->GetProject()->GetProjDir(pItem->GetActiveConfig());
	CString strWorkspace = (const TCHAR *)dirWorkspace;
	CString strProject = (const TCHAR *)dirProject;
	CString strBase;

	if (strWorkspace.CompareNoCase(strProject) == 0)
	{
		const CPath * ppathProj = pItem->GetProject()->GetFilePath();
		ppathProj->GetBaseNameString(strBase);
	}
	else
	{
		// subproject
		ASSERT( (strProject.GetLength() > strWorkspace.GetLength()) );
		strBase = strProject.Right(strProject.GetLength()-strWorkspace.GetLength()-1);
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	ASSERT(idOutDirProp != (UINT)-1);

	CString strOut;
	VERIFY(m_pSlob->GetStrProp(idOutDirProp, strOut) == valid);

	const TCHAR * pchT;
	strVal = "";

	// If the output directory doesn't end in a forward slash
	// or a backslash, append one.
	if (!strOut.IsEmpty())
	{
		strVal = strOut;

		pchT = (const TCHAR *)strVal + strVal.GetLength();
		pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

		if (*pchT != _T('/') && *pchT != _T('\\'))
			strVal += _T('/');
	}

	// Add the base, and extension prefix
	strVal += strBase;
	strVal += _T(".xbe");
}

GPT OPTION_HANDLER(XbeBuilder)::GetDefStrProp(UINT idProp, CString & val)
{
	if(!IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

UINT OPTION_HANDLER(XbeBuilder)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	/* For us, the .exe is an intermediate file */
	if (idPropL == P_XbeName)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
}

BOOL CXbeBuilderPageTab ::Validate()
{
	if(m_nValidateID == IDC_OPTSTR)
		/* We'll just require that our output name end in ".xbe" */
		return Validate_DestinationProp(P_XbeName, IDOPT_XBENAME, IDC_OPTSTR,
			IDS_DEST_XBE, "xbe", FALSE, TRUE);
	return COptionMiniPage::Validate();
}

#ifdef XBCP

void OPTION_HANDLER(XbeBuilder)::ResetPropsForConfig(ConfigurationRecord * pcr)
{
    // do the base-class thing first
    COptionHandler::ResetPropsForConfig(pcr);

    // reset our 'deferred' prop.
    pcr->BagCopy(BaseBag, CurrBag, P_DeferredMecr, P_DeferredMecr, TRUE);
}

BOOL OPTION_HANDLER(XbeBuilder)::CanResetPropsForConfig(ConfigurationRecord * pcr)
{
    // do the base-class thing first
    if (COptionHandler::CanResetPropsForConfig(pcr))
        return TRUE;    // no need to check anymore

    // check our 'deferred' prop.
    return !pcr->BagSame(BaseBag, CurrBag, P_DeferredMecr, P_DeferredMecr, TRUE);
}

#endif // XBCP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\platxbox.h ===
//
// Xbox Platform
//
// [matthewt]
//
						
#ifndef _INCLUDE_PLATFORM_XBOX_H
#define _INCLUDE_PLATFORM_XBOX_H

#include "stdafx.h"

// declare out platform
extern	PlatformInfo	g_PlatformInfoXbox;

// declare our project types
class CProjTypeXboxExe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxExe)

public:
	CProjTypeXboxExe()
		: CProjType(szAddOnXbox, BCID_ProjType_XboxExe, /* id */
					IDS_XBOXEXE_PROJTYPE, CProjType::application, /* props */
					szAddOnXbox, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | ImageXbe | SubsystemWindows | TargetIsDebugable; }
};

#ifdef XBOXDLL
class CProjTypeXboxDll : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxDll)

public:
	CProjTypeXboxDll()
		: CProjType(szAddOnXbox, BCID_ProjType_XboxDll, /* id */
					IDS_XBOXDLL_PROJTYPE, CProjType::dynamiclib, /* props */
					szAddOnXbox, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | SubsystemWindows | TargetIsDebugable; }
};
#endif

class CProjTypeXboxLib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxLib)

public:
	CProjTypeXboxLib()
		: CProjType(szAddOnXbox, BCID_ProjType_XboxLib, /* id */
					IDS_XBOXLIB_PROJTYPE, CProjType::staticlib, /* props */
					szAddOnXbox, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | SubsystemWindows | TargetIsDebugable; }
};

class CProjTypeXboxGeneric : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxGeneric)

public:
	CProjTypeXboxGeneric()
		: CProjType(szAddOnXbox, BCID_ProjType_XboxGeneric, /* id */
					IDS_GENERIC_PROJTYPE, CProjType::generic, /* props */
					szAddOnXbox, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();
	int GetAttributes () {  return SubsystemWindows | TargetIsDebugable; }
	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	

};

#endif // _INCLUDE_PLATFORM_XBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//		are changed infrequently
//

#if _MSC_VER >= 800
#pragma warning(disable:4200) // (C8) 'zero sized array in struct/union'
#pragma warning(disable:4062) // (C8) 'enumerate in switch not handled'
#pragma warning(disable:4065) // (C8) 'switch statement contains only default'
#endif

#ifdef _NTWIN
#pragma warning(disable:4165) // '__stdcall function can't take variable number of arguments'
#endif

#pragma warning(disable:4251) // dll-interface warnings...
#pragma warning(disable:4275)

#define XBCP

#ifdef _WIN32
#define _SUSHI_PROJECT
#else
#define _NOCTL3D
#endif

#define OEMRESOURCE // to get oem bitmap id's
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxpriv.h>
#ifdef _WIN32
#include <tchar.h>
#else
#include <ctype.h>
#endif

// Include the NT image file defines
#include <macimage.h>

extern "C" {
#include "limits.h"
};
				    
#include "main.h"
#include "shlsrvc.h"
#include "package.h"
#include "resource.h"
#include "bldiface.h"
#include "prjconfg.h"
#include "projtool.h"
#include "xbox.h"
#include <bldrcvtr.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbox.rc
//

// string resources
#define IDS_TL_XBOX_LOCAL               15600
#define IDS_XBOXEXE_PROJTYPE            15601
#define IDS_XBOXLIB_PROJTYPE            15602
#define IDS_XBOXDLL_PROJTYPE            15603
#define IDS_CAT_CODEGEN                 15605
#define IDS_CAT_XBEBLD_GENERAL          15606
#define IDS_CAT_XBEBLD_TITLEINFO        15607
#define IDS_MFCDLL_OLD_LIBS             15608
#define IDS_MFC_OLD_LIBS                15609
#define IDS_TL_XBOX_TCPIP               15610
#define IDS_CAT_XBEBLD_CERTIFICATE      15611
// 15612
#define IDS_XBOX_LIBS_CONV              15613
#define IDS_XBOX_PLATFORM               15614
#define IDS_XBOXLINKCOFF_TOOL_UI        15615
#define IDS_XBOXCOMPILER32_TOOL_UI      15616
#define IDS_XBOXEXE_CPLR_DBG            15617
#define IDS_XBOXEXE_CPLR_REL            15618
#define IDS_XBEBUILD_COMMON             15619
#define IDS_XBEBUILD_DBG                15620
#define IDS_XBEBUILD_REL                15621
// 15622-15624
#define IDS_XBOX_MTL_COMMON             15625
#define IDS_XBOX_MTL_DBG                15626
#define IDS_XBOX_MTL_REL                15627
// 15628
#define IDS_XBOX_PLATFORM_SHORT         15629
#define IDS_XBOXEXE_XBEBUILD            15630
#define IDS_XBOXEXE_LINK                15631
#define IDS_XBOXLIB_LINK                15632
#define IDS_XBOXDLL_LINK                15633
#define IDS_Thread0                     15634
#define IDS_Thread1                     15635
#define IDS_Thread2                     15636
// 15637-15639
#define IDS_CallConv0                   15640
#define IDS_CallConv1                   15641
#define IDS_CallConv2                   15642
#define IDS_ByteAlign0                  15643
#define IDS_ByteAlign1                  15644
#define IDS_ByteAlign2                  15645
#define IDS_ByteAlign3                  15646
#define IDS_ByteAlign4                  15647
// 15648
#define IDS_XBOXLINKCOFF_TOOL           15649
#define IDS_XBOXCOMPILER32_TOOL         15650
#define IDS_Thread0d                    15651
#define IDS_Thread1d                    15652
#define IDS_Thread2d                    15653
#define IDS_Rating0                     15655
#define IDS_Rating1                     15656
#define IDS_Rating2                     15657
#define IDS_Rating3                     15658
#define IDS_Rating4                     15659
#define IDS_Rating5                     15660
#define IDS_Rating6                     15661
#define IDS_RatingNone                  15662
#define IDS_XBOX_CPLR_COMMON            15663
#define IDS_XBOX_CPLR_DBG               15664
#define IDS_XBOX_CPLR_REL               15665
#define IDS_XBOX_LINK_COMMON            15666
#define IDS_XBOX_RC_COMMON              15667
#define IDS_XBOX_RC_DBG                 15668
#define IDS_XBOX_RC_REL                 15669
#define IDS_XBOX_LINK_DBG               15670
#define IDS_XBOX_LINK_REL               15671
#define IDS_XBOX_BSCMAKE_DBG            15672
#define IDS_XBOX_BSCMAKE_REL            15673
#define IDS_XBOX_BSCMAKE_COMMON         15674
#define IDS_XBCP_TOOL                   15675
#define IDS_XBCP_TOOL_UI                15676
#define IDS_DESC_XBCPMAKING             15677
#define IDS_XBCP_COMMON                 15678
// 15679-15682
#define IDS_GENERIC_PROJTYPE            15683
// 15684
#define IDS_XBOX_LIBS_CORE              15685
#define IDS_XBEBUILD_TOOL               15686
#define IDS_XBEBUILD_TOOL_UI            15687
// 15688
#define IDS_DESC_XBEBUILD               15689
// 15690-15691
#define IDS_DEST_XBE                    15692
// 15693-15699

// dialog resources
#define IDDP_COMPILER_XBOX              15601
#define IDDP_XBEBLD_GENERAL             15602
#define IDDP_XBEBLD_TITLEINFO           15603
#define IDC_TXT_TITLEID                 15604
#define IDC_TXT_TITLENAME               15605
#define IDC_TXT_PUBNAME                 15606
#define IDC_TITLEID                     15607
#define IDC_TITLENAME                   15608
#define IDC_PUBNAME                     15609
#define IDC_TXT_XESTACK                 15610
#define IDC_XESTACK                     15611
#define IDC_XEDEBUG                     15612
#define IDC_XBCP_DEFERRED               15620
#define IDC_XBENAME                     15621
#define IDC_TXT_XBENAME                 15624
#define IDC_TXT_THREAD                  15625
#define IDC_THREAD                      15626
#define IDC_CALLCONV                    15627
#define IDC_TXT_CALLCNV                 15628
#define IDC_BYTE                        15629
#define IDC_TXT_BYTE                    15630
#define IDC_TXT_LIMITMEM                15631
#define IDC_LIMITMEM                    15632
#define IDC_TXT_TITLEIMAGE              15633
#define IDC_TITLEIMAGE                  15634
#define IDC_TXT_TITLEINFO               15635
#define IDC_TITLEINFO                   15636
#define IDC_TXT_SAVEIMAGE               15637
#define IDC_SAVEIMAGE                   15638
#define IDC_TXT_XEFLAGS                 15639
#define IDC_XEFLAGS                     15640
#define IDC_TXT_XBEREGION               15641
#define IDC_XBEREGION                   15642
#define IDC_TXT_XBERATING               15643
#define IDC_XBERATING                   15644
#define IDDP_XBEBLD_CERTIFICATE         15645

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        15689
#define _APS_NEXT_COMMAND_VALUE         15689
#define _APS_NEXT_CONTROL_VALUE         15692
#define _APS_NEXT_SYMED_VALUE           15689
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\toolxbcp.cpp ===
//
// Xbox Xbcp Tool
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toolxbcp.h"	// our local header file

#ifdef XBCP

#include <bldapi.h>
#include <bldguid.h>

IMPLEMENT_DYNAMIC(CXbcpTool, CSchmoozeTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CXbcpTool::CXbcpTool() : CSchmoozeTool()
{
	// tool name
	m_nIDName = IDS_XBCP_TOOL;
	m_nIDUIName = IDS_XBCP_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("xbecopy.exe");
	m_strToolInput = _TEXT("*.xbe");
	m_strToolPrefix = _TEXT("XBCP");

	// deferred tool
	m_fDeferredTool = TRUE;

	// Olympus 53: DON'T perform action if able
	ASSERT(m_fPerformIfAble == FALSE);
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the mecr tool
BOOL CXbcpTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		CPath * pPath;
		if ((pPath = pItem->GetProject()->GetTargetFileName()) == (CPath *)NULL)
			continue;

		int i;
		VERIFY(pItem->GetProject()->GetIntProp(P_DeferredMecr, i));
		if (i == dabNotDeferred)
		{
			// write out to .trg to makefile if mfile is not deferred
			CPath pathName;
			pathName = *pPath;
			pathName.ChangeExtension(_TEXT("TRG"));

			if (!pAction->AddOutput((const CPath *)&pathName))
				ASSERT(FALSE);
		}
		delete pPath;
	}

	return TRUE; // success
}

UINT CXbcpTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;
    BOOL fCreate = stage == TOB_Stage && type != TOB_Clean;
    BOOL fClean = stage == TOB_Pre && type == TOB_Clean;

	act = CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);

	// finished building browser database
	if ((fCreate || fClean) && act != ACT_Error)
	{
		// set timestamp on dummy .TRG output on *our* filesystem
		POSITION posAction = lstActions.GetHeadPosition();
		while (posAction != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
			
			CFileRegSet * pSet = pAction->GetOutput();
			FileRegHandle frh;
			pSet->InitFrhEnum();
			while ((frh = pSet->NextFrh()) != (FileRegHandle)NULL) {
                if(fCreate) {
				    HANDLE hdle = ::CreateFile
									    ((const TCHAR *)*pAction->m_pregistry->GetRegEntry(frh)->GetFilePath(),
									     GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, NULL, 0L);

				    if (hdle != INVALID_HANDLE_VALUE)
					    VERIFY(::CloseHandle(hdle));
                }
                if(fClean)
                    DeleteFile((const TCHAR *)*pAction->m_pregistry->GetRegEntry(frh)->GetFilePath());
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
			}
		}
	}

	return act;
}

BOOL CXbcpTool::GetCommandOptions(CActionSlob * pAction, CString & strOptions)
{
 	g_prjoptengine.SetOptionHandler(pAction->m_pTool->GetOptionHandler());
	g_prjoptengine.SetPropertyBag(pAction->m_pItem);
	if (!g_prjoptengine.GenerateString(strOptions))
		return FALSE;

	return TRUE;	// ok
}

BOOL CXbcpTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList &plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
 		CProjItem * pItem = pAction->Item();

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		CPath *pPathTarget = (CPath *)pItem->GetProject()->GetTargetFileName();

		BOOL fTargetFile = FALSE;

		// add our inputs to the command-line
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		FileRegHandle frhInput;
		pset->InitFrhEnum();
		CString strInput;
		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			VERIFY(strDescription.LoadString(IDS_DESC_XBCPMAKING));
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
			CString strExt = pPath->GetExtension();

			// generate tool options
			// HACK, HACK, HACK for the ole mfile tool and exe projects/external targets
 			CString strCmdLine;
			CProject * pProject = pAction->m_pItem->GetProject();
			if (pProject->IsExeProject() || pProject->IsExternalTarget())
				VERIFY(strCmdLine.LoadString(IDS_XBCP_COMMON));
			// Ok generate the tool options the proper way.
			else if (!pAction->GetCommandOptions(strCmdLine))
			{
				delete pPathTarget;
				return FALSE;
			}

			if (_tcsicmp(pPathTarget->GetFullPath(), pPath->GetFullPath()) == 0)
				fTargetFile = TRUE;

			//delete pPathTarget;
            //pPathTarget = NULL;

			// quote this input and make relative to project directory?
			if (!pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE))
			{
				// Use absolute path, quoted
				strInput = _T('"');
				strInput += *pPath;
				strInput += _T('"');
			}

			// base file name
			CString strBaseName = pPath->GetFileName();
							
			if ( !fTargetFile ){
				continue;
			}
			strCmdLine += _T(' ');
			strCmdLine += strInput;

			// Make sure we have a remote executable name...
			if (!pItem->GetProject()->GetInitialRemoteTarget())
				return FALSE;

			// append the name of our remote target
			CString strRemoteTarget;
			if (!pItem->GetProject()->GetStrProp(P_RemoteTarget, strRemoteTarget))
				return FALSE;

			// for the primary target, use the name in remote target
			strCmdLine += _TEXT(" \"");
			strCmdLine += strRemoteTarget;
			strDescription += strRemoteTarget;
			fTargetFile = FALSE;

			strCmdLine += _T('"');

			// may create a tmp. file if cmdline too long
			if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
				return FALSE;	// error

			// add this to our list of command-lines
			CCmdLine *pCmdLine = new CCmdLine;
			pCmdLine->slCommandLines.AddTail(strCmdLine);
			pCmdLine->slDescriptions.AddTail(strDescription);
			pCmdLine->nProcessor = 1;

			plCommandLines.AddTail(pCmdLine);
		}
		delete pPathTarget;

	}

	return TRUE;	// success
}

#if 0
DAB CXbcpTool::DeferredAction(CActionSlob * pAction, CString * pstrAction)
{
	int iDefer;
	if (pAction->m_pItem->GetProject()->GetIntProp(P_DeferredMecr, iDefer) != valid)
	{
		ASSERT(FALSE);	// shouldn't happen
		iDefer = 0;
	}

/*
	if (pstrAction != (CString *)NULL)
		ASSERT(FALSE);	// FUTURE:
*/

	switch (iDefer)
	{
		case 0:	return dabNotDeferred;
		case 1:	return dabDeferred;
		default: ASSERT(FALSE); return dabNotDeferred;
	}
}

BOOL CXbcpTool::SetDeferredAction(CActionSlob * pAction, DAB dab)
{
	int iDefer;
	switch (dab)
	{
		case dabNotDeferred:
			iDefer = 0; break;

		case dabDeferred:
			iDefer = 1; break;

		default:
			ASSERT(FALSE); iDefer = 0; break;
	}

	return pAction->m_pItem->GetProject()->SetIntProp(P_DeferredMecr, iDefer);
}
#endif

const CSchmoozeTool::SchmoozeData CXbcpTool::m_XbcpSchmoozeData =
{
		_TEXT ("XBCP"),		 		//pszExeMacro;
		_TEXT ("XBCP_FLAGS"),  		//pszFlagsMacro;
		_TEXT (""),						//pszSpecialFlags;
		_TEXT ("XBCP_FILES"),			//pszConsumeMacro;
		_TEXT (""),						//pszSpecialConsume;
		_TEXT (" $(XBCP)"),			//pszExeMacroEx;
		_TEXT (" $(XBCP_FLAGS)"),   	//pszFlagsMacroEx;
		_TEXT (""),			//pszSpecialFlagsEx;
		_TEXT (" $(XBCP_FILES)"), 		//pszConsumeMacroEx;
		_TEXT (""),				//pszSpecialConsumeEx;
		_TEXT("trg"),					//pszProductExtensions;
		_TEXT(""),						//pszDelOnRebuildExtensions;
};

BOOL CXbcpTool::IsConsumableFile(const CPath * pPath)
{
	if (FileNameMatchesExtension (pPath, m_strToolInput))
		return TRUE;

	LPTSTR pszPathOut = NULL;
	LPBUILDSYSTEM pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
	if (pBldSysIFace)
	{
		if (pBldSysIFace->IsActiveBuilderValid() == S_OK)
			pBldSysIFace->GetTargetFileName(ACTIVE_BUILDER, &pszPathOut);
		pBldSysIFace->Release();
	}
	if (pszPathOut)
	{
		BOOL bOkay = _tcsicmp(pPath->GetFullPath(), pszPathOut);
		delete [] pszPathOut;
		return bOkay;
	}
	else
		return FALSE;
}

BOOL CXbcpTool::IsProductFile(const CPath * pPath)
{
	return FileNameMatchesExtension(pPath, m_XbcpSchmoozeData.pszProductExtensions);
}

BOOL CXbcpTool::IsDelOnRebuildFile(const CPath * pPath)
{
	return FileNameMatchesExtension(pPath, m_XbcpSchmoozeData.pszDelOnRebuildExtensions);
}
///////////////////////////////////////////////////////////////////////////////
static BOOL CXbcpToolTargetCallback(DWORD dw, FileRegHandle frh)
{
	return ((CSchmoozeTool *) dw)->IsProductFile(
				g_FileRegistry.GetRegEntry(frh)->GetFilePath()
			);
}

BOOL CXbcpTool::DoWriteBuildRule(CActionSlob * pAction)
{
	CString strTargets, strBuildLine;
	const SchmoozeData& sd = GetMacs();
	ASSERT (PresentInActiveConfig ( pAction->m_pItem ));
	
	TRY
	{
        /* First see whether we can fill the XBCP_DEST macro */
        CString strXbcpDest("XBCP_DEST");
		CString strRemoteTarget;

		LPBUILDSYSTEM pBldSysIFace;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace)));
		if (pBldSysIFace->IsActiveBuilderValid() == S_OK)
			pBldSysIFace->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteTarget);
		pBldSysIFace->Release();
        if(!strRemoteTarget.IsEmpty()) {
            CString strOut = '"' + strRemoteTarget + '"';
            m_pMakWriter->WriteMacro(strXbcpDest, strOut);
        }

        CObList lstItems; lstItems.AddHead(pAction->m_pItem);
		MakeQuotedString(
						pAction->GetOutput(),
						strTargets,
						m_pBaseDir,
						TRUE,
						NULL,
						NULL,
                        NULL, FALSE,
                        &lstItems, FALSE
						);

		strBuildLine = (strBuildLine + sd.pszSpecialConsumeEx) + sd.pszConsumeMacroEx;
		m_pMakWriter->WriteDesc ( strTargets, strBuildLine);

		strBuildLine = CString (sd.pszExeMacroEx) + sd.pszFlagsMacroEx + sd.pszSpecialFlagsEx + sd.pszConsumeMacroEx + _TEXT(" $(") + strXbcpDest + _TEXT(")\r\n" );
		m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (strBuildLine);
		m_pMakWriter->EndLine ();
		m_pMakWriter->EndLine ();
	}
	CATCH (CException, e)
	{
		strBuildLine.Empty (); strTargets.Empty();
		THROW_LAST ();
	}	
	END_CATCH

	return TRUE;
}

#endif // XBCP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\platxbox.cpp ===
// // Xbox Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platxbox.h"    // our local header file

#include <bldapi.h>
#include <bldguid.h>

IMPLEMENT_DYNAMIC(CProjTypeXboxExe, CProjType)
#ifdef XBOXDLL
IMPLEMENT_DYNAMIC(CProjTypeXboxDll, CProjType)
#endif
IMPLEMENT_DYNAMIC(CProjTypeXboxLib, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeXboxGeneric, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

#define TLLOC_NAME  "TLXBOX"
#define EM_NAME     "XEM"
#define SH_NAME     "SHXBOX"
#define EE_NAME     "EECXX"

TLInfo g_rgTLInfoXbox[] =
{
    //{_T(TLLOC_NAME),IDS_TL_XBOX_LOCAL,  TFL_LOCAL},
    {_T(TLLOC_NAME),   IDS_TL_XBOX_TCPIP,  TFL_CFGABLE}
};

PlatformInfo g_PlatformInfoXbox =
{
    _T("Xbox"),          // Official platform name -- DO NOT LOCALIZE!
    xbox,                   // Unique ID
    IDS_XBOX_PLATFORM,         // Localizable description string
    IDS_XBOX_PLATFORM_SHORT,// Abbreviated localizable description string
    _T(EM_NAME),                // EM name
    _T(SH_NAME),                    // SH name
    _T(EE_NAME),                // EE name
    sizeof( g_rgTLInfoXbox )/sizeof( *g_rgTLInfoXbox ), // Number of TLs
    g_rgTLInfoXbox,         // Array of TLInfo structs
    0,                          // Number of NMs
    NULL,                       // Array of NMInfo structs
    _T("res"),                  // RC extension
    "xbox\\bin;",               // Platform specific Path directories
    "xbox\\include;",           // Platform specific Include Path directories
    "xbox\\lib;",               // Platform specific Lib Path directories
    "xbox\\src;",               // Platform specific Source Path directories
    0 |                         // Not Primary platform
    PIA_Allow_WorkingDir |      // Can use a working dir. for debugging
    PIA_Supports_IncCplr |      // Supports inc. cplr.
    PIA_Supports_RTTI |         // Supports RTTI
    PIA_Supports_IncLink|       // Supports ilink
    PIA_Supports_MinBuild |     // Supports minimum build
    PIA_Enable_Language |       // Enable language for RC option
    PIA_Allow_MFCinDLL |        // Supports use of mfc in a dll
    PIA_Allow_ProgArgs |        // Executable can use program arguments for Debug etc.
    PIA_Supports_RemoteDbg|     // Supports remote debugging
    PIA_Enable_Stub|            // Allow DOS Stub
    PIA_Enable_AllDebugType,    // Allow Debug Types
    NoUseMFC,                   // Default is not using MFC
    _T("")                  // Default output directories
};

// implementation

// pre-installed components
#include "..\..\ide\pkgs\bld\src\toolbsc.h"
#include "..\..\ide\pkgs\bld\src\toolrc.h"
#include "..\..\ide\pkgs\bld\src\toolmtl.h"
#include "..\..\ide\pkgs\bld\src\toollib.h"

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultXboxLinkOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_XBOX_LINK_COMMON, fDebug ? IDS_XBOX_LINK_DBG : IDS_XBOX_LINK_REL, nIDOption);

	/* We don't need debug options again; we just got them */
#if 0
	// REVIEW: This should be just added to the IDS_XBOX_LINK_DBG string once all the 
	// platforms support separate types.
	if (fDebug)
	{
		CString strXtraDbg; 
		VERIFY(strXtraDbg.LoadString(IDS_XBOX_LINK_DBG));
		strOption += ' '; strOption += strXtraDbg;
	}
#endif

    CString strXtraLibs;
    VERIFY(strXtraLibs.LoadString(IDS_XBOX_LIBS_CORE));
    strOption += ' '; strOption += strXtraLibs;

#if 0
    LPBUILDSYSTEM pBldSysIFace;
    VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace)));
    if (pBldSysIFace->LanguageSupported(CPlusPlus) == S_OK)
    {
        VERIFY(strXtraLibs.LoadString(IDS_XBOX_LIBS));
        strOption += ' '; strOption += strXtraLibs;
    }
    pBldSysIFace->Release();
#endif
}

void VPROJDeriveDefaultXboxRcOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_XBOX_RC_COMMON, fDebug ? IDS_XBOX_RC_DBG : IDS_XBOX_RC_REL, nIDOption);
}

void VPROJDeriveDefaultXboxBscMakeOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_XBOX_BSCMAKE_COMMON, fDebug ? IDS_XBOX_BSCMAKE_DBG : IDS_XBOX_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultXbeBuildOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_XBEBUILD_COMMON, fDebug ? IDS_XBEBUILD_DBG : IDS_XBEBUILD_REL, nIDOption);
}

void VPROJDeriveDefaultXbcpOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_XBCP_COMMON, -1, nIDOption);
}

void VPROJDeriveDefaultXboxLibOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    strOption.LoadString(nIDOption);
}

BOOL CProjTypeXboxExe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    VERIFY(strDebugMode.LoadString(IDS_DEBUG_CONFIG));
    VERIFY(strReleaseMode.LoadString(IDS_RELEASE_CONFIG));

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_XboxExe:
                VPROJDeriveDefaultXboxLinkOptions(strOption, fDebug, IDS_XBOXEXE_LINK);
                break;

			case BCID_Tool_XbeBuilder:
                VPROJDeriveDefaultXbeBuildOptions(strOption, fDebug, UINT(-1));
				break;

#ifdef XBCP
			case BCID_Tool_Xbcp:
                VPROJDeriveDefaultXbcpOptions(strOption, fDebug, UINT(-1));
				break;
#endif

            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultXboxRcOptions(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultXboxBscMakeOptions(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_XBOX_MTL_COMMON, fDebug ? IDS_XBOX_MTL_DBG : IDS_XBOX_MTL_REL, UINT(-1)) ;
                break;

            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

#ifdef XBOXDLL
BOOL CProjTypeXboxDll::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    VERIFY(strDebugMode.LoadString(IDS_DEBUG_CONFIG));
    VERIFY(strReleaseMode.LoadString(IDS_RELEASE_CONFIG));

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_XboxDll:
                VPROJDeriveDefaultXboxLinkOptions(strOption, fDebug, IDS_XBOXDLL_LINK);
                break;

            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultXboxRcOptions(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultXboxBscMakeOptions(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_XBOX_MTL_COMMON, fDebug ? IDS_XBOX_MTL_DBG : IDS_XBOX_MTL_REL, UINT(-1)) ;
                break;

            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}
#endif

BOOL CProjTypeXboxLib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    VERIFY(strDebugMode.LoadString(IDS_DEBUG_CONFIG));
    VERIFY(strReleaseMode.LoadString(IDS_RELEASE_CONFIG));

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF Library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultXboxLibOptions(strOption, fDebug, IDS_XBOXLIB_LINK);
                break;

            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultXboxRcOptions(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultXboxBscMakeOptions(strOption, fDebug, UINT(-1));
                break;

            default:
                ASSERT(FALSE);  // need default options for one of our own tools!
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeXboxGeneric::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    strOption = "";
    return TRUE;
}

BOOL CProjTypeXboxExe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnXbox, BCID_Tool_Linker_XboxExe);
	AddTool(szAddOnXbox, BCID_Tool_XbeBuilder);
#ifdef XBCP
	AddTool(szAddOnXbox, BCID_Tool_Xbcp);
#endif
#if 0
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);
#endif

    return TRUE;    // success
}

BOOL CProjTypeXboxLib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_Lib);
#if 0
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
#endif

    return TRUE;    // success
}

#ifdef XBOXDLL
BOOL CProjTypeXboxDll::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnXbox, BCID_Tool_Linker_XboxDll);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}
#endif

BOOL CProjTypeXboxGeneric::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\toolxbe.h ===
/*
 *
 * toolxbe.h
 *
 * XBE builder tool definition
 *
 */

#include "..\..\ide\pkgs\bld\src\schmztl.h" // the schmooze tool
#include "optnxbe.h"

extern CSchmoozeTool::SchmoozeData g_schdataXbeBuild;

class CXbeBuilderTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CXbeBuilderTool);

public:
	CXbeBuilderTool();

	BOOL HasPrimaryOutput(void) { return TRUE; }

	virtual const SchmoozeData & GetMacs() const {return g_schdataXbeBuild;}

	virtual BOOL IsDelOnRebuildFile ( const CPath *pPath );
	virtual BOOL IsProductFile(const CPath *pPath);

	virtual BOOL PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC);
	virtual BOOL GenerateDependencies(CActionSlob *pAction, FileRegHandle frh, CErrorContext &EC);
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC);
    virtual BOOL AffectsOutput(UINT idProp);
	virtual BOOL GetCommandLines(CActionSlobList & lstActions,
		CPtrList & plCommandLines, DWORD attrib, CErrorContext & EC);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\toolxbcp.h ===
//
// Xbox copy Tool
//
// [colint]
//

#ifndef _INCLUDE_TOOLXBCP_CMN_H
#define _INCLUDE_TOOLXBCP_CMN_H

#include "schmztl.h"			// the CSchmoozeTool class
#include "optnxbcp.h"

#ifdef XBCP

class CXbcpTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CXbcpTool)

	static const SchmoozeData m_XbcpSchmoozeData;
	virtual const SchmoozeData& GetMacs () const 
										{return m_XbcpSchmoozeData;};

public:
	CXbcpTool();

	// -> from CBuildTool
	// Return the files generated by the mecr tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);

 	// Generate command lines for the browser database maker
	virtual BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);
	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
							 DWORD aob, CErrorContext & EC);

#if 0
	virtual DAB DeferredAction(CActionSlob * pAction, CString * pstrAction = (CString *)NULL);
	virtual BOOL SetDeferredAction(CActionSlob * pAction, DAB dab);
#endif

	// Get command line options for this tool
	virtual BOOL GetCommandOptions(CActionSlob * pAction, CString & strOptions);
	// <- from CBuildTool

	virtual BOOL IsConsumableFile ( const CPath *pPath );	
	// Filter function to pick files this item migth make:
	virtual BOOL IsProductFile 	  ( const CPath *pPath );

	// Filter function to pick files to delete on rebuild:
	virtual BOOL IsDelOnRebuildFile	  ( const CPath *pPath );

	// Xbcp cannot handle response files, so we must write our own
	// build rule
	virtual BOOL DoWriteBuildRule 	(CActionSlob * pAction);

	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
	// These methods exist to replace 'IsKindOf(Tool_Class)' functionality
	// they should be removed with a more extensive re-work of the build system.
	// [matthewt]
	virtual BOOL IsMecrTool() {return TRUE;}
	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
};

#endif // XBCP

#endif // _INCLUDE_TOOLXBCP_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\toolxbe.cpp ===
/*
 *
 * toolxbe.cpp
 *
 * Image builder tool
 *
 */

#include "stdafx.h"
#pragma hdrstop
#include "toolxbe.h"

IMPLEMENT_DYNAMIC(CXbeBuilderTool, CSchmoozeTool)

CSchmoozeTool::SchmoozeData g_schdataXbeBuild =
{
		    _TEXT ("XBE"),		 		//pszExeMacro;
		    _TEXT ("XBE_FLAGS"),  		//pszFlagsMacro;
			_TEXT (""),						//pszSpecialFlags;
		    _TEXT ("XBE_OBJS"),			//pszConsumeMacro;
			_TEXT (""),				//pszSpecialConsume;
		    _TEXT (" $(XBE)"),			//pszExeMacroEx;
		    _TEXT (" $(XBE_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (""),						//pszSpecialFlagsEx;
		    _TEXT (" $(XBE_OBJS)"), 		//pszConsumeMacroEx;
			_TEXT (""),			//pszSpecialConsumeEx;
		    _TEXT("xbe"),		//pszProductExtensions;
		    _TEXT("xbe"), //pszDelOnRebuildExtensions;
};

CXbeBuilderTool::CXbeBuilderTool()
{
	m_strToolExeName = _TEXT("imagebld.exe");
	m_nIDName = IDS_XBEBUILD_TOOL;
	m_nIDUIName = IDS_XBEBUILD_TOOL_UI;
	m_strToolInput = _TEXT("*.exe;*.dll");
	m_strToolPrefix = _TEXT("XBE");
	m_nOrder = 1;
}

BOOL CXbeBuilderTool::GenerateDependencies(CActionSlob *pAction, FileRegHandle frh, CErrorContext &EC)
{
	return TRUE;
}

BOOL CXbeBuilderTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while(posAction != NULL) {
		CActionSlob *pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem *pItem = pAction->m_pItem;

		if(type & AOGO_Primary) {
			CString strName;

			CDir *pDir = &pItem->GetProject()->GetWorkspaceDir();

			/* Find the output XBE name */
			if(pItem->GetStrProp(MapLogical(P_XbeName), strName) != valid)
				strName = "";

			CPath path;

			if(!path.CreateFromDirAndFilename(*pDir, strName) ||
					!pAction->AddOutput(&path))
				return FALSE;
		}

		/* We have no other file output types */
	}

	return TRUE;
}

BOOL CXbeBuilderTool::AffectsOutput(UINT idPropL)
{
    return idPropL == P_XbeName;
}

BOOL CXbeBuilderTool::GetCommandLines(CActionSlobList & lstActions,
	CPtrList & plCommandLines, DWORD attrib, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();

	while(posAction != NULL) {
		CActionSlob *pAction = (CActionSlob*)lstActions.GetNext(posAction);
		CProjItem *pItem = pAction->Item();
		CString strCmdLine;

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		/* Start with the options */
		if(!pAction->GetCommandOptions(strCmdLine))
			return FALSE;
		ReplaceEnvVars(strCmdLine);

		/* Now add our inputs */
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		FileRegHandle frhInput;
		pset->InitFrhEnum();
		CString strInput;
		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();

			// quote this input and make relative to project directory?
			pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE);
			// If GetRelativeName failed, it's probably because the two
			// paths are on different drives, so we just can't make a 
			// relative path.  In this case, however, pPath must contain
			// at least a drive letter (and will probably be a full path)
			// Even if relativization fails, the string will still be quoted

			strCmdLine += _T('\n');
			strCmdLine += strInput;
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
		}
		strCmdLine += _T('\n');

		// may create a tmp. file if cmdline too long
		if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
			return FALSE;	// error

		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddHead(strCmdLine);

		// our description
		CString strDescription;
		strDescription.LoadString(IDS_DESC_XBEBUILD);
		pCmdLine->slDescriptions.AddHead(strDescription);
		pCmdLine->nProcessor = 1;

		plCommandLines.AddTail(pCmdLine);
	}
	return TRUE;
}

BOOL CXbeBuilderTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return TRUE;
}

BOOL CXbeBuilderTool::IsProductFile(const CPath *pPath)
{
	return FileNameMatchesExtension (pPath, g_schdataXbeBuild.pszProductExtensions);
}

BOOL CXbeBuilderTool::IsDelOnRebuildFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, g_schdataXbeBuild.pszDelOnRebuildExtensions);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbox.cpp ===
//
// Xbox C/C++ AddOn
//
// Xbox Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

#include "stdafx.h" 
#include <afxdllxx.h>	// our modified version of afxdllx.h

#include <initguid.h>
#include <bldapi.h>
#include <bldguid.h>

// add-on's MFC extension DLL information struct.
static AFX_EXTENSION_MODULE extensionDLL = {NULL, NULL};

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// our components
#include "platxbox.h"

#include "xbxtoolc.h"
#include "xbxtooll.h"
#include "toolxbe.h"
#include "toolxbcp.h"


class CXboxCAddOn : public CPackage
{
public:
	CXboxCAddOn();

	// register the build system components for this platform
	BOOL DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id);

	virtual DWORD GetIdRange(RANGE_TYPE rt);

private:
	WORD wpkgid;
};

CXboxCAddOn::CXboxCAddOn()
	// o instance
	// o handle to window
	// o package id (* do not use *)
	// o command-table
	// o index into cmdtable
	: CPackage(extensionDLL.hModule, 0, 0)
{
}


BOOL CXboxCAddOn::DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD bsc_id)
{
	wpkgid = pcompmgr->GenerateBldSysCompPackageId((TCHAR *)szAddOnXbox);

    DWORD bsc_idXboxPlatform = GenerateComponentId(wpkgid, BCID_Platform_Xbox);

	// C++ installed?
	static BOOL fGotCPP = TRUE;
#if 0	// avoid loading DEVCPP package for no reason
	if( !fGotCPP ){
		LPBUILDSYSTEM pBldSysIFace;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace)));
		fGotCPP = (pBldSysIFace->LanguageSupported(CPlusPlus) == S_OK);
		ASSERT(fGotCPP);
		pBldSysIFace->Release();
	}	
#endif
	CPlatform *pPlat;
	// what is the hook?
	switch (blc_type)
	{
		case BLC_Platform:
			pPlat = new CPlatform(&g_PlatformInfoXbox);
			pcompmgr->RegisterBldSysComp(pPlat, bsc_idXboxPlatform);
			break;

		case BLC_TargetType:
			if (bsc_id == bsc_idXboxPlatform){
				// our Xbox project types
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxExe);
#ifdef XBOXDLL
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxDll);
#endif
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxLib);
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxGeneric);
			}
			break;

		case BLC_Tool:
		{
			DWORD type = pcompmgr->BldSysCompType(bsc_id);

			// for the platform?
			if (type == BLC_Platform)
			{
				// yes
				// only for the Xbox platform!
				if (bsc_id == bsc_idXboxPlatform){
					// our Xbox tools
					if (fGotCPP)	// install C/C++ compiler only if have language
						pcompmgr->RegisterBldSysComp(new CCCompilerXboxTool,
													 GenerateComponentId(wpkgid, BCID_Tool_Compiler_Xbox));
					pcompmgr->RegisterBldSysComp(new CLinkerXboxExeTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Linker_XboxExe));
#ifdef XBOXDLL
					pcompmgr->RegisterBldSysComp(new CLinkerXboxDllTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Linker_XboxDll));
#endif
					pcompmgr->RegisterBldSysComp(new CXbeBuilderTool,
												 GenerateComponentId(wpkgid, BCID_Tool_XbeBuilder));
#ifdef XBCP
					pcompmgr->RegisterBldSysComp(new CXbcpTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Xbcp));
#endif
				}
			break;
			}
			// for a target type?
			else if (fGotCPP && type == BLC_TargetType)	// install C/C++ compiler only if have language
			{		   
				// yes
				CBldSysCmp * pcomp;
				VERIFY(pcompmgr->LookupBldSysComp(bsc_id, pcomp));

				// only for the Xbox platform!
				if (pcomp->RelatedCompId() != bsc_idXboxPlatform)	break;

				if (((CProjType *)pcomp)->GetUniqueTypeId() == CProjType::generic)	break;

				// add our Xbox C/C++ compiler tool to these target types
				((CProjType *)pcomp)->AddTool(wpkgid, BCID_Tool_Compiler_Xbox);
			}
			break;
		}

		case BLC_OptionHdlr:
			// only for the Xbox platform!
			if (bsc_id == bsc_idXboxPlatform){
				// our Xbox option handlers
				if (fGotCPP)	// install C/C++ compiler only if have language
					pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(CompilerXbox));

				pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(XbeBuilder));
				pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(LinkerXboxExe));
#ifdef XBOXDLL
				pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(LinkerXboxDll));
#endif
#ifdef XBCP
				pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(Xbcp));
#endif
			}
			break;

		case BLC_Scanner:
			break;

		default:
			break;
	}

	// nothing left to register
	return FALSE;
}

DWORD CXboxCAddOn::GetIdRange(RANGE_TYPE rt)
{
	switch (rt)
	{
		case MIN_RESOURCE:
		case MIN_STRING:
			return MIN_POWERPC_RESOURCE_ID;
			
		case MAX_RESOURCE:
		case MAX_STRING:
			return MAX_X86_RESOURCE_ID;
	}

	return CPackage::GetIdRange(rt);
}






// package entry/exit routines

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;

extern "C" BOOL APIENTRY RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		if (!IsShellDefFileVersion(SHELL_DEFFILE_VERSION))
			return(FALSE);
	}
	return(ExtRawDllMain(hInstance, dwReason, lpReserved));
}

extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hInstance);

		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory here,
		//   use the TRACE or ASSERT macros or call MessageBox
		if (!AfxInitExtensionModule(extensionDLL, hInstance))
			return 0;

		// This adds our DLL to the MFC maintained list of "AFX
		// Extension DLLs" which is used by serialization functions
		// and resource loading...  This will be deleted by MFC in
		// the AfxTermExtensionModule function.
		new CDynLinkLibrary(extensionDLL);

		// rest of init now happens in InitPackage
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}

	return TRUE;   // ok
}

extern "C" BOOL PASCAL AFX_EXPORT InitPackage(HWND hWndShell)
{
	// register this package
	theApp.RegisterPackage(new CXboxCAddOn);	  

	// other initialization
	return TRUE;	// init'ed ok
}

extern "C" void PASCAL AFX_EXPORT ExitPackage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbox.h ===
//
// Xbox C/C++ AddOn
//
// Xbox Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

// platforms, tools, option handlers provided by this module

// add-on's name
// HEY! if you change this, change devblg.pkg:project.cpp as well
#define szAddOnXbox "Microsoft Xbox C/C++ v1.0"

// our 'Xbox' build system components

#define BCID_Platform_Xbox			5

#define BCID_OptHdlr_Compiler_Xbox	520
#define BCID_OptHdlr_Linker_XboxExe	521
#define BCID_OptHdlr_Linker_XboxDll	522
// HEY! if you change this, change devblg.pkg:project.cpp as well
#define BCID_OptHdlr_XbeBuilder     523
#define BCID_OptHdlr_Xbcp           524

#define BCID_Tool_Compiler_Xbox		540
#define BCID_Tool_Linker_XboxExe	541
#define BCID_Tool_Linker_XboxDll	542
#define BCID_Tool_XbeBuilder        543
#define BCID_Tool_Xbcp              544

#define BCID_ProjType_XboxExe		560
#define BCID_ProjType_XboxDll		561
#define BCID_ProjType_XboxCon		562
#define BCID_ProjType_XboxLib		563
#define BCID_ProjType_XboxGeneric	564
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxoptnl.h ===
//
// Xbox Linker Tool Options
//
// [colint]
//

#ifndef _INCLUDE_OPTNLINK_XBOX_H
#define _INCLUDE_OPTNLINK_XBOX_H

#include "projprop.h"			// our option property ids
#include "prjoptn.h"			// macros used to decl/defn our tables
#include "..\..\ide\pkgs\bld\src\optnlink.h"	// our base option handler, the NT Linker 

//-----------------------------------------------
// our ption property page
//-----------------------------------------------

extern CRuntimeClass * g_linkXboxExeTabs[];
extern CRuntimeClass * g_linkXboxDllTabs[];

//----------------------------------------------------------------
// our Xbox Exe linker option data
//----------------------------------------------------------------

// someday we'll subclass the core linker's option handler to make
// GetFakeDirProp work right in our cases

// Xbox linker option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerXboxExe, /* name */
	szAddOnXbox, BCID_OptHdlr_Linker_XboxExe, /* Xbox linker option handler */
	szAddOnXbox, BCID_Tool_Linker_XboxExe, /* Xbox linker tool */
	szAddOnGeneric, BCID_OptHdlr_Linker /* base generic linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_linkXboxExeTabs;}

	UINT GetFakePathDirProp(UINT idProp);
#if 0
	virtual GPT GetDefStrProp(UINT idProp, CString &val);
#endif

END_OPTHDLR()

#if 0
#define P_XbeName				0x1000

#define IDOPT_XBENAME           IDOPT_BASE

class CLinkerXboxExePage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerXboxExePage)
	DECLARE_IDE_CONTROL_MAP()
};
#endif

//----------------------------------------------------------------
// our Xbox Dll/Lib linker option data
//----------------------------------------------------------------

#ifdef XBOXDLL
// Xbox compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerXboxDll, /* name */
	szAddOnXbox, BCID_OptHdlr_Linker_XboxDll, /* Xbox linker option handler */
	szAddOnXbox, BCID_Tool_Linker_XboxDll, /* Xbox linker tool */
	szAddOnGeneric, BCID_OptHdlr_Linker /* base generic linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()
#if 0
public:
	// our option pages
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_linkXboxDllTabs;}
#endif

END_OPTHDLR()
#endif

#endif // _INCLUDE_OPTNCPLR_XBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxoptnl.cpp ===
//
// Xbox Linker Tool Options
//
// [colint]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "xbxoptnl.h"	// our local header file
#include "xbxtooll.h"

//----------------------------------------------------------------
// our Xbox Exe linker option strings
//----------------------------------------------------------------

#if 0
BEGIN_OPTSTR_TABLE(LinkerXboxExe, (UINT)NULL, (UINT)NULL, P_XbeName, P_XbeName, TRUE)
	IDOPT_XBENAME,		"xbe:out:%1",				OPTARGS1(P_XbeName),	single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerXboxExe)
	OPTDEF_STRING(XbeName, "")
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CLinkerXboxExePage, CLinkerPageTab)

CRuntimeClass * g_linkXboxExeTabs[] =
{
	RUNTIME_CLASS(CLinkerXboxExePage),
	(CRuntimeClass *)NULL,
};

BEGIN_IDE_CONTROL_MAP(CLinkerXboxExePage, IDDP_LINKER_XBOXEXE, IDS_CAT_XBEBUILD)
	MAP_EDIT(IDC_XBENAME, P_XbeName)
END_IDE_CONTROL_MAP()

GPT OPTION_HANDLER(LinkerXboxExe)::GetDefStrProp(UINT idProp, CString &val)
{
	GPT gpt;
	UINT nProp = MapActual(idProp);

	if(nProp == P_XbeName)
	{
		UINT idPropNameActual;
		COptionHandler *popthdlr = this;

		/* Figure out which option handler owns P_OutName */
		while(popthdlr->GetDepth() != OHGetDepth(P_OutName))
		{
			popthdlr = popthdlr->GetBaseOptionHandler();
			ASSERT(popthdlr);
			if(!popthdlr)
				return invalid;
		}
		/* Now get the actual prop id for the output name */
		idPropNameActual = popthdlr->MapLogical(P_OutName);

		/* Finally, get the output name */
		CString strOut;
		if(valid != m_pSlob->GetStrProp(popthdlr->MapLogical(P_OutName),
			strOut))
		{
			ASSERT(FALSE);
			val = "";
			return valid;
		}

		/* Turn the name from .exe into .xbe */
		GetXbeFromExe(strOut, val);
		return valid;
	} else {
		ASSERT(FALSE);
		return invalid;
	}
}
#endif

//----------------------------------------------------------------
// our Xbox Dll linker option strings
//----------------------------------------------------------------
#ifdef XBOXDLL
BEGIN_OPTSTR_TABLE(LinkerXboxDll, (UINT)NULL, (UINT)NULL, 0, 0, TRUE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerXboxDll)
END_OPTDEF_MAP()

CRuntimeClass * g_linkXboxDllTabs[] =
{
	(CRuntimeClass *)NULL,
};
#endif

BEGIN_OPTSTR_TABLE(LinkerXboxExe, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, TRUE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerXboxExe)
END_OPTDEF_MAP()

CRuntimeClass * g_linkXboxExeTabs[] =
{
	(CRuntimeClass *)NULL,
};

UINT OPTION_HANDLER(LinkerXboxExe)::GetFakePathDirProp(UINT idProp)
{
	COptionHandler *popthdlrLinker = GetBaseOptionHandler();
	ASSERT(popthdlrLinker);
	/* Find out which linker property we're dealing with */
	UINT idPropL = popthdlrLinker->MapActual(idProp);

	/* For us, the .exe is an intermediate file */
	if (idPropL == P_OutName)
		return P_OutDirs_Intermediate;

	return popthdlrLinker->GetFakePathDirProp(idProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxoptnc.cpp ===
//
// Xbox Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "xbxoptnc.h"	// our local header file

//----------------------------------------------------------------
// our Xbox compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerXbox, (UINT)NULL, (UINT)NULL, P_CallConv, P_Thread, TRUE)
	IDOPT_CALLCONV,		"G%{d|r|z}1",				OPTARGS1(P_CallConv),					single,
	IDOPT_BYTE,			"Zp%{2|4|8|16|[1]}1",		OPTARGS1(P_ByteAlign),					single,
	IDOPT_THREAD,		"M%{Ld|Td|L|T}1",	OPTARGS1(P_Thread),						single,

// compatibility with VC++ 1.x compiler options, we'll read them
// in then nuke them ;-)
	IDOPT_FLOATPOINT,	"FP%{i87|i|a|c87|c}1",		OPTARGS1(P_FloatPoint),					single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerXbox)
	OPTDEF_INT(CallConv, 1)
	OPTDEF_INT(ByteAlign, 3)
	OPTDEF_INT(Thread, 4)
	OPTDEF_INT(FloatPoint, -1)
END_OPTDEF_MAP()


DEFINE_LOCALIZED_ENUM(CallConvEnum)
	LOCALIZED_ENUM_ENTRY(IDS_CallConv0 /*"__cdecl *"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_CallConv1 /*"__fastcall"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_CallConv2 /*"__stdcall"*/, 3)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(ByteAlignEnum)
	LOCALIZED_ENUM_ENTRY(IDS_ByteAlign0 /*"1 Byte"*/, 5)
	LOCALIZED_ENUM_ENTRY(IDS_ByteAlign1 /*"2 Bytes"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_ByteAlign2 /*"4 Bytes"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_ByteAlign3 /*"8 Bytes *"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_ByteAlign4 /*"16 Bytes"*/, 4)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(ThreadEnum)
	LOCALIZED_ENUM_ENTRY(IDS_Thread0 /*"Single-threaded (libcmt.lib)"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_Thread0d /*"Debug Single-threaded (libcmt.lib)"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_Thread1 /*"Multithreaded (libcmt.lib)"*/, 4)
	LOCALIZED_ENUM_ENTRY(IDS_Thread1d /*"Debug Multithreaded (libcmtd.lib)"*/, 2)
END_LOCALIZED_ENUM_LIST()
	
IMPLEMENT_DYNCREATE(CCompilerXboxPage, CCompilerPageTab)

CRuntimeClass * g_cplrXboxTabs[] =
{
	RUNTIME_CLASS (CCompilerXboxPage),
	(CRuntimeClass *)NULL,
};


BEGIN_IDE_CONTROL_MAP(CCompilerXboxPage, IDDP_COMPILER_XBOX, IDS_CAT_CODEGEN)
	MAP_COMBO_LIST(IDC_CALLCONV, P_CallConv, CallConvEnum)
	MAP_COMBO_LIST(IDC_BYTE, P_ByteAlign, ByteAlignEnum)
	MAP_COMBO_LIST(IDC_THREAD, P_Thread, ThreadEnum)
END_IDE_CONTROL_MAP()

// compiler tool option default map 'faking'
BOOL OPTION_HANDLER(CompilerXbox)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_Thread);
}


GPT OPTION_HANDLER(CompilerXbox)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OPTION_HANDLER(CompilerXbox)::FormFakeIntProp(UINT idProp, int & nVal)
{
	UINT idPropL = MapActual(idProp);

	// should not call this if it is not a fake property
	ASSERT (IsFakeProp (idProp)) ;

	BOOL bUseDebugLibs = FALSE;
	((CProjItem *)m_pSlob)->GetIntProp(P_UseDebugLibs, bUseDebugLibs);

	if (bUseDebugLibs)
		{
		nVal = 2;   //MTd
		}
	else
		{
		nVal = 4;   //MT
		}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxoptnc.h ===
//
// Xbox Compiler Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNCPLR_XBOX_H
#define _INCLUDE_OPTNCPLR_XBOX_H

#include "projprop.h"			// our option property ids
#include "prjoptn.h"			// macros used to decl/defn our tables
#include "..\..\ide\pkgs\bld\src\optncplr.h"	// our base option handler, the Common Compiler

//-----------------------------------------------
// our option property page
//-----------------------------------------------

extern CRuntimeClass * g_cplrXboxTabs[];

//----------------------------------------------------------------
// our Xbox compiler option data
//----------------------------------------------------------------

// Xbox compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	CompilerXbox, /* name */
	szAddOnXbox, BCID_OptHdlr_Compiler_Xbox, /* Xbox compiler option handler */
	szAddOnXbox, BCID_Tool_Compiler_Xbox, /* Xbox compiler tool */
	szAddOnGeneric, BCID_OptHdlr_Compiler /* base generic compiler option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_cplrXboxTabs;}

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' int prop
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

private:
	// form a 'fake' string prop
	virtual void FormFakeIntProp(UINT idProp, int & nVal);

END_OPTHDLR()

// Xbox compiler tool properties
#define P_CallConv						0x1000
#define P_ByteAlign				   		0x1001
#define P_FloatPoint					0x1002
#define P_Thread						0x1003

// Xbox compiler tool options (option ids)
#define IDOPT_CPUX86					IDOPT_BASE + 0
#define IDOPT_CALLCONV					IDOPT_BASE + 1
#define IDOPT_BYTE						IDOPT_BASE + 2
#define IDOPT_FLOATPOINT				IDOPT_BASE + 3
#define IDOPT_THREAD					IDOPT_BASE + 4

class CCompilerXboxPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerXboxPage)
	DECLARE_IDE_CONTROL_MAP()
};

#endif // _INCLUDE_OPTNCPLR_XBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxtoolc.cpp ===
//
// Xbox Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "xbxtoolc.h"	// our local header file

IMPLEMENT_DYNAMIC ( CCCompilerXboxTool, CCCompilerNTTool )

static char rgchVc70[] = "vc70";

CCCompilerXboxTool::CCCompilerXboxTool() : CCCompilerNTTool()
{
	m_strToolExeName = _TEXT("cl.exe");
	m_nIDName = IDS_XBOXCOMPILER32_TOOL;
	m_nIDUIName = IDS_XBOXCOMPILER32_TOOL_UI;
	m_MrSupportLevel = Full;
}

//////////////////////////////////////////////////////////////////////////////
// Default tool options for the Xbox compiler tool
BOOL CCCompilerXboxTool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	// are we a mode we can handle?
	ASSERT(mode == MOB_Debug || mode == MOB_Release);
	
	CString strPart; 

	// Our common tool options
	VERIFY(strOption.LoadString(IDS_XBOX_CPLR_COMMON));

	// Our mode tool options
 	VERIFY(strPart.LoadString(mode == MOB_Debug ? IDS_XBOX_CPLR_DBG : IDS_XBOX_CPLR_REL));
	strOption += _T(' '); strOption += strPart;

	// Return appropriate tool options according to the attributes
	// of the target type
	UINT nIDAttrib = (UINT)-1;

    // EXE options get added for all projects
#if 0
	if (attrib & ImageExe)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_XBOXEXE_CPLR_DBG : IDS_XBOXEXE_CPLR_REL;
	}
#endif
    nIDAttrib = mode == MOB_Debug ? IDS_XBOXEXE_CPLR_DBG : IDS_XBOXEXE_CPLR_REL;

	// Our attribute tool options
	if (nIDAttrib != (UINT)-1)
	{
		VERIFY(strPart.LoadString(nIDAttrib));
		strOption += _T(' '); strOption += strPart;
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the compiler tool
BOOL CCCompilerXboxTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->Item();

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);
		CDir * pDir = &pProject->GetWorkspaceDir();

		// object files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Obj), _TEXT(".obj"), pDir)){
			ASSERT(FALSE);
			return( FALSE );
		}

		// source browser files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Sbr), _TEXT(".sbr"), pDir, (TCHAR *)NULL, MapLogical(P_GenBrowserInfo))){
			ASSERT(FALSE);
			return( FALSE );
		}
				
		// pdb files (both .pdb and .idb)
		// P_DebugInfo == 3 is /Zi
		//
		int iDebugInfo;
		if ((pItem->GetIntProp (MapLogical(P_DebugInfo), iDebugInfo) == valid) && iDebugInfo >= DebugInfoPdb)
		{
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".pdb"), pDir, rgchVc70, (UINT)-1 /* no enable id */, FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return( FALSE );
			}
		}
		
		// Add idb for /Gm.
		int iMr,iFd;
		if ((pItem->GetIntProp( MapLogical(P_Enable_MR), iMr) == valid) && iMr ){
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, rgchVc70,  MapLogical(P_Enable_MR), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}
		else if ((pItem->GetIntProp( MapLogical(P_Enable_FD), iFd) == valid) && iFd )
		{
			// Add idb for /FD.
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, rgchVc70,  MapLogical(P_Enable_FD), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}

		// check to see if this file produces or uses a PCH file....
		// get the location of of the /Fp setting
		CPath pathPch;
		BOOL bval;

		// clear the .pch file dep. from the source deps...
		CFileRegSet * pfrs = pAction->GetSourceDep();
		FileRegHandle frh;

		pfrs->InitFrhEnum();
		while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frh)->GetFilePath();
			if (_tcsicmp(pPath->GetExtension(), _TEXT(".pch")) == 0)
			{
				// remove the .pch as a source dep.
				if (!pAction->RemoveSourceDep(frh))
					ASSERT(FALSE);
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				break;	// done!
			}
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
		}

		CString strPch;
		if ((pItem->GetStrProp(MapLogical(P_PchDefaultName), strPch) != valid) || strPch.IsEmpty())
			continue;	// no pch name....
			
		// add a possible .pch file dep.
		if ((pItem->GetIntProp(MapLogical(P_PchCreate), bval) == valid) && bval)
		{
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
				if (!pAction->AddOutput(&pathPch))
					ASSERT(FALSE);
		}
		else if ((pItem->GetIntProp(MapLogical(P_PchUse), bval) == valid) && bval)
		{
			// add the .pch as a source dep.
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
			{
				CString strPch = (const TCHAR *)pathPch;
				if (!pAction->AddSourceDep(strPch))
					ASSERT(FALSE);
			}
		}
	}

	return TRUE; // success
}

#if 0
///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Xbox options are ok to use/not use MFC
BOOL CCCompilerXboxTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_Thread), ThreadForUsingMFC(pProjItem, iUseMFC));

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
#endif

#if 0
// This is our first OLE compiler tool.
COLECompilerTool::COLECompilerTool( void ){
};


BEGIN_INTERFACE_MAP(COLECompilerTool,CCmdTarget)
    INTERFACE_PART(COLECompilerTool, IID_IBuildTool, Compiler)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP_(ULONG) COLECompilerTool::XCompiler::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COLECompilerTool::XCompiler::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COLECompilerTool::XCompiler::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}
/////////////////////////////////////////////////////////////////////////
// IBuildTool

STDMETHODIMP COLECompilerTool::XCompiler::IsCollectorTool(void)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GetID(UINT *pId)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	*pId = NULL;
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::Filter(LPBUILDFILE pFile)
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	const CPath *pPath = pFile->GetFilePath();
	if( FileNameMatchesExtension( pPath, "*.cpp;*.c" ) )
		return S_OK;

	return S_FALSE;
}

STDMETHODIMP COLECompilerTool::XCompiler::PerformBuild( int type, int stage,LPENUMBSACTIONS pActions, int *result )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
		{
			// need to rebuild?

			if (type == TOB_Clean)
			{
				// delete our .pch on re-build
				// Only deletes if AutoPch. In that case, we need to walk all the files to be compiled,
				// possibly deleting a different header for each file. In the standard case where you have
				// one file that creates the pch and others use it, we don;t need to delete; compiling the
				// file that creates it will rebuild the pch file. bobz 9/5/95

				LPBSACTION pAction[10];
				ULONG nGot = 10;
				while( nGot == 10 ){
					pActions->Next( 10, pAction, &nGot );
					ULONG i=0;
					while ( i < nGot ){
						// deal with pAction[i]
						pAction[i]->Release();
						i++;
					}
				}
			}
			else if( type == TOB_Build )
			{
				// delete the .obj file if we think we should have a .pdb and we don't
				LPBSACTION pAction[10];
				ULONG nGot = 10;
				while( nGot == 10 ){
					pActions->Next( 10, pAction, &nGot );
					ULONG i=0;
					while ( i < nGot ){
						LPBUILDFILE    frh;
						LPBUILDFILESET pfrs;
						pAction[i]->GetOutputs( &pfrs );
/*
						pfrs->InitEnum();
						while ( frh = pfrs->Next() )
						{
							LPCOLESTR pPath = frh->GetFilePath();
							if (_tcsicmp(pPath->GetExtension(), _TEXT(".pdb")) == 0)
							{
								if (!pPath->ExistsOnDisk())
								{
									CProject *pProject = pAction->Item()->GetProject();
									ASSERT(pProject != (CProject *)NULL);
	
									if (GetItemOutputFile(pAction->Item(), MapLogical(P_OutputDir_Obj), frh, _TEXT(".obj"), &pProject->GetWorkspaceDir()))
										if (!g_buildengine.DeleteFile(frh, EC) && !(aob & AOB_IgnoreErrors))
											act = ACT_Error;	// failure
								}
								break;	// done!
							}
						}
*/
						pAction[i]->Release();
						i++;
					}
				}
			}
			break;
		}

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GenerateCommandLines( LPENUMBSACTIONS pActions, CStringList &slCommandLines, CStringList &slDescriptions )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_COMPILING));

	CString strCmdLine;

	LPBSACTION pAction[10];
	ULONG nGot = 10;
	while( nGot == 10 ){
		pActions->Next( 10, pAction, &nGot );
		ULONG i=0;
		while ( i < nGot ){

			LPBUILDFILE pFile;
			pAction[i]->GetFile(&pFile);
			// ActionState as = pAction[i]->m_state;
	
			// strFilePath = pFile->GetFilePath();
			CString strFilePath = (const TCHAR *)*(pFile->GetFilePath());
	
			//if (!pAction->GetCommandOptions(str))
			//	return FALSE;
			CString strOptions = "/c";
	
			// our command-line of form,
			// '<exe> <options> "<input-file>"'
			strCmdLine = "cl.exe";
			strCmdLine += _TEXT(" ");
			strCmdLine += strOptions;
			strCmdLine += _TEXT(" \"");
			strCmdLine += strFilePath;
			strCmdLine += _TEXT("\"");
	
			slCommandLines.AddHead(strCmdLine);
	
			// our description
			slDescriptions.AddHead(strDescription);
			pAction[i]->Release();
			i++;
		}
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GenerateOutputs( LPENUMBSACTIONS pActions )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);

	LPBSACTION pAction[10];
	ULONG nGot = 10;
	while( nGot == 10 ){
		pActions->Next( 10, pAction, &nGot );
		ULONG i=0;
		while ( i < nGot ){
			LPBUILDFILE pFile;
			pAction[i]->GetFile( &pFile );
	
			// object files
			CPath path = *(pFile->GetFilePath());
			path.ChangeExtension(_TEXT(".obj"));
			// pAction[i]->SetOutput( &path );
			pAction[i]->Release();
			i++;
		}
	}

	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::GetDependencies( LPENUMBSACTIONS )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::EnumOptionStrings( LPENUMOPTIONSTRINGS * )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}

STDMETHODIMP COLECompilerTool::XCompiler::EnumOptionTypes( LPENUMOPTIONTYPES * )
{
	METHOD_PROLOGUE_EX(COLECompilerTool, Compiler);
	return NOERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxtoolc.h ===
//
// Intelx86 Compiler Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLCPLR_Xbox_H
#define _INCLUDE_TOOLCPLR_Xbox_H

#include "oletool.h"
#include "projtool.h"			// the CBuildTool classes
#include "..\..\ide\pkgs\bld\src\toolcplr.h"	// our COMMON compiler tool
#include "xbxoptnc.h"			// our Xbox compiler tool options

class CCCompilerXboxTool : public CCCompilerNTTool
{
	DECLARE_DYNAMIC (CCCompilerXboxTool)

public:
	CCCompilerXboxTool();

	// Default tool options for the Intelx86 compiler tool
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption);

    // generate Xbox-compiler-specific file list
    virtual BOOL GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC);

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	//virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#if 0
class COLECompilerTool : public CCmdTarget
{
public:
	COLECompilerTool();
protected:
	// IBUILDTOOL
	BEGIN_INTERFACE_PART(Compiler, IBuildTool)
		INIT_INTERFACE_PART(COLECompilerTool, Compiler)
		STDMETHOD(IsCollectorTool)(void);
		STDMETHOD(Filter)(LPBUILDFILE);
		STDMETHOD(PerformBuild)( int type, int stage,LPENUMBSACTIONS, int *result );
		STDMETHOD(GenerateCommandLines)( LPENUMBSACTIONS, CStringList &, CStringList & );
		STDMETHOD(GenerateOutputs)( LPENUMBSACTIONS );
		STDMETHOD(GetDependencies)( LPENUMBSACTIONS );
		STDMETHOD(EnumOptionStrings)( LPENUMOPTIONSTRINGS * );
		STDMETHOD(EnumOptionTypes)( LPENUMOPTIONTYPES * );
		STDMETHOD(GetID)( UINT * );
	END_INTERFACE_PART(Compiler)

	DECLARE_INTERFACE_MAP()

};
#endif


#endif // _INCLUDE_TOOLCPLR_Xbox_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\dbg_res\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by VPROJDBG.RC
//
#define IDS_PROJINFO                    16517
#define IDDP_PROJINFO                   16517
#define IDC_D_TRG_LISTBOX               19901
#define IDC_D_PROPS_LISTBOX             19902
#define IDC_D_PROP_TYPE                 19903
#define IDC_D_PROP_VALUE                19904
#define IDC_D_DEFAULT_BAG               19905
#define IDC_D_BASE_BAG                  19906

// V3TOOLS build - commenting out because defined elsewhere in afxres.h
// #define IDC_STATIC			-1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        19905
#define _APS_NEXT_COMMAND_VALUE         19905
#define _APS_NEXT_CONTROL_VALUE         19907
#define _APS_NEXT_SYMED_VALUE           19905
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxtooll.h ===
//
// Xbox Linker Tool
//
// [colint]
//

#ifndef _INCLUDE_TOOLLINK_Xbox_H
#define _INCLUDE_TOOLLINK_Xbox_H

#include "..\..\ide\pkgs\bld\src\toollink.h"	// our COMMON compiler tool
#include "xbxoptnl.h"			// our Xbox compiler tool options

class CLinkerXboxExeTool : public CLinkerTool
{
	DECLARE_DYNAMIC (CLinkerXboxExeTool)

public:
	CLinkerXboxExeTool();

    //BOOL GetCommandLines(CActionSlobList&, CPtrList&, DWORD, CErrorContext&);
	BOOL HasPrimaryOutput(void) { return FALSE; }

	// Xbox UI for specific tool options
	// FUTURE:	
};

#ifdef XBOXDLL
class CLinkerXboxDllTool: public CLinkerTool
{
	DECLARE_DYNAMIC (CLinkerXboxDllTool)

public:
	CLinkerXboxDllTool();
};
#endif

void GetXbeFromExe(CString &, CString &);

#endif // _INCLUDE_TOOLLINK_Xbox_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autocfgs.cpp ===
// AutoCfgs.cpp : implementation file
//

#include "stdafx.h"
#include "autocfg.h"
#include "AutoCfgs.h"
#include "autoprj.h"
#include <utilauto.h>
#include <main.h>
#include <ObjModel\blddefs.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAutoConfigurations dual implementation

STDMETHODIMP CAutoConfigurations::XConfigurations::get_Application(IDispatch * FAR* Application)
{
	METHOD_PROLOGUE(CAutoConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Application = pThis->GetApplication();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfigurations::XConfigurations::get_Count(long FAR* Count)
{
	METHOD_PROLOGUE(CAutoConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Count = pThis->GetCount();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfigurations::XConfigurations::get_Parent(IBuildProject FAR* FAR* Parent)
{
	METHOD_PROLOGUE(CAutoConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Parent = (IBuildProject*) pThis->GetParent();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfigurations::XConfigurations::get__NewEnum(IUnknown * FAR* _NewEnum)
{
	METHOD_PROLOGUE(CAutoConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*_NewEnum = pThis->GetNewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfigurations::XConfigurations::Item(VARIANT Index, IConfiguration FAR* FAR* Item)
{
	METHOD_PROLOGUE(CAutoConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Item = (IConfiguration*) pThis->Item(Index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


/////////////////////////////////////////////////////////////////////////////
// CAutoConfigurations

IMPLEMENT_DYNCREATE(CAutoConfigurations, CAutoObj)

CAutoConfigurations::CAutoConfigurations()
{
	EnableDualAutomation();
	m_pPtrlConfigs = NULL;
	m_hBld = NULL;
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoConfigurations::~CAutoConfigurations()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
	g_LinkAutoObjToProject.OnAutoObjDestroyed(this);
}

void CAutoConfigurations::ReleaseConfigsInList()
{
	POSITION pos = m_pPtrlConfigs->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlConfigs->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pDispatch->Release() ;
	}
	m_pPtrlConfigs->RemoveAll();
}
void CAutoConfigurations::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	// Release each individual configuration & the collection
	ReleaseConfigsInList();

	// The collection is in charge of cleaning this up.
	delete m_pPtrlConfigs ;
	m_pPtrlConfigs = NULL;


	CAutoObj::OnFinalRelease();
}

void CAutoConfigurations::AssociatedObjectReleased()
{
	ASSERT (m_hBld != NULL);
	m_hBld = NULL;
}


BEGIN_MESSAGE_MAP(CAutoConfigurations, CAutoObj)
	//{{AFX_MSG_MAP(CAutoConfigurations)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoConfigurations, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoConfigurations)
	DISP_PROPERTY_EX(CAutoConfigurations, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoConfigurations, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoConfigurations, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoConfigurations, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_DEFVALUE(CAutoConfigurations, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoConfigurations, "_NewEnum", DISPID_NEWENUM, GetNewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(CAutoConfigurations, CAutoObj)
 	INTERFACE_PART(CAutoConfigurations, IID_IDispConfigurations, Dispatch)
 	INTERFACE_PART(CAutoConfigurations, IID_IConfigurations, Dispatch)
    DUAL_ERRORINFO_PART(CAutoConfigurations)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoConfigurations, IID_IConfigurations)
DS_IMPLEMENT_ENABLE_DUAL(CAutoConfigurations, Configurations)
DS_DELEGATE_DUAL_INTERFACE(CAutoConfigurations, Configurations)

/////////////////////////////////////////////////////////////////////////////
// CAutoConfigurations message handlers

LPDISPATCH CAutoConfigurations::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

long CAutoConfigurations::GetCount() 
{
	RefreshConfigsInList();
	return m_pPtrlConfigs->GetCount();
}

LPUNKNOWN CAutoConfigurations::GetNewEnum() 
{
	RefreshConfigsInList();
	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlConfigs);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoConfigurations::GetParent() 
{
	if (m_hBld == NULL)
	{
		// This project no longer exists
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_PRJ_NOTEXIST, m_strProject);
		DsThrowOleDispatchException(DS_E_PROJECT_NOT_VALID, (LPCTSTR) strPrompt);
	}

	return CAutoProject::Create(m_hBld, m_strProject)->GetIDispatch(FALSE);
}

LPDISPATCH CAutoConfigurations::Item(const VARIANT FAR& index) 
{
	// Check to see if there isn't a parameter.
	if (index.vt == VT_ERROR)
	{
		// Parameter is optional and is not supplied.
		// Return a pointer to this collection.
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}

	RefreshConfigsInList();

	// Check to see if the parameter is a string
	if (index.vt == VT_BSTR)
	{
		// Parameter is the configuration name
		CString strName(index.bstrVal);

		LPDISPATCH pDispRetConfiguration = NULL;
		POSITION pos = m_pPtrlConfigs->GetHeadPosition();
		while (pos != NULL)
		{
			LPDISPATCH pDispCurrConfiguration = m_pPtrlConfigs->GetNext(pos);
			CAutoConfiguration* pProj = CAutoConfiguration::FromIDispatch((IConfiguration*)pDispCurrConfiguration);
			ASSERT_KINDOF(CAutoConfiguration, pProj);
			if (strName == pProj->m_strName)
			{
				pDispRetConfiguration = pDispCurrConfiguration;
				pDispRetConfiguration->AddRef();
				break;
			}
		}
		return pDispRetConfiguration ;
	}

    // coerce index to VT_I4
	COleVariant coercedIndex(index);
	coercedIndex.ChangeType(VT_I4);
 	IDispatch* pObj = NULL ;
	// Subtract 1 from index, since we expect a 1-based index.
    POSITION pos = m_pPtrlConfigs->FindIndex(coercedIndex.lVal - 1);
    if (pos != NULL)
	{
        pObj = m_pPtrlConfigs->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
    
	ASSERT (pObj != NULL);
	pObj->AddRef();
	return pObj ;
}

CAutoConfigurations* CAutoConfigurations::Create(HBUILDER hBld, LPCTSTR szProject)
{
	// Make a new CAutoConfigurations
	CAutoConfigurations* pConfigs = new CAutoConfigurations;
	pConfigs->m_pPtrlConfigs = new CDispatchList;
	pConfigs->m_hBld = hBld;
	pConfigs->m_strProject = szProject;

	// Enumerate through targets, create a CAutoConfiguration for each,
	//  and put them all in m_pPtrlConfigs.
/*
	if (hBld != NULL)
		pConfigs->RefreshConfigsInList();
	else
		ASSERT(FALSE);
*/
	g_LinkAutoObjToProject.OnAutoObjCreated(pConfigs, hBld);
	return pConfigs;
}


void CAutoConfigurations::RefreshConfigsInList()
{
	ReleaseConfigsInList();

	if (m_hBld == NULL)
	{
		// This project no longer exists
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_PRJ_NOTEXIST, m_strProject);
		DsThrowOleDispatchException(DS_E_PROJECT_NOT_VALID, (LPCTSTR) strPrompt);
	}

	HBLDTARGET hBldTarget;
	CString strTarget;
	g_BldSysIFace.InitTargetEnum(m_hBld);
	while ( (hBldTarget = g_BldSysIFace.GetNextTarget(strTarget, m_hBld)) != NULL )
	{
		CAutoConfiguration* pConfig = 
			CAutoConfiguration::Create(m_hBld, strTarget );

		// Add the new configuration's IDispatch on the end of this
		//  configuration collection's internal pointer list.
		// Don't AddRef pConfig, since it was just created (that implicitly
		//  addrefs it).
		m_pPtrlConfigs->AddTail(pConfig->GetIDispatch(FALSE));
	}
}


// ------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// CAutoDepConfigurations dual implementation

STDMETHODIMP CAutoDepConfigurations::XConfigurations::get_Application(IDispatch * FAR* Application)
{
	METHOD_PROLOGUE(CAutoDepConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Application = pThis->GetApplication();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoDepConfigurations::XConfigurations::get_Count(long FAR* Count)
{
	METHOD_PROLOGUE(CAutoDepConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Count = pThis->GetCount();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoDepConfigurations::XConfigurations::get_Parent(IBuildProject FAR* FAR* Parent)
{
	METHOD_PROLOGUE(CAutoDepConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Parent = (IBuildProject*) pThis->GetParent();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoDepConfigurations::XConfigurations::get__NewEnum(IUnknown * FAR* _NewEnum)
{
	METHOD_PROLOGUE(CAutoDepConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*_NewEnum = pThis->GetNewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoDepConfigurations::XConfigurations::Item(VARIANT Index, IConfiguration FAR* FAR* Item)
{
	METHOD_PROLOGUE(CAutoDepConfigurations, Dispatch)
	
	TRY_DUAL(IID_IConfigurations)
	{
		*Item = (IConfiguration*) pThis->Item(Index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


/////////////////////////////////////////////////////////////////////////////
// CAutoDepConfigurations

IMPLEMENT_DYNCREATE(CAutoDepConfigurations, CAutoObj)

CAutoDepConfigurations::CAutoDepConfigurations()
{
	EnableDualAutomation();
	m_pPtrlConfigs = NULL;
	m_hBld = NULL;
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoDepConfigurations::~CAutoDepConfigurations()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
	g_LinkAutoObjToProject.OnAutoObjDestroyed(this);
}

void CAutoDepConfigurations::ReleaseConfigsInList()
{
	POSITION pos = m_pPtrlConfigs->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlConfigs->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pDispatch->Release() ;
	}
	m_pPtrlConfigs->RemoveAll();
}
void CAutoDepConfigurations::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	// Release each individual configuration & the collection
	ReleaseConfigsInList();

	// The collection is in charge of cleaning this up.
	delete m_pPtrlConfigs ;
	m_pPtrlConfigs = NULL;


	CAutoObj::OnFinalRelease();
}

void CAutoDepConfigurations::AssociatedObjectReleased()
{
	ASSERT (m_hBld != NULL);
	m_hBld = NULL;
}


BEGIN_MESSAGE_MAP(CAutoDepConfigurations, CAutoObj)
	//{{AFX_MSG_MAP(CAutoDepConfigurations)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoDepConfigurations, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoDepConfigurations)
	DISP_PROPERTY_EX(CAutoDepConfigurations, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDepConfigurations, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoDepConfigurations, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoDepConfigurations, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_DEFVALUE(CAutoDepConfigurations, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoDepConfigurations, "_NewEnum", DISPID_NEWENUM, GetNewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(CAutoDepConfigurations, CAutoObj)
 	INTERFACE_PART(CAutoDepConfigurations, IID_IDispConfigurations, Dispatch)
 	INTERFACE_PART(CAutoDepConfigurations, IID_IConfigurations, Dispatch)
    DUAL_ERRORINFO_PART(CAutoDepConfigurations)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoDepConfigurations, IID_IConfigurations)
DS_IMPLEMENT_ENABLE_DUAL(CAutoDepConfigurations, Configurations)
DS_DELEGATE_DUAL_INTERFACE(CAutoDepConfigurations, Configurations)

/////////////////////////////////////////////////////////////////////////////
// CAutoDepConfigurations message handlers

LPDISPATCH CAutoDepConfigurations::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

long CAutoDepConfigurations::GetCount() 
{
	RefreshConfigsInList();
	return m_pPtrlConfigs->GetCount();
}

LPUNKNOWN CAutoDepConfigurations::GetNewEnum() 
{
	RefreshConfigsInList();
	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlConfigs);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoDepConfigurations::GetParent() 
{
	if (m_hBld == NULL)
	{
		// This project no longer exists
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_PRJ_NOTEXIST, m_strProject);
		DsThrowOleDispatchException(DS_E_PROJECT_NOT_VALID, (LPCTSTR) strPrompt);
	}

	return CAutoProject::Create(m_hBld, m_strProject)->GetIDispatch(FALSE);
}

LPDISPATCH CAutoDepConfigurations::Item(const VARIANT FAR& index) 
{
	// Check to see if there isn't a parameter.
	if (index.vt == VT_ERROR)
	{
		// Parameter is optional and is not supplied.
		// Return a pointer to this collection.
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}

	RefreshConfigsInList();

	// Check to see if the parameter is a string
	if (index.vt == VT_BSTR)
	{
		// Parameter is the configuration name
		CString strName(index.bstrVal);

		LPDISPATCH pDispRetConfiguration = NULL;
		POSITION pos = m_pPtrlConfigs->GetHeadPosition();
		while (pos != NULL)
		{
			LPDISPATCH pDispCurrConfiguration = m_pPtrlConfigs->GetNext(pos);
			CAutoConfiguration* pProj = CAutoConfiguration::FromIDispatch((IConfiguration*)pDispCurrConfiguration);
			ASSERT_KINDOF(CAutoConfiguration, pProj);
			if (strName == pProj->m_strName)
			{
				pDispRetConfiguration = pDispCurrConfiguration;
				pDispRetConfiguration->AddRef();
				break;
			}
		}
		return pDispRetConfiguration ;
	}

    // coerce index to VT_I4
	COleVariant coercedIndex(index);
	coercedIndex.ChangeType(VT_I4);
 	IDispatch* pObj = NULL ;
	// Subtract 1 from index, since we expect a 1-based index.
    POSITION pos = m_pPtrlConfigs->FindIndex(coercedIndex.lVal - 1);
    if (pos != NULL)
	{
        pObj = m_pPtrlConfigs->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
    
	ASSERT (pObj != NULL);
	pObj->AddRef();
	return pObj ;
}



void CAutoDepConfigurations::RefreshConfigsInList()
{
	ReleaseConfigsInList();

	if (m_hBld == NULL)
	{
		// This project no longer exists
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_PRJ_NOTEXIST, m_strProject);
		DsThrowOleDispatchException(DS_E_PROJECT_NOT_VALID, (LPCTSTR) strPrompt);
	}

	HPROJDEP hProjDep;
	HBLDTARGET hBldTarget;
	CString strTarget;
	
	CProject* pProject = g_BldSysIFace.CnvHBuilder(m_hBld);
	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig(m_strProject);

	// Find the HFileSet for the parent config.
	CObList lstDepSet;
	POSITION posHDepSet;
	g_BldSysIFace.InitProjectDepEnum(ACTIVE_FILESET,m_hBld,lstDepSet,posHDepSet);
	while ( (hProjDep = g_BldSysIFace.GetNextProjectDep(ACTIVE_FILESET, m_hBld,lstDepSet,posHDepSet)) != NULL )
	{

		// From the proj dep find the target.
		// from the target
		CProjectDependency *pProjDep =(CProjectDependency*)hProjDep;
		CTargetItem * pTarg = pProjDep->GetProjectDep();
		CProject *pDepProject = pTarg->GetProject();
		HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget ((HBUILDER) pDepProject);
		HFILESET hFileSet = g_BldSysIFace.GetFileSet ((HBUILDER) pDepProject, hTarget);
		strTarget.Empty();
		g_BldSysIFace.GetTargetNameFromFileSet (hFileSet, strTarget, (HBUILDER)pProject );
		if( !strTarget.IsEmpty() ){
			// From the HBLDTARGET find the string strTarget
			
			CAutoConfiguration* pConfig = 
				CAutoConfiguration::Create((HBUILDER) pDepProject, strTarget );
	
			// Add the new configuration's IDispatch on the end of this
			//  configuration collection's internal pointer list.
			// Don't AddRef pConfig, since it was just created (that implicitly
			//  addrefs it).
			m_pPtrlConfigs->AddTail(pConfig->GetIDispatch(FALSE));
		}
	}
}


CAutoDepConfigurations* CAutoDepConfigurations::Create(HBUILDER hBld, LPCTSTR szProject)
{
	// Make a new CAutoDepConfigurations
	CAutoDepConfigurations* pConfigs = new CAutoDepConfigurations;
	pConfigs->m_pPtrlConfigs = new CDispatchList;
	pConfigs->m_hBld = hBld;
	pConfigs->m_strProject = szProject;

	// Enumerate through targets, create a CAutoConfiguration for each,
	//  and put them all in m_pPtrlConfigs.
/*
	if (hBld != NULL)
		pConfigs->RefreshConfigsInList();
	else
		ASSERT(FALSE);
*/
	g_LinkAutoObjToProject.OnAutoObjCreated(pConfigs, hBld);
	return pConfigs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\add_ons\xbox\xbxtooll.cpp ===
//
// Xbox Linker Tool
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "xbxtooll.h"	// our local header file

IMPLEMENT_DYNAMIC (CLinkerXboxExeTool, CLinkerTool)
#ifdef XBOXDLL
IMPLEMENT_DYNAMIC (CLinkerXboxDllTool, CLinkerTool)
#endif

CLinkerXboxExeTool::CLinkerXboxExeTool () : CLinkerTool()
{
#if 0
	m_nIDName = IDS_XBOXLINKCOFF_TOOL;
	m_nIDUIName = IDS_XBOXLINKCOFF_TOOL_UI;
#endif
}

#ifdef XBOXDLL
CLinkerXboxDllTool::CLinkerXboxDllTool() : CLinkerTool()
{
	m_nIDName = IDS_XBOXLINKCOFF_TOOL;
	m_nIDUIName = IDS_XBOXLINKCOFF_TOOL_UI;
}
#endif

#if 0
BOOL CLinkerXboxExeTool::GetCommandLines(CActionSlobList &lstActions,
    CPtrList &plCommandLines, DWORD attrib, CErrorContext &EC)
{
	CPtrList plLinker;

	/* First we gather the linker's command lines */
    if(!CLinkerTool::GetCommandLines(lstActions, plLinker, attrib, EC))
        return FALSE;

	/* Now we walk through the linker's command lines and strip out those
	 * options belonging to imagebld, forming a new linker command and a new
	 * imagebld command for each one */
	POSITION posCmd = plLinker.GetHeadPosition();
	while(posCmd != (POSITION)NULL)
	{
		CCmdLine *pclLinker = (CCmdLine *)plLinker.GetNext(posCmd);
		CCmdLine *pclXbe = new CCmdLine;
		POSITION posStr = pclLinker->slCommandLines.GetHeadPosition();
		while(posStr != (POSITION)NULL)
		{
			CString *pstr = (CString *)&pclLinker->slCommandLines.GetNext(posStr);
			CString strXbeCmd;
			CString strDescription;
			int ichOpt, ichEnd;

			/* Draconic, but simplistic */
			pstr->MakeLower();

			/* Look for the linker's /out: parameter to use as imagebld's
			 * input */
			ichOpt = pstr->Find("/out:");
			if(ichOpt < 0)
			{
				/* We can't handle this case, so we'll force an error */
				delete pclXbe;
				return FALSE;
			}
			
			/* We don't want the /out: part */
			ichOpt += 5;
			ichEnd = pstr->Find(' ', ichOpt);
			CString strExe = ichEnd < 0 ? pstr->Mid(ichOpt) :
				pstr->Mid(ichOpt, ichEnd - ichOpt);

			strXbeCmd = strExe + ' ';

			/* Build the default xbe name in case we don't see the option */
			CString strXbe;
			GetXbeFromExe(strExe, strXbe);

			/* Now look for all of the /xbe: parameters */
			while((ichOpt = pstr->Find("/xbe:")) >= 0)
			{
				/* Get the / in there */
				strXbeCmd += '/';
				/* And put in the rest of the option */
				ichEnd = pstr->Find(' ', ichOpt);
				if(ichEnd < 0)
					ichEnd = pstr->GetLength();
				/* If this is the /out option, we can throw away our default
				 * out value */
				if(pstr->Mid(ichOpt + 5, 4) == "out:")
					strXbe = "";
				strXbeCmd += pstr->Mid(ichOpt + 5, ichEnd - (ichOpt + 5)) + ' ';
				/* Take the option out of the linker string */
				pstr->Delete(ichOpt, ichEnd - ichOpt);
			}

			/* Tack on our xbe name if we need to */
			if(!strXbe.IsEmpty())
				strXbeCmd += "/out:" + strXbe;

			/* With all that done, put this string on the imagebld cmd list */
			if (!g_buildengine.FormCmdLine(CString("imagebld.exe"), strXbeCmd, EC))
			{
				delete pclXbe;
				return FALSE;
			}

			strDescription.LoadString(IDS_DESC_XBEBUILD);
			pclXbe->slDescriptions.AddTail(strDescription);
			pclXbe->slCommandLines.AddTail(strXbeCmd);
		}

		/* This command item is out of the way, so flesh out the imagebld
		 * structures and add both the linker and imagebld commands to the
		 * complete list */

		plCommandLines.AddTail(pclLinker);
		plCommandLines.AddTail(pclXbe);
	}

	return TRUE;
}

void GetXbeFromExe(CString &strExe, CString &strXbe)
{
	int ich = strExe.Find(".exe");
	if(ich < 0)
	{
		/* No .exe, so we append .xbe -- inside a terminal quote if
		 * necessary */
		if(strExe.Right(1) == "\"")
			strXbe = strExe.Left(strExe.GetLength() - 1) + ".xbe\"";
		else
			strXbe = strExe + ".xbe";
	}
	else
		/* Replace the .exe with .xbe */
		strXbe = strExe.Left(ich) + ".xbe" + strExe.Mid(ich + 4);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autocfg.cpp ===
// autocfg.cpp : implementation file
//

#include "stdafx.h"
#include "autocfg.h"
#include <ObjModel\appauto.h>
#include <main.h>
#include "autoprj.h"
#include "autocfgs.h"
#include <ObjModel\blddefs.h>
#include "prjconfg.h"
#include "projitem.h"
#include "project.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoConfiguration dual implementation

STDMETHODIMP CAutoConfiguration::XConfiguration::get_Application(IDispatch * FAR* Application)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		*Application = pThis->GetApplication();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoConfiguration::XConfiguration::get__Name(BSTR FAR* _Name)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		*_Name = pThis->GetName();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoConfiguration::XConfiguration::get_Name(BSTR FAR* Name)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		*Name = pThis->GetName();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::get_Parent(IDispatch * FAR* Parent)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		*Parent = pThis->GetParent();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::AddToolSettings(BSTR szTool, BSTR szSettings, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strTool = szTool;
		CString strSettings = szSettings;
		pThis->AddToolSettings(strTool, strSettings, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::RemoveToolSettings(BSTR szTool, BSTR szSettings, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strTool = szTool;
		CString strSettings = szSettings;
		pThis->RemoveToolSettings(strTool, strSettings, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::AddCustomBuildStep(BSTR szCommand, BSTR szOutput, BSTR szDescription, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strCommand = szCommand;
		CString strOutput = szOutput;
		CString strDescription = szDescription;
		pThis->AddCustomBuildStep(strCommand, strOutput, strDescription, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::AddFileSettings(BSTR szFile, BSTR szSettings, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strFile = szFile;
		CString strSettings = szSettings;
		pThis->AddFileSettings(strFile, strSettings, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::RemoveFileSettings(BSTR szFile, BSTR szSettings, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strFile = szFile;
		CString strSettings = szSettings;
		pThis->RemoveFileSettings(strFile, strSettings, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::AddCustomBuildStepToFile(BSTR szFile, BSTR szCommand, BSTR szOutput, BSTR szDescription, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		CString strFile = szFile;
		CString strCommand = szCommand;
		CString strOutput = szOutput;
		CString strDescription = szDescription;
		pThis->AddCustomBuildStepToFile(strFile, strCommand, strOutput, strDescription, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


// REVIEW(kperry): This is an artifact of a poorly thought out feature. The vtable entry can be resued.
STDMETHODIMP CAutoConfiguration::XConfiguration::Reserved11(void)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		return E_NOTIMPL;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::MakeCurrentSettingsDefault( VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		pThis->MakeCurrentSettingsDefault(Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoConfiguration::XConfiguration::get_Configurations(IConfigurations FAR* FAR* Configurations)
{
	METHOD_PROLOGUE(CAutoConfiguration, Dispatch)
	
	TRY_DUAL(IID_IConfiguration)
	{
		
		*Configurations = (IConfigurations*) pThis->GetDependentConfigurations();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}




/////////////////////////////////////////////////////////////////////////////
// CAutoConfiguration

IMPLEMENT_DYNCREATE(CAutoConfiguration, CAutoObj)

CAutoConfiguration::CAutoConfiguration()
{
	EnableDualAutomation();
	
	m_pConfigs = NULL;
	m_hBuilder = NULL;
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoConfiguration::~CAutoConfiguration()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

	g_LinkAutoObjToProject.OnAutoObjDestroyed(this);
}


void CAutoConfiguration::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.
	ASSERT (m_pConfigs != NULL);

	m_pConfigs->Release();
	m_pConfigs = NULL;
	
	CAutoObj::OnFinalRelease();
}

void CAutoConfiguration::AssociatedObjectReleased()
{
	ASSERT (m_hBuilder != NULL);
	m_hBuilder = NULL;
}


BEGIN_MESSAGE_MAP(CAutoConfiguration, CAutoObj)
	//{{AFX_MSG_MAP(CAutoConfiguration)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoConfiguration, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoConfiguration)
	DISP_PROPERTY_EX(CAutoConfiguration, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoConfiguration, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoConfiguration, "AddToolSettings", AddToolSettings, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CAutoConfiguration, "RemoveToolSettings", RemoveToolSettings, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CAutoConfiguration, "AddCustomBuildStep", AddCustomBuildStep, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT)
	DISP_PROPERTY_EX(CAutoConfiguration, "Configurations", GetDependentConfigurations, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoConfiguration, "Reserved11", Reserved11, VT_EMPTY, VTS_NONE )
	DISP_FUNCTION(CAutoConfiguration, "MakeCurrentSettingsDefault", MakeCurrentSettingsDefault, VT_EMPTY, VTS_VARIANT)
//	DISP_FUNCTION(CAutoConfiguration, "Build", Build, VT_EMPTY, VTS_VARIANT)
	DISP_FUNCTION(CAutoConfiguration, "AddFileSettings", AddFileSettings, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CAutoConfiguration, "RemoveFileSettings", RemoveFileSettings, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CAutoConfiguration, "AddCustomBuildStepToFile", AddCustomBuildStepToFile, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR VTS_VARIANT)
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoConfiguration, "Name", DISPID_VALUE, GetName, SetNotSupported, VT_BSTR)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(CAutoConfiguration, CAutoObj)
	INTERFACE_PART(CAutoConfiguration, IID_IDispConfiguration, Dispatch)
	INTERFACE_PART(CAutoConfiguration, IID_IConfiguration, Dispatch)
	DUAL_ERRORINFO_PART(CAutoConfiguration)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoConfiguration, IID_IConfiguration)
DS_IMPLEMENT_ENABLE_DUAL(CAutoConfiguration, Configuration)
DS_DELEGATE_DUAL_INTERFACE(CAutoConfiguration, Configuration)


/////////////////////////////////////////////////////////////////////////////
// CAutoConfiguration message handlers

LPDISPATCH CAutoConfiguration::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

LPDISPATCH CAutoConfiguration::GetParent() 
{
	if (m_hBuilder == NULL)
		ThrowInvalidError();
	CProject* pProj = g_BldSysIFace.CnvHBuilder(m_hBuilder);
	const CPath* pPath = pProj->GetFilePath();
	if (pPath == NULL)
		// No path?  Bogus
		return NULL;

	CString strProjName;
	pPath->GetBaseNameString(strProjName);
	return CAutoProject::Create(m_hBuilder, strProjName)->GetIDispatch(FALSE);
}

BSTR CAutoConfiguration::GetName() 
{
	return m_strName.AllocSysString();
}

CAutoConfiguration* CAutoConfiguration::Create(HBUILDER hBuilder, LPCTSTR szName)
{
	CAutoConfiguration* pConfig = new CAutoConfiguration;
	pConfig->m_strName = szName;
	pConfig->m_hBuilder = hBuilder;
	pConfig->m_nDepth = 0;

	//REVIEW(kperry) name should be name of project I think.
	CAutoDepConfigurations* pConfigs = CAutoDepConfigurations::Create(hBuilder, szName);
	// Don't AddRef pConfigs, since we just created it, and that implicitly
	//  addrefs it.
	pConfig->m_pConfigs = pConfigs->GetIDispatch(FALSE);

	g_LinkAutoObjToProject.OnAutoObjCreated(pConfig, hBuilder);
	return pConfig;
}

void CAutoConfiguration::ThrowInvalidError()
{
	// This configuration is no longer valid
	CString strPrompt;
	AfxFormatString1(strPrompt, IDS_AUTO_CFG_NOTEXIST, m_strName);
	DsThrowOleDispatchException(DS_E_CONFIGURATION_NOT_VALID, (LPCTSTR) strPrompt);
}


void CAutoConfiguration::EnsureBuildable()
{
	if (m_hBuilder == NULL)
		ThrowInvalidError();

	CProject* pProject = g_BldSysIFace.CnvHBuilder(m_hBuilder);
	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig(m_strName);
	CProjType* pProjType = pProject->GetProjType();
	if (pProjType == NULL)
		ThrowInvalidError();

	if (pProject->m_bProjIsExe || !pProjType->IsSupported() 
		|| pProjType->GetPlatform() == NULL 
		|| !pProjType->GetPlatform()->GetBuildable())
	{
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_CFG_NOTSUPPORTED, m_strName);
		DsThrowOleDispatchException(DS_E_CONFIGURATION_NOT_SUPPORTED, (LPCTSTR) strPrompt);
	}
}

HBLDTARGET CAutoConfiguration::GetTarget()
{
	HBLDTARGET hTarget = 0;
	if (m_hBuilder == NULL ||
		(hTarget = g_BldSysIFace.GetTarget(m_strName, m_hBuilder)) == NULL)
	{
		ThrowInvalidError();
	}
	return hTarget;
}

void CAutoConfiguration::AddToolSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved) 
{
	CTempDisableUI tempNoUI;
	HBLDTARGET hTarget = GetTarget();	// Will throw error if invalid
	if (!g_BldSysIFace.SetToolSettings(hTarget, szSettings, szTool,
		TRUE, FALSE, m_hBuilder))
	{
		DsThrowOleDispatchException(DS_E_CANT_ADD_SETTINGS, IDS_AUTO_CANT_ADD_SETTINGS);
	}
}

void CAutoConfiguration::RemoveToolSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved) 
{
	CTempDisableUI tempNoUI;
	HBLDTARGET hTarget = GetTarget();	// Will throw error if invalid

	// [davbr] TEMPORARY (hopefully) FIX FOR DEVSTUDIO 96 BUG 11735.  The real
	//  fix should be made in bldiface.cpp: CBldSysIFace::SetToolSettingsI.
	//  SetToolSettingsI should no longer search for a verbatim occurrence
	//  of the user-supplied settings string in the canonical listing of
	//  all the settings on the tool.  Instead, it should call
	//  g_prjoptengine.ParseString with optbeh having OBAnti (not OBClear)
	//  set.  In other words, erase the entire "if (!fAdd) ... else ..."
	//  clause and always pass the original settings string to ParseString;
	//  simply adjust optbeh based on whether the user is adding or
	//  removing (OBAnti) options.  Unfortunately, I tried this and it
	//  didn't work.  Some settings would get removed correctly, but others
	//  appeared to be misinterpreted while parsing.  All function calls
	//  "succeeded" but the wrong things were happening.  THIS SHOULD BE
	//  FIXED IN THE FUTURE
	//
	// For now, the workaround [HACK] code is HERE, not in bldiface, so only
	//  automation controllers will benefit from it (and no one else
	//  will get screwed if there are problems).  We manually parse
	//  through the settings string finding options and passing them one
	//  by one to SetToolSettings.  We make a special case for /D which
	//  has two common formats (/D_SYMBOL and /D "_SYMBOL"), only one of
	//  which (the latter) will work with SetToolSettings.

	// Make R/W copy of the string on the stack to play with
	int nOrigLength = _tcslen(szSettings);
	LPTSTR szSettingsCopy = (LPTSTR) _alloca(nOrigLength+sizeof(TCHAR));
	_tcscpy(szSettingsCopy, szSettings);

	LPCTSTR szPrefixes = "/-";
	LPTSTR szNext = szSettingsCopy;
	LPTSTR szCurr;
	
	// Judiciously add/remove NULL terminators in the middle of the
	//  string to pick out each option individually, to pass to
	//  bldiface's AddToolSettings.
	while (szNext != NULL)
	{
		szCurr = szNext;

		// Is there a flag after the current one?  If so, temporarily NULL
		//  terminate before next flag.
		int nPos = _tcscspn(szCurr+1, szPrefixes);
		if (nPos + (szCurr+1-szSettingsCopy) >= nOrigLength)
			szNext = NULL;
		else
		{
			szNext = szCurr+1 + nPos;
			*szNext = '\0';
		}

		LPTSTR szStringToPass = szCurr;		// May get modified for special flags

		// SPECIAL CASE: /D flag (don't adjust if we're altering linker
		//  or bscmake settings)
		if (*(szCurr+1) == 'D' && *(szCurr+2) != ' ' && *(szCurr+2) != '"'
			&& _tcsicmp(szTool, "link.exe") && _tcsicmp(szTool, "bscmake.exe"))
		{
			// Convert: /D_SYMBOL -> /D "_SYMBOL".  Allocate new
			//  string on the stack, with extra room for space and two quotes
			szStringToPass = (LPTSTR) _alloca(_tcslen(szCurr) + 4*sizeof(TCHAR));
			_tcscpy(szStringToPass, "/D \"");

			// Length of symbol is distance to nearest space,
			//  minus /D.
			int nSymbolLength = _tcscspn(szCurr+2, " ");

			_tcsncat(szStringToPass, szCurr+2, nSymbolLength);	// append sym
			_tcscat(szStringToPass, "\"");						// append final "
		}

		if (!g_BldSysIFace.SetToolSettings(hTarget, szStringToPass, szTool,
			FALSE, FALSE, m_hBuilder))
		{
			DsThrowOleDispatchException(DS_E_CANT_REMOVE_SETTINGS, IDS_AUTO_CANT_REMOVE_SETTINGS);
		}

		// Undo NULL termination and continue
		if (szNext != NULL)
			*szNext = '/';
	}
}

void CAutoConfiguration::AddCustomBuildStep(LPCTSTR szCommand, LPCTSTR szOutput, LPCTSTR szDescription, const VARIANT FAR& Reserved) 
{
	CTempDisableUI tempNoUI;
	if( szCommand && _tcslen(szCommand) && szOutput && _tcslen(szOutput) )
	{
		HBLDTARGET hTarget = GetTarget();	// Will throw error if invalid
		if (g_BldSysIFace.AssignCustomBuildStep(szCommand, szOutput, szDescription, hTarget,
			NO_FILE, m_hBuilder))
		{
			return;
		}
	}
	DsThrowOleDispatchException(DS_E_CANT_ADD_BUILD_STEP, IDS_AUTO_CANT_ADD_BUILD_STEP);
}

void CAutoConfiguration::AddFileSettings(LPCTSTR szFile, LPCTSTR szSettings, const VARIANT FAR& Reserved) 
{
	CTempDisableUI tempNoUI;
	HBLDTARGET	hTarget = GetTarget();	
	CPath 		pathFile;
	HBLDFILE 	hFile;
	HFILESET	hFileSet = ACTIVE_FILESET;
	HBUILDER	hBld = GetHBuilder();	

	CProject *	pProject=(CProject *)hBld;	

	ASSERT( pProject != NULL );
	CDir dir = pProject->GetProjDir();
	if ( pathFile.CreateFromDirAndFilename( dir, szFile ) )
	{
		if( g_BldSysIFace.GetFile( &pathFile, hFile, ACTIVE_FILESET, hBld ) )
		{
			if (g_BldSysIFace.SetToolSettings(hTarget, hFile, szSettings, NULL,
				TRUE, FALSE))
			{
				// success
				return;
			}
		}
	}
	DsThrowOleDispatchException(DS_E_CANT_ADD_SETTINGS, IDS_AUTO_CANT_ADD_SETTINGS);
}

void CAutoConfiguration::RemoveFileSettings(LPCTSTR szFile, LPCTSTR szSettings, const VARIANT FAR& Reserved)
{
	CTempDisableUI tempNoUI;
	HBLDTARGET hTarget = GetTarget();	// Will throw error if invalid
	CPath 		pathFile;
	HBLDFILE 	hFile;
	HFILESET	hFileSet = ACTIVE_FILESET;
	HBUILDER	hBld = GetHBuilder();	

	CProject *	pProject=(CProject *)hBld;	

	ASSERT( pProject != NULL );
	CDir dir = pProject->GetProjDir();
	if ( pathFile.CreateFromDirAndFilename( dir, szFile ) )
	{
		if( g_BldSysIFace.GetFile( &pathFile, hFile, ACTIVE_FILESET, hBld ) )
		{

			// [davbr] TEMPORARY (hopefully) FIX FOR DEVSTUDIO 96 BUG 11735.  The real
			//  fix should be made in bldiface.cpp: CBldSysIFace::SetToolSettingsI.
			//  SetToolSettingsI should no longer search for a verbatim occurrence
			//  of the user-supplied settings string in the canonical listing of
			//  all the settings on the tool.  Instead, it should call
			//  g_prjoptengine.ParseString with optbeh having OBAnti (not OBClear)
			//  set.  In other words, erase the entire "if (!fAdd) ... else ..."
			//  clause and always pass the original settings string to ParseString;
			//  simply adjust optbeh based on whether the user is adding or
			//  removing (OBAnti) options.  Unfortunately, I tried this and it
			//  didn't work.  Some settings would get removed correctly, but others
			//  appeared to be misinterpreted while parsing.  All function calls
			//  "succeeded" but the wrong things were happening.  THIS SHOULD BE
			//  FIXED IN THE FUTURE
			//
			// For now, the workaround [HACK] code is HERE, not in bldiface, so only
			//  automation controllers will benefit from it (and no one else
			//  will get screwed if there are problems).  We manually parse
			//  through the settings string finding options and passing them one
			//  by one to SetToolSettings.  We make a special case for /D which
			//  has two common formats (/D_SYMBOL and /D "_SYMBOL"), only one of
			//  which (the latter) will work with SetToolSettings.
		
			// Make R/W copy of the string on the stack to play with
			int nOrigLength = _tcslen(szSettings);
			LPTSTR szSettingsCopy = (LPTSTR) _alloca(nOrigLength+sizeof(TCHAR));
			_tcscpy(szSettingsCopy, szSettings);
		
			LPCTSTR szPrefixes = "/-";
			LPTSTR szNext = szSettingsCopy;
			LPTSTR szCurr;
			
			
			// Judiciously add/remove NULL terminators in the middle of the
			//  string to pick out each option individually, to pass to
			//  bldiface's AddToolSettings.
			while (szNext != NULL)
			{
				szCurr = szNext;
		
				// Is there a flag after the current one?  If so, temporarily NULL
				//  terminate before next flag.
				int nPos = _tcscspn(szCurr+1, szPrefixes);
				if (nPos + (szCurr+1-szSettingsCopy) >= nOrigLength)
					szNext = NULL;
				else
				{
					szNext = szCurr+1 + nPos;
					*szNext = '\0';
				}
		
				LPTSTR szStringToPass = szCurr;		// May get modified for special flags
		
				// SPECIAL CASE: /D flag (don't adjust if we're altering linker
				//  or bscmake settings)
				if( *(szCurr+1) == 'D' && *(szCurr+2) != ' ' && *(szCurr+2) != '"' )
				{
					// Convert: /D_SYMBOL -> /D "_SYMBOL".  Allocate new
					//  string on the stack, with extra room for space and two quotes
					szStringToPass = (LPTSTR) _alloca(_tcslen(szCurr) + 4*sizeof(TCHAR));
					_tcscpy(szStringToPass, "/D \"");
		
					// Length of symbol is distance to nearest space,
					//  minus /D.
					int nSymbolLength = _tcscspn(szCurr+2, " ");
		
					_tcsncat(szStringToPass, szCurr+2, nSymbolLength);	// append sym
					_tcscat(szStringToPass, "\"");						// append final "
				}
		
				if (!g_BldSysIFace.SetToolSettings(hTarget, hFile, szStringToPass, NULL,
					FALSE, FALSE))
				{
					DsThrowOleDispatchException(DS_E_CANT_REMOVE_SETTINGS, IDS_AUTO_CANT_REMOVE_SETTINGS);
				}
		
				// Undo NULL termination and continue
				if (szNext != NULL)
					*szNext = '/';
			}
		}
	}
}

void CAutoConfiguration::AddCustomBuildStepToFile(LPCTSTR szFile, LPCTSTR szCommand, LPCTSTR szOutput, LPCTSTR szDescription, const VARIANT FAR& Reserved)
{
	CTempDisableUI tempNoUI;
	HBLDTARGET hTarget = GetTarget();	// Will throw error if invalid
	CPath 		pathFile;
	HBLDFILE 	hFile;
	HFILESET	hFileSet = ACTIVE_FILESET;
	HBUILDER	hBld = GetHBuilder();	
	CProject *	pProject=(CProject *)hBld;	

	ASSERT( pProject != NULL );
	CDir dir = pProject->GetProjDir();
	if ( pathFile.CreateFromDirAndFilename( dir, szFile ) )
	{
		if( g_BldSysIFace.GetFile( &pathFile, hFile, ACTIVE_FILESET, hBld ) )
		{
			if( szCommand && _tcslen(szCommand) && szOutput && _tcslen(szOutput) )
			{
				if (g_BldSysIFace.AssignCustomBuildStep(szCommand, szOutput, szDescription, hTarget,
					hFile, m_hBuilder))
				{
					g_BldSysIFace.SetUserDefinedDependencies(
						"",
						hTarget,
						hFile,
						m_hBuilder);
					// success
					return;
				}
			}
		}
	}
	DsThrowOleDispatchException(DS_E_CANT_ADD_BUILD_STEP, IDS_AUTO_CANT_ADD_BUILD_STEP);
}


void CAutoConfiguration::Reserved11(void)
{
}

void CAutoConfiguration::MakeCurrentSettingsDefault(const VARIANT FAR& Reserved)
{
	CTempDisableUI tempNoUI;
	HBLDTARGET hTarget = GetTarget();	
	g_BldSysIFace.MakeTargPropsDefault(hTarget, m_hBuilder);
}


LPDISPATCH CAutoConfiguration::GetDependentConfigurations() 
{
	ASSERT (m_pConfigs != NULL);
	m_pConfigs->AddRef();
	return m_pConfigs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autocfg.h ===
// autocfg.h : header file
//
#include <utilauto.h>
#include <ObjModel\bldauto.h>
#include <ObjModel\bldguid.h>
#include "autoguid.h"
#include "bldiface.h"


class CAutoConfigurations;
/////////////////////////////////////////////////////////////////////////////
// CAutoConfiguration command target

class CAutoConfiguration : public CAutoObj
{
	friend class CAutoConfigurations;
	friend class CAutoDepConfigurations;
	DECLARE_DYNCREATE(CAutoConfiguration)

	CAutoConfiguration();           // protected constructor used by dynamic creation

// Attributes
public:
	static CAutoConfiguration* Create(HBUILDER hBuilder, LPCTSTR szName);
	virtual void AssociatedObjectReleased();
	HBUILDER GetHBuilder() { return m_hBuilder; }
	LPCTSTR GetConfigName() { return m_strName; }

	// This throws a dispatch exception if an invalid configuration
	//  is being used.
	void EnsureBuildable();

// Operations
public:
	DECLARE_DUAL_ERRORINFO();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoConfiguration)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_strName;
	DWORD 	m_nDepth;
	LPDISPATCH m_pConfigs;
	HBUILDER m_hBuilder;		// HBUILDER to parent project
	virtual ~CAutoConfiguration();
	HBLDTARGET GetTarget();
	void ThrowInvalidError();

	// Generated message map functions
	//{{AFX_MSG(CAutoConfiguration)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoConfiguration)
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg void AddToolSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved);
	afx_msg void RemoveToolSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved);
	afx_msg void AddCustomBuildStep(LPCTSTR szCommand, LPCTSTR szOutput, LPCTSTR szDescription, const VARIANT FAR& Reserved);
	afx_msg void Reserved11(void);
	afx_msg void MakeCurrentSettingsDefault(const VARIANT FAR& Reserved);
	afx_msg LPDISPATCH GetDependentConfigurations();
//	afx_msg void Build();
	afx_msg void AddFileSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved);
	afx_msg void RemoveFileSettings(LPCTSTR szTool, LPCTSTR szSettings, const VARIANT FAR& Reserved);
	afx_msg void AddCustomBuildStepToFile(LPCTSTR szFile, LPCTSTR szCommand, LPCTSTR szOutput, LPCTSTR szDescription, const VARIANT FAR& Reserved);
	//}}AFX_DISPATCH
	afx_msg BSTR GetName();
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

 	DS_BEGIN_DUAL_INTERFACE_PART(Configuration)
		STDMETHOD(get__Name)(THIS_ BSTR FAR* _Name);
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application);
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent);
		STDMETHOD(get_Name)(THIS_ BSTR FAR* Name);
	    STDMETHOD(AddToolSettings)(THIS_ BSTR szTool, BSTR szSettings, VARIANT Reserved);
	    STDMETHOD(RemoveToolSettings)(THIS_ BSTR szTool, BSTR szSettings, VARIANT Reserved);
	    STDMETHOD(AddCustomBuildStep)(THIS_ BSTR szCommand, BSTR szOutput, BSTR szDescription, VARIANT Reserved);
		STDMETHOD(get_Configurations)(THIS_ IConfigurations FAR* FAR* Configurations);
	    STDMETHOD(Reserved11)(THIS);
	    STDMETHOD(MakeCurrentSettingsDefault)(THIS_ VARIANT Reserved);
//	    STDMETHOD(Build)(THIS_ VARIANT Reserved);
	    STDMETHOD(AddFileSettings)(THIS_ BSTR szFile, BSTR szSettings, VARIANT Reserved);
	    STDMETHOD(RemoveFileSettings)(THIS_ BSTR szFile, BSTR szSettings, VARIANT Reserved);
	    STDMETHOD(AddCustomBuildStepToFile)(THIS_ BSTR szFile, BSTR szCommand, BSTR szOutput, BSTR szDescription, VARIANT Reserved);
 	DS_END_DUAL_INTERFACE_PART(Configuration)
 
 	DS_DECLARE_ENABLE_DUAL(CAutoConfiguration, Configuration)

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autocfgs.h ===
// AutoCfgs.h : header file
//
#include <utilauto.h>
#include <ObjModel\bldauto.h>
#include <ObjModel\bldguid.h>
#include "autoguid.h"
#include "bldiface.h"



/////////////////////////////////////////////////////////////////////////////
// CAutoConfigurations command target

class CAutoConfigurations : public CAutoObj
{
	DECLARE_DYNCREATE(CAutoConfigurations)

	CAutoConfigurations();           // protected constructor used by dynamic creation

// Attributes
public:
	static CAutoConfigurations* Create(HBUILDER hBld, LPCTSTR szProject);
	virtual void AssociatedObjectReleased();

// Operations
public:
	DECLARE_DUAL_ERRORINFO();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoConfigurations)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlConfigs;
	HBUILDER m_hBld;
	CString m_strProject;
	virtual ~CAutoConfigurations();

	virtual void RefreshConfigsInList();
	void ReleaseConfigsInList();

	// Generated message map functions
	//{{AFX_MSG(CAutoConfigurations)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoConfigurations)
	afx_msg LPDISPATCH GetApplication();
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& Index);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN GetNewEnum();
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
 	DS_BEGIN_DUAL_INTERFACE_PART(Configurations)
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application);
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get_Parent)(THIS_ IBuildProject FAR* FAR* Parent);
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
		STDMETHOD(Item)(THIS_ VARIANT Index, IConfiguration FAR* FAR* Item);
 	DS_END_DUAL_INTERFACE_PART(Configurations)
 
 	DS_DECLARE_ENABLE_DUAL(CAutoConfigurations, Configurations)

};

/////////////////////////////////////////////////////////////////////////////
class CAutoDepConfigurations : public CAutoObj
{
	DECLARE_DYNCREATE(CAutoDepConfigurations)

	CAutoDepConfigurations();           // protected constructor used by dynamic creation

// Attributes
public:
	static CAutoDepConfigurations* Create(HBUILDER hBld, LPCTSTR szProject);
	virtual void AssociatedObjectReleased();

// Operations
public:
	DECLARE_DUAL_ERRORINFO();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoDepConfigurations)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlConfigs;
	HBUILDER m_hBld;
	CString m_strProject;
	virtual ~CAutoDepConfigurations();

	virtual void RefreshConfigsInList();
	void ReleaseConfigsInList();

	// Generated message map functions
	//{{AFX_MSG(CAutoDepConfigurations)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoDepConfigurations)
	afx_msg LPDISPATCH GetApplication();
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& Index);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN GetNewEnum();
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
 	DS_BEGIN_DUAL_INTERFACE_PART(Configurations)
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application);
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get_Parent)(THIS_ IBuildProject FAR* FAR* Parent);
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
		STDMETHOD(Item)(THIS_ VARIANT Index, IConfiguration FAR* FAR* Item);
 	DS_END_DUAL_INTERFACE_PART(Configurations)
 
 	DS_DECLARE_ENABLE_DUAL(CAutoDepConfigurations, Configurations)
public:
protected:
	CString m_strConfig;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autoprj.cpp ===
// AutoPrj.cpp : implementation file
//

#include "stdafx.h"
#include "autocfgs.h"
#include "AutoPrj.h"
#include <main.h>
#include <ObjModel\appauto.h>
#include <ObjModel\blddefs.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern void RefreshTargetCombos(BOOL bEmpty = FALSE);

/////////////////////////////////////////////////////////////////////////////
// CAutoProject dual implementation

STDMETHODIMP CAutoProject::XBuildProject::get_Application(IDispatch * FAR* Application)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*Application = pThis->GetApplication();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoProject::XBuildProject::get_Name(BSTR FAR* Name)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*Name = pThis->GetName();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::get_FullName(BSTR FAR* FullName)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*FullName = pThis->GetFullName();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::get_Type(BSTR FAR* Type)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*Type= pThis->GetType();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::get_Parent(IDispatch * FAR* Parent)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*Parent = pThis->GetParent();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::get_Configurations(IConfigurations FAR* FAR* Configurations)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		*Configurations = (IConfigurations*) pThis->GetConfigurations();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::AddFile(BSTR szFile, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		CString strFile = szFile;
		pThis->AddFile(strFile, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProject::XBuildProject::AddConfiguration(BSTR szConfiguration, VARIANT Reserved)
{
	METHOD_PROLOGUE(CAutoProject, Dispatch)
	
	TRY_DUAL(IID_IBuildProject)
	{
		CString strConfig = szConfiguration;
		pThis->AddConfiguration(strConfig, Reserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


/////////////////////////////////////////////////////////////////////////////
// CAutoProject

IMPLEMENT_DYNCREATE(CAutoProject, CAutoObj)

CAutoProject::CAutoProject()
{
	EnableDualAutomation();

	m_pConfigs = NULL;
	m_hBld = NULL;

	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoProject::~CAutoProject()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

	g_LinkAutoObjToProject.OnAutoObjDestroyed(this);
}


void CAutoProject::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	ASSERT (m_pConfigs != NULL);

	m_pConfigs->Release();
	m_pConfigs = NULL;

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoProject, CAutoObj)
	//{{AFX_MSG_MAP(CAutoProject)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoProject, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoProject)
	DISP_PROPERTY_EX_ID(CAutoProject, "Application", 2, GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX_ID(CAutoProject, "Parent", 3,GetParent, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX_ID(CAutoProject, "Type", 4,GetType, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX_ID(CAutoProject, "Configurations", 100, GetConfigurations, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION_ID(CAutoProject, "AddFile", 101, AddFile, VT_EMPTY, VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION_ID(CAutoProject, "AddConfiguration", 102,AddConfiguration, VT_EMPTY, VTS_BSTR VTS_VARIANT)
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoProject, "Name", 0, GetName, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX_ID(CAutoProject, "FullName", 1, GetFullName, SetNotSupported, VT_BSTR)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(CAutoProject, CAutoObj)
	INTERFACE_PART(CAutoProject, IID_IDispProject, Dispatch)
	INTERFACE_PART(CAutoProject, IID_IGenericProject, Dispatch)
	INTERFACE_PART(CAutoProject, IID_IBuildProject, Dispatch)
	DUAL_ERRORINFO_PART(CAutoProject)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoProject, IID_IBuildProject)
DS_IMPLEMENT_ENABLE_DUAL(CAutoProject, BuildProject)
DS_DELEGATE_DUAL_INTERFACE(CAutoProject, BuildProject)
DS_IMPLEMENT_VTBL_PAD_10(CAutoProject, BuildProject)

/////////////////////////////////////////////////////////////////////////////
// CAutoProject message handlers

LPDISPATCH CAutoProject::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

LPDISPATCH CAutoProject::GetParent() 
{
	// Application object is a Project's parent
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

BSTR CAutoProject::GetName() 
{
	return m_strName.AllocSysString();
}

BSTR CAutoProject::GetFullName()
{
	return m_strFullName.AllocSysString();
}

BSTR CAutoProject::GetType()
{
	CString strResult(DS_BUILD_PROJECT);

	return strResult.AllocSysString();
}

LPDISPATCH CAutoProject::GetConfigurations() 
{
	ASSERT (m_pConfigs != NULL);
	m_pConfigs->AddRef();
	return m_pConfigs;
}

void CAutoProject::AddFile(LPCTSTR szFile, const VARIANT FAR& Reserved) 
{
	CTempDisableUI tempNoUI;
	CPath 		pathFile;
	HBLDFILE 	hFile;
	HFILESET	hFileSet = ACTIVE_FILESET;

	CProject *	pProject=(CProject *)m_hBld;

	ASSERT( pProject != NULL );
	CDir dir = pProject->GetProjDir();
	if ( pathFile.CreateFromDirAndFilename( dir, szFile ) )
	{
		if( g_BldSysIFace.AddFile( ACTIVE_FILESET, &pathFile, 0, m_hBld ) )
		{
			return;
		}
	}
	DsThrowOleDispatchException(DS_E_CANT_ADD_FILE, IDS_AUTO_CANT_ADD_FILE);
}

void CAutoProject::AddConfiguration(LPCTSTR szName, const VARIANT FAR& Reserved)
{
	CTempDisableUI tempNoUI;
	CPath 		pathFile;
	HBLDFILE 	hFile;
	HFILESET	hFileSet = ACTIVE_FILESET;

	CProject *	pProject=(CProject *)m_hBld;

	ASSERT( pProject != NULL );
	CDir dir = pProject->GetProjDir();

	// FIX this replace with GetDefaultPlatform
	const TCHAR *szPlatform = _T("Win32");
	// strPlatDesc = *(g_prjcompmgr.GetPrimaryPlatform()->GetUIDescription());

	const TCHAR *szProjType = NULL;

	// FIX this replace with GetName
	CProjType * pProjType = pProject->GetProjType();
	const CString *strTypeName = pProjType->GetTypeUIDescription();
	szProjType = *strTypeName;
	CString strProjName;
	pProject->GetName(strProjName);
	CString strName =  strProjName + " - " + szPlatform + " " + szName;

	// Make sure this name doen't already exist
	CString strTarget;
	// Enumerate all the targets
	g_BldSysIFace.InitTargetEnum(m_hBld);
	HBLDTARGET hTarget = g_BldSysIFace.GetNextTarget(strTarget, m_hBld);
	while (hTarget != NO_TARGET)
	{
		if (strTarget.CompareNoCase(strName) == 0)
		{
			// target already exist
			DsThrowOleDispatchException(DS_E_CANT_ADD_CONFIGURATION, IDS_AUTO_CANT_ADD_CONFIGURATION);
		}
		hTarget = g_BldSysIFace.GetNextTarget(strTarget, m_hBld);
	}

	HBLDTARGET hSettingsTarg = NO_TARGET;
	hSettingsTarg = g_BldSysIFace.GetActiveTarget(m_hBld);
	if (g_BldSysIFace.AddTarget( strName,
								szPlatform, 
								szProjType,
								TRUE,
								TRUE,
								TrgMirror,
								hSettingsTarg,
								SettingsDefault,
								hSettingsTarg,
								TRUE,
								TRUE,
								TRUE,
								m_hBld
								))
	{
		RefreshTargetCombos();
		return;
	}
	DsThrowOleDispatchException(DS_E_CANT_ADD_CONFIGURATION, IDS_AUTO_CANT_ADD_CONFIGURATION);
}

CAutoProject* CAutoProject::Create(HBUILDER hBld, LPCTSTR szName)
{
	CAutoProject* pProject = new CAutoProject;
	pProject->m_strName = szName;
	ASSERT(hBld != NO_BUILDER);
	if(hBld != NO_BUILDER)
		pProject->m_strFullName = (const char *)*g_BldSysIFace.CnvHBuilder(hBld)->GetFilePath();

	pProject->m_hBld = hBld;

	CAutoConfigurations* pConfigs = CAutoConfigurations::Create(hBld, szName);

	// Don't AddRef pConfigs, since we just created it, and that implicitly
	//  addrefs it.
	pProject->m_pConfigs = pConfigs->GetIDispatch(FALSE);
	g_LinkAutoObjToProject.OnAutoObjCreated(pProject, hBld);
	return pProject;
}

/////////////////////////////////////////////////////////////////////////////
// CLinkAutoObjToProject

CLinkAutoObjToProject g_LinkAutoObjToProject;

void CLinkAutoObjToProject::OnProjectDestroyed(CProject* pProject)
{
	// Notify each autoobj that's mapped to this CProject
	POSITION pos = m_PtrMap.GetStartPosition();
	while (pos != NULL)
	{
		CAutoObj* pAutoObj;
		CProject* pProjectIter;
		m_PtrMap.GetNextAssoc(pos, pAutoObj, pProjectIter);
		if (pProject != pProjectIter)
			continue;
		ASSERT_KINDOF(CAutoObj, pAutoObj);
		pAutoObj->AssociatedObjectReleased();
		VERIFY(m_PtrMap.RemoveKey(pAutoObj));
	}
}

void CLinkAutoObjToProject::OnAutoObjDestroyed(CAutoObj* pAutoObj)
{
	CProject* pDummy;
	VERIFY(!m_PtrMap.Lookup(pAutoObj, pDummy) || m_PtrMap.RemoveKey(pAutoObj));
}

void CLinkAutoObjToProject::OnAutoObjCreated(CAutoObj* pAutoObj, HBUILDER hBld)
{
	m_PtrMap[pAutoObj] = g_BldSysIFace.CnvHBuilder(hBld);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autoguid.h ===
// GUIDs used in our automation object model that are not exposed to the user
//  in include\objmodel\bldguid.h.  These are the dispinterface IDs and the
//  CLSIDs which are declared in the type library and used internally to 
//  implement the objects, but are not exposed to C++ clients through our
//  headers.

// {96961261-A819-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IDispConfigurations,
0x96961261L,0xA819,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {96961262-A819-11cf-AD07-00A0C9034965}
DEFINE_GUID(CLSID_Configurations,
0x96961262L,0xA819,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {0452FFE0-A81D-11CF-AD07-00A0C9034965}
DEFINE_GUID(IID_IDispProject,
0x0452FFE0L,0xA81D,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {0452FFE1-A81D-11CF-AD07-00A0C9034965}
DEFINE_GUID(CLSID_Project,
0x0452FFE1L,0xA81D,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {0452FFE2-A81D-11CF-AD07-00A0C9034965}
DEFINE_GUID(IID_IDispConfiguration,
0x0452FFE2L,0xA81D,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {0452FFE3-A81D-11CF-AD07-00A0C9034965}
DEFINE_GUID(CLSID_Configuration,
0x0452FFE3L,0xA81D,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\batchdlg.cpp ===
//
// Implementation for CBatchBldDlg class
//
// History:
// Date				Who			What
// 01/17/94			colint			created
//////////////////////////////////////////////////////////////////

#include "stdafx.h"		// standard AFX include
#pragma hdrstop
#include "batchdlg.h"
#include "resource.h"
#include "msgboxes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


CMapStringToPtr CBatchBldDlg::m_mapSelected;
BOOL CBatchBldDlg::m_bSelectionOnly = FALSE;

///////////
// CBatchBldDlg IMPLEMENTATION
///////////
CBatchBldDlg::CBatchBldDlg ( CWnd * pParent /* = NULL */)
 			: C3dDialog (CBatchBldDlg::IDD, pParent) 
{
	m_bRebuild = FALSE;
	m_bClean = FALSE;
}

BEGIN_MESSAGE_MAP (CBatchBldDlg, C3dDialog)
	//{{AFX_MSG_MAP (CBatchBldDlg)
		ON_BN_CLICKED(IDC_REBUILD_BATCH, OnRebuild)
		ON_BN_CLICKED(IDC_CLEAN_BATCH, OnClean)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

void CBatchBldDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBatchBldDlg)
	DDX_Check(pDX, IDC_SELECT_BATCH, m_bSelectionOnly);
	//}}AFX_DATA_MAP
}

///////////////////////////////
// BOOL CBatchBldDlg::OnInitDialog()
///////////////////////////////
BOOL CBatchBldDlg::OnInitDialog()
{
	CString	strCurrentConfigName ;
	CString strProject;
	CListBox * plbTarget = (CListBox *)GetDlgItem (IDC_TARGET_LIST) ;
	int i, iCurSel, nConfigs;
	const ConfigurationRecord * pcr;
	CPlatform * pPlatform;
	ASSERT (g_pActiveProject != NULL);

	// Subclass the check listbox
	VERIFY(m_lbConfigs.SubclassDlgItem(IDC_TARGET_LIST, this));
	m_lbConfigs.SetRedraw(FALSE);

	// call base class OnInitDialog
	C3dDialog::OnInitDialog() ;
	// get the project's current configuration
	g_pActiveProject->GetStrProp(P_ProjActiveConfiguration, strCurrentConfigName);

	m_lbConfigs.ResetContent();
	// First, enumerate all possible configurations and put the supported
	// ones in the list box
	CProject::InitProjectEnum();
	CProject * pProject;
	CClientDC dc(&m_lbConfigs);
	int width, maxwidth = 0;

	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		const CPtrArray & ppcr = *pProject->GetConfigArray();
		nConfigs = ppcr.GetSize();
		for (i = 0; i < nConfigs; i++)
		{
			pcr = (ConfigurationRecord *)ppcr[i];
		
			// Only works for internal projects
			if( pProject->m_bProjIsExe )
				continue;

	 		// If the project is an internal makefile then we must get the
			// platform from the projtype of ppcr[i]
			CProjType * pprojtype;
			VERIFY(g_prjcompmgr.LookupProjTypeByName(pcr->GetOriginalTypeName(), pprojtype));
			pPlatform = pprojtype->GetPlatform();
 
			if (pPlatform->IsSupported() && (pPlatform->GetBuildable()==TRUE) )
			{
				CString strConfig = pcr->GetConfigurationName();
				m_lbConfigs.AddString(strConfig);
				width = dc.GetTextExtent(strConfig, strConfig.GetLength()).cx;
				maxwidth = __max(maxwidth, width);
			}
		}
	}
		
	// might need horz scrollbars
	m_lbConfigs.SetHorizontalExtent(maxwidth + 14); // add width of checkbox

	// update # of configs actually supported
	nConfigs = m_lbConfigs.GetCount();

	iCurSel = plbTarget->FindStringExact (-1, (const TCHAR *)strCurrentConfigName) ;
	if (iCurSel!=LB_ERR) plbTarget->SetCurSel(iCurSel);

	for (i = 0; i < nConfigs; i++){
		if( m_mapSelected.GetCount() ){
			CString strConfigName;
			m_lbConfigs.GetText(i, strConfigName);
			void *pDummy;
			if( m_mapSelected.Lookup(strConfigName, pDummy) ){
				m_lbConfigs.SetCheck(i, TRUE);
			}
		} else {
			m_lbConfigs.SetCheck(i, TRUE);
		}
	}

	m_lbConfigs.SetRedraw(TRUE);

	return TRUE ;
}

///////////////////////////////
// CBatchBldDlg::OnOK()
///////////////////////////////
VOID CBatchBldDlg::OnOK()
{
	GetConfigs();
	m_bRebuild = FALSE;
	m_bClean = FALSE;
	C3dDialog::OnOK();
}

///////////////////////////////
// CBatchBldDlg::OnRebuild()
///////////////////////////////
VOID CBatchBldDlg::OnRebuild()
{
	GetConfigs();
	m_bRebuild = TRUE;
	m_bClean = FALSE;
	C3dDialog::OnOK();
}

///////////////////////////////
// CBatchBldDlg::OnRebuild()
///////////////////////////////
VOID CBatchBldDlg::OnClean()
{
	GetConfigs();
	m_bClean = TRUE;
	m_bRebuild = FALSE;
	C3dDialog::OnOK();
}

///////////////////////////////
// CBatchBldDlg::GetConfigs()
///////////////////////////////
void CBatchBldDlg::GetConfigs()
{
	// Construct the list of configs to build
	int nItem, nConfigs;

	// Construct a CStringList of the config names
	// that we are going to build
	m_pBuildConfigs->RemoveAll();
	nConfigs = m_lbConfigs.GetCount();
	m_mapSelected.RemoveAll();
	for (nItem = 0; nItem < nConfigs; nItem++)
	{
		if (m_lbConfigs.GetCheck(nItem))
		{	
			CString strConfigName;

			m_lbConfigs.GetText(nItem, strConfigName);
			m_pBuildConfigs->AddTail(strConfigName);
			m_mapSelected.SetAt(strConfigName,NULL);
		}
	}
}

///////////////////////////////
// CBatchBldDlg::OnCancel()
///////////////////////////////
VOID CBatchBldDlg::OnCancel()
{
	// Cancel, so no build is done

	C3dDialog::OnCancel();
}


BOOL CBatchBldDlg::LoadBatchBldOpt(CArchive & archive)
{
	TRY
	{

		// Construct the list of configs to build
		int nItem, nConfigs;

		archive >> nConfigs;
		if (nConfigs == -1)
		{
			// -1 indicates this is really a version flag
			// that we should read m_bSelectionOnly
			archive >> (int)m_bSelectionOnly;

			// now read the real nConfigs
			archive >> nConfigs;
		}
		
		m_mapSelected.RemoveAll();
		for (nItem = 0; nItem < nConfigs; nItem++)
		{
			CString strConfigName;

			archive >> strConfigName;
			m_mapSelected.SetAt(strConfigName,NULL);
		}
	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
 	END_CATCH_ALL
	
	return TRUE;	// succeed
}


BOOL CBatchBldDlg::SaveBatchBldOpt(CArchive & archive)
{
	TRY
	{
		
		// Construct the list of configs to build
		int nItem, nConfigs;

		nConfigs = m_mapSelected.GetCount();
		POSITION pos;

		ASSERT(nConfigs != -1);
		archive << (-1); // flag new format using m_bSelectionStored
		archive << (int)m_bSelectionOnly;

		archive << (nConfigs);

		pos = m_mapSelected.GetStartPosition();

		for (pos = 	m_mapSelected.GetStartPosition (); pos != NULL;)
		{
			CString strConfigName;
			void *pv;
			m_mapSelected.GetNextAssoc ( pos, strConfigName, pv );

			archive << (strConfigName);
		}

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

 	return TRUE;
}


CMapStringToPtr CProjectsDlg::m_mapSelectedProjects;

///////////
// CProjectsDlg IMPLEMENTATION
///////////
CProjectsDlg::CProjectsDlg ( CWnd * pParent /* = NULL */)
 			: C3dDialog (CProjectsDlg::IDD, pParent) 
{
	m_bExport = FALSE;
}

BEGIN_MESSAGE_MAP (CProjectsDlg, C3dDialog)
	//{{AFX_MSG_MAP (CProjectsDlg)
		ON_BN_CLICKED(IDC_SELECT_ALL, OnSelectAll)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

///////////////////////////////
// BOOL CProjectsDlg::OnInitDialog()
///////////////////////////////
BOOL CProjectsDlg::OnInitDialog()
{
	CString strProject;
	int i;
	CPlatform * pPlatform;
	if (!m_bExport)
	{
		// this also works for write project
		CString strCaption;
		strCaption.LoadString(IDS_WRITE_PROJECTS);
		SetWindowText(strCaption);

		GetDlgItem(IDC_EXPORT_DEPS)->ShowWindow(SW_HIDE);
	}

	// Get proper workspace dir
	ASSERT(g_pProjWksIFace);
	LPCSTR pszPath;
	VERIFY(SUCCEEDED(g_pProjWksIFace->GetWorkspaceDocPathName(&pszPath)));
	CPath pathWkspc;
	ASSERT((pszPath!=NULL) && (*pszPath));
	VERIFY(pathWkspc.Create(pszPath));
	CDir dirWkspc;
	dirWkspc.CreateFromPath(pathWkspc);

	// Subclass the check listbox
	VERIFY(m_lbProjects.SubclassDlgItem(IDC_TARGET_LIST, this));
	m_lbProjects.SetRedraw(FALSE);

	// call base class OnInitDialog
	C3dDialog::OnInitDialog() ;

	m_lbProjects.ResetContent();
	// First, enumerate all possible projects put them in the list box
	CProject::InitProjectEnum();
	CProject * pProject;
	CProject * pCmpProject;
	CClientDC dc(&m_lbProjects);
	int width, maxwidth = 0;
	CString strMakePath, strProjectName;

	CPath MakPath;
	MakPath.SetAlwaysRelative();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		// Only works for internal projects
		if( pProject->m_bProjIsExe )
		{
			ASSERT(0);
			continue;
		}

		strProjectName = strProject;
		MakPath = *pProject->GetFilePath();
		if (m_bExport)
			MakPath.ChangeExtension(_T(".mak"));

		MakPath.GetRelativeName(dirWkspc, strMakePath);
		strProjectName = strProject + _T("  (") + strMakePath + _T(')');

		i = m_lbProjects.AddString(strProjectName);
		if (i < 0)
		{
			ASSERT(0);
			continue;
		}
		pCmpProject = NULL;
		if ((m_mapSelectedProjects.IsEmpty()) || (m_mapSelectedProjects.Lookup(strProject, (void * &)pCmpProject)))
		{
			ASSERT(pCmpProject==NULL || pCmpProject==pProject);
			m_lbProjects.SetCheck(i, TRUE);

			// REVIEW: select also
			// m_lbProjects.SetSel(i, TRUE);
		}

		m_mapProjects.SetAt(strProjectName, (void *)pProject);
		width = dc.GetTextExtent(strProjectName, strProjectName.GetLength()).cx;
		maxwidth = __max(maxwidth, width);
	}
		
	// might need horz scrollbars
	m_lbProjects.SetHorizontalExtent(maxwidth + 14); // add width of checkbox

	m_lbProjects.SetRedraw(TRUE);

	return TRUE ;
}

////////////////////////////////////////////////////////////
// Button-clicked handlers

void CProjectsDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectsDlg)
	DDX_Check(pDX, IDC_EXPORT_DEPS, m_bExportDeps);
	//}}AFX_DATA_MAP
}

///////////////////////////////
// CProjectsDlg::OnOK()
///////////////////////////////
VOID CProjectsDlg::OnOK()
{
	GetProjects();
	if (m_mapSelectedProjects.IsEmpty())
	{
		MsgBox(Error, IDS_NO_PROJ_SEL);
		m_lbProjects.SetFocus();
		return;
	}
	C3dDialog::OnOK();
}

///////////////////////////////
// CProjectsDlg::OnSelectAll()
///////////////////////////////
VOID CProjectsDlg::OnSelectAll()
{
	m_lbProjects.SetSel(-1, TRUE);
	m_lbProjects.SetFocus();
}

///////////////////////////////
// CProjectsDlg::GetProjects()
///////////////////////////////
void CProjectsDlg::GetProjects()
{
	m_mapSelectedProjects.RemoveAll();  // review
	
	CProject * pProject;
	int nItem, nProjects = m_lbProjects.GetCount();
	CString strProjectName, strProject;

	for (nItem = 0; nItem < nProjects; nItem++)
	{
		m_lbProjects.GetText(nItem, strProjectName);
		if (!m_mapProjects.Lookup(strProjectName, (void * &) pProject))
		{
			ASSERT(0);
			continue;
		}
		strProject = pProject->GetTargetName();
		if (m_lbProjects.GetCheck(nItem))
		{	
			// update selection
			m_mapSelectedProjects.SetAt(strProject, pProject);
		}
		else
		{
			// make sure it is not selected
			m_mapSelectedProjects.RemoveKey(strProject);
		}
	}
}

///////////////////////////////
// CProjectsDlg::OnCancel()
///////////////////////////////
VOID CProjectsDlg::OnCancel()
{
	// Cancel, so no export is done

	C3dDialog::OnCancel();
}

BOOL CProjectsDlg::LoadProjectsSelOpt(CArchive & archive)
{
	TRY
	{

		// Construct the list of projects to export
		int nItem, nProjects;
		void * pv;

		archive >> nProjects;
		
		m_mapSelectedProjects.RemoveAll();
		for (nItem = 0; nItem < nProjects; nItem++)
		{
			CString strProject;

			archive >> strProject;
			m_mapSelectedProjects.SetAt(strProject,NULL);
		}

		CString strProject;
		CProject::InitProjectEnum();
		CProject * pProject;
		while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
		{
			if (m_mapSelectedProjects.Lookup(strProject, pv))
			{
				m_mapSelectedProjects.SetAt(strProject, pProject);
			}
		}
	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
 	END_CATCH_ALL
	
	return TRUE;	// succeed
}


BOOL CProjectsDlg::SaveProjectsSelOpt(CArchive & archive)
{
	TRY
	{
		
		// Construct the list of projects to export
		int nItem, nProjects;

		nProjects = m_mapSelectedProjects.GetCount();
		POSITION pos;

		archive << (nProjects);

		pos = m_mapSelectedProjects.GetStartPosition();

		while (pos != NULL)
		{
			CString strProject;
			void *pv;
			m_mapSelectedProjects.GetNextAssoc ( pos, strProject, pv );

			archive << (strProject);
		}

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

 	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\awiface.h ===
//
// CAppWizIFace
//
// AppWizard Interface to New/Insert Project dialog
//
// [davbr]
//

#ifndef _INCLUDE_APPWIZIFACE_H
#define _INCLUDE_APPWIZIFACE_H

// Size of m_pnPlatforms array in build system's CPromptDlg.  This represents the
//  maximum number of platforms we can display at once.
#define MAX_PLATFORMS 8

#ifndef VS_PACKAGE
#include "utilctrl.h"
#endif	// VS_PACKAGE

enum {APPWIZTERMTYPE_CANCEL, APPWIZTERMTYPE_EMPTYPROJ, APPWIZTERMTYPE_APPWIZPROJ, APPWIZTERMTYPE_RERUNPROMPTDLG};

#ifndef VS_PACKAGE
class CProjTypeList;
#endif	// VS_PACKAGE

#ifdef VS_PACKAGE
#include <bldapi.h>
#endif

class CAppWizIFace
{
public:

	// Each time the new/insert project dialog pops up, call this before
	//  calling any of the other APIs.
#ifdef VS_PACKAGE
	virtual void InitAppWiz(HWND hWnd, IServiceProvider *pSp);

	IServiceProvider *m_pSp ;
	IBuildWizardX *m_pBldWizX ;
	IBuildPlatformsX *m_pBldPlatsX;

	void ReleasePtrs(void)
	{
		if (m_pBldPlatsX)
		{
			m_pBldPlatsX->Release() ;
			m_pBldPlatsX = NULL ;
		}

		if (m_pBldWizX)
		{
			m_pBldWizX->Release() ;
			m_pBldWizX = NULL ;
		}

		if (m_pSp)
		{
			m_pSp->Release() ;
			m_pSp = NULL ;
		}
	}

	CAppWizIFace() 
	{ 
		m_pSp = NULL; 
		m_pBldPlatsX = NULL ;
		m_pBldWizX = NULL ;
	}

	~CAppWizIFace() 
	{ 
		ReleasePtrs();
	}
#else
	virtual void InitAppWiz(HWND hWnd);
#endif

	// This takes the projtype list box, and fills it with the standard appwiz
	//  project types.  Returns number of appwiz types.

#ifndef VS_PACKAGE	
	virtual int AddAppWizProjectTypesAtTop(CListBox* pList);
	virtual int AddAppWizProjectTypesAtTop(CProjTypeList* pList);

	// This takes the projtype list box, and fills it with any custom appwiz's it finds.
	//  It returns whether number of custom AppWizards
	virtual int AddCustomAppWizProjectTypesAtBottom(CListBox* pList);
	virtual int AddCustomAppWizProjectTypesAtBottom(CProjTypeList* pList);

	// Fills the platforms checklist with platforms supported by the indicated
	//  custom AppWizard
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CStringArray* pChklstPlatforms);

	// Fills the platforms checklist with platforms supported by the indicated
	//  AppWizard type (its index into the project type combo box).
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CStringArray* pChklstPlatforms);
#endif

	// After the user clicks "Create" with an appwiz type selected, but before
	//  you call RunAppWizSteps, call this and make sure it returns TRUE.  Otherwise,
	//  don't dismiss new/insert project.
	virtual BOOL CanRunAppWizSteps(LPCTSTR szProj, LPCTSTR szProjDir, int* pnPlatforms);

	// This runs the wizard.  It returns one of the APPWIZTERMTYPE_ values.
	// TODO: These values are currently defined in ide\include\appwzshd.h.  They
	//  need to moved here after the build system starts using this interface and
	//  no longer uses appwzshd.h.
	virtual int RunAppWizSteps();

	// If RunAppWizSteps was successful, the caller should create & pass a new HBUILDER if
	//  a new workspace is being created, otherwise the current HBUILDER if this is
	//  from insert project.  This function takes the HBUILDER and adds the AppWizard
	//  targets.
	virtual void AddAppWizTargets(HBUILDER hBld);

	virtual BOOL GetAppWizDialog( CString &strDialog );

	// Call this so AppWizard deallocates stuff.  If you run appwiz steps, call after
	//  AddAppWizTargets.  Otherwise, call after the new/insert project dialog is
	//  dismissed.
	virtual void ExitAppWiz();
};	


#define GETAPPWIZIFACE  (MAKEINTRESOURCE(1))
typedef CAppWizIFace* (WINAPI* PGETAPPWIZIFACE)();

#ifdef VS_PACKAGE
extern CAppWizIFace g_AppWizIFace;
#endif

#endif // _INCLUDE_APPWIZIFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\blddlg.cpp ===
// BLDDLG.CPP
// -----------
// Implements the Directories dialog.
//
// History
// =======
// 20-Feb-96	karlsi		Created

////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop
#include "blddlg.h"
#include "dlgbase.h"
#include "resource.h"
#include "projcomp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#if 0
////////////////////////////////////////////////////////////
// CBldGrid
CBldGrid::CBldGrid()
	: CStringListGridWnd(GRIDLIST_ELLIPSE)
{
}
#endif

////////////////////////////////////////////////////////////
// Constructors, destructors

CBldOptDlg::CBldOptDlg()
	: CDlgTab(IDDP_OPTIONS_BUILD, IDS_BUILD)
{
	// m_BldGrid.m_pDlg = this;
	m_bAlreadyWarnedOfBuild = FALSE;	
	m_bAlwaysExportMakefile = FALSE;
	m_bExportDeps = FALSE;
	m_bWriteBuildLog = TRUE;
}

CBldOptDlg::~CBldOptDlg
(
)
{
}

////////////////////////////////////////////////////////////
// CBldOptDlg::Activate

BOOL CBldOptDlg::Activate
(
	CTabbedDialog *	ptd,
	CPoint			cp
)
{
	// TODO:

	// Make sure that the actual activation occurs!
	return CDlgTab::Activate( ptd, cp );
}


BOOL CBldOptDlg::ValidateTab()
{
	// currently always valid

	return TRUE;
}

////////////////////////////////////////////////////////////
// CBldOptDlg::OnInitDialog

BOOL CBldOptDlg::OnInitDialog
(
)
{
#if 0
	VERIFY(m_DirGrid.ReplaceControl(this,
									IDC_PLACEHOLDER2, IDC_DIRS_LIST,
									WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
									WS_EX_CLIENTEDGE, GRIDWND_TB_ALL));
#endif

	m_bAlwaysExportMakefile = g_bAlwaysExportMakefile;
	m_bExportDeps = g_bAlwaysExportDeps;
	m_bWriteBuildLog = g_bWriteBuildLog;

	CDlgTab::OnInitDialog();

	return(TRUE);
}

////////////////////////////////////////////////////////////
// CBldOptDlg::CheckForBuildAndWarn
void CBldOptDlg::CheckForBuildAndWarn ()
{
	if (m_bAlreadyWarnedOfBuild) return;
	m_bAlreadyWarnedOfBuild = TRUE;
	return;  // don't care at the moment

	// If there is a build in process, then warn the user that changes
	// to the directories will not take effect until the next build:

	if (g_Spawner.SpawnActive ())
	{
		MsgBox ( Information, IDS_DIR_CHANGE_IN_BUILD ); // UNDONE
	}
}

////////////////////////////////////////////////////////////
// CBldOptDlg::CommitTab

void CBldOptDlg::CommitTab()
{
	if (GetSafeHwnd() == NULL)
		return;

	UpdateData(TRUE);
	// m_BldGrid.AcceptControl();

	// TODO: update data
	g_bAlwaysExportMakefile = m_bAlwaysExportMakefile;
	g_bAlwaysExportDeps = m_bExportDeps;
	g_bWriteBuildLog = m_bWriteBuildLog;
}

////////////////////////////////////////////////////////////
// Button-clicked handlers

void CBldOptDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBldOptDlg)
	DDX_Check(pDX, IDC_EXPORT_DEPS, m_bExportDeps);
	DDX_Check(pDX, IDC_ALWAYS_EXPORT_MAK, m_bAlwaysExportMakefile);
	DDX_Check(pDX, IDC_WRITE_BUILD_LOG, m_bWriteBuildLog);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CBldOptDlg, CDlgTab)
	//{{AFX_MSG_MAP(CBldOptDlg)
	ON_BN_CLICKED(IDC_ALWAYS_EXPORT_MAK,OnClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CBldOptDlg::OnClick()
{
	CButton* pBtn = (CButton*)GetDlgItem(IDC_ALWAYS_EXPORT_MAK);

	if (NULL!= pBtn)
	{
		if (pBtn->GetCheck())
		{
			// this warning is gratuitous
			// AfxMessageBox( IDS_WRN_SETEXPORTMAKEFILE, MB_OK | MB_ICONINFORMATION );
		}
	}
}

#if 0
BOOL CBldOptDlg::OnAdd(int nIndex)
{
	return TRUE;
}

BOOL CBldOptDlg::OnDel(int nIndex)
{
	return TRUE;
}

BOOL CBldOptDlg::OnMove(int nSrcIndex, int nDestIndex)
{
	CheckForBuildAndWarn();
	return TRUE;
}

BOOL CBldOptDlg::OnChange(int nIndex)
{
	CheckForBuildAndWarn();
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\blddlg.h ===
// BLDDLG.H
// ---------
// Exports from BLDDLG.CPP.
//
// History
// =======
// 20-Feb-96	karlsi		Created

#ifndef __BLDDLG_H__
#define __BLDDLG_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#if 0  // We might need a grid control 
#ifndef __UTILCTRL_H__
#include "utilctrl.h"
#endif

////////////////////////////////////////////////////////////
// CBldGrid
class CBldGrid : public CStringListGridWnd
{
// Construction
public:
	CBldGrid();

// Attributes
public:
	class CBldOptDlg* m_pDlg;

// Overrides
protected:
	virtual inline BOOL OnChange(int nIndex);
	virtual inline BOOL OnAddString(int nIndex);
	virtual inline BOOL OnDeleteString(int nIndex);
	virtual inline BOOL OnMove(int nSrcIndex, int nDestIndex);
};
#endif

////////////////////////////////////////////////////////////
// CBldOptDlg

class CBldOptDlg : public CDlgTab
{
protected:

			BOOL m_bAlreadyWarnedOfBuild;
			BOOL m_bExportDeps;
			BOOL m_bAlwaysExportMakefile;
			BOOL m_bWriteBuildLog;
			// Have we already warned that a build is going on.

			// CBldGrid m_BldGrid;

			VOID	CheckForBuildAndWarn ();
				// Warn the use if there's a build going on that changes
				//  won't take effect.

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBldOptDlg)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
					CBldOptDlg();
					~CBldOptDlg();

	virtual	BOOL	OnInitDialog();
	virtual	void	CommitTab();
	virtual BOOL	Activate(CTabbedDialog *, CPoint);
	virtual BOOL	ValidateTab();
	virtual void	OnClick();


#if 0
	BOOL OnAdd(int nIndex);
	BOOL OnDel(int nIndex);
	BOOL OnMove(int nSrcIndex, int nDestIndex);
	BOOL OnChange(int nIndex);
#endif

	//{{AFX_MSG(CBldOptDlg)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////

#if 0
// CBldGrid inlines
inline BOOL CBldGrid::OnChange(int nIndex)
{
	return m_pDlg->OnChange(nIndex);
}

inline BOOL CBldGrid::OnAddString(int nIndex)
{
	return m_pDlg->OnAdd(nIndex);
}

inline BOOL CBldGrid::OnDeleteString(int nIndex)
{
	return m_pDlg->OnDel(nIndex);
}

inline BOOL CBldGrid::OnMove(int nSrcIndex, int nDestIndex)
{
	return m_pDlg->OnMove(nSrcIndex, nDestIndex);
}
#endif


#endif // __BLDDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\autoprj.h ===
// AutoPrj.h : header file
//
#include <utilauto.h>
#include <ObjModel\bldauto.h>
#include <ObjModel\bldguid.h>
#include "autoguid.h"
#include "bldiface.h"


class CAutoProjects;

/////////////////////////////////////////////////////////////////////////////
// CAutoProject command target

class CAutoProject : public CAutoObj
{
	friend class CAutoProjects;
	DECLARE_DYNCREATE(CAutoProject)

	CAutoProject();           // protected constructor used by dynamic creation

// Attributes
public:
	static CAutoProject* Create(HBUILDER hBld, LPCTSTR szName);

// Operations
public:
	DECLARE_DUAL_ERRORINFO();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoProject)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	HBUILDER m_hBld;
	CString m_strName;
	CString m_strFullName;
	LPDISPATCH m_pConfigs;
	virtual ~CAutoProject();

	// Generated message map functions
	//{{AFX_MSG(CAutoProject)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoProject)
	afx_msg BSTR GetName();
	afx_msg BSTR GetFullName();
	afx_msg BSTR GetType();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH GetConfigurations();
	afx_msg void AddFile(LPCTSTR szFile, const VARIANT FAR& Reserved);
	afx_msg void AddConfiguration(LPCTSTR szConfiguration, const VARIANT FAR& Reserved);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

 	DS_BEGIN_DUAL_INTERFACE_PART(BuildProject)
		STDMETHOD(get_Name)(THIS_ BSTR FAR* Name);
		STDMETHOD(get_FullName)(THIS_ BSTR FAR* FullName);
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application);
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent);
	    STDMETHOD(get_Type)(THIS_ BSTR FAR* pType);
		STDMETHOD(get_Configurations)(THIS_ IConfigurations FAR* FAR* Configurations);
	    STDMETHOD(AddFile)(THIS_ BSTR szFile, VARIANT Reserved);
	    STDMETHOD(AddConfiguration)(THIS_ BSTR szConfiguration, VARIANT Reserved);
		DS_DECLARE_VTBL_PAD_10()
 	DS_END_DUAL_INTERFACE_PART(BuildProject)
 
 	DS_DECLARE_ENABLE_DUAL(CAutoProject, BuildProject)
};

/////////////////////////////////////////////////////////////////////////////
// CLinkAutoObjToProject

// This object serves as an intermediary between CProject and
//  the automation objects that depend on it.  When one goes away
//  the other is notified by this object.

class CLinkAutoObjToProject
{
public:
	void OnProjectDestroyed(CProject* pProject);
	void OnAutoObjDestroyed(CAutoObj* pAutoObj);
	void OnAutoObjCreated(CAutoObj* pAutoObj, HBUILDER hBld);

protected:
	// If both automation objects and CProject's are around, it's
	//  more frequent that the automation objects will be
	//  created/destroyed than CProject's being created and destroyed.
	//  So access is optimized for having a CAutoObj, and needing to
	//  find the linked CProject.
	CTypedPtrMap< CMapPtrToPtr, CAutoObj*, CProject* > m_PtrMap;
};

extern CLinkAutoObjToProject g_LinkAutoObjToProject;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\batchdlg.h ===
//
// batchdlg.h
//
// Defines CBatchBldDlg class, batch build dialog for building multiple
// project configurations in one go.
//
// Implementation is in : batchdlg.cpp
// 
// History:
// Date				Who			What
// 01/17/94			colint			created
//////////////////////////////////////////////////////////////////

#ifndef _BATCHDLG_H_
#define _BATCHDLG_H_

#include "resource.h"
#include "prjconfg.h"
#include "utilctrl.h"
#include <dlgbase.h>	// C3dDialog

/////////////////////////////////////////////////////////////////
// CBatchDlg class
// definition for batch build Dialog
//////////////////////////////////////////////////////////////////

class CBatchBldDlg: public C3dDialog
{
//  Construction 
public:
 	CBatchBldDlg ( CWnd * pParent = NULL );

// Dialog Data
	//{{AFC_DATA(CBatchBldDlg)
	enum { IDD = IDD_PROJECT_BATCH_BUILD } ;
	BOOL 		m_bRebuild;
	BOOL 		m_bClean;
	static BOOL	m_bSelectionOnly;
	//}}AFX_DATA

	CCheckList m_lbConfigs;
	CStringList * m_pBuildConfigs;
	static CMapStringToPtr m_mapSelected;

	static BOOL LoadBatchBldOpt(CArchive & archive);
	static BOOL SaveBatchBldOpt(CArchive & archive);

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	DECLARE_MESSAGE_MAP()

	void GetConfigs();

public:
	//{{AFX_MSG(CBatchBldDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnRebuild();
	afx_msg void OnClean();
	//}}AFX_MSG

// private data
private:
} ;

/////////////////////////////////////////////////////////////////
// CProjectsDlg class
// definition for select projects Dialog
//////////////////////////////////////////////////////////////////

class CProjectsDlg: public C3dDialog
{
//  Construction 
public:
 	CProjectsDlg ( CWnd * pParent = NULL );

// Dialog Data
	//{{AFC_DATA(CProjectsDlg)
	enum { IDD = IDD_SELECT_PROJECTS } ;
	BOOL 		m_bExport;
	BOOL 		m_bExportDeps;
	//}}AFX_DATA

	CCheckList m_lbProjects;
	static CMapStringToPtr m_mapSelectedProjects;

	// FUTURE: use these to persist selection
	static BOOL LoadProjectsSelOpt(CArchive & archive);
	static BOOL SaveProjectsSelOpt(CArchive & archive);

// Implementation
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectsDlg)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	DECLARE_MESSAGE_MAP()

	void GetProjects();

public:
	//{{AFX_MSG(CProjectsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	virtual void OnSelectAll();
	//}}AFX_MSG

// private data
private:
	CMapStringToPtr m_mapProjects;
} ;
#endif // _BATCHDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldiface.cpp ===
//
// CBldSysIFace
//
// Build System Interface
//
// [matthewt]
//

#include "stdafx.h"

#include "bldiface.h"	// local header
#include "depgraph.h"	// dep. graph
#include "exttarg.h"    // external target type
#include "awiface.h"    // Appwiz interface
#include "prjdlg.h"     // project/workspace dlg
#include "bldslob.h"	// target nodes in workspace window
#include "bldnode.h"	// build view

#include "optnlink.h"	// to include P_MachineType constant
#include "autoprj.h"

#include <resapi.h>
#include <resguid.h>
#include <prjapi.h>
#include <prjguid.h>
#include <sys\utime.h>
#include "oleref.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBldSysIFace g_BldSysIFace;	// one 'n' only bld system interface

CProject *g_pActiveProject = NULL;

extern CProjComponentMgr g_prjcompmgr;
extern CFileRegistry g_FileRegistry;
extern BOOL bJavaSupported, bJavaOnce; // defined in vproj.cpp
extern BOOL g_bNoUI;		// defined in project.cpp
extern BOOL g_bConversionPrompted;	// defined in project.cpp

extern CImageWell g_imageWell;	// project item glyphs

CMapStringToOb *CBldSysIFace::pUnknownDepMap = NULL;  //save the unknown dep list temporarily, we need to clean this up properly before we quit a project
CString g_strTarg = _TEXT("");

// Funky appwizard class interface thing. Will go away when the appwizard exports an interface through the shell
class CAppWizardHandler
{
public:
	CAppWizardHandler() {m_hDLL = (HINSTANCE)NULL; m_pAppWizIFace = NULL; }
	~CAppWizardHandler() {if (m_hDLL) FreeLibrary(m_hDLL); m_pAppWizIFace = NULL; }

	BOOL LoadAppWiz();
	__inline CAppWizIFace* GetAppWizIFace() { return m_pAppWizIFace; }

protected:
	HINSTANCE	m_hDLL;
	CAppWizIFace* m_pAppWizIFace;
};

// Loads appwiz, if it hasn't been loaded already.  Most of this code was cut & pasted from
//  the beginning of InvokeAppwizAndCreateTarget.
BOOL CAppWizardHandler::LoadAppWiz()
{
	TCHAR rgchModName[MAX_PATH];
	CPath pathAppwzName;

	GetModuleFileName(GetResourceHandle(), rgchModName, sizeof(rgchModName));
	if (!pathAppwzName.Create(rgchModName))
	{
		// enable file registry file change notification
		g_FileRegDisableFC = FALSE;
		return FALSE;
	}

#ifdef _DEBUG
	pathAppwzName.ChangeFileName(_T("MFCAPWZD.DLL"));
#else
	pathAppwzName.ChangeFileName(_T("MFCAPWZ.DLL"));
#endif

	// check if it's already been loaded, if not we'll attempt to load it
	if (!m_hDLL)
		m_hDLL = SushiLoadLibrary((const TCHAR *)pathAppwzName, TRUE);

	// is this loaded?
	if (!m_hDLL)
		return FALSE;	// failure to load the dll

	// now, set up m_pAppWizIFace.
	PGETAPPWIZIFACE pGetAppWizIFace = (PGETAPPWIZIFACE) GetProcAddress(m_hDLL, GETAPPWIZIFACE);
	ASSERT (pGetAppWizIFace != NULL);

	m_pAppWizIFace = (*pGetAppWizIFace)();
	ASSERT (m_pAppWizIFace != NULL);

	return TRUE;
}

static CAppWizardHandler g_AppWizardHandler;

CAppWizIFace* GetAppWizIFace()
{
	return g_AppWizardHandler.GetAppWizIFace();
}

CProjComponentMgr * CBldSysIFace::GetProjComponentMgr()
{
	return &g_prjcompmgr;
}

CFileRegistry * CBldSysIFace::GetFileRegistry()
{
	return &g_FileRegistry;
}

CBldSysIFace::CBldSysIFace() {
}

CBldSysIFace::~CBldSysIFace() {
    DeleteUnknownDepMap();
}

//
// Builder object conversion
//
CProject * CBldSysIFace::CnvHBuilder(HBUILDER hBld)
{
	CProject * pProject = (CProject *)(hBld != ACTIVE_BUILDER ? hBld : GetActiveBuilder());
	return pProject;
}

CTargetItem * CBldSysIFace::CnvHTarget(HBUILDER hBld, HBLDTARGET hTarg)
{
	if (hTarg==ACTIVE_TARGET)
	{
		if (hBld == ACTIVE_BUILDER)
			hBld = GetActiveBuilder();

		if (hBld != NO_BUILDER)
		{
			return ((CProject *)hBld)->GetActiveTarget();
		}
		return NULL;
	}
	
	if (hTarg==NO_TARGET)
		return NULL;

	if (hBld == ACTIVE_BUILDER)
		hBld = GetBuilder(hTarg); // don't trust caller default

	if (hBld==NO_BUILDER)
		return NULL;

	return CnvHBuilder(hBld)->GetTarget(m_strlstTargets.GetAt((POSITION)hTarg));
}

CTargetItem * CBldSysIFace::CnvHFileSet(HBUILDER hBld, HFILESET hFileSet)
{
	CTargetItem * pTargetItem = (CTargetItem *)(hFileSet != ACTIVE_FILESET ? hFileSet : (HFILESET)CnvHTarget(hBld, GetActiveTarget(hBld)));
	if( pTargetItem == NULL )
		return pTargetItem;

	ASSERT_VALID(pTargetItem);
	return pTargetItem;
}

CFileItem * CBldSysIFace::CnvHBldFile(HFILESET hFileSet, HBLDFILE hFile)
{
	ASSERT_VALID((CFileItem *)hFile);
	return (CFileItem *)hFile;
}

CProjectDependency * CBldSysIFace::CnvHProjDep(HFILESET hFileSet, HPROJDEP hProjDep)
{
	ASSERT_VALID((CProjectDependency *)hProjDep);
	return (CProjectDependency *)hProjDep;
}

HFILESET CBldSysIFace::GetFileSet(HBUILDER hBld, HBLDTARGET hTarg)
{
	return (HFILESET)CnvHTarget(hBld, hTarg);
}

BOOL CBldSysIFace::RenameTarget
(
	const TCHAR * pchTargFrom, 
	const TCHAR * pchTargTo
)
{
	CString strKey = pchTargFrom;
	CString strNewName = pchTargTo;
	strKey.MakeUpper();	// case insensitive lookup
	strNewName.MakeUpper();
 	
	// get our target name
	POSITION pos = m_strlstTargets.Find(strKey);
	if (pos != NULL)
	{
#if 0 // this logic is broken
#ifdef _DEBUG
		// make sure we're not trying to change the builder name here!
		HBUILDER hBld = GetBuilder((HBLDTARGET)pos);
		CTargetItem * pTarget = CnvHBuilder(hBld)->GetTarget(pchTargTo);
		CString strProjName = pTarget->GetTargetName();
		int len = strProjName.GetLength();
		ASSERT(_tcsnicmp(strProjName, pchTargTo, len)==0);
#endif
#endif
		m_strlstTargets.SetAt(pos, strNewName);
		return TRUE;
	}

	return FALSE;
}

BOOL CBldSysIFace::GetFlavourFromConfigName
(
	const TCHAR * pchConfigName,
	CString & strFlavour
)
{
	// Form the whole configuration name
	CString strConfig = pchConfigName;
	int nFirst = strConfig.ReverseFind(_T('-'));
	ASSERT(nFirst != -1);
	nFirst += 2; // Skip over hyphen and trailing space

	CString strPlatformAndFlavour = strConfig.Right(strConfig.GetLength() - nFirst);
	CString strRemain;

	do 
	{
		CString strPlatform;
		CPlatform * pPlatform;	
		g_prjcompmgr.InitPlatformEnum();
		while (g_prjcompmgr.NextPlatform(pPlatform))
		{
			strPlatform = *(pPlatform->GetName());
			if (strPlatform.Compare(strPlatformAndFlavour.Left(strPlatform.GetLength())) == 0)
			{
				// Found the platform.
				strFlavour = strPlatformAndFlavour.Right(strPlatformAndFlavour.GetLength() - (strPlatform.GetLength() + 1));
				return TRUE;
 			}
		}
		strRemain = strConfig.Left(nFirst-2);
		nFirst = strRemain.ReverseFind(_T('-'));
		if (nFirst != -1 && (strRemain.GetLength()>4))
		{
			nFirst += 2;
			strPlatformAndFlavour = strConfig.Right(strConfig.GetLength() - nFirst);
		}
		else
		{
			// no more '-', we didn't get a standard config name, but...
			// olympus 1991 [patbr] look again using short name for Intel
			CString strWinPlatform("Win32");
			if (strWinPlatform.Compare(strPlatformAndFlavour.Left(strWinPlatform.GetLength())) == 0)
			{
				// Found the platform.
				strFlavour = strPlatformAndFlavour.Right(strPlatformAndFlavour.GetLength() - (strWinPlatform.GetLength() + 1));
				return TRUE;
			}
			else
			{
				ASSERT(FALSE);
				return FALSE;
			}
		}
	} while (1);

	return FALSE;
}

//
// Build system enabled?
//
// Dsabled if,
// o no supported platform is installed

BOOL CBldSysIFace::BuildSystemEnabled()
{
	BOOL fSupportedPlatform = FALSE;

	// make sure we have a SUPPORTED platform
	CPlatform * pPlatform;
	g_prjcompmgr.InitPlatformEnum();
	while (g_prjcompmgr.NextPlatform(pPlatform))
	{
		//if (pPlatform->IsPrimaryPlatform())
		if (pPlatform->IsSupported ())
		{
			fSupportedPlatform = TRUE;
			break;
		}
	}

	return fSupportedPlatform;	// ok
}

//
// Builder query API
//

// Get the active builder
HBUILDER CBldSysIFace::GetActiveBuilder() 
{
	return (HBUILDER)g_pActiveProject;
}

HBUILDER CBldSysIFace::GetBuilder(HBLDTARGET hTarg) 
{
	HBUILDER hBld;
	if (m_mapPrjTargets.Lookup(hTarg, (void *&)hBld))
		return (hBld);

	return NO_BUILDER;
}

HBUILDER CBldSysIFace::GetBuilderFromFileSet(HFILESET hFileSet) 
{
	CTargetItem * pTarget = CnvHFileSet(ACTIVE_BUILDER, hFileSet);
	if (pTarget != NULL)
		return (HBUILDER)(pTarget->GetProject());

	// if there is an HFileset the will be a builder
	// ASSERT(0);
	return NO_BUILDER;
}

HBUILDER CBldSysIFace::GetBuilderFromName(const TCHAR *	pchBld ) 
{
	CString strBld = pchBld;
	strBld.MakeUpper();

	CProject *pProject = NULL;
	POSITION pos = CProject::m_lstProjects.GetHeadPosition();  // use our own private pos pointer
	while (pos != NULL)
	{
		pProject = (CProject *)CProject::m_lstProjects.GetNext(pos);
		CString strProjectName;
		// VERIFY(pProject->GetStrProp(P_ProjItemName, strProjectName));

		ConfigurationRecord * pcr = pProject->GetActiveConfig();
		if(pcr)
			pcr->GetProjectName(strProjectName);

		strProjectName.MakeUpper();
		if( strProjectName == strBld ){
			return( (HBUILDER)pProject );
		}
	}

	return NO_BUILDER;
}

CString CBldSysIFace::GetNameFromBuilder(HBUILDER hBld) 
{
	CString strProjectName;
	CProject *pProject = CnvHBuilder(hBld);
	if(pProject != NULL ){
		ConfigurationRecord * pcr = pProject->GetActiveConfig();
		if(pcr)
			pcr->GetProjectName(strProjectName);
	}
	return strProjectName;
}

// Get the type of a builder
BuilderType CBldSysIFace::GetBuilderType
(
	HBUILDER		hBld		// builder to get type of, default='active builder'
)
{
	BuilderType bldType = InternalBuilder;
	CProject *pProject = CnvHBuilder(hBld);
	if(pProject != NULL ){
		if (pProject->IsExeProject())
			bldType = ExeBuilder;
		else
			bldType = InternalBuilder;
	}
	// if there is a build project in the workspace and something else is active 
	// then you can be sure that the build project is internal
    return bldType;
}

// need to dirty the workspace file whenever our changes affect its contents
void SetWorkspaceDocDirty()
{
	LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
	ASSERT(pProjSysIFace);
	VERIFY(SUCCEEDED(pProjSysIFace->SetWorkspaceDocDirty()));
}

// Get a builders filename
const CPath * CBldSysIFace::GetBuilderFile
(
	HBUILDER		hBld		// builder to get file for, default='active builder'
)
{
	CProject * pProject;
	if (hBld == ACTIVE_BUILDER || hBld == NO_BUILDER)
	{
		// Not a valid assertion (KiP)
		// ASSERT(g_pActiveProject != NULL);
		if( g_pActiveProject == NULL ){
			return NULL;
		}
		pProject = g_pActiveProject;
	}
	else
	{
		pProject = CnvHBuilder(hBld);
	}
	ASSERT_VALID(pProject);
	return pProject->GetFilePath();
}

//
// Builder creation API
//
// Using this API, a builder can be created, targets added, files added
// to those targets and tool settings & properties set for the files.
//
HBUILDER CBldSysIFace::CreateBuilder
(
	const TCHAR *	pchBldPath,	// builder path
	BOOL			fForce,		// force the creation
	BOOL			fOpen		// create and then read from storage (eg. makefile), default=create new
)
{
	//$UNDONE: fForce is no longer used (it used to close the previous workspace).
	// [fabriced] 25jul96
	
// 	// do we have an active builder?
//	HBUILDER hBld = GetActiveBuilder();
//	if (hBld != NO_BUILDER)
//	{
//        // if (!fForce)
//        //    return NO_BUILDER;
//
//	//UNDONE: save old workspace, actually
//        if (fForce && (!SaveBuilder(ACTIVE_BUILDER) || !CloseBuilder(ACTIVE_BUILDER)))
//            return NO_BUILDER;
//	}

	// REVIEW(kperry:9/96)
	// if we alread have a builder with the same name then fail
	// if the workspace is an exe workspace then fail.

	// As of the ne architecture we no longer have the right to set the active project

	// Create the project object
	CProject * pOldProject = g_pActiveProject;
	CProject * pProject;
	pProject = new CProject;
	g_pActiveProject = pProject;

	CPath WksPath;
	CDir WksDir;

	CDir dirOld; dirOld.CreateFromCurrent();
	CPath path;

	if (pchBldPath != (const TCHAR *)NULL && path.Create(pchBldPath))
	{
		// set the current directory to match the pathname 
		if( !_tcsicmp( path.GetExtension(), ".mdp") ) {
			path.ChangeExtension(".mak");
			pchBldPath = (const TCHAR *)path;
		}

		CDir currentDir; currentDir.CreateFromPath(path);
		currentDir.MakeCurrent();
	}

	// create new one or create and open from storage?
	if (fOpen)
	{
		// open an existing document
		if (!pProject->InitFromFile (pchBldPath, FALSE))
 			goto CreationError;

		// Inform the shell that we changed the current directory
		theApp.OnDirChange();

#if 0
		// REVIEW: leave the first project as the current one by default?
		if (pOldProject != NULL)
		{
			ASSERT(!fForce);
			g_pActiveProject = pOldProject;
		}
#endif
	}
	else
 	{
		// No private data to initialize for a new project.
		// Pls. note active target is initialised by calls to CBldSysIFace::AddTarget()
		pProject->m_bPrivateDataInitialized = TRUE;

		if (!pProject->InitNew(NULL))
			goto CreationError;

		if (pchBldPath != NULL)
		{
			CPath pathProjName;

			if	(!pathProjName.Create(pchBldPath) ||
				 !pProject->SetFile(&pathProjName))
				goto CreationError;

			pProject->InformDependants (SN_FILE_NAME);
		}
		else
		{
			CString strProjectName;

			VERIFY(pProject->GetStrProp(P_ProjItemName, strProjectName));
			// UNDONE (colint)
			// SetTitle (strProjectName); 
		}
		
#if 0
		// REVIEW: leave the first project as the current one?
		if (pOldProject != NULL)
		{
			ASSERT(!fForce);
			g_pActiveProject = pOldProject;
		}
#endif

		SetWorkspaceDocDirty();
	}

	// reset the current dir to the workspace directory
	WksPath.Create(*pProject->GetFilePath());
	ProjNameToWksName(WksPath);
	VERIFY(WksDir.CreateFromPath(WksPath));
	WksDir.MakeCurrent();
	// Inform the shell that we may have changed the current directory
	theApp.OnDirChange();

	// return a pointer to this newly created builder
	return (HBUILDER)pProject;

CreationError:

	g_pActiveProject = pOldProject;

	// Delete the project object
	if (pProject->m_bConvertedDS4x)
	{
		// may also need to delete temp projects
		POSITION pos = CProject::m_lstProjects.GetTailPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pProject = (CProject *)CProject::m_lstProjects.GetPrev(pos);
			if (pProject->m_bConvertedDS4x)
			{
				delete pProject;
			}
		}
	}
	else
	{
		delete pProject;
	}
	g_pActiveProject = pOldProject;
 
	// set back the current directory since it fails to open
	dirOld.MakeCurrent();

	return NO_BUILDER;
}

// Set the dirty state of the builder
BOOL CBldSysIFace::SetDirtyState
(
	HBUILDER	hBld,		// builder to dirty/clean, default='active builder'
	BOOL		fDirty		// default='dirty builder'
)
{
	// get the builder
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == NULL)
		return FALSE;	// no project, so clean

	// old dirty state?
	BOOL fOldDirty = pProject->IsDirty();

	// dirty or clean?
	if (fDirty)
		pProject->DirtyProject();
	else
		pProject->CleanProject();

	// return old dirty state
	return fOldDirty; 
}

// Get the dirty state of the builder
BOOL CBldSysIFace::GetDirtyState
(
	HBUILDER	hBld		// builder to dirty/clean, default='active builder'
)
{
	// get the builder
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == NULL)
		return FALSE;	// no project, so clean

	return(pProject->IsDirty());
}

// Save a builder.
BOOL CBldSysIFace::SaveBuilder
(
	HBUILDER		hBld		// builder to save, default='save active builder'
)
{
	BOOL bRetVal = FALSE;

	if (hBld == ACTIVE_BUILDER)
	{
		CString strBuilder = _T("<no name>");
		bRetVal = TRUE; // default
		// special case: close all builders
		InitBuilderEnum();
		while ((bRetVal) && ((hBld = GetNextBuilder(strBuilder, FALSE)) != NO_BUILDER))
		{
			ASSERT(hBld != ACTIVE_BUILDER);
			bRetVal == bRetVal && SaveBuilder(hBld);
		}
		return bRetVal;
	}

	ASSERT(hBld != NO_BUILDER);

	// Get the builder
   	CProject * pProject = CnvHBuilder(hBld);
	ASSERT(pProject);
	if( pProject == NULL )
		return bRetVal;

    // Only need to save internal project file's, i.e. makefiles
    if (GetBuilderType(hBld) == InternalBuilder)
    {
	    // get a builder for this target to be searched in
    	CProject * pProject = CnvHBuilder(hBld);
		const CPath * pPath = pProject->GetFilePath();

		BOOL bIsSccActive = (g_pSccManager->IsSccInstalled() == S_OK);
		BOOL bIsSccOpInProgress = (g_pSccManager->IsSccOpInProgress() == S_OK);
		CStringArray files;
		if (pPath->IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)*pPath) == S_OK))
		{
			files.Add((const TCHAR*)*pPath);
		}
		if (g_bAlwaysExportMakefile)
		{
			CPath path = *pPath;
			path.ChangeExtension(_T(".mak"));
			if (path.IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
			{
				files.Add((const TCHAR*)path);
			}
			path.ChangeExtension(_T(".dep"));
			if ((g_bAlwaysExportDeps) && (path.IsReadOnlyOnDisk()) && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
			{
				files.Add((const TCHAR*)path);
			}
		}
		if ((!pProject->m_bProjExtConverted) && ((files.GetSize() > 0) || (pPath->IsReadOnlyOnDisk())) && (pProject->IsDirty()) &&
			((!bIsSccActive) || (files.GetSize() == 0) || (g_pSccManager->CheckOutReadOnly(files, TRUE, FALSE) == S_FALSE)))
		{
            if (bIsSccOpInProgress)
			{
				bRetVal = TRUE; // we're probably trying to check this out
			}
			else if (pPath->IsReadOnlyOnDisk())
			{
				CString strMsg;
				MsgText(strMsg, IDS_SAVE_READ_ONLY, (const TCHAR *)*pPath);
				if ((!g_bConversionPrompted) && g_pAutomationState->DisplayUI() && !g_bNoUI) //ShellOM:State
				{
						bRetVal = (MsgBox(Error, strMsg, MB_OKCANCEL)==IDOK);
				}
				else if (theApp.m_bInvokedCommandLine)
				{
					
					theApp.WriteLog(strMsg + _T("\n"), TRUE);
					bRetVal = TRUE; // keep going
				}
				else
				{
					bRetVal = TRUE; // REVIEW: oh well
				}
			}
			else
			{
				bRetVal = TRUE;
			}
		}
#if 0
		else if (pProject->m_bProjExtConverted)
		{
			// Do SaveAs to allow rename if wrapped makefile
			g_bWriteProject = TRUE;
			bRetVal = pProject->DoSaveAs();
		}
#endif
		else
		{
			// if it's still read-only, assume user said no or in scc op
			if (!pPath->IsReadOnlyOnDisk())
			{
				g_bWriteProject = TRUE;
				CPath OptPath(*pPath);
				bRetVal = pProject->DoSave();

				if (bRetVal) pProject->m_bProjMarkedForSave = FALSE;
				// get .mdp path and force time stamp to be newer than
				// .mak. This will allow us to detect an updated .mak when
				// we open the project, and ignore the .mdp contents.
				ProjNameToOptName(OptPath);// UNDONE: bogus
				_utime(OptPath, NULL);
			}
			else
				bRetVal = TRUE;
		}
    }
    else
        bRetVal = TRUE;

	return bRetVal;
}
  
HBUILDER CBldSysIFace::DeactivateBuilder(HBUILDER hBld)
{
	ASSERT(hBld);
	CProject * pProject = (CProject *)hBld;

	// set active project to something else
	if (pProject && pProject == g_pActiveProject)
	{
		CProject * pActiveProject;
		g_pActiveProject = NULL;  	// we may no longer have an active project!
		POSITION pos = CProject::m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pActiveProject = (CProject *)CProject::m_lstProjects.GetNext(pos);
			if ((pActiveProject != NULL) && (pActiveProject != pProject))
			{
				ASSERT_VALID(pActiveProject);
				if (pActiveProject->IsLoaded())
				{
					HBLDTARGET hTarget = GetActiveTarget((HBUILDER)pActiveProject);
					if (hTarget==NO_TARGET)
					{
						CTargetItem * pTargetItem;
						CString strTargetName;
						pActiveProject->InitTargetEnum();
						VERIFY(pActiveProject->NextTargetEnum(strTargetName, pTargetItem));
						hTarget = GetTarget(strTargetName, (HBUILDER)pActiveProject);
						ASSERT (hTarget);
					}
					SetActiveTarget(hTarget, (HBUILDER)pActiveProject);
					break;
				}
				else
				{
					g_pActiveProject = pActiveProject; // at least we have one
				}
			}
		}
	}
	return (HBUILDER)g_pActiveProject;
}

// Close a builder.
BOOL CBldSysIFace::CloseBuilder
(
	HBUILDER	hBld,			// builder to close, if == ACTIVE_BUILDER, then close active builder
	DeletionCause dcCause
)
{
	if (hBld == ACTIVE_BUILDER)
	{
		// actually closing the workspace
#ifdef PERF_MEASUREMENTS
		DWORD dwCloseStartTime = 0;

		if (theApp.m_bPerfQA_Workspace)
		{
			theApp.dwWorkspaceTime = 0;
			dwCloseStartTime = ::GetTickCount( );
		}
#endif // PERF_MEASUREMENTS

		CString strBuilder = _T("<no name>");
		BOOL retval = TRUE; // default
		// special case: close all builders
		InitBuilderEnum();
		while ((retval) && ((hBld = GetNextBuilder(strBuilder, FALSE)) != NO_BUILDER))
		{
			ASSERT(hBld != ACTIVE_BUILDER);
			g_bInProjClose = TRUE;
			retval = retval && CloseBuilder(hBld,dcCause);
			InitBuilderEnum(); // hack: must re-init, since first project was just removed!
		}
		g_bInProjClose = FALSE;

#ifdef PERF_MEASUREMENTS
		if (theApp.m_bPerfQA_Workspace)
		{
			DWORD dwCloseEndTime = ::GetTickCount( );
			theApp.dwWorkspaceTime = dwCloseEndTime - dwCloseStartTime;
		}
#endif // PERF_MEASUREMENTS

		return retval;
	}

	ASSERT(hBld != ACTIVE_BUILDER);
	// Get the builder
   	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == (CProject *)NULL)
		return TRUE;	// nothing to do

	hBld = (HBUILDER)pProject; // make sure not NULL
	if (!pProject->m_bProjectComplete)
	{
		ASSERT(0);
		return FALSE;  // avoid recursion
	}

	if (!theApp.NotifyPackages(PN_QUERY_CLOSE_PROJECT))
		return FALSE;
 
	
	// set active project to something else
	if (pProject == g_pActiveProject)
	{
		DeactivateBuilder((HBUILDER)pProject);
	}

	// Must remove nodes before we say that the project is closed
    // otherwise the prj package will attempt to delete our nodes
    // which we can't handle.
	GetBuildNode()->RemoveNodes(hBld);

#if 1 // REVIEW: may not be needed once ClassView handles PN_CLOSE_PROJECT properly
    if (pProject->GetActiveConfig() != NULL)
    {
	CTargetItem * pTarget = pProject->GetActiveTarget();
	if (pTarget != NULL)
		theApp.NotifyPackages(PN_DEL_FILESET, (void *)(HFILESET)pTarget);
    }
#endif

	CString strName;
	pProject->GetName(strName);
	
	

	// Do NOT move this line.  We must notify other packages of the close 
	// project before we do everything below (like deleting the file registry)

	IBSProject * pIBSProject = pProject->GetInterface();
	IPkgProject *pPkgProj;
	pIBSProject->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
	theApp.NotifyPackages(PN_CLOSE_PROJECT, (void *)pPkgProj);
	pPkgProj->Release();
	pIBSProject->Release();

	delete pProject;

	// if we are deleting this project from the workspace then delete all the
	// project deps that refer to it.
	if( dcCause == ProjectDelete ){
		::RemoveAllReferences(strName);
	}
	
	// only do this when we're closing the very last project
	if (g_pActiveProject==NULL)
	{
		// olympus 16 (briancr)
		// Clear the global file registry after closing a workspace.
		// Theoretically, we shouldn't have to do this since an FRH gets deleted
		// when its reference count reaches zero.

#ifndef REFCOUNT_WORK
		g_FileRegistry.DeleteAll();
#else
#ifdef _DEBUG
		if (!g_FileRegistry.IsEmpty() )
			AfxDump(&g_FileRegistry);
#endif
		// This assertion is causing problems??
		//	ASSERT(g_FileRegistry.IsEmpty());
#endif

		m_lstDepSet.RemoveAll();
		m_lstFileSet.RemoveAll();
		m_lstFile.RemoveAll();

		// olympus 2424 (briancr)
		// the fix for olympus 16 overlooked clearing pUnknownDepMap, so do it here
		DeleteUnknownDepMap();

		// end olympus 16 fix
	}

	return TRUE;	// success
}

BOOL CBldSysIFace::OnOpenWorkspace(const TCHAR *pszWorkspaceName, BOOL bTemporary, BOOL bInsertingIntoWks)
{
    ASSERT(GetFileError()==CFileException::none); // should already be reset by this point
    // reset global file error
    SetFileError(CFileException::none);
	g_bBadConversion = FALSE;

	// remember the directory we had before builder creation
 	CDir oldDir; oldDir.CreateFromCurrent();

#ifdef PERF_MEASUREMENTS
	DWORD dwOpenStartTime = 0;

	if (theApp.m_bPerfQA_Workspace)
	{
		theApp.dwWorkspaceTime = 0;
		dwOpenStartTime = ::GetTickCount( );
	}
#endif // PERF_MEASUREMENTS

	// disable file registry file change notification during builder creation
	BOOL bOldDisable = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	CPath MakeFilePath;
	MakeFilePath.Create(pszWorkspaceName);
	if (_tcsicmp(MakeFilePath.GetExtension(), _T(WORKSPACE_EXT))==0)
	{
		// don't even try to read a .wks file here
		ASSERT(0); // should be caught by workspace loader
		return FALSE;
	}

	// open up a builder? (non-appwiz created -> this is part of the workspace)
	HBUILDER hBld;
	hBld = g_BldSysIFace.CreateBuilder(MakeFilePath, !bInsertingIntoWks /* force close old */, TRUE /* open */);

	// do we have a valid builder?
	if (hBld == NO_BUILDER)
	{
		// enable file registry file change notification
		g_FileRegDisableFC = bOldDisable;
		return FALSE;
	}

	CProject *pProject = g_BldSysIFace.CnvHBuilder(hBld);
	IBSProject *pBSProj = pProject->GetInterface();
	COleRef<IPkgProject> pPkgProject;
	pBSProj->QueryInterface(IID_IPkgProject, (void **)&pPkgProject);
	pBSProj->Release();
	if (g_pProjWksIFace && !bInsertingIntoWks)
		g_pProjWksIFace->AddProject(pPkgProject, FALSE);

	pProject = g_pActiveProject;

	// enable file registry file change notification
	g_FileRegDisableFC = bOldDisable;

	// Scan the project dependencies if needed.  We do this here instead
	// of in the project, so the window can be displayed first:
	BOOL bWasReadOnly = pProject->WasReadOnly();

	if (pProject->m_bProjMarkedForScan)
	{
		// If this project was read-only at load time, reset that state
		// now; otherwise, the scan will "dirty" the project and cause
		// a warning message:
		if (bWasReadOnly)
			pProject->ResetReadOnly();

		// Do the scan:
		//BOOL bProjectDirty = pProjDoc->m_pNotifySlob->IsProjectDirty(pProject);
		pProject->DoTopLevelScan();

		if (pProject->m_bProjConverted && (!((pProject->m_bConvertedDS4x) || (pProject->m_bConvertedVC20) || (pProject->m_bConvertedDS5x))))
			pProject->ConvertDeps();

		//if (!bProjectDirty) 
			// This scan should in fact not dirty the project (only if the project is not marked
			// dirty :
		//	pProject->InformDependants(SN_PROJ_PUBLICS_CLEAN);

		// If the project was read-only at load time, recheck that state:
		if (bWasReadOnly)
			pProject->RecheckReadOnly();
	}

	if (!pProject->IsExeProject())
	{
		if (pProject->m_bProjMarkedForSave)
		{
	   		// Opening an newly-created project (Wizard callback)
			if (pProject->m_bProjConverted)
			{
				// Make sure we save the converted project, <Cancel> will
				// abort the open document file
				g_bWriteProject = TRUE;
				pProject->SetOkToDirtyProject();
				pProject->DirtyProject();

				if (pProject->m_bProjExtConverted)
				{
					// Do SaveAs to allow rename if wrapped makefile
					if (!pProject->DoSaveAs())
						return FALSE;
				}
				else if ((!pProject->m_bConvertedDS5x) || (!pProject->GetFilePath()->IsReadOnlyOnDisk())) // scc not init yet!
				{
					pProject->DoSave();
				}

				// Set the name of the new workspace
				LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
				if (!bInsertingIntoWks)
				{
					CPath Path = *(pProject->GetFilePath());
					Path.ChangeExtension(WORKSPACE_EXT);
	                VERIFY(SUCCEEDED(pProjSysIFace->SetWorkspaceDoc((const TCHAR *)Path)));
				}
				VERIFY(SUCCEEDED(pProjSysIFace->SetWorkspaceDocDirty()));

				if (pProject->m_bConvertedDS4x)
				{
					// Also need to save any converted subprojects
					CProject::InitProjectEnum();
					CString strProject;
					CProject * pNewProject;
					while ((pNewProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
					{
						if ((pNewProject != pProject) && (pNewProject->m_bProjMarkedForSave) && (pNewProject->m_bConvertedDS4x))
						{
							pNewProject->SetOkToDirtyProject();
							pNewProject->DirtyProject();
							g_bWriteProject = TRUE;
							pNewProject->DoSave();
						}
					}
                }
			}
			else if (!bWasReadOnly)
			{
				// Re-save project in verbose format
				// FUTURE (karlsi): should do this quietly, if possible
				g_bWriteProject = TRUE;
				pProject->DoSave();
			}
		}
	}

	if (pProject->m_bConvertedDS4x)
	{
		// Also need to save any converted subprojects
		POSITION pos = CProject::m_lstProjects.GetHeadPosition(); // most use our own pointer
		CProject * pNewProject;
		ASSERT(pos != NULL);
		while (pos != NULL)
		{
			pNewProject = (CProject *)CProject::m_lstProjects.GetNext(pos);
			ASSERT(pNewProject);
			if ((pNewProject != NULL) && (pNewProject->m_bProjMarkedForSave))
			{
				pNewProject->m_bProjMarkedForSave = FALSE;

				// Inform packages that we've opened an existing project
				COleRef<IBSProject> pIBSProject = pNewProject->GetInterface();
				COleRef<IPkgProject> pPkgProj;
				pIBSProject->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
            	if ((g_pProjWksIFace) && (pPkgProj != pPkgProject))
            		g_pProjWksIFace->AddProject(pPkgProj, FALSE);

				if (g_pProjWksIFace && (!bInsertingIntoWks || (pNewProject != g_pActiveProject)))
					theApp.NotifyPackages(PN_OPEN_PROJECT, (void *)pPkgProj);
                pPkgProj.SRelease();

				pNewProject->m_bConvertedDS4x = FALSE;
			}
		}
	}
	else
	{
		if ((!pProject->m_bConvertedDS5x) || (!pProject->GetFilePath()->IsReadOnlyOnDisk())) // scc not init yet!
		{
			pProject->m_bProjMarkedForSave = FALSE;
		}
		else
		{
			ASSERT(pProject->IsDirty());
		}
		
		pProject->m_bConvertedDS5x = FALSE;

			// Inform packages that we've opened an existing project
		COleRef<IBSProject> pIBSProject = pProject->GetInterface();
		COleRef<IPkgProject> pPkgProj;
		pIBSProject->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
		if (g_pProjWksIFace && !bInsertingIntoWks)
			theApp.NotifyPackages(PN_OPEN_PROJECT, (void *)pPkgProj);
	}

#ifdef _DEBUG
#ifdef USE_LOCAL_BUILD_HEAP
	// heap debug info.
	afxDump << "\nBuild System Node Heap\n";
	CGrNode::g_heapNodes.Dump(afxDump);

	afxDump << "\nBuild System File Heap\n";
	CFileRegEntry::g_heapEntries.Dump(afxDump);
#endif
#endif // _DEBUG

#ifdef PERF_MEASUREMENTS
	if (theApp.m_bPerfQA_Workspace)
	{
		DWORD dwOpenEndTime = ::GetTickCount( );
		theApp.dwWorkspaceTime = dwOpenEndTime - dwOpenStartTime;
	}
#endif // PERF_MEASUREMENTS

	return TRUE;
}

BOOL CBldSysIFace::OpenWorkspace(const TCHAR *pchWorkspace)
{
    return(FALSE);
}

BOOL CBldSysIFace::OnDefaultWorkspace(const TCHAR *pszFileToAdd)
{
	// Create a default project
	CPath pathProjName, pathFileToAdd;

	pathProjName.Create(pszFileToAdd);
	pathProjName.ChangeExtension(_T(BUILDER_EXT)); 

	pathFileToAdd.Create(pszFileToAdd);

	// See if the .PJX file already exists.  If so, warn the user.
	if (pathProjName.ExistsOnDisk())
	{
		CString	strT;

		if (MsgBox(	Question,
					MsgText(strT,
							IDS_WARN_OVERWRITE_EXISTING_PROJ,
							(const TCHAR *)pathProjName), MB_YESNO)
					== IDNO)
			return FALSE;

		// Delete the .PJX file.
		pathProjName.DeleteFromDisk();
 	}

	// create a new builder, force close the old one if it exists
	HBUILDER hBld = g_BldSysIFace.CreateBuilder((const TCHAR *)pathProjName.GetFullPath(), FALSE /* force close old */);
	if (hBld == NO_BUILDER)
		return FALSE;	// failure

	LPSOURCEQUERY pSrcQuery;
	LPSOURCEEDIT pDoc;
	CString Language;
	BOOL fJavaFile = FALSE;

    if (SUCCEEDED (theApp.FindInterface (IID_ISourceQuery, (LPVOID *)&pSrcQuery)))
	{
		if (SUCCEEDED (pSrcQuery->CreateSourceEditForDoc ((PSTR) pszFileToAdd, &pDoc, FALSE)))
		{
			pDoc->GetLanguage (Language);
			if (Language == "Java")
				fJavaFile = TRUE;
			pDoc->Release ();
		}
		pSrcQuery->Release ();
	}
	// Find the 'console' project type:
	//
	CProjType *	pProjType;

	g_prjcompmgr.InitProjTypeEnum();

	if (fJavaFile)
	{
		while (g_prjcompmgr.NextProjType(pProjType))
			if (pProjType->GetUniqueTypeId() == CProjType::javaapplet)
				break;
		
		VERIFY(pProjType->GetUniqueTypeId()==CProjType::javaapplet);
	}
	else
	{
		while (g_prjcompmgr.NextProjType(pProjType))
			if ((pProjType->GetPlatform()->IsPrimaryPlatform())
				&& (pProjType->GetUniqueTypeId()==CProjType::consoleapp))
				break;

		VERIFY(pProjType->GetUniqueTypeId()==CProjType::consoleapp);
	}
	// create the project as a default 'simple' one
	// o not using MFC
	// o not using output directories
	HBLDTARGET hDebugTarg, hReleaseTarg;
	(void) g_BldSysIFace.AddDefaultTargets
			(
				(const TCHAR *)*pProjType->GetPlatformName(),	// 'official' name of this target's platform
				(const TCHAR *)*pProjType->GetTypeName(),		// 'official' name of this target type
				hDebugTarg, hReleaseTarg,						// our newly created targets (returned)
				FALSE,											// we're using 'official' names
				TRUE,											// not using output directories
				FALSE											// not using MFC
			);

	// Add the specified file to the project:
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	pProject->AddFile(&pathFileToAdd);

	// Save the project.
	SaveBuilder(hBld);

	COleRef<IBSProject> pIBSProject = pProject->GetInterface();
	COleRef<IPkgProject> pPkgProj;
	pIBSProject->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
	if(g_pProjWksIFace)
		g_pProjWksIFace->AddProject(pPkgProj, FALSE);
	theApp.NotifyPackages (PN_NEW_PROJECT, (void *)pPkgProj);
	if(g_pProjWksIFace)
		g_pProjWksIFace->SetActiveProject(pPkgProj, TRUE);
	// Enable config change notifications (because this isn't done in this case otherwise,
	// since we don't try to load a vcp file)
	pProject->m_bNotifyOnChangeConfig = TRUE;

    return TRUE;
}

//
// Fileset API
//

HFILESET CBldSysIFace::GetFileSetFromTargetName
(
	const TCHAR *	pchTarget,		// name of this fileset to get
	HBUILDER		hBld			// handle to the builder containing the target, default='active builder'
)
{
	if (hBld == ACTIVE_BUILDER || hBld == NO_BUILDER )
	{
		// search all builders
		CString strBuilder;
		InitBuilderEnum();
		HFILESET retval = NO_FILESET;
		while ((hBld = GetNextBuilder(strBuilder, TRUE)) != NO_BUILDER)
		{
			ASSERT(hBld != ACTIVE_BUILDER);
			retval = GetFileSetFromTargetName(pchTarget, hBld);
			if (retval != NO_FILESET)
				break;	// got one
		}
		return retval;
	}

	// null-terminated empty string?
	if (*pchTarget == _T('\0'))
		return NO_FILESET;

	CString strFileSetName;
	InitFileSetEnum(hBld);
	HFILESET hFileSet = GetNextFileSet();
	while (hFileSet != NO_FILESET)
	{
		VERIFY(GetFileSetName(hFileSet, strFileSetName, hBld));
		CString strProject = pchTarget;
  		int iDash = strProject.Find(_T(" - "));
  		if (iDash > 0)
  	      strProject = strProject.Left(iDash);

		if (!strFileSetName.CompareNoCase(strProject))
			return hFileSet;

		hFileSet = GetNextFileSet();
	}

	return NO_FILESET;
}

BOOL CBldSysIFace::GetFileSetName
(
	HFILESET		hFileSet,					// Fileset to get name of
	CString &		str,						// Fileset name
	HBUILDER		hBld                		// handle to the builder containing the fileset, default='active builder'
)
{
	// NYI for anything other than the active builder.
	// ASSERT(hBld == ACTIVE_BUILDER);

	// Get the target item associated with the fileset
	CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
	if(pTarget == NULL){
		return FALSE;
	}

	// Get the target items config array
	const CPtrArray* pConfigArray = pTarget->GetConfigArray();
	int nSize = pConfigArray->GetSize();

	// Look for the first valid config for this target item
	ConfigurationRecord * pcr = NULL;
	for (int i = 0; i < nSize; i++)
	{
		pcr = (ConfigurationRecord*)pConfigArray->GetAt(i);
		if (pcr->IsValid())
 			break;
	}

	if (pcr == NULL)
		return FALSE;

	// Get the name of the valid config that we found
	CString strConfig = pcr->GetConfigurationName();
	CString strTemp = strConfig;

	// Form the whole configuration name
	int cbLen = strConfig.GetLength();
	int nFirst;
	do
	{
		nFirst = strTemp.Find(_T('-'));
		ASSERT(nFirst != -1);
		strTemp = strConfig.Left(nFirst);
	} while ((nFirst > 0) && (strConfig[nFirst-1]!=_T(' ')));

	ASSERT(strConfig[nFirst+1]==_T(' '));
	nFirst += 2; // Skip over hyphen and trailing space

	CString strPlatformAndFlavour = strConfig.Right(cbLen - nFirst);
	CString strRemain;

	do 
	{
		CString strPlatform;
		CPlatform * pPlatform;	
		g_prjcompmgr.InitPlatformEnum();
		while (g_prjcompmgr.NextPlatform(pPlatform))
		{
			strPlatform = *(pPlatform->GetName());
			if (strPlatform.Compare(strPlatformAndFlavour.Left(strPlatform.GetLength())) == 0)
			{
				// Found the platform.
				str = strConfig.Left(cbLen - strPlatformAndFlavour.GetLength() - 3);
				return TRUE;
 			}
		}
		strRemain = strPlatformAndFlavour;
		strTemp = strRemain;
		do
		{
			nFirst = strTemp.Find(_T('-'));
			if (nFirst != -1)
				strTemp = strRemain.Left(nFirst);
		} while ((nFirst > 0) && (strRemain[nFirst-1]!=_T(' ')));

		if (nFirst != -1 && (strRemain.GetLength()>4))
		{
			ASSERT(strRemain[nFirst+1]==_T(' '));
			nFirst += 2;
			strPlatformAndFlavour = strRemain.Right(strRemain.GetLength() - nFirst);
		}
		else
		{
			// no more '-', we didn't get a standard config name, but...
			// olympus 1991 [patbr] look again using short name for Intel
			CString strWinPlatform("Win32");
			if (strWinPlatform.Compare(strPlatformAndFlavour.Left(strWinPlatform.GetLength())) == 0)
			{
				// Found the platform.
				str = strConfig.Left(cbLen - strPlatformAndFlavour.GetLength() - 3);
				return TRUE;
			}
			else
			{
				ASSERT(FALSE);
				return FALSE;
			}
		}
	} while (1);

	return FALSE;
}

BOOL CBldSysIFace::GetTargetNameFromFileSet
(
	HFILESET		hFileSet,					// Fileset to get name of
	CString &		str,						// Fileset name
	HBUILDER		hBld,						// handle to the builder to match, default='active builder'
	BOOL			bInvalid					// If there is no target that matches the current default project then
												// we just get a valid target, unless this is TRUE, in which case we
												// return "fileset name - No matching configuration", default='FALSE'
)
{
	str.Empty();
 	// Get a project pointer
	CProject * pMatchProject;
	if ((hBld == ACTIVE_BUILDER) || (hBld == NO_BUILDER))
		pMatchProject = (CProject *)GetActiveBuilder();
	else
		pMatchProject = (CProject *)hBld;

	if(pMatchProject == NULL)
	{
		return FALSE;
	}
	
	// Get the name of the active config to match
	ConfigurationRecord * pcr = pMatchProject->GetActiveConfig();
	if (pcr==NULL) // can happen during project creation
	{
		// ASSERT(0);
		return FALSE;
	}

	HBUILDER hTargetBld = GetBuilderFromFileSet(hFileSet); // don't trust default
	CString strActiveConfig = pcr->GetConfigurationName();
	CString strMatchingDescription;
	pcr->GetConfigurationDescription(strMatchingDescription);

	CString strFileSet, strFlavor;

	// Get the fileset name
	if (!GetFileSetName(hFileSet, strFileSet, hTargetBld))
		return FALSE;

	// Get the build flavour name
	GetFlavourFromConfigName(strActiveConfig, strFlavor);
	// filesetname + platform + " "
	strActiveConfig = strActiveConfig.Left(strActiveConfig.GetLength() - strFlavor.GetLength());
	// get platform name
	int nSep = strActiveConfig.ReverseFind(_T('-'));
	strActiveConfig = strActiveConfig.Right(strActiveConfig.GetLength() - nSep + 1);

	// Form the fileset name
	str = strFileSet + strActiveConfig + strFlavor;
	// Lookup the fileset name in the target list
	CString strTargetName = str;
	strTargetName.MakeUpper();	// case insensitive lookup
 	HBLDTARGET hTarg = (HBLDTARGET)m_strlstTargets.Find(strTargetName);
	if (hTarg == NO_TARGET)
	{
		if (!bJavaOnce)
		{
			bJavaOnce=TRUE;
			bJavaSupported = IsPackageLoaded(PACKAGE_LANGJVA);
		}
		if (bJavaSupported)
		{
			// This is a hack of all hacks...
			// If Java is the active config, then anything with the same flavor matches.
			// If not, then we have to check to see if the fileset supports
			// Java.  If it does, then it will match anything with the same flavor.

			CString strSubPlat, 
				    strSubFlavor,
					strWin32Target, strOtherTarget,
			        strJavaPlat = " - Java Virtual Machine " + strFlavor, 
					strWin32Plat = " - Win32 " + strFlavor;
			CStringList strlstTargs;

			GetFileSetTargets (hFileSet, strlstTargs);

			// to get all targets for this fileset 
			POSITION pos = strlstTargs.GetHeadPosition();
			while (pos != NULL)
			{
				// First, is the default platform java and is there a target with
				// the same flavor?

				strTargetName = strlstTargs.GetNext(pos);
				GetFlavourFromConfigName (strTargetName, strSubFlavor);

				int nSep1 = strTargetName.ReverseFind(_T('-'));
				strSubPlat = strTargetName.Right(strTargetName.GetLength() - nSep1 + 1);


				if (strSubPlat == strJavaPlat)
				{
					str = strTargetName;
					return (TRUE); 
				}

				if (strSubPlat == strWin32Plat)
				{
					strWin32Target = strTargetName;
					break;
				}
				if (strOtherTarget.IsEmpty () && strSubFlavor == strFlavor)
					strOtherTarget = strTargetName;					
			}
			if (strActiveConfig == " - Java Virtual Machine ")
			{
				if (!strWin32Target.IsEmpty ())
				{
					str = strWin32Target;
					return (TRUE); 
				}
				else if (!strOtherTarget.IsEmpty ())
				{
					str = strOtherTarget;
					return (TRUE); 
				}
			}
		}

		// No configuration of the fileset that matches the current default project's
		// configuration, so we just pick a configuration that does exist for the fileset
		if (bInvalid)
		{
			CString strNoMatch;
			strNoMatch.LoadString(IDS_NO_MATCHING_CONFIG);

 			str = strFileSet + _T(" - ") + strNoMatch;
			return FALSE;
		}
		else
		{
			CStringList strlstTargs;
			GetFileSetTargets (hFileSet, strlstTargs);

			// to get all targets for this fileset 
			int nLongest = 0;
			POSITION pos = strlstTargs.GetHeadPosition();
			while (pos != NULL)
			{
				// First, is the default platform java and is there a target with
				// the same flavor?

				CString strConfigName = strlstTargs.GetNext(pos);
				// get the platform
				CProject *pProject = (CProject *)hTargetBld;
				ConfigurationRecord * pcr = pProject->ConfigRecordFromConfigName(strConfigName);
				//     how many characters match 
				//     if this is longer than the longest so far,
				//			this is our new longest

				// GetFlavourFromConfigName (strTargetName, strSubFlavor);
				CString strDescription;
				pcr->GetConfigurationDescription ( strDescription );
				int nMax;
				if(strDescription.GetLength() > strMatchingDescription.GetLength() ){
					nMax = strMatchingDescription.GetLength();
				} else {
					nMax = strDescription.GetLength();
				}

				int i=0;
				while( i < nMax && strDescription[i] == strMatchingDescription[i] ){
					i++;
				}
				if( i > nLongest){
					nLongest = i;
					str = pcr->GetConfigurationName();
				}

			}
			if( nLongest )
				return FALSE;

			InitTargetEnum(hTargetBld);
			hTarg = GetNextTarget(str, hTargetBld);
			while (hTarg != NO_TARGET)
			{
				if (GetFileSet(hTargetBld, hTarg) == hFileSet)
				{
					GetTargetName(hTarg, str, hTargetBld);
					return FALSE;
				}

				hTarg = GetNextTarget(str, hTargetBld);
			}
			return FALSE;
		}
	}
 
	return TRUE;
}

BOOL CBldSysIFace::GetTargetFromFileSet
(
	HFILESET		hFileSet,					// Fileset to get current target for
	HBLDTARGET &	hTarg,						// Target for the Fileset
	HBUILDER		hBld,                		// handle to the builder containing the fileset to match, default='active builder'
	BOOL			bInvalid					// If this is TRUE and we don't get a match then we return FALSE, if this
												// is FALSE then we always return some valid target. default=FALSE
)
{
	// Get the name of the fileset 
	CString strTargetName;
	if (!GetTargetNameFromFileSet(hFileSet, strTargetName, hBld, bInvalid) && bInvalid)
		return FALSE;

	// Lookup the fileset name in the target list
	strTargetName.MakeUpper();	// case insensitive lookup
 	hTarg = (HBLDTARGET)m_strlstTargets.Find(strTargetName);
	if (hTarg == NO_TARGET)
		return FALSE;

	// We found it
	return TRUE;
}

// Get the active target if there is on, or NO_TARGET if there isn't.
HBLDTARGET CBldSysIFace::GetActiveTarget
(
	HBUILDER		hBld		// handle to the builder containing the targets, default='active builder'
)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);

	if (pProject == NULL)
		return NO_TARGET;

	if (pProject->GetActiveConfig() == NULL)
		return NO_TARGET;

	// get our active target name
	CString strTarg = pProject->GetActiveConfig()->GetConfigurationName();

	return GetTarget((const TCHAR *)strTarg, (HBUILDER)pProject);
}

// Set the active target.
BOOL CBldSysIFace::SetActiveTarget
(
	HBLDTARGET		hTarg,		// target to make the active one
	HBUILDER		hBld		// handle to the builder containing the targets, default='active builder'
)
{
	if (g_Spawner.SpawnActive())
		return FALSE;

	ASSERT(hTarg != NO_TARGET);

	// get our target name
	CString strTarg = m_strlstTargets.GetAt((POSITION)hTarg);

	// get a builder for this target to be searched in
	if (hBld == ACTIVE_BUILDER)
		hBld = GetBuilder(hTarg); // don't trust caller default

	if( hBld == NO_BUILDER )
		return FALSE;

	CProject * pProject = CnvHBuilder(hBld);
	ASSERT(pProject != NULL);

	BOOL bRet = TRUE;
	if (pProject != g_pActiveProject)
	{
		COleRef<IPkgProject> pPkgProject;
		LPBSPROJECT pIProj = pProject->GetInterface();
		VERIFY(SUCCEEDED(pIProj->QueryInterface(IID_IPkgProject, (void **)&pPkgProject)));
		pIProj->Release();

		if(g_pProjWksIFace)
			bRet = SUCCEEDED(g_pProjWksIFace->SetActiveProject(pPkgProject, TRUE));

		//
		// review(tomse): Assertion is failing when build a non-active project and 
		// setting active project to the project that is already active.
		// This is probably because g_pActiveProject is the project being built, not
		// the active IPkgProject.
		// The SetActiveProject succeeds because it always succeeds when changing to the
		// already active project.
		//
		ASSERT(!bRet || pProject == g_pActiveProject);

		//
		// QUICK FIX for #20767.
		// Leave assert but return FALSE instead doing further processing for
		// active project that really didn't change.
		//
		if (bRet && pProject != g_pActiveProject)
			return FALSE;
	}

	// set this target as our active one
	if(bRet)
		bRet = g_pActiveProject->SetStrProp(P_ProjActiveConfiguration, strTarg);
	if(bRet)
		pProject->SetActiveConfig(strTarg);

	return bRet;	// ok?
}

BOOL CBldSysIFace::SetDefaultTarget
(
	HBLDTARGET		hTarg,		// target to make the default one
	HBUILDER		hBld		// handle to the builder containing the targets, default='active builder'
)
{
	ASSERT(hTarg != NO_TARGET);

	if (hBld == ACTIVE_BUILDER)
		hBld = GetBuilder(hTarg); // don't trust caller default

	if( hBld == NO_BUILDER )
		return FALSE;

	// get our target name
	CString strTarg;
    if (!GetTargetName(hTarg, strTarg, hBld))
        return FALSE;

	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);

	// set this target as our active one
    pProject->m_strProjDefaultConfiguration = strTarg;

	return TRUE;	// ok?
}

// Get a target with name 'pchTarg' from the builder, 'hBld'.
HBLDTARGET CBldSysIFace::GetTarget
(
	const TCHAR *	pchTarg,	// name of this target to get
	HBUILDER		hBld		// handle to the builder containing the target, default='active builder'
)
{
	// null-terminated empty string?
	if (*pchTarg == _T('\0'))
		return NO_TARGET;

	CString strKey = pchTarg;
	strKey.MakeUpper();	// case insensitive lookup
	HBLDTARGET hTarg = (HBLDTARGET)m_strlstTargets.Find(strKey);
	
	if (hTarg == NO_TARGET)
	{
		// It is okay for someone to ask us for a TARGET when there is no BUILDER. We should
		// just answer no.

		if (hBld != NO_BUILDER)
		{
			hTarg = (HBLDTARGET)m_strlstTargets.AddTail(strKey);
			m_mapPrjTargets.SetAt(hTarg, hBld);
		}
	}

	return hTarg;
}

// Set the active target, Can be NO_BUILDER
BOOL CBldSysIFace::SetActiveBuilder
(
	HBUILDER		hBld		// handle to the builder containing the targets, default='active builder'
)
{
	CProject * pProject;
	if(hBld != NO_BUILDER)
		pProject = CnvHBuilder(hBld);
	else
		pProject = NULL;

	if (pProject == NULL)
	{
		if (NULL != g_pActiveProject)
		{
			g_pActiveProject = pProject;
			// don't notify if project is null!
			// newly activated project will notify
		}
		return TRUE;
	}

	if (pProject->GetActiveConfig() == NULL)
		return FALSE;

	// get our active target name
	CString strTarg = pProject->GetActiveConfig()->GetConfigurationName();

	pProject->SetActiveConfig(strTarg);
	if (pProject != g_pActiveProject)
	{
		g_pActiveProject = pProject;
	}

	// set this target as our active one
	BOOL fRet = g_pActiveProject->SetStrProp(P_ProjActiveConfiguration, strTarg);

	return fRet;	// ok?
}

BOOL CBldSysIFace::GetProjectDir(HBLDTARGET hTarget, HBUILDER hBld, CString &str)
{
	if (hBld == ACTIVE_BUILDER)
		hBld = GetBuilder(hTarget); // don't trust caller default
	if (hBld == NO_BUILDER)
		return FALSE;

	CTargetItem *pTarget = CnvHTarget(hBld, hTarget);

	if  (pTarget)
	{
		str = (const TCHAR *)pTarget->GetTargDir();
		if (str.IsEmpty())
		{
			str = CnvHBuilder(hBld)->GetWorkspaceDir();
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CBldSysIFace::GetWorkspaceDir(HBUILDER hBld, CString& str)
{
	CProject * pProject = (CProject *)(hBld != ACTIVE_BUILDER ? hBld : GetActiveBuilder());
	if (pProject)
	{
		str = (const TCHAR *)pProject->GetWorkspaceDir();
		return TRUE;
	}
	return FALSE;	
}


BOOL CBldSysIFace::GetTargetName
(
	HBLDTARGET		hTarg,		// target to get name of
	CString &		str,		// target name
	HBUILDER		hBld		// handle to the builder containing the target, default='active builder'
)
{
	if (hTarg == NO_TARGET)
		return FALSE;

	hBld = GetBuilder(hTarg); // don't trust caller default

	if (hBld == NO_BUILDER)
		return FALSE;

	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);
    if (pcr != NULL)
	    str = pcr->GetConfigurationName();
 	return (pcr != NULL);
}

// Create a target with name 'pchTarg' and add it to a builder.
// Name of the 'official' platform must be specified in 'pchPlat', eg. "Win32 (x86)"
// Name of the target type must be specified in 'pchType', eg. "Application"
// Create debug or release default settings when a file is added to this target, 'fDebug'?
// A target can mirror another target's, 'hMirrorTarg', fileset.
// Function may fail (HBLDTARGET == NO_TARGET).
HBLDTARGET CBldSysIFace::AddTarget
(
	const TCHAR *	pchTarg,				// name of this target

	const TCHAR *	pchPlat,				// name of this target's platform
	const TCHAR *	pchType,				// name of this target type
	BOOL			fUIDesc,				// platform and type are UI descriptions?
   
   	BOOL			fDebug,					// debug or release settings? default=debug

	TrgCreateOp		trgop,					// clone or mirrors another target? default=no
	HBLDTARGET		hOtherTarg,				// target to clone or mirror

	SettingOp		setop,					// copy or default settings?
	HBLDTARGET		hSettingsTarg,			// target to copy settings from 

	BOOL			bQuiet,					// show any warnings/errors during creation? default=yes
	BOOL			fOutDir,				// output directories? default=no
 	BOOL			fUseMFC,				// use MFC? default=yes
	HBUILDER		hBld					// builder that contains target? default=('current'==ACTIVE_BUILDER) 
)
{
	ASSERT(hBld != ACTIVE_BUILDER);
	if( hBld == ACTIVE_BUILDER || hBld == NO_BUILDER )
		return NO_TARGET;

 	// a string version of our target type, eg. 'Win32 (x86) Application" 
	CString strTargName = CProjType::MakeNameFromPlatformAndType(pchPlat, pchType);

	CProjType * pProjType;
	if ((!fUIDesc && !g_prjcompmgr.LookupProjTypeByName((LPCTSTR)strTargName, pProjType)) ||
		(fUIDesc && !g_prjcompmgr.LookupProjTypeByUIDescription((LPCTSTR)strTargName, pProjType))
	   )
		return NO_TARGET;

	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	CProjTempProjectChange projChange(pProject);

	// store away the current config so we can reset it at the end of this
	// operation
	CString strActiveConfig;
	pProject->GetStrProp(P_ProjActiveConfiguration, strActiveConfig);

	// adjust our use of MFC
	fUseMFC = fUseMFC && g_prjcompmgr.MFCIsInstalled();

	// disable notification while we create this configuration
	pProject->m_bNotifyOnChangeConfig = FALSE;

	// a string version of our target name
	CString strTarg;
	if (pchTarg != (const TCHAR *)NULL)
	{
		strTarg = pchTarg;	// user-supplied
	}
	else
	{
		// auto-created by us
 		DefaultConfig(pProject, *(pProjType->GetPlatformUIDescription()), fDebug ? IDS_DEBUG_CONFIG : IDS_RELEASE_CONFIG, strTarg);
	}

	// string versions of our 'other' targets name
	CString strOtherTarg, strSettingsTarg;

	// do we have these?
	if (hOtherTarg != NO_TARGET)
		strOtherTarg = m_strlstTargets.GetAt((POSITION)hOtherTarg);
	else
		ASSERT(trgop == TrgDefault);		// with no other target we must have this

	if (hSettingsTarg != NO_TARGET)
		strSettingsTarg = m_strlstTargets.GetAt((POSITION)hSettingsTarg);
	else
		ASSERT(setop == SettingsDefault);	// with no settings target we must have this!

	CObList olItemList;
	POSITION pos;
	CProjItem *pItem;

	HBLDTARGET hTarg = (HBLDTARGET)GetTarget(strTarg, hBld);
	VERIFY(pProject->CreateTarget(strTarg, pProjType, trgop == TrgMirror ? strOtherTarg : _TEXT("")));

	ConfigurationRecord * pcrNewTarg = GetConfigRecFromTargetI(hTarg, hBld);
	CTargetItem * pNewTarget = pProject->GetTarget(strTarg);
	const CPlatform * pNewPlatform = pProjType->GetPlatform();

	// inform the graph of this target that it is being created
	UINT oldmode = g_buildengine.GetDepGraph(pcrNewTarg)->SetGraphMode(Graph_Creating);

	// set target dir
	if (!g_strTarg.IsEmpty())
		pNewTarget->SetTargDir(g_strTarg);

	if (pNewTarget->GetTargetName().IsEmpty())
	{
		int index = strTarg.Find(" - ");
		ASSERT(index > 0);
		CString strTargetName = strTarg.Left(index);
		pNewTarget->SetTargetName(strTargetName);
		if (pProject->GetTargetName().IsEmpty())
			pProject->SetTargetName(strTargetName);
		ASSERT(strTargetName == pProject->GetTargetName());
	}

	// establish output dirs for new target?
	CString strProjDir = _TEXT("");
	CString strOutDirs;
	if (fOutDir)
	{
		if (!g_strTarg.IsEmpty() )
		{
			CPath path;
			CDir  dir;

			TCHAR buffer[MAX_PATH];
			_tcscpy( buffer, (LPCSTR)g_strTarg );
			int nLen = _tcslen( buffer );

			if( *_tcsdec( buffer, buffer+ nLen ) != _T('\\') ) {
				_tcscat( buffer, _T("\\") );
			}
			// add a dummy file for CPath
			_tcscat( buffer, _T("a") );

			path.Create( buffer );
			dir = pProject->GetWorkspaceDir();

			path.GetRelativeName( dir, strProjDir );
			// remove the dumy filename
			strProjDir = strProjDir.Left( strProjDir.GetLength() - 1 );


			// remove the leading ".\"  if GetRelativeName succeeded
			if ( (strProjDir.Find('.') == 0) && (strProjDir.Find('\\') == 1)  ) {
				strProjDir = strProjDir.Right(strProjDir.GetLength()-2);
			}

			// remove ending '\\'
			int ich = strProjDir.ReverseFind('\\');
			if (ich != -1 && ich == strProjDir.GetLength()-1)
			{
				strProjDir = strProjDir.Left(strProjDir.GetLength()-1);	
			}
		}
		if (pchTarg != (const TCHAR *)NULL)
		{
			if (!g_strTarg.IsEmpty())
			{
				CPath path;
				CString strConfig;
				GetFlavourFromConfigName(strTarg, strConfig); 

				if ( (strConfig.Compare("Debug") == 0) || (strConfig.Compare("Release") == 0) )
				{
					strOutDirs = *(pProjType->GetPlatform()->GetDefOutDirPrefix());
					if (strOutDirs.IsEmpty())
					{
						// x86 platform
						strOutDirs += fDebug ? _T("Debug") : _T("Release");
					}
					else
					{
						// others
						strOutDirs += fDebug ? _T("Dbg") : _T("Rel");
					}
					if (path.CreateFromDirAndFilename(pProject->GetProjDir(), strOutDirs) 
						&& path.ExistsOnDisk())
					{
						GetNewOutputDirName(pProject, strTarg, strOutDirs);
					}
				}
				else
				{
					// added config, use config name as default dir
					strOutDirs += strConfig;
				}
			}
			else
			{
				// attempt to generate a unique name 
				GetNewOutputDirName(pProject, strTarg, strOutDirs);
			}
		}
		else
		{
			// set up defaults for intermediate and target directories
			strOutDirs = *(pProjType->GetPlatform()->GetDefOutDirPrefix());
			if (strOutDirs.IsEmpty())
			{
				strOutDirs += fDebug ? _T("Debug") : _T("Release");
			}
			else
			{
				strOutDirs += fDebug ? _T("Dbg") : _T("Rel");
			}
		}

		ASSERT(!strOutDirs.IsEmpty());

		// Java doesn't write output to a different directory for now.
		if (pProjType->GetPlatform()->GetUniqueId() == java)
			strOutDirs = "";

		if (!g_strTarg.IsEmpty() )
		{
			CString strTmp;

			if (!strProjDir.IsEmpty())
			{
				if (pProjType->GetPlatform()->GetUniqueId() == java)
					strTmp = strProjDir;
				else
					strTmp = strProjDir + _T("\\") + strOutDirs;
			}
			else
			{
				strTmp = strOutDirs;
			}
			strOutDirs = strTmp;
		}

		// need to set dirs earlier for powermac dll, because we might add files
		// if ((pNewPlatform->GetUniqueId() == macppc) && ((pProjType->GetAttributes() & ImageDLL) != 0))
		{
			pProject->SetStrProp(P_OutDirs_Intermediate, strOutDirs);
			pProject->SetStrProp(P_OutDirs_Target, strOutDirs);
			pProject->SetStrProp(P_Proj_TargDir, strProjDir);
		}
	}

	// assign the build actions
	CActionSlob::AssignActions(pNewTarget, (CPtrList *)NULL, pcrNewTarg);


	// do the target-level settings
	if (setop != SettingsClone)
	{
		// create a fresh configuration here

		// set the debug/release default settings	
		pProject->SetIntProp(P_UseDebugLibs, fDebug); // used for MFC libs

		// set a deferred browser database make
		pProject->SetIntProp(P_NoDeferredBscmake, FALSE);

		if (fDebug)
			VERIFY(g_prjcompmgr.SetDefaultDebugToolOptions(pProject));
		else
			VERIFY(g_prjcompmgr.SetDefaultReleaseToolOptions(pProject));

		pProject->SetStrProp(P_ProjActiveConfiguration, strTarg);
		if (fDebug)
			VERIFY(pProjType->SetDefaultDebugTargetOptions(pProject, pNewTarget, fUseMFC));
		else
			VERIFY(pProjType->SetDefaultReleaseTargetOptions(pProject, pNewTarget, fUseMFC));
	}
	else
	{
		ASSERT(setop == SettingsClone);	// must be clone

		// we are creating a new config by cloning from an existing one

	 	// get the platform for the original 'settings' target
	    ConfigurationRecord * pcrOldTarg = GetConfigRecFromTargetI(hSettingsTarg, hBld);

		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig(pcrOldTarg);

		const CPlatform* pOldPlatform = pProject->GetProjType()->GetPlatform();
		projTempConfigChange.Release();

		// cross-platform?
		// if so then set up our default settings first
		if (pOldPlatform != pNewPlatform)
		{
			// copy in default tool settings
			if (fDebug)
				VERIFY(g_prjcompmgr.SetDefaultDebugToolOptions(pProject));
			else
				VERIFY(g_prjcompmgr.SetDefaultReleaseToolOptions(pProject));
		}

		// CreateConfig()  creates property bag ONLY in the project level, 
		// and the lower level will be created when SetStrProp(P_ProjActiveConfiguration,..)
		// is called.
		pProject->CopyCommonProps(pProject, strSettingsTarg);
		
		// after the prop bag is cloned
		// we need to reset
		// o original project type
		// o project configuration name
		// o active configuration name
		pProject->SetStrProp(P_ProjOriginalType, *pProjType->GetName());
		pProject->SetStrProp(P_ProjConfiguration, strTarg);
		pProject->SetStrProp(P_ProjActiveConfiguration, strTarg);

		// cross-platform?
		// if so then set up our us of MFC
		if (pOldPlatform != pNewPlatform)
		{
			// if we were using MFC make sure we use the right default
			// o we want NoMFC if none, or the library if dll is not supported
			int iUseMFC, iUseMFCDef;

			if (fUseMFC)
				iUseMFCDef = (pNewPlatform->GetAttributes() & PIA_Allow_MFCinDLL) ? UseMFCInDll : UseMFCInLibrary;
			else
				iUseMFCDef = NoUseMFC;

	 		if (!pProject->GetIntProp(P_ProjUseMFC, iUseMFC) || iUseMFC > iUseMFCDef)
				iUseMFC = iUseMFCDef;

			pProject->SetIntProp(P_ProjUseMFC, iUseMFC);

			// not handled in ::InformDependants do it here 
			if (!pProject->m_bProjectComplete)
				// we need to make sure we have the right setup
				// for an MFC project
				pProjType->PerformSettingsWizard(pProject, iUseMFC);

			// Set up the Machine option as this will be incorrect
			UINT nPlatformId = pNewPlatform->GetUniqueId();
			UINT nMachineProp;
			switch (nPlatformId)
			{
				case win32x86:		nMachineProp = 2;	break;
				case win16x86:		nMachineProp = 1;	break;
				case mac68k:		nMachineProp = 3;	break;
				case macppc:		nMachineProp = 5;	break;
				case win32alpha:	nMachineProp = 4;	break;
				default:			nMachineProp = 2;	break;	// default to x86
 			}

			COptionHandler * popthdlr;
			VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker),
												 (CBldSysCmp *&)popthdlr));
 			pProject->SetIntProp (popthdlr->MapLogical(P_MachineType), nMachineProp);
 		}

		// also need to inform dependants that things are changing
		pProject->InformDependants(SN_ALL);
	} 

	if (fOutDir)
	{
		pProject->SetStrProp(P_OutDirs_Intermediate, strOutDirs);
		pProject->SetStrProp(P_OutDirs_Target, strOutDirs);
		pProject->SetStrProp(P_Proj_TargDir, strProjDir);
	}

	// do the file-level settings
	if (setop != SettingsClone)
	{
		// Copy any files we need to
		if (trgop == TrgCopy)
		{
			// Get the target to copy from and the target to copy to.
			CTargetItem* pTarget = pProject->GetTarget(strOtherTarg);
 			ASSERT_VALID(pTarget);
			ASSERT_VALID(pNewTarget);

 			// Now copy all the files
			HFILESET hFileSet = GetFileSet(ACTIVE_BUILDER, hTarg);
			for (POSITION pos = pTarget->GetHeadPosition(); pos != NULL;)
			{
				CObject* pOb = pTarget->GetNext(pos);
				// We copy only fileitems except target references
 				if (pOb->IsKindOf(RUNTIME_CLASS(CFileItem)) && !pOb->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
  					(void)AddFile(hFileSet, ((CFileItem *)pOb)->GetFilePath(), FALSE, hBld);
  			}
		}
		else
		{
            // We are mirroring files so we must preserve deps
			if (!g_bNewUpdateDepModel)
				PreserveDependencies(pNewTarget, pProject);
		}

		// we have to make sure that we don't have multiple .rc and .def
		// defined
		// 
		// First, flatten the subtree
		CObList FileItemList;
		const ConfigurationRecord * pcr = pProject->GetActiveConfig();
		ASSERT_VALID(pNewTarget);
		CFileRegistry* pTargetRegistry = pNewTarget->GetRegistry();
		
		BOOL fMultiRC = pTargetRegistry->GetFileItemList(pNewTarget, pTargetRegistry->GetRCFileList(),
													   FileItemList, FALSE, pcr) && FileItemList.GetCount() > 1;
		BOOL fMultiDEF = pTargetRegistry->GetFileItemList(pNewTarget, pTargetRegistry->GetDEFFileList(),
														FileItemList, FALSE, pcr) && FileItemList.GetCount() > 1;

		// need to make the check?
		if (fMultiRC || fMultiDEF)
		{
			BOOL fInformOfMultiRC = fMultiRC, fInformOfMultiDEF = fMultiDEF;

			pNewTarget->FlattenSubtree(olItemList, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeGroups);
			for (pos = olItemList.GetHeadPosition(); pos != NULL ;)
			{
				pItem = (CProjItem *) olItemList.GetNext(pos);
				if (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem))) // only interested in file items
					continue;

				CPtrList * pFileList;
				if (pTargetRegistry->GetFileList(pItem->GetFilePath(), (const CPtrList * &)pFileList))	// multiple ext file?
				{
					TCHAR * pExt = (TCHAR *)NULL;
					BOOL fMulti = FALSE;
					if (pFileList == pTargetRegistry->GetRCFileList())
					{
						fMulti = fMultiRC;
						if (fInformOfMultiRC)
						{
							pExt = _TEXT(".rc");
							fInformOfMultiRC = FALSE;
						}
					}
					else if (pFileList == pTargetRegistry->GetDEFFileList())
					{
						fMulti = fMultiDEF;
						if (fInformOfMultiDEF)
						{
							pExt = _TEXT(".def");
							fInformOfMultiDEF = FALSE;
						}
					}
					else
						// need to recognise other multiple file sets!
						ASSERT(FALSE);

					// multiple of these?
					if (!fMulti)
						continue;	// no!

					if (pExt == (TCHAR *)NULL)
					{
						// exclude this item from build	(both for default and current prop. bags)
						pItem->SetIntProp(P_ItemExcludedFromBuild, TRUE);

						int idOldBag = pItem->UsePropertyBag(BaseBag);
						pItem->SetIntProp(P_ItemExcludedFromBuild, TRUE);
						(void) pItem->UsePropertyBag(idOldBag);
					}
					else
					{
						// warn of this file? (only if not in quiet mode)
						if (!bQuiet)
							InformationBox(IDS_FILE_TYPE_EXISTS, pExt);
					}
				}
			}
		}
	}
	else
	{
		// Get the target to copy from and the target to copy to.
		CTargetItem* pTarget = pProject->GetTarget(strOtherTarg);
		CTargetItem* pNewTarget = pProject->GetTarget(strTarg);
		ASSERT_VALID(pTarget);
		ASSERT_VALID(pNewTarget);

		// Copy any files we need to
		if (trgop == TrgCopy)
		{
 			// Now copy all the files
			HFILESET hFileSet = GetFileSet(ACTIVE_BUILDER, hTarg);
			for (POSITION pos = pTarget->GetHeadPosition(); pos != NULL;)
			{
				CObject* pOb = pTarget->GetNext(pos);
 				if (pOb->IsKindOf(RUNTIME_CLASS(CFileItem)) && !pOb->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
  					(void)AddFile(hFileSet, ((CFileItem *)pOb)->GetFilePath(), FALSE, hBld);
  			}
		}

		// we have to clone the CProjItem's property bags as well
		// but we can only do this AFTER setting the P_ProjActiveConfiguration 
		// property (above), since that is the time where the property bags
		// at the lower lever are created.
		// 
		// First, flatten the destination subtree
 		pNewTarget->FlattenSubtree(olItemList, CProjItem::flt_Normal | 
								   CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjDeps);
		if (trgop == TrgCopy)
		{
			// We are copying files so the src and destination items are NOT the same, so
			// we must flatten the src target subtree too
			CObList olSrcItemList;
			pTarget->FlattenSubtree(olSrcItemList, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | 
									CProjItem::flt_ExcludeProjDeps);

			// Now we iterate through the subtrees, getting corresponding items from each flattened subtree
			POSITION posSrc, posDest;
            CProjItem *pSrcItem, *pDestItem;
			for (posSrc = olSrcItemList.GetHeadPosition(), posDest = olItemList.GetHeadPosition(); 
				 posSrc != NULL && posDest != NULL ;)
			{
				// Get the destination and src projitems
				pDestItem = (CProjItem *) olItemList.GetNext(posDest);
				pSrcItem = (CProjItem *) olSrcItemList.GetNext(posSrc);

				// Clone the property bag
				pDestItem->CopyCommonProps(pSrcItem, strSettingsTarg);

				// Set the base settings to be the same as the current settings at the
				// time of the copy
				pDestItem->SetCurrentConfigAsBase(); // copy the prop bag to default prop bag

				// also need to inform dependants that things are changing
				pDestItem->InformDependants(SN_ALL);
 			}
		}
		else
		{
			ASSERT(trgop == TrgMirror);		// Must be mirror

            // We are mirroring files so we must preserve deps
			if (!g_bNewUpdateDepModel)
				PreserveDependencies(pNewTarget, pProject);

			// We are mirroring which means the src and destination items are the same
			// So loop through the destination list of projitems
			for (pos = olItemList.GetHeadPosition(); pos != NULL ;)
			{
				// Get the src, and destination projitem
				pItem = (CProjItem *) olItemList.GetNext(pos);
			 	
			 	// Copy the current settings
			 	pItem->CopyCommonProps(pItem, strSettingsTarg);

                // Set the base settings to be the same as the current settings at the
                // time of the copy
                pItem->SetCurrentConfigAsBase(); // copt the prop bag to default prop bag

				// also need to inform dependants that things are changing
				pItem->InformDependants(SN_ALL);
 			}
		}
	}

	// inform the graph of this target that it is now back in its original state
	(void) g_buildengine.GetDepGraph(pcrNewTarg)->SetGraphMode(oldmode);

	// finally make sure that we remember the 'base' (default) options
 	pProject->SetCurrentConfigAsBase();

	// set 'default' config to first debug config. created
 	if (fDebug &&
 		(pProject->m_strProjDefaultConfiguration.IsEmpty() ||
		 pProjType->GetPlatform()->IsPrimaryPlatform()     ||
		 pProjType->GetPlatform()->GetUniqueId() == java)			 
	   )
	{
		pProject->m_strProjDefaultConfiguration = strTarg;
	}

	// Make sure we are in the same config we were in when we
	// started to do this operation
	if (!strActiveConfig.IsEmpty())
		pProject->SetStrProp(P_ProjActiveConfiguration, strActiveConfig);

	// re-enable config. change notifications
	pProject->m_bNotifyOnChangeConfig = TRUE;

	// Send out a notification to other packages to tell them that
	// there is a new target
	if (pProject->m_bProjectComplete)
    {
		LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
        BOOL bWorkspaceInitialised = pProjSysIFace->IsWorkspaceInitialised() == S_OK;
		pProject->m_listTargIncl.AddTarget (hTarg);

        if (bWorkspaceInitialised)
    		theApp.NotifyPackages(PN_ADD_TARGET, (void *)hTarg);
    }

	return hTarg;
}

BOOL CBldSysIFace::AddDefaultTargets
(
	const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
	const TCHAR *	pchType,				// UI or 'official' name of this target type

	HBLDTARGET &	hDebugTarg,				// our created debug target
	HBLDTARGET &	hReleaseTarg,			// our created release target

	BOOL			fUIDesc,				// using UI or 'official' names? default=UI
	BOOL			fOutDir,				// output directories? default=yes
	BOOL			fUseMFC,				// use MFC? default=yes

	HBLDTARGET		hMirrorTarg,			// do we want to 'chain the mirroring'?
	HBUILDER		hBld,					// builder that contains target? default='active builder'
	const TCHAR *	pchTarg 				// name of this target, default use NULL to official names
)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	hBld = (HBUILDER)pProject; // convert ACTIVE_PROJECT to actual value;
	if( hBld == NO_BUILDER )
		return FALSE;

	g_strTarg = pProject->GetWorkspaceDir();
	
	CProjTempProjectChange projChange(pProject);

	hDebugTarg = hReleaseTarg = NO_TARGET;

	CString strTarg;

	// a string version of our target type, eg. 'Win32 (x86) Application" 
	CString strTargName = CProjType::MakeNameFromPlatformAndType(pchPlat, pchType);

	// Get the project type for these targets
	CProjType * pProjType = NULL;
	if ((!fUIDesc && !g_prjcompmgr.LookupProjTypeByName((LPCTSTR)strTargName, pProjType)) ||
		(fUIDesc && !g_prjcompmgr.LookupProjTypeByUIDescription((LPCTSTR)strTargName, pProjType))
	   )
		return FALSE;

	//
	// create our release config. for this project type
	//

	if (pchTarg != NULL)
	{
		CString strMode, strPlatformUIDescription;
		VERIFY(strMode.LoadString(IDS_RELEASE_CONFIG));
		strPlatformUIDescription = *(pProjType->GetPlatformUIDescription());
		strTarg = pchTarg;	// user-supplied
		strTarg += _T(" - ") + strPlatformUIDescription + _T(" ") + strMode;
	}
	else
	{
		strTarg = _TEXT("");
	}

	hReleaseTarg = AddTarget
	(
		(pchTarg!=NULL) ? (LPCTSTR)strTarg:NULL,

		pchPlat,				// 'official' name of this target's platform
		pchType,				// 'official' name of this target type
		fUIDesc,				// we're using 'official' names

		FALSE,					// release settings

		hMirrorTarg == NO_TARGET ? TrgDefault : TrgMirror,	// default or 'chain-the-mirroring' target? default=no chaining
		hMirrorTarg,										// no target to clone or mirror

		SettingsDefault,		// default settings
		NO_TARGET,				// no target to copy settings from
		 
		FALSE,					// show any warnings/errors during creation? default=yes
		fOutDir,				// create output directories?
		fUseMFC,				// use MFC?
		hBld					// builder that contains target? default='active builder'
	);
	if (hReleaseTarg == NO_TARGET)
		return FALSE;	// failure

	//
	// create our debug config. for this project type
	//
	
	if (pchTarg != NULL)
	{
		CString strMode, strPlatformUIDescription;
		VERIFY(strMode.LoadString(IDS_DEBUG_CONFIG));
		strPlatformUIDescription = *(pProjType->GetPlatformUIDescription());
		strTarg = pchTarg;	// user-supplied
		strTarg += _T(" - ") + strPlatformUIDescription + _T(" ") + strMode;
	}
	else
	{
		strTarg= _TEXT("");
	}

	hDebugTarg = AddTarget
	(
		(pchTarg!=NULL) ? (LPCTSTR)strTarg:NULL,

		pchPlat,				// 'official' name of this target's platform
		pchType,				// 'official' name of this target type
		fUIDesc,				// we're using 'official' names

		TRUE,					// debug settings

		TrgMirror,				// default target
		hReleaseTarg,			// mirror other default target

		SettingsDefault,		// default settings
		NO_TARGET,				// no target to copy settings from
		 
		FALSE,					// show any warnings/errors during creation? default=yes
		fOutDir,				// create output directories?
		fUseMFC,				// use MFC?
		hBld					// builder that contains target? default='active builder'
	);
	if (hDebugTarg == NO_TARGET)
		return FALSE;	// failure

 	// set active config to be the default
	pProject->SetStrProp(P_ProjActiveConfiguration, pProject->m_strProjDefaultConfiguration);

#if 0	// Groups temporarily disabled
	// UNDONE: fix default Group logic
	if (fOutDir && fUseMFC && (pchTarg!=NULL))
	{
		// Add default groups
		pProject->AddNewGroup("Source Files","cpp;c;cxx;rc;def");
		pProject->AddNewGroup("Header Files","h;hxx;hpp");
		pProject->AddNewGroup("Resource Files","ico;rc2;bmp"); // UNDONE
	}
#endif
	g_strTarg = "";
 
	return TRUE;	// success
}

// Delete an existing target
void CBldSysIFace::DeleteExeTarget
(
	HBLDTARGET		hTarg		// target to delete
)
{
	m_mapPrjTargets.RemoveKey(hTarg);
	m_strlstTargets.RemoveAt((POSITION)hTarg);

}

// Delete an existing target
BOOL CBldSysIFace::DeleteTarget
(
	HBLDTARGET		hTarg,		// target to delete
	HBUILDER		hBld		// builder that contains target? default='active builder'
)
{
	// get a builder for this target to be searched in

	ASSERT(NO_BUILDER!=hBld);
	HBUILDER hCmpBld = GetBuilder(hTarg);
	ASSERT(NO_BUILDER!=hCmpBld);
	ASSERT(hBld == hCmpBld);
	hBld = hCmpBld;
	ASSERT(hBld);

	CProject * pProject = CnvHBuilder(hBld);
	ASSERT(pProject);

	if( pProject == NULL )
		return FALSE;

	// Get the name of the target to delete
	CString strTarget;
	GetTargetName(hTarg, strTarget, hBld);

	LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
	BOOL bWorkspaceInitialised = (pProjSysIFace->IsWorkspaceInitialised() == S_OK);

	const CPtrArray* pConfigArray = pProject->GetConfigArray();
	int nSize = pConfigArray->GetSize();
	if (pProject->m_bProjectComplete)
	{
		// if we're destroying the project, make sure it is not active
		if ((nSize==1) && (pProject == g_pActiveProject))
			DeactivateBuilder(hBld);
	}

	// Delete the target
	BOOL bRetVal = pProject->DeleteTarget(strTarget);

	// Remove the target from our list of targets if we succeeded in deleting it
	if (bRetVal)
	{
		m_mapPrjTargets.RemoveKey(hTarg);
 		m_strlstTargets.RemoveAt((POSITION)hTarg);
	}

	pConfigArray = pProject->GetConfigArray();
	nSize = pConfigArray->GetSize();
	if (pProject->m_bProjectComplete)
	{
		// If the delete operation succeeded then send out a notification
		// to other packages to tell them that this target has been deleted
		if (bRetVal && bWorkspaceInitialised)
  	 		theApp.NotifyPackages(PN_DEL_TARGET, (void *) hTarg);

		ASSERT(bRetVal);
		if ((bRetVal !=0) && (nSize==0) && (!g_bInProjClose)) // avoid recursion
		{
			// are we deleting the entire project?
			IBSProject *pBSProj = pProject->GetInterface();
			COleRef<IPkgProject> pPkgProj;
			pBSProj->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
			//FindProjWksIFace()->SetActiveProject(pPkgProj, TRUE);
			pBSProj->Release();
			bRetVal = SUCCEEDED(g_pProjWksIFace->DeleteProject(pPkgProj, FALSE));
		}

	}

	// success?
	return bRetVal;
 }

// Add a target as a dependency of another target.
HPROJDEP CBldSysIFace::AddProjectDependency
(
	HFILESET		hFileSet,			// fileset in which to *place* dependency
	HFILESET		hDependantFileSet,	// fileset on which to place a dependency
	HBUILDER		hBld, 				// builder that contains hFileSet'
	HBUILDER		hDependantBld /* = NO_BUILDER */	// builder that contains hDependantFileSet (default is to use hBld)
)
{
	// make sure we have a builder for this target to be searched in
	if (hDependantBld == NO_BUILDER)
		hDependantBld = hBld;

	if (hBld == ACTIVE_BUILDER)
		hBld = GetBuilderFromFileSet(hFileSet); // don't trust default

	if (hDependantBld == ACTIVE_BUILDER)
		hDependantBld = GetBuilderFromFileSet(hDependantFileSet); // don't trust default

    // get the target item for the target we are adding to.
	CProject *pTopProject = CnvHBuilder(hBld);
	CProject *pSubProject = CnvHBuilder(hDependantBld);
    CTargetItem* pTarget = CnvHFileSet(hBld, hFileSet);
	CTargetItem* pDependantTarget = CnvHFileSet(hDependantBld, hDependantFileSet);

	if( pTopProject==NULL || pSubProject==NULL || pTarget==NULL || pDependantTarget==NULL ){
		// something is bogus. Bail now !
		return (HPROJDEP)NULL;
	}

    // Create the target dependency
    CProjectDependency* pProjectDep = new CProjectDependency();
    pProjectDep->SetProjectDep(pDependantTarget);

	CString strTop; pTopProject->GetName(strTop);
	CString strSub; pSubProject->GetName(strSub);

	::AddDep( strTop, strSub, pProjectDep );

	// Add the target dependency to the required target
	pTopProject->SetOkToDirtyProject(FALSE);
    pProjectDep->MoveInto(pTarget);
	pTopProject->SetOkToDirtyProject();

	// Return the Target dep as a file (allows doing things like checking
	// for dupes)
	return (HPROJDEP)pProjectDep;
}

BOOL CBldSysIFace::RemoveProjectDependency
(
	HPROJDEP		hProjDep,				// handle to the project dependency
	HFILESET		hFileSet,				// handle to the fileset
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	// Get the file item 
	CProjectDependency * pProjDep = CnvHProjDep(hFileSet, hProjDep);

	// Delete it
	pProjDep->MoveInto(NULL);

	return TRUE;	// ok
}

HFILESET CBldSysIFace::GetDependantProject
(
	HPROJDEP		hProjDep,				// handle to the project dependency
	HFILESET		hFileSet,				// handle to the fileset
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	CProjectDependency * pProjDep = CnvHProjDep(hFileSet, hProjDep);
	
	CTargetItem * pTarget = pProjDep->GetProjectDep();

	return (HFILESET)pTarget;
}

// FUTURE: target deletion API

// Delete an existing target
HFOLDER CBldSysIFace::AddFolder(HFILESET hFileSet, const TCHAR * pchFolder, HBUILDER hBld /* = ACTIVE_BUILDER */, HFOLDER hFolder /* = NO_FOLDER */, const TCHAR * pchFilter /* = NULL */)
{
	// get a builder for this target to be searched in
	CProjContainer * pContainer = (CProjContainer *)hFolder;
	if ((pContainer == NULL) || (!pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer))))
	{
		// get the target item 
		pContainer = (CProjContainer *)CnvHFileSet(hBld, hFileSet);
	}

	return (HFOLDER)(CProjContainer *)(pContainer->AddNewGroup(pchFolder, pchFilter));
}

extern BOOL g_bExcludedNoWarning; // defined in pfilereg.cpp

// Create a file and add it to a target, 'hTarg', with or without default settings, 'fSettings'.
// Function may fail (HBLDFILE == NO_FILE).
HBLDFILE CBldSysIFace::AddFile
(
	HFILESET		hFileSet,				// handle to the fileset
	const CPath *	ppathFile,				// file path
	int				fSettings,			// default settings for this fileitem
	HBUILDER		hBld,					// builder that contains target? default='active builder' 
	HFOLDER			hFolder					// default is NO_FOLDER
)
{
	ASSERT((fSettings & ~(ADB_EXCLUDE_FROM_BUILD | ADB_EXCLUDE_FROM_SCAN))==0);	// NYI

	// get a builder for this target to be added to
	if (hBld == ACTIVE_BUILDER)
		hBld = GetActiveBuilder();

	if( hBld == NO_BUILDER )
		return NO_FILE;

	CProject * pProject = CnvHBuilder(hBld);
	CProjTempProjectChange projChange(pProject);

	// get the target item 
	CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
	if (pTarget == NULL)
		return NO_FILE;

	// reject wildcards
	if (_tcspbrk(*ppathFile, _T("*?")))
	{
		return NO_FILE;
	}

	CDir dir;
	// make sure we're not trying to add a directory
	if (dir.CreateFromString((LPCTSTR)*ppathFile) && dir.ExistsOnDisk())
	{
		return NO_FILE;
	}
	// special logic to identify template files so that they go
	// in the right folder and so that ClassView never sees them
	BOOL bIsTemplate = ((fSettings & ADB_EXCLUDE_FROM_SCAN)!=0);
	if ((!bIsTemplate) && (dir.CreateFromPath(*ppathFile)))
	{
		CString strDir = dir;
		strDir.MakeLower();
		int nTemplate, nEnd;
		if ((nTemplate = strDir.Find("\\template")) != -1)
		{
			nEnd = nTemplate + strlen("\\template");
			if ((nEnd >= strDir.GetLength()) || (strDir[nEnd] == '\\'))
			{
				bIsTemplate = TRUE;
				fSettings |= (ADB_EXCLUDE_FROM_SCAN | ADB_EXCLUDE_FROM_BUILD);
			}
		}
	}
	CProjContainer * pContainer = (CProjContainer *)hFolder;  // use specified folder, if any
	if ((pContainer == NULL) || (!pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer))))
	{
		pContainer = pTarget;  // by default, just add to the target
		CProjItem * pItem;

		CString strFilter;
		CString strTemplateFilter;
		strTemplateFilter.LoadString(IDS_TEMPLATE_FILES_FILTER);
		CObList ol;
 		pTarget->FlattenSubtree(ol, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjDeps);
		POSITION pos = ol.GetHeadPosition();
		while (pos != NULL)
		{
			pItem = (CProjItem *)ol.GetNext(pos);
			ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProjItem)));
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
			{
				if ((pItem->GetStrProp(P_GroupDefaultFilter, strFilter)==valid) && (!strFilter.IsEmpty()))
				{
					if (strFilter == strTemplateFilter) // "<templates>"
					{
						if (bIsTemplate)
						{
							pContainer = (CProjContainer *)pItem;
							break;
						}
					}
					else if (FileNameMatchesExtension(ppathFile, strFilter))
					{
						// found appropriate group to add this too
						if (pContainer == pTarget) // make sure we're overriding the default
							pContainer = (CProjContainer *)pItem;
						if (!bIsTemplate)
							break;
					}
				}
			}
		}
	}
	
	// get the targets file registry
	CFileRegistry * pRegistry = pTarget->GetRegistry();
	ASSERT(pRegistry != NULL);

	// check to see if the file is in the target already
	FileRegHandle frh = pRegistry->LookupFile(ppathFile);
	if (frh != (FileRegHandle)NULL)
	{
		CObList * oblist = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
#ifdef REFCOUNT_WORK
		frh->ReleaseFRHRef();
#endif
		if (oblist != NULL)
		{
			// already there, can't do this!
			// ASSERT(FALSE);
			return FALSE;
		}
	}

	// create the file
	CFileItem * pFile;
	if ((pFile = new CFileItem) == (CFileItem *)NULL)
		return NO_FILE;

	// set the file path
	pFile->SetFile(ppathFile);

	// REVIEW: only do this for class-oriented files
	// see if we should exclude this from clsview, etc.
	// Note: must do this before the MoveInto...
	if ((fSettings & ADB_EXCLUDE_FROM_SCAN)!=0)
		pFile->SetIntProp(P_ItemExcludedFromScan, TRUE);

	// avoid gratuitous warning if we're about to exclude anyway
	if ((fSettings & ADB_EXCLUDE_FROM_BUILD)!=0)
		g_bExcludedNoWarning = TRUE;

	// move the file into the target
	pFile->MoveInto(pContainer);

	if ((fSettings & ADB_EXCLUDE_FROM_BUILD)!=0)
		g_bExcludedNoWarning = FALSE;

	// see if we should exclude this from the build
	if (((fSettings & ADB_EXCLUDE_FROM_BUILD)!=0)
//		|| (FileNameMatchesExtension(ppathFile, "rc2"))
		)
	{
		// REVIEW: only do this for class-oriented files
		pFile->SetIntProp(P_ItemExcludedFromScan, TRUE);

		int iSize = pTarget->GetPropBagCount();
		ASSERT(iSize);
		const CPtrArray * pArrayCfg = pTarget->GetConfigArray();
		for (int i = 0; i < iSize; i++)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)(*pArrayCfg)[i]; 
			if (pcr->IsValid())
			{
				CProjTempConfigChange projTempConfigChange(pProject);
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
				pFile->SetIntProp(P_ItemExcludedFromBuild, TRUE);
				int idOldBag = pFile->UsePropertyBag(BaseBag);
				pFile->SetIntProp(P_ItemExcludedFromBuild, TRUE);
				(void) pFile->UsePropertyBag(idOldBag);
			}
		}
	}

	// return the newly created file
	return (HBLDFILE)pFile;
}

void CBldSysIFace::AddMultiFiles
(
	HFILESET			hFileSet,		// handle to the fileset
	const CPtrList *	plstpathFiles,		// pointer list of file paths (const CPath *'s)
	CPtrList *			plstHBldFiles,		// returned list of HBLDFILEs
	int					fSettings,	// default settings for this fileitem
	HBUILDER			hBld,			// builder that contains target? default='active builder'
	HFOLDER				hFolder			// folder to insert files into; default is NO_FOLDER
)
{
    CProject * pProject = CnvHBuilder(hBld);

	if( pProject == NULL )
		return;	// failure

	CProjTempProjectChange projChange(pProject);

    pProject->BeginBatch();

	// inform the graphs that these targets are now being modified
	g_buildengine.SetGraphMode(Graph_Creating, CnvHBuilder(hBld));

	POSITION pos = plstpathFiles->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		HBLDFILE hFile = AddFile(hFileSet, (const CPath *)plstpathFiles->GetNext(pos), fSettings, hBld, hFolder);
		plstHBldFiles->AddTail((void *)hFile);
	}
	
	// inform the graphs that these targets are now stable
	g_buildengine.SetGraphMode(Graph_Stable, CnvHBuilder(hBld));

    pProject->EndBatch();
}

// Add a dependency file to a fileset, 'hFileSet'.
// ** Note, this doesn't actually add the file as such, it just informs
// other parties, say SCC, that we have a new file that is a 'part of' the fileset.
// Use ::AddFile if you want to *actually* be a part of the fileset.
// Function may fail (HBLDFILE == NO_FILE).
BOOL CBldSysIFace::AddDependencyFile
(
	HFILESET		hFileSet,	// handle to the fileset
	const CPath *	ppathFile,	// dependency file path
	HBUILDER		hBld,		// builder that contains target? default='active builder'
	HFOLDER			hFolder		// folder to insert dep into
)
{
	HBLDFILE hFile = AddFile(hFileSet, ppathFile, 0 /* ADB_EXCLUDE_FROM_BUILD */, hBld, hFolder);
	return (hFile != NO_FILE);// Function may fail (HBLDFILE == NO_FILE).
}

BOOL CBldSysIFace::CheckFile
(
	HFILESET		hFileSet,				// handle to the fileset
	CPath &			pathFile,				// file path
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	CObList lstFile;
	CTargetItem *pTarg =  CnvHFileSet(ACTIVE_BUILDER, hFileSet);
	if( pTarg == NULL )
		return FALSE;

	pTarg->FlattenSubtree(lstFile, CProjItem::flt_Normal | CProjItem::flt_ExcludeGroups);

	BOOL bFileFound, bRetVal = TRUE;
	POSITION pos;

	do
	{
		bFileFound = FALSE;
		
		// Check the files in the fileset
		pos = lstFile.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CFileItem * pItem = (CFileItem *)lstFile.GetNext(pos);
			if (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
				continue;

			// Does the file exist in the fileset, if so then
			// we flag the fact that we've found the file, and
			// "warp" the filename, so that the next time thru we
			// hopefully won't find the file.
			if (*(pItem->GetFilePath()) == pathFile)
			{
				bFileFound = TRUE;
				bRetVal = FALSE;
				pathFile.PostFixNumber();
				break;
			}
		}
	} while (bFileFound);

	// Did we need to change the filename
	return bRetVal;
}

// Delete a file 'hFile' from a fileset, 'hFileSet'
BOOL CBldSysIFace::DelFile
(
	HBLDFILE 		hFile,		// handle to file
	HFILESET		hFileSet,	// handle to the fileset
	HBUILDER		hBld		// builder that contains target? default='active builder'
)
{
	// Get the file item 
	CFileItem * pItem = CnvHBldFile(hFileSet, hFile);

	// Delete it
	pItem->MoveInto(NULL);

	return TRUE;	// ok
}

BOOL CBldSysIFace::GetFile
(
	const CPath * 	ppathFile, 	// file path
	HBLDFILE &		hFile,		// handle to the file
	HFILESET		hFileSet,	// handle to the fileset
	HBUILDER		hBld,		// builder that contains target? default='active builder'
	BOOL			bSimple	// if TRUE check includes deps and intermediate target files, default = FALSE,
)
{
	// Get the target item 
	CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
	if (pTarget == NULL)
		return FALSE;

	// Get the targets file registry
	CFileRegistry * pRegistry = pTarget->GetRegistry();
	ASSERT(pRegistry != NULL);

	// Check to see if the file is in the target
	FileRegHandle frh = pRegistry->LookupFile(ppathFile);
	if (frh == NULL)
		return FALSE;

	// Do we care about dependencies and intermediate target files?
	if (bSimple)
#ifndef REFCOUNT_WORK
		return TRUE;
#else
	{
		frh->ReleaseFRHRef();
		return TRUE;
	}
#endif

	// The file is there, so now get the associated list of
	// file items for this file reg entry, and if there is
	// no list then this item is not really part of the target
	// (i.e. it is a dependency, or an intermediate target)
	CObList * oblist = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
#ifdef REFCOUNT_WORK
	frh->ReleaseFRHRef();
#endif
	if (oblist == NULL)
		return FALSE;

	POSITION pos = oblist->GetHeadPosition();
	while (pos != NULL)
	{
		// Get the file item and its parent
		CFileItem * pFile = (CFileItem *)oblist->GetNext(pos);
		CTargetItem * pContainer = pFile->GetTarget();

		// Is this file item in our target, if so we've found the file
		if (pContainer == pTarget)
		{
			hFile = (HBLDFILE)pFile;
			return TRUE;
 		}
	}

    // We found an entry in the registry but there is no associated projitem
    // that is contained in the target, so we haven't really found the file
	return FALSE;
}

// Add/subtract tool settings, pchSettings, to a target, 'hTarg'.
// Must specify the 'executable' name of the tool'.
BOOL CBldSysIFace::SetToolSettings
(
	HBLDTARGET		hTarg,					// handle to the target
	const TCHAR * 	pchSettings,			// tool settings
	const TCHAR *	pchTool, 				// executable of the tool that 'owns' these settings
	BOOL			fAdd,					// add or subtact? default=add
	BOOL			fClear,					// clear settings before add or subtract?
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	return SetToolSettingsI(hTarg, CnvHBuilder(hBld), pchSettings, pchTool, fAdd, fClear);
}

// Add/subtract tool settings, pchSettings, to a file, 'hFile'.
// Optional to specify the 'executable' name of the tool'.
BOOL CBldSysIFace::SetToolSettings
(
	HBLDTARGET		hTarg,					// handle to the target that contains the file
	HBLDFILE		hFile,					// handle to the file
	const TCHAR * 	pchSettings,			// tool settings
	const TCHAR *	pchTool, 				// executable of the tool that 'owns' these settings
	BOOL			fAdd,					// add or subtact? default=add
	BOOL			fClear					// clear settings before add or subtract?
)
{
	HFILESET hFileSet = GetFileSet(ACTIVE_BUILDER, hTarg);
	if( hFileSet == NO_FILESET )
		return FALSE;

	return SetToolSettingsI(hTarg, CnvHBldFile(hFileSet, hFile),
							pchSettings, pchTool, fAdd, fClear);
}

void CBldSysIFace::MakeTargPropsDefault
(
	HBLDTARGET		hTarg,					// handle to the target
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	// get this target's config record
	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProject * pItem = CnvHBuilder(hBld);
	if( pItem == NULL )
		return; 	// failure

	// force this item into our config., make default current, then reset config.
	pItem->ForceConfigActive(pcr);	
	pItem->SetCurrentConfigAsBase();
	pItem->ForceConfigActive();
}

// Get a string property for this target
BOOL CBldSysIFace::GetTargetProp
(
	HBLDTARGET		hTarg,					// handle to the target
	UINT			idProp,					// identifier of the property
	CString &		str,						// property value
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	BOOL bRetVal = FALSE;
	CPath Path;

    // Handle default builder
    if (hBld == ACTIVE_BUILDER)
        hBld = GetActiveBuilder();

    // We should have a target
    ASSERT(hTarg != NO_TARGET);

	// Get the project item
	CProject * pProject = CnvHBuilder(hBld);

	if( pProject == NULL )
		return FALSE;
		

	// Get the internal prop number if there is one
	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	if (idPropI == 0)
	{
		// Faked properties
		switch (idProp)
		{
			case Prop_TargetDirectory:
 				str = pProject->GetProjDir();
				bRetVal = TRUE;
				break;

			default:
 				// Unknown faked property, so fail the operation
				bRetVal = FALSE;
				break;
		}
	}
	else
	{
		// Real internal property

		// get this target's config record
		ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

		// force this item into our config and get the property value
		pProject->ForceConfigActive(pcr);	
  		bRetVal = (pProject->GetStrProp(idPropI, str) == valid);
  		pProject->ForceConfigActive();
 	}

	return bRetVal;
}

// Get an integer property for this target
BOOL CBldSysIFace::GetTargetProp
(
	HBLDTARGET		hTarg,					// handle to the target
	UINT			idProp,					// identifier of the property
	int &			i,						// property value
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	BOOL bRetVal = FALSE;
	CPath Path;

    // Handle default builder
    if (hBld == ACTIVE_BUILDER)
        hBld = GetActiveBuilder();

    // We should have a target
    ASSERT(hTarg != NO_TARGET);

	// Get the project item
	CProject * pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;

	// Get the internal prop number if there is one
	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	if (idPropI == 0)
	{
		// Faked properties
 	}
	else
	{
		// Real internal property

		// get this target's config record
		ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

		// force this item into our config and get the property value
		pProject->ForceConfigActive(pcr);	
  		bRetVal = pProject->GetIntProp(idPropI, i);
  		pProject->ForceConfigActive();
 	}

	return bRetVal;
}

// Set an integer or string property for this target
BOOL CBldSysIFace::SetTargetProp
(
	HBLDTARGET		hTarg,					// handle to the target
	UINT			idProp,					// identifier of the property
	int				i,						// property value
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	BOOL fResetAllDefault = FALSE;

	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	// get this target's config record
	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProject * pItem = CnvHBuilder(hBld);
	if( pItem == NULL || pcr == NULL )
		return FALSE;

	CProjTempProjectChange projChange(pItem);

	// pretend that we're complete so that we don't ignore these prop. sets
	// kinda hacky, but appwiz will set these and we will ignore
	// them in CProjItem::InformDependants if we think we're creating a project
	BOOL bOldProjectComplete = pItem->m_bProjectComplete;
	if (idPropI == P_OutDirs_Target || idPropI == P_OutDirs_Intermediate)
		pItem->m_bProjectComplete = TRUE;

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

	// set integer property
	BOOL fRet = pItem->SetIntProp(idPropI, i);
	if (fRet)
		pcr->BagCopy(CurrBag, BaseBag, idPropI, idPropI);

	pItem->m_bProjectComplete = bOldProjectComplete;

	// have the target wizards ensure this is fine..
	CProjType * pprojtype = pItem->GetProjType();

	if (pprojtype != (CProjType *)NULL)
	{
		// Microsoft Foundation Classes Wizard?
		if (idProp == Prop_UseOfMFC)
		{
			pprojtype->PerformSettingsWizard(pItem, i);
			fResetAllDefault = TRUE;
		}
	}

	// reset this item's config.
	projTempConfigChange.Release();

	// make sure we still have all current as defaults?
	if (fResetAllDefault)
		MakeTargPropsDefault(hTarg, hBld != ACTIVE_BUILDER ? hBld : GetActiveBuilder());

	return fRet;	// ok?
}

BOOL CBldSysIFace::SetTargetProp
(
	HBLDTARGET		hTarg,					// handle to the target
	UINT			idProp,					// identifier of the property
	CString &		str,					// property value
	HBUILDER		hBld					// builder that contains target? default='active builder'
)
{
	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	// get this target's config record
	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProject * pItem = CnvHBuilder(hBld);

	if( pItem == NULL || pcr == NULL )
		return FALSE;

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

	// set string property
	BOOL fRet = pItem->SetStrProp(idPropI, str);
	if (fRet)
		pcr->BagCopy(CurrBag, BaseBag, idPropI, idPropI);
  	

	return fRet;	// ok?
}

// Returns the state of the target.
// Any files that are considered 'final' products,
// eg. an .exe or .dll, are returned in the 
// path list 'lstPath'. Use FileState() to determine
// the state of these.
UINT CBldSysIFace::TargetState
(
	CObList *	plstPath /* = NULL */,		// paths that are not current (== (CObList *)NULL if not req'd)	
	const TCHAR * pchTarget /* = NULL */,	// default is the primary target (usually .exe)
	HBLDTARGET	hTarg /* = NO_TARGET */,	// handle to the target 
	HBUILDER	hBld /* = ACTIVE_BUILDER */	// handle to the builder that contains this
)
{
	if (!theApp.m_bInvokedCommandLine)
	{
		// checks if there are some 'dirty' project files in the IDE
		// (ie: not saved yet)
		if (!g_VPROJIdeInterface.Initialize())
			return TRG_STAT_Unknown;
		
		if (g_VPROJIdeInterface.GetEditDebugStatus()->ProjectFilesModified() == S_OK)
			return TRG_STAT_Out_Of_Date;
	}

	// do we have an active builder?
    if (hBld == ACTIVE_BUILDER)
	    hBld = GetActiveBuilder();

	if (hTarg == NO_TARGET)
        hTarg = GetActiveTarget(hBld);

	CProject * pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return TRG_STAT_Unknown; // there is no active project

	// not a valid call for EXE-only builders
  	ASSERT(!pProject->m_bProjIsExe);

	// get the target item 
 	CTargetItem * pTarget = CnvHTarget(hBld, hTarg);

	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	// get our project type
	CProjType * pProjType;

	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig(pcr);
	pProjType = pTarget->GetProjType();
	projTempConfigChange.Reset();

	if (pProjType == (CProjType *)NULL)
		return TRG_STAT_Unknown;

	// if the current target is an external target then 
	// assume that we're current
	if (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
		return TRG_STAT_Current;

	// file registry handle to the target
	FileRegHandle frhTarget = NULL;

	// need to find the primary target?
	if (pchTarget == (const TCHAR *)NULL)
	{
#if 0
		CFileRegSet * psetTarg = (CFileRegSet *)pcr->GetTargetFiles();
		
		// return a (const CPath *)NULL if there are no primary targets
		if (psetTarg == (const CFileRegSet *)NULL)
			return TRG_STAT_Unknown;
		
#ifndef REFCOUNT_WORK
		frhTarget = (FileRegHandle)psetTarg->GetContent()->GetHead(); 
#else
		frhTarget = psetTarg->GetFirstFrh(); 
#endif

		delete psetTarg;
#endif
	}
	else
	{
		// lookup this target
		CFileRegistry * pregistry = g_buildengine.GetRegistry(pcr);
		ASSERT(pregistry != (CFileRegistry *)NULL);

		if ((frhTarget = pregistry->LookupFile(pchTarget)) == (FileRegHandle)NULL)
			return TRG_STAT_Unknown;
	}

	CPtrList lstprojdeprefs;

	projTempConfigChange.ChangeConfig(pcr);

	// munge dep graph to take subprojects into account
	HFILESET hFileSet = GetFileSet(hBld, hTarg);
	POSITION posDep;
	CObList  lstDep;
	InitProjectDepEnum( hFileSet, hBld, lstDep, posDep );

	HPROJDEP hProjDep;
	while ((hProjDep = GetNextProjectDep( hFileSet, hBld, lstDep, posDep )) != NO_PROJDEP)
	{
 		CProjectDependency * pProjDep = CnvHProjDep(hFileSet, hProjDep);
		ConfigurationRecord * pcrProjDep = pProjDep->GetTargetConfig();

		if (pcrProjDep != NULL)
		{
            PROJDEPREFINFO * pProjDepRefInfo = new PROJDEPREFINFO;
            pProjDepRefInfo->pProjDep = pProjDep;
            pProjDepRefInfo->pcr = pcr;

            lstprojdeprefs.AddTail(pProjDepRefInfo);

            CActionSlob::AddRefFileItem(pProjDep);
		}
	}

	projTempConfigChange.Reset();

	UINT nRetVal = TRG_STAT_Current;

	// are we up to date?
	CPtrList lstFrh;
	if (g_buildengine.HasBuildState(pcr, lstFrh, DS_OutOfDate, frhTarget))
	{
		// place out pointer to paths in the list?
		if (plstPath != (CObList *)NULL)
		{
			POSITION pos = lstFrh.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				FileRegHandle frh = (FileRegHandle)lstFrh.GetNext(pos);
				plstPath->AddTail((CObject *)g_FileRegistry.GetRegEntry(frh)->GetFilePath());
			}
		}

		nRetVal = TRG_STAT_Out_Of_Date;
		goto ExitTargetState;
	}

	// don't check our target dependencies for a specific target
	if (pchTarget == (const TCHAR *)NULL)
	{
		// initial the target dep. enum
		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig(pcr);

		HFILESET hFileSet = GetFileSet(hBld, hTarg);
		InitProjectDepEnum(hFileSet, hBld, lstDep, posDep);

		HPROJDEP hProjDep;
		HBLDTARGET hTargDep;
		while ((hProjDep = GetNextProjectDep(hFileSet, hBld, lstDep, posDep)) != NO_PROJDEP)
		{
			HFILESET hDepFileSet = GetDependantProject(hProjDep, hFileSet, hBld);
			if(hDepFileSet == NULL ) continue;

			HBUILDER hDepBld = GetBuilderFromFileSet(hDepFileSet);
			if (GetTargetFromFileSet(hDepFileSet, hTargDep, hBld, TRUE))
			{
				UINT state = TargetState(plstPath, (const TCHAR *)NULL, hTargDep, hDepBld);
				if (state != TRG_STAT_Current){
					nRetVal = state;
				    goto ExitTargetState;
				}
			}
		}
		
	}

ExitTargetState:

	projTempConfigChange.ChangeConfig(pcr);

	while (!lstprojdeprefs.IsEmpty())
	{
		PROJDEPREFINFO * pProjDepRefInfo = (PROJDEPREFINFO *)lstprojdeprefs.RemoveHead();
		CActionSlob::ReleaseRefFileItem(pProjDepRefInfo->pProjDep);
 	}

	projTempConfigChange.Release();

#ifdef REFCOUNT_WORK
	if (NULL!=frhTarget)
		frhTarget->ReleaseFRHRef();
#endif

	return nRetVal;	// we're current!
}

UINT CBldSysIFace::FileState
(
	const CPath * pathFile				// path of the file to get state for
)
{
	ASSERT(FALSE);
	return TRG_STAT_Unknown;	// unknown state
}

// Given a path to a source file, 'pathSrc', and a list of include directives, 'strlstIncs',
// this function will return a list of paths, 'lstpath', that represent the 'resolved' (or
// absolute) location of the file represented by each include directive.
// Any standard includes, eg. #include <stdio.h>, will be ignored if 'fIgnStdIncs' is TRUE.
// If per-file include directives, eg. compiler /I, exist for the 'pathSrc' then these will be used.
//
// Note: It is up to the caller of this function to deallocate the CPath *'s in 'lstPath'.
//
// Returns FALSE if the operation cannot be performed.
BOOL CBldSysIFace::ResolveIncludeDirectives
(
	const CPath & pathSrc,
	const CStringList & strlstIncs,
	CStringList & lstPath,
	BOOL fIgnStdIncs,
	const CString & strPlat
)
{
	CString strIncDirs;	// our include directories
	static CPath pathSrcLast;
	static fSetLastPath = FALSE;
	
	// remeber last C style file we scan, assuming the parser will call us per CFile order
	// such as C file, then all the includes belong to this C file.
	// The reason we need to do this, is because include file are not in our file set, we can't get per file
	// settings for them, another way is that parser to pass us the source .cpp/c name too...
	if (_tcsicmp(pathSrc.GetExtension(),_TEXT(".cpp"))==0 || _tcsicmp(pathSrc.GetExtension(),_TEXT(".c")) == 0)
	{
		pathSrcLast = pathSrc;
		fSetLastPath = TRUE;
		if (!GetIncludePathI(strIncDirs, strPlat, &pathSrc))
			return FALSE;
	}
	else if (fSetLastPath && (_tcsicmp(pathSrcLast.GetExtension(),_TEXT(".cpp"))==0 || _tcsicmp(pathSrcLast.GetExtension(),_TEXT(".c")) == 0))
	{
		// non C file, h file and last C style file set
		if (!GetIncludePathI(strIncDirs, strPlat, &pathSrcLast))
			return FALSE;	// failed to get include directories
	}
	else
	{
		if (!GetIncludePathI(strIncDirs, strPlat, &pathSrc))
			return FALSE;
	}
		
	// our base directory
	CDir dirBase;
	if (!dirBase.CreateFromPath(pathSrc))
		return FALSE;	// failed to get the base directory for the source

	return ResolveIncludeDirectivesI(strIncDirs, (const CDir &)dirBase, strlstIncs, lstPath, fIgnStdIncs, strPlat, &pathSrc);
	/*
	ResolveIncludeDirectivesI(lstIncDirs, (const CDir &)dirBase, strlstIncs, lstPath, fIgnStdIncs, strPlat, &pathSrc);

	CStringList *pstrlstIncs;

	pstrlstIncs = new CStringList;
	POSITION pos = lstPath.GetHeadPosition();		
	while (pos != (POSITION)NULL)
	{
		CString str;
		CPath * pPath = (CPath *)lstPath.GetNext(pos);
		if (pPath != (CPath *)NULL)
		{
			str = pPath->GetFullPath();
			pstrlstIncs->AddTail(str);
		}

	}

	UpdateDependencyList(pathSrc, (CStringList &)*pstrlstIncs, GetActiveTarget(), GetActiveBuilder());

	return TRUE;
	*/
}

// As above, but given a directory to initially search, 'dir'.
BOOL CBldSysIFace::ResolveIncludeDirectives
(
	const CDir & dirBase,
	const CStringList & strlstIncs,
	CStringList & lstPath,
	BOOL fIgnStdIncs,
	const CString & strPlat
)
{
	CString strIncDirs;	// our include directories
	if (!GetIncludePathI(strIncDirs, strPlat))
		return FALSE;	// failed to get include directories

	return ResolveIncludeDirectivesI(strIncDirs, (const CDir &)dirBase, strlstIncs, lstPath, fIgnStdIncs, strPlat, (const CPath *)NULL);
}

// Given a list path to a source file, 'pathSrc', and a list of include directives, 'strlstIncs',
// this function will return a list of paths, 'lstpath', that represent the 'resolved' (or
// absolute) location of the file represented by each include directive.
// Any standard includes, eg. #include <stdio.h>, will be ignored if 'fIgnStdIncs' is TRUE.
// If per-file include directives, eg. compiler /I, exist for the 'pathSrc' then these will be used.
//
// Note: It is up to the caller of this function to deallocate the CPath *'s in 'lstPath'.
//
// Returns FALSE if the operation cannot be performed.
BOOL CBldSysIFace::ResolveIncludeDirectives
(
	const CObList & lstpathSrc,
	const CStringList & strlstIncs,
	CStringList & lstPath,
	HBLDTARGET hTarget
	)
{
	if (NULL==g_pActiveProject)
		return FALSE;

	POSITION posPath = lstpathSrc.GetHeadPosition();		
	ASSERT (posPath != (POSITION)NULL);
	CPath * pathSrc = (CPath *)lstpathSrc.GetNext(posPath);

	CString strlstIncDirs;	// our include directories
	CDirMgr * pDirMgr = GetDirMgr();
	ASSERT (pDirMgr != (CDirMgr *)NULL);
	pDirMgr->GetDirListString (strlstIncDirs, DIRLIST_INC, -1);

	CProject * pProject = g_pActiveProject;

	ASSERT (pProject);
	CString strIncls;
	pProject->m_listTargIncl.Lookup(hTarget, strIncls);
	strlstIncDirs = strIncls + _T(';') + strlstIncDirs;

	// our base directory
	CDir dirBase;
	if (!dirBase.CreateFromPath(*pathSrc))
		return FALSE;	// failed to get the base directory for the source

	// get the current project
	HBUILDER hBld = GetActiveBuilder();
	CProject * pBuilder = hBld != NO_BUILDER ? CnvHBuilder(hBld) : (CProject *)NULL;

	// include directive information
	CIncludeEntry entry;
	entry.m_OriginalDir = dirBase;
	entry.m_nLineNumber = 0;			// N/A 
	entry.m_bShouldBeScanned = FALSE;	// N/A (not to be scanned)

	CString strInclude, strFile;

	POSITION posInc = strlstIncs.GetHeadPosition();
	while (posInc != (POSITION)NULL)
	{
		// get the include directive,
		// this is of the forms "file" or <file>
		strInclude = strlstIncs.GetNext(posInc);

		int cchInclude = strInclude.GetLength();
		TCHAR * pchInclude = strInclude.GetBuffer(cchInclude + 1);

		if (*pchInclude != _T('<') && *pchInclude != _T('\"'))
		{
			ASSERT(FALSE);
			return FALSE;
		}

		// standard include?
		entry.m_EntryType = (*pchInclude == _T('<')) ?
							IncTypeCheckIncludePath : 
							IncTypeCheckIncludePath | IncTypeCheckOriginalDir | IncTypeCheckParentDir;

		// strip the leading and trailing characters from 'strInclude'
		TCHAR * pchFile = strFile.GetBuffer(cchInclude - 1);
		strncpy(pchFile, pchInclude + 1, cchInclude - 2);
		pchFile[cchInclude - 2] = _T('\0');
		strFile.ReleaseBuffer();

		BOOL fIgnore = TRUE;	// by default ignore

		// is this a system include? ignore?
		if (!g_SysInclReg.IsSysInclude(strFile))
		{
			entry.m_FileReference = strFile;	// the file
			entry.CheckAbsolute();				// check the absoluteness of scanned dep.

			FileRegHandle frhFile;	// the 'resolved' file

			// build directory to make relative to?
			const TCHAR * pchBldDir = pBuilder != (CProject *)NULL ?
									  (const TCHAR *)pBuilder->GetWorkspaceDir() : _TEXT("");

			posPath = lstpathSrc.GetHeadPosition();
			while (posPath != (POSITION)NULL)
			{
				CPath * pPath = (CPath *)lstpathSrc.GetNext(posPath);

				// our base directory
				CDir dirParent;
				if (!dirParent.CreateFromPath(*pPath))
					return FALSE;
				if (entry.FindFile((const TCHAR *)strlstIncDirs, dirParent, pchBldDir, frhFile))
				{	
					CFileRegEntry * pfilereg = g_FileRegistry.GetRegEntry(frhFile);
					ASSERT(pfilereg != (CFileRegEntry *)NULL);

					// add path to our list
					lstPath.AddTail((CString)*pfilereg->GetFilePath());
#ifdef REFCOUNT_WORK
					frhFile->ReleaseFRHRef();
#endif
				  
			 		fIgnore = FALSE;	// don't ignore 
					break;
				}
			}

			// file not found
			if (fIgnore)
			{
				if (frhFile != (FileRegHandle)NULL)
				{
					CFileRegEntry * pfilereg = g_FileRegistry.GetRegEntry(frhFile);
					ASSERT(pfilereg != (CFileRegEntry *)NULL);

					// add path to our list
					lstPath.AddTail((CString)*pfilereg->GetFilePath());
#ifdef REFCOUNT_WORK
					frhFile->ReleaseFRHRef();
#endif
				}
			}
		}
 	}

	return TRUE;	// success
}


// Internal core for CBldSysIFace::ResolveIncludeDirectives() methods.
BOOL CBldSysIFace::ResolveIncludeDirectivesI
(
	CString & strlstIncDirs,
	const CDir & dirBase,
	const CStringList & strlstIncs,
	CStringList & lstPath,
	BOOL fIgnStdIncs,
	const CString & strPlat,
	const CPath *pathSrc
)
{
	HBUILDER hBld = GetActiveBuilder();
	CProject * pBuilder = hBld != NO_BUILDER ? CnvHBuilder(hBld) : (CProject *)NULL;

	// FUTURE: use this information to update our own cache

	// include directive information
	CIncludeEntry entry;
	entry.m_OriginalDir = dirBase;
	entry.m_nLineNumber = 0;			// N/A 
	entry.m_bShouldBeScanned = FALSE;	// N/A (not to be scanned)

	CString strInclude, strFile;

	POSITION posInc = strlstIncs.GetHeadPosition();
	while (posInc != (POSITION)NULL)
	{
		// get the include directive,
		// this is of the forms "file" or <file>
		strInclude = strlstIncs.GetNext(posInc);

		int cchInclude = strInclude.GetLength();
		TCHAR * pchInclude = strInclude.GetBuffer(cchInclude + 1);

		if (*pchInclude != _T('<') && *pchInclude != _T('\"') && *pchInclude != _T('\''))
		{
            // [paulde] change from ASSERT to TRACE because some callers have a 
            // legitimate need to pass names that don't begin with these chars,
            // and for those that care, you at least get a trace message.
			TRACE("CBldSysIFace::ResolveIncludeDirectivesI: file does not begin with [<\"']\n");
			return FALSE;
		}

		// standard include?
		entry.m_EntryType = (*pchInclude == _T('<')) ?
							IncTypeCheckIncludePath : 
							IncTypeCheckIncludePath | IncTypeCheckOriginalDir;

		// strip the leading and trailing characters from 'strInclude'
		TCHAR * pchFile = strFile.GetBuffer(cchInclude - 1);
		strncpy(pchFile, pchInclude + 1, cchInclude - 2);
		pchFile[cchInclude - 2] = _T('\0');
		strFile.ReleaseBuffer();

		BOOL fIgnore = TRUE;	// by default ignore

		// is this a system include? ignore?
		if (!(fIgnStdIncs && g_SysInclReg.IsSysInclude(strFile)))
		{
			entry.m_FileReference = strFile;	// the file
			entry.CheckAbsolute();				// check the absoluteness of scanned dep.

			FileRegHandle frhFile = NULL;	// the 'resolved' file

			// build directory to make relative to?
			const TCHAR * pchBldDir = pBuilder != (CProject *)NULL ?
									  (const TCHAR *)pBuilder->GetWorkspaceDir() : _TEXT("");

			if (entry.FindFile((const TCHAR *)strlstIncDirs, dirBase, pchBldDir, frhFile))
			{	
				CFileRegEntry * pfilereg = g_FileRegistry.GetRegEntry(frhFile);
				ASSERT(pfilereg != (CFileRegEntry *)NULL);

				// add path to our list
				lstPath.AddTail((CString)*pfilereg->GetFilePath());
#ifdef REFCOUNT_WORK
					frhFile->ReleaseFRHRef();
#endif
				  
			 	fIgnore = FALSE;	// don't ignore 
			}
			else
			{
				// otherwise, remember the headers we didn't find, so they can still be on the dep list
				if (pathSrc != (CPath *)NULL)
				{
					CPtrList *pPtrList;

					// get extension, we only record done the missing headers for C files
					// this is kind of incomplete, but it should cover the most common cases and
					// don't think the complete check will worth the work
					TCHAR * pch = _tcschr((TCHAR *)pathSrc->GetFullPath(), '.');
					if ((frhFile != (FileRegHandle)NULL) && pch && (_tcsicmp(pch, ".cpp")==0 || _tcsicmp(pch, ".cxx")==0 || _tcsicmp(pch, ".c")==0 ))					
					{
						if (pUnknownDepMap == NULL)
						{
							// allocate the default map
							pUnknownDepMap = new CMapStringToOb;
						}
						// add/create the mapped list of unknown deps
						if (pUnknownDepMap->Lookup((LPCTSTR)pathSrc->GetFullPath(), (CObject *&)pPtrList))
						{
							pPtrList->AddTail((void *)frhFile);
						}
						else
						{
							pPtrList = new CPtrList;
							pUnknownDepMap->SetAt((LPCTSTR)pathSrc->GetFullPath(), (CObject *)pPtrList);
							pPtrList->AddTail((void *)frhFile);
						}
					}
				}
#ifdef REFCOUNT_WORK
				if (NULL!=frhFile)
					frhFile->ReleaseFRHRef();
#endif
			}
			// release this ref. to the file reg-handle?
			// don't do this currently while somebody needs the *pPath ptrs!
			// could go back to new'ing a copy ourselves ....
			// g_FileRegistry.ReleaseRef(frhFile);
  		}
		
		// tag as ignored?
//		if (fIgnore)
			// ignore this one
//			lstPath.AddTail((CPath *)NULL);
 	}

	return TRUE;	// success
}



// Return the full search path for includes for a file.
// FUTURE: Use per-file include paths, eg. as specified by /i for the linker
BOOL CBldSysIFace::GetIncludePath
(
	CObList & lstIncDirs,
	const CString & strPlat,
	const CPath * ppathSrc,
	const CString & strTool,
	HBUILDER hBld
)
{
	BOOL fGotPerFile = FALSE;

	// make all of these relative to the builder directory
	CProject * pBuilder = CnvHBuilder(hBld);
				
	if (ppathSrc != (const CPath *)NULL && pBuilder != (CProject *)NULL)
	{
		// active fileset?
		HFILESET hFileSet;
		CBuildTool * pBuildTool = NULL;
		if (!strPlat.IsEmpty())
		{
			HBLDTARGET hTarget = GetTarget(strPlat, hBld);
			hFileSet = GetFileSet(hBld, hTarget);

		}
		else
		{
			hFileSet = (HFILESET)pBuilder->GetActiveTarget();
		}

		HBLDFILE hFile;
		CProjItem * pItem = NULL;

		if (hFileSet && GetFile(ppathSrc, hFile, hFileSet, hBld))
		{
			// get the target file CProjItem
			pItem = CnvHBldFile(hFileSet, hFile);
			ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
			
			CProjTempConfigChange projTempConfigChange(pItem->GetProject());

			ConfigurationRecord * pcr;
			if (!strPlat.IsEmpty())
			{
				// get this target config record
				pcr = pItem->ConfigRecordFromConfigName((const TCHAR *)strPlat, TRUE);
				ASSERT(pcr != (ConfigurationRecord *)NULL);

				// force this item into our config.
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	
			}
			pBuildTool = pItem->GetSourceTool();
		}
		else if ( !strTool.IsEmpty() ) {
			// get the include directories for this tool
			CProjType *pProjType = pBuilder->GetProjType();
			CPtrList * pTools = pProjType->GetToolsList();
			POSITION pos = pTools->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CBuildTool * pTool = (CBuildTool *)pTools->GetNext(pos);
				CString strTargTool;
	
				if (pTool->GetStrProp(P_ToolExeName, strTargTool) == valid &&
					_tcsicmp((const TCHAR *)strTargTool, (const TCHAR *)strTool) == 0
				   )
				{
					pBuildTool = pTool;
					pItem = pBuilder;
					break;
				}
			}
		}

		// get the include directories for this tool
		if (pBuildTool != (CBuildTool *)NULL)
		{
			CString strIncDirs;
			pBuildTool->GetIncludePaths(pItem, strIncDirs);

			// allow ',;' as join chars.
			COptionList strlstIncDirs(_T(';'), TRUE);
			strlstIncDirs.SetString(strIncDirs);

			// change to the builder directory
			CCurDir curDir(pBuilder->GetWorkspaceDir());

			POSITION pos = strlstIncDirs.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CDir * pDir = new CDir;
				if (pDir->CreateFromString(strlstIncDirs.GetNext(pos)))
					// caller must de-allocate these
					lstIncDirs.AddTail(pDir);
			}
			 
			fGotPerFile = TRUE;
		}
	}

	// got per-file includes?
	if (!fGotPerFile)
	{
		CDirMgr * pDirMgr = GetDirMgr();
		ASSERT(pDirMgr != (CDirMgr *)NULL);

		// get the index of the toolset
		int nToolSet = strPlat.IsEmpty() ? (int)-1 : pDirMgr->GetPlatformToolset(strPlat);

		// get the directory list
		const CObList * plstIncDirs = pDirMgr->GetDirList(DIRLIST_INC, nToolSet);
		
		// construct our list (copy this directory manager one into ours)
		POSITION pos = plstIncDirs->GetHeadPosition();
		while (pos != (POSITION)NULL)
			// caller must de-allocate these
			lstIncDirs.AddTail(new CDir((const CDir &)*plstIncDirs->GetNext(pos)));
	}

	return TRUE;	// success 
}

// Parser will call this function. We need to update the dep list for this file if the dep list
// changed. 
void CBldSysIFace::UpdateDependencyList
(
	const CPath & pathSrc,   // source file
	const CStringList & strlstIncs, //list of includes for this file
	HBLDTARGET		hTarg,	// handle to the target
	HBUILDER		hBld	// builder that contains target? default=('current'==ACTIVE_BUILDER) 
)
{
	//
	// Current not using dependency information from NCB.
	//
#if 0

	CPtrList *pdepList;

	CProject * pBuilder = CnvHBuilder(hBld);

	if (pathSrc != NULL && pBuilder != (CProject *)NULL)
	{
		// active fileset?
		HFILESET hFileSet = GetFileSet(hBld, hTarg);
		HBLDFILE hFile;

		if (hFileSet && GetFile(&pathSrc, hFile, hFileSet, hBld))
		{
			// get the target file CFileItem
			CFileItem * pItem = CnvHBldFile(hFileSet, hFile);	

			// loop through the include list, create a list by file handle, so we don't need to have
			// the list being passed in around anymore
			CString strInclude;
			
			pdepList = new CPtrList;
			POSITION posInc = strlstIncs.GetHeadPosition();
			while (posInc != (POSITION)NULL)
			{
				// This should be the full path
				strInclude = strlstIncs.GetNext(posInc);
				// Get the file reg handle for the file, we should have registed this file before we get here
				FileRegHandle frh = CFileRegFile::LookupFileHandleByName(strInclude);
				ASSERT(frh);

				// Add it to out depList
				pdepList->AddTail((void *)frh);
			}
			// add any unknown dep list
			CPtrList *pUnknownDepList;

			if (pUnknownDepMap && pUnknownDepMap->Lookup((LPCTSTR)pathSrc.GetFullPath(), (CObject *&)pUnknownDepList))
			{
				POSITION posInc = pUnknownDepList->GetHeadPosition();
				while (posInc != (POSITION)NULL)
				{
					FileRegHandle frh = (FileRegHandle) pUnknownDepList->GetNext(posInc);
					ASSERT(frh);

					// Add reference frh copied from pUnknownDepList.
					frh->AddFRHRef();
					// Add it to out depList
					pdepList->AddTail((void *)frh);
				}
				pUnknownDepList->RemoveAll();
				delete pUnknownDepList;
				pUnknownDepMap->RemoveKey((LPCTSTR)pathSrc.GetFullPath());
				if (pUnknownDepMap->IsEmpty())
				{
					delete pUnknownDepMap;
					pUnknownDepMap = NULL;
				}
			}

			// queue it up for update dep later
			FileItemDepUpdateQ(pItem, pdepList, NULL, g_FileDepUpdateListQ, FALSE, hTarg);					
			POSITION posFrh = pdepList->GetHeadPosition();
			while (posFrh!=NULL)
			{
				FileRegHandle frh = (FileRegHandle)pdepList->GetNext(posFrh);
				frh->ReleaseFRHRef();
			}
		}
	}
#endif	// #if 0
}

// Internal helper for CBldSysIFace::AddToolSettings() etc.
BOOL CBldSysIFace::SetToolSettingsI
(
	HBLDTARGET		hTarg,					// handle to the target that contains the file
	CProjItem *		pItem,					// pointer to the builder item
	const TCHAR * 	pchSettings,			// tool settings
	const TCHAR *	pchTool,				// executable of the tool that 'owns' these settings
	BOOL			fAdd,					// add or subtact? default=add
	BOOL			fClear					// clear settings before add or subtract?
)
{
	// get our target name
	CString strTarg = m_strlstTargets.GetAt((POSITION)hTarg);

	// get this target config record
	ConfigurationRecord * pcr = pItem->ConfigRecordFromConfigName((const TCHAR *)strTarg);
	CProjTempProjectChange projChange(pItem->GetProject());

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	
	
	// get this item's target type for the config.
	CProjType * pProjType = pItem->GetProjType();
	ASSERT(pProjType != (CProjType *)NULL);

	projTempConfigChange.Reset();

	// get the tool we want
	CBuildTool * pBuildTool = NULL;

	if (pchTool == (const TCHAR *)NULL)
	{
		// we can look for the tool for this source
		if (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
			return FALSE;	// can't do unnamed tools for non-source

		pBuildTool = pProjType->PickTool(pItem->GetFileRegHandle());
	}
	else
	{
		// if no .exe then add it (simple canonicalise)
		CString strTool = pchTool, strTargTool;
		if (!strTool.CompareNoCase("mfc")){
			if( pchSettings ){
				int iUseOfMFC = atoi(pchSettings);
				if( iUseOfMFC >= 0 && iUseOfMFC < 3 ){
					SetTargetProp(hTarg, Prop_UseOfMFC, iUseOfMFC, (HBUILDER)pItem->GetProject());
					return TRUE;
				}
			}
			return FALSE;
		} else if(!strTool.CompareNoCase("xbox!remotename")) {
		    /* Make sure we're on an xbox project */
            if(pProjType->GetPlatform()->GetUniqueId() != xbox)
                return FALSE;
		    CProject *pProj = pItem->GetProject();
		    CString strTarg(pchSettings);
		    pProj->SetRemoteTargetFileName(strTarg);
		    return TRUE;
        }

		
		if (strTool.GetLength() < 4 || strTool.Right(4).CompareNoCase(".exe"))
			strTool += ".exe";

		// enumerate the tools for this project type
		// and get matching exe name
		CPtrList * pTools = pProjType->GetToolsList();
		POSITION pos = pTools->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CBuildTool * pTool = (CBuildTool *)pTools->GetNext(pos);

			if (pTool->GetStrProp(P_ToolExeName, strTargTool) == valid &&
				_tcsicmp((const TCHAR *)strTargTool, (const TCHAR *)strTool) == 0
			   )
			{
				pBuildTool = pTool;
				break;
			}
		}
	}

	if (pBuildTool == (CBuildTool *)NULL)
		return FALSE;	// no tool for this item
	
	COptionHandler * popthdlr = pBuildTool->GetOptionHandler();
	if (popthdlr == (COptionHandler *)NULL)
		return FALSE;	// no option handler for this item

	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	
	
	// refer our engine to this item and option handler
	g_prjoptengine.SetOptionHandler(popthdlr);
	g_prjoptengine.SetPropertyBag(pItem);

	// get our settings string
	CString strSettings;
	BOOL fSet = TRUE;

	if (!fAdd)
	{
		(void) g_prjoptengine.GenerateString(strSettings, OBNone | OBShowDefault | OBNeedEmptyString /* NOT (OBShowFake | ONInherit) */);

		// remove these settings from the current set
		int iSubStr = strSettings.Find(pchSettings);
		if (iSubStr != -1)
		{
			// remove this 'piece' of the string
			CString strWork;
			strWork = strSettings.Left(iSubStr);
			strWork += strSettings.Right(strSettings.GetLength() - iSubStr - _tcslen(pchSettings));

			// set the new string
			strSettings = strWork;
		}
		else
		{
			// not found, don't bother to set these
			fSet = FALSE;
		}
	}
	else
	{
		// just set these
		strSettings = pchSettings;
	}

	// parse the options?
	if (fSet)
	{
		// clear if explicit or if subtract
		OptBehaviour optbeh = OBNone | OBNeedEmptyString;
		if (fClear || !fAdd) optbeh |= OBClear;

		g_prjoptengine.ParseString(strSettings, optbeh);
	}

	return TRUE;	// success
}							 

// Map an external property number to an internal property number
static UINT mapPropToPropI[] =
{
	P_ItemExcludedFromBuild,		// property 0
	P_ProjUseMFC,					// property 1
	P_ProjAppWizUseMFC,				// property 2
	0,								// property 3
	0,								// property 4
	P_OutDirs_Intermediate,			// property 5
	P_OutDirs_Target,				// property 6
	P_Proj_TargDefExt,				// property 7
};

BOOL CBldSysIFace::MapPropToPropI
(
	UINT			idProp,						// external property number
	UINT &			idPropI						// internal (private) property number
)
{
	if ((idProp + 1) > (sizeof(mapPropToPropI) / sizeof(UINT)))
	{
		ASSERT(FALSE);	// alert failure in debug version
		return FALSE;	// failed
	}

	// perform the mapping
	idPropI = mapPropToPropI[idProp];

	// is this property valid
	return TRUE;	// ok
}

// Get the config. record for a file, 'hFile', in a given target, 'hTarg'.
ConfigurationRecord * CBldSysIFace::GetConfigRecFromFileI
(
	HBLDTARGET		hTarg,	// handle to the target
 	HBLDFILE		hFile	// handle to the file to get the config. for
)
{
	// get the target file CProjItem
	CFileItem * pItem = CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile);
	ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));

	// get our target name
	CString strTarg = m_strlstTargets.GetAt((POSITION)hTarg);

	// get this target config record (create it if it doesn't exist)
	return pItem->ConfigRecordFromConfigName((const TCHAR *)strTarg, TRUE);
}

// Get the config. record for a target, 'hTarg'
ConfigurationRecord * CBldSysIFace::GetConfigRecFromTargetI
(
	HBLDTARGET		hTarg,	// handle to the target
	HBUILDER		hBld	// builder that contains target? default=('current'==ACTIVE_BUILDER) 
)
{
	// get the target file CProject
	CProject * pItem = CnvHBuilder(hBld);
	if( pItem == NULL )
		return NULL;
	
	ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProject)));

	// get our target name
	CString strTarg = m_strlstTargets.GetAt((POSITION)hTarg);

	// get this target config record
	return pItem->ConfigRecordFromConfigName((const TCHAR *)strTarg);
}

// Set an integer or string property for this file
BOOL CBldSysIFace::SetFileProp
(
	HBLDTARGET		hTarg,					// handle to the target that contains the file
	HBLDFILE		hFile,					// handle to the file
	UINT			idProp,					// identifier of the property
	int				i						// property value
)
{
	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	// get this file's config record
	ConfigurationRecord * pcr = GetConfigRecFromFileI(hTarg, hFile);

	CFileItem * pItem = CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile);
	CProjTempProjectChange projChange(pItem->GetProject());

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

	// set integer property
	BOOL fRet = pItem->SetIntProp(idPropI, i);
	if (fRet)
		pcr->BagCopy(CurrBag, BaseBag, idPropI, idPropI);
	

	return fRet;	// ok?
}

BOOL CBldSysIFace::SetFileProp
(
	HBLDTARGET		hTarg,					// handle to the target that contains the file
	HBLDFILE		hFile,					// handle to the file
	UINT			idProp,					// identifier of the property
	CString &		str						// property value
)
{
	UINT idPropI;
	if (!MapPropToPropI(idProp, idPropI))
		return FALSE;

	// get this file's config record
	ConfigurationRecord * pcr = GetConfigRecFromFileI(hTarg, hFile);

	CFileItem * pItem = CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile);

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

	// set string property
	BOOL fRet = pItem->SetStrProp(idPropI, str);
	if (fRet)
		pcr->BagCopy(CurrBag, BaseBag, idPropI, idPropI);
	

	return fRet;	// ok?
}
   
void CBldSysIFace::MakeFilePropsDefault
(
	HBLDTARGET		hTarg,					// handle to the target that contains the file
	HBLDFILE		hFile					// handle to the file
)
{
	// get this file's config record
	ConfigurationRecord * pcr = GetConfigRecFromFileI(hTarg, hFile);

	CFileItem * pItem = CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile);

	// force this item into our config., make default current, then reset config.
	pItem->ForceConfigActive(pcr);	
	pItem->SetCurrentConfigAsBase();
	pItem->ForceConfigActive();
}

// Enumerate projects
void CBldSysIFace::InitBuilderEnum()
{
	CProject::InitProjectEnum();
}

HBUILDER CBldSysIFace::GetNextBuilder(CString & strBuilder, BOOL bOnlyLoaded /* = TRUE */)
{
	return (HBUILDER)(CProject::NextProjectEnum(strBuilder, bOnlyLoaded));
}

// Enumerate targets
void CBldSysIFace::InitTargetEnum(HBUILDER hBld)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == (CProject *)NULL)
		return;

	pProject->InitTargetEnum();
}

HBLDTARGET CBldSysIFace::GetNextTarget(CString & strTarget, HBUILDER hBld)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == (CProject *)NULL)
		return NO_TARGET;

	CTargetItem * pTargetItem;
	if (!pProject->NextTargetEnum(strTarget, pTargetItem))
		return NO_TARGET;

	return GetTarget(strTarget, hBld);
}

void CBldSysIFace::InitProjectDepEnum(HFILESET hFileSet, HBUILDER hBld /* = ACTIVE_BUILDER */)
{
	// FUTURE: extend to allow enum of multiple target dependencies
	// cache
	m_lstDepSet.RemoveAll();
	m_posHDepSet = (POSITION)NULL;

	int fo = CProjItem::flt_OnlyTargRefs;

	CTargetItem *pTarg = CnvHFileSet(hBld, hFileSet);
	ASSERT(pTarg != NULL);
	pTarg->FlattenSubtree(m_lstDepSet, fo);

	// get start of enumeration
	m_posHDepSet = m_lstDepSet.GetHeadPosition();
}

HPROJDEP CBldSysIFace::GetNextProjectDep(HFILESET hFileSet, HBUILDER hBld /* = ACTIVE_BUILDER */)
{
	if (m_posHDepSet == (POSITION)NULL)
		return NO_PROJDEP;

 	CProjectDependency * pProjDep = (CProjectDependency *)m_lstDepSet.GetNext(m_posHDepSet);
 
	return (HPROJDEP)pProjDep;
}

void CBldSysIFace::InitProjectDepEnum(HFILESET hFileSet, HBUILDER hBld, CObList &lstDepSet, POSITION &posHDepSet )
{
	// FUTURE: extend to allow enum of multiple target dependencies
	// cache
	lstDepSet.RemoveAll();
	posHDepSet = (POSITION)NULL;

	int fo = CProjItem::flt_OnlyTargRefs;

	CTargetItem *pTarg = CnvHFileSet(hBld, hFileSet);
	ASSERT(pTarg != NULL);
	pTarg->FlattenSubtree(lstDepSet, fo);

	// get start of enumeration
	posHDepSet = lstDepSet.GetHeadPosition();
}

HPROJDEP CBldSysIFace::GetNextProjectDep(HFILESET hFileSet, HBUILDER hBld, CObList &lstDepSet, POSITION &posHDepSet )
{

	if (posHDepSet == (POSITION)NULL)
		return NO_PROJDEP;

 	CProjectDependency * pProjDep = (CProjectDependency *)lstDepSet.GetNext(posHDepSet);
 
	return (HPROJDEP)pProjDep;
}

DWORD CBldSysIFace::GetDepth(HBLDTARGET){
	return 0;
}

// Enumerate file sets
void CBldSysIFace::InitFileSetEnum(HBUILDER hBld)
{
	// FUTURE: extend to allow enum of multiple builder filesets
	// cache
	m_lstFileSet.RemoveAll();
	m_posHFileSet = (POSITION)NULL;

	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == (CProject *)NULL)
		return;

	// get our list to enumerate
	pProject->InitTargetEnum();
	CString strDummy; CTargetItem * pTarget;
	while (pProject->NextTargetEnum(strDummy, pTarget))
	{
		// make sure we only get distinct filesets
		if (m_lstFileSet.Find(pTarget) == (POSITION)NULL)
			m_lstFileSet.AddTail(pTarget);
	}

	// get start of enumeration
	m_posHFileSet = m_lstFileSet.GetHeadPosition();
}

HFILESET CBldSysIFace::GetNextFileSet(HBUILDER hBld)
{
	if (m_posHFileSet == (POSITION)NULL)
		return NO_FILESET;

	return (HFILESET)m_lstFileSet.GetNext(m_posHFileSet);
}

// Enumerate files
void CBldSysIFace::InitFileEnum(HFILESET hFileSet, UINT filter /* = FileEnum_RemoveDeps */)
{
	// FUTURE: extend to allow enum of multiple fileset files
	// cache
	m_lstFile.RemoveAll();
	m_posHFile = (POSITION)NULL;

	// get our list to enumerate
	int fo = 0;
	if (filter & FileEnum_RemoveExcluded)
		fo |= CProjItem::flt_RespectItemExclude;

	if (filter & FileEnum_RemoveDeps) // default is no deps
		fo |= CProjItem::flt_ExcludeDependencies;

	fo |= (CProjItem::flt_ExcludeProjDeps | CProjItem::flt_ExcludeGroups);	// remove project deps
	
	CnvHFileSet(NO_BUILDER, hFileSet)->FlattenSubtree(m_lstFile, fo);

	// get start of enumeration
	m_posHFile = m_lstFile.GetHeadPosition();
}

HBLDFILE CBldSysIFace::GetNextFile(FileRegHandle & frh, HFILESET hFileSet)
{
	if (m_posHFile == (POSITION)NULL)
		return (HBLDFILE)NO_FILE;

	CFileItem * pItem = (CFileItem *)m_lstFile.GetNext(m_posHFile);
	ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));

	// get the file's file registry handle
	frh = pItem->GetFileRegHandle();
	return (HBLDFILE)pItem;
}												
BOOL CBldSysIFace::IsScanableFile(HBLDFILE hFile)
{
	if (hFile == (HBLDFILE)NO_FILE)
		return FALSE;

	int val;
	CProjItem * pItem = (CProjItem *)hFile;
	if (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		return FALSE;

	if ((pItem->GetIntProp(P_ItemExcludedFromScan, val)==valid) && (val!=0))
		return FALSE;

	return TRUE;
}

// Get a string list of possible target names for a file set
BOOL CBldSysIFace::GetFileSetTargets
(
	HFILESET		hFileSet,			// the file set to retrieve the target list for
	CStringList &	strlstTargs			// list of target names
)
{
	ASSERT(hFileSet != NO_FILESET);

	// make sure we have an empty string list
	strlstTargs.RemoveAll();

	const CPtrArray * paryConfigs = CnvHFileSet(ACTIVE_BUILDER, hFileSet)->GetConfigArray();
	int i = 0, iLast = paryConfigs->GetUpperBound();

	while (i <= iLast)
	{
		ConfigurationRecord * pcr = (ConfigurationRecord *) paryConfigs->GetAt(i++);	// get this one and advance

		// add the name if our target to our list if this target is valid
		if (pcr->IsValid())
			strlstTargs.AddTail(pcr->GetConfigurationName());
	}

	return TRUE;	// ok
}

// Enumerate files

// Get a string list of possible platform names for a target type (return *all* platforms when 'pchPlat' is NULL)
const CStringList * CBldSysIFace::GetAvailablePlatforms
(
	const TCHAR *	pchPlat,			// UI or 'official' platform name? default=retrieve across *all* platforms
	BOOL			fUIDesc				// return UI or 'official' names? default=UI
)
{
	return g_prjcompmgr.GetListOfPlatforms(pchPlat, fUIDesc);
}

// Get a string list of possible target type names (across *all* installed platforms).
const CStringList * CBldSysIFace::GetTargetTypeNames
(								   	
	const TCHAR *	pchTarg,		 	// UI or 'official' target name? default=retrieve all platforms
	BOOL			fUIDesc				// return UI or 'official' names? default=UI
)
{
	return g_prjcompmgr.GetListOfTypes(pchTarg, fUIDesc);
}

//
// Builder file section support
//
// Provide a callback function that will be called when 
// a buffer needs to be provided to be written or a 
// buffer has been read and can be processed.
//
// Pls. note that sections are distinguished by name.

// UNDONE: fix for multiple project model
BOOL CBldSysIFace::RegisterSection(CBldrSection * pbldsect)
{
	void * pvDummy;
	CString strKey;

	if (pbldsect->m_hBld == NULL)
	{
		pbldsect->m_hBld = GetActiveBuilder();
	}
	strKey.Format("%d:%s", pbldsect->m_hBld, pbldsect->m_strName);


	// check the validity of the section
	if (pbldsect->m_strName.IsEmpty() ||					// got a name?
		m_mapSections.Lookup(strKey, pvDummy)	// unique?
	   )
		return FALSE;

	m_mapSections.SetAt(strKey, (void *)pbldsect);
	return TRUE;	// success
}

BOOL CBldSysIFace::DeregisterSection(const CBldrSection * pbldsect)
{
	CString strKey;
	HBUILDER hBld;

	hBld = pbldsect->m_hBld;
	if (hBld == NULL)
	{
		hBld = GetActiveBuilder();
	}
	strKey.Format("%d:%s", hBld, pbldsect->m_strName);

	return m_mapSections.RemoveKey(strKey);
}

void CBldSysIFace::InitSectionEnum()
{
	m_posSection = m_mapSections.GetStartPosition();
}

CBldrSection * CBldSysIFace::GetNextSection(CString & strSection)
{
	CBldrSection * pbldsect = (CBldrSection *)NULL;
	strSection = "";

	if (m_posSection != (POSITION)NULL)
		m_mapSections.GetNextAssoc(m_posSection, strSection, (void * &)pbldsect);

	return pbldsect;
}

CBldrSection * CBldSysIFace::FindSection(const TCHAR * pchName, HBUILDER hBld /*  = ACTIVE_BUILDER */)
{
	CBldrSection * pbldsect;
	CString strKey;

	if (hBld == ACTIVE_BUILDER)
	{
		hBld = GetActiveBuilder();
	}
	strKey.Format("%d:%s", hBld, pchName);

	if (!m_mapSections.Lookup(strKey, (void * &)pbldsect))
	{
		hBld = ACTIVE_BUILDER; // failed. Look up "global" build section (created before projects). BUG Orion 20232
		strKey.Format("%d:%s", hBld, pchName);
		if (!m_mapSections.Lookup(strKey, (void * &)pbldsect))
			pbldsect = (CBldrSection *)NULL;

	}

	return pbldsect;
}


//
// Builder fileset query support
//

// Resource files
BOOL CBldSysIFace::GetResourceFileList
(
	CPtrList &		listRcPath,		// returned list of CPath *'s
	BOOL			fOnlyBuildable,	// only buildable ones?
	HFILESET		hFileSet,		// handle to the fileset (FUTURE: only does active)
	HBUILDER		hBld			// build that contains target? default='active builder'
)
{
	CProject * pProject = CnvHBuilder(hBld);

	if (pProject == NULL)
		return FALSE;

    if (pProject->IsExeProject())
    {
        // For exe projects we just return the path of the exe.
        listRcPath.AddTail((void *)pProject->GetFilePath());
        return TRUE;
    }

	ConfigurationRecord * pcr = (ConfigurationRecord *)NULL;

	// Convert the fileset to a target
	if (hFileSet != NULL)
	{
		CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
		pProject = pTarget->GetProject();

		// Get the target items config array
		const CPtrArray* pConfigArray = pTarget->GetConfigArray();
		int nSize = pConfigArray->GetSize();

		// Look for the first valid config for this target item
		for (int i = 0; i < nSize; i++)
		{
			pcr = (ConfigurationRecord*)pConfigArray->GetAt(i);
			if (pcr->IsValid())
 				break;
		}

		if (pcr == NULL)
			return FALSE;
	}

	// get our list of resource CFileItems
	CObList lstFileItems;
	if (!pProject->GetResourceFileList(lstFileItems, fOnlyBuildable, pcr))
		return FALSE;

	// construct our list of CPath *s
	listRcPath.RemoveAll();
	POSITION pos = lstFileItems.GetHeadPosition();
	while (pos != (POSITION)NULL)
		listRcPath.AddTail((void *)((CProjItem *)lstFileItems.GetNext(pos))->GetFilePath());

	return TRUE;	// ok
}

BOOL CBldSysIFace::GetResourceIncludePath
(
	CPath *pResFile, 
	CString &strIncludes
)
{
	ConfigurationRecord * pcr = (ConfigurationRecord *)NULL;

	// Also need to save any converted subprojects
	CProject::InitProjectEnum();
	CString strProject;
	CProject * pProject;
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
	{
		// get our list of resource CFileItems
		CObList lstFileItems;
		if (!pProject->GetResourceFileList(lstFileItems, FALSE, pcr))
			return FALSE;

		POSITION pos = lstFileItems.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CFileItem *pItem = (CFileItem *)lstFileItems.GetNext(pos);
			if (*(pItem->GetFilePath()) == *pResFile)
			{
				return(pProject->GetResourceIncludePath(pItem, strIncludes));
			}
		}
	}

	// get our list of resource CFileItems

	return FALSE;
}


// 
// Mixed-language support
//

// Is the language currently installed?
BOOL CBldSysIFace::LanguageSupported(UINT idLang)
{
	// perform this based on package installed?
	UINT idPkg = 0;

	if (idLang == CPlusPlus)
		idPkg = PACKAGE_LANGCPP;
	else if (idLang == Java)
		idPkg = PACKAGE_LANGJVA;
	else if (idLang == FORTRAN)
		idPkg = PACKAGE_LANGFOR;
	else
	{
		ASSERT(0);
	}
	

	return theApp.GetPackage(idPkg) != (CPackage *)NULL;
}


BOOL CBldSysIFace::OpenResource
(
	const TCHAR *	strResource,				// comma-seperated list of commands (can be macro-ized)
	long 			lType,
	HBLDTARGET		hTarg,					// handle to the target 
	HBUILDER		hBld					// build that contains target? default='active builder'
)
{
	BOOL hr = TRUE;
	CPtrList ptrlist;
	HFILESET hFileSet = GetFileSet(hBld, hTarg);
	GetResourceFileList(ptrlist, FALSE, hFileSet, hBld);
	if ( ptrlist.GetCount() > 0 )
	{
		CPath *pResPath = (CPath *)ptrlist.GetHead();
		pResPath->GetActualCase(TRUE);

		HCOMPOSITION hComp;
		LPRESOURCEIO pInterface;
		if (SUCCEEDED(theApp.FindInterface(IID_IResourceIO, (LPVOID FAR *)&pInterface)))
		{
			if (SUCCEEDED(pInterface->OpenRcFile(hFileSet, pResPath->GetFullPath(), &hComp)))
			{
				if (SUCCEEDED(pInterface->OpenResource(hComp, RT_DIALOG, strResource /* id */, -1 , NULL)))
				{
					hr = FALSE;
				}
			}
			pInterface->Release();
		}
	}
	return hr;
}

//
// Custom Build step support
//

BOOL CBldSysIFace::AssignCustomBuildStep
(
	const TCHAR *	pchCommand,				// comma-seperated list of commands (can be macro-ized)
	const TCHAR *	pchOutput,				// comma-seperated list of output files (can be macro-ized)
	const TCHAR *	pchDescription,			// description (if NULL then default description)
	HBLDTARGET		hTarg,					// handle to the target 
	HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
	HBUILDER		hBld					// build that contains target? default='active builder'
)
{
	// do we have a command and output?
	if (!pchCommand || pchCommand[0] == _T('\0') ||
		!pchOutput || pchOutput[0] == _T('\0')
	   )
		return FALSE;

	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
    ASSERT(pProject);
	if( pProject == NULL )
		return FALSE;

	CProjTempProjectChange projChange(pProject);

    // get the config rec for the target we depend upon.
    ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProjItem * pItem = hFile != NO_FILE ? (CProjItem *)CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile) : pProject;

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

 	CProjType *pProjType = pProject->GetProjType();
	if ( pProjType && pProjType->GetUniqueTypeId() == CProjType::exttarget ){
		pProject->SetStrProp(P_Proj_CmdLine, pchCommand);
	
		CString str = _T("");
		pProject->SetStrProp(P_Proj_RebuildOpt, pchDescription);
		pProject->SetStrProp(P_Proj_Targ, pchOutput);
		pProject->SetStrProp(P_Caller, pchOutput);
		pProject->SetStrProp(P_Proj_BscName, str);
		//pProject->SetStrProp(P_Proj_WorkingDir, str);
		pProject->SetStrProp(P_WorkingDirectory, str);
		pProject->SetStrProp(P_Args, str);
		pProject->SetIntProp(P_PromptForDlls, 1);
		pProject->SetStrProp(P_RemoteTarget, str);
		return TRUE;	// ok
	}

	// replace all new line characters with comma's
	TCHAR *pStr = _tcsdup(pchCommand);
	TCHAR *pCommand = pStr;
	
	while( *pStr != _T('\0') ){
		if( *pStr == _T('\n')  ){
			*pStr = _T('\t');
		}
		pStr = _tcsinc(pStr);
	}

	pStr = _tcsdup(pchOutput);
	TCHAR *pOutput = pStr;
	
	while( *pStr != _T('\0') ){
		if( *pStr == _T('\n')  ){
			*pStr = _T('\t');
		}
		pStr = _tcsinc(pStr);
	}
	CString strOutput = pOutput;
	CString strCommand = pCommand;
	
	// set custom build step
	BOOL fRet =
		CCustomBuildTool::SetCustomBuildStrProp(pItem,P_CustomCommand, strCommand) &&
		CCustomBuildTool::SetCustomBuildStrProp(pItem,P_CustomOutputSpec, strOutput) &&
		(!pchDescription || pItem->SetStrProp(P_CustomDescription, pchDescription));
	
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		pItem->SetIntProp(P_ItemIgnoreDefaultTool, TRUE);

	free(pCommand);
	free(pOutput);

	return fRet;	// ok
}

BOOL CBldSysIFace::UnassignCustomBuildStep
(
	HBLDTARGET		hTarg,					// handle to the target 
	HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
	HBUILDER		hBld					// build that contains target? default='active builder'
)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
    ASSERT(pProject);
	if( pProject == NULL )
		return FALSE;

	CProjTempProjectChange projChange(pProject);

    // get the config rec for the target we depend upon.
    ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProjItem * pItem = hFile != NO_FILE ? (CProjItem *)CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile) : (CProjItem *)CnvHTarget(hBld, hTarg);

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
		
	// un-assign custom build step
	BOOL fRet =
		pItem->SetStrProp(P_CustomCommand, "") &&
		pItem->SetStrProp(P_CustomOutputSpec, "") &&
		pItem->SetStrProp(P_CustomDescription, "");

	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		pItem->SetIntProp(P_ItemIgnoreDefaultTool, FALSE);

	return fRet;	// ok
}

BOOL CBldSysIFace::SetUserDefinedDependencies
(
	const TCHAR *	pchUserDeps,				// comma-seperated list of files (can be macro-ized)
	HBLDTARGET		hTarg,					// handle to the target 
	HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
	HBUILDER		hBld					// build that contains target? default='active builder'
)
{
	// get a builder for this target to be searched in
	CProject * pProject = CnvHBuilder(hBld);
    ASSERT(pProject);
	if( pProject == NULL )
		return FALSE;

	CProjTempProjectChange projChange(pProject);

    // get the config rec for the target we depend upon.
    ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CProjItem * pItem = hFile != NO_FILE ? (CProjItem *)CnvHBldFile(GetFileSet(ACTIVE_BUILDER, hTarg), hFile) : pProject;

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pProject);
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

	// replace all new line characters with tab's
	TCHAR *pCommand;
	if (NULL!=pchUserDeps && 0 != pchUserDeps[0])
	{
		pCommand = _tcsdup(pchUserDeps);
		TCHAR *pStr = pCommand;
		while( *pStr != _T('\0') ){
			if( (*pStr == _T('\n')) || (*pStr == _T(',')) ){
				*pStr = _T('\t');
			}
			pStr = _tcsinc(pStr);
		}
	}
	else
		pCommand = _tcsdup(_T(""));

	

	// set custom build step
	BOOL fRet = pItem->SetStrProp(P_UserDefinedDeps, pCommand);
	
	free(pCommand);

	return fRet;	// ok
}

BOOL CBldSysIFace::GetSelectedFile
(
	CPath * path						// path of file currently selected
)
{
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	CMultiSlob *pMultiSlob;
	VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));

	if (pMultiSlob == NULL)
		return FALSE;

	CProjItem * pItem = (CProjItem *)pMultiSlob->GetDominant();
	if (pItem == NULL)
		return FALSE;

	if (!pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
		return FALSE;
	
	if (pItem->GetContentList() != NULL)
		return FALSE;

	path = (CPath *)pItem->GetFilePath();

	return TRUE;
}

// compiler option handler
#include "optncplr.h"

// Map a build file id to an internal property number and component
typedef struct
{
	UINT s_idProp;
	UINT s_idOptHdlr;
	const TCHAR * s_pcDefFilename;
	const TCHAR * s_pcDefExtension;
} S_FileId;

static S_FileId mapFileIdToProp[] =
{
	{P_OutputDir_Pdb, BCID_OptHdlr_Compiler, CActionSlob::szDefVCFile, _TEXT(".pdb")},	// file id 0
	{P_OutputDir_Pch, BCID_OptHdlr_Compiler, CActionSlob::szDefVCFile, _TEXT(".pch")},	// file id 1
	{P_OutputDir_Pdb, BCID_OptHdlr_Compiler, CActionSlob::szDefVCFile, _TEXT(".idb")},	// file id 2
};

BOOL CBldSysIFace::GetBuildFile
(
	UINT idFile,
	TCHAR * szFileName, int cchFileBuffer,
	HBLDTARGET hTarg,
	HBUILDER hBld /* = ACTIVE_BUILDER */
)
{
	if ((idFile + 1) > (sizeof(mapFileIdToProp) / (sizeof(UINT) * 2)))
	{
		ASSERT(FALSE);	// alert failure in debug version
		return FALSE;	// failed
	}

	// get this target's config record
	ConfigurationRecord * pcr = GetConfigRecFromTargetI(hTarg, hBld);

	CString strFile;
	CProject * pItem = CnvHBuilder(hBld);
	if( pItem == NULL )
		return FALSE;

	// force this item into our config.
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	

  	BOOL fRet = FALSE;

	COptionHandler * popthdlr;

	BOOL fGotFileName = FALSE;

		// lookup the option handle for the compiler?
	if (g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, mapFileIdToProp[idFile].s_idOptHdlr),
									  (CBldSysCmp *&)popthdlr) &&

		// use it to map the .PDB name string prop?
		pItem->GetStrProp(popthdlr->MapLogical(mapFileIdToProp[idFile].s_idProp), strFile) &&

		// not empty?
		!strFile.IsEmpty()
	   )
	{
		// Okay, the item has an apperently non empty-name entry.  See if its
		// a directory by checking last character.  If it is,
		int len = strFile.GetLength();
		const TCHAR * pc = (const TCHAR *)strFile;
		pc = _tcsdec(pc, (TCHAR *)(pc+len));
	
		// need a filename?
		if (*pc != _T('/') && *pc != _T('\\'))
			fGotFileName = TRUE;	// no ... it doesn't appear to be a dir.
	}

	// got a filename?
	if (!fGotFileName)
	{
		// no, create a default..
		if (mapFileIdToProp[idFile].s_pcDefFilename)
			strFile += mapFileIdToProp[idFile].s_pcDefFilename;
		else
			// just append and change extension later
			strFile += pItem->GetFilePath()->GetFileName();
	}

	CPath pathFile;

	if (pathFile.CreateFromDirAndFilename(pItem->GetProjDir(), strFile))
	{
		// change the extension
		pathFile.ChangeExtension(mapFileIdToProp[idFile].s_pcDefExtension);

		// can we squirt this into the buffer?
		TCHAR * pch = (TCHAR *)(const TCHAR *)pathFile;
		if (_tcslen(pch) < (size_t)cchFileBuffer)
		{
			_tcscpy(szFileName, pch);
			fRet= TRUE;
		}
	}


	return fRet;
}



// For mirrored case, we need to make sure dep gets updated
// For C-syntax files, we just queue them up on the force update list, assuming parser will call us
// the force update list will do update when we write to proj file if parser didn't do anything for us
// For non-C-syntax files, we will just do the scan deps
void CBldSysIFace::PreserveDependencies
	(
		CTargetItem * pNewTarget,
		CProject * pProject
	)
{
//	ASSERT(!g_bNewUpdateDepModel);

	ASSERT(pNewTarget);
	CObList SubList;
	pNewTarget->GetBuildableItems(SubList);
	POSITION pos = SubList.GetHeadPosition();
	while (pos)
	{
		CProjItem *pTempItem = (CProjItem *) SubList.GetNext( pos );
		ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );
		ASSERT_VALID( pTempItem );
		if (pTempItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
		{
			CPath * pPath = (CPath *)pTempItem->GetFilePath();
			TCHAR * pch = _tcschr((TCHAR *)pPath->GetFullPath(), '.');

#if 0
			// don't scan the deps for now, hopefully background parser will do this for us quick enough
			if (pch && (_tcsicmp(pch, ".cpp")==0 || _tcsicmp(pch, ".cxx")==0 || _tcsicmp(pch, ".c")==0 ))
			{
				//queue it for update later
				FileItemDepUpdateQ((CFileItem *)pTempItem, NULL, NULL, g_FileForceUpdateListQ);
			}
			else
			{
				//scan deps, we queue on update list, so it will be updated at idle time
				FileItemDepUpdateQ((CFileItem *)pTempItem, NULL, NULL, g_FileForceUpdateListQ);
				FileRegHandle frh = pTempItem->GetFileRegHandle();
				FileItemDepUpdateQ((CFileItem *)pTempItem, NULL, frh, g_FileDepUpdateListQ);
			}
#endif
		}
	}
}

BOOL CBldSysIFace::LoadAppWiz()
{
	// set up to invoke MFCAPPWZ.DLL for C/C++?
	return g_AppWizardHandler.LoadAppWiz();
}


// Return the full search path for includes for a file.
// FUTURE: Use per-file include paths, eg. as specified by /i for the linker
BOOL CBldSysIFace::GetIncludePathI
(
	CString & strIncDirs,
	const CString & strPlat,
	const CPath * ppathSrc
)
{
	BOOL fGotPerFile = FALSE;

	// make all of these relative to the builder directory
	HBUILDER hBld = GetActiveBuilder();
	CProject * pBuilder = hBld != NO_BUILDER ? (CProject *)CnvHBuilder(hBld) : (CProject *)NULL;
				
	if (ppathSrc != (const CPath *)NULL && pBuilder != (CProject *)NULL)
	{
		// active fileset?
		HFILESET hFileSet;
		if (!strPlat.IsEmpty())
		{
			HBLDTARGET hTarget = GetTarget(strPlat, hBld);
			hFileSet = GetFileSet(hBld, hTarget);

		}
		else
		{
			hFileSet = (HFILESET)pBuilder->GetActiveTarget();
		}

		HBLDFILE hFile;
		if( hFileSet ){
			if (GetFile(ppathSrc, hFile, hFileSet, hBld))
			{
				// get the target file CProjItem
				CFileItem * pItem = CnvHBldFile(hFileSet, hFile);
				ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
				
				ConfigurationRecord * pcr;
				CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	
				if (!strPlat.IsEmpty())
				{
					// get this target config record
					pcr = pItem->ConfigRecordFromConfigName((const TCHAR *)strPlat, TRUE);
					ASSERT(pcr != (ConfigurationRecord *)NULL);
	
					// force this item into our config.
					projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);	
				}
	
				// get the include directories for this tool
				CBuildTool * pTool = pItem->GetSourceTool();
				if (pTool != (CBuildTool *)NULL)
				{
					pTool->GetIncludePaths(pItem, strIncDirs);
					fGotPerFile = TRUE;
				}
			}

		}
	}

	// got per-file includes?
	if (!fGotPerFile)
	{
		CDirMgr * pDirMgr = GetDirMgr();
		ASSERT(pDirMgr != (CDirMgr *)NULL);

		// get the index of the toolset
		int nToolSet = strPlat.IsEmpty() ? (int)-1 : pDirMgr->GetPlatformToolset(strPlat);

		pDirMgr->GetDirListString(strIncDirs, DIRLIST_INC, nToolSet);
	}

	return TRUE;	// success 
}

BOOL CBldSysIFace::IsBuildInProgress()
{
	return g_Spawner.SpawnActive();
}

HRESULT CBldSysIFace::DoSpawn(
	CStringList& lstCmd,		// Commands
	LPCTSTR szDirInit,			// Spawn directory
	BOOL fClear,				// Clear output window?
	BOOL fAsync,					// Asynchronous spawn
	DWORD *pcErr,				// OUT: number of errors
	DWORD *pcWarn				// OUT: number of warnings
)
{
	CDir dir;
	if (!dir.CreateFromString(szDirInit))
		return E_INVALIDARG;

	CErrorContext *pEC;
	if (g_Spawner.SpawnActive () ||	(pEC = g_Spawner.InitSpawn (fClear)) == NULL) 
		return E_UNEXPECTED;

	theApp.NotifyPackages (PN_BEGIN_BUILD, (void *) FALSE);
	// The following will be deleted by CSpawner::DoSpawn
	CCmdLine* pCmdLine = new CCmdLine();

	// Create CCmdLine object 
	CPtrList plCmds;
	POSITION posCmd = lstCmd.GetHeadPosition();
	while (posCmd)	 {
		CString& strCmd = lstCmd.GetNext(posCmd);
		pCmdLine->slCommandLines.AddTail(strCmd);
		pCmdLine->slDescriptions.AddTail("");
	}
	plCmds.AddTail(pCmdLine);

	CString str;
	CEnvironmentVariableList bldenviron;
	CDirMgr * pDirMgr = GetDirMgr();
	pDirMgr->GetDirListString(str, DIRLIST_PATH);
	bldenviron.AddVariable ("path", str);
	// Until the linker is fixed to not need the LIB
	// path for ENC relinks, pass this to the environment
	pDirMgr->GetDirListString ( str, DIRLIST_LIB );
	bldenviron.AddVariable ("lib", str);

	bldenviron.SetVariables();

	HRESULT hResult;
	DWORD errs, warns;
	UINT cmd = g_Spawner.DoSpawn(plCmds, dir, FALSE, FALSE, *pEC, fAsync);
	g_Spawner.GetErrorCount ( errs, warns );

	switch (cmd) {
	case CMD_Complete:
		hResult = NOERROR;
		break;
	case CMD_Canceled:
		hResult = E_ABORT;
		break;
	default:
		hResult = E_FAIL;
		// fixup case where an error occured but the spawner couldn't figure that out.
		// REVIEW: the whole counting of errors scheme should be reworked so we don't have to do this.
		// [vs98 24842]
		if (0 == errs)
			errs ++;
	}

	if (cmd == CMD_Canceled)
		pEC->AddString(IDS_USERCANCELED);

	bldenviron.ResetVariables();
	theApp.NotifyPackages (PN_END_BUILD, (void *) FALSE);
	g_Spawner.TermSpawn();
	*pcErr = errs;
	*pcWarn = warns;
	return hResult;
}

// Returns True if the given file name is in the fileset.
BOOL CBldSysIFace::IsProjectFile
(
	const CPath *	ppathFile,				// file path
	BOOL			bDepsInProject,			// Are dependencies part of the project
	HBUILDER		hBld					// builder that contains target? default='active builder' 
)
{
    // We'd better have a valid file path 
	if (!ppathFile) 
        return FALSE;

	// active builder means check all projects for this file
	if (hBld == ACTIVE_BUILDER)
	{
		// search all builders
		CString strBuilder;
		InitBuilderEnum();
		while ((hBld = GetNextBuilder(strBuilder, TRUE)) != NO_BUILDER)
		{
			ASSERT(hBld != ACTIVE_BUILDER);
			if (IsProjectFile(ppathFile, bDepsInProject, hBld))
				return TRUE;
		}
		return FALSE;
	}

	ASSERT(hBld != ACTIVE_BUILDER);
	// first, check for the project file itself!
	const CPath * ppathBuilder = GetBuilderFile(hBld);
	if ((ppathBuilder != NULL) && (*ppathFile == *ppathBuilder))
		return TRUE;

	// Check all filesets
	InitFileSetEnum(hBld);
	HFILESET hFileSet = GetNextFileSet();
	while (hFileSet != NO_FILESET)
	{
		// get the target item 
		CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
	
		// get the targets file registry
		CFileRegistry * pRegistry = pTarget->GetRegistry();
		ASSERT(pRegistry != NULL);
		
		// check to see if the file is in the target already
		FileRegHandle frh = pRegistry->LookupFile(ppathFile);
		//
		// review(tomse):
		// The previous logic for bDepsInProject was to return TRUE if there was a file item
		// list and bDepsInProject is TRUE and to immediately return TRUE if !bDepsInProject.
		// i.e., if bDepsInProject is TRUE, then there also must be an associated file item
		// for IsProjectFile to return TRUE which seems to be the reverse meaning of bDepsInProject.
		// Therefore, bDepsInProject is passed into IsFileInTarget for the
		// bAsFileItem flag so that the file item list will be checked if TRUE.
		// 
		if (NULL!=frh && pTarget->IsFileInTarget(frh,bDepsInProject))
		{
			frh->ReleaseFRHRef();
			return TRUE;
		}
		if (NULL!=frh)
			frh->ReleaseFRHRef();

		hFileSet = GetNextFileSet();
	}
    return FALSE;
}
 
void CBldSysIFace::DeleteUnknownDepMap(void)
{
	if (pUnknownDepMap != NULL) {
		POSITION pos = pUnknownDepMap->GetStartPosition();
		while (pos != (POSITION)NULL) {
			CPtrList	*pUnknownDepList;
			CObject		*pObj;
			CString		key;
			pUnknownDepMap->GetNextAssoc( pos, key, pObj );
			pUnknownDepList = (CPtrList *)pObj;
			pUnknownDepList->RemoveAll();
			delete pUnknownDepList;
			pUnknownDepMap->RemoveKey( (LPCTSTR)key );
		}
		delete pUnknownDepMap;
		pUnknownDepMap = NULL;
	}
}

int CBldSysIFace::GetBuilderToolset(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if (pProject != NULL)
		return(pProject->GetProjectToolset());
	else
		return(-1);
}

CPath *CBldSysIFace::GetTargetFileName(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return NULL;
	return pProject->GetTargetFileName();
}

int CBldSysIFace::GetTargetAttributes(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return NULL;
	return pProject->GetTargetAttributes();
}

void CBldSysIFace::GetRemoteTargetFileName(CString &strTarg, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetRemoteTargetFileName(strTarg);
}

void CBldSysIFace::SetRemoteTargetFileName(CString &strTarg, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->SetRemoteTargetFileName(strTarg);
}

CWnd *CBldSysIFace::GetSlobWnd(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return NULL;
	return pProject->GetSlobWnd();
}

const CPath *CBldSysIFace::GetBrowserDatabaseName(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return NULL;
	return pProject->GetBrowserDatabaseName();
}

void CBldSysIFace::UpdateBrowserDatabase(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->UpdateBrowserDatabase();
}

BOOL CBldSysIFace::GetPreCompiledHeaderName( CString &strPch, HBUILDER hBld )
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return pProject->GetPreCompiledHeaderName(strPch);
}

void CBldSysIFace::GetCallingProgramName(CString &strProg, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetCallingProgramName(strProg);
}

void CBldSysIFace::SetCallingProgramName(CString &strProg, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->SetStrProp(P_Caller, strProg);
}

void CBldSysIFace::GetProgramRunArguments(CString &strArgs, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetProgramRunArguments(strArgs);
}

void CBldSysIFace::SetProgramRunArguments(CString &strArgs, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->SetProgramRunArguments(strArgs);
}

void CBldSysIFace::GetWorkingDirectory(CString &strDir, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetWorkingDirectory(strDir);
}

BOOL CBldSysIFace::TargetIsCaller(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->TargetIsCaller());
}

BOOL CBldSysIFace::GetPromptForDlls(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->FPromptForDlls());
}

void CBldSysIFace::SetPromptForDlls(BOOL bPrompt, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->SetPromptForDlls(bPrompt);
}

void CBldSysIFace::SetProjectState(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->SetProjectState();
}

BOOL CBldSysIFace::GetClassWizAddedFiles(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->m_bClassWizAddedFiles);
}

void CBldSysIFace::SetClassWizAddedFiles(BOOL bAdded, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->m_bClassWizAddedFiles = bAdded;
}

void CBldSysIFace::ScanAllDependencies(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->ScanAllDependencies();
}

void CBldSysIFace::GetVersionInfo(PROJECT_VERSION_INFO *pInfo, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetVersionInfo(pInfo);
}

BOOL CBldSysIFace::GetInitialExeForDebug(BOOL bExecute, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->GetInitialExeForDebug(bExecute));
}

BOOL CBldSysIFace::GetInitialRemoteTarget(BOOL bBuild, BOOL fAlways, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->GetInitialRemoteTarget(bBuild, fAlways));
}

BOOL CBldSysIFace::UpdateRemoteTarget(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->UpdateRemoteTarget());
}

BOOL CBldSysIFace::DoTopLevelBuild(BOOL bBuildAll, CStringList *pConfigs,
			FlagsChangedAction fca, BOOL bVerbose, BOOL bClearOutputWindow, HBUILDER hBld, BOOL bRecurse )
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->DoTopLevelBuild(bBuildAll, pConfigs, fca, bVerbose, bClearOutputWindow, bRecurse));
}

void CBldSysIFace::GetEnvironmentVariables(CEnvironmentVariableList *pEnvList, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetEnvironmentVariables(pEnvList);
}

BOOL CBldSysIFace::IsProfileEnabled(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return(pProject->IsProfileEnabled());
}

CPlatform *CBldSysIFace::GetCurrentPlatform(HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return NULL;
	return(pProject ? pProject->GetCurrentPlatform() : NULL);
}

IBuildProject* CBldSysIFace::GetAutoProject(HBUILDER hBld)
{
	// First, we need to find the name of the builder so we can create
	//  an auto project for it.  Iterate through the builders until
	//  we find the name.
	HBUILDER hBldCurr;
	CString strBuilderCurr;
	InitBuilderEnum();
	while ( (hBldCurr = GetNextBuilder(strBuilderCurr)) != NULL )
	{
		if (hBldCurr == hBld)
		{
			// Found the name, so create the project and leave!
			// Don't AddRef the auto project, since it was just created (that implicitly
			//  addrefs it).
			return (IBuildProject*) CAutoProject::Create(hBldCurr, strBuilderCurr)
				->GetIDispatch(FALSE);
		}
	}

	return NULL;				// Not found
}

void CBldSysIFace::GetJavaClassName(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaClassName(str);
}

void CBldSysIFace::GetJavaClassFileName(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaClassFileName(str);
}

void CBldSysIFace::GetJavaDebugUsing(ULONG* pDebugUsing, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	*pDebugUsing = pProject->GetJavaDebugUsing();
}

void CBldSysIFace::GetJavaBrowser(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaBrowser(str);
}

void CBldSysIFace::GetJavaStandalone(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaStandalone(str);
}

void CBldSysIFace::GetJavaStandaloneArgs(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaStandaloneArgs(str);
}

void CBldSysIFace::GetJavaHTMLPage(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaHTMLPage(str);
}

void CBldSysIFace::GetJavaClassPath(CString &str, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	pProject->GetJavaClassPath(str);
}

void CBldSysIFace::GetJavaStandaloneDebug(ULONG* pStandaloneDebug, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return;
	*pStandaloneDebug = pProject->GetJavaStandaloneDebug();
}

BOOL CBldSysIFace::GetInitialJavaInfoForDebug(BOOL bExecute, HBUILDER hBld)
{
	CProject *pProject = CnvHBuilder(hBld);
	if( pProject == NULL )
		return FALSE;
	return pProject->GetInitialJavaInfoForDebug(bExecute);
}


#ifdef _DEBUG
//
// debug function
//
void DebugBldIFace()
{
	TCHAR szBuffer[_MAX_PATH];
	VERIFY(g_BldSysIFace.GetBuildFile(IDFILE_COMPILER_PCH, szBuffer, _MAX_PATH, g_BldSysIFace.GetActiveTarget())); 
}
#endif  

HRESULT CBldSysIFace::GetPkgProject(HBUILDER builder, IPkgProject** outPkgProject)
// outPkgProject should be a COleRef<> and they should better support assignment.
{
	ASSERT(outPkgProject != NULL);
	CProject *pProject = CnvHBuilder(builder);
	if( pProject == NULL )
		return E_FAIL;
	COleRef<IBSProject> bsProject = pProject->GetInterface();
	if (*outPkgProject != NULL) {
		(**outPkgProject).Release();
	}
	return bsProject->QueryInterface(IID_IPkgProject, (void**) outPkgProject);
}
BOOL CBldSysIFace::GetProjectGlyph(HBUILDER hBld, HFILESET hFileSet, CImageWell& imageWell, UINT * pnImage)
{
	if (&imageWell == NULL || pnImage == NULL)
		return FALSE;

	*pnImage = 4;
	VERIFY(imageWell.Load(IDB_SINGLE_ITEM, CSize(16, 16)));
	VERIFY(imageWell.Open());
	VERIFY(imageWell.CalculateMask());

	if ((hFileSet != ACTIVE_FILESET) && (hFileSet != NO_FILESET))
		hBld = GetBuilderFromFileSet(hFileSet);
	
	CProject * pProject = CnvHBuilder(hBld);
	if (pProject == NULL)
		return FALSE;

	// different glyphs for different proj types
	*pnImage += pProject->GetGlyphIndex(); // 0, 1 or 2

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldrcvtr.cpp ===
//
// Conversion of old VC++ 1.x builder files (.mak)
//
// [matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "bldrcvtr.h"	// our local header

IMPLEMENT_DYNAMIC(CBuilderConverter, CBldSysCmp)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Our CBuilderConverter class which is used to convert old VC++ 1.x builder files (.MAK).
// Each product variant should register one of these, e.g. the x86 C++ package and the x86 FORTRAN package.
CBuilderConverter::CBuilderConverter(const TCHAR * szPkg, WORD id)
{
	// set our id.
	SetId(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkg), id));
}

CBuilderConverter::~CBuilderConverter()
{
}

// initialise the converter prior to builder conversion
BOOL CBuilderConverter::FInitialise()
{
	return TRUE;	// success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldnode.h ===
//
// CBldNode
//
// Build Node
//
// [colint]
//

#ifndef _INCLUDE_BLDNODE_H
#define _INCLUDE_BLDNODE_H

/////////////////////////////////////////////////////////////////////////////
// CBuildNode
//
// This class is the main interface to the project window system

class CBuildNode
{
public:
	CBuildNode();
	~CBuildNode();

	// Basic project window interface
	virtual const TCHAR *GetNodeName();
	virtual CSlob *CreateNode();
	virtual void SetNodeFilter();

	// Process notifications about target deletions/additions here
	void TargetNotify(BOOL bDelete, HBLDTARGET hTarget);
	void ConfigChange();

	// Make the build pane visible
	void ShowBuildPane(BOOL bSetFocus = FALSE);

    // Hold/Enable visual updates to the workspace window
    void HoldUpdates();
    void EnableUpdates();

	// Target Node manager apis, for adding/removing target nodes
	// from our list of target nodes that we maintain
	void AddNode(CSlob * pViewSlob);
	void RemoveNode(CSlob * pViewSlob);

	// Creates a new target
	CSlob * CreateNode(HBLDTARGET hTarget, HBUILDER hBld);

	// Create new wrapper slobs for a given item
	CBuildSlob * CreateSlobs(CProjItem * pItem, ConfigurationRecord * pcrBase, CBuildSlob * pParent, BOOL bClone = FALSE);

	// Get the CBuildSlob corresponding to a given target. This function
	// will create CBuildSlobs if no appropriate ones already exist
	CBuildSlob * GetTargetSlob(HBLDTARGET hTarget);

	// Remove a CBuildSlob corresponding to a given target.
	void RemoveTargetSlob(HBLDTARGET hTarget);
	
	// Removes a Buildslob from our map
	void RemoveBuildSlob(CBuildSlob * pBuildSlob);

	// Removes all nodes in the build pane belonging to project hBld
	void RemoveNodes(HBUILDER hBld);

	// Removes all nodes in the build pane
	void RemoveAllNodes();

	// Are we currently in the process of removing all the nodes in the build pane
	BOOL RemovingAllNodes() { return m_bRemovingAllNodes; }

	// Tell anyone in the build pane about changes in config names
	void InformBldSlobs(CSlob * pChangedSlob, UINT idChange, DWORD dwHint);

	void AddDefaultNodes();

    // Gets a pointer to the first target slob if one exists
    CSlob * GetFirstTarget();

	void InitBldNodeEnum() { m_posTarget = m_lstNodes.GetHeadPosition(); }
	BOOL NextBldNodeEnum(void ** pNode)
	{
		if (m_posTarget == (POSITION)NULL)
			return FALSE;
		*pNode = m_lstNodes.GetNext(m_posTarget);
		return TRUE;
	}

	HBLDTARGET GetActiveTarget() { return m_hActiveTarget; }
	
protected:
	// Create new wrappers
	CBuildSlob * CreateTargetSlob(HBLDTARGET hTarget);

private:
	CMapPtrToPtr	m_mapTargets;	// Map from hTarget to CBuildSlob
	CPtrList		m_lstNodes;		// List of CBuildViewSlobs
	POSITION		m_posTarget;

	HBLDTARGET			m_hActiveTarget;	// Active target
	
	BOOL	m_bRemovingAllNodes;	// Are we removing all the nodes
};


/////////////////////////////////////////////////////////////////////////////
// CDefBuildNode
//
// This class provides the default build pane and nodes

class CDefBuildNode : public CDefProvidedNode
{
public:
	CDefBuildNode();
	~CDefBuildNode();

	void Add(CSlob * pNewNode);

	// We have our own pane
 	virtual BOOL HasOwnPane() { return TRUE; }

	// ...a string to use as the name for the pane, and...
	const TCHAR* GetPaneName()
	{
		if (m_strPaneName.IsEmpty())
			m_strPaneName.LoadString(IDS_PANE_NAME);
		return m_strPaneName;
	}

	// ...a function which can be called to create the node,
	// which returns a pointer to a slob which will then be
	// inserted into the pane (this can be a CMultiSlob if the
	// node provider wants to insert more than one root node).
	virtual CSlob *CreateNode();

	virtual int GetPriorityIndex()
		{ return 500; }

	virtual UINT GetHelpID()
		{ return (UINT)HID_WND_FILEVIEW; }

	virtual HBITMAP GetPaneGlyph()
	{
		HRSRC hRes = ::FindResource(GetResourceHandle(), MAKEINTRESOURCE(IDB_PANEGLYPH_BITMAP), RT_BITMAP);
		return(::AfxLoadSysColorBitmap(GetResourceHandle(), hRes));
	}

private:
    CMultiSlob * m_pTargets;
	CString m_strPaneName;
};

/////////////////////////////////////////////////////////////////////////////
// CDefAddBuildNode
//
// This class provides is used to add a new node to the build pane

class CDefAddBuildNode : public CDefProvidedNode
{
public:
	CDefAddBuildNode(HBLDTARGET hTarget, HBUILDER hBld);
	~CDefAddBuildNode();

	// We have our own pane
 	virtual BOOL HasOwnPane() { return TRUE; }

	// ...a string to use as the name for the pane, and...
	const TCHAR* GetPaneName()
	{
		if (m_strPaneName.IsEmpty())
			m_strPaneName.LoadString(IDS_PANE_NAME);
		return m_strPaneName;
	}

	// ...a function which can be called to create the node,
	// which returns a pointer to a slob which will then be
	// inserted into the pane (this can be a CMultiSlob if the
	// node provider wants to insert more than one root node).
	virtual CSlob *CreateNode();

	virtual int GetPriorityIndex()
		{ return 500; }

	virtual UINT GetHelpID()
		{ return (UINT)HID_WND_FILEVIEW; }

	virtual HBITMAP GetPaneGlyph()
	{
		HRSRC hRes = ::FindResource(GetResourceHandle(), MAKEINTRESOURCE(IDB_PANEGLYPH_BITMAP), RT_BITMAP);
		return(::AfxLoadSysColorBitmap(GetResourceHandle(), hRes));
	}

protected:
	HBLDTARGET	m_hTarget;
	HBUILDER	m_hBld;
	CString		m_strPaneName;
};

#ifdef CUSTOM_BLDNODES
// Only do this if the user can add and delete bld nodes as visual 
// representations of targets

/////////////////////////////////////////////////////////////////////////////
// CBuildGeneralPage
//
// This is the class for our Target filter page.

class CBuildGeneralPage : public CSlobPage
{
	virtual void InitializePage();
	virtual BOOL Validate();

	DECLARE_DYNAMIC(CBuildGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
};

extern CBuildGeneralPage g_BuildGeneralPage;

#endif

/////////////////////////////////////////////////////////////////////////////
// Helper function for getting a pointer to the one and only build node
CBuildNode* GetBuildNode();
extern CBuildNode* g_pBuildNode;

#endif // _INCLUDE_BLDNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldnode.cpp ===
//
// CSimpleBldNode
//
// Build Node
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "resource.h"

#include <prjapi.h>
#include <prjguid.h>

#include "bldslob.h"
#include "bldnode.h"	// our local header
#include "vwslob.h"
#include "exevw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Image wells for the glyphs we use in the build nodes

CImageWell g_imageWell;

/////////////////////////////////////////////////////////////////////////////
// Help functions for getting a pointer to the build node

CBuildNode* g_pBuildNode = 0;
CBuildNode* GetBuildNode()
{
    // return the build node pointer
	return g_pBuildNode;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode construction/destruction

CBuildNode::CBuildNode()
{
	// Initialize our build node pointer
	g_pBuildNode = this;

	// We are not removing any nodes yet!!
	m_bRemovingAllNodes = FALSE;

	// Set up the image wells
    if (!g_imageWell.IsOpen())
    {
 	    VERIFY(g_imageWell.Load(IDB_SINGLE_ITEM, CSize(16, 16)));
    	VERIFY(g_imageWell.Open());
	    VERIFY(g_imageWell.CalculateMask());
    }
}

CBuildNode::~CBuildNode()
{
	// Null out our build node pointer
	g_pBuildNode = NULL;
}

const TCHAR * CBuildNode::GetNodeName()
{
	// This is the name of our node type
	// FUTURE: Move to .rc. This is unused right now.
	static TCHAR szName[] = "Target";	
	return szName;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode, node creation for the active target/exe projects

CSlob * CBuildNode::CreateNode()
{
	// Are we an exe project
	if (g_BldSysIFace.GetBuilderType() == ExeBuilder)
	{
		// Exe project
		CExeViewSlob * pExeSlob = new CExeViewSlob();
		m_lstNodes.AddTail(pExeSlob);

		// return the exe project slob as our node
		return pExeSlob;
	}
	else
	{
		// We should have an active target
		HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget();
		ASSERT(hTarget != NO_TARGET);
		HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();

		// Create the new node and add it to our list of top level nodes
		CBuildViewSlob * pViewSlob = new CBuildViewSlob(hTarget, hBld);
		m_lstNodes.AddTail(pViewSlob);
		
		// return the new node
		return pViewSlob;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode, node creation for a particular target. NOTE this will not
// work for exe projects

CSlob * CBuildNode::CreateNode(HBLDTARGET hTarget, HBUILDER hBld)
{
	// Should only be calling this for internal projects
	ASSERT(g_BldSysIFace.GetBuilderType() == InternalBuilder);

	// The specified target must be a target
	ASSERT(hTarget != NO_TARGET);

	// Create the node and add it to our list of top level nodes
	// ASSERT(hBld==ACTIVE_BUILDER || hBld == g_BldSysIFace.GetBuilder(hTarget));
	CBuildViewSlob * pViewSlob = new CBuildViewSlob(hTarget, hBld);
	m_lstNodes.AddTail(pViewSlob);

	// return the new node
	return pViewSlob;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::AddNode, this is used when we are serializing to add in the
// view nodes to our list of view nodes.

void CBuildNode::AddNode(CSlob * pViewSlob)
{
	// This is used when we load in our serialized
	// data, as we don't creat the slobs, but we need
	// to set up the list of top level nodes.
	m_lstNodes.AddTail(pViewSlob);
}

void CBuildNode::RemoveNode(CSlob * pViewSlob)
{
	POSITION pos = m_lstNodes.Find(pViewSlob);
	if (pos != NULL)
		m_lstNodes.RemoveAt(pos);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::SetNodeFilter, this is called just after creation and will
// display the property page for the new node, which gives the user a list
// of possible targets they can select from.

void CBuildNode::SetNodeFilter()
{
	// Show the property page
	ShowPropertyBrowser();

	// Activate the filter field
	UpdatePropertyBrowser();
	BeginPropertyBrowserEdit(P_Title);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::TargetNotify, we get here when a target was either deleted or
// added

void CBuildNode::TargetNotify(BOOL bDelete, HBLDTARGET hTarget)
{
	if (bDelete)
	{
		// A target has been deleted so we'd better remove
		// any top level nodes that reference it
        RemoveTargetSlob(hTarget);
 	}
	else
	{
		// Process target additions here
		// Ok add a new node automagically!
		HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);

		CTargetItem * pTarget = g_BldSysIFace.CnvHTarget(hBld, hTarget);

		CBuildViewSlob * pTargetSlob;
		HBLDTARGET hCurrTarg;	CTargetItem * pCurrTarg;
		POSITION pos = m_lstNodes.GetHeadPosition();
		while (pos != NULL)
		{
			pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);
			hCurrTarg = pTargetSlob->GetTarget();

			pCurrTarg = g_BldSysIFace.CnvHTarget(hBld, hCurrTarg);
			if (pCurrTarg == pTarget)
			{
				HBLDTARGET hNewTarg;
				HFILESET hFileSet = g_BldSysIFace.GetFileSet(hBld, hCurrTarg);
				VERIFY(g_BldSysIFace.GetTargetFromFileSet(hFileSet, hNewTarg, hBld));
				if (hNewTarg == hTarget)
				{
					// we need to change the target that the node on display
					// represents
					pTargetSlob->SetFilterTarget(hTarget);
				}
				return;
			}
		}

		CDefAddBuildNode defNewNode(hTarget, hBld);

		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		VERIFY(SUCCEEDED(pProjSysIFace->AddRootProvidedNode(&defNewNode, NULL)));
	}
}

void CBuildNode::ConfigChange()
{
    HoldUpdates();

	HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
	
	m_hActiveTarget = g_BldSysIFace.GetActiveTarget(hBld);

	HBUILDER hCurrBld;
	HBLDTARGET hCurrTarg;
    HFILESET hFileSet;
	CBuildViewSlob * pTargetSlob;
	POSITION pos = m_lstNodes.GetHeadPosition();
	while (pos != NULL)
	{
		pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);
		hCurrTarg = pTargetSlob->GetTarget();
		hCurrBld = g_BldSysIFace.GetBuilder(hCurrTarg);
		if(hCurrBld)
		{
			hFileSet = g_BldSysIFace.GetFileSet(hCurrBld, hCurrTarg);

			// we could get null file set if hCurrTarg is to be deleted
			if (hFileSet != (HFILESET)NULL)
			{
				HBLDTARGET hTarg;
				g_BldSysIFace.GetTargetFromFileSet(hFileSet, hTarg, hBld /* REVIEW: hCurrBld? */);

				// Check whether hTarg is in the middle of being deleted; if so we must
				// avoid setting the CBuildViewSlob to display it.  This could happen
				// if hTarg was the active config, but was deleted, so we are now
				// changing the active config to a target with the same platform as hTarg
				// (but different fileset).  [olympus:1022]
				CString strTmp;
				if (g_BldSysIFace.GetTargetName(hTarg, strTmp, hCurrBld))
				{
					// It is OK to have this viewslob display its fileset's current
					// platform.
					pTargetSlob->SetFilterTarget(hTarg);
				}

				// case where non build system project is active ?
				if( hBld == NO_BUILDER ){
					// Force a repaint of our target node
					pTargetSlob->InformDependants(SN_ALL);
				}
			}
		}
	}	
	
	// make sure that active target node is visible
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	pos = m_lstNodes.GetHeadPosition();
	while (pos != NULL)
	{
		pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);
		hCurrTarg = pTargetSlob->GetTarget();
		if (hCurrTarg == m_hActiveTarget)
		{
			pProjSysIFace->ScrollSlobIntoView(pTargetSlob, TRUE);
			break;
		}
	}

    EnableUpdates();
}

/////////////////////////////////////////////////////////////////////////////
// Remove all the nodes in the build pane for a particular project
void CBuildNode::RemoveNodes(HBUILDER hBld)
{
	// Get a pointer to the project workspace window interface
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	ASSERT(hBld);
	pProjSysIFace->FlushUndo();

	// Loop through all nodes that match hBld
	CBuildViewSlob * pTargetSlob;
	POSITION pos, posThis;
	pos = m_lstNodes.GetHeadPosition();
	while (pos != NULL)
	{
		// Get the next node
		posThis = pos;
		pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);

		// Get the target corresponding to the target
		HBLDTARGET hTarget = pTargetSlob->GetTarget();

		// only interested in ones that match this builder
		HBUILDER hCmpBld = g_BldSysIFace.GetBuilder(hTarget);
		
		// ASSERT(hCmpBld!=NOBUILDER); // REVIEW: currently fails if exe project!
		if ((hCmpBld!=NO_BUILDER) && (hCmpBld!=hBld))
			continue;

		// attempt to remove this node--this will only succeed if the node
		// is visible in the FileView tree, and is unnecessary otherwise.
		pProjSysIFace->RemoveSlob(pTargetSlob, FALSE);
 	
		CBuildSlob * pBuildSlob;
		// Ok now delete the wrapper slobs
		if ((m_mapTargets.Lookup((void *&)hTarget, (void *&)pBuildSlob)))
		{
			delete pBuildSlob;

			// Remove the CBuildSlob entry in our map
			m_mapTargets.RemoveKey((void *&)hTarget);
		}
 	}
}

/////////////////////////////////////////////////////////////////////////////
// Remove all the nodes in the build pane

void CBuildNode::RemoveAllNodes()
{
	// We are removing all nodes (this is used to ignore informs)
	m_bRemovingAllNodes = TRUE;

	// Get a pointer to the project workspace window interface
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	// Loop through all nodes that are being shown
	CBuildViewSlob * pTargetSlob;
	POSITION pos, posThis;
	pos = m_lstNodes.GetHeadPosition();
	while (pos != NULL)
	{
		// Get the next node
		posThis = pos;
		pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);

		// Get the target corresponding to the target
		HBLDTARGET hTarget = pTargetSlob->GetTarget();

		// Remove this node (this will cause it to be deleted)
		VERIFY(SUCCEEDED(pProjSysIFace->RemoveSlob(pTargetSlob, FALSE)));
 	
		CBuildSlob * pBuildSlob;
		// Ok now delete the wrapper slobs
		if ((m_mapTargets.Lookup((void *&)hTarget, (void *&)pBuildSlob)))
		{
			delete pBuildSlob;

			// Remove the CBuildSlob entry in our map
			m_mapTargets.RemoveKey((void *&)hTarget);
		}
 	}

	// Ok we have finished removing all the nodes
	m_bRemovingAllNodes = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::GetTargetSlob, this does a lookup to see if we have CBuildSlobs
// already for the given target, if not we create them

CBuildSlob * CBuildNode::GetTargetSlob(HBLDTARGET hTarget)
{
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
	if (hBld == NO_BUILDER)
		return NULL;

	// Should only be calling this for internal projects
	ASSERT(g_BldSysIFace.GetBuilderType(hBld) == InternalBuilder);

	// Find the wrapper slob for the given target, if it
	// doesn't exist then we attempt to create it
	CBuildSlob * pBuildSlob = NULL;
	if (!m_mapTargets.Lookup((void *&)hTarget, (void *&)pBuildSlob))
		pBuildSlob = CreateTargetSlob(hTarget);
	
	// Return the CBuildSlob
	return pBuildSlob;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::RemoveBuildSlob, this removes a build slob from our map. This
// is needed when a CBuildSlob is deleted because the underlying projitem has
// been deleted. In this case the CBuildSlob self destructs and so we need a 
// way to remove the entry in our map. Just before the CBuildSlob destructs
// we get called here, and so have a chance to remove the entry in the map


// FUTURE: Possible performance problem, as for every CBuildSlob that
// gets deleted this function will be called, and we do a search for it in our
// map. This could get to be a problem if we have a lot of targets.

void CBuildNode::RemoveBuildSlob(CBuildSlob * pSlob)
{
    // Ok now delete the wrapper slobs
    CBuildSlob * pBuildSlob;
    HBLDTARGET hTarget;
	POSITION pos = m_mapTargets.GetStartPosition();
	while (pos != NULL)
	{
		m_mapTargets.GetNextAssoc(pos, (void *&)hTarget, (void *&)pBuildSlob);
		if (pBuildSlob == pSlob)
		{
			// Found the target corresponding to the CBuildSlob so remove it
			m_mapTargets.RemoveKey((void *&)hTarget);
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::RemoveTargetSlob, this really removes any CBuildViewSlobs currently
// representing the target being deleted. The CBuildSlob hierachy is also deleted

void CBuildNode::RemoveTargetSlob(HBLDTARGET hTarget)
{
	// Should only be calling this for internal projects
	ASSERT(g_BldSysIFace.GetBuilderType() == InternalBuilder);

	// A Target is being deleted
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	CBuildViewSlob * pTargetSlob;
	POSITION pos, posThis;
	pos = m_lstNodes.GetHeadPosition();
	while (pos != NULL)
	{
		posThis = pos;
		pTargetSlob = (CBuildViewSlob *)m_lstNodes.GetNext(pos);
		if (pTargetSlob->GetTarget() == hTarget)
		{
			// Ok we got the slob, so now tell the project window to remove it
			VERIFY(SUCCEEDED(pProjSysIFace->RemoveSlob(pTargetSlob, FALSE)));
		}
	}

    CBuildSlob * pBuildSlob;
    // Ok now delete the wrapper slobs
    
	if (m_mapTargets.Lookup((void *&)hTarget, (void *&)pBuildSlob))
    {
		delete pBuildSlob;

		// Remove the CBuildSlob entry in our map
		m_mapTargets.RemoveKey((void *&)hTarget);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::CreateSlobs, this function creates the wrapping CBuildSlobs for
// some CProjItems

CBuildSlob * CBuildNode::CreateSlobs(CProjItem * pItem, ConfigurationRecord * pcrBase, CBuildSlob * pParent, BOOL bClone /* = FALSE */)
{
	// Should only be calling this for internal projects
	ASSERT(g_BldSysIFace.GetBuilderType() == InternalBuilder);

	// Get the matching configuration for this item
	ConfigurationRecord * pcr = NULL;
	if (pcrBase != NULL)
	{
		pcr = pItem->ConfigRecordFromBaseConfig(pcrBase, TRUE);
	}
	else
	{
		ASSERT(bClone);
	}

	// Check that this dep cntr is in the same config as the one we are
	// intereested in.
	if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
	{
 		BOOL bOk = ((pcrBase != NULL) && (((CDependencyContainer *)pItem)->IsValid(pcrBase)));
		if (!bOk)
			return NULL;
	}

	// Create a wrapper for this proj item
	CBuildSlob * pSlob = new CBuildSlob(pItem, pcr);

	// Add the wrapper as a dependent of the real item
	pItem->AddDependant(pSlob);

	// Move this slob into its parent
	if (pParent != NULL)
	{
		if (bClone)
		{
			// fake MoveInto that isn't recorded
			pSlob->SetContainer(pParent);
			pParent->Add(pSlob);
		}
		else
		{
			pSlob->MoveInto(pParent);
		}
	}
 
	// Now create any wrappers for any children of this proj item
	CObList * pContentList = pItem->GetContentList();
	if (pContentList)
	{
		if (pParent == NULL)
			pSlob->UnThunkMoves();

		POSITION pos = pContentList->GetHeadPosition();
		while (pos != NULL)
		{
			CProjItem * pItem = (CProjItem *)pContentList->GetNext(pos);
			CreateSlobs(pItem, pcrBase, pSlob, bClone);
		}

		if (pParent == NULL)
			pSlob->ThunkMoves();
	}

	return pSlob;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::InformBldSlobs, this passes informs onto any bldslob that added
// itself to our inform list. Bulk of the work is done in CBuildViewSlob, this
// really just thunks through to that implementation

void CBuildNode::InformBldSlobs(CSlob * pChangedSlob, UINT idChange, DWORD dwHint)
{ 
	// We must have a target node to do this
	if (m_mapTargets.GetCount() == 0)
		return;

	// Ok just get any random target node, in our case we get the first one
	HBLDTARGET hTarget;
	CBuildSlob * pBuildSlob;
	POSITION pos = m_mapTargets.GetStartPosition();
	m_mapTargets.GetNextAssoc(pos, (void* &)hTarget, (void *&)pBuildSlob);
	pBuildSlob->InformBldSlobs(pChangedSlob, idChange, dwHint);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildNode::CreateTargetSlob, this creates all the wrapping CBuildSlobs for
// a given target

CBuildSlob * CBuildNode::CreateTargetSlob(HBLDTARGET hTarget)
{
	// Get the active builder and the project
 	// HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
	CProjItem * pItem = g_BldSysIFace.CnvHTarget(hBld, hTarget);
	if (pItem == NULL)
		return NULL;	// could be NULL if unsupported platform

	// Get the configuration name
	CString strConfigName;
	VERIFY(g_BldSysIFace.GetTargetName(hTarget, strConfigName, hBld));

	// Get the configuration record pointer for this 
	ConfigurationRecord * pcr = pItem->ConfigRecordFromConfigName(strConfigName);
	pcr = (ConfigurationRecord *) pcr->m_pBaseRecord;

	// Create the wrapper slobs
	CBuildSlob * pTargetSlob = CreateSlobs(pItem, pcr, NULL);

	// Add this wrapped target to our list of wrapped targets
	m_mapTargets.SetAt((void *&)hTarget, pTargetSlob);

	// Return a pointer to the newly created wrapper for the target itself
	return pTargetSlob;
}

CSlob * CBuildNode::GetFirstTarget()
{
	if (!m_lstNodes.IsEmpty())
		// Get a build view slob that is on display
		return (CSlob *)m_lstNodes.GetHead();
    else
        return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// ShowBuildPane makes the build pane visible

void CBuildNode::ShowBuildPane(BOOL bSetFocus /* = FALSE */)
{
	// We must have some nodes to make this visible
    CSlob * pTargetSlob = GetFirstTarget();
    if (pTargetSlob)
	{
		// Activate the pane containing the build view slob, which should be
		// the build pane.
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		VERIFY(SUCCEEDED(pProjSysIFace->ActivateContainingPane(pTargetSlob, TRUE, bSetFocus)));
	}
}

/////////////////////////////////////////////////////////////////////////////
// HoldUpdates stops the workspace window from visually updating

void CBuildNode::HoldUpdates()
{
    CSlob * pTargetSlob = GetFirstTarget();
    if (pTargetSlob)
	{
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
        VERIFY(SUCCEEDED(pProjSysIFace->FreezeContainingPane(pTargetSlob)));
	}
}

/////////////////////////////////////////////////////////////////////////////
// EnableUpdates allows the workspace window to visually update

void CBuildNode::EnableUpdates()
{
    CSlob * pTargetSlob = GetFirstTarget();
    if (pTargetSlob)
	{
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
        VERIFY(SUCCEEDED(pProjSysIFace->ThawContainingPane(pTargetSlob)));
	}
}

void CBuildNode::AddDefaultNodes()
{
	// Do we need to add any default nodes
	if (m_lstNodes.IsEmpty())
	{
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		CDefBuildNode DefNode;
		VERIFY(SUCCEEDED(pProjSysIFace->AddRootProvidedNode(&DefNode, NULL)));
 	}
}

/////////////////////////////////////////////////////////////////////////////
// CDefBuildNode construction/destruction

CDefBuildNode::CDefBuildNode()
{
	m_pTargets = NULL;
}

CDefBuildNode::~CDefBuildNode()
{
    if (m_pTargets)
        delete m_pTargets;
}

/////////////////////////////////////////////////////////////////////////////
// CDefBuildNode::CreateNode, this creates the default nodes for a builder

CSlob * CDefBuildNode::CreateNode()
{
    if (m_pTargets)
        delete m_pTargets;

	// We create a node for each target so we must use a MultiSlob
	m_pTargets = new CMultiSlob;

	// Are we dealing with an exe project
    if (g_BldSysIFace.GetBuilderType() == ExeBuilder)
    {
		// We only add one node for an exe project
        m_pTargets->Add(GetBuildNode()->CreateNode());
    }
    else
    {
    	// Enumerate all targets and add a node for each one
		CString strProject;
    	HBLDTARGET hTarget;
		HFILESET hFileSet;
		HBUILDER hBld;
		g_BldSysIFace.InitBuilderEnum();
		while ((hBld = g_BldSysIFace.GetNextBuilder(strProject, FALSE)) != NO_BUILDER)
		{
			g_BldSysIFace.InitFileSetEnum(hBld);
			while ((hFileSet = g_BldSysIFace.GetNextFileSet(hBld)) != NO_FILESET)
  			{
		    	g_BldSysIFace.GetTargetFromFileSet(hFileSet, hTarget, hBld);
				if (hTarget != NO_TARGET)
				{
					m_pTargets->Add(GetBuildNode()->CreateNode(hTarget, hBld));
				}
		    }
		}
    }

	// Return our nodes
	return m_pTargets;
}

void CDefBuildNode::Add(CSlob * pNewNode)
{
	if (m_pTargets==NULL)
		m_pTargets = new CMultiSlob;
	m_pTargets->Add(pNewNode);
}

/////////////////////////////////////////////////////////////////////////////
// CDefAddBuildNode construction/destruction

CDefAddBuildNode::CDefAddBuildNode(HBLDTARGET hTarget, HBUILDER hBld)
{
	m_hTarget = hTarget;
	m_hBld = hBld;
}

CDefAddBuildNode::~CDefAddBuildNode()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDefAddBuildNode::CreateNode, this class is used to add a new node to the
// build pane

CSlob * CDefAddBuildNode::CreateNode()
{
 	return (GetBuildNode()->CreateNode(m_hTarget, m_hBld));
}

#ifdef CUSTOM_BLDNODES

/////////////////////////////////////////////////////////////////////////////
// Target Filter property page

IMPLEMENT_DYNAMIC(CBuildGeneralPage, CSlobPage)

BEGIN_IDE_CONTROL_MAP(CBuildGeneralPage, IDDP_PROPERTIES_TARGETS, IDS_PROPERTIES_TARGETS)
	MAP_EDIT(IDC_TARGET, P_Title)
END_IDE_CONTROL_MAP()

CBuildGeneralPage g_BuildGeneralPage;

/////////////////////////////////////////////////////////////////////////////
// CBuildGeneralPage::InitializePage, fill the Target Filter combo with the
// available targets

void CBuildGeneralPage::InitializePage()
{
	// Base class initialization
	CSlobPage::InitializePage();

	// Clear out the combos contents
	CComboBox* pCombo = (CComboBox*)GetDlgItem(IDC_TARGET);
	pCombo->ResetContent();
	
	// Prepare to enumerate the targets
	HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
	g_BldSysIFace.InitTargetEnum(hBld);

	// Enumerate all the targets
	CString strTarget;
	HBLDTARGET hTarget;
	int nIndex;
	hTarget = g_BldSysIFace.GetNextTarget(strTarget, hBld);
	while (hTarget != NO_TARGET)
	{
		// Add the target to the combo box
		nIndex = pCombo->AddString(strTarget);

		// Select this if it is the currently active target for
		// the selected CBuildViewSlob
		if (hTarget == ((CBuildViewSlob *)m_pSlob)->GetTarget())
			pCombo->SetCurSel(nIndex);

		// Continue enumeration
		hTarget = g_BldSysIFace.GetNextTarget(strTarget, hBld);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildGeneralPage::Validate, this is where we change the target that the
// CBuildViewSlob represents

BOOL CBuildGeneralPage::Validate()
{
	// Get the index of the selected item
	CComboBox* pCombo = (CComboBox*)GetDlgItem(IDC_TARGET);
	int nIndex = pCombo->GetCurSel();

	// If we have an item then try to change the target
	if (nIndex != LB_ERR)
	{
		// Get the text currently selected
		CString strTarget;
		pCombo->GetLBText(nIndex, strTarget);

		// If we have a target name then look it up and set it
		// as our filter
		if (!strTarget.IsEmpty())
		{
			HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTarget);
			((CBuildViewSlob *)m_pSlob)->SetFilterTarget(hTarget);
		}
		else
			return FALSE;
	}
	return CSlobPage::Validate();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldiface.h ===
//
// CBldSysIFace
//
// Build System Interface
//
// [matthewt]
//

#ifndef _INCLUDE_BLDSYSIFACE_H
#define _INCLUDE_BLDSYSIFACE_H

#if defined(_BLD_INTERNAL)
#define BLD_IFACE _declspec(dllexport)
#elif defined(_BLD_ADD_ON)
#define BLD_IFACE _declspec(dllimport)
#else	// we *don't* export to an other packages (ie. the shell, res etc.)
#define BLD_IFACE
#endif	// !BLD_INTERNAL

#pragma warning(disable:4251) // dll-interface warnings...
#pragma warning(disable:4275)

#include "oletool.h"

// our builder interface (project.h)
class CProject;
class CProjItem;

// our builder component manager (prjconfg.h)
class CProjComponentMgr;

// our file registry (pfilereg.h)
#include "pfilereg.h"

class CBldSysIFace;

// FUTURE: move into the shell and export
#ifndef EXPORTED
#define EXPORTED virtual
#endif

#include <bldapi.h>

#include <utilbld_.h>

#include "prjconfg.h"

// properties
//

// item excluded in the build (currently only applicable to files)
#define Prop_ExcludeFromBuild		0x0
// 0 - included
// !0 - excluded

// use of MFC (integer prop)
#define Prop_UseOfMFC				0x1  
// 0 - not using MFC
// 1 - using MFC in a static lib
// 2 - using MFC in a DLL

// mark as an AppWiz target
#define Prop_AppWizTarg				0x2

// class wizard file name
#define Prop_ClsWzdName				0x3

// target directory name
#define Prop_TargetDirectory		0x4

// output directories
#define Prop_IntermediateOutDir		0x5
#define Prop_TargetOutDir			0x6

// default target extension
// if not set then
// '.exe' for apps
// '.dll' for dynamic link libraries
// '.lib' for static libraries
#define Prop_TargetDefExt			0x7

class CProject;
class CTargetItem;
class CFileItem;
class CProjectDependency;


class CBldSysIFace : CObject
{
public:
	CBldSysIFace();

	// Return the build system's builder component manager.
	// The component manager is used to register tools, platforms etc.
	// through. These components are usually stored in add-on platform 'packages'.
	EXPORTED CProjComponentMgr * GetProjComponentMgr();

	// Return the file system's global file registry.
	EXPORTED CFileRegistry * GetFileRegistry();

	//
	// Builder API
	//

	// Return the active build system if there is one, or NO_BUILDER if there isn't
	EXPORTED HBUILDER GetActiveBuilder();

	// Get the type of a builder. The possible builder types are :-
	// ExeBuilder, this is a builder that can only be used to debug files
	// Internal Builder, a full internal builder, supports building and debugging
	EXPORTED BuilderType GetBuilderType
	(
		HBUILDER		hBld = ACTIVE_BUILDER 	// builder to get type of
	);

	// Get the filename that this builder is stored in
	EXPORTED const CPath * GetBuilderFile
	(
		HBUILDER		hBld 	// builder to get file for
	);

	//
	// Using this API, a builder can be created, targets added, files added
	// to those targets and tool settings & properties set for the files.
	//
	// Create a builder with the name 'pchBldPath'.
	// If fForce == TRUE then if any builder is already open the user will
	// be prompted to close this builder, else the function will fail (HBUILDER == NO_BUILDER).
	EXPORTED HBUILDER CreateBuilder
	(
		const TCHAR *	pchBldPath,		// builder path
		BOOL			fForce = FALSE,	// force the creation
		BOOL			fOpen = FALSE	// create and then read from storage (eg. makefile), default=create new
	);

	// Set the dirty state of the builder
	EXPORTED BOOL SetDirtyState
	(
		HBUILDER	hBld,		// builder to dirty/clean, default='active builder'
		BOOL		fDirty = TRUE				// default='dirty builder'
	);

	// Get the dirty state of the builder
	EXPORTED BOOL GetDirtyState
	(
		HBUILDER	hBld		// builder to dirty/clean, default='active builder'
	);

	// Save a builder.
	EXPORTED BOOL SaveBuilder
	(
		HBUILDER		hBld	// builder to save, default='save active builder'
	);

	// Close a builder.
	EXPORTED BOOL CloseBuilder
	(
		HBUILDER		hBld, 	// builder to close, default='close active builder'
		DeletionCause	dcCause 	// builder to close, default='close active builder'
	);

	//
	// Workspace API
	// NOTE: We don't actually load/create/save the workspace, that is done by the prj package
	// However we do provide the UI for some of these things, and this is done here
	//

	// A workspace is being opened. We must open the makefile, and do various other things too.
	EXPORTED BOOL OnOpenWorkspace
	(
		const TCHAR *	pchWorkspaceName,	// Workspace name
		BOOL            bTemporary,         // Temporary workspace??
		BOOL            bInsertingIntoWks   // inserting into workspace? (don't AddProject main project)
	);

	// A default workspace is being created. We must create the makefile and add in the file
	EXPORTED BOOL OnDefaultWorkspace
	(
		const TCHAR *	pszFileToAdd		// File to base workspace around
	);

    EXPORTED BOOL OpenWorkspace
    (
        const TCHAR * pchWorkspace    // Name of workspace to open, can be
                                      // a .mak, or .exe/.dll/etc.., or .mdp
    );

	//
	// Fileset API
	//

	// Get a fileset with name 'pchFileSet' from the builder, 'hBld'.
	EXPORTED HFILESET GetFileSetFromTargetName
	(
		const TCHAR *	pchFileSet,					// name of this fileset to get
		HBUILDER		hBld 	// handle to the builder containing the fileset, default='active builder'
	);

	// Get the name of the target corresponding to a fileset, uses the default project to get
	// the information about the platform/debugness of the target
	// e.g, if the fileset's name is "foo", and the default project is "bar - win32 debug"
	// then this function returns "foo - win32 debug"
	EXPORTED BOOL GetTargetNameFromFileSet
	(
		HFILESET		hFileset,					// Fileset to get target name for
		CString &		str,						// Target name
		HBUILDER		hBld = ACTIVE_BUILDER, 	// handle to the builder containing the fileset, default='active builder'
		BOOL			bInvalid = FALSE			// If TRUE then we put 'No matching Configuration' after non matching configs
	);

	// Get the name of a fileset, e,g, "foo"
	EXPORTED BOOL GetFileSetName
	(
		HFILESET		hFileset,					// Fileset to get name of
		CString &		str,						// Fileset name
		HBUILDER		hBld 	// handle to the builder containing the fileset, default='active builder'
	);

	// Get the target corresponding to a fileset, given the context of the default project.
	EXPORTED BOOL GetTargetFromFileSet
	(
		HFILESET		hFileSet,					// Fileset to get current target for
		HBLDTARGET &	hTarg,						// Target for the Fileset
		HBUILDER		hBld = ACTIVE_BUILDER, 	// handle to the builder containing the fileset to match, default='active builder'
		BOOL			bInvalid = FALSE			// Do we care about non matching configs?
	);

	//
	// Target API
	//

	// Get the active target if there is on, or NO_TARGET if there isn't.
	EXPORTED HBLDTARGET GetActiveTarget
	(
		HBUILDER		hBld = ACTIVE_BUILDER		// handle to the builder containing the targets, default='active builder'
	);

	// Set the active target.
	EXPORTED BOOL SetActiveTarget
	(
		HBLDTARGET		hTarg,						// target to make the active one
		HBUILDER		hBld = ACTIVE_BUILDER		// handle to the builder containing the targets, default='active builder'
	);

    EXPORTED BOOL SetDefaultTarget
    (
		HBLDTARGET		hTarg,						// target to make the default one
		HBUILDER		hBld = ACTIVE_BUILDER		// handle to the builder containing the targets, default='active builder'
    );

	// Get a target with name 'pchTarg' from the builder, 'hBld'.
	EXPORTED HBLDTARGET GetTarget
	(
		const TCHAR *	pchTarg,					// name of this target to get
		HBUILDER		hBld 	// handle to the builder containing the target, default='active builder'
	);

	EXPORTED BOOL GetTargetName
	(
		HBLDTARGET		hTarg,						// target to get name of
		CString &		str,						// target name
		HBUILDER		hBld 	// handle to the builder containing the target, default='active builder'
	);


	// Create a target with name 'pchTarg' and add it to a builder.
	// Name of the 'official' or 'UI' platform must be specified in 'pchPlat', eg. "Win32 (x86)"
	// Name of the target type must be specified in 'pchType', eg. "Application"
	// Create debug or release default settings when a file is added to this target, 'fDebug'?
	// A target can mirror another target's, 'hMirrorTarg', fileset.
	// Function may fail (HBLDTARGET == NO_TARGET).
	EXPORTED HBLDTARGET AddTarget
	(
		const TCHAR *	pchTarg,				// name of this target (if == NULL then names auto created)

		const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
		const TCHAR *	pchType,				// UI or 'official' name of this target type
		BOOL			fUIDesc = TRUE,			// using UI or 'official' names? default=UI

		BOOL			fDebug = TRUE,			// debug or release settings? default=debug

		TrgCreateOp		trgop = TrgDefault,		// clone or mirros another target? default=no
		HBLDTARGET		hOtherTarg = NO_TARGET,	// target to clone or mirror

		SettingOp		setop = SettingsDefault,	// copy or default settings?
		HBLDTARGET		hSettingsTarg = NO_TARGET,	// target to copy settings from
		 
		BOOL			fQuiet = FALSE,			// show any warnings/errors during creation? default=yes
		BOOL			fOutDir = TRUE,			// output directories? default=yes
		BOOL			fUseMFC = TRUE,			// use MFC? default=yes
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder' 
	);

	// Create a pair of debug and release targets that mirror each other's file sets.
	EXPORTED BOOL AddDefaultTargets
	(
		const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
		const TCHAR *	pchType,				// UI or 'official' name of this target type

		HBLDTARGET &	hDebugTarg,				// newly created debug target
		HBLDTARGET &	hReleaseTarg,			// newly created release target

		BOOL			fUIDesc = TRUE,			// using UI or 'official' names? default=UI
		BOOL			fOutDir = TRUE,			// output directories? default=yes
		BOOL			fUseMFC = TRUE,			// use MFC? default=yes

		HBLDTARGET		hMirrorTarg = NO_TARGET,// do we want to 'chain the mirroring'?
		HBUILDER		hBld = ACTIVE_BUILDER,	// builder that contains target? default='active builder'
		const TCHAR *	pchTarg = NULL			// name of this target (if == NULL then names auto created)
	);
	
	// Delete an existing target
	EXPORTED BOOL DeleteTarget
	(
		HBLDTARGET		hTarg,					// target to delete
		HBUILDER		hBld 	// builder that contains target? default='active builder'
	);

	// Add a project as a dependency of another project.
	EXPORTED HPROJDEP AddProjectDependency
	(
		HFILESET		hFileSet,				// fileset in which to *place* dependency
		HFILESET		hDependantFileSet,		// fileset on which to place a dependency
		HBUILDER		hBld, 					// builder that contains hFileSet'
		HBUILDER		hDependantBld = NO_BUILDER 	// builder that contains hDependantFileSet (default is to use hBld)
	);

	EXPORTED BOOL RemoveProjectDependency
	(
		HPROJDEP		hProjDep,				// handle to the project dependency
		HFILESET		hFileSet,				// handle to the fileset
		HBUILDER		hBld 	// builder that contains target? default='active builder'
	);

	EXPORTED HFILESET GetDependantProject
	(
		HPROJDEP		hProjDep,				// handle to the project dependency
		HFILESET		hFileSet,				// handle to the fileset
		HBUILDER		hBld 	// builder that contains target? default='active builder'
	);

	// Add or subtract tool settings, pchSettings, to a target, 'hTarg'.
	// Must specify the 'executable' name of the tool'.
	// Subtract, fAdd==FALSE, will only work for individual options, eg. '/WX' and not '/WX /D "_DEBUG"'
	EXPORTED BOOL SetToolSettings
	(
		HBLDTARGET		hTarg,					// handle to the target
		const TCHAR * 	pchSettings,			// tool settings
		const TCHAR *	pchTool,				// name of the tool that 'owns' these settings
		BOOL			fAdd = TRUE,			// add or subtact? default=add
		BOOL			fClear = FALSE,			// clear settings before add or subtract?
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	//
	// Property API
	//

	// Get a string property for this target
	EXPORTED BOOL GetTargetProp
	(
		HBLDTARGET		hTarg,					// handle to the target
		UINT			idProp,					// identifier of the property
		CString &		str,					// property value
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	// Get an integer property for this target
	EXPORTED BOOL GetTargetProp
	(
		HBLDTARGET		hTarg,					// handle to the target
		UINT			idProp,					// identifier of the property
		int &			i,						// property value
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	// Set an integer or string property for this target
	EXPORTED BOOL SetTargetProp
	(
		HBLDTARGET		hTarg,					// handle to the target
		UINT			idProp,					// identifier of the property
		int				i,						// property value
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	EXPORTED BOOL SetTargetProp
	(
		HBLDTARGET		hTarg,					// handle to the target
		UINT			idProp,					// identifier of the property
		CString &		str,					// property value
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	EXPORTED void MakeTargPropsDefault
	(
		HBLDTARGET		hTarg,					// handle to the target
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	EXPORTED HFOLDER AddFolder
	(
		HFILESET hFileSet,
		const TCHAR * pchFolder,
		HBUILDER hBld = ACTIVE_BUILDER,
		HFOLDER hFolder = NO_FOLDER,
		const TCHAR * pchFilter = NULL
	);

	//
	// File API
	//

	// Create a file and add it to a fileset, 'hFileSet', with or without default settings, 'fSettings'.
	// Function may fail (HBLDFILE == NO_FILE).
	EXPORTED HBLDFILE AddFile
	(
		HFILESET		hFileSet,				// handle to the fileset
		const CPath *	ppathFile,				// file path
		int			fSettings = 0,// use default settings(NYI)
		HBUILDER		hBld = ACTIVE_BUILDER,	// builder that contains target? default='active builder'
		HFOLDER			hFolder = NO_FOLDER		// folder for the file
	);

	// Create and add multiple files to a fileset, 'hFileSet', as above.
	// PLEASE use this in preference to adding them singly as it is more efficient to 
	// batch them up.
	EXPORTED void AddMultiFiles
	(
		HFILESET			hFileSet,				// handle to the fileset
		const CPtrList *	plstpathFiles,			// pointer list of file paths (const CPath *'s)
		CPtrList *			plstHBldFiles,			// returned list of HBLDFILEs (some may be NO_FILE if error)
		int				fSettings = 0,// use default settings for this target type? (NYI)
		HBUILDER			hBld = ACTIVE_BUILDER,	// builder that contains target? default='active builder'
		HFOLDER				hFolder = NO_FOLDER		// group to add files to
	);

	// Add a dependency file to a fileset, 'hFileSet'.
	// ** Note, this doesn't actually add the file as such, it just informs
	// other parties, say SCC, that we have a new file that is a 'part of' the fileset.
	// Use ::AddFile if you want to *actually* be a part of the fileset.
	// Function may fail (return value == FALSE).
	EXPORTED BOOL AddDependencyFile
	(
		HFILESET		hFileSet,				// handle to the fileset
		const CPath *	ppathFile,				// dependency file path
		HBUILDER		hBld = ACTIVE_BUILDER,	// builder that contains target? default='active builder'
		HFOLDER			hFolder = NO_FOLDER		// folder for dependency
	);

	// Checks a filename to see if it is ok to add to a fileset. Returns TRUE if the file is not
	// in the fileset, FALSE otherwise. If the given file is in the fileset then the function "warps"
	// the given filename such that the new filename is not in the fileset, and will be ok to add to
	// it. The "warped" filename is returned in pathFile.
	EXPORTED BOOL CheckFile
	(
		HFILESET		hFileSet,				// handle to the fileset
		CPath &			pathFile,				// file path
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	// Delete a file 'hFile' from a fileset, 'hFileSet'
	EXPORTED BOOL DelFile
	(
		HBLDFILE 		hFile,					// handle to file
		HFILESET		hFileSet,				// handle to the fileset
		HBUILDER		hBld 	// builder that contains target? default='active builder'
	);

	// Gets a file from a given target. If a file corresponding to the file path is found in the fileset,
	// 'hFileset', then 'hFile' is set to be the file. Returns TRUE only if the file was found, otherwise FALSE.
	// If the hFile pointer is NULL, then we don't lookup the corresponding File Item to the ppathfile, but
	// just check if the file is in the target.
 	EXPORTED BOOL GetFile
	(
		const CPath *	ppathFile,				// file path
		HBLDFILE &		hFile,					// pointer to handle to file
		HFILESET		hFileSet,				// handle to the fileset
		HBUILDER		hBld,	// build that contains target? default='active builder'
    	BOOL			bSimple = FALSE         // if TRUE check includes deps and intermediate target files, default = FALSE,
	);

	// Add or subtract tool settings, pchSettings, to a file, 'hFile'.
	// Optional to specify the 'executable' name of the tool'.
	EXPORTED BOOL SetToolSettings
	(
		HBLDTARGET		hTarg,						// handle to the target that contains the file
		HBLDFILE		hFile,						// handle to the file
		const TCHAR * 	pchSettings,				// tool settings
		const TCHAR *	pchTool = (const TCHAR *)NULL,	// executable of the tool that 'owns' these settings, default='primary tool'NULL)
		BOOL			fAdd = TRUE,				// add or subtact? default=add
		BOOL			fClear = FALSE				// clear settings before add or subtract?
	);

	//
	// Property API
	//

	// Set the 'file included in build' property for a file, 'hFile', in a target, 'hTarg'.  
	__inline BOOL SetBuildExclude
	(
		HBLDTARGET		hTarg,						// handle to the target that contains the file
		HBLDFILE		hFile,						// handle to the file
		BOOL			fExclude = TRUE				// include this item in the build for the target? default=no
	)
		{return SetFileProp(hTarg, hFile, Prop_ExcludeFromBuild, (int)fExclude);}
	
	// Set an integer or string property for this file
	EXPORTED BOOL SetFileProp
	(
		HBLDTARGET		hTarg,					// handle to the target that contains the file
		HBLDFILE		hFile,					// handle to the file
		UINT			idProp,					// identifier of the property
		int				i						// property value
	);

	EXPORTED BOOL SetFileProp
	(
		HBLDTARGET		hTarg,					// handle to the target that contains the file
		HBLDFILE		hFile,					// handle to the file
		UINT			idProp,					// identifier of the property
		CString &		str						// property value
	);

	EXPORTED void MakeFilePropsDefault
	(
		HBLDTARGET		hTarg,					// handle to the target that contains the file
		HBLDFILE		hFile					// handle to the file
	);

	//
	// Build state etc. API
	//

	// Returns the state of the primary target.
	// Any files that are considered out of date,
	// eg. an .obj, .exe, or .dll, are returned in the 
	// path list 'plstPath'. Use FileState() to determine
	// the state of these.
	//
	// N.B. build system will alloc./dealloc the CPath *'s in 'plstPath'
	EXPORTED UINT TargetState
	(
		CObList *	plstPath = (CObList *)NULL,	// paths that are not current (== (CObList *)NULL if not req'd)
		const TCHAR * pchTarget = NULL,			// default is the primary target (usually .exe)
		HBLDTARGET	hTarg = NO_TARGET,			// handle to the target 
		HBUILDER	hBld = ACTIVE_BUILDER		// handle to the builder that contains this
	);

	EXPORTED UINT FileState
	(
		const CPath * pathFile				// path of the file to get state for
	);

	//
	// Dependency searching API
	// (eg. source dependencies such as #includes)
	//

	// Given a path to a source file, 'pathSrc', and a list of include directives, 'strlstIncs',
	// this function will return a list of paths, 'lstpath', that represent the 'resolved' (or
	// absolute) location of the file represented by each include directive.
	// The include path used is that for the platform 'strPlat', or thbe platform for the currently
	// selected target if 'strPlat' is empty.
	// Any standard includes, eg. #include <stdio.h>, will be ignored if 'fIgnStdIncs' is TRUE.
	// If per-file include directives, eg. compiler /I, exist for the 'pathSrc' then these will be used.
	//
	// Returns FALSE if the operation cannot be performed.
	EXPORTED BOOL ResolveIncludeDirectives
	(
		const CPath &		pathSrc,
		const CStringList &	strlstIncs, 
		CStringList &			lstPath,
		BOOL				fIgnStdIncs = TRUE,
		const CString &		strPlat = _TEXT("")
	);

 	// As for above but given a directory to initially search, 'dirBase'.
	EXPORTED BOOL ResolveIncludeDirectives
	(
		const CDir &		dirBase,
		const CStringList &	strlstIncs,
		CStringList &			lstPath,
		BOOL				fIgnStdIncs,
		const CString &		strPlat
	);

	// This is used by parser, so we can search a list of parent locations
	EXPORTED BOOL ResolveIncludeDirectives
	(
		const CObList & lstpathSrc,              //list of path as parent dir to search include 
		const CStringList & strlstIncs,
		CStringList & lstPath,
		HBLDTARGET hTarget
	);


	// Appends the full search path (directory list) to 'lstIncDirs', for includes for a file, 'pathSrc',
	// on a particular platform, 'strPlat'.
	// If 'strPlat' is empty, then the platform for the currently selected target is used.
	// FUTURE: Use per-file include paths, eg. as specified by /i for the linker
	//
	// Note: It is up to the caller of this function to deallocate the CDir *'s in 'lstIncDirs'.
	//
	// Returns FALSE if the operation cannot be performed.
	EXPORTED BOOL GetIncludePath
	(
		CObList &			lstIncDirs,
		const CString &		strPlat = _TEXT(""),
		const CPath *		ppathSrc = (const CPath *)NULL,
		const CString & strTool = _TEXT(""),
		HBUILDER hBld = ACTIVE_BUILDER
	);

	//Parser will call this function to give the pathSrc file's include list 
	EXPORTED void UpdateDependencyList
	(
		const CPath &		pathSrc,				// source file
		const CStringList &	strlstIncs,				// list of includes for this file
		HBLDTARGET			hTarg,					// handle to the target
		HBUILDER			hBld = ACTIVE_BUILDER	// handle to the builder that contains this
	);

	//
	// Enumeration and information API
	//
	// WARNING:
	// Currently these enumeration API can only enumerate single builder items at a time.
	// o file set enumertion
	// o file enumeration
	//

	EXPORTED void InitBuilderEnum();
	EXPORTED HBUILDER GetNextBuilder(CString & strBuilder, BOOL bOnlyLoaded = TRUE);
	EXPORTED void InitTargetEnum(HBUILDER hBld = ACTIVE_BUILDER);
	// Returns the name of the target as strTarget.
	EXPORTED HBLDTARGET GetNextTarget(CString & strTarget, HBUILDER hBld = ACTIVE_BUILDER);

	EXPORTED void InitProjectDepEnum(HFILESET hFileSet, HBUILDER hBld = ACTIVE_BUILDER);
	EXPORTED HPROJDEP GetNextProjectDep(HFILESET hFileSet, HBUILDER hBld = ACTIVE_BUILDER);
	EXPORTED DWORD GetDepth(HBLDTARGET);

	EXPORTED void InitProjectDepEnum(HFILESET hFileSet, HBUILDER hBld,CObList &lstDepSet, POSITION &posHDepSet );
	EXPORTED HPROJDEP GetNextProjectDep(HFILESET hFileSet, HBUILDER hBld,CObList &lstDepSet, POSITION &posHDepSet );

	EXPORTED void InitFileSetEnum(HBUILDER hBld = ACTIVE_BUILDER);
	EXPORTED HFILESET GetNextFileSet(HBUILDER hBld = ACTIVE_BUILDER);

	EXPORTED void InitFileEnum(HFILESET, UINT filter = FileEnum_RemoveDeps);
	// Returns the file registry handle as frh.
	EXPORTED HBLDFILE GetNextFile(FileRegHandle & frh, HFILESET);
	EXPORTED BOOL IsScanableFile(HBLDFILE hFile);

	// Get a string list of possible target names for a file set
	EXPORTED BOOL GetFileSetTargets
	(
		HFILESET		hFileSet,			// the file set to retrieve the target list for
		CStringList &	strlstTargs			// list of target names
	);

	// Get a string list of possible platform names for a target type (return *all* platforms when 'pchTarg' is NULL)
	EXPORTED const CStringList * GetAvailablePlatforms
	(
		const TCHAR *	pchTarg = (const TCHAR *)NULL, 	// UI or 'official' target name? default=retrieve all platforms
		BOOL			fUIDesc = TRUE					// return UI or 'official' names? default=UI
	);

	// Get a string list of possible target type names for a platform (across *all* installed platforms when 'pchPlat' is NULL)
	EXPORTED const CStringList * GetTargetTypeNames
	(
		const TCHAR *	pchPlat = (const TCHAR *)NULL,	// UI or 'official' platform name? default=retrieve across *all* platforms
		BOOL			fUIDesc = TRUE					// return UI or 'official' names? default=UI
	);

	EXPORTED HFILESET GetFileSet(HBUILDER hBld, HBLDTARGET hTarg);

	//
	// Get particular files of interest from the dependency graph of
	// a particular target and builder (default is active builder)
	// 'idFile' is the id of the filer we're interested in

	EXPORTED BOOL GetBuildFile
	(
		UINT idFile,
		TCHAR * szFileName, int cchFileBuffer,
		HBLDTARGET hTarg,
		HBUILDER hBld = ACTIVE_BUILDER
	);

	//
	// Builder file section support
	//
	// Provide a callback function that will be called when 
	// a buffer needs to be provided to be written or a 
	// buffer has been read and can be processed.
	//
	// Pls. note that sections are distinguished by name.
	EXPORTED BOOL RegisterSection(CBldrSection * pbldsect);
	EXPORTED BOOL DeregisterSection(const CBldrSection * pbldsect);

	// Enumeration
	EXPORTED void InitSectionEnum();
	EXPORTED CBldrSection * GetNextSection(CString & strSection);

	// Lookup
	EXPORTED CBldrSection * FindSection(const TCHAR * pchName, HBUILDER hBld = ACTIVE_BUILDER);

	// 
	// Builder fileset query support
	//

	// Resource files
	EXPORTED BOOL GetResourceFileList
	(
		CPtrList &		listRcPath,				// returned list of CPath *'s
		BOOL			fOnlyBuildable = FALSE,	// only buildable ones?
		HFILESET		hFileSet = NULL,		// handle to the fileset (FUTURE: only does active)
		HBUILDER		hBld = ACTIVE_BUILDER	// build that contains target? default='active builder'
	);

	EXPORTED BOOL GetResourceIncludePath
	(
		CPath *pResFile, 
		CString &strIncludes
	); 
	
	BOOL CBldSysIFace::OpenResource
	(
		const TCHAR *	strResource,				
		long 			lType,
		HBLDTARGET		hTarg,					// handle to the target 
		HBUILDER		hBld					// build that contains target? default='active builder'
	);

	// 
	// Mixed-language support
	//

#define CPlusPlus	0x0
#define FORTRAN		0x1
#define Java		0x2

	// Is the language currently installed?
	EXPORTED BOOL LanguageSupported(UINT idLang);

	//
	// Custom Build step support
	//

	// Macros supported
	//
	// $IntDir			- intermediate directory
	// $OutDir			- output directory
	// $WkspDir			- workspace directory
	// $ProjDir			- project directory
	// $TargetDir		- target directory
	// $InputDir		- input directory
	// $WkspBase		- workspace file basename
	// $Target			- full path of target
	// $TargetBase		- target file basename
	// $Input			- full path of input
	// $InputBase		- input file basename

	EXPORTED BOOL AssignCustomBuildStep
	(
		const TCHAR *	pchCommand,				// comma-seperated list of commands (can be macro-ized)
		const TCHAR *	pchOutput,				// comma-seperated list of output files (can be macro-ized)
		const TCHAR *	pchDescription,			// description (if NULL then default description)
		HBLDTARGET		hTarg,					// handle to the target 
		HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
		HBUILDER		hBld = ACTIVE_BUILDER	// build that contains target? default='active builder'
	);
	
	EXPORTED BOOL UnassignCustomBuildStep
	(
		HBLDTARGET		hTarg,					// handle to the target 
		HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
		HBUILDER		hBld = ACTIVE_BUILDER	// build that contains target? default='active builder'
	);

	//
	// Build view apis
	//
	
	// Get the path of the selected file in the build view. If we have a multi-selection then we
	// take the dominant. If no file is selected the return value is FALSE, TRUE otherwise.
	EXPORTED BOOL GetSelectedFile
	(
		CPath * path							// Selected file
	);

	// Get project sub directory for this hTarget
	EXPORTED BOOL GetProjectDir(HBLDTARGET hTarget, HBUILDER hBld, CString& str);

	// Get the workspace dir which is where .mak/.vcp resident
	EXPORTED BOOL GetWorkspaceDir(HBUILDER hBld, CString& str);

	//
	// Build system enabled?
	//
	// Dsabled if,
	// o no primary platform is installed

	EXPORTED BOOL BuildSystemEnabled();


	//
	// Builder object conversion
	//

	CProject * CnvHBuilder(HBUILDER hBld);
	CTargetItem * CnvHTarget(HBUILDER hBld, HBLDTARGET hTarg);
	CTargetItem * CnvHFileSet(HBUILDER hBld, HFILESET hFileSet);
	CFileItem * CnvHBldFile(HFILESET hFileSet, HBLDFILE hFile);
	CProjectDependency * CnvHProjDep(HFILESET hFileSet, HPROJDEP hProjDep);

	// Rename an existing target
	BOOL RenameTarget
	(
		const TCHAR *	pchTargFrom,					// name of this target to rename
		const TCHAR *	pcgTargTo						// new name for target
	);

	BOOL GetFlavourFromConfigName
	(
		const TCHAR *	pchConfigname,					// configuration name
		CString &		str							// flavour name (e.g, Debug, Release,..)
	);

	BOOL LoadAppWiz();
	
	// Returns whether a build is currently in progress.
	EXPORTED BOOL IsBuildInProgress();

	EXPORTED HRESULT DoSpawn(CStringList& lstCmd, LPCTSTR szDirInit, BOOL fClear, BOOL fASync, DWORD *pcErr, DWORD *pcWarn);

	// Returns the OLE Automation Project object associated with
	//  the given HBUILDER
	IBuildProject* GetAutoProject(HBUILDER hBld);

private:
	// Set tool settings on an item.
	BOOL SetToolSettingsI
	(
		HBLDTARGET		hTarg,						// handle to the target
		CProjItem *		pItem,						// pointer to the builder item
		const TCHAR * 	pchSettings,				// tool settings
		const TCHAR *	pchTool = (const TCHAR *)NULL,	// name of the tool that 'owns' these settings, default='primary tool'NULL)
		BOOL			fAdd = TRUE,				// add or subtact? default=add
		BOOL			fClear = FALSE				// clear settings before add or subtract?
	);

	// Map an external property number to an internal property number
	BOOL MapPropToPropI
	(
		UINT			idProp,						// external property number
		UINT &			idPropI						// internal (private) property number
	);

	// Get the config. record for a file, 'hFile', in a given target, 'hTarg'.
	ConfigurationRecord * GetConfigRecFromFileI
	(
		HBLDTARGET		hTarg,						// handle to the target
		HBLDFILE		hFile						// handle to the file to get the config. for
	);

	// Get the config. record for a target, 'hTarg'
	ConfigurationRecord * GetConfigRecFromTargetI
	(
		HBLDTARGET		hTarg,						// handle to the target
		HBUILDER		hBld = ACTIVE_BUILDER		// builder that contains target? default=('current'==ACTIVE_BUILDER) 
	);									


	// Core method for CBldSysIFace::ResolveIncludeDirectives() methods.
	BOOL ResolveIncludeDirectivesI
	(
		CString & strlstIncDirs,
		const CDir & dirBase,
		const CStringList & strlstIncs,
		CStringList & lstPath,
		BOOL fIgnStdIncs,
		const CString & strPlat,
		const CPath * pathSrc
	);

	// For mirrored case, we need to make sure dep gets updated
	// For C-syntax files, we just queue them up on the force update list, assuming parser will call us
	// the force update list will do update when we write to proj file if parser didn't do anything for us
	// For non-C-syntax files, we will just do the scan deps
	void PreserveDependencies
	(
		CTargetItem * pNewTarget,
		CProject * pProject
	);

	BOOL GetIncludePathI
	(
		CString &			strIncDirs,               //pass back includes in string form 
		const CString &		strPlat = _TEXT(""),
		const CPath *		ppathSrc = (const CPath *)NULL
	);

public:
	~CBldSysIFace();

	// Determine if the given file is pat of the fileset
	EXPORTED BOOL IsProjectFile
	(
		const CPath *	ppathFile,				// file path
		BOOL			bDepsAreProjFiles = FALSE,	//
		HBUILDER		hBld = ACTIVE_BUILDER	// builder that contains target? default='active builder'
	);

	EXPORTED BOOL GetBuilderToolset
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED CPath *GetTargetFileName
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED int GetTargetAttributes
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetRemoteTargetFileName
	(
		CString &		strTarg,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void SetRemoteTargetFileName
	(
		CString &		strTarg,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED CWnd *GetSlobWnd
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED const CPath *GetBrowserDatabaseName
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void UpdateBrowserDatabase
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetCallingProgramName
	(
		CString &		strProg,
		HBUILDER		hBld = ACTIVE_BUILDER
	);
	
	EXPORTED void SetCallingProgramName
	(
		CString &		strProg,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetProgramRunArguments
	(
		CString &		strArgs,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void SetProgramRunArguments
	(
		CString &		strArgs,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetWorkingDirectory
	(
		CString &		strDir,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL TargetIsCaller
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL GetPromptForDlls
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void SetPromptForDlls
	(
		BOOL			bPrompt,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void SetProjectState
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL GetClassWizAddedFiles
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void SetClassWizAddedFiles
	(
		BOOL			bAdded,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void ScanAllDependencies
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetVersionInfo
	(
		PROJECT_VERSION_INFO *pInfo,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL GetInitialExeForDebug
	(
		BOOL			bExecute,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL GetInitialRemoteTarget
	(
		BOOL			bBuild,
		BOOL			fAlways,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL UpdateRemoteTarget
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL DoTopLevelBuild
	(
		BOOL			bBuildAll,
		CStringList *	pConfigs,
		FlagsChangedAction	fca,
		BOOL			bVerbose,
		BOOL			bClearOutputWindow,
		HBUILDER		hBld = ACTIVE_BUILDER,
		BOOL			bRecurse = TRUE
	);

	EXPORTED void GetEnvironmentVariables
	(
		CEnvironmentVariableList *pEnvList,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL IsProfileEnabled
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	CPlatform *GetCurrentPlatform
	(
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	// Return the builder if there is one, or NO_BUILDER if there isn't
	EXPORTED HBUILDER GetBuilder(HBLDTARGET hTarg);
	EXPORTED HBUILDER GetBuilderFromFileSet(HFILESET hFileSet);

	EXPORTED HBUILDER DeactivateBuilder(HBUILDER hBld);
private:
	// delete the lists contained in pUnknownDepMap
	void DeleteUnknownDepMap(void);

private:
	CMapStringToPtr m_mapSections;					// our map of section names to section info.
	POSITION m_posSection;							// section enumeration 

	CStringList m_strlstTargets;					// used to maintain targets names added so far

	POSITION m_posHDepSet;							// target dep enum.
	CObList m_lstDepSet;							// FUTURE: make per-builder

	POSITION m_posHFileSet;							// file set enumeration
	CObList m_lstFileSet;							// FUTURE: make per-builder

	POSITION m_posHFile;							// file enumeration
	CObList m_lstFile;								// FUTURE: make per-fileset

	static CMapStringToOb *pUnknownDepMap;
	CMapPtrToPtr m_mapPrjTargets;
public:
	EXPORTED HBUILDER GetBuilderFromName(const TCHAR * 	pchBld);
	EXPORTED CString GetNameFromBuilder(HBUILDER hBld);
	EXPORTED BOOL SetActiveBuilder(	HBUILDER hBld );

// Java support
public:
	EXPORTED void GetJavaClassName
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaClassFileName
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaDebugUsing
	(
		ULONG*			pDebugUsing,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaBrowser
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaStandalone
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaStandaloneArgs
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaHTMLPage
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaClassPath
	(
		CString &		str,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED void GetJavaStandaloneDebug
	(
		ULONG*			pStandaloneDebug,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL GetInitialJavaInfoForDebug
	(
		BOOL			bExecute,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	// Delete the target which corresponds to a .exe project 
	EXPORTED void DeleteExeTarget
	(
		HBLDTARGET		hTarg					// target to delete
    );

	EXPORTED BOOL GetPreCompiledHeaderName
	(
		CString 		&strPch,
		HBUILDER		hBld = ACTIVE_BUILDER
	);

	EXPORTED BOOL SetUserDefinedDependencies
	(
		const TCHAR *	pchUserDeps,				// comma-seperated list of commands (can be macro-ized)
		HBLDTARGET		hTarg,					// handle to the target 
		HBLDFILE		hFile,					// handle to the file (if NO_FILE then custom build step for target)
		HBUILDER		hBld = ACTIVE_BUILDER	// build that contains target? default='active builder'
	);

	EXPORTED HRESULT GetPkgProject(
		HBUILDER builder,
		IPkgProject** outPkgProject
	);
	EXPORTED BOOL GetProjectGlyph(HBUILDER hBld, HFILESET hFileSet, CImageWell& imageWell, UINT * pnImage);
};									  

void SetWorkspaceDocDirty();

// our 'generic' build system components
// pls. note that the package for the 'generic' components is zero
#define idAddOnGeneric			0
#define szAddOnGeneric			(TCHAR *)NULL

#define BCID_Tool_RcCompiler	1
#define BCID_Tool_RcCompilerNT	2
#define BCID_Tool_Compiler		3
#define BCID_Tool_Linker		4
#define BCID_Tool_LinkerNT		5
#define BCID_Tool_BscMake		6
#define BCID_Tool_MkTypLib		7
#define BCID_Tool_Lib			8
#define BCID_Tool_CustomBuild	9
#define BCID_Tool_SpecialBuild	10

#define BCID_OptHdlr_Compiler		20
#define BCID_OptHdlr_Linker			21
#define BCID_OptHdlr_LinkerNT		22
#define BCID_OptHdlr_RcCompiler		23
#define BCID_OptHdlr_RcCompilerNT	24 
#define BCID_OptHdlr_BscMake		25
#define BCID_OptHdlr_Lib			26
#define BCID_OptHdlr_MkTypLib		27

// This is used as a base id for the external target
// type, and so we will use id's starting from this
// running to this id + the number of installed platforms.
// Note, we have a maximum of 100 external target types...
#define BCID_ProjType_ExternalTarget	100

// DO NOT PUT ANY BUILD ID'S AFTER THIS ONE
// This is used as a base id for any custom 
// components such as custom tools
#define BCID_Custom_Component			200
		
extern CBldSysIFace g_BldSysIFace;	// one 'n' only bld system interface

#endif // _INCLUDE_BLDSYSIFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldrfile.h ===
// CBuildFile
//
// Build file reading and writing.
//
// [matthewt]
//
				   
#ifndef _BUILD_FILE_H_
#define _BUILD_FILE_H_


extern const UINT nVersionNumber;
extern const UINT nLastCompatibleMakefile;
extern const UINT nLastCompatibleOPTFile;

// Computed value do not alter
extern const UINT nVersionMajor;
extern const UINT nVersionMinor;
extern const UINT nLastCompatibleMakefileMinor;


class CBuildFile 
{
public:
	CBuildFile();
	virtual ~CBuildFile();

	//
	// Top-level read/write
	//

	// read in the VC++ builder file
	BOOL ReadBuildFile(const CProject * pBuilder);

	// write out the VC++ builder file
	BOOL WriteBuildFile(const CProject * pBuilder);

	// 'NMake syntax' section read/write
	BOOL ReadSectionForNMake(const TCHAR * pchname);
	BOOL WriteSectionForNMake(CBldrSection * pbldsect);

	// 
	// 'NMake syntax' tools write
	// Write for 'pItem' in configs. 'pCfgArray' (default is use builder's) using the
	// 'nm' name mangler.
	//
	BOOL WriteToolForNMake(CProjItem * pItem, CNameMunger * nm, CPtrArray * pCfgArray = (CPtrArray *)NULL);

	// Current build tool mark to use
	static WORD m_wToolMarker;

	// FUTURE: move these two back to private: when all CProject read/write is moved here
	// current reader
	CMakFileReader * m_pmr;

	// current project write
	CMakFileWriter * m_ppw;

	// current makefile write
	CMakFileWriter * m_pmw;

	// current depfile write
	CMakFileWriter * m_pdw;

private:
	// current builder we are reading or writing
	CProject * m_pBuilder;

	// list of tools which were included in the read/write
	CPtrList m_lstToolsUsed;

	// Store the refs we add into the dep graph for project dependencies in this list
	// so we can remove them after writing the makefile
	CPtrList m_lstProjDepRefs;

	void AddProjDepsToGraph();
	void RemoveProjDepsFromGraph();
};

// our *single* instance of the build file reader and writer
extern BLD_IFACE CBuildFile g_buildfile;

#endif // _BUILD_FILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldrfile.cpp ===
// CBuildFile
//
// Build file reading and writing.
//
// [matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "bldrfile.h"	// local header
#include "exttarg.h"	// external targets
#include "version.h"    // for makefile versions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Convention: bump by 1 for OPT changes or simple makefile changes;
// Bump up to multiple of 10 for incompatible makefile format changes.

///////////////////////////////////////////////////////////////////////////////
// Makefile change history
// ALWAYS update this when bumping the OPT/Makefile version number
//
// Version number					Change							Made by
// 		30000						<reserved for release>			colint
// 		30001						Added targets					colint
//		30002						Fixed mirroring for targitems	colint
//		30003						Added file mapping				billjoy
//		30004						Removed old clw filename		colint
//      40000                       Break all old v3 makefiles      colint
//                                  (target name changes)
//      40001                       Fix INTDIR creation rule        colint
//                                  to use $(NULL), not nul


// Change these
static const UINT nMakeFileFormat = 00;	// internal makefile format number
const UINT nLastCompatibleMakefile = 40000;
const UINT nLastCompatibleOPTFile = 50009;

// Computed values do not alter
const UINT nVersionMajor = rmj;		// whole product major version
const UINT nVersionMinor = rmm;		// whole product minor version
const UINT nVersionNumber = (rmj * 10000) + (rmm * 100) + nMakeFileFormat;
const UINT nLastCompatibleMakefileMinor = ((nLastCompatibleMakefile % 10000) / 100);

#ifndef _SHIP
extern BOOL	g_bUseReleaseVersion;
#endif

// our instance of the build file reader and writer
CBuildFile AFX_DATA_EXPORT g_buildfile;

// builder file delimiters
static const TCHAR * pcBuilderMark = _TEXT("Project");
static const TCHAR * pcSectionMark = _TEXT("Section");
static const TCHAR * pcPropertyPrefix = _TEXT("PROP ");
static const TCHAR * pcEndToken = _TEXT("End");
static BOOL HasPerConfigDeps( CProjItem *pItem );

// defined in projitem.cpp
extern void CountkidsRecursively(CProjItem * pItem, int & rCount);

// helpers
int	CountInterestingChildren(CProjItem * pItem)
{
	int nCount = 1;
	if (pItem->GetContentList())
		for (POSITION pos = pItem->GetHeadPosition (); pos != (POSITION)NULL;)
		{
			CountkidsRecursively((CProjItem *) pItem->GetNext(pos), nCount);
		}

	return nCount;
}


// our tool marker
WORD CBuildFile::m_wToolMarker = 0;

CBuildFile::CBuildFile()
{
}

CBuildFile::~CBuildFile()
{
}

// write out the VC++ builder file
BOOL CBuildFile::WriteBuildFile(const CProject * pBuilder)
{
#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "msvcbldd.dll", "WriteBuildFile()", letypeBegin, 0);
#endif

	ASSERT(g_bExportMakefile || g_bWriteProject || g_bExportDeps);
	if (!g_bExportMakefile && !g_bExportDeps)
		g_bWriteProject = TRUE; // default

	// remember this builder
	m_pBuilder = (CProject *)pBuilder;

	// path of our builder
	const CPath * ppathBuilder = m_pBuilder->GetFilePath();
	ASSERT(ppathBuilder != (const CPath *)NULL);

	CPath pathPJ = *ppathBuilder;
	CPath pathEx = *ppathBuilder;
	CPath pathDep = *ppathBuilder;

	pathPJ.ChangeExtension(BUILDER_EXT);  // for M3
	if (pathPJ != *ppathBuilder)
	{
		// change it if it was something different (eg. .bld)
		m_pBuilder->SetFile(&pathPJ);
		SetWorkspaceDocDirty(); // make sure this gets written out
	}

	pathEx.ChangeExtension("mak");

#if 0	// switched this out to fix bug #873
	// REVIEW: For M1 (at least), make sure a .mak file exists on disk
	// so that we'll have a link to the associated internal project file
	// even after the format/extension changes in M2
	if (!pathEx.ExistsOnDisk())
		g_bExportMakefile = TRUE;
#endif

	// always write a .dep file if we're writing a .mak and it doesn't exist
	pathDep.ChangeExtension("dep");

#ifdef _DEBUG
	if (g_bExportMakefile && !pathDep.ExistsOnDisk())
		ASSERT(g_bExportDeps);
#endif

	// directory of our builder
	const CDir * pdirBuilder = (const CDir *)&m_pBuilder->GetWorkspaceDir();

	// no tool's used yet
	m_lstToolsUsed.RemoveAll();

	// incr. our marker
	m_wToolMarker++;

	// can we create the builder file?
	// o CountInteresingChildren() is used to provide the progression feedback range

 	// file exceptions can occur during builder file write
 	CFileException e;

	// makefile writer
	CMakFileWriter mw, pw, dw;

	int ProjSize = CountInterestingChildren(m_pBuilder);

	if (g_bWriteProject)
	{
		if (!pw.Create(pathPJ, &e, ProjSize))
		{
			CString str;
			MsgBox(Error, MsgText(str, pathPJ, IDS_PROJ_OPEN_FOR_WRITE_FAIL, &e));
			return FALSE;	// couldn't create builder file
		}
	}

	if (g_bExportMakefile)
	{
		UINT attrib = MakRW_Default | MakRW_ShowStatus | MakW_Makefile;
		if (g_bWriteProject)
			attrib = attrib & ~MakRW_ShowStatus;
		if (!mw.Create(pathEx, &e, ProjSize, attrib))
		{
			CString str;
			MsgBox(Error, MsgText(str, pathEx, IDS_PROJ_OPEN_FOR_WRITE_FAIL, &e));
			if (g_bWriteProject)
			{
				// still write the .dsp file even if export fails
				g_bExportMakefile = FALSE;
			}
			else
			{
				return FALSE;	// couldn't create makefile
			}
		}
	}
	if (g_bExportDeps)
	{
		UINT attrib = MakRW_Default | MakRW_ShowStatus | MakW_Depfile;
		if (g_bWriteProject || g_bExportMakefile)
			attrib = attrib & ~MakRW_ShowStatus;

		// REVIEW: ProjSize may not be meaningful/correct in this case:
		if (!dw.Create(pathDep, &e, ProjSize, attrib))
		{
			CString str;
			MsgBox(Error, MsgText(str, pathDep, IDS_PROJ_OPEN_FOR_WRITE_FAIL, &e));
			if (g_bWriteProject || g_bExportMakefile)
			{
				// still write the .dsp/.mak file even if dep export fails
				g_bExportDeps = FALSE;
				g_ScannerCache.EndCache();
			}
			else
			{
				return FALSE;	// couldn't create deps file
			}
		}
	}

	//Update deps if this is not a new project and there is any to be updated.
	if (g_bExportDeps)
	{
		if (!m_pBuilder->m_bProjMarkedForSave || m_pBuilder->m_bProjExtConverted)
			UpdateBeforeWriteOutMakeFile();
	}

	// Add any necessary dependencies for project dependencies to the dep graph
	AddProjDepsToGraph();

	BOOL bRetval = TRUE;

	// remember this writer
	m_ppw = &pw;
	m_pmw = &mw;
	m_pdw = &dw;

	// reset global file error
	SetFileError(CFileException::none);

	// clear cache used by MakeQuotedString()
	ClearMQSCache();

	// no properties can change from here on out
	ConfigCacheEnabler EnableCaching;

	// generic buffer
	CString str;

	// show wait cursor while save is in progress...
	CWaitCursor wc;

	TRY
	{
		//
		// write signature strings
		//

		if (g_bWriteProject)
		{
			TCHAR buf[33];
			CString str1;
			// first write workspace project signature
			VERIFY (str.LoadString (IDS_DSPROJ_SIG_STRING));
			VERIFY (str1.LoadString(IDS_DSPROJ_NAME));
			ConfigurationRecord * pcr = m_pBuilder->GetActiveConfig();
			CString strProjectName;
			if(pcr)
				pcr->GetProjectName(strProjectName);
			str1 += strProjectName;
			str1 += _T("\"");
			str += str1;
			VERIFY (str1.LoadString (IDS_PACKAGE_OWNER));
			_stprintf(buf, _T("%d>"), PACKAGE_VPROJ);
			str += str1;
			str += buf;
			pw.WriteComment(str);

			VERIFY (str.LoadString (IDS_BUILDPRJ_SIG_STRING));
	#ifndef _SHIP
			if (!g_bUseReleaseVersion)
				_ultoa (nVersionNumber, buf, 10);
			else
	#endif
			_stprintf(buf, _T("%x.%02d"), nVersionMajor, nVersionMinor);

			str += buf;
			pw.WriteComment(str);
		}

		if (g_bExportMakefile)
		{
            VERIFY (str.LoadString (IDS_EXPORT_SIG_STRING));
			str += pathPJ.GetFileName();
			mw.WriteComment(str);
		}

		if (g_bExportDeps)
		{
            VERIFY (str.LoadString (IDS_EXPORTDEPS_SIG_STRING));
			str += pathEx.GetFileName();
			dw.WriteComment(str);
			dw.EndLine();
		}

		//
		// write out version information
		//

#ifndef _SHIP
		if (!g_bUseReleaseVersion)
		{
			// Record VPROJ version number for tracking purposes
#ifdef _DEBUG
			str = "MSVCBLDD";
#else
			str = "MSVCBLD";
#endif
			{	// calculate and write VPROJ version number
				TCHAR	rgchModName[_MAX_PATH];
				DWORD	dwHandle, dwVerInfoSize;
				unsigned int dwValueSize;
				VOID *	pvVerInfo;
				VOID *	pvValue;
				if ((::GetModuleFileName(GetModuleHandle((LPCTSTR)str), rgchModName, sizeof(rgchModName) / sizeof(TCHAR)))
				 && ((dwVerInfoSize = ::GetFileVersionInfoSize(rgchModName, &dwHandle)) != 0))
				{
					pvVerInfo = new TCHAR[dwVerInfoSize];
					if ((::GetFileVersionInfo(rgchModName, dwHandle, dwVerInfoSize, pvVerInfo))
						&& (::VerQueryValue(pvVerInfo,"\\StringFileInfo\\040904E4\\FileVersion",&pvValue,&dwValueSize)))
					{
						str = str + _T(": version ") + (TCHAR *)pvValue;

						if (g_bWriteProject)
							pw.WriteComment ( str );
						if (g_bExportMakefile)
							mw.WriteComment ( str );
						if (g_bExportDeps)
							dw.WriteComment ( str );
					}
					delete [] pvVerInfo;
				}
			}
		}
#endif // !_SHIP

		if (g_bWriteProject)
		{
			//
			// write out 'do not edit' comment
			//
			VERIFY(str.LoadString(IDS_DO_NOT_EDIT_MAKEFILE));
			pw.WriteComment(str);

			pw.EndLine();
		}

		// write out the configuration header
		// o list of targets
		
		if (g_bWriteProject)
		{
			if (!m_pBuilder->WriteConfigurationHeader(*m_ppw))
				AfxThrowFileException(CFileException::generic);
		}

		if (g_bExportMakefile)
		{
			if (!m_pBuilder->WriteConfigurationHeader(*m_pmw))
				AfxThrowFileException(CFileException::generic);
		}

		//
		// write out the contents of the builder, eg. files, target referecences etc.
		//

		
		if (g_bWriteProject)
		{
			// write project open comment
			// pw.WriteSeperatorString();
			pw.WriteCommentEx("Begin %s", pcBuilderMark);

			// FUTURE: move this into the 'Builder Settings' section in the builder file

			// construct special 'PROP <name> <value>' line
#if 0
			CString strOutput;
			if (m_pBuilder->GetStrProp(P_ProjSccProjName, strOutput) == valid && !strOutput.IsEmpty())
			{
				strOutput = pcPropertyPrefix + (_T("Source_Control_Project \"") + strOutput + _T('\"'));
				pw.WriteComment(strOutput);
			}

			if (m_pBuilder->GetStrProp(P_ProjSccProjAux, strOutput) == valid && !strOutput.IsEmpty())
			{
				strOutput = pcPropertyPrefix + (_T("Source_Control_ProjAux \"") + strOutput + _T('\"'));
				pw.WriteComment(strOutput);
			}
#endif
		}

		CNameMunger nm;

		// write builder level tools section
		if (!WriteToolForNMake(m_pBuilder, &nm))
			AfxThrowFileException(CFileException::generic);

		// write each of the items the builder contains (not recursive)
		for (POSITION pos = m_pBuilder->GetHeadPosition(); pos != (POSITION)NULL;)
		{
			CProjItem * pProjItem = (CProjItem *)m_pBuilder->GetNext(pos);

			if (!pProjItem->WriteToMakeFile(pw, mw, *pdirBuilder, nm))
				AfxThrowFileException(CFileException::generic);
		}

		if (g_bWriteProject)
		{
			// write builder closing comment
			pw.WriteCommentEx("%s %s", pcEndToken, pcBuilderMark);
			// pw.WriteSeperatorString();
		}

		if (g_bWriteProject)
		{
			// 
			// write out our sections
			//
			CBldrSection * pbldsect; CString strName;
			g_BldSysIFace.InitSectionEnum();
			while ((pbldsect = g_BldSysIFace.GetNextSection(strName)) != (CBldrSection *)NULL)
			{
				if (m_pBuilder == (CProject *)pbldsect->m_hBld)  // only do this if it is our builder
				{
				if (!WriteSectionForNMake(pbldsect))
 					AfxThrowFileException(CFileException::generic);
				}
			}
		}

		if (g_bWriteProject)
		{
			// can we close the builder file?
			bRetval = pw.Close();
		}

		if (g_bExportMakefile)
		{
			// can we close the builder file?
			bRetval = mw.Close() && bRetval;
		}

		if (g_bExportDeps)
		{
			// can we close the builder file?
			bRetval = dw.Close() && bRetval;
		}
		if (!bRetval)
			AfxThrowFileException(CFileException::generic);
	}
	CATCH(CException, e)
	{
		// safely close the writer (if not already closed)
		if (bRetval)	// don't Abort() if Close() failed
		{
			
			if (g_bWriteProject)
			{
				pw.Abort();
			}
			if (g_bExportMakefile)
			{
				mw.Abort();
			}
			if (g_bExportDeps)
			{
				dw.Abort();
			}
			bRetval = FALSE;
		}

		str.Empty ();

		if ((e->IsKindOf(RUNTIME_CLASS(CFileException))) && (((CFileException *)e)->m_cause != CFileException::none))
		{
			if (GetFileError() != CFileException::none && ((CFileException *)e)->m_cause == CFileException::generic)
				((CFileException *)e)->m_cause = GetFileError();

			// REVIEW: not quite right
			// we can show the type of exception
			if (g_bWriteProject)
				MsgBox(Error, MsgText(str, pathPJ, IDS_PROJ_SAVING_FAILED, (CFileException *)e));
			else
				MsgBox(Error, MsgText(str, pathEx, IDS_PROJ_SAVING_FAILED, (CFileException *)e));
		}
		else
		{
			if (GetFileError()==CFileException::none)
				SetFileError(CFileException::generic);

			// can't show the type of exception
			MsgBox(Error, IDS_PROJ_SAVING_FAILED);
		}
	}
	END_CATCH

	// Remove proj deps from the graph
	RemoveProjDepsFromGraph();

	// for all tool's that we used tell them we've finished
	// writing the builder
	POSITION pos = m_lstToolsUsed.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CBuildTool * pTool = (CBuildTool *)m_lstToolsUsed.GetNext(pos);
		pTool->EndProjectWrite(m_pBuilder, *(CDir *)pdirBuilder);
	}

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "msvcbldd.dll", "WriteBuildFile()", letypeEnd, 0);
#endif

	// null out the writer
	m_ppw = (CMakFileWriter *)NULL;
	m_pmw = (CMakFileWriter *)NULL;
	m_pdw = (CMakFileWriter *)NULL;

	return bRetval;
}

// 'NMake syntax' section write
BOOL CBuildFile::WriteSectionForNMake(CBldrSection * pbldsect)
{
	ASSERT(g_bWriteProject);

	// ask for the section data?
	if (pbldsect->m_pfn)
		if (!(*pbldsect->m_pfn)(pbldsect, SECT_WRITE))
			return FALSE;	// couldn't

 	// file exceptions can occur during builder file write
 	CFileException e;
	BOOL bRetval;

	TRY
	{
		TCHAR * pch = pbldsect->m_pch;
		UINT cch = pbldsect->m_cch;

		// anything to write?
		if (pch != (TCHAR *)NULL && *pch != _T('\0'))
		{
			// write section header
			// m_ppw->WriteSeperatorString();
			m_ppw->WriteCommentEx("%s %s", pcSectionMark, (const TCHAR *)pbldsect->m_strName);

			// write out section
			while (*pch != _T('\0'))
			{
				// write the first line
				m_ppw->WriteCommentEx("\t%s", pch);

				pch += _tcslen(pch);	// skip line
				pch++;					// skip terminator
			}

			// terminate section
			m_ppw->WriteCommentEx("%s %s", pcEndToken, pcSectionMark);
			// m_ppw->WriteSeperatorString();
		}

		bRetval = TRUE;		// success
	}
	CATCH(CException, e)
	{
		bRetval = FALSE;	// failure
	}
	END_CATCH

	// end section write?
	if (pbldsect->m_pfn)
		(void) (*pbldsect->m_pfn)(pbldsect, SECT_END);

	return bRetval;
}

// tool info. struct
typedef struct
{
	CBuildTool *	pTool;
	CActionSlob *	pAction;
	int				iAreas;
} S_ToolRec;

// quick 'n' dirty CFileRegEntry set compare
// used below for comparing dependency file sets
//
// only return TRUE
// if the sets contain exactly the same CFileRegEntrys in the same order
BOOL QuickNDirtyRegSetCompare(CFileRegSet * pregSet, CFileRegSet * pregSet2)
{
	// compare the two sets
#ifndef REFCOUNT_WORK
	const CPtrList * plst = pregSet->GetContent();
	const CPtrList * plst2 = pregSet2->GetContent();
#else
	const CPtrList * plst = &pregSet->m_Contents;
	const CPtrList * plst2 = &pregSet2->m_Contents;
#endif
	if (plst->GetCount() != plst2->GetCount())
		return FALSE;	// not equal

	POSITION pos = plst->GetHeadPosition();
	POSITION pos2 = plst2->GetHeadPosition();
	while (pos != (POSITION)NULL)
		if (plst->GetNext(pos) != plst2->GetNext(pos2))
			return FALSE;	// not equal

	return TRUE;	// equal!
}

int TRcompare( const void *arg1, const void *arg2 )
{
	/* Compare all of both strings: */
	CBuildTool *pTool1 = (*( S_ToolRec ** )arg1)->pTool;
	CBuildTool *pTool2 = (*( S_ToolRec ** )arg2)->pTool;

	return _stricmp( (const TCHAR *)pTool1->m_strToolPrefix,(const TCHAR *)pTool2->m_strToolPrefix  );
}


BOOL CBuildFile::WriteToolForNMake(CProjItem * pItem, CNameMunger * pnm, CPtrArray * pCfgArray /* = NULL */)
{
	// our builder directory
	const CDir * pdirBuilder = (const CDir *)&m_pBuilder->GetWorkspaceDir();

	// are we at the builder-level?
	BOOL fBldrLevel = pItem == m_pBuilder;
	BOOL fUseProjConfig = TRUE;

	// use the builder's configs?
	if (pCfgArray == (CPtrArray *)NULL)
	{
		CTargetItem *pTarget = pItem->GetTarget();
		if (!fBldrLevel && pTarget != NULL && pTarget != pItem)
		{
			fUseProjConfig = FALSE;
			pCfgArray = (CPtrArray *)pTarget->GetConfigArray();
		}
		else
			pCfgArray = (CPtrArray *)m_pBuilder->GetConfigArray();
	}

	// what tools' across *all* configs. care about this item?
	POSITION pos;
	CMapPtrToPtr mapToolToAction;
	S_ToolRec *pListToolRecs[1024];		// note that this is a rediculously large number. Reality will be closer to 4 or 5 max but why take chances
	int nLastRec=0;
	CProjTempConfigChange projTempConfigChange(m_pBuilder);
	int i;

	for ( i = pCfgArray->GetSize(); i > 0; i--)
	{
		// get the actions, transfer to tool's list
		ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(i-1);

		if (fUseProjConfig || pcr->IsValid())
		{
			// get the actions for the item in this builder config.
			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
			CActionSlobList * pActions = pItem->GetActiveConfig()->GetActionList();


			pos = pActions->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);

				// if not already in tool's list then add
				S_ToolRec * pToolRec;
				if (!mapToolToAction.Lookup(pAction->m_pTool, (void * &)pToolRec))
				{
					pToolRec = new S_ToolRec;
					pToolRec->pTool = pAction->m_pTool;
					pToolRec->pAction = pAction;

					mapToolToAction.SetAt(pAction->m_pTool, pToolRec);
					pListToolRecs[nLastRec] = pToolRec;
					nLastRec++;
					ASSERT(nLastRec<1024);

					// call begin builder write if not done already
					if (pAction->m_pTool->m_wBuildFileMark != m_wToolMarker)
					{
						pAction->m_pTool->m_wBuildFileMark = m_wToolMarker;
						pAction->m_pTool->BeginProjectWrite(m_pBuilder, *(CDir *)pdirBuilder);

						// note this
						m_lstToolsUsed.AddTail(pAction->m_pTool);
					}
				}
			}
		}
	}

#if 1
	// now go back and add psedo-record for any unused tools at the project level
	// if not already in tool's list then add
	if (fBldrLevel)
	{
		CProjType * pLastType = NULL;
		for ( i = pCfgArray->GetSize(); i > 0; i--)
		{
			// get the actions, transfer to tool's list
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(i-1);
			ASSERT(fUseProjConfig);
			// if (fUseProjConfig || pcr->IsValid())
			{
				// get the actions for the item in this builder config.
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
				CBuildTool * pTool;
				S_ToolRec * pToolRec;
				CProjType * pProjType = m_pBuilder->GetProjType();
				if ((pProjType == NULL) || (pProjType == pLastType))
					continue; // been there, done that	
				pLastType = pProjType;	// remember this for next time
  				CPtrList * pToolsList = pProjType->GetToolsList();
				POSITION pos = pToolsList->GetHeadPosition();
				while (pos != NULL)
				{
					pTool = (CBuildTool *)pToolsList->GetNext(pos);
					if (!mapToolToAction.Lookup(pTool, (void * &)pToolRec))
					{
						pToolRec = new S_ToolRec;
						pToolRec->pTool = pTool;
						pToolRec->pAction = NULL;  // not handled!

						mapToolToAction.SetAt(pTool, pToolRec);
						pListToolRecs[nLastRec] = pToolRec;
						nLastRec++;
						ASSERT(nLastRec<1024);

						// call begin builder write if not done already
						if (pTool->m_wBuildFileMark != m_wToolMarker)
						{
							pTool->m_wBuildFileMark = m_wToolMarker;
							pTool->BeginProjectWrite(m_pBuilder, *(CDir *)pdirBuilder);

							// note this
							m_lstToolsUsed.AddTail(pTool);
						}
					}
				}
			}
		}
	}
#endif

	// Get a predictable order
	qsort(pListToolRecs,nLastRec,sizeof(S_ToolRec *),TRcompare);

	//
	// create our info. tool rec. list
	//

	// per-config. targets?
	BOOL fPerConfigTarg = FALSE;

	// union of our tool areas 
	int iUnionAreas = NoAreas;

	// get each of our tools
	for( i=0; i<nLastRec; i++)
	{
		// CBuildTool * pTool; S_ToolRec * pToolRec;
		// mapToolToAction.GetNextAssoc(pos, (void * &)pTool, (void * &)pToolRec);
		S_ToolRec * pToolRec = pListToolRecs[i];
		CBuildTool *pTool = pListToolRecs[i]->pTool;

		// FUTURE: improve BeginWritingSession()
		int iAreas = pToolRec->iAreas = pTool->BeginWritingSession(pItem, pToolRec->pAction, m_ppw, m_pmw, (CDir *)pdirBuilder, pnm);

		// if this is a target level tool and we are writing for the project
		// then check for recognise per-config targets at the builder-level
		if (pTool->m_fTargetTool && fBldrLevel && !fPerConfigTarg && iAreas != NoAreas)
			// we always assume per-config. targets
			fPerConfigTarg = TRUE;

		CRuntimeClass* prt = pTool->GetRuntimeClass();
		if (_tcscmp(prt->m_lpszClassName, "CCCompilerJavaTool") == 0)
			fPerConfigTarg = TRUE;

		// perform the union of the areas
		iUnionAreas |= iAreas;
	}

	// make sure we do per-config. writing if we have per-config. 'non-tool' props.
	if ((iUnionAreas & (PerConfig|PerConfigInt)) == 0)
		if (pItem->HasMakefileProperties())
			iUnionAreas |= PerConfigInt;

	if (g_bWriteProject)
	{
		// write out the per-item props.
		pItem->WritePerItemProperties(*m_ppw);
	}

	// dependencies line per-config.?
	// if per-config. targ. then yes!
	BOOL fPerConfigToolDep = fPerConfigTarg;

	if( pItem->IsKindOf(RUNTIME_CLASS(CFileItem)) && HasPerConfigDeps( pItem ) ) 
		fPerConfigToolDep = TRUE;

	UINT nMRDeps = 0;
	BOOL fPerConfigToolDepInt = FALSE;

	if (!fPerConfigToolDep)
	{
		
		CProjTempConfigChange projTempConfigChange(m_pBuilder);
		ConfigurationRecord * pcrComp = (ConfigurationRecord *)NULL;
		for ( i = pCfgArray->GetSize(); i > 0; i--)
		{
			ConfigurationRecord * pcrNext = (ConfigurationRecord *)pCfgArray->GetAt(i-1);

			if (fUseProjConfig || pcrNext->IsValid())
			{
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcrNext->m_pBaseRecord);

				ConfigurationRecord * pcr = (ConfigurationRecord *)pItem->GetActiveConfig();
   				CActionSlobList * pActions = pcr->GetActionList();
 				if (pActions->GetCount() > 1)
				{
						fPerConfigToolDep = fPerConfigToolDepInt = TRUE;
						break;	// per-config tool dependencies
				}

				if (pActions->GetCount() == 0)
				{
						continue; // ignore this one (no tool)
				}

  				CActionSlob * pAction = (CActionSlob *)pActions->GetHead();
 
				if (pAction->m_pTool->HasDependencies(pcr))
				{
					nMRDeps++;
					if (!g_bExportDeps || !m_pBuilder->m_bProj_PerConfigDeps)
						continue;		
				}
				else if (nMRDeps > 0) // inconsistent MRDeps usage
				{
					fPerConfigToolDepInt = TRUE;
					if (fPerConfigToolDep || !g_bExportMakefile)
	 					break;	// per-config tool depedencies
				}
				else if (pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
				{
					fPerConfigToolDep = TRUE;
				}
				else
				{
				
				}

				// have a config. to compare against?
				if ((pcrComp != (ConfigurationRecord *)NULL)
					 && ((pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))) || (m_pBuilder->m_bProj_PerConfigDeps))
					)
				{
					// get our per-item action list
					CActionSlobList * pActionsComp = pcrComp->GetActionList();

					CActionSlob * pActionComp = (CActionSlob *)pActionsComp->GetHead();

					// compare dependencies
					if (!QuickNDirtyRegSetCompare(pAction->GetScannedDep(), pActionComp->GetScannedDep()) ||
						!QuickNDirtyRegSetCompare(pAction->GetMissingDep(), pActionComp->GetMissingDep()) ||
						(pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))&&!QuickNDirtyRegSetCompare(pAction->GetSourceDep(), pActionComp->GetSourceDep()))
					   )
					{
						fPerConfigToolDep = TRUE;
						if (nMRDeps==0)
							fPerConfigToolDepInt = TRUE;

						if (fPerConfigToolDepInt || !g_bWriteProject)
							break;	// per-config tool depedencies
					}
				}

				// compare config.?
				pcrComp = pcr;
			}
		}
		
	}

	// if per-config. tool dep.
#if 0
	if (fPerConfigToolDep)
	{
		iUnionAreas |= PerConfigExt;
	}
#endif
	if (fPerConfigToolDepInt)
	{			
		iUnionAreas |= PerConfigInt;
	}

	if (fBldrLevel)
	{
		// look at all the projtypes in use and check for external target types
		CProjType * pProjType;
		BOOL fHasExternalTargets = FALSE;

		for ( i = pCfgArray->GetSize(); i > 0; i--)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(i-1);
			if (g_prjcompmgr.LookupProjTypeByName(pcr->GetOriginalTypeName(), pProjType))
			{
				// do we have an external target type in use?
				// if so we cannot write the tool dep. line outside of the #ifdef blocks
				if (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
				{
					fHasExternalTargets = TRUE;
					break;
				}
			}
		}

		if (fHasExternalTargets)
			fPerConfigToolDep = TRUE;
	}

	BOOL fRetval = TRUE;

	TRY
	{
		// can we write out the tool dep. line outside of the config. block?
		if (!fPerConfigToolDep)
		{
			CProjTempConfigChange projTempConfigChange(m_pBuilder);
// FAST_EXPORT
			int pcrIndex = m_pBuilder->GetScannedConfigIndex();
			if ((!m_pBuilder->m_bProj_PerConfigDeps) && pcrIndex >= 0 && pcrIndex < pCfgArray->GetSize())
			{
				ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(pcrIndex);
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
			}
			else
// FAST_EXPORT
			if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
			{
				// need to ensure we use a valid config for deps
				BOOL bExcluded;
				ConfigurationRecord * pcrBest = (ConfigurationRecord *)NULL;
				ConfigurationRecord * pcrItem;
				ConfigurationRecord * pcr;
				int i, nSize = pCfgArray->GetSize();
				for ( i = 0; i < nSize; i++)
				{
					pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
					if (pcr->IsSupported()) // REVIEW: probably not necessary
					{
						m_pBuilder->ForceConfigActive((ConfigurationRecord *)pcr->m_pBaseRecord);
						if (pItem->GetIntProp(P_ItemExcludedFromBuild, bExcluded) != valid)
							bExcluded = FALSE;
						pcrItem = pItem->GetActiveConfig();
						ASSERT(pcr->m_pBaseRecord == pcrItem->m_pBaseRecord);
						m_pBuilder->ForceConfigActive();

						if (!bExcluded && (pcrItem->GetBuildTool() != NULL))
						{
							pcrBest = pcr;
							break;
						}
					}
				}
				if (pcrBest != NULL)
					projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcrBest->m_pBaseRecord);
			}

			if (g_bExportDeps)
			{
				// write out any dependencies
				if (!pItem->WriteMakeFileDependencies(*m_pdw, *pnm, FALSE))
					AfxThrowFileException(CFileException::generic);
			}

			if (g_bExportMakefile)
			{
#if 0				// now written as part of custom build rule
				// write out any dependencies, if necessary
				// only used for custom build rules
				if (!pItem->WriteMakeFileDependencies(*m_pmw, *pnm, FALSE))
					AfxThrowFileException(CFileException::generic);
#endif

				// write output directory macros, tool dep. line, and output directory build rule,
				if ((!pItem->WriteOutDirMacro(*m_pmw)) || (fBldrLevel && !m_pBuilder->WriteMasterDepsLine(*m_pmw, *pdirBuilder)) || (!pItem->WriteOutDirDescBlk(*m_pmw)))
				{
					AfxThrowFileException(CFileException::generic);
				}
			}

			if (g_bWriteProject)
			{
				// write out any dependencies, if necessary
				// not required if MRE deps supported
				if (!pItem->WriteMakeFileDependencies(*m_ppw, *pnm, FALSE))
					AfxThrowFileException(CFileException::generic);

				// write tool dep. line
				// if (fBldrLevel && !m_pBuilder->WriteMasterDepsLine(*m_ppw, *pdirBuilder))
				// 	AfxThrowFileException(CFileException::generic);
			}
		}

		// write headers?
		if (iUnionAreas & Header)
		{
			pos = mapToolToAction.GetStartPosition();
			for( i=0; i<nLastRec; i++)
			{
				S_ToolRec * pToolRec = pListToolRecs[i];
				CBuildTool *pTool = pListToolRecs[i]->pTool;

				// write header here if tool used by all configs
				if ((pToolRec->iAreas & (Header | BuildRule)) == (Header | BuildRule))
					pToolRec->pTool->WriteHeaderSection(pToolRec->pAction);
			}
		}

   		int nMaxIndex = iUnionAreas & (PerConfig|PerConfigInt|PerConfigExt) ? pCfgArray->GetSize() - 1 : 0;
		BOOL bFirstCfg = TRUE;

		// 0 = never write; 1 = write once; n = write per config
		int nWriteProject = 0, nExportMakefile = 0, nExportDeps = 0;
		if (g_bWriteProject)
		{
			nWriteProject = 1; 
		  	if ((iUnionAreas & (PerConfig|PerConfigInt))!=0)
				nWriteProject += nMaxIndex;
		}

		// REVIEW: need to fix logic for makefiles vs. deps
		if (g_bExportMakefile)
		{
			nExportMakefile = 1; 
		  	if ((iUnionAreas & (PerConfig|PerConfigExt))!=0)
				nExportMakefile += nMaxIndex;
		}
		if (g_bExportDeps)
		{
			nExportDeps = 1; 
			// REVIEW: can't have deps at BldrLevel
		  	if (fPerConfigToolDep && !fBldrLevel)
				nExportDeps += nMaxIndex;
		}

		CProjTempConfigChange projTempConfigChange(m_pBuilder);

		for (int k = 0; k <= nMaxIndex ; k++)
		{
			// set each configuration active in turn
			ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(k);
			if (fUseProjConfig || pcr->IsValid())
			{
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

				// do this?
				if (!pItem->IsKindOf(RUNTIME_CLASS(CProject)) && 
					!pItem->GetTarget()->GetActiveConfig()->IsValid())
				{
					continue;
				}

				if (nMaxIndex)
				{
					// write IF/ELSEIF if writing multiple configs
					pItem->m_cp = bFirstCfg ? CProjItem::FirstConfig : CProjItem::MiddleConfig;
					if (nWriteProject > 1)
						pItem->WriteConfigurationIfDef(*m_ppw, pItem->GetActiveConfig());
					if (nExportMakefile > 1)
						pItem->WriteConfigurationIfDef(*m_pmw, pItem->GetActiveConfig());
					if (nExportDeps > 1)
						pItem->WriteConfigurationIfDef(*m_pdw, pItem->GetActiveConfig());
				}

				// write out properties stored in comments
				if (nWriteProject > k)
				{
					if (!pItem->WriteMakeFileProperties(*m_ppw))
						AfxThrowFileException(CFileException::generic);
				}

				if (fPerConfigToolDep)
				{
					if (nWriteProject > k)
					{
						// write out any dependencies, if necessary
						// not required if MRE deps supported
						if (!pItem->WriteMakeFileDependencies(*m_ppw, *pnm, TRUE))
							AfxThrowFileException(CFileException::generic);
					}

					if (nExportMakefile > k)
					{
#if 0					// now written as part of custom build rule
						// write out any dependencies, if necessary
						// only used for custom build rules
						if (!pItem->WriteMakeFileDependencies(*m_pmw, *pnm, TRUE))
							AfxThrowFileException(CFileException::generic);
#endif
						// write output directory macros, tool dep. line, and output directory build rule,
						if (!pItem->WriteOutDirMacro(*m_pmw) ||
							(fBldrLevel && !m_pBuilder->WriteMasterDepsLine(*m_pmw, *pdirBuilder)) ||
							!pItem->WriteOutDirDescBlk(*m_pmw)
						   )
							AfxThrowFileException(CFileException::generic);
					}
					if (nExportDeps > k)
					{
						// write out any dependencies
						if (!pItem->WriteMakeFileDependencies(*m_pdw, *pnm, TRUE))
							AfxThrowFileException(CFileException::generic);
					}
				}

				bFirstCfg = FALSE;

				if (fBldrLevel)
				{
					// get our per-item action list
					CActionSlobList * pActions = pItem->GetActiveConfig()->GetActionList();
					pos = pActions->GetHeadPosition();
					CBuildTool * pTool;
					CProjType * pProjType = m_pBuilder->GetProjType();
					ASSERT(pProjType);
				
					CPtrList * pToolsList = pProjType->GetToolsList();
					POSITION pos = pToolsList->GetHeadPosition();
					while (pos != NULL)
					{
						// get the tool
						pTool = (CBuildTool *)pToolsList->GetNext(pos);
						CActionSlob * pAction;
						S_ToolRec * pToolRec;

						// find it's area
						if (mapToolToAction.Lookup(pTool, (void * &)pToolRec))
						{
							// get the tools's action
							POSITION pos2 = pActions->Find(pTool);
							if (pos2)
							{
								pAction = (CActionSlob *)pActions->GetAt(pos2);
							}
							else
							{
								pAction = NULL;
							}
							if (pToolRec->iAreas & (PerConfig | PerConfigExt | ToolUsed))
							{
								// write builder-level header here if tool NOT used by all configs
								if (fBldrLevel)
									if ((pToolRec->iAreas & (Header | BuildRule)) == Header)
										pTool->WriteHeaderSection(pAction);
									

								// write out the tool's add/subtract data:
								if (nWriteProject > k)
									pTool->WriteAddSubtractLine(pItem);
							
								if ((nExportMakefile > k) || (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
									|| (pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool))))
								{
									pTool->WritePerConfigData(pItem, pAction);
								}
							}
						}
					}	
				}
				else // fileitem
				{
					// get our per-item action list
					CActionSlobList * pActions = pItem->GetActiveConfig()->GetActionList();
					pos = pActions->GetHeadPosition();
					while (pos != (POSITION)NULL)
					{
						// get the action
						CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);
						// get the action's tool
						CBuildTool * pTool = pAction->m_pTool;
						S_ToolRec * pToolRec;
	
						// find it's area
						if (mapToolToAction.Lookup(pTool, (void * &)pToolRec))
						{
							if (pToolRec->iAreas & (PerConfig | PerConfigExt | ToolUsed))
							{
								// write builder-level header here if tool NOT used by all configs
								if (fBldrLevel)
									if ((pToolRec->iAreas & (Header | BuildRule)) == Header)
										pTool->WriteHeaderSection(pAction);

								// write out the tool's add/subtract data:
								if (nWriteProject > k)
									pTool->WriteAddSubtractLine(pItem);
							
								if ((nExportMakefile > k) || (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
									|| (pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool))))
									pTool->WritePerConfigData(pItem, pAction);
							}
							// file item?
							else if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
							{
								ASSERT((pToolRec->iAreas & BuildRule)==0);
								if ((nExportMakefile > k) || (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
									|| (pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool))))
									pTool->WritePerConfigData(pItem, pAction);
							}
						}
					}	
				}
			}
		}

		// write final !ENDIF if writing multiple configs
		if (nMaxIndex)
		{
			pItem->m_cp = CProjItem::EndOfConfigs;
			if (nWriteProject > 1)
				pItem->WriteConfigurationIfDef(*m_ppw, NULL);
			if (nExportMakefile > 1)
				pItem->WriteConfigurationIfDef(*m_pmw, NULL);
			if (nExportDeps > 1)
				pItem->WriteConfigurationIfDef(*m_pdw, NULL);
		}

		// finish up by writing the tool build rule
		// and then ending the writing session
		for( i=0; i<nLastRec; i++)
		{
			S_ToolRec * pToolRec = pListToolRecs[i];
			CBuildTool *pTool = pListToolRecs[i]->pTool;

			if (pToolRec->iAreas & BuildRule)
			{
				ASSERT(!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
				ASSERT(pToolRec->pAction != NULL);
				if (pToolRec->pAction != NULL)
					pToolRec->pTool->WriteBuildRule(pToolRec->pAction);
			}

			if (pToolRec->iAreas != NoAreas)
				pToolRec->pTool->EndWritingSession();
		}
		projTempConfigChange.Release();

		// write include dep file here for exported makefile
		if (fBldrLevel && g_bExportMakefile)
		{
			m_pmw->EndLine ();	// REVIEW: needed?

	 		// !IF "$(NO_EXTERNAL_DEPS)" != "1"
			CString str = "\"$(NO_EXTERNAL_DEPS)\" != \"1\"";
			m_pmw->WriteDirective (CMakDirective::DTYP_IF, str);

			CPath makPathDep = *m_pBuilder->GetFilePath(); // REVIEW: get from actual path
			makPathDep.ChangeExtension(".dep");
			str = makPathDep.GetFileName();
			str = "\"" + str + "\"";

			// !IF EXISTS("foo.dep")
			CString str2 = "EXISTS("; str2 += str; str2 += ")";
			m_pmw->WriteDirective (CMakDirective::DTYP_IF, str2);

			// !INCLUDE "foo.dep"
			m_pmw->WriteDirective (CMakDirective::DTYP_INCLUDE, str);

			// !ELSE
			m_pmw->WriteDirective (CMakDirective::DTYP_ELSE, NULL);

			// !MESSAGE Warning: cannot find "devbld.dep"
			str2 = "Warning: cannot find " + str;
			m_pmw->WriteDirective (CMakDirective::DTYP_MESSAGE, str2);

			m_pmw->WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
			m_pmw->WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
			m_pmw->EndLine ();
		}
	}
	CATCH(CException, e)
	{
		fRetval = FALSE;	// failure
	}
	END_CATCH

	// update progress status
	if (g_bWriteProject)
		m_ppw->WroteObject();
	if (g_bExportMakefile)
		m_pmw->WroteObject();

	// Clean up the map.
	for( i=0; i<nLastRec; i++)
	{
		S_ToolRec * pToolRec = pListToolRecs[i];
		delete pToolRec;
	}
	mapToolToAction.RemoveAll();
	
	return fRetval;	// success?
}

static BOOL HasPerConfigDeps( CProjItem *pItem ){

	BOOL bExcluded;
	ConfigurationRecord * pcr;
	CBuildTool *pTool = NULL;
	const CPtrArray & ppcr = *pItem->GetConfigArray();
	int i, nNumConfigs = pItem->GetPropBagCount();
	for (i = 0; i < nNumConfigs; i++)
	{
		pcr = (ConfigurationRecord *)ppcr[i];
		ASSERT_VALID (pcr);
		pItem->ForceConfigActive(pcr);
		if (pItem->GetIntProp(P_ItemExcludedFromBuild, bExcluded) != valid)
			bExcluded = FALSE;
		
		if (!bExcluded)
		{
			if (pTool==NULL)
			{
				pTool = pcr->GetBuildTool();
			}
			else if (pTool != pcr->GetBuildTool())
			{
				// reset the config.
				pItem->ForceConfigActive();
		   		return TRUE;
			}
		}
	}
	
	// reset the config.
	pItem->ForceConfigActive();
	return FALSE;
}


// read in the VC++ builder file
BOOL CBuildFile::ReadBuildFile(const CProject * pBuilder)
{
	// remember this builder
	m_pBuilder = (CProject *)pBuilder;

	// no tool's used yet
	m_lstToolsUsed.RemoveAll();

	// incr. our marker
	m_wToolMarker++;

	BOOL bRetval = TRUE;

	return bRetval;
}

// 'NMake syntax' section read
#define CCH_ALLOC_BLOCK		256
BOOL CBuildFile::ReadSectionForNMake(const TCHAR * pchname)
{
	// dynamic creation of sections?
	BOOL fAddDynaSection = FALSE;

	// get a section with this name?
	CBldrSection * pbldsect = g_BldSysIFace.FindSection(pchname);
	if (pbldsect == (CBldrSection *)NULL)
	{	
		HBUILDER hBld = g_BldSysIFace.GetActiveBuilder(); //dra
		if ((pbldsect = new CBldrSection(hBld)) == (CBldrSection *)NULL)
			return FALSE;

		// set the name, and mark as async.
		pbldsect->m_strName = pchname;
		pbldsect->m_pfn = NULL;

		fAddDynaSection = TRUE;
	}

	// init.
	pbldsect->m_pch = (TCHAR *)NULL;
	pbldsect->m_cch = 0;

 	// file exceptions can occur during builder file read
 	CFileException e;
	BOOL bRetval;

	// builder file object
	CObject * pObject = (CObject *)NULL;

	TRY
	{
		TCHAR * pch;
		UINT cch = 0;
		UINT cchAlloc = CCH_ALLOC_BLOCK;
		pch = (TCHAR *)calloc(cchAlloc + 1, sizeof(TCHAR));	// alloc. one for zero-term.
		if (pch == (TCHAR *)NULL)
			AfxThrowFileException(CFileException::generic);

		pbldsect->m_pch = pch;

		// break out when we reach the end of the section or EOF
		for (;;)
		{
			// read in section
			pObject = m_pmr->GetNextElement();
			ASSERT(pObject != (CObject *)NULL);

			// reached end of builder file prematurely?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				AfxThrowFileException(CFileException::generic);

			// read in our sections
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				TCHAR * pchComment = (TCHAR *)(const TCHAR *)((CMakComment *)pObject)->m_strText;

				// end of the section?
				if (!_tcsncmp(pchComment, pcEndToken, _tcslen(pcEndToken)))
				{
					*(pbldsect->m_pch + cch) = _T('\0'); cch++;	// zero. term

					// set out buffer size
					pbldsect->m_cch = cch;

					// provide the section data and get the return code?
					if (pbldsect->m_pfn)
						bRetval = (*pbldsect->m_pfn)(pbldsect, SECT_READ);
					else
						bRetval = TRUE;
					break;
				}

				// data length in section?
				UINT cchLen = _tcslen(pchComment);

			TryAgain:

				if ((cchLen + 1) > (cchAlloc - cch))	// incl zero. term
				{
					// need more memory so re-alloc
					cchAlloc += CCH_ALLOC_BLOCK;
					pch = (TCHAR *)realloc(pbldsect->m_pch, sizeof(TCHAR) * (cchAlloc + 1));		// alloc. one for zero-term.
					if (pch == (TCHAR *)NULL)
						AfxThrowFileException(CFileException::generic);

 					pbldsect->m_pch = pch;

					goto TryAgain;
				}

				// copy data into our buffer
				_tcscpy(pbldsect->m_pch + cch, pchComment);
				cch += cchLen;
				*(pbldsect->m_pch + cch) = _T('\0'); cch++;	// zero. term
			}

			// delete this object
			delete pObject; pObject = (CObject *)NULL;
		}
	}
	CATCH(CException, e)
	{	
		bRetval = FALSE;	// failure
	}
	END_CATCH

	// unget the last builder file element so that
	// our caller can process it
	if (pObject != (CObject *)NULL)
		m_pmr->UngetElement(pObject);

	// got a dyna-section and ok?
	if (fAddDynaSection)
	{
		// ok?
		if (bRetval)
		{
			// register this one
			g_BldSysIFace.RegisterSection((CBldrSection *)pbldsect);
		}
		else
		{
			// free up our data (we used sync. notify)
			if (pbldsect->m_pch != (TCHAR *)NULL)
				free(pbldsect->m_pch);

			// delete our section
			delete pbldsect;
		}
	}
	else
	{
		// free up our data (we used sync. notify)
		if (pbldsect->m_pch != (TCHAR *)NULL){
			free(pbldsect->m_pch);
			pbldsect->m_pch = NULL;
		}
	}

	return bRetval;
}

void CBuildFile::AddProjDepsToGraph()
{
	// not expanded
	CProject * pProject = m_pBuilder;

	const CPtrArray & ppcr = *pProject->GetConfigArray();
	ConfigurationRecord * pcr;

	CProjTempConfigChange projTempConfigChange(pProject);

	CObList ol;
	int fo = CProjItem::flt_OnlyTargRefs;
	pProject->FlattenSubtree(ol, fo);

 	for (POSITION pos = ol.GetHeadPosition(); pos != NULL; )
	{
		CProjectDependency * pProjectDep = (CProjectDependency *) ol.GetNext(pos);
		if (pProjectDep->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
			CTargetItem * pTarget = pProjectDep->GetTarget();
			const CPtrArray & ppcr = *pTarget->GetConfigArray();

			int ccr = ppcr.GetSize();
			for (int icr = 0; icr < ccr; icr++)
			{
				pcr = (ConfigurationRecord *)ppcr[icr];
				if (pcr->IsValid())
				{
                    pcr = (ConfigurationRecord *)pcr->m_pBaseRecord;
					projTempConfigChange.ChangeConfig(pcr);

	 				ConfigurationRecord * pcrProjDep = pProjectDep->GetTargetConfig();

					if (pcrProjDep != NULL)
					{
						PROJDEPREFINFO * pProjDepRefInfo = new PROJDEPREFINFO;
						pProjDepRefInfo->pProjDep = pProjectDep;
						pProjDepRefInfo->pcr = pcr;	 // REVIEW

						m_lstProjDepRefs.AddTail(pProjDepRefInfo);
					
						CActionSlob::AddRefFileItem(pProjectDep);
					}
				}
			}
		}
	}
}

void CBuildFile::RemoveProjDepsFromGraph()
{
	CProject * pProject = m_pBuilder;

	CProjTempConfigChange projTempConfigChange(pProject);

	while (!m_lstProjDepRefs.IsEmpty())
	{
		PROJDEPREFINFO * pProjDepRefInfo = (PROJDEPREFINFO *)m_lstProjDepRefs.RemoveHead();

		projTempConfigChange.ChangeConfig (pProjDepRefInfo->pcr);
		CActionSlob::ReleaseRefFileItem(pProjDepRefInfo->pProjDep);
		delete pProjDepRefInfo;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldrcvtr.h ===
// 
// CMak* (builder components) and CBuilderConverter
//
// Conversion of old VC++ 1.x builder files (.mak)
//
// [matthewt]
//

#ifndef _INCLUDE_BLDRCVTR_H
#define _INCLUDE_BLDRCVTR_H

#ifndef _SUSHI_PROJECT
// If you are including this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

// CMak* classes
// These classes represent the various syntactic elements of a
// builder makefile.
class BLD_IFACE CMakComment : public CObject
{
	DECLARE_DYNAMIC(CMakComment)

public:
	// constructor + destructor
	CMakComment(const TCHAR *);
	virtual ~CMakComment();

	CString		m_strText;	// text of comment

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class BLD_IFACE CMakMacro : public CObject
{
	DECLARE_DYNAMIC(CMakMacro)

public:
  	// constructor + destructor
	CMakMacro(const CString&, const CString &);
	virtual ~CMakMacro();

 	CString		m_strName;		// macro name
	CString		m_strValue;		// macro value
	CString		m_strRawData;	// raw data

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class BLD_IFACE CMakDescBlk : public CObject
{
	DECLARE_DYNAMIC(CMakDescBlk)

public:
  	// constructor + destructor
	// Note, the object is initially constructed with the targets
	// and dependencies strings.  Commands are added later
	// via AddCommand().
	CMakDescBlk(const CString &, const CString &);
	virtual ~CMakDescBlk();

	// Add a command to the list of commands.
	void AddCommand(const TCHAR *);

	CString		m_strTargets;	// string representing target(s) (left side of ':')
	CString		m_strDeps;		// string representing dependencies (right side of ':')
	CString		m_strTool;
	CStringList	m_listCommands;	// list of commands
	CString		m_strRawData;

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class BLD_IFACE CMakDirective : public CObject
{
	DECLARE_DYNAMIC(CMakDirective)

public:
 	// local type
	enum DTYP
	{
		DTYP_CMDSWITCHES,
		DTYP_ERROR,
		DTYP_MESSAGE,
		DTYP_INCLUDE,
		DTYP_IFNDEF,
		DTYP_IFDEF,
		DTYP_IF,
		DTYP_ELSEIFNDEF,
		DTYP_ELSEIFDEF,
		DTYP_ELSEIF,
		DTYP_ELSE,
		DTYP_ENDIF,
		DTYP_UNDEF
	};

 	// constructor + destructor
	CMakDirective(DTYP, const CString &);
	virtual ~CMakDirective();

	DTYP		m_dtyp;			// directive type.
	CString		m_strRemOfLine;	// string containing remainder of line after directive

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class BLD_IFACE CMakError : public CObject
{
	DECLARE_DYNAMIC(CMakError)

public:
  	// constructor + destructor
	CMakError();
	virtual ~CMakError();
};

class BLD_IFACE CMakEndOfFile : public CObject
{
	DECLARE_DYNAMIC(CMakEndOfFile)

public:
  	// constructor + destructor
	CMakEndOfFile();
	virtual ~CMakEndOfFile();
};

// Our CBuilderConverter class which is used to convert old VC++ 1.x builder files (.MAK).
// Each product variant should register one of these, e.g. the x86 C++ package and the x86 FORTRAN package.
// information block for the conversion of old Caviar/Cuda/Sanchovy projects

class CBuilderConverter;
typedef struct tagCNV_INFO
{
	const CPath * pPath;	// path of the builder we are attempting to convert
	CProject * pProject;	// builder we are creating
	
	int nStatus;			// wants to attempt (1) or abort (-1) this conversion?
	BOOL fSilent;			// silent conversion? used for converting samples without prompting
	BOOL f32Bit;			// is this a 32-bit project? (read-only)
	int nUseMFC;			// project using MFC == (read/write)
							// NoUseMFC
							// UseMFCInLibrary 
							// UseMFCInDll (UseMFCDefault)

	CBuilderConverter *	pbldrcnvtr;	// the builder converter that's performing the conversion
} CNV_INFO;

class BLD_IFACE CBuilderConverter : public CBldSysCmp, public COptHdlrMapper
{
	DECLARE_DYNAMIC(CBuilderConverter)

public:
	// contructor + destructor
	CBuilderConverter(const TCHAR * szPkg, WORD id);
	virtual ~CBuilderConverter();
	
	// Initialise the converter prior to builder conversion.
	virtual BOOL FInitialise();

	// Can this builder converter do the conversion?
	// Return FALSE if cannot, return TRUE if still deciding and set
	// 'pcnvinfo->fAttempt' to TRUE if would like to attempt.
	virtual BOOL CanConvert(CObject * pMakObj, UINT nCurrLine, CNV_INFO * pcnvinfo) = 0;

	// Do the conversion...
	// Return FALSE if cannot, return TRUE if successful.
	virtual BOOL DoConvert(CObject * pMakObj, UINT nCurrLine, CNV_INFO * pcnvinfo) = 0;

	// Finish the conversion
	virtual BOOL FinishConvert(CNV_INFO * pcnvinfo) = 0;

private:
};

#endif // _INCLUDE_BLDRCVTR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\configs.h ===
#ifndef __CONFIGS_H__
#define __CONFIGS_H__

#include <afxcmn.h>
#include <utilctrl.h>

/////////////////////////////////////////////////////////////////////////////
// The "Project Configurations..." dialog box.
class CProjectConfigurationsDlg : public C3dDialog
{
// Construction
public:
	CProjectConfigurationsDlg(CWnd* pParent = NULL);
	virtual ~CProjectConfigurationsDlg();

// Dialog Data
protected:
	CTreeCtrl	m_ConfigurationsTree;
	int			m_nFileset;

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);

	// Message map functions.
	virtual BOOL OnInitDialog();
	afx_msg void OnAddConfiguration();
	afx_msg void OnRemove();
	afx_msg void OnSelectConfiguration(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnOK ();
	DECLARE_MESSAGE_MAP()

	// Helpers
	void EnableButtons();
	void FillTree();
	void CalculateInvalidDependencies(HBLDTARGET hConfig, CStringList& rslConfigs);
	BOOL IsConfig(HTREEITEM hItem);
	HBLDTARGET GetConfig(HTREEITEM hItem);
	LPCTSTR GetConfigName(HTREEITEM hItem);
	HFILESET GetProject(HTREEITEM hItem);
	LPCTSTR GetProjectName(HTREEITEM hItem);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\cursor.h ===
//
// cursor.h
//
// Defines a simple cursor manager
//
// Implementation is in : cursor.cpp
//
// History:
// Date				Who			What
// 01/26/94			colint			Created
//////////////////////////////////////////////////////////////////////////

#ifndef __CURSORMGR_H__
#define __CURSORMGR_H__

class CCursorManager
{
public:
	CCursorManager();
	~CCursorManager();

	HCURSOR GetDDCur( int iBase )
	{	return GetCursor(iBase*4); }
	HCURSOR GetDDCopyCur( int iBase )
	{	return GetCursor(iBase*4 + 1); }
	HCURSOR GetDDMultiCur( int iBase )
	{	return GetCursor(iBase*4 + 2); }
	HCURSOR GetDDMultiCopyCur( int iBase )
	{	return GetCursor(iBase*4 + 3); }

	void Flush();
	void Cleanup();

	// Indices into the aCursorIDs static array.
	// Because they are indices, order does matter here.
	enum {
		iFileItem,			// = 0
	};

protected:
	HCURSOR GetCursor( int iCursor );

	HCURSOR* m_phCurs;
	int      m_nAllocCurs;
};

extern CCursorManager g_Cursors;

#endif // __CURSORMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\cursor.cpp ===
//
// Implementation for CCursorManager class
//
// History:
// Date				Who			What
// 01/26/94			colint			created
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop
#include "cursor.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//  CCursorManager
//      Deals with the drag-drop cursors.

CCursorManager g_Cursors;

static UINT BASED_CODE aCursorIDs[] =
{
    IDC_DDFILE, IDC_DDCOPYFILE, IDC_DDMULTIFILE, IDC_DDCOPYMULTIFILE,
};

CCursorManager::CCursorManager()
{
    m_phCurs = (HCURSOR*) new char [sizeof(HCURSOR)*sizeof(aCursorIDs)/sizeof(UINT)];
    m_nAllocCurs = sizeof(aCursorIDs)/sizeof(UINT);

    for ( int i = 0; i < m_nAllocCurs; i++ )
        m_phCurs[i] = NULL;
}

CCursorManager::~CCursorManager()
{
    Cleanup();
}

HCURSOR CCursorManager::GetCursor( int iCursor )
{
    ASSERT( m_phCurs != NULL );
    ASSERT( iCursor >= 0 && iCursor < m_nAllocCurs );

    if ( m_phCurs[iCursor] == NULL )
    {
        m_phCurs[iCursor] = ::LoadCursor(GetResourceHandle(),
            MAKEINTRESOURCE(aCursorIDs[iCursor]));

        if ( m_phCurs[iCursor] == NULL )
            return ::LoadCursor( NULL, IDC_ARROW );
    }

    return m_phCurs[iCursor];
}

void CCursorManager::Flush()
{
    ASSERT( m_phCurs != NULL );

    for ( int i = 0; i < m_nAllocCurs; i++ )
    {
        if ( m_phCurs[i] != NULL )
            DestroyCursor( m_phCurs[i] );
    }
}

void CCursorManager::Cleanup()
{
    if ( m_phCurs != NULL )
    {
        Flush();
        delete ((void*)m_phCurs);
        m_phCurs = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldslob.h ===
//
// CBldSlob
//
// Build Slob
//
// [colint]
//

#ifndef _INCLUDE_BLDSLOB_H
#define _INCLUDE_BLDSLOB_H

class CBuildSlob : public CProjSlob
{
	DECLARE_SERIAL(CBuildSlob)
	typedef CProjSlob Inherited;
public:
	CBuildSlob();
	CBuildSlob(CProjItem * pItem, ConfigurationRecord * pcr);
	~CBuildSlob();

	// Content list support
	virtual CObList* GetContentList() { return (&m_Contents); }

	// Window viewing this slob
	virtual CSlobWnd* GetSlobWnd() const;

	// Paste/remove support
	virtual BOOL CanAct(ACTION_TYPE action) { return((m_pItem == NULL) ? FALSE : m_pItem->CanAct(action)); }
	virtual BOOL CanAdd ( CSlob *pAddSlob );
	virtual BOOL CanRemove(CSlob* pRemoveSlob)
		{ return m_pItem->CanRemove(((CBuildSlob *)pRemoveSlob)->GetProjItem()); }
	virtual BOOL PreAct(ACTION_TYPE action)	{ return m_pItem->PreAct(action); }

	// Property support
	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetStrProp(UINT idProp, const CString & val);
	virtual BOOL SetLongProp(UINT idProp, long val) { return SetIntProp(idProp, val); }
	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString & val);
	virtual GPT GetLongProp(UINT idProp, long& val) { int val1 = val; GPT retval = GetIntProp(idProp, val1); val = val1; return retval; }

	// Property Window Interface...
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Standard Display routine
	virtual BOOL DrawGlyph(CDC *pDC, LPCRECT lpRect);

	//  Get filename associated with this slob, if any:
	virtual const CPath *GetFilePath () const;
	virtual FileRegHandle GetFileRegHandle () const;
	virtual int GetAssociatedFiles(CStringArray &);

    // Verb and command support
    virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);
	CProjItem * GetProjItem() { return m_pItem; }

	// Override SetSlobProp to handle disconnecting notification
	BOOL SetSlobProp(UINT idProp, CSlob * val);

	// Our incredible move item overrides
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged);
 	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged);
 	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged);

	// Set the container of this slob, without telling anyone
	CBuildSlob * SetContainer(CSlob * pSlob);

	// Tree sorting
	virtual SORT_TYPE GetSortType() { return override_sort; }
	virtual int CompareSlob(CSlob *pCmpSlob);

	// Fixup the active config on the project, so we can do prop stuff
	// correctly
	void FixupItem();
	void UnFixupItem();

	// Get the configuration name for this item (i.e. the config of the projitem that
	// it represents)
	CString & GetConfigurationName() const { return m_pcr->GetConfigurationName(); }

	void SetMatchingConfig(LPCTSTR pszConfig, BOOL bContents = TRUE);

		// HACK ALERT, HACK ALERT, HACK ALERT
	// I couldn't come up with a clean way to do this, so here we have some state
	// variables.

	// Used to switch thunking of CBuildSlob moves through to the CProjItems. E.g.
	// if you move a CBuildSlob, and thunking is on, then the corresponding CProjItem
	// will also be moved. 
	void ThunkMoves() { m_bThunkMoves = TRUE; }
	void UnThunkMoves() { m_bThunkMoves = FALSE; }

	// Used to ignore informs. This is necessary when we are in the process of undoing
	// an action, and have moved a CProjItem back into the project, which causes a
	// bunch of notifications to be sent to CProjItems. However we want to ignore
	// some of these notifications, namely the ones sent to the CBuildSlob representing
	// the container that the CBuildSlob on the undo stack will be moved into. That is
	// we have a CProjItem, and a CBuildSlob on the undo stack, when we move the CProjItem
	// into the project, we would normally create two wrapping CBuildSlobs by the
	// notification mechanism. BUT we now only have to create one of these wrappers,
	// because the other one is on the undo stack and will be moved back into our CBuildSlob
	// hierachy shortly.
	void IgnoreInforms() { m_bIgnoreInforms = TRUE; }
	void UnIgnoreInforms() { m_bIgnoreInforms = FALSE; }
	BOOL IgnoringInforms() { return m_bIgnoreInforms; }

	// Pass informs onto a select list of CBuildSlobs. At the moment this list
	// contains CBuildSlobs that care about configuration name changes
	void InformBldSlobs(CSlob * pChangedSlob, UINT idChange, DWORD dwHint);

	// Clipboard support. Clone must make a clone of the wrapper (i.e. this), and
	// also a clone of the corresponding CProjItem. PrepareAddList does filtering
	// on the list of things to paste into this CBuildSlob, based on the contents
	// of this CBuildSlob already (i.e remove dupes, remove items already in the
	// container being pasted into).
	virtual CSlob * Clone();
	virtual void PrepareAddList(CMultiSlob* pAddList, BOOL fPasting);

	virtual void GetGlyphTipText(CString & str);

	// Drop/Drag cursor support
	virtual HCURSOR GetCursor(int ddcCursorStyle);

	virtual void	PrepareDrop(CDragNDrop *pInfo);
	virtual CSlobDragger* CreateDragger(CSlob *pDragObject, CPoint screenPoint);
	virtual void	DoDrop(CSlob *pSlob, CSlobDragger *pDragger);
	virtual void	DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint);

	// Verb Support

	// Context sensitive build support
	// This has to be public, since the CBuildViewSlob will thunk to it
	afx_msg void OnClean();
	afx_msg void OnUpdateClean(CCmdUI * pCmdUI);
	afx_msg void OnBuild();
	afx_msg void OnBuildNoDeps();
	afx_msg void OnUpdateBuild(CCmdUI * pCmdUI);
	afx_msg void OnAddGroup();
	afx_msg void OnUpdateAddGroup(CCmdUI * pCmdUI);
	afx_msg void OnPopupFilesIntoProject();
	afx_msg void OnUpdateFilesIntoProject(CCmdUI *pCmdUI);

	void FlattenContents(CObList & ol, BOOL bItemsOnly = TRUE);
protected:
    //{{AFX_MSG(CBuildSlob)
    afx_msg void OnOpenItem();
	afx_msg void OnCompileItem();
    afx_msg void OnUpdateOpenItem(CCmdUI * pCmdUI);
	afx_msg void OnUpdateCompileItem(CCmdUI * pCmdUI);
    //}}AFX_MSG

	// Set the item we are wrapping
	void SetItem(CProjItem * pItem) { m_pItem = pItem; }

	// Set the config we are wrapping
	void SetConfig(ConfigurationRecord * pcr) { m_pcr = pcr; }
	ConfigurationRecord * GetConfig(void) { return m_pcr; }

private:
	CObList m_Contents;			// Our contents
	CString m_strTitle;			// Our title
	CString m_strProjWinTitle;	// ???????????

	// to make slobs aware of tree-control connections
	BOOL m_bIsExpanded;
	BOOL m_bIsExpandable;

	// property containing IPkgProject interface pointer (if appropriate)
	LONG m_lIPkgProject;

	// HACK ALERT
	// State variables
	BOOL m_bIgnoreInforms;		// Ignore informs
	static BOOL m_bThunkMoves;	// Thunk moves

	// The item and config record this slob represents
	CProjItem * m_pItem;
	ConfigurationRecord * m_pcr;

	// Used to implement Fixup/UnFixup Item
	CProjTempConfigChange *m_pTempConfigChange;
	DWORD	m_dwFixupRefCount;

	// Our list of CBuildSlobs that wish to be informed about certain prop changes
	static CObList m_lstInform;

	CPtrList m_DeathRow;	// list of Slobs to be delete during a Drop
	CSlob *m_pProxyContainer;

	DECLARE_SLOBPROP_MAP();
};

class CBuildIt {
public:
	CBuildIt(BOOL bFireEvents = TRUE);
	~CBuildIt();
	static CMapStringToPtr 	m_mapConfigurationsBuilt;
	static CMapStringToPtr 	m_mapMissingEnvVars;
	static int 				m_actualErrs;
	static int 				m_warns;
	static int 				m_depth;
	static BOOL				m_bFireEvents;
};


#endif // _INCLUDE_BLDSLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\depgraph.h ===
//
// CGrNode, CGraph, CFileDepGraph
//
// Graph node, dependency graph node, graph and dependency graph classes
//
// [matthewt]
//

#ifndef _INCLUDE_DEPGRAPH_H
#define _INCLUDE_DEPGRAPH_H

#if defined(_DEBUG) && defined(new)
#define _DO_DEBUG_NEW
#undef new
#endif

#ifdef _DEBUG
// Define DEPGRAPH_VIEW to enable graphical view of dependency graph.
#define DEPGRAPH_VIEW
#endif

#include "pfilereg.h"	// file registry notification (CFileRegNotifyRx)

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

// node instance identifier
typedef ULONG NID;
#define nidNil ((ULONG)-1)

// edge instance identifier
typedef ULONG EID;
#define ET EID

// CGrNfyRx events
#define GrEvt_Destroy		0x1

// Relationship manipulation
#define GrEvt_AddChild		0x2
#define GrEvt_AddParent		0x3
#define GrEvt_DelChild		0x4
#define GrEvt_DelParent		0x5

// Edge manipulation
#define GrEvt_AddEdge		0x6
#define GrEvt_DelEdge		0x7

// mode of graph
#define Graph_Creating		0x0
#define Graph_Destroying	0x1
#define Graph_Stable		0x2

// forward decls.
class CGrNode;
class CGraph;
class CFileDepGraph;
class CLayout;

class CGrNfyRx
{
public:
	CGrNfyRx() {}
	virtual ~CGrNfyRx() {}

	// Rx for graph node change events
	virtual void OnGrNfy(UINT grevt, CGrNode * grn, void * pvhint) = 0;
};

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

class CGrNode
{
friend class CGraph;
friend class CLayout;

public:
	// constructor+destructor
	CGrNode(CGraph * pgraph, NID nid, USHORT cChildren = 0, USHORT iDepth = 0);
	virtual ~CGrNode();

	// handle our own allocations
	// we'll use our own private Win32 heap
	// and place de-alloc'ed blocks into a 
	// global list
// can't override operator new if the "new" is already #defined to be
// DEBUG_NEW
#ifdef USE_LOCAL_BUILD_HEAP
#if defined(_DEBUG) && defined (new)
#define REDEF_NEW
#undef new
#endif
	__inline void * operator new(size_t size) {return g_heapNodes.alloc(size);}
	__inline void * operator new(size_t size, LPCSTR, int) {return g_heapNodes.alloc(size);}
#ifdef REDEF_NEW
#undef REDEF_NEW
#define new DEBUG_NEW
#endif
	__inline void operator delete(void * p) {g_heapNodes.dealloc(p);}
#endif

	// retrieve the properties of this graph node
	__inline NID Nid()					{return m_nid;}
	__inline USHORT	CChildren()			{return m_cChildren;}
	__inline CGrNode * Child(USHORT i)	{return m_rgChildren[i];}
	__inline EID Edge(USHORT i)			{return m_rgEdges[i];}
	__inline USHORT CParents()			{return m_cParents;}
	__inline CGrNode * Parent(USHORT i)	{return m_rgParents[i];}

	// layout related
#ifdef DEPGRAPH_VIEW
	__inline USHORT	ICol()				{return m_iDepth;}
	__inline USHORT	IRow()				{return m_iPos;}
	__inline BOOL	FFake()				{return m_fFake;}
	__inline BOOL	CReversed()			{return m_cReversed;}
	__inline BOOL	FRecursive()		{return m_fRecursive;}
	__inline void	SetSize(CSize size)	{m_sizeView = size;}
	__inline CSize	GetSize()			{return m_sizeView;}
#endif // DEPGRAPH_VIEW

	// add or remove graph node event receivers
	void AddGrNfyRx(CGrNfyRx * pgrnfyrx);
	void RemoveGrNfyRx(CGrNfyRx * pgrnfyrx);

	// Rx for changes in node connections
	virtual void InformGrNfyRx(UINT grevt, void * pvhint = (void *)0);

	// graph mode changed
	virtual void OnGraphMode(UINT newmode) {/* do nothing */};

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext & dc) const;
	virtual void DumpNid(CDumpContext & dc) const;
#endif

	// add a new child to this node with specified edge
	void AddChild(CGrNode * pgrn, EID eid = (EID)NULL);

	// remove a child (refrenced by index)
	void DelChild(USHORT iChild);

#ifdef USE_LOCAL_BUILD_HEAP
	// our local graph node heap
	static CLclHeap g_heapNodes;
#endif

	BOOL		m_fVisited:1;		// visited?
	// BOOL        m_fCleared:1;       // cleared?

protected:
	NID			m_nid;				// node instance identifier
	USHORT		m_cParents;			// count of parents
	USHORT		m_cChildren;		// count of children

	CGrNode * *	m_rgChildren;		// array of children
	USHORT		m_allocChildren;	// size of child array alloc.
	USHORT		m_allocParents;		// size of parent array alloc.

	CGrNode * *	m_rgParents;		// array of parents

	EID *		m_rgEdges;			// array of edges

	// layout related.
#ifdef DEPGRAPH_VIEW
	BOOL		m_fWorking:1;		// this node is currently being examined
	BOOL		m_fFake:1;			// artifically created node -- invalid handle
	BOOL		m_fRecursive:1;		// mark item as recursive if it is
	USHORT		m_iDepth;			// depth of this item
	USHORT		m_iPos;				// position in column
	CGrNode *	m_pgrnAlias;		// pointer to equivalent fake node
	CGrNode *	m_pgrnNext;			// pointer to next node in queue
	CGrNode *	m_pgrnPrev;			// pointer to prev node in queue
	USHORT		m_iParent;			// next parent to insert
	USHORT		m_cSiblings;		// count of siblings
	USHORT		m_cReversed;		// count of reversed edges
	USHORT		m_cost;				// cost in current position
	CSize		m_sizeView;			// cache info to help views out
#endif // DEPGRAPH_VIEW

	// Rx
	CGrNfyRx	*m_GrNfyRx;
 
private:
#ifdef DEPGRAPH_VIEW
	// our assigned graph 
	CGraph *	m_pgraph;
#endif

#ifdef _KIPDEBUG
    static int nCount;
#endif
};

/*
/////////////////////////////////////
// CViewGrNode - visual graph node //
/////////////////////////////////////

class CViewGrNode : public CGrNode
{
public:
	CViewGrNode() {};
	~CViewGrNode() {};
};
*/

////////////////////////////////////////
// CDepGrNode - dependency graph node //
////////////////////////////////////////

// state of a dependency
typedef enum DepState
{
	DS_Unknown = 0x0,			// unknown state
	DS_DepMissing = 0x1,		// dependency missing
	DS_OutOfDate = 0x2,			// dependant out of date wrt dependency
	DS_Current = 0x4,			// dependant is current wrt to dependency
	DS_ForcedOutOfDate= 0x8	// dependant is forced out of date wrt dependency
};

//
// Relationship is as follows:
//
// Dependency (child) <- Dependant (parent)
//
#define DepGrEvt_AddDpnt	GrEvt_AddParent
#define DepGrEvt_DelDpnt	GrEvt_DelParent
#define DepGrEvt_AddDpcy	GrEvt_AddChild
#define DepGrEvt_DelDpcy	GrEvt_DelChild

// Manage a static length list of FileRegHandles
class FRHArray {
public:
	FRHArray( int n = 0 );
	~FRHArray( ){ delete []m_pDepcy; }

	void 		  SetAt( FileRegHandle frh, int i )	{ ASSERT(i<m_nFRH); m_pDepcy[i] = frh; }
	FileRegHandle GetAt( int i ) 					{ ASSERT(i<m_nFRH); return m_pDepcy[i]; }
	int 		  GetCount() 						{ return m_nFRH; }

	void Replace( int n );

private:		
	FileRegHandle  *m_pDepcy;		// the array of n+1 elements
	int				m_nFRH;			// the number of elements
};


class CDepGrNode : public CGrNode, CFileRegNotifyRx
{

public:
	CDepGrNode(CFileDepGraph * pgraph, CFileRegistry * pregistry, FileRegHandle frh);
	virtual ~CDepGrNode();

	// state query
	__inline UINT Depstate()				{return m_state;}
	__inline void SetDepstate(UINT state)	{
		USHORT oldState = m_state;
		m_state = (USHORT)state;
		if( m_state != oldState )
			OnDepStateChanged( m_state );
	}
	__inline FileRegHandle Frh()			{return (FileRegHandle)Nid();}
	__inline CFileRegSet * DepcySet()		{return &m_frsDepcy;}
//	__inline FRHArray * DepcyListAtCurr()	{return &m_lstDepcy;}

	// Rx for changes in dep. connections
	virtual void InformGrNfyRx(UINT grevt, void * pvhint = (void *)0);

	// Rx for file change events
	virtual void OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);

	// figure the dependency state
	// and sent out an inform if it has changed
	void FigureDepState();

	// inform that dependency state has changed
	virtual void OnDepStateChanged(UINT state);

	// graph mode changed
	virtual void OnGraphMode(UINT newmode);

#ifdef _DEBUG
	virtual void DumpNid(CDumpContext & dc) const;
#endif
	// the depcy list is dirty
	USHORT 			m_fDirtyDepLst:1;	

private:
	// ignore dependency changes?
	USHORT			m_fIgnoreDepcy:1;

	// state of this node
	USHORT			m_state;

	// our assigned registry
	CFileRegistry * m_pregistry;

	// dependency file registry set
	CFileRegSet		m_frsDepcy;	// calc. attributes

	// dependency file set at last build attempt
//	FRHArray		m_lstDepcy;
};

/////////////////////////////////////////////////////////////////////////////////////
// CNidGraphDoc - protocol for applying graph structure to an underlying document //
////////////////////////////////////////////////////////////////////////////////////

class CGraphPainter;
class CNidGraphDoc
{
public:
	// constructor+destructor
	CNidGraphDoc() {}
	virtual ~CNidGraphDoc() {}

	//
	// what is the structure of this graph?
	// the 'protocol', ie. all these methods *must* be implemented in derived class
	//
	virtual USHORT	CRootsInitWalk() = 0;
	virtual BOOL	FNextRoot(NID &) = 0;

	virtual USHORT	CChildrenInitWalk(NID nidNode) = 0;
	virtual BOOL	FNextNid(NID &, ET &) = 0;

	//
	// how is this graph to be drawn?
	//
	virtual CGraphPainter * GetPainter() {ASSERT(FALSE); return NULL;}
	virtual USHORT	GetMaxDepth() {return 0;}
	virtual BOOL 	IsReversed() {return FALSE;}
};

////////////////////////////
// CGraph - generic graph //
////////////////////////////  

// order of performing ops. on graph
#define PrePerform	0x0
#define PostPerform	0x1

// graph operation funcation
typedef BOOL (*GraphOpFn)(CGrNode * pgrn, DWORD & dw, BOOL & fLookChildren);

class CGraph : public CObject, public CGrNfyRx, public CNidGraphDoc
{
	DECLARE_DYNCREATE(CGraph)

public:
	// constructor+destructor
	CGraph();
	virtual ~CGraph();

	// retrieve the properties of this graph
	__inline USHORT CRoots()			{return m_cRoots;}
	__inline CGrNode * Root(USHORT i)	{return m_rgRoots[i];}

	// add and delete root nodes
	void AddRoot(CGrNode * pgrn);
	void DelRoot(CGrNode * pgrn);

	// insert and remove graph nodes
	void InsertNode(CGrNode * pgrn);
	void RemoveNode(CGrNode * pgrn);

	// clear visited (default is all)?
	void ClearVisited( void );

	// CNidGraphDoc implementation for generic graphs
	USHORT	CRootsInitWalk();
	BOOL	FNextRoot(NID & nid);
	USHORT	CChildrenInitWalk(NID nidNode);
	BOOL	FNextNid(NID &, ET &);

	// graph node lookup
	__inline BOOL LookupNode(NID nid, CGrNode * & pgrn)
		{return m_mapNodes.Lookup((void *)nid, (void * &)pgrn);}

	// set graph mode
	UINT SetGraphMode(UINT mode);

	// Rx for graph node change events
	virtual void OnGrNfy(UINT grevt, CGrNode * pgrn, void * pvhint);

	// perform a graph operation 'pfn' over each node in the graph
	// passes the 'dwUser' to the operation
	// performs in the order specified by 'order'
	// starts with 'nid' or all roots if nid == nidNil
	BOOL PerformOperation(GraphOpFn pfn, DWORD & dwUser, UINT order = PrePerform, NID nid = nidNil);

#ifdef _DEBUG
	virtual void Dump(CGrNode * pgrn, int iDepth, CDumpContext & dc) const;
	virtual void Dump(CDumpContext & dc) const;
#endif

	// mode of the graph
	UINT		m_mode;

protected:
	BOOL PerformOperationI(GraphOpFn pfn, DWORD & dwUser, UINT order, CGrNode * pgrn);
   	// void ClearCleared(CGrNode * pgrn);

	CGrNode * * m_rgRoots;		// our array pf root nodes
	USHORT		m_allocRoots;	// size of root array alloc.

	USHORT		m_cRoots;		// count of roots
	USHORT		m_iRoot;		// state of root graph walk
	USHORT		m_iChild;		// state of children graph walk
	CGrNode *	m_pgrnChild;	// current node in walk

	CMapPtrToPtr m_mapNodes;	// our map of the nodes
};

//////////////////////////////////////
// CFileDepGraph - dependency graph //
//////////////////////////////////////

// attributes of dependency graph retrieval
#define AOR_None		0x0		// none
#define AOR_Recurse		0x1		// recursively check dependencies
#define AOR_ChkOpts		0x2		// check for action option changes
#define AOR_Verbose		0x4		// verbose mode, ie. use prompts etc.
#define AOR_PreChk		0x8		// pre-check dependencies, ie. don't reset state
#define AOR_ChkInp		0x10	// check for action input changes
#define AOR_Default		(AOR_Recurse | AOR_ChkOpts | AOR_Verbose)

// type of dependency
#define DEP_Scanned		0x1
#define DEP_Source		0x2
#define DEP_Input		0x3
#define DEP_Output		0x4
#define DEP_Dependency	0x5
#define DEP_Missing		0x6
#define DEP_UserDefined	0x7		// Never scanned or modified except by user.

class CActionSlob;
class CFileDepGraph : public CGraph
{
	DECLARE_DYNCREATE(CFileDepGraph)

public:
	CFileDepGraph(CFileRegistry * pregistry);
	virtual ~CFileDepGraph();

	//
	// Dependency graph modification
	//

	BOOL ModifyDep
	(
		FileRegHandle frhDep,
		CActionSlob * pAction,
		UINT dep,
		BOOL fAdd,
		BOOL fWithAction = TRUE
	);

	// find a dependency 'frhDep'
	//
	// 'pgrn' is the last found CGrNode (last in 'arggrn')
	// 'arygrn' is the accumulated list of CGrNode's that have the dep. (if NULL then find just one == 'pgrn')
	// 'fSearchSets' search in dependency sets?
	BOOL FindDep
	(
		FileRegHandle frhDep,
		CDepGrNode * & pgrn,
		CPtrArray * parygrn = (CPtrArray *)NULL,
		BOOL fSearchSets = FALSE
	);

	//
	// Dependency graph info. retrieval
	//

	void StartPasses();

	// what actions are performed on the dependencies with a state in 'stateFilter' (default is 'not current')?
	// o 'lstFrh' is a list of all files whose state 'match' caused the action addition
	// o 'frhStart' is the dependant to start from (default is 'do all out of date')
	// o 'aor' attributes of action retrieval (default is 'verbose, recurse and check for option changes')
	// returns CMD_ value
	UINT RetrieveBuildActions
	(
		CActionSlobList & lstActions,
		CPtrList & lstFrh,
 		CErrorContext & EC,
		FileRegHandle frhStart = (FileRegHandle)NULL,
		UINT stateFilter = DS_OutOfDate | DS_ForcedOutOfDate,
		UINT aor = AOR_Default
	);

	// what actions 'contribute' to the dependent?
	// o 'lstActions' is a list of actions
	// o 'frhStart' is the dependant to start from
	// return CMD_ value
	UINT RetrieveOutputActions
	(
		CActionSlobList & lstActions,
 		CErrorContext & EC,
		FileRegHandle frhStart
	);

	// CNidGraphDoc implementation for file dependency graphs
	virtual USHORT	CChildrenInitWalk(NID nidNode);
	virtual BOOL	FNextNid(NID &, ET &);

	// should we 'count' the dependency sets as part of our
	// graph document?
	BOOL m_fShowDepSets;

	//
	// File Graph Operations
	//

	// clean, dwUser is a error context (CErrorContext *)
	static BOOL Clean(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren);

	// get all output, dwUser is a an array to hold all output FRHs (CFileRegSet *)
	static BOOL GetAllOutput(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren);
	static BOOL GetAllOutputExceptCustom(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren);

	// get the target files
	static BOOL GetAllTarget(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
	{
		return GetTarget(FALSE, pgrn, dwUser, fLookChildren);
	}

	// get the primary files
	static BOOL GetPrimaryTarget(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
	{
		return GetTarget(TRUE, pgrn, dwUser, fLookChildren);
	}

	// get the primary files
	static BOOL GetPrimaryTargetNoCustom(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
	{
		return GetTarget(TRUE, pgrn, dwUser, fLookChildren, TRUE);
	}

	static BOOL GetCustomOutput(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren);

private:
	// helper
	static BOOL GetTarget(BOOL fPrimary, CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren, BOOL bNoCustom = FALSE);
	 
	// add a dependency relationship
	// o 'frhDpcy' is the file(s) we are dependant on
	// o 'frhDpnt is the dependent file(s)
	// o 'pActionSlob' is the action that should be performed to
	//    make the dependant 'current' wrt the dependency
	BOOL AddDepEdgeI
	(
		FileRegHandle frhDpcy,
		FileRegHandle frhDpnt,
		CActionSlob * pActionSlob = (CActionSlob *)NULL
	);

	// remove a dependency relationship 
	BOOL RemoveDepEdgeI
	(
		FileRegHandle frhDpcy,
		FileRegHandle frhDpnt,
		CActionSlob * pActionSlob = (CActionSlob *)NULL,
		BOOL fAllDepnts = FALSE
	);

	// our list of dep. sets
	CPtrList m_lstDepSets;

	// our assigned registry
	CFileRegistry * m_pregistry;

	// helper for RetrieveBuildActions()
	// returns CMD_ value
	UINT EnumerateBuildActionsI
	(
		CActionSlobList & lstActions,
 		CPtrList & lstFrh,
		CErrorContext & EC,
		CDepGrNode * pgrn,
		UINT stateFilter,
		UINT & aor
	);

	// already prompted to build setting changes?
	BOOL m_fPromptedCheckOptions;
	
	// cannot build list
	CPtrList m_lstCannotBuild;

};

#ifdef _DO_DEBUG_NEW
#define new DEBUG_NEW
#endif

#endif // _INCLUDE_DEPGRAPH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\depgraph.cpp ===
//
// CGrNode, CGraph, CDepGraph
//
// Graph node, dependency graph node, graph and dependency graph classes
//
// [matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "depgraph.h"	// our local header
#include "engine.h"		// CActionSlob
#include "mrdepend.h"
#include "toolsdlg.h"

IMPLEMENT_DYNAMIC(CGraph, CObject)
IMPLEMENT_DYNAMIC(CFileDepGraph, CGraph)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// FRHArray thin array

FRHArray::FRHArray( int n ){
	m_pDepcy = new FileRegHandle[n]; 
	m_nFRH = n;
}

void FRHArray::Replace( int n ){ 
	delete []m_pDepcy;
	m_pDepcy = new FileRegHandle[n]; 
	m_nFRH = n;
}


//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

#ifdef USE_LOCAL_BUILD_HEAP
// graph node local heap
CLclHeap CGrNode::g_heapNodes(50);
#endif

// granularity of allocations
#define C_ALLOC_PARENT	2
#define C_ALLOC_CHILD	12
#define C_ALLOC_ROOT	12
#define C_ALLOC_EDGES	C_ALLOC_CHILD

#ifdef _KIPDEBUG
	int CGrNode::nCount = 0;
#endif

// constructor+destructor
CGrNode::CGrNode(CGraph * pgraph, NID nid, USHORT cChildren /* = 0 */, USHORT iDepth /* = 0 */)
{
	// this graph node's identifier
	m_nid = nid;

	// this graph node's depth
#ifdef DEPGRAPH_VIEW
	m_iDepth = iDepth;
#endif // DEPGRAPH_VIEW

	// initialise
	m_rgChildren = m_rgParents = (CGrNode * *)NULL;
	m_allocChildren = m_allocParents = 0;
	m_rgEdges = (EID *)NULL;

	// layout related
#ifdef DEPGRAPH_VIEW
	m_pgrnAlias = m_pgrnPrev = 	m_pgrnNext = (CGrNode *)NULL;
	m_iParent = 0;
	m_cReversed = 0;
	m_cost = 0xffff;
	m_iPos = 0;
	m_fFake = FALSE;
	m_fWorking = FALSE;
	m_fRecursive = FALSE;
#endif // DEPGRAPH_VIEW

	m_cParents = 0;
	m_cChildren = cChildren;
	m_fVisited = FALSE;
    	// m_fCleared = FALSE;

#ifdef DEPGRAPH_VIEW
	m_pgraph = pgraph;
#endif

	m_GrNfyRx = NULL;

	// pre-allocate some children?
	if (m_cChildren)
	{
		m_allocChildren += m_cChildren;

#ifdef USE_LOCAL_BUILD_HEAP
		m_rgChildren = (CGrNode * *)g_heapNodes.alloc(sizeof(CGrNode *) * m_allocChildren);
		m_rgEdges = (EID *)g_heapNodes.alloc(sizeof(EID) * m_allocChildren);
#else
		m_rgChildren = new CGrNode *[m_allocChildren];
		m_rgEdges = new EID[m_allocChildren];
#endif
	}

#ifdef _KIPDEBUG
	nCount++;
#endif
}

CGrNode::~CGrNode()
{
	// inform that we are being deleted
	InformGrNfyRx(GrEvt_Destroy);
	 
	// delete our storage
#ifdef USE_LOCAL_BUILD_HEAP
	if (m_rgParents)	g_heapNodes.dealloc(m_rgParents);
	if (m_rgChildren)	g_heapNodes.dealloc(m_rgChildren);
	if (m_rgEdges)		g_heapNodes.dealloc(m_rgEdges);
#else
	if (m_rgParents)	delete []m_rgParents;
	if (m_rgChildren)	delete []m_rgChildren;
	if (m_rgEdges)		delete []m_rgEdges;
#endif

}

#ifdef _DEBUG
void CGrNode::AssertValid() const
{
	// validate our storage boundaries
	ASSERT(m_cParents >= 0 && m_cChildren >= 0);

	// validate our storage
	ASSERT(m_rgParents == (CGrNode * *)NULL ||
		   AfxIsValidAddress((const void *)m_rgParents, m_cParents * sizeof(CGrNode *)));

	ASSERT(m_rgChildren == (CGrNode * *)NULL ||
		   AfxIsValidAddress((const void *)m_rgChildren, m_cChildren * sizeof(CGrNode *)));
}

void CGrNode::Dump(CDumpContext & dc) const
{
	// dump node info.
	DumpNid(dc);

	// dump linkage info.
	dc << "Count children : " << m_cChildren << " : Count parents : " << m_cParents << "\r\n";
}						    

void CGrNode::DumpNid(CDumpContext & dc) const
{
	// dump basic node identifier info.
	dc << "NID : " << m_nid << "\r\n";
}
#endif

// add or remove graph node event receivers
void CGrNode::AddGrNfyRx(CGrNfyRx * pgrnfyrx)
{	
	ASSERT( m_GrNfyRx == NULL );
	m_GrNfyRx = pgrnfyrx;
}

void CGrNode::RemoveGrNfyRx(CGrNfyRx * pgrnfyrx)
{
#ifdef _DEBUG
	if( m_GrNfyRx != NULL ){
		ASSERT( m_GrNfyRx == pgrnfyrx );
	}
#endif
	m_GrNfyRx = NULL;
}

void CGrNode::InformGrNfyRx(UINT grevt, void * pvhint)
{
	if( m_GrNfyRx == NULL ) return;
	m_GrNfyRx->OnGrNfy(grevt, this, pvhint);
}

void CGrNode::AddChild(CGrNode * pgrn, EID eid /* = (EID)0 */)
{
	//
	// add a new child to this node
	//

	// allocate our new array of children?
	BOOL fRealloc = m_cChildren >= m_allocChildren;

	CGrNode * * rgChildren = m_rgChildren; EID * rgEdges = m_rgEdges;
	
	// re-alloc?
	if (fRealloc)
	{
		m_allocChildren += C_ALLOC_CHILD;

#ifdef USE_LOCAL_BUILD_HEAP
		rgChildren = (CGrNode * *)g_heapNodes.alloc(sizeof(CGrNode *) * m_allocChildren);
		rgEdges = (EID *)g_heapNodes.alloc(sizeof(EID) * m_allocChildren);
#else
		rgChildren = new CGrNode *[m_allocChildren];
		rgEdges = new EID[m_allocChildren];
#endif

		// move current children
		memcpy(rgChildren, m_rgChildren, m_cChildren * sizeof(CGrNode *));
		memcpy(rgEdges, m_rgEdges, m_cChildren * sizeof(EID));
	}
	 
	// insert child + edge into child + edge list
	rgChildren[m_cChildren] = pgrn;
	rgEdges[m_cChildren] = eid;

	// remember our new array?
	if (fRealloc)
	{

#ifdef USE_LOCAL_BUILD_HEAP
		if (m_rgChildren) g_heapNodes.dealloc(m_rgChildren);
		if (m_rgEdges) g_heapNodes.dealloc(m_rgEdges);
#else
		if (m_rgChildren) delete []m_rgChildren;
		if (m_rgEdges) delete []m_rgEdges;
#endif

		m_rgChildren = rgChildren;
		m_rgEdges = rgEdges;
	}

	// increment our child count
	m_cChildren++;

	// inform
	InformGrNfyRx(GrEvt_AddChild, (void *)pgrn->Nid()); 
	InformGrNfyRx(GrEvt_AddEdge, (void *)eid); 

	//
	// add ourselves as a parent of this node
	//

	// allocate our new array of parents for it?
	fRealloc = pgrn->m_cParents >= pgrn->m_allocParents;
 	CGrNode * * rgParents = pgrn->m_rgParents;
	
	if (fRealloc)
	{
		pgrn->m_allocParents += C_ALLOC_PARENT;

#ifdef USE_LOCAL_BUILD_HEAP
		rgParents = (CGrNode * *)g_heapNodes.alloc(sizeof(CGrNode *) * pgrn->m_allocParents);
#else
		rgParents = new CGrNode *[pgrn->m_allocParents];
#endif

		// move current parents
		memcpy(rgParents, pgrn->m_rgParents, pgrn->m_cParents * sizeof(CGrNode *));
	}

	// insert ourselves as a parent
	rgParents[pgrn->m_cParents] = this;

	// remember our new array?
	if (fRealloc)
	{
#ifdef USE_LOCAL_BUILD_HEAP
		if (pgrn->m_rgParents) g_heapNodes.dealloc(pgrn->m_rgParents);
#else
		if (pgrn->m_rgParents) delete []pgrn->m_rgParents;
#endif

		pgrn->m_rgParents = rgParents;
	}

	// increment their parent count
	pgrn->m_cParents++;

	// inform
	pgrn->InformGrNfyRx(GrEvt_AddParent, (void *)this->Nid());
}

void CGrNode::DelChild(USHORT iChild)
{
	//
	// remove a child (refrenced by index)
	//

	// ensure within our bounds
	ASSERT(m_cChildren > 0 && iChild < m_cChildren);

	// remember the child before removal
	CGrNode * pgrn = m_rgChildren[iChild];
	EID eid = m_rgEdges[iChild];

	// remove this child
	while (iChild + 1 < m_cChildren)
	{
		m_rgChildren[iChild] = m_rgChildren[iChild+1];
		m_rgEdges[iChild] = m_rgEdges[iChild+1];
		iChild++;
	}

	// decrement our child count
	m_cChildren--;

	// inform
	InformGrNfyRx(GrEvt_DelChild, (void *)pgrn->Nid());
	InformGrNfyRx(GrEvt_DelEdge, (void *)eid); 

	// remove ourselves as a parent?
	if (pgrn->m_cParents)
	{
		BOOL fFound = FALSE;
		USHORT iParent = 0;
		while (iParent < pgrn->m_cParents)
		{
			// if found then remove parent
			if (fFound)
				pgrn->m_rgParents[iParent - 1] = pgrn->m_rgParents[iParent];

			// if ~found then search for parent
			else
				fFound = (pgrn->m_rgParents[iParent] == this);

			iParent++;
		}

		// make sure we found the parent
		ASSERT(fFound);

		// decrement their parent count
		pgrn->m_cParents--;

		// inform
		pgrn->InformGrNfyRx(GrEvt_DelParent, (void *)this);
	}
}

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

CDepGrNode::CDepGrNode(CFileDepGraph * pgraph, CFileRegistry * pregistry, FileRegHandle frh)
	: CGrNode(pgraph, (NID)frh)
{
	// store the file registry
	m_pregistry = pregistry;

	// initialise
	m_state = DS_Unknown;
	m_fIgnoreDepcy = pgraph->m_mode != Graph_Stable; 

	if (!m_fIgnoreDepcy)
		(void) m_frsDepcy.CalcAttributes();

	// add ourselves as a Rx of file change events
	// of both the dependent and dependency
	m_pregistry->GetRegEntry(Frh())->AddNotifyRx(this);

	if (!m_fIgnoreDepcy)
		m_frsDepcy.AddNotifyRx(this);

	// dependency list at last build attempt is not dirty
	m_fDirtyDepLst = FALSE;

	// add a reference to this registry entry
#ifndef REFCOUNT_WORK
	g_FileRegistry.AddRegRef(Frh());
#else
	Frh()->AddFRHRef();
#endif

#ifdef _DEBUG_BLD
	TCHAR * pchDep;
	CFileRegEntry * preg = m_pregistry->GetRegEntry(Frh());

	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDep = "set";
	else
		pchDep = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

	TRACE("\r\nCreate <%s> (%lx) in %lx", pchDep, this, m_pregistry);
#endif // _DEBUG_BLD
}

CDepGrNode::~CDepGrNode()
{
	// inform that we are being deleted
	InformGrNfyRx(GrEvt_Destroy);

#ifdef _DEBUG_BLD
	TCHAR * pchDep;
	CFileRegEntry * preg = m_pregistry->GetRegEntry(Frh());

	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDep = "set";
	else
		pchDep = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

	TRACE("\r\nDelete <%s> (%lx) in %lx", pchDep, this, m_pregistry);
 #endif // _DEBUG_BLD

	// remove ourselves as a Rx of file change events
	// of both the dependent and dependency
	m_pregistry->GetRegEntry(Frh())->RemoveNotifyRx(this);
	
	if (!m_fIgnoreDepcy)
		m_frsDepcy.RemoveNotifyRx(this);

	// assert that we don't have any dependencies
#ifndef REFCOUNT_WORK
	ASSERT(m_frsDepcy.GetContent()->IsEmpty());
#else
	ASSERT(m_frsDepcy.IsEmpty());
#endif

	// remove a reference to this registry entry
#ifndef REFCOUNT_WORK
	g_FileRegistry.ReleaseRegRef(Frh());
#else
	Frh()->ReleaseFRHRef();
#endif
}

// graph mode changed
void CDepGrNode::OnGraphMode(UINT newmode)
{
	// what would be our new state?
	BOOL fIgnoreDepcy = newmode != Graph_Stable; 

	// changed?
	if (m_fIgnoreDepcy != (USHORT)fIgnoreDepcy)
	{
		// remove ourselves as a dependency
		m_frsDepcy.RemoveNotifyRx(this);

		// empty our dependency set
		m_frsDepcy.EmptyContent();

		if (!fIgnoreDepcy)
		{
			// turn-off incr. calc. of attributes
			(void) m_frsDepcy.CalcAttributes(FALSE);

			// add new dependencies to our set
			for (USHORT iChild = CChildren(); iChild > 0; iChild--)
			{
				CDepGrNode * pgrnDep = (CDepGrNode *)Child(iChild - 1);
				m_frsDepcy.AddRegHandle(pgrnDep->Frh());
			}

			// turn back on incr. calc. of attributes
			(void) m_frsDepcy.CalcAttributes();

			// update our dependency state
			FigureDepState();

			// add ourselves as a dependency now
			m_frsDepcy.AddNotifyRx(this);
		}

		// dependency list at last build attempt is dirty   
		m_fDirtyDepLst = TRUE;

		m_fIgnoreDepcy = (USHORT)fIgnoreDepcy;
	}
}

// Rx for file change events
void CDepGrNode::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	// which type of file change event?
	switch (idChange)
	{
		// newest timestamp changes?
		case P_NewTStamp:

		// existence of dependencies?
		case P_ExistsOnDisk:

			// update our dependency state...
			FigureDepState();
			break;

		// File set changed.
		case FRI_ADD:
		case FRI_DESTROY:
			FigureDepState();
			break;

#ifdef _DEBUG

#ifndef REFCOUNT_WORK
		// local destroy?
		case FRN_LCL_DESTROY:
			if ((CFileRegistry *)dwHint != m_pregistry)
				break;

			// destroying ourselves?
			ASSERT(hndFileReg != Frh());
			break;

		// global destroy
		case FRN_DESTROY:

			// destroying ourselves?
			ASSERT(hndFileReg != Frh());
			break;
#endif

#endif

		default:
			break;
	}
}

// Rx for changes in dep. connections
void CDepGrNode::InformGrNfyRx(UINT grevt, void * pvhint)
{
	// which type of dep. connection event?
	switch (grevt)
	{
		// changing what are dependant on us?
		case DepGrEvt_AddDpnt:
		case DepGrEvt_DelDpnt:
		{
			break;
		}

		// changing what we depend on?
		case DepGrEvt_AddDpcy:
		case DepGrEvt_DelDpcy:
			
			// do we want to do this now?
			if (!m_fIgnoreDepcy)
			{
				if (grevt == DepGrEvt_AddDpcy)
					m_frsDepcy.AddRegHandle((FileRegHandle)pvhint);
				else
					m_frsDepcy.RemoveRegHandle((FileRegHandle)pvhint);

				// dependency list at last build attempt is dirty   
				m_fDirtyDepLst = TRUE;
			}
			break;

		default:
			break;
	}

	// send out the event (use the base-class to do this)
	CGrNode::InformGrNfyRx(grevt, pvhint);
}

// figure the dependency state
// and sent out an inform if it has changed
void CDepGrNode::FigureDepState()
{
	// cache old state
	UINT oldstate = (UINT)m_state;

	// new state 
	UINT newstate = DS_Unknown;

	// ignore if no dependencies
#ifndef REFCOUNT_WORK
	if (!m_frsDepcy.GetContent()->IsEmpty())
#else
	if (!m_frsDepcy.IsEmpty())
#endif
	{
		BOOL bVal;

		//
		// one of our deps. missing?
		//
		if (m_frsDepcy.GetIntProp(P_ExistsOnDisk, bVal) && !bVal)				
			newstate |= DS_DepMissing;

		// If we are forced out of date then ignore current/out of date stuff
		if ((m_state & DS_ForcedOutOfDate)==0)
		{
			//
			// compare deps. most recent timestamp to our timstamp
			//
		 	CFileRegEntry * pentry = m_pregistry->GetRegEntry(Frh());
			if (pentry->GetIntProp(P_ExistsOnDisk, bVal) && bVal)
			{
				FILETIME ftimeDep, ftimeOur;
				if (m_frsDepcy.GetTimeProp(P_NewTStamp, ftimeDep) &&
					m_pregistry->GetRegEntry(Frh())->GetTimeProp(P_NewTStamp, ftimeOur))
				{
#ifdef FUZZY95
					if (CFileRegistry::MyFuzzyCompareFileTime(&ftimeDep, &ftimeOur) <= 0)
#else
					if (CFileRegistry::MyCompareFileTime(&ftimeDep, &ftimeOur) <= 0)
#endif
						newstate |= DS_Current;
					else
						newstate |= DS_OutOfDate;
				}
			}
			else
			{
				newstate |= DS_OutOfDate;
			}
		}
	}

#ifdef _DEBUG	// this test moved above
	// If we are forced out of date then ignore current/out of date stuff
	if (m_state & DS_ForcedOutOfDate)
	{
		ASSERT((newstate & (DS_Current | DS_OutOfDate))==0);
	}
#endif

	// Actually alter our state now
	m_state &= ~(DS_Current | DS_OutOfDate | DS_DepMissing);
	m_state |= newstate;

	// changed?
	if (m_state != oldstate)
		OnDepStateChanged((UINT)m_state);
}

void CDepGrNode::OnDepStateChanged(UINT state)
{
#ifdef _DEBUG
	if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
	{
		// our state has changed, dump
		DumpNid(afxDump);
	}
#endif

#ifdef BUILD_SYSTEM
	TRACE("\r\n>> Dep State Changed for %s << now ", Frh()->GetFilePath()->GetFullPath() );
	if( m_state & DS_Current )
		TRACE(" %s ", "DS_Current" );
	if( m_state & DS_OutOfDate )
		TRACE(" %s ", "DS_OutOfDate" );
	if( m_state & DS_ForcedOutOfDate )
		TRACE(" %s ", "DS_ForcedOutOfDate" );
	if( m_state & DS_DepMissing )
		TRACE(" %s ", "DS_DepMissing" );
#endif

    ASSERT((m_state & (DS_Current | DS_OutOfDate)) != (DS_Current | DS_OutOfDate));
    ASSERT((m_state & (DS_Current | DS_ForcedOutOfDate)) != (DS_Current | DS_ForcedOutOfDate));

    // If we are out of date then propagate changes to parents
    if (m_state & (DS_OutOfDate | DS_ForcedOutOfDate))
    {
        // Propagate changes to next layer down!!
        for (USHORT iParent = CParents(); iParent > 0; iParent--)
        {
            CDepGrNode * pgrnParent = (CDepGrNode *)Parent(iParent-1);

            UINT depstate = pgrnParent->Depstate();

            // if not out of date, then force out of date
            if ((depstate & ( DS_OutOfDate | DS_ForcedOutOfDate ) ) == 0)
            {
                // Set dep state and recurse on parent
                pgrnParent->SetDepstate((depstate & ~DS_Current) | DS_ForcedOutOfDate); 
                // pgrnParent->OnDepStateChanged((depstate & ~DS_Current) | DS_ForcedOutOfDate);
            }
        }
    }
}

#ifdef _DEBUG
void CDepGrNode::DumpNid(CDumpContext & dc) const
{
	// dump filereghandle info.
	CFileRegEntry * pentry = m_pregistry->GetRegEntry(((CDepGrNode *)this)->Frh());
	ASSERT(pentry != (CFileRegEntry *)NULL);
	pentry->Dump(dc);

	// dump state
	dc << "Dep. State : ";
	UINT state = m_state;
	if (state == DS_Unknown)
	{
		dc << "unknown";
	}
	else
	{
		BOOL fNeedAnd = FALSE;
		while (state != 0)
		{
			if (fNeedAnd)
				dc << " and ";

			if (state & DS_OutOfDate)
			{
				dc << "out of date";
				state &= ~DS_OutOfDate; 
			}
			else
			if (state & DS_DepMissing)
			{
				dc << "dependency missing";
				state &= ~DS_DepMissing; 
			}
			else
			if (state & DS_Current)
			{
				dc << "current";
				state &= ~DS_Current; 
			}
			else
			if (state & DS_ForcedOutOfDate)
			{
				dc << "forced-out";
				state &= ~DS_ForcedOutOfDate; 
			}

			fNeedAnd = TRUE;
		}
	}
	dc << "\r\n";
}
#endif
 
///////////////////////////////////////
// CGraph - generic graph 'protocol' //
///////////////////////////////////////

CGraph::CGraph() :
	m_mapNodes(991)	// increase default hash table size to allow large graphs.
{
	// initialise
	m_rgRoots = (CGrNode * *)NULL;
	m_allocRoots = 0;

	m_cRoots = 0;
	m_mode = Graph_Stable;
}

CGraph::~CGraph()
{
	// delete our roots (we shouldn't have any)
	ASSERT(!m_cRoots);

#ifdef _DEBUG
	if (m_cRoots != 0)
		Dump(afxDump);
#endif

	// delete our storage
#ifdef USE_LOCAL_BUILD_HEAP
	while (m_cRoots > 0)
		CGrNode::g_heapNodes.dealloc(m_rgRoots[--m_cRoots]);
	if (m_rgRoots)	CGrNode::g_heapNodes.dealloc(m_rgRoots);
#else
	int cRoots = m_cRoots; // bug fix
	while (cRoots > 0)
	{
		delete m_rgRoots[--cRoots];
	}
	ASSERT(m_cRoots == 0); // m_cRoots decremented inside d'tor!
	if (m_rgRoots)	delete []m_rgRoots;
#endif
}

#ifdef _DEBUG
void CGraph::Dump(CGrNode * pgrn, int iDepth, CDumpContext & dc) const
{
	// dump node + children
	pgrn->Dump(dc);
	for (USHORT iChild = 0; iChild < pgrn->CChildren(); iChild++)
	{
		// dump depth
		dc << "Depth : " << iDepth;
		Dump(pgrn->Child(iChild), iDepth + 1, dc);
		dc << "\r\n";
	}
}

void CGraph::Dump(CDumpContext & dc) const
{
	for (USHORT iRoot = 0; iRoot < m_cRoots; iRoot++)
	{
		// dump roots
		dc << "Root " << iRoot << " : ";
		Dump(m_rgRoots[iRoot], 0, dc);
		dc << "\r\n\r\n";
	}
} 
#endif

// CNidGraphDoc implementation
USHORT CGraph::CRootsInitWalk()
{
	m_iRoot = 0;
	return CRoots();
}

BOOL CGraph::FNextRoot(NID & nid)
{
	if (m_iRoot >= CRoots())
		return FALSE;

	nid = (NID)Root(m_iRoot++);
	return TRUE;
}

USHORT CGraph::CChildrenInitWalk(NID nidNode)
{
	m_iChild = 0;
	m_pgrnChild = (CGrNode *)nidNode;

	return m_pgrnChild->CChildren();
}

BOOL CGraph::FNextNid(NID & nid, ET & et)
{
	if (m_iChild >= m_pgrnChild->CChildren())
		return FALSE;

	nid = (NID)m_pgrnChild->Child(m_iChild);
	et = m_pgrnChild->Edge(m_iChild++);
	return TRUE;

}

// insert and remove graph nodes
void CGraph::InsertNode(CGrNode * pgrn)
{
#ifdef _DEBUG
	void * pvDummy;
#endif
	ASSERT(!m_mapNodes.Lookup((void *)pgrn->Nid(), pvDummy));

	// make sure we are informed of changes
	pgrn->AddGrNfyRx(this);

	// is this a root?
	if (pgrn->CParents() == 0)
		AddRoot(pgrn);
 	 
	// remember this
	m_mapNodes.SetAt((void *)pgrn->Nid(), pgrn);

#ifdef _DEBUG
	if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
	{
		TRACE("\r\n>> Insert node <<"); pgrn->Dump(afxDump);
	}
#endif
}

void CGraph::RemoveNode(CGrNode * pgrn)
{
#ifdef _DEBUG
	void * pvDummy;
#endif
	ASSERT(m_mapNodes.Lookup((void *)pgrn->Nid(), pvDummy));

	// is this a root?
	if (pgrn->CParents() == 0)
		DelRoot(pgrn);

	// make sure we are no longer informed
	pgrn->RemoveGrNfyRx(this);

	// don't remember this
	m_mapNodes.RemoveKey((void *)pgrn->Nid());

#ifdef _DEBUG
	if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
	{
		TRACE("\r\n>> Remove node <<"); pgrn->Dump(afxDump);
	}
#endif
}

void CGraph::AddRoot(CGrNode * pgrn)
{
	ASSERT(pgrn->CParents() == 0);

	// allocate our new array of children?
	BOOL fRealloc = m_cRoots >= m_allocRoots;
	CGrNode * * rgRoots = m_rgRoots;

	// re-alloc?
	if (fRealloc)
	{
		m_allocRoots += C_ALLOC_ROOT;

#ifdef USE_LOCAL_BUILD_HEAP
		rgRoots = (CGrNode * *)CGrNode::g_heapNodes.alloc(sizeof(CGrNode *) * m_allocRoots);
#else
		rgRoots = new CGrNode *[m_allocRoots];
#endif

		// move our current roots
		memcpy(rgRoots, m_rgRoots, m_cRoots * sizeof(CGrNode *));
	}

	// insert this root
	rgRoots[m_cRoots] = pgrn;

	// remember our new array?
	if (fRealloc)
	{
#ifdef USE_LOCAL_BUILD_HEAP
		if (m_rgRoots) CGrNode::g_heapNodes.dealloc(m_rgRoots);
#else
		if (m_rgRoots) delete []m_rgRoots;
#endif

		m_rgRoots = rgRoots;
	} 

	// increment our root count
	m_cRoots++;

#ifdef _DEBUG
	if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
	{
		TRACE("\r\n>> Add root <<"); pgrn->Dump(afxDump);
	}
#endif
}

void CGraph::DelRoot(CGrNode * pgrn)
{
	BOOL fFound = FALSE;
	int iRoot = 0;
	while (iRoot < m_cRoots)
	{
		// if found then remove parent
		if (fFound)
			m_rgRoots[iRoot - 1] = m_rgRoots[iRoot];

		// if ~found then search for parent
		else
			fFound = (m_rgRoots[iRoot] == pgrn);

		iRoot++;
	}

	// make sure we found the root
	ASSERT(fFound);

	// decrement the root count
	m_cRoots--;

#ifdef _DEBUG
	if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
	{
		TRACE("\r\n>> Delete root <<"); pgrn->Dump(afxDump);
	}
#endif
}

#if 0
void CGraph::ClearCleared(CGrNode * pgrn)
{
    if (pgrn->m_fCleared)
    {
        pgrn->m_fCleared = FALSE;
		for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			ClearCleared(pgrn->Child(iChild-1));
    }
}

void CGraph::ClearVisited(CGrNode * pgrn /* = (CGrNode *)NULL */)
{
	if (pgrn == (CGrNode *) NULL)
	{
		for (USHORT iRoot = CRoots(); iRoot > 0; iRoot--)
			ClearVisited(Root(iRoot-1));

		for (iRoot = CRoots(); iRoot > 0; iRoot--)
			ClearCleared(Root(iRoot-1));
	}
	else
	{
        if (pgrn->m_fCleared)
            return;

		pgrn->m_fVisited = FALSE;
        pgrn->m_fCleared = TRUE;
		for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			ClearVisited(pgrn->Child(iChild-1));
	}
} 
#else
// although originally writen to recursivly clear flags, this routine was only
// used to clear the enbtire dep graph. It should only be used that way.
void CGraph::ClearVisited( void )
{
	void *p;
	void *pVal;
	CGrNode * pgrn;

	// iterate over all nodes in this graph. flipping the visited bit to false.
	POSITION pos = m_mapNodes.GetStartPosition();
	while( pos != (POSITION)NULL ) {
		m_mapNodes.GetNextAssoc( pos, p, pVal );
		pgrn = (CGrNode *)pVal;
		pgrn->m_fVisited = FALSE;
	}
}
#endif


// Rx for graph node change events
void CGraph::OnGrNfy(UINT grevt, CGrNode * pgrn, void * pvhint)
{
	switch (grevt)
	{
		case GrEvt_AddParent:
			// no longer a root? 
			if (pgrn->CParents() == 1)
				DelRoot(pgrn);
#ifdef _DEBUG
			if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
			{
				TRACE("\r\n>> Add parent to <<"); pgrn->Dump(afxDump);
				TRACE("\r\n>>            of <<"); ((CGrNode *)pvhint)->Dump(afxDump);
			}
#endif
			break;

		case GrEvt_DelParent:
			// become a root?
			if (pgrn->CParents() == 0)
				AddRoot(pgrn);

#ifdef _DEBUG
			if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
			{
				TRACE("\r\n>> Delete parent from <<"); pgrn->Dump(afxDump);
				TRACE("\r\n>>                 of <<"); ((CGrNode *)pvhint)->Dump(afxDump);
			}
#endif
 			break;

		case GrEvt_AddChild:
#ifdef _DEBUG
			if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
			{
				TRACE("\r\n>> Add child to <<"); pgrn->Dump(afxDump);
				TRACE("\r\n>>           of <<"); ((CGrNode *)pvhint)->Dump(afxDump);
			}
#endif
			break;

		case GrEvt_DelChild:

#ifdef _DEBUG
			if (g_buildengine.m_dwDebugging & DBG_BS_GRP)
			{
				TRACE("\r\n>> Delete child from <<"); pgrn->Dump(afxDump);
				TRACE("\r\n>>                of <<"); ((CGrNode *)pvhint)->Dump(afxDump);
			}
#endif
			break;

		case GrEvt_Destroy:
			RemoveNode(pgrn);
			break;

		default:
			break;
	}
}

// set graph mode
UINT CGraph::SetGraphMode(UINT mode)
{
	UINT oldmode = m_mode;
	m_mode = mode;

	// loop through and tell them of this change
	POSITION pos = m_mapNodes.GetStartPosition();
	while (pos != (POSITION)NULL)
	{
		void * key; CGrNode * pgrn;
		m_mapNodes.GetNextAssoc(pos, key, (void * &)pgrn); 
		pgrn->OnGraphMode(m_mode);
	}

	return oldmode;	// return old mode
}

BOOL CGraph::PerformOperationI
(
	GraphOpFn pfn,
	DWORD & dw,
	UINT order,
	CGrNode * pgrn
)
{
 	// visited
	pgrn->m_fVisited = TRUE;

	ASSERT(pfn);
	ASSERT(pgrn != (CGrNode *)NULL);

	BOOL fLookChildren = TRUE;	// enumerate kids?

	// perform a pre-op.?
	if (order == PrePerform)
		if (!(*pfn)(pgrn, dw, fLookChildren))
			return FALSE;	// failed to perform op.

	// enumerate kids
	if (fLookChildren)
	{
		for (USHORT iChild = 0; iChild < pgrn->CChildren(); iChild++)
		{
			CGrNode * pgrnChild = pgrn->Child(iChild);
			if (!pgrnChild->m_fVisited)
				if (!PerformOperationI(pfn, dw, order, pgrnChild))
					return FALSE;	// failed to perform op. for child
		}
	}

	// perform a post-op.
	if (order == PostPerform)
		if (!(*pfn)(pgrn, dw, fLookChildren))
			return FALSE;	// failed to perform op.

	return TRUE;	// ok
}

BOOL CGraph::PerformOperation
(
	GraphOpFn pfn,
	DWORD & dw,
	UINT order /* = PrePerform */,
	NID nid /* = nidNil */
)
{
	ASSERT(pfn);

	// for each of these nodes construct a list of actions, don't visit nodes twice
    // which may happen given multiple starts
	ClearVisited();

	if (nid == nidNil)
	{
		// perform operation for roots
		for (USHORT iRoot = 0; iRoot < m_cRoots; iRoot++)
			if (!PerformOperationI(pfn, dw, order, m_rgRoots[iRoot]))
				return FALSE;	// failed to perform op. for root
	} 
	else
	{
		// perform op. for select node
		CGrNode * pgrn;
		if (!LookupNode(nid, pgrn) ||
			!PerformOperationI(pfn, dw, order, pgrn))
			return FALSE;	// failed to find node or perform op.
	}

	return TRUE;	// ok
}

///////////////////////////////////////////
// Default graph ops
///////////////////////////////////////////

///////////////////////////////////////////
// CFileDepGraph - file dependency graph //
///////////////////////////////////////////

CFileDepGraph::CFileDepGraph(CFileRegistry * pregistry)
{
	// assign our registry
	m_pregistry = pregistry;

	// don't show dep. sets by default
	m_fShowDepSets = FALSE;
}

CFileDepGraph::~CFileDepGraph()
{
}

BOOL CFileDepGraph::ModifyDep
(
	FileRegHandle frhDep,
	CActionSlob * pAction,
	UINT dep,
	BOOL fAdd,
	BOOL fWithAction /* = TRUE */
)
{
	// what kind of dep.?
	switch (dep)
	{
		case DEP_Input:
		case DEP_Source:
		{
			// 
			// add this input or source dep. to each of the outputs
			//
			FileRegHandle frhOut;
			CFileRegSet * pfrsOutput = pAction->GetOutput();
			CWordArray * paryOutputAttrib = pAction->GetOutputAttrib();
			int i = 0;

			pfrsOutput->InitFrhEnum();
			while ((frhOut = pfrsOutput->NextFrh()) != (FileRegHandle)NULL)
			{
				BOOL fWithAction = !!paryOutputAttrib->GetAt(i++);
				CActionSlob * pEdgeAction = fWithAction ? pAction : (CActionSlob *)NULL;

				if (fAdd)
				{
					if (!AddDepEdgeI(frhDep, frhOut, pEdgeAction))
#ifndef REFCOUNT_WORK
						return FALSE;
#else
					{
						frhOut->ReleaseFRHRef();
						return FALSE;
					}
#endif
				}
				else
				{
					if (!RemoveDepEdgeI(frhDep, frhOut, pEdgeAction, TRUE /* propagate */))
#ifndef REFCOUNT_WORK
						return FALSE;
#else
					{
						frhOut->ReleaseFRHRef();
						return FALSE;
					}
#endif
				}
#ifdef REFCOUNT_WORK
				frhOut->ReleaseFRHRef();
#endif
			}
		
			break;
		}

		case DEP_Output:
		{
			//
			// remove scanned/source/missing dependencies (en masse) to this output
			//
			// (*only* for non-target tools, ie. ones that scan!)

			if (!fAdd && !pAction->m_pTool->m_fTargetTool)
			{
				CFileRegSet * pfrsScanned = pAction->GetScannedDep();

				if (!RemoveDepEdgeI((FileRegHandle)pfrsScanned, frhDep, (CActionSlob *)NULL, TRUE /* propagate */))
					return FALSE;

				// this set doesn't need to calc attributes!
				// OLYMPUS 13658: However we do need to calc attributes if this set is
				// used by some other action, i.e it has some parents after removing the edge above.
				// So we can only switch off calc of attributes when the set has 0 parents.
                CDepGrNode * pgrnDepcy;
				if (FindDep(pfrsScanned, pgrnDepcy))
				{
					if (pgrnDepcy->CParents() == 0)
						pfrsScanned->CalcAttributes(FALSE);

				}

				CFileRegSet * pfrsSource = pAction->GetSourceDep();

				if (!RemoveDepEdgeI((FileRegHandle)pfrsSource, frhDep))
					return FALSE;

				CFileRegSet * pfrsMissing = pAction->GetMissingDep();

				if (!RemoveDepEdgeI((FileRegHandle)pfrsMissing, frhDep, (CActionSlob *)NULL, TRUE /* propagate */))
					return FALSE;

                // Remove source deps originally added as missing/scanned
                // deps. 
				FileRegHandle frhSrcDep;
				pfrsSource->InitFrhEnum();
				while ((frhSrcDep = pfrsSource->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					if (pAction->GetMissingDep()->RegHandleExists(frhSrcDep) ||
						pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
						if (!RemoveDepEdgeI(frhSrcDep, frhDep))
							return FALSE;
#else
				{
					if (pAction->GetMissingDep()->RegHandleExists(frhSrcDep) ||
						pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
					{
						if (!RemoveDepEdgeI(frhSrcDep, frhDep))
						{
							frhSrcDep->ReleaseFRHRef();
							return FALSE;
						}
					}

					frhSrcDep->ReleaseFRHRef();
				}
#endif
 			}

			//
			// 
			// add each of the inputs to this output
			//
			FileRegHandle frhIn;
			CFileRegSet * pfrsInput = pAction->GetInput();

			CActionSlob * pEdgeAction = fWithAction ? pAction : (CActionSlob *)NULL;
	
			pfrsInput->InitFrhEnum();

			//
			// remove out input->output dep. first
			//
			if (!fAdd)
			{
				while ((frhIn = pfrsInput->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					if (!RemoveDepEdgeI(frhIn, frhDep, pEdgeAction, TRUE /* propagate */))
						return FALSE;
#else
				{
					if (!RemoveDepEdgeI(frhIn, frhDep, pEdgeAction, TRUE /* propagate */))
					{
						frhIn->ReleaseFRHRef();
						return FALSE;
					}
					frhIn->ReleaseFRHRef();
				}
#endif
			}

			//
			// can we find this output in a dep. set?
			//
			CDepGrNode * pgrnDep;

			// find action for the dependents
			CPtrArray aryDeps;
			if (FindDep(frhDep, pgrnDep, &aryDeps, TRUE))
			{
				int i = aryDeps.GetSize();
				while (i > 0)
				{
					pgrnDep = (CDepGrNode *)aryDeps.GetAt(--i);
					if (pgrnDep->CParents())
					{
						// action is the 1st edge of our 1st parent
						pgrnDep = (CDepGrNode *)pgrnDep->Parent(0);

						CActionSlob * pActionDep = (CActionSlob *)pgrnDep->Edge(0);
						// ASSERT(pActionDep != (CActionSlob *)NULL);

						if (pActionDep != (CActionSlob *)NULL)
						{

							//
							// make this a source dep.
							//
							if (fAdd)
							{
								if (!pActionDep->AddSourceDep(frhDep))
									return FALSE;
							}
							//
							// can we find this output in the source dep. set?
							// remove as a source dep. if it originated from the
							// scanned or missing dep. otherwise leave it, we
							// didn't add it as a source dep. originally!
							//
							else
							if (pActionDep->GetSourceDep()->RegHandleExists(frhDep) &&
								(pActionDep->GetMissingDep()->RegHandleExists(frhDep) ||
								pActionDep->GetScannedDep()->RegHandleExists(frhDep))
								)
							{
								if (!pActionDep->RemoveSourceDep(frhDep))
									return FALSE;
							}
						}
					}
				}
			}

			//
			// add our input->output dep. last
			//
	 		if (fAdd)
			{
				while ((frhIn = pfrsInput->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					if (!AddDepEdgeI(frhIn, frhDep, pEdgeAction))
						return FALSE;
#else
				{
					if (!AddDepEdgeI(frhIn, frhDep, pEdgeAction))
					{
						frhIn->ReleaseFRHRef();
						return FALSE;
					}
					frhIn->ReleaseFRHRef();
				}
#endif
			}

			//
			// add scanned/missing dependencies (en masse) to this output
			//
			// (*only* for non-target tools, ie. ones that scan!)
			//
			if (fAdd && !pAction->m_pTool->m_fTargetTool)
			{
				CFileRegSet * pfrsScanned = pAction->GetScannedDep();

				if (!AddDepEdgeI((FileRegHandle)pfrsScanned, frhDep))
					return FALSE;

				// make sure we this set calc's attributes!
				(void)pfrsScanned->CalcAttributes();

				CFileRegSet * pfrsSource = pAction->GetSourceDep();

				if (!AddDepEdgeI((FileRegHandle)pfrsSource, frhDep))
					return FALSE;

				CFileRegSet * pfrsMissing = pAction->GetMissingDep();

				if (!AddDepEdgeI((FileRegHandle)pfrsMissing, frhDep))
					return FALSE;

                // Add scanned/missing deps that are really source deps
				FileRegHandle frhSrcDep;
				pfrsSource->InitFrhEnum();
				while ((frhSrcDep = pfrsSource->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					if (pAction->GetMissingDep()->RegHandleExists(frhSrcDep) ||
						pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
						if (!AddDepEdgeI(frhSrcDep, frhDep))
							return FALSE;
#else
				{
					if (pAction->GetMissingDep()->RegHandleExists(frhSrcDep) ||
						pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
					{
						if (!AddDepEdgeI(frhSrcDep, frhDep))
						{
							frhSrcDep->ReleaseFRHRef();
							return FALSE;
						}
					}
					frhSrcDep->ReleaseFRHRef();
				}
#endif
			}

			break;
		}

		case DEP_Scanned:
			break;	// no nothing

		default:
			break;	// no nothing
	}

	return TRUE;	// done 
}

// add a dependency relationship
// o 'frhDpcy' is the file(s) we are dependant on
// o 'frhDpnt is the dependent file(s)
// o 'pActionSlob' is the action that should be performed to
//    make the dependant 'current' wrt the dependency
BOOL CFileDepGraph::AddDepEdgeI
(
	FileRegHandle frhDpcy,
	FileRegHandle frhDpnt,
	CActionSlob * pAction /* = (CActionSlob *)NULL*/
)
{
	// ignore the joining the same files (this is a no-op)
	if (frhDpcy == frhDpnt)
		return TRUE;	// pretend that we've done it

#if 0
#pragma message( "Check for library as input" )
	if (frhDpcy->IsNodeType(CFileRegNotifyRx::nodetypeRegFile))
		ASSERT( 0 != _tcsicmp(frhDpcy->GetFilePath()->GetExtension(), ".lib" ) );
#endif

	// get a node for the dependency and one for the dependent,
	// else create one....
	CDepGrNode * pgrnDepcy, * pgrnDepnt;
	if (!FindDep(frhDpcy, pgrnDepcy))
	{
		// create and place in graph
		pgrnDepcy = new CDepGrNode(this, m_pregistry, frhDpcy);
		InsertNode(pgrnDepcy);

		// add to our list of sets?
		CFileRegEntry * preg = m_pregistry->GetRegEntry(frhDpcy);
		if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		{
			ASSERT(m_lstDepSets.Find(preg) == (POSITION)NULL);
			m_lstDepSets.AddTail(preg);
		}
	}

	if (!FindDep(frhDpnt, pgrnDepnt))
	{
		// create and place in graph
		pgrnDepnt = new CDepGrNode(this, m_pregistry, frhDpnt);
		InsertNode(pgrnDepnt);

		// add to our list of sets?
		CFileRegEntry * preg = m_pregistry->GetRegEntry(frhDpnt);
		if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		{
			ASSERT(m_lstDepSets.Find(preg) == (POSITION)NULL);
			m_lstDepSets.AddTail(preg);
		}
	}

	// connect dependency (child) <- dependant (parent)
	// with the action (if one exists) as the edge

	// make sure we haven't already done this
	for (USHORT iChild = pgrnDepnt->CChildren(); iChild > 0; iChild--)
	{
		if (pgrnDepcy == pgrnDepnt->Child(iChild-1))
			return TRUE;	// already performed addition
	}

#ifdef _DEBUG_BLD
	// trace this
	TCHAR * pchDepcy, * pchDepnt;
	CFileRegEntry * preg;
	
	preg = m_pregistry->GetRegEntry(frhDpcy);
	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDepcy = "set";
	else
		pchDepcy = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

 	preg = m_pregistry->GetRegEntry(frhDpnt);
	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDepnt = "set";
	else
		pchDepnt = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

	TRACE("\r\nAdd <%s>:%lx (%lx) to <%s>:%lx (%lx) in %lx", pchDepcy, frhDpcy, pgrnDepcy, pchDepnt, frhDpnt, pgrnDepnt, m_pregistry);
#endif // _DEBUG_BLD

	pgrnDepnt->AddChild(pgrnDepcy, (EID)pAction);

    // Now need to propagate dep state to new node!!!
    if (pgrnDepcy->Depstate() & (DS_OutOfDate | DS_ForcedOutOfDate))
    {
        UINT depstate = pgrnDepnt->Depstate();

        if ((depstate & DS_ForcedOutOfDate) == 0)
        {
            pgrnDepnt->SetDepstate((depstate & ~DS_Current) | DS_ForcedOutOfDate);
            // pgrnDepnt->OnDepStateChanged((depstate & ~DS_Current) | DS_ForcedOutOfDate); 
        }
    }
    
	return TRUE;	// success
}

// remove a dependency relationship
BOOL CFileDepGraph::RemoveDepEdgeI
(
	FileRegHandle frhDpcy,
	FileRegHandle frhDpnt,
	CActionSlob * pAction /* = (CActionSlob *)NULL*/,
	BOOL fAllDepnts /* = FALSE */
)
{
	// get a node for the dependency and one for the dependent,
	// and delete them
	// (automatic removal and disconnection from graph...)
	CDepGrNode * pgrnDepcy, * pgrnDepnt;
	if (!FindDep(frhDpcy, pgrnDepcy) ||
		!FindDep(frhDpnt, pgrnDepnt))
	{
		// already removed....
		return TRUE;
	}

		// ignore the joining the same files (this is a no-op)
	if (frhDpcy == frhDpnt)
	{
		// We may need to remove this node if this is joining the same files and the node
		// has no other children (but maybe some parents)
		if (pgrnDepnt->CChildren() == 0)
		{
			// Remove any parents
			for (USHORT iParent = pgrnDepcy->CParents(); iParent > 0; iParent--)
			{
				pgrnDepnt = (CDepGrNode *)pgrnDepcy->Parent(iParent - 1);
 				RemoveDepEdgeI(frhDpcy, pgrnDepnt->Frh());
 			}
		}

		return TRUE;	// pretend that we've done it
	}

	// disconnect dependency
	for (USHORT iChild = pgrnDepnt->CChildren(); iChild > 0; iChild--)
	{
		// search for this
		if (pgrnDepcy == pgrnDepnt->Child(iChild - 1))
		{
			// delete child
			pgrnDepnt->DelChild(iChild - 1);
			break;
		}
	}

#ifdef _DEBUG_BLD
	// trace this
	TCHAR * pchDepcy, * pchDepnt;
	CFileRegEntry * preg;

	preg = m_pregistry->GetRegEntry(frhDpcy);
	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDepcy = "set";
	else
		pchDepcy = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

 	preg = m_pregistry->GetRegEntry(frhDpnt);
	if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		pchDepnt = "set";
	else
		pchDepnt = (TCHAR *)(const TCHAR *)*preg->GetFilePath();

	TRACE("\r\nRemove <%s>:%lx (%lx) from <%s>:%lx (%lx) in %lx", pchDepcy, frhDpcy, pgrnDepcy, pchDepnt, frhDpnt, pgrnDepnt, m_pregistry);
 #endif // _DEBUG_BLD

	// delete dependency if no longer connected
	if (pgrnDepcy->CParents() == 0 && pgrnDepcy->CChildren() == 0)
	{
		// remove from our list of sets
		CFileRegEntry * preg = m_pregistry->GetRegEntry(frhDpcy);
		if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
		{
			POSITION pos = m_lstDepSets.Find(preg);
			ASSERT(pos != (POSITION)NULL);
			m_lstDepSets.RemoveAt(pos);
		}

		delete pgrnDepcy;
	}

	//
	// Remove if we don't have any parents or children OR
	// If fAllDepnts is TRUE, remove from any parents we have that don't have
	// an action that uses us and we don't have any children.
	//
	if (fAllDepnts && pgrnDepnt->CParents() != 0 && pgrnDepnt->CChildren() == 0)
	{
		//
		// For each parent, find the reference for pgrnDepnt, and check if the
		// associated edge is NULL.
		//
		for (USHORT iParent = pgrnDepnt->CParents(); iParent > 0; iParent--)
		{
			CDepGrNode* pgrnParent = (CDepGrNode *)pgrnDepnt->Parent(iParent - 1);

			//
			// Loop though children of our parent to find ourselves.
			//
			CActionSlob* pParentAction = NULL;
			for (USHORT iChild = pgrnParent->CChildren(); iChild > 0; iChild--)
			{
				if ((CDepGrNode *)pgrnParent->Child(iChild - 1) == pgrnDepnt )
				{
					pParentAction = (CActionSlob*)pgrnParent->Edge(iChild - 1);
					break;
				}
			}
			if (NULL!=pParentAction)
				continue;

			if (!RemoveDepEdgeI(frhDpnt, pgrnParent->Frh()))
				return FALSE;
		}
	}
	else
	{
	 	if (pgrnDepnt->CParents() == 0 && pgrnDepnt->CChildren() == 0)
		{
			// remove from our list of sets
			CFileRegEntry * preg = m_pregistry->GetRegEntry(frhDpnt);
			if (preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
			{
				POSITION pos = m_lstDepSets.Find(preg);
				ASSERT(pos != (POSITION)NULL);
				m_lstDepSets.RemoveAt(pos);
			}

			delete pgrnDepnt;
		}
	}

	return TRUE;	// success
}

BOOL CFileDepGraph::FindDep
(
	FileRegHandle frhDep,
	CDepGrNode * & pgrn,	// a CDepGrNode
	CPtrArray * parygrn,	// accumulator of CDepGrNode's
	BOOL fSearchSets		/* = FALSE */
)
{
	BOOL fFound = FALSE;

	// can we find it as a 'single' node?
	if (LookupNode((NID)frhDep, (CGrNode * &)pgrn))
		return !fSearchSets;	// found... return whether found in a set

	// search our sets?
	if (fSearchSets)
	{
		POSITION pos = m_lstDepSets.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CFileRegSet * pfrsSet = (CFileRegSet *)m_lstDepSets.GetNext(pos);
			if (pfrsSet->RegHandleExists(frhDep) &&
				FindDep((FileRegHandle)pfrsSet, pgrn, parygrn)
			   )
			{
				fFound = TRUE;

				// found one, make a note and .. carry on searching?
				if (parygrn == (CPtrArray *)NULL)
					break;	// no!

				parygrn->Add(pgrn);
			}
		}
	}

	return fFound;	// not found
}

void CFileDepGraph::StartPasses()
{
	// use a different action marker than the last time we did the passes
	CActionSlob::m_wActionMarker++;

	// clear our 'cannot build' list
	m_lstCannotBuild.RemoveAll();
}

// what actions 'contribute' to the dependent?
// o 'lstActions' is a list of actions
// o 'frhStart' is the dependant to start from
// return CMD_ value
UINT CFileDepGraph::RetrieveOutputActions
(
	CActionSlobList & lstActions,
 	CErrorContext & EC,
	FileRegHandle frhStart
)
{
	ASSERT(frhStart != (FileRegHandle)NULL);

	// look for this in our graph
	CDepGrNode * pgrn;
	if (!FindDep(frhStart, pgrn))
		return CMD_Error;

	// remove existing ones
	lstActions.RemoveAll();

	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CActionSlob * pAction = (CActionSlob *)pgrn->Edge(iChild-1);
		if (pAction != (CActionSlob *)NULL)
			lstActions.AddTail(pAction);
	}

	return CMD_Complete;
}

// what actions are performed on the dependencies with a state in 'stateFilter' (default is 'not current')?
// o 'frhStart' is the dependant to start from (default is 'do all out of date')
UINT CFileDepGraph::RetrieveBuildActions
(
	CActionSlobList & lstActions,
	CPtrList & lstFrh,
 	CErrorContext & EC,
	FileRegHandle frhStart /* = (FileRegHandle)NULL*/,
	UINT stateFilter /* = DS_OutOfDate */,
	UINT aor /* = AOR_Default */
)
{	
	// initialise
	m_fPromptedCheckOptions = !(aor & AOR_Verbose);

    // for each of these nodes construct a list of actions, don't visit nodes twice
    // which may happen given multiple starts
    ClearVisited();

	UINT cmdRet = CMD_Complete;

	ASSERT(NULL != g_pActiveProject);
	CPath pathIdb =  
		g_pActiveProject->GetMrePath(g_pActiveProject->GetActiveConfig());

	// Minimal rebuild dependency interface.
	IMreDependencies* pMreDepend = 
		IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);

	// nodes to start from?
	CPtrList lstStartNodes;
	if (frhStart == (FileRegHandle)NULL)
	{
		// any roots?
		USHORT iRoot = CRoots();
		if (iRoot == 0)
		{
			if (NULL!=pMreDepend)
				pMreDepend->Release();

			return CMD_Complete;
		}

		for (; iRoot > 0; iRoot--)
		{
			CDepGrNode* pNode = (CDepGrNode *)Root(iRoot-1);
			//
			// Filter out deferred tools.
			//
			if (NULL!=pNode && NULL!=pNode->Edge(0))
			{
				CActionSlob * pAction = (CActionSlob *)pNode->Edge(0);
				DAB dab = pAction->m_pTool->DeferredAction(pAction);
				if (dab == dabDeferred || dab == dabNeverBuild)
				{
					// don't use this one, don't replace
					continue;
				}
			}
			cmdRet = EnumerateBuildActionsI(lstActions, lstFrh, EC, (CDepGrNode *)Root(iRoot-1), stateFilter, aor);
			if (cmdRet != CMD_Complete)
				goto ExitRetrieve;
		}
	}
	else
	{
		// find this node?
		CDepGrNode * pgrnDep;
		if (!FindDep(frhStart, pgrnDep))
		{
			// couldn't find the start node
			cmdRet = CMD_Error;
			goto ExitRetrieve;
		}

		cmdRet = EnumerateBuildActionsI(lstActions, lstFrh, EC, pgrnDep, stateFilter, aor);
		if (cmdRet != CMD_Complete)
			goto ExitRetrieve;
	}

ExitRetrieve:

	if (NULL!=pMreDepend)
		pMreDepend->Release();

	// return command code
	return cmdRet;
}

extern BOOL g_bBatchBuildInProgress;
UINT CFileDepGraph::EnumerateBuildActionsI
(
	CActionSlobList & lstActions,
	CPtrList & lstFrh,
 	CErrorContext & EC,
	CDepGrNode * pgrn,
	UINT stateFilter,
	UINT & aor
)
{	
	// make sure we have up-to-date
	// timestamps prior to getting the
	// dependency state
	if (!pgrn->m_fVisited)
		(void) m_pregistry->GetRegEntry(pgrn->Frh())->UpdateAttributes();	// does nothing if being watched

	// visited
	pgrn->m_fVisited = TRUE;

	if (pgrn->CChildren() == 0)
		return CMD_Complete;

	int cVisited = 0;

	//
	// See if dependencies need to be updated.
	//
    CActionSlob * pAction = (CActionSlob *)pgrn->Edge(0);
	if ( NULL != pAction )
	{
		if ( !pAction->IsDepInfoInitialized() )
		{
			pAction->UpdateDepInfo();
		}
	}

	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CDepGrNode * pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);

		// enumerate actions of our child?
		// o recursive and child not visited
		// (depth first, post-order)
		if ((aor & AOR_Recurse) && !pgrnChild->m_fVisited)
		{
			UINT cmdRet = EnumerateBuildActionsI(lstActions, lstFrh, EC, pgrnChild, stateFilter, aor);
			if (cmdRet != CMD_Complete)
				return cmdRet;

			cVisited++;
		}
	}


	// our dependency state check
	// o dependant state is a subset of our filter?
	// pgrn->FigureDepState( );
	UINT depState = pgrn->Depstate();

	if ((depState & DS_ForcedOutOfDate) != 0)
	{
		if ((stateFilter & DS_ForcedOutOfDate) != 0)
		{
			// REVIEW(kperry) just because we want find out what t build, we shouldn't
			//				  set it back in date !
			pgrn->SetDepstate(depState & ~DS_ForcedOutOfDate);
			pgrn->FigureDepState( );
			depState = pgrn->Depstate() | DS_ForcedOutOfDate;
		}
		else if (pAction != NULL)
		{
			UINT oldState = depState;
			pgrn->SetDepstate(depState & ~DS_ForcedOutOfDate);
			pgrn->FigureDepState( );
			depState = ((oldState & stateFilter) == 0) ? pgrn->Depstate() : oldState;
			pgrn->SetDepstate(oldState); // restore old state
		}
	}

	// do we have an action we might want to add?
	if (pAction == (CActionSlob *)NULL)
		return CMD_Complete;
 
	BOOL fAddAction = ((depState & stateFilter) != 0);

	// have we already retrieved this?
	if ( pAction->m_wMark == CActionSlob::m_wActionMarker)
	{
		// be aggressive here, mark our parents as likely to be out of date
		if (fAddAction)
			for (USHORT iParent = pgrn->CParents(); iParent > 0; iParent--)
			{
				CDepGrNode * pgrnParent = (CDepGrNode *)pgrn->Parent(iParent-1);
				
				UINT depState = pgrnParent->Depstate();

				// if current, then force out of date
				if ((depState & DS_OutOfDate) == 0)
					pgrnParent->SetDepstate((depState & ~DS_Current) | DS_OutOfDate);
			}
		return CMD_Complete;
	}


	// not adding actions?
	// explain why?
	if (!fAddAction)
	{
		// dependency missing....and no actions that may generate them!
		if (pgrn->Depstate() & DS_DepMissing)
		{
			BOOL fIgnDepMissing = (pgrn->Depstate() & ~stateFilter) == DS_DepMissing;	// ignore missing dependency?

			for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			{
				CActionSlob * pEdge = (CActionSlob *)pgrn->Edge(iChild-1);
				if ( pEdge != (CActionSlob *)NULL  )
				{
					CDepGrNode * pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);
					CFileRegEntry * pregChild = m_pregistry->GetRegEntry(pgrnChild->Frh());

					// not exist and an action?
					if ( !pregChild->ExistsOnDisk() )
					{
						// don't ignore this missing dependency
						fIgnDepMissing = FALSE;
						break;
					}
				}
			}

			// ignore missing dependency in the case that we
			// we *only* missing dependencies for non-action
			// relationships, eg. scanned deps.
			fAddAction = fIgnDepMissing;
		}
	}


	// refresh the command-line options
	
	// anything changed?
	BOOL fOptsChnged;
	BOOL fRefreshOk = pAction->RefreshCommandOptions(fOptsChnged, (aor & AOR_PreChk) != 0);

	// o check for options changes and have they possibly changed?
	if ((aor & AOR_ChkOpts) && fRefreshOk && fOptsChnged && !fAddAction)
	{
		// do we want to prompt?
		if (!m_fPromptedCheckOptions)
		{
			m_fPromptedCheckOptions = TRUE;
			int iReply;
			if( g_bBatchBuildInProgress )
				iReply = IDYES;
			else
				iReply = MsgBox(Question, IDS_PROJ_SUGGEST_REBUILD);

			if (iReply == IDNO)
			{
				// don't check for option changes...
				aor &= ~AOR_ChkOpts;
			}
			else if (iReply == IDCANCEL)
			{
				// user cancelled the build
				return CMD_Canceled;
			}
			else
			{
				// user replied yes, add this
				fAddAction = TRUE;

				// Delete the outputs to this action so that we will
				// rebuild this if something goes wrong, as the change
				// in build settings is lost after the first attempted
				// build. Don't delete target outputs, since thats rude.
				if( !pAction->BuildTool()->m_fTargetTool && !(aor & AOR_PreChk) ){
					CFileRegSet * pOutput = pAction->GetOutput();
					CFileRegEntry *frh = (CFileRegEntry *)pOutput->GetFirstFrh();
					if( frh != NULL ){
						frh->DeleteFromDisk();
						frh->ReleaseFRHRef();
					}
				}
			}
		}
		else
		{
			// already prompted and the answer
			// must have been yes, add this
			fAddAction = TRUE;

            // Delete the outputs to this action so that we will
            // rebuild this if something goes wrong, as the change
            // in build settings is lost after the first attempted
            // build
			if( !pAction->BuildTool()->m_fTargetTool && !(aor & AOR_PreChk) ){
				CFileRegSet * pOutput = pAction->GetOutput();
				CFileRegEntry *frh = (CFileRegEntry *)pOutput->GetFirstFrh();
				if( frh != NULL ){
					frh->DeleteFromDisk();
					frh->ReleaseFRHRef();
				}
			}
		}
	}
/*	
	// o check for action input changes?
	if (!fAddAction &&							// not already adding action?
		(aor & AOR_ChkInp) &&					// want to check intputs?
		(pgrn->Depstate() & DS_Current)	&&		// dep-state current?
		pgrn->m_fDirtyDepLst &&					// possible dep. list change?
		pgrn->DepcyListAtCurr()->GetCount()
	   )
	{
#ifndef REFCOUNT_WORK
		const CPtrList * plstDepcy = pgrn->DepcySet()->GetContent();
		FRHArray *plstOldDepcy = pgrn->DepcyListAtCurr();

		// anything changed?
		if (plstDepcy->GetCount() != plstOldDepcy->GetCount())
#else
		FRHArray *plstOldDepcy = pgrn->DepcyListAtCurr();

		// anything changed?
		if (pgrn->DepcySet()->GetCount() != plstOldDepcy->GetCount())
#endif
		{
			// for sure ...., so add action
			fAddAction = TRUE;
		}
		else
		{
			// compare content to be sure ....
			int n = plstOldDepcy->GetCount();
			int i = 0;
			CFileRegSet * pregset = pgrn->DepcySet();
			ASSERT( NULL != pregset );
			while( i < n ){
			    FileRegHandle frh = plstOldDepcy->GetAt(i);
			    if( pregset->RegHandleExists( frh ) == FALSE ){
					fAddAction = TRUE;
					break;
			    }
			    i++;
			}
		}
	}

  */

	// add the action now?
	if (fAddAction)
	{
		// make sure we don't attempt to retrieve it again
		pAction->m_wMark = CActionSlob::m_wActionMarker;

		// add the file that caused the action
		ASSERT(pgrn->Frh()->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
		lstFrh.AddTail(pgrn->Frh());

		// be aggressive here, mark our parents as likely to be out of date
		for (USHORT iParent = pgrn->CParents(); iParent > 0; iParent--)
		{
			CDepGrNode * pgrnParent = (CDepGrNode *)pgrn->Parent(iParent-1);
			
			UINT depState = pgrnParent->Depstate();

			// if current, then force out of date
			if ((depState & DS_OutOfDate) == 0)
				pgrnParent->SetDepstate((depState & ~DS_Current) | DS_OutOfDate);
		}
	}

	// not adding actions, yet attempted to build all we can?
	// explain why?
	if ( (!(aor & AOR_Recurse) || (cVisited && lstActions.GetCount()== 0)) && (aor & AOR_Verbose) )
	// if ( (!(aor & AOR_Recurse) || (cVisited)) && (aor & AOR_Verbose) )
	{
		// dependency missing....and no actions that may generate them!
		if (pgrn->Depstate() & DS_DepMissing)
		{
			CString strMsg;	// message buffer
			for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			{
				CDepGrNode * pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);
				CFileRegEntry * pregChild = m_pregistry->GetRegEntry(pgrnChild->Frh());

				// exist?
				if (pregChild->ExistsOnDisk())
					continue;

				// loop through deps. and warn about deps. that are missing
				if (pregChild->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
				{
					// report source deps. (headers) that are missing
					FileRegHandle frh;
					((CFileRegSet *)pregChild)->InitFrhEnum();
					while ((frh = ((CFileRegSet *)pregChild)->NextFrh()) != (FileRegHandle)NULL)
					{
						CFileRegFile * pregFile = (CFileRegFile *)m_pregistry->GetRegEntry(frh);
						if (!pregFile->ExistsOnDisk())
						{
							// REVIEW:: this is O(n^3) but only called if build is going to fail anyway
							// Should change to a map.
							if (!m_lstCannotBuild.Find(pregFile))
							{
								EC.AddString(MsgText(strMsg, IDS_CANNOT_BUILD_DEP, (const TCHAR *)*pregFile->GetFilePath()));
								m_lstCannotBuild.AddTail(pregFile);
								g_Spawner.m_dwProjWarning++;
							}
						}
#ifdef REFCOUNT_WORK
						frh->ReleaseFRHRef();
#endif
					}
				}
				else if (pgrnChild->CChildren() == 0)
				{
					// report file that we don't know how to or failed to build
					if (!m_lstCannotBuild.Find(pregChild))
					{
						EC.AddString(MsgText(strMsg, IDS_CANNOT_BUILD_DEP, (const TCHAR *)*pregChild->GetFilePath()));
						m_lstCannotBuild.AddTail(pregChild);
						g_Spawner.m_dwProjWarning++;
					}
				}
			}
		}
	}

	// construct our list of dependencies for when we were
	// last attempted to be built?
	if (pgrn->m_fDirtyDepLst)
	{
//#ifndef REFCOUNT_WORK
#if 1
		//
		// review(tomse): pgrn->DepcySet contains both CFileRegFile's and
		// CFileRegSet's.  Since this algorithm is only interested in top level
		// m_Contents items, it can't use InitFrhEnum/NextFrh.  This should
		// be reviewed.
		//
#ifndef REFCOUNT_WORK
		const CPtrList * plstDepcy = pgrn->DepcySet()->GetContent();
#else
//		const CPtrList * plstDepcy = &pgrn->DepcySet()->m_Contents;
#endif
//		FRHArray * plstOldDepcy = pgrn->DepcyListAtCurr();
//		plstOldDepcy->Replace( plstDepcy->GetCount() );
		
//		int i;		
//		POSITION pos;
//		for( i = 0, pos = plstDepcy->GetHeadPosition(); pos != (POSITION)NULL; i++ ) {
//			plstOldDepcy->SetAt( (FileRegHandle)plstDepcy->GetNext(pos), i);
#else
		CFileRegSet* pregset = pgrn->DepcySet();
		FRHArray * plstOldDepcy = pgrn->DepcyListAtCurr();
		plstOldDepcy->Replace( pregset->GetCount() );
		
		int i;
		FileRegHandle frhTemp = NULL;
		pregset->InitFrhEnum();
		i = 0;
		while ( NULL!=(frhTemp = pregset->NextFrh()) )
		{
			// No file sets expected.
			ASSERT( frhTemp->IsNodeType(CFileRegNotifyRx::nodetypeRegFile));
			plstOldDepcy->SetAt( frhTemp, i);
			frhTemp->ReleaseFRHRef();
			i++;
#endif
		// }

		// dependencies at last build are now clean
		pgrn->m_fDirtyDepLst = FALSE;
	}

	// transfer the actions to the 'master' list
	// versions
	if (fAddAction)
		lstActions.AddTail( pAction );
		
	return CMD_Complete;	// ok
}

// CNidGraphDoc implementation
USHORT CFileDepGraph::CChildrenInitWalk(NID nidNode)
{
	m_iChild = 0;
	m_pgrnChild = (CGrNode *)nidNode;

	// don't count dependency sets
	int iChild = 0, cChild = 0;
	for (;iChild < m_pgrnChild->CChildren(); iChild++)	
	{
		CDepGrNode * pgrn = (CDepGrNode *)m_pgrnChild->Child(iChild);
		CFileRegEntry * preg = g_FileRegistry.GetRegEntry(pgrn->Frh());
		if (!m_fShowDepSets && preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
			continue;

		cChild++;
	}

	return cChild;
}

BOOL CFileDepGraph::FNextNid(NID & nid, ET & et)
{
	NextNidChild:

	if (m_iChild >= m_pgrnChild->CChildren())
		return FALSE;

	CDepGrNode * pgrn = (CDepGrNode *)m_pgrnChild->Child(m_iChild);
	CFileRegEntry * preg = g_FileRegistry.GetRegEntry(pgrn->Frh());
	if (!m_fShowDepSets && preg->IsNodeType(CFileRegNotifyRx::nodetypeRegSet))
	{
		m_iChild++;
		goto NextNidChild;
	}

	nid = (NID)m_pgrnChild->Child(m_iChild);
	et = m_pgrnChild->Edge(m_iChild++);
	return TRUE;
}

///////////////////////////////////////////
// Default file graph ops
///////////////////////////////////////////

BOOL CFileDepGraph::Clean(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
{
	// only clean intermediate files
	if (pgrn->CParents() == 0 || pgrn->CChildren() == 0)
		return TRUE;	// ignore

	// file registry handle
	FileRegHandle frh = ((CDepGrNode *)pgrn)->Frh();
	CFileRegEntry * preg = g_FileRegistry.GetRegEntry(frh);
	ASSERT(preg != (CFileRegEntry *)NULL);

	// only files!
	if (!preg->IsNodeType(CFileRegNotifyRx::nodetypeRegFile))
		return TRUE;	// ignore

	// attempt to delete the file
	(void)g_buildengine.DeleteFile(frh, *(CErrorContext *)dwUser);
	return TRUE;
}

BOOL CFileDepGraph::GetAllOutput(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
{
	// only get output files
	if (pgrn->CChildren() == 0)
		return TRUE;	// ignore

	// file registry handle
	FileRegHandle frh = ((CDepGrNode *)pgrn)->Frh();

	// add to set
	((CFileRegSet *)dwUser)->AddRegHandle(frh);
	return TRUE;
}

BOOL CFileDepGraph::GetAllOutputExceptCustom(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
{
	// only get output files
	if (pgrn->CChildren() == 0)
		return TRUE;	// ignore

	// get our actions that contribute to target
	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CActionSlob * pAction = (CActionSlob *)pgrn->Edge(iChild-1);
		if ( pAction == (CActionSlob *)NULL )
			continue;
		if ( pAction->BuildTool()->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) )
			return TRUE;

	}

	// file registry handle
	FileRegHandle frh = ((CDepGrNode *)pgrn)->Frh();

	// add to set
	((CFileRegSet *)dwUser)->AddRegHandle(frh);
	return TRUE;
}

BOOL CFileDepGraph::GetTarget(BOOL fPrimary, CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren, BOOL bNoCustom )
{
	// only look at children if we think there might be more targets!
	fLookChildren = FALSE;

	// file registry handle
	FileRegHandle frh = ((CDepGrNode *)pgrn)->Frh();

	// get our actions that contribute to target
	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CActionSlob * pAction = (CActionSlob *)pgrn->Edge(iChild-1);

		// want this?
		
		// primary target's *must* have an action!
		if (fPrimary && pAction == (CActionSlob *)NULL)
			continue;

		// must be target-item or no-parents
		BOOL fActionOnTargetItem = pAction == (CActionSlob *)NULL ||
								   pAction->Item()->IsKindOf(RUNTIME_CLASS(CTargetItem)) ||
								   pAction->Item()->IsKindOf(RUNTIME_CLASS(CProject)); 
		
		if (!(pgrn->CParents() == 0 || fActionOnTargetItem))
			continue;

		// front or back?
		BOOL fFront = TRUE;
		
		if (pAction != (CActionSlob *)NULL)
		{
			// *all* deferred tools go at back
			if (pAction->BuildTool()->m_fDeferredTool)
				fFront = FALSE;

			// *all* non-target 'targets' go at back
			else if (!pAction->BuildTool()->m_fTargetTool)
				fFront = FALSE;

			// look in children if we're a non-target or deferred-tool
			// action on a target-item
			if (!fFront && fActionOnTargetItem)
				fLookChildren = TRUE;

			if ( bNoCustom && pAction->BuildTool()->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) )
				continue;
		}
		else
		{
			fFront = FALSE;
		}

		((CFileRegSet *)dwUser)->AddRegHandle(frh, TRUE, fFront);
		break;	// done!
	}

	return TRUE;
}


BOOL CFileDepGraph::GetCustomOutput( CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
{
	BOOL fPrimary= TRUE;
	// only look at children if we think there might be more targets!
	fLookChildren = FALSE;

	// file registry handle
	FileRegHandle frh = ((CDepGrNode *)pgrn)->Frh();

	// get our actions that contribute to target
	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CActionSlob * pAction = (CActionSlob *)pgrn->Edge(iChild-1);

		// want this?
		
		// primary target's *must* have an action!
		if (fPrimary && pAction == (CActionSlob *)NULL)
			continue;

		// must be target-item or no-parents
		BOOL fActionOnTargetItem = pAction == (CActionSlob *)NULL ||
								   pAction->Item()->IsKindOf(RUNTIME_CLASS(CTargetItem)) ||
								   pAction->Item()->IsKindOf(RUNTIME_CLASS(CProject)); 
		
		if (!(pgrn->CParents() == 0 || fActionOnTargetItem))
			continue;

		// front or back?
		BOOL fFront = TRUE;
		
		if (pAction != (CActionSlob *)NULL)
		{
			// *all* deferred tools go at back
			if ( !pAction->BuildTool()->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) )
				continue;

			// *all* non-target 'targets' go at back
			else if (!pAction->BuildTool()->m_fTargetTool)
				fFront = FALSE;

			// look in children if we're a non-target or deferred-tool
			// action on a target-item
			if (!fFront && fActionOnTargetItem)
				fLookChildren = TRUE;
		}
		else
		{
			fFront = FALSE;
		}
		
	    CString strOutput;
		CCustomBuildTool *pTool = (CCustomBuildTool *)pAction->BuildTool();
		pTool->GetCustomBuildStrProp(pAction->Item(), P_CustomOutputSpec, strOutput);
		ExpandMacros(&strOutput,strOutput,pAction,TRUE);
		COptionList lstOutSpec(_T('\t'), FALSE);
		lstOutSpec.SetString((const TCHAR *)strOutput);
		POSITION pos = lstOutSpec.GetHeadPosition();

		while (pos != (POSITION)NULL)
		{
			CString strOutSpec= lstOutSpec.GetNext(pos);
			((CMapStringToPtr *)dwUser)->SetAt(strOutSpec,(void *)fActionOnTargetItem);
		}
		break;	// done!
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\bldslob.cpp ===
//
// Build Slob
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "resource.h"

#include <prjapi.h>
#include <prjguid.h>

#include "bldslob.h"	// our local header
#include "bldnode.h"
#include "vwslob.h"
#include "targdlg.h"
#include "cursor.h"
#include "oleref.h"
#include <utilauto.h>	// For Automation CAutoApp


#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#undef new
#endif

CBuildIt::CBuildIt(BOOL bFireEvents /* = TRUE */)
{
	m_actualErrs = 0;
	m_warns = 0;
	m_bFireEvents = bFireEvents;
	ASSERT(m_depth==0);

	m_depth++;
	m_mapMissingEnvVars.RemoveAll();
	m_mapConfigurationsBuilt.RemoveAll();

	if (m_bFireEvents)
	{
		theApp.m_pAutoApp->FireBeforeBuildStart();
	}
}

CBuildIt::~CBuildIt() {
	CString strVar;
	void *dummy;
	CErrorContext * pEC = g_buildengine.OutputWinEC();
	POSITION pos = m_mapMissingEnvVars.GetStartPosition();

	if (m_bFireEvents) // REVIEW
	{
		if( pos ){
			CString strMissing;
			strMissing.LoadString(IDS_MISSING_ENV_VAR);
			pEC->AddString(strMissing);
		}
		while( pos ){
			m_mapMissingEnvVars.GetNextAssoc(pos,strVar,dummy);
			// dump strVar to output window.
			strVar = "$(" + strVar + ")";
			pEC->AddString(strVar);
		}
	}

	if (m_bFireEvents)
	{
		theApp.m_pAutoApp->FireBuildFinish(m_actualErrs, m_warns);
	}

	m_depth--;
}

CMapStringToPtr  CBuildIt::m_mapConfigurationsBuilt;
CMapStringToPtr  CBuildIt::m_mapMissingEnvVars;
int 			 CBuildIt::m_actualErrs = -1;
int 			 CBuildIt::m_warns = -1;
int 			 CBuildIt::m_depth = 0;
BOOL			 CBuildIt::m_bFireEvents = FALSE;

#define MENU_TEXT_CCH 200

#define SCC_FOLDERS

IMPLEMENT_SERIAL(CBuildSlob, CProjSlob, 1)

BOOL CBuildSlob::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (nID == IDM_SLOB_DEFAULTCMD && nCode == CN_COMMAND)
	{
		// If we represent a folder then let the project window code do the default thing
		if (!GetContentList()->IsEmpty())
			return FALSE;
	}

	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		switch (nID)
		{
		case IDM_PROJITEM_OPEN:
			OnOpenItem();
			return TRUE;
		case IDM_PROJITEM_CCOMPILE:
			OnCompileItem();
			return TRUE;
		case IDM_PROJITEM_CBUILD:
			OnBuild();
			return TRUE;
		case IDM_PROJITEM_CBUILD_NO_DEPS:
			OnBuildNoDeps();
			return TRUE;
		case IDM_PROJECT_CLEAN:
			OnClean();
			return TRUE;
		case IDM_PROJITEM_ADD_GROUP:
			OnAddGroup();
			return TRUE;
		case IDM_SLOB_DEFAULTCMD:
			OnOpenItem();
			return TRUE;
		case IDM_INSERT_FILES_POP:
			OnPopupFilesIntoProject();
			return TRUE;
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert


		switch (nID)
		{
		case IDM_PROJITEM_OPEN:
			OnUpdateOpenItem(pCmdUI);
			return TRUE;
		case IDM_PROJITEM_CCOMPILE:
			OnUpdateCompileItem(pCmdUI);
			return TRUE;
		case IDM_PROJITEM_CBUILD:
		case IDM_PROJITEM_CBUILD_NO_DEPS:
			OnUpdateBuild(pCmdUI);
			return TRUE;
		case IDM_PROJECT_CLEAN:
			OnUpdateClean(pCmdUI);
			return TRUE;
		case IDM_PROJITEM_ADD_GROUP:
			OnUpdateAddGroup(pCmdUI);
			return TRUE;
		case IDM_SLOB_DEFAULTCMD:
			pCmdUI->Enable(TRUE);
			return TRUE;
		case IDM_INSERT_FILES_POP:
			OnUpdateFilesIntoProject(pCmdUI);
			return TRUE;
		}
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildSlob property map

#define theClass CBuildSlob
BEGIN_SLOBPROP_MAP(CBuildSlob, CProjSlob)
	STR_PROP(ProjWinTitle)
	BOOL_PROP(IsExpanded)
	BOOL_PROP(IsExpandable)
	LONG_PROP(IPkgProject)
	SLOB_PROP(ProxyContainer)
END_SLOBPROP_MAP()
#undef theClass

/////////////////////////////////////////////////////////////////////////////
// Image wells used to draw our glyphs

extern CImageWell g_imageWell;	// project item glyphs

/////////////////////////////////////////////////////////////////////////////
// HACK ALERT, HACK ALERT, here are the infamous state variables

// Are we currently processing an inform
BOOL CBuildSlob::m_bThunkMoves = TRUE;

/////////////////////////////////////////////////////////////////////////////
// The inform list

CObList CBuildSlob::m_lstInform;

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob construction/destruction

CBuildSlob::CBuildSlob()
{
	// No item, or config initially
	m_pItem = NULL;
	m_pcr = NULL;

	// Data structures for safe fixup/unfixup.
	m_pTempConfigChange = NULL;
	m_dwFixupRefCount = 0;

	// Not ignoring informs to begin with
	m_bIgnoreInforms = FALSE;

	m_bIsExpanded = FALSE;
	m_bIsExpandable = TRUE;
	m_lIPkgProject = NULL;
	m_pProxyContainer = NULL;
}

CBuildSlob::CBuildSlob(CProjItem * pItem, ConfigurationRecord * pcr)
{
	ASSERT(pItem);

	// Set up our item and config
	m_pItem = pItem;
	m_pcr = pcr;

	// Data structures for safe fixup/unfixup.
	m_pTempConfigChange = NULL;
	m_dwFixupRefCount = 0;

	// Not ignoring informs to begin with
	m_bIgnoreInforms = FALSE;

	m_bIsExpanded = FALSE;
	m_bIsExpandable = TRUE;
	// WinslowF this needs to be initialized for Insert Files Into Folder.
	m_lIPkgProject = NULL;
	m_pProxyContainer = NULL;

	// If this item represents a target, or a target reference
	// then it will need to know about changes in configuration names
	// so we add it to our select list of CBuildSlobs
	if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
 		m_lstInform.AddTail(this);
}

CBuildSlob::~CBuildSlob()
{
	ASSERT(m_dwFixupRefCount == 0);
	ASSERT(m_pTempConfigChange == NULL);

	// If we still have an associated item then we'd better make ourselves
	// no longer a dependant of it
	if (m_pItem)
		m_pItem->RemoveDependant(this);

	// If the build slob is in the undo buffer, then it is the
	// sole owner of this item, so delete the item.
	if ((GetContainer() == &theUndoSlob) && (m_pItem != NULL) && (m_pItem->GetContainer() != &theUndoSlob))
		delete m_pItem;
	else if (GetContainer() == &theClipboardSlob )
	{
		//
		// Deleting from clipboard should not record.
		//
		theUndoSlob.Pause();
		delete m_pItem;
		theUndoSlob.Resume();
	}
 
	// Get rid of our contents
 	CObList * pContentList = GetContentList();
	if (pContentList)
	{
		POSITION pos = pContentList->GetHeadPosition();
		while (pos != NULL)
		{
			CBuildSlob *pSlob = (CBuildSlob *)pContentList->GetNext(pos);
			delete pSlob;
		}
	}

	// If we are on the select list of CBuildSlobs that get informs about
	// configuration name changes then get us off of it!!!!
	POSITION pos = m_lstInform.Find(this);
	if (pos != NULL)
		m_lstInform.RemoveAt(pos);
}

CSlobWnd * CBuildSlob::GetSlobWnd() const
{
	CSlobWnd * pSlobWnd = CSlob::GetSlobWnd();
	if (pSlobWnd == NULL)
	{
		CSlob * pViewSlob = GetBuildNode()->GetFirstTarget();
		if (pViewSlob)
			pSlobWnd = pViewSlob->GetSlobWnd();
	}

	return pSlobWnd;
}

/////////////////////////////////////////////////////////////////////////////
// Property page stuff. Basically thunks through to the CProjItems, great eh!!

BOOL CBuildSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	BOOL bRet = m_pItem->SetupPropertyPages(pNewSel, bSetCaption);
	CProjSlob::SetupPropertyPages(pNewSel, FALSE);

	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::CanAdd, we determine here whether we have any buildslobs to
// paste into this target. Only CBuildSlobs can be pasted in targets

BOOL CBuildSlob::CanAdd(CSlob * pAddSlob)
{
	ASSERT(m_pItem != NULL);
	if ((!m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem))) &&
		(!m_pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))))
		return FALSE;

	if (g_Spawner.SpawnActive())
		return FALSE;

	// Handle multislobs
	if (pAddSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) || pAddSlob == &theClipboardSlob)
	{
		POSITION pos = pAddSlob->GetHeadPosition();
		while (pos != NULL)
		{
			// Get the next slob
			CSlob * pSlob = (CSlob *)pAddSlob->GetNext(pos);
			ASSERT(pSlob->IsKindOf(RUNTIME_CLASS(CSlob)));

			// If this is a CBuildSlob then we have something that we can add
			if (!pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				return FALSE;				

			CProjItem * pItem = ((CBuildSlob *)pSlob)->GetProjItem();
			if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
				continue;

			// we can now pseudo-drop dependencies, which get
			// converted to CFileItems before they are dropped
			if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)))
				continue;

			if (!pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
				return FALSE;

			// ensure we're not trying to add a group to itself
			CProjItem * pContainer = m_pItem;
			while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				if (pContainer == pItem)
					return FALSE; // can't add this group
				pContainer = (CProjItem *)pContainer->GetContainer();
			}
		}

		return TRUE;
	}
	// We can only add CBuildSlobs
	else if (pAddSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
	{
		CProjItem * pItem = ((CBuildSlob *)pAddSlob)->GetProjItem();

		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
			return TRUE;

		// we can now pseudo-drop dependencies, which get
		// converted to CFileItems before they are dropped
		if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)))
			return TRUE;

		if (!pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
			return FALSE;

		// ensure we're not trying to add a group to itself
		CProjItem * pContainer = m_pItem;
		while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
		{
			if (pContainer == pItem)
				return FALSE; // can't add this group
			pContainer = (CProjItem *)pContainer->GetContainer();
		}
		return TRUE;
	}

	// No CBuildSlobs so nothing to add
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Property management. Lotsa thunks. Basically the method here is
// 1, If the property is one of our own (i.e. CBuildSlob) then handle it here
// 2. Else, make sure we are using the right property bag on the CProjItem,
// 3. And put the Project in the config that this wrapper uses.
// 4. Do the required operation.
// 5. Reset everything
// 6. Return

BOOL CBuildSlob::SetIntProp(UINT idProp, int val)
{
	// Handle the wrappers own properties
	if (idProp == P_IsExpandable || idProp == P_IsExpanded)
	{
		if (idProp == P_IsExpanded && val && m_pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		{
			//
			// This is where external dependencies are updated.
			//
			BOOL bNeedsDepUpdate = FALSE;
			CDependencyContainer* pDepCntr = (CDependencyContainer*)m_pItem;
			FixupItem();
			if (NULL==pDepCntr->GetTarget())
			{
				UnFixupItem();
				return FALSE;
			}
			else if (valid==pDepCntr->GetTarget()->GetIntProp(P_TargNeedsDepUpdate,bNeedsDepUpdate) &&
				bNeedsDepUpdate )
			{
#if 0
				if (NULL==pDepCntr->GetHeadPosition())
#endif
					pDepCntr->GetProject()->DoTopLevelScan(FALSE);
				pDepCntr->GetTarget()->SetIntProp(P_TargNeedsDepUpdate,FALSE);

				BOOL bReturnFalse = pDepCntr->GetContentList()->IsEmpty();
				if (bReturnFalse)
				{
					//
					//
					//
					CProject* pProject = pDepCntr->GetProject();
					if (NULL!=pProject)
						pProject->SetIntProp(P_HasExternalDeps,FALSE);

					UnFixupItem();
					//
					// Set to not expandable.
					//
					CSlob::SetIntProp(P_IsExpandable, FALSE);
					return FALSE;
				}
			}
			UnFixupItem();
		}
   		return CSlob::SetIntProp(idProp, val);
	}

	// Ok this should be a property of the projitem so we
	// attempt to thunk through to the real projitem 
	ASSERT_VALID (m_pItem);
	ASSERT_VALID (m_pcr);
	
	if (m_pItem == NULL || m_pcr == NULL)
		return FALSE;

	// Make sure we are using the right property bag
	int nOldBag = m_pItem->UsePropertyBag(CurrBag);

	// Set up the config
	CProject * pProject = m_pItem->GetProject();
  	ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
	CProjTempConfigChange projTempConfigChange(pProject);
 	projTempConfigChange.ChangeConfig(pcrBase);

	// Do the SetIntProp
	BOOL fRet = m_pItem->SetIntProp(idProp, val);

	// Reset the config
	projTempConfigChange.Release();

	// Reset the property bag
	m_pItem->UsePropertyBag(nOldBag);

	// Return the result
 	return fRet;
}

BOOL CBuildSlob::SetStrProp(UINT idProp, const CString& val)
{
	ASSERT_VALID (m_pItem);
	ASSERT_VALID (m_pcr);

	if (m_pItem == NULL || m_pcr == NULL)
		return FALSE;

	// Make sure we are using the right property bag
	int nOldBag = m_pItem->UsePropertyBag(CurrBag);

	// Set up the config
	CProject * pProject = m_pItem->GetProject();
 	ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
	CProjTempConfigChange projTempConfigChange(pProject);
 	projTempConfigChange.ChangeConfig(pcrBase);

	// We should not be setting the title for a wrapper item
	ASSERT(idProp != P_Title);

	// Do the SetStrProp
	BOOL fRet = m_pItem->SetStrProp(idProp, val);

	// Reset the config
	projTempConfigChange.Release();

	// Reset the property bag
	m_pItem->UsePropertyBag(nOldBag);

	// Return the result
	return fRet;
}

GPT CBuildSlob::GetIntProp(UINT idProp, int &val)
{
	// Handle the wrappers own properties
	if (idProp == P_IsExpandable || idProp == P_IsExpanded || idProp == P_HasGlyphTipText)
	{
		switch (idProp)
		{
			case P_IsExpandable:
				//
				// Always TRUE for CDependencyContainer that hasn't been intialized with
				// dependencies yet.
				//
				if (m_pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
				{
					val = !(GetContentList()->IsEmpty());

					// Return TRUE if updating contents has been deferred.
					if (!val)
					{
						FixupItem();
						CDependencyContainer* pDepCntr = (CDependencyContainer*)m_pItem;
						if (NULL!=pDepCntr->GetTarget())
						{
							pDepCntr->GetTarget()->GetIntProp(P_TargNeedsDepUpdate,val);
						}
						UnFixupItem();
					}
				}
				else
					val = !(GetContentList()->IsEmpty());
 				return valid;
	
			case P_IsExpanded:
				return CSlob::GetIntProp(idProp, val);

			case P_HasGlyphTipText:
				val = FALSE; // default
				ASSERT(m_pItem);
				if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
				{
 					if (m_pItem->GetProject()->GetFileRegHandle() != NULL)
					{
						val = (g_pSccManager->IsSccInstalled() == S_OK);
					}

				}
				else if (m_pItem->GetFileRegHandle() != NULL)
				{
					val = (g_pSccManager->IsSccInstalled() == S_OK);
				}
				return valid;

			default:
				ASSERT(FALSE);
                		return invalid;
        	}
	}
 
	// Ok this should be a property of the projitem so we
	// attempt to thunk through to the real projitem 

	if (m_pItem == NULL || m_pcr == NULL)
		return invalid;

	ASSERT_VALID (m_pItem);
	
	if (m_pcr->m_pBaseRecord != m_pcr->m_pBaseRecord->m_pBaseRecord)
		return invalid;	   // could happen during delete

	ASSERT_VALID (m_pcr);  // REVIEW: make sure we never hit this

	// Make sure we are using the right property bag
	int nOldBag = m_pItem->UsePropertyBag(CurrBag);
	CProject * pProject = m_pItem->GetProject();

	// this can happen during cut & paste, etc.
	if (pProject == NULL)
		return invalid;

	// Set up the config
 	ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
	CProjTempConfigChange projTempConfigChange(pProject);
 	projTempConfigChange.ChangeConfig(pcrBase);

	// Do the GetIntProp
	GPT gpt = m_pItem->GetIntProp(idProp, val);

	// Reset the config
	projTempConfigChange.Release();

	// Reset the property bag
	m_pItem->UsePropertyBag(nOldBag);

	// Return the result
	return gpt;
}

GPT CBuildSlob::GetStrProp(UINT idProp, CString &val)
{
	if (m_pItem == NULL || m_pcr == NULL)
		return invalid;

	ASSERT_VALID (m_pItem);
	if (NULL==m_pItem->ConfigRecordFromBaseConfig(const_cast<ConfigurationRecord*>(m_pcr->m_pBaseRecord)))
		return invalid;	   // could happen during delete

	ASSERT_VALID (m_pcr); // REVIEW: make sure we never hit this

	CProject * pProject = m_pItem->GetProject();
	if (pProject == NULL)
		return invalid;

    GPT gpt = invalid;

	// Make sure we are using the right property bag
	int nOldBag = m_pItem->UsePropertyBag(CurrBag);

	// Set up the config
	ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
	CProjTempConfigChange projTempConfigChange(pProject);
 	projTempConfigChange.ChangeConfig(pcrBase);

	// If we are getting the title of this node then we
	// check to see if this is a wrapper around a Target
	// item, if so we want to get the name of the primary
	// target file produced by this target as the title
	if (idProp == P_Title)
	{
 		if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		{
			static CString str;
			if (str.IsEmpty())
				VERIFY(str.LoadString(IDS_SP_FILES));
/*bc
			const CPath * pPath = pProject->GetTargetFileName();
		
            CTargetItem * pTarget = (CTargetItem *)m_pItem;

			// Have to reset config so that we handle non-matching configs correctly
			projTempConfigChange.Reset();
			GetBldSysIFace()->GetTargetNameFromFileSet((HFILESET)pTarget, val, (HBUILDER)pProject, TRUE);
			projTempConfigChange.ChangeConfig(pcrBase);
            
			// We may fail to get the primary target filename
			// in which case we revert to the configuration name
			if (pPath)
 				val = val + _T(" (") + pPath->GetFileName() + _T(')');
 */
			val = m_pItem->GetTargetName();
			// g_BldSysIFace.GetFileSetName((HFILESET)m_pItem, val, (HBUILDER)pProject);
			val += str;

			gpt = valid;
		}
		// Everything else just gets the projitem name normally
		else
			gpt = m_pItem->GetStrProp(P_ProjItemName, val);
	}
	else if (idProp == P_ProjWinTitle)
		gpt = CSlob::GetStrProp(idProp, val);
    else
	// Do the GetStrProp
	    gpt = m_pItem->GetStrProp(idProp, val);

	// reset and free up the critical section.
	projTempConfigChange.Release();

	// Reset the property bag
	m_pItem->UsePropertyBag(nOldBag);
 
	// Return the result
	return gpt;
}

BOOL CBuildSlob::DrawGlyph(CDC *pDC, LPCRECT lpRect)
{
	// Is there a matching configuration
	CString strConfig;
    CTargetItem * pTarget = m_pItem->GetTarget();
	if (!pTarget)
	{
		ASSERT(0);
		return FALSE;
	}

	CProject * pProject = pTarget->GetProject();
	ASSERT(pProject);


	// Draw container glyphs
 	CObList * pContentList = GetContentList();
	if ((m_pItem!=NULL) && ((m_pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))) ||
		(m_pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))))

	{
		return FALSE;	// Default is to use project workspace's glyphs
  	}

	// 0: part of build, 1: excluded from build; 2: not buildable
	ASSERT(m_pItem);

	FixupItem();

	const CPath * pPath = m_pItem->GetFilePath();

	int nGlyph = 2;

	if (m_pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		BOOL bExcluded = FALSE;
		if ((GetIntProp(P_ItemExcludedFromBuild, bExcluded) == valid) && (bExcluded))
		{
			nGlyph = 1;
		}
		else if (((CFileItem*)m_pItem)->GetSourceTool() != (CBuildTool *)NULL)
		{
			nGlyph = 0;
		}
	}
	else if (m_pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)) ||
		 m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
	{
		CProject * pRefProject = NULL;
		if (m_pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
			BOOL bExcluded = TRUE;
			GetIntProp(P_ItemExcludedFromBuild, bExcluded);
			nGlyph = bExcluded ? 10 : 7;

			CTargetItem * pRefTarget = ((CProjectDependency *)m_pItem)->GetProjectDep();
			if (pRefTarget != NULL)
				pRefProject = pRefTarget->GetProject();
		}
		else
		{
			nGlyph = 4; // project glyph
			pRefProject = pProject;
		}

		// different glyphs for different proj types
		if (pRefProject != NULL)
		{
			// need to get path from assoc. project for these
			pPath = pRefProject->GetFilePath();
			nGlyph += pRefProject->GetGlyphIndex(); // 0, 1 or 2
		}
	}

	int status = 0;
	BOOL bIsSccActive = (g_pSccManager->IsSccActive() == S_OK);
	if (bIsSccActive && (pPath != NULL))
	{
		g_pSccManager->GetStatus(&status, (LPCTSTR)*pPath);	
		if ((status != -1) && ((status & (SCC_STATUS_CONTROLLED|SCC_STATUS_DELETED))==SCC_STATUS_CONTROLLED))
		{
			nGlyph += 13;
			if ((status & SCC_STATUS_SHARED)!=0)
			{
				nGlyph +=13;
			}
		}
	}


	CPoint	pt(lpRect->left, lpRect->top);
	g_imageWell.DrawImage(pDC, pt, nGlyph);

	// may need to draw SCC glyph as well (overlay)
	if (status > 0)
	{
		ASSERT(g_pSccManager!=NULL);
		g_pSccManager->DrawGlyph(pDC, lpRect, status, FALSE);
	}

	UnFixupItem();

	return TRUE;
}

//  Get filename associated with this slob, if any:
const CPath * CBuildSlob::GetFilePath() const
{
	if (m_pItem==NULL)
		return NULL;

	return m_pItem->GetFilePath();
}

FileRegHandle CBuildSlob::GetFileRegHandle() const
{
	if (m_pItem==NULL)
		return NULL;

	return m_pItem->GetFileRegHandle();
}

int CBuildSlob::GetAssociatedFiles(CStringArray & saFiles)
{
#ifdef SCC_FOLDERS
	if (m_pItem != NULL && m_pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))) {
		// recurse for folders
		return Inherited::GetAssociatedFiles(saFiles);
	}
#endif
	const CPath * pPath = GetFilePath();
	if ((pPath==NULL) || (pPath->IsEmpty()))
		return 0;
	
	saFiles.Add((LPCTSTR)*pPath);
	return 1;
}

void CBuildSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
	// Check if this inform is about a dependency container, if so then
	// we always accept informs about dep containers
	BOOL bDontIgnoreInform = FALSE;
	if (pChangedSlob->IsKindOf(RUNTIME_CLASS(CProjItem)))
	{
		if (pChangedSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)) && dwHint &&
			((CProjItem *)dwHint)->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
			bDontIgnoreInform = TRUE;
	}

	// Are we ignoring informs at the moment
	if (m_bIgnoreInforms && !bDontIgnoreInform)
		return;

 	ASSERT_VALID (pChangedSlob);
	if (!pChangedSlob->IsKindOf(RUNTIME_CLASS(CProjItem)) && pChangedSlob != m_pItem)
	{
		CSlob::OnInform(pChangedSlob, idChange, dwHint);
		return;
	}

	UnThunkMoves();

	// shouldn't use these notifications with project stuff
	ASSERT (idChange != SN_SAVED && idChange != SN_LOADED &&
			idChange != SN_DIRTY && idChange != SN_CLEAN);

	switch (idChange)
	{
		case SN_DESTROY_CONFIG:
		{
			// Is the config that is going away the one that we
			// care about
			ConfigurationRecord * pcr = (ConfigurationRecord *)dwHint;

			if (m_pcr && pcr && pcr->m_pBaseRecord == m_pcr->m_pBaseRecord)
			{
				ASSERT_VALID (m_pcr);

				if (m_pItem->IsKindOf (RUNTIME_CLASS (CTargetItem)))
				{
					// Ok our config is going away, so we'd better go too
					GetBuildNode()->RemoveBuildSlob(this);

					// Destroy ourselves.
					theUndoSlob.Pause();
					MoveInto(NULL);
					theUndoSlob.Resume();
				}
				else
				{
					m_pcr = NULL;
				}
			}
			break;
		}

 		case SN_DESTROY:
			// ignore destroy messages
 			// Our item has gone away on us!!
			if (pChangedSlob == m_pItem)
				m_pItem = NULL;

			// We may need to remove ourselves from the build nodes map
//			ASSERT(NULL!=GetBuildNode());
			if (NULL!=GetBuildNode())
				GetBuildNode()->RemoveBuildSlob(this);

			CSlob::OnInform (pChangedSlob, idChange, dwHint);

			// Delete us
			theUndoSlob.Pause();
			MoveInto(NULL);
		 	theUndoSlob.Resume();
			break;
 	
		case SN_ADD:
		{
 			// Create the new wrappers here
            CProjItem * pItem = (CProjItem *)dwHint;

			// This had better be a notification from a CProjItem
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
            {
				if (!theUndoSlob.InUndoRedo() || (!pItem->CanAct(act_insert_into_undo_slob)))
				{
					ASSERT_VALID (m_pcr);

					if (!pItem->CanAct(act_insert_into_undo_slob))
						theUndoSlob.Pause();

					ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
					GetBuildNode()->CreateSlobs(pItem, pcrBase, this);
					if (!pItem->CanAct(act_insert_into_undo_slob))
						theUndoSlob.Resume();
				}
            }
            else
 			    // pass onto the base-class
			    CSlob::OnInform (pChangedSlob, idChange, dwHint);
				 
			break;
		}

		case SN_REMOVE:
		{
 			// Remove wrapper slobs here
            CProjItem * pItem = (CProjItem *)dwHint;

			// This had better be a notification from a CProjItem
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
            {
  				CObList * pContentList = GetContentList();
				if (pContentList)
				{
					POSITION pos = pContentList->GetHeadPosition();
					while (pos != NULL)
					{
						CBuildSlob * pSlob = (CBuildSlob *)pContentList->GetNext(pos);
						if (pSlob->GetProjItem() == pItem && (bDontIgnoreInform || (!pSlob->IgnoringInforms())))
						{
							// Found wrapper corresponding to the item being removed
							// so lets get rid of the wrapper itself!
 							ASSERT(pItem->CanAct(act_insert_into_undo_slob) || (!theUndoSlob.IsRecording()));
							CBuildSlob * pNextSlob;
							while ((pos != NULL) && ((pNextSlob = (CBuildSlob *)pContentList->GetAt(pos))->GetProjItem() != pItem) && (!pNextSlob->CanAct(act_insert_into_undo_slob))) (void)GetNext(pos);

							pSlob->MoveInto(NULL);
 							// break;
						}
					}
				}
            }
            else
  			    // pass onto the base-class
			    CSlob::OnInform (pChangedSlob, idChange, dwHint);
   
			break;
		}

		case P_SccStatus:
		{

			InformDependants(P_ProjWinTitle);

			// pass onto the base-class
			CSlob::OnInform (pChangedSlob, idChange, dwHint);
			break;
		}

		default:
		{
			// Check to see if this prop notify is to do with the right config.
			CProjItem * pItem = (CProjItem *)pChangedSlob;

			// This had better be a notification from a CProjItem
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
			{
				ConfigurationRecord * pcr = pItem->GetActiveConfig();
				if (pcr == NULL || m_pcr == NULL)
					break;

				if (pcr->m_pBaseRecord != m_pcr->m_pBaseRecord)
					break;
		
				// only do this if the item changing concerns our config.
				if (((CProjItem *)pChangedSlob)->UsePropertyBag() != CurrBag)
					break;
		
				// notify the view of this change if needed
				// o has the containment changed for a slob?
				// o has the view of the slob changed?
				// o has the title text or excluded from build state changed?
				// o has the name of the project node in the window changed? (config. change)
				if (idChange == P_Container || idChange == P_GroupName || 
					idChange == P_ItemExcludedFromBuild || idChange == P_ID || 
					idChange == SN_CONTENT || idChange == SN_FILE_NAME || 
					idChange == P_ProjConfiguration || idChange == P_TargetName)
				{
					// Do something here to handle view changes!!!
					ASSERT(idChange);

					if (idChange == P_ItemExcludedFromBuild || idChange == SN_FILE_NAME || 
						idChange == P_ProjConfiguration || idChange == P_TargetName)
						InformDependants(P_ProjWinTitle);
 				}
			}

			// pass onto the base-class
			CSlob::OnInform (pChangedSlob, idChange, dwHint);
			break;
		}
	}

	ThunkMoves();
}

void CBuildSlob::SetMatchingConfig(LPCTSTR pszConfig, BOOL bContents /* = TRUE */)
{
	m_pcr = m_pItem->ConfigRecordFromConfigName(pszConfig);
 	ASSERT(m_pcr);
	if (!m_pcr)
		return;

	if (bContents && (GetContentList() != NULL))
	{
		POSITION pos = GetContentList()->GetHeadPosition();
		while (pos != NULL)
		{
			CBuildSlob *pSlob = (CBuildSlob *)GetContentList()->GetNext(pos);
			pSlob->SetMatchingConfig(pszConfig, bContents);
		}
	}
}

BOOL CBuildSlob::PreMoveItem(CSlob * & pContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged)
{
	// If we are moving this into NULL then we'd better
	// disconnect from the real projitem
	//if (pContainer == NULL && m_pItem)
	//	m_pItem->RemoveDependant(this);

    if (fToBldSlob && (!fFromBldSlob) && m_bThunkMoves)
    {
        ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));

		((CBuildSlob *)pContainer)->IgnoreInforms();

        CProjItem * pItem = ((CBuildSlob *)pContainer)->GetProjItem();
//		theUndoSlob.Pause();
		m_pItem->MoveInto(pItem);
// 		theUndoSlob.Resume();

		if (m_pcr == NULL)
		{
			// Set up the pcr for the wrapper
			ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
			// don't try to set if parent not set yet
			if (((CBuildSlob *)pContainer)->GetConfig() != NULL)
			{
				CString strConfig = ((CBuildSlob *)pContainer)->GetConfigurationName();
 				SetMatchingConfig(strConfig);
				ASSERT(m_pcr);
			}
		}

#if 0
		if ((!GetContentList()) || (GetContentList()->IsEmpty()))
		{
			ConfigurationRecord * pcrBase =  NULL;
			if (m_pcr)
				pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
			
			// need to reconstruct contents at this point
			if (m_pItem->GetContentList() != NULL)
			{
				POSITION pos = m_pItem->GetContentList()->GetHeadPosition();
				while (pos != NULL)
				{
					CProjItem * pItem = (CProjItem *)m_pItem->GetContentList()->GetNext(pos);
#ifdef _DEBUG
					CBuildSlob * pChild = 
#endif
					GetBuildNode()->CreateSlobs(pItem, pcrBase, this, TRUE);
				}
			}
		}
#endif

#if 0	// bogus hack
		// if moving from undo or clipboard, net to ensure our contents are hooked up properly
		if (GetContentList())
		{
			POSITION pos = GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CBuildSlob *pSlob = (CBuildSlob *)GetContentList()->GetNext(pos);
				CSlob * pThis = this;
				pSlob->PreMoveItem(pThis, fFromBldSlob, fToBldSlob, fPrjChanged);
			}
		}
#endif
		((CBuildSlob *)pContainer)->UnIgnoreInforms();
    }
	else if (fToBldSlob && fFromBldSlob)
	{
        ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));

		((CBuildSlob *)pContainer)->IgnoreInforms();
		((CBuildSlob *)GetContainer())->IgnoreInforms();

		// FUTURE (billjoy) we REALLY need to find out why HoldUpdates
		// doesn't keep paint messages from coming thru when we have to 
		// put up the rc dialog ("you can only have one rc file in a 
		// project" or something).  The paint causes a GetStrProp for the
		// title of this rc slob, but m_pcr hasn't been set yet (it is
		// set a few lines down).  The same change should be made to 
		// fix the code in the above "if" block
        CProjItem * pItem = ((CBuildSlob *)pContainer)->GetProjItem();
		theUndoSlob.Pause();
		m_pItem->MoveInto(pItem);
 		theUndoSlob.Resume();

		// Set up the pcr for the wrapper
		ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
				// don't try to set if parent not set yet
		ASSERT(((CBuildSlob *)pContainer)->GetConfig() != NULL);
		CString strConfig = ((CBuildSlob *)pContainer)->GetConfigurationName();
 		SetMatchingConfig(strConfig);

		((CBuildSlob *)GetContainer())->UnIgnoreInforms();
		((CBuildSlob *)pContainer)->UnIgnoreInforms();
	} // UNDONE: handle third case!!!

	return TRUE;
}

BOOL CBuildSlob::MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged)
{
	// removing item altogether from project?
	if (fFromBldSlob && (!fToBldSlob) && m_bThunkMoves)
	{
		IgnoreInforms();
		((CBuildSlob *)pOldContainer)->IgnoreInforms();

#if 0
		// Make a copy of the item we are deleting so that the proxy can
		// refer to it.
		CProjItem * pCloneItem = (CProjItem *)m_pItem->Clone();
#endif
 
		// Disconnect associated projitem here
//		theUndoSlob.Pause();
		m_pItem->MoveInto(NULL);
// 		theUndoSlob.Resume();

		SetConfig(NULL);
#if 0
		// Set up our cloned item (no content yet)
 		SetItem(pCloneItem);
#if 0
#else

		// Set up the pcr for content, as it will have changed
		ASSERT(((CBuildSlob *)pOldContainer)->GetConfig() != NULL);
		CString strConfig = ((CBuildSlob *)pOldContainer)->GetConfigurationName();
		SetMatchingConfig(strConfig);
		ASSERT(m_pcr);
#endif
#endif
#if 0
		ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
		// need to reconstruct contents at this point
		if (pCloneItem->GetContentList())
		{
			POSITION pos = pCloneItem->GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CProjItem * pItem = (CProjItem *)pCloneItem->GetContentList()->GetNext(pos);
#ifdef _DEBUG
				CBuildSlob * pChild = 
#endif
				GetBuildNode()->CreateSlobs(pItem, pcrBase, this, TRUE);
			}
		}
#endif

		((CBuildSlob *)pOldContainer)->UnIgnoreInforms();
		UnIgnoreInforms();
	}

	return CSlob::SetSlobProp(P_Container, pContainer);
}

BOOL CBuildSlob::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromBldSlob, BOOL fToBldSlob, BOOL fPrjChanged)
{
	if (fToBldSlob && (/* fPrjChanged || */!fFromBldSlob) && m_bThunkMoves)
	{
		m_pItem->AddDependant(this);  // UNDONE: recurse?
	}

	if (fToBldSlob && (m_pcr == NULL))
	{
		// Set up the pcr for the wrapper
		ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
		// don't try to set if parent not set yet
		if (((CBuildSlob *)pContainer)->GetConfig() != NULL)
		{
			CString strConfig = ((CBuildSlob *)pContainer)->GetConfigurationName();
 			SetMatchingConfig(strConfig);
			ASSERT(m_pcr);
		}
	}
	if (fFromBldSlob && pOldContainer && theUndoSlob.IsRecording())
	{
		ASSERT(pOldContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
		CProjContainer * pItemContainer = (CProjContainer *)((CBuildSlob *)pOldContainer)->m_pItem;
		if ((pItemContainer) && (pItemContainer->IsKindOf(RUNTIME_CLASS(CProjContainer))) && (pItemContainer->GetProject() != NULL) && (pItemContainer->GetProject()->m_bProjectComplete) && (pItemContainer->IsKindOf(RUNTIME_CLASS(CTargetItem)) || pItemContainer->GetTarget() != NULL))
			pItemContainer->RefreshAllMirroredDepCntrs();
	}

	if (fToBldSlob && pContainer && theUndoSlob.IsRecording())
	{
		ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
		CProjContainer * pItemContainer = (CProjContainer *)((CBuildSlob *)pContainer)->m_pItem;
		if ((pItemContainer) && (pItemContainer->IsKindOf(RUNTIME_CLASS(CProjContainer))) &&  (pItemContainer->GetProject() != NULL) && (pItemContainer->GetProject()->m_bProjectComplete) && (pItemContainer->IsKindOf(RUNTIME_CLASS(CTargetItem)) || pItemContainer->GetTarget() != NULL))
			pItemContainer->RefreshAllMirroredDepCntrs();
	}

	return TRUE;
}

BOOL CBuildSlob::SetSlobProp(UINT idProp, CSlob * val)
{
 	// only interested in container property changes
	if (idProp != P_Container)
		// pass on to the base-class
		return CSlob::SetSlobProp(idProp, val);

	// old container?
	CSlob * pOldContainer = m_pContainer; 

	if (val != NULL && val->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
	{
		// Really mean to move it into the build slob
		val = ((CBuildViewSlob *)val)->GetBuildSlob();
	}

	// from a Build Slob?
	BOOL fFromBldSlob = m_pContainer && m_pContainer->IsKindOf(RUNTIME_CLASS(CBuildSlob));

	// into a Build Slob?
	BOOL fToBldSlob = val && val->IsKindOf(RUNTIME_CLASS(CBuildSlob));

	BOOL fPrjChanged = FALSE;

	if (fFromBldSlob && fToBldSlob)
	{
		ASSERT(val->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
		CProjItem * pItem = ((CBuildSlob *)val)->m_pItem;
		if (pItem) 
		{
			fPrjChanged = (pItem->GetProject() != m_pItem->GetProject());
		}
	}

	// pre-move item
	if (!PreMoveItem(val, fFromBldSlob, fToBldSlob, fPrjChanged))
		return FALSE;

	// do the 'containment' part of the move
	if (!MoveItem(val, pOldContainer, fFromBldSlob, fToBldSlob, fPrjChanged))
		return FALSE;

	// post-move item, only call if not deleted!
	// ie. not deleted if moving to another container.
	if ((val || theUndoSlob.IsRecording()) &&
		!PostMoveItem(val, pOldContainer, fFromBldSlob, fToBldSlob, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}

CBuildSlob * CBuildSlob::SetContainer(CSlob * pSlob)
{
	CBuildSlob * pOldContainer = (CBuildSlob *)m_pContainer;
	m_pContainer = pSlob;
	return pOldContainer;
}

void CBuildSlob::FixupItem()
{
	if (m_pcr == NULL)
		return;

	ASSERT_VALID (m_pcr);
/*
	What this should reallydo is get the active config from the active project and attempt to
	place this project in the configuration. Question is how, and what do we do if there is no match.
*/

	CString strConfig;
	CTargetItem *pTarg = GetProjItem()->GetProject()->GetActiveTarget();
	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)pTarg, strConfig, ACTIVE_BUILDER, TRUE );

	if( !bMatchingConfig ){
		return;
	}
	if ( m_dwFixupRefCount == 0 )
	{
		m_pTempConfigChange = new CProjTempConfigChange(GetProjItem()->GetProject());
		m_pTempConfigChange->ChangeConfig(strConfig);
	}
	else {
		ASSERT(m_pTempConfigChange);
	}
	m_dwFixupRefCount++;

}

void CBuildSlob::UnFixupItem()
{

	// If m_pcr was NULL in fixup, the ref count wasn't bumped
	if (m_dwFixupRefCount == 0)
		return;

	ASSERT(m_dwFixupRefCount > 0);

	if (--m_dwFixupRefCount == 0 )
	{
		delete m_pTempConfigChange;
		m_pTempConfigChange = NULL;
	}
}

#ifdef VB_MAKEFILES
extern BOOL g_bVBInstalled;
#endif

void CBuildSlob::GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds)
{
	ASSERT(m_pItem != NULL);
	const CPath* pPath = m_pItem->GetFilePath();
	CStringArray paths;
	if (pPath != NULL) {
		paths.Add(*pPath);
	}
	HBUILDER builder = NULL;

    if (m_pItem->IsKindOf(RUNTIME_CLASS(CProjContainer)))
	{
		CProject* pProject = m_pItem->GetProject();
		builder = (HBUILDER) pProject;
		FixupItem();
		BOOL bSupported = (!pProject->m_bProjIsExe && pProject->GetProjType()->IsSupported() && pProject->CanDoTopLevelBuild());
		BOOL bBuildable = FALSE;
		if( bSupported )
		 	bBuildable = pProject->GetProjType()->GetPlatform()->GetBuildable();
		UnFixupItem();

		if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		{
			pPath = pProject->GetFilePath();
			paths.Add(*pPath);

			if (bSupported && bBuildable)
			{
				aVerbs.Add(IDM_PROJITEM_CBUILD);
				aVerbs.Add(IDM_PROJITEM_CBUILD_NO_DEPS);
				aVerbs.Add(IDM_PROJECT_CLEAN);
			}

			if (bSupported ){
				aVerbs.Add(IDM_PROJITEM_ADD_GROUP);
				aVerbs.Add(IDM_INSERT_FILES_POP);
			}
#ifdef VB_MAKEFILES
			if( pProject->m_bVB == TRUE && g_bVBInstalled ){
 				aVerbs.Add(IDM_PROJECT_EDIT);
			}
#endif
		}
		else if (m_pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
#ifdef SCC_FOLDERS
			GetAssociatedFiles(paths);
#endif
			if (bSupported)
			{
				aVerbs.Add(IDM_PROJITEM_ADD_GROUP);
				aVerbs.Add(IDM_INSERT_FILES_POP);
			}
		}
	}

	if (!m_pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
		!m_pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
	{
    	aCmds.Add(IDM_PROJECT_SETTINGS_POP);
	}

	if (g_pSccManager->IsSccInstalled() == S_OK)
	{
		CStringArray* pPath = &paths; // hack to reduce diffs
		if (g_pSccManager->IsValidOp(*pPath, SccOutOp) == S_OK)
			aCmds.Add(IDM_SCC_OUT);

		if (g_pSccManager->IsValidOp(*pPath, SccInOp) == S_OK)
			aCmds.Add(IDM_SCC_IN);

		if (g_pSccManager->IsValidOp(*pPath, SccUnOutOp) == S_OK)
			aCmds.Add(IDM_SCC_UNOUT);

		CProject* pProject = m_pItem->GetProject();
		builder = (HBUILDER) pProject;
		if (g_pSccManager->IsValidOp(*pPath, SccAddOp) == S_OK)
			aCmds.Add(IDM_SCC_ADD);
		else if (builder != NULL && g_pSccManager->IsBuilderControlled((HPROJECT)builder) == S_FALSE)
			aCmds.Add(IDM_SCC_ADD);
	}

	// Can only open non proj containers.
	if (!m_pItem->IsKindOf(RUNTIME_CLASS(CProjContainer)) && !m_pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
     	aVerbs.Add(IDM_PROJITEM_OPEN);

	if (m_pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		// Determine if we are part of an external target
		// or not
		CProject* pProject = m_pItem->GetProject();
        FixupItem();
		BOOL bBuildable = (!pProject->m_bProjIsExe && pProject->GetProjType()->IsSupported() && pProject->GetProjType()->GetPlatform()->GetBuildable() && pProject->CanDoTopLevelBuild());

        BOOL bExternalTarget = pProject->IsExternalTarget();
        UnFixupItem();			


        // Compile only available when we are not building
        if (!g_Spawner.SpawnActive())
        {
            // Check to see if this is in an external target
            // Compile is only valid for non external targets
         	if (!bExternalTarget && bBuildable )
        		aVerbs.Add(IDM_PROJITEM_CCOMPILE);
        }
	}
}

int CBuildSlob::CompareSlob(CSlob * pCmpSlob)
{
	ASSERT(pCmpSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)));
	CProjItem * pItem = GetProjItem();
	CProjItem * pCmpItem = ((CBuildSlob *)pCmpSlob)->GetProjItem();

	// Put dependency containers at the end of this container
	if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return 1;

	if (pCmpItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return -1;

	// Put Groups at the start of this container
	if (pCmpItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return 1;

	if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return -1;

	// Put subprojects at the start of this container
	if (pCmpItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return 1;

	if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return -1;

	CString strExt, strCmpExt; 
	BOOL bCmpIsFileItem = ((CProjItem *)pCmpItem)->IsKindOf(RUNTIME_CLASS(CFileItem));
	BOOL bIsFileItem = pItem->IsKindOf(RUNTIME_CLASS(CFileItem));
	if (bCmpIsFileItem)
		strCmpExt = ((CFileItem *)pCmpItem)->GetFilePath()->GetExtension();
	if (bIsFileItem)
		strExt = pItem->GetFilePath()->GetExtension();

	// Put .lib files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".lib")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".lib")==0))
		return -1;

	// Put .obj files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".obj")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".obj")==0))
		return -1;

	// Everything else is sorted based on their P_Title property, i.e alphabetically
	int retval = CProjSlob::CompareSlob(pCmpSlob);

	// as a tie breaker, use the absolute path to at least get consistency
	if (retval == 0)
	{
		ASSERT(pItem->GetFilePath() != NULL);
		ASSERT(pCmpItem->GetFilePath() != NULL);
		retval = _tcsicmp((LPCTSTR)*pItem->GetFilePath(), (LPCTSTR)*pCmpItem->GetFilePath());
	}
	ASSERT(retval != 0); // should never be equal
	return retval;
}

void CBuildSlob::OnOpenItem()
{
	// Pass on to the item to open
	m_pItem->OnCmdMsg(IDM_PROJITEM_OPEN, CN_COMMAND, NULL, NULL);
}

void CBuildSlob::OnUpdateOpenItem(CCmdUI * pCmdUI)
{
	// Open is only available on non-folders and non-subfolders

	// a folder is an item with a non empty content list
	BOOL bFolder = !(GetContentList()->IsEmpty());

	// a subfolder is defined as a project dependancy
	BOOL bSubfolder = FALSE;
	if (GetProjItem()->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		bSubfolder = TRUE;

	BOOL bEnable =  !bFolder && !bSubfolder && !GetProjItem()->IsKindOf(RUNTIME_CLASS(CProjContainer));
	pCmdUI->Enable( bEnable );
}

void CBuildSlob::OnCompileItem()
{
	CBuildTool * pTool;

	// has a multi select build been stopped by the user ?
	if( g_bStopBuild == TRUE )
		return;

	// Make sure we are in the right config
    FixupItem();

	if (!m_pItem->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
		((pTool = m_pItem->GetSourceTool()) == (CBuildTool *)NULL))
	{
		CString	strError;
		MsgBox(	Information,
				MsgText(strError,
						IDS_CANT_COMPILE_NO_TOOL,
						(const TCHAR *)*m_pItem->GetFilePath()));
        UnFixupItem();
		return;
	}

	// Also make sure the item itself thinks it's OK to build.
	if (!m_pItem->CanDoTopLevelBuild())
	{
		ASSERT(FALSE);	// Command should have been disabled
        UnFixupItem();
		return;
	}

	// FINALLY, we can compile the damn thing.
	m_pItem->CmdCompile(FALSE);
    
	// Reset the config
	UnFixupItem();
}

void CBuildSlob::OnUpdateCompileItem(CCmdUI * pCmdUI)
{
	BOOL bEnable = FALSE;
	if( !g_pActiveProject ){
		pCmdUI->Enable(FALSE);
		return;
	}

	// Is there a matching configuration
	CString strConfig;
	CBuildSlob *pSlob = (CBuildSlob *)GetContainer();
	CProject * pProject = pSlob->GetProjItem()->GetProject();

	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)(pSlob->GetProjItem()), strConfig, (HBUILDER)pProject, TRUE);

	FixupItem();

	// No compile for exe projects
	if (g_BldSysIFace.GetBuilderType() == ExeBuilder)
		bEnable = FALSE;

	CString			strCompileMenu, strTarget;
	TCHAR			szMenuText[MENU_TEXT_CCH];
	CBuildTool * pTool;


	// Can only compile certain fileitems
	if (m_pItem != (CProjItem *)NULL &&
		m_pItem->IsKindOf(RUNTIME_CLASS(CFileItem)) &&
		(pTool = m_pItem->GetSourceTool()) != (CBuildTool *)NULL)
	{
		ASSERT(m_pItem->GetFilePath());
		strTarget = m_pItem->GetFilePath()->GetFileName();
		bEnable = TRUE;
 	}
	else
		bEnable = FALSE;
	
	strCompileMenu.LoadString(IDS_CPOP_COMPILE);

    pProject = m_pItem->GetProject();
    ASSERT(pProject);

	CProjType *pProjType = pProject->GetProjType();
	ASSERT(pProjType);

	// Is the projtype supported
 	BOOL bIsSupported = pProjType->IsSupported() && pProjType->GetPlatform()->GetBuildable();


	// Enable menuitem and set text
	wsprintf(szMenuText, strCompileMenu,
		strTarget.Left(MENU_TEXT_CCH - strCompileMenu.GetLength()));
	pCmdUI->SetText(szMenuText);
	pCmdUI->Enable(bEnable && bIsSupported && bMatchingConfig && g_Spawner.CanSpawn());

	UnFixupItem();
}

void CBuildSlob::OnBuild()
{
	// has a multi select build been stopped by the user ?
	if( g_bStopBuild == TRUE )
		return;

	FixupItem();
	
	CProject * pProject = m_pItem->GetProject();
	ASSERT(pProject);

	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	UINT nPos;
	VERIFY(SUCCEEDED(pProjSysIFace->GetVerbPosition(&nPos)));

 	BOOL bClearOutputWindow = (nPos == 0);

	CBuildIt wholeBuild;

	// Don't do a build on the target item, instead thunk it
	// upwards to the project, however we do build file items
	// directly
	if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		pProject->DoTopLevelBuild(FALSE, NULL, fcaNeverQueried, TRUE, bClearOutputWindow, TRUE);
	else
		m_pItem->DoTopLevelBuild(FALSE, NULL, fcaNeverQueried, TRUE, bClearOutputWindow, TRUE);

	UnFixupItem();
}

void CBuildSlob::OnBuildNoDeps()
{
	// has a multi select build been stopped by the user ?
	if( g_bStopBuild == TRUE )
		return;

	FixupItem();
	
	CProject * pProject = m_pItem->GetProject();
	ASSERT(pProject);

	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	UINT nPos;
	VERIFY(SUCCEEDED(pProjSysIFace->GetVerbPosition(&nPos)));

 	BOOL bClearOutputWindow = (nPos == 0);

	// Don't do a build on the target item, instead thunk it
	// upwards to the project, however we do build file items
	// directly

	CBuildIt wholeBuild;

	if (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		pProject->DoTopLevelBuild(FALSE, NULL, fcaNeverQueried, TRUE, bClearOutputWindow, FALSE );
	else
		m_pItem->DoTopLevelBuild(FALSE, NULL, fcaNeverQueried, TRUE, bClearOutputWindow, FALSE);


	UnFixupItem();
}

void CBuildSlob::OnUpdateBuild(CCmdUI * pCmdUI)
{
	if( !g_pActiveProject ){
		pCmdUI->Enable(FALSE);
		return;
	}
		
	// Is there a matching configuration
	CString strConfig;
	CBuildSlob *pSlob = (CBuildSlob *)GetContainer();
	CProject * pProject = pSlob->GetProjItem()->GetProject();
	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)(pSlob->GetProjItem()), strConfig, (HBUILDER)pProject, TRUE);

	FixupItem();

	pProject = m_pItem->GetProject();
	pCmdUI->Enable(!pProject->m_bProjIsExe && bMatchingConfig && pProject->GetProjType()->IsSupported() && pProject->CanDoTopLevelBuild());

	UnFixupItem();
}

void CBuildSlob::OnClean()
{
	FixupItem();

	CProject * pProject = m_pItem->GetProject();

	// can we use the src pkg iface to select build output window
	if (g_VPROJIdeInterface.Initialize())
		g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();

	ASSERT_VALID (m_pcr);

	if (m_pcr == NULL)
		return;

	CErrorContext * pEC = g_buildengine.OutputWinEC();

	// perform the clean operation on the appropriate graph
	DWORD dw = (DWORD)pEC;
	CBuildIt wholeBuild(FALSE);
	pProject->DoTopLevelBuild(TOB_Clean,NULL,fcaNeverQueried,TRUE,TRUE, FALSE);
	// g_buildengine.GetDepGraph(m_pcr)->PerformOperation(CFileDepGraph::Clean, dw);

	UnFixupItem();
}

void CBuildSlob::OnUpdateClean(CCmdUI * pCmdUI)
{
	if( !g_pActiveProject ){
		pCmdUI->Enable(FALSE);
		return;
	}
	// Is there a matching configuration
	CString strConfig;
	CBuildSlob *pSlob = (CBuildSlob *)GetContainer();
	CProject * pProject = pSlob->GetProjItem()->GetProject();
	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)(pSlob->GetProjItem()), strConfig, (HBUILDER)pProject, TRUE);

	FixupItem();

	pProject = m_pItem->GetProject();
	pCmdUI->Enable(!pProject->m_bProjIsExe && bMatchingConfig && pProject->GetProjType()->IsSupported() && pProject->CanDoTopLevelBuild());
	UnFixupItem();
}

void CBuildSlob::OnAddGroup()
{
	FixupItem();
	CProject *pProject = m_pItem->GetProject();
	pProject->CreateNewGroup();
	UnFixupItem();
}

void CBuildSlob::OnUpdateAddGroup(CCmdUI * pCmdUI)
{
	LPPROJECTWORKSPACEWINDOW pInterface = FindProjWksWinIFace();
	if ((pInterface == NULL) || (g_Spawner.SpawnActive()))
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	CMultiSlob *pMultiSlob;
	VERIFY(SUCCEEDED(pInterface->GetSelectedSlob(&pMultiSlob)));

	if (pMultiSlob->GetContentList() == NULL ||	pMultiSlob->GetContentList()->GetCount() > 1)
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
}

void CBuildSlob::OnPopupFilesIntoProject()
{
	FixupItem();
	CProject *pProject = m_pItem->GetProject();
	pProject->ActPopupFilesIntoProject();
	UnFixupItem();
}

void CBuildSlob::OnUpdateFilesIntoProject(CCmdUI *pCmdUI)
{
	FixupItem();
	CProject *pProject = m_pItem->GetProject();
	pProject->UpdPopupFilesIntoProject(pCmdUI);
	UnFixupItem();
}

void CBuildSlob::InformBldSlobs(CSlob * pChangedSlob, UINT idChange, DWORD dwHint)
{
	CBuildSlob * pBuildSlob;

	POSITION pos = m_lstInform.GetHeadPosition();
	while (pos != NULL)
	{
		// Get the build slob, and determine if the associated item is a target reference
		pBuildSlob = (CBuildSlob *)m_lstInform.GetNext(pos);
 		
		// Do the inform
		pBuildSlob->OnInform(pChangedSlob, idChange, dwHint);
	}
}

CSlob * CBuildSlob::Clone()
{
	CProjItem * pCloneItem = (CProjItem *)m_pItem->Clone();
#if 0
	CBuildSlob * pClone = (CBuildSlob *)CSlob::Clone();

	pClone->SetItem(pCloneItem);
	pClone->SetConfig(NULL);
#else
	// do our own pseudo-clone and fixup contents later
	// theUndoSlob.Pause();
	// ConfigurationRecord * pcrBase = (ConfigurationRecord *)m_pcr->m_pBaseRecord;
	CBuildSlob * pClone = GetBuildNode()->CreateSlobs(pCloneItem, NULL, NULL, TRUE);
	CopyProps(pClone);	// REVIEW: needed?

	// theUndoSlob.Resume();

#endif

    return pClone;
}

void CBuildSlob::PrepareAddList(CMultiSlob* pAddList, BOOL fPasting)
{
	CBuildSlob * pBldSlob;
	CMapPtrToPtr mapFileRegs;
	CProjItem * pItem, *pDupItem;
	CObList * pAddListContents = pAddList->GetContentList();
	CTargetItem * pTarget = GetProjItem()->GetTarget();
	ASSERT(pTarget);

 	FileRegHandle hndFileReg;
	CObList * pGrpContents = GetContentList();
	
 	POSITION pos = pGrpContents->GetHeadPosition();
	while (pos != NULL)	 // UNDONE: need to check withing group contents also!
	{
		pBldSlob = (CBuildSlob *) pGrpContents->GetNext(pos);
		pItem = (CFileItem *) pBldSlob->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			VERIFY((hndFileReg = pItem->GetFileRegHandle()) != 0);
			mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
		}
	}

	// Now cycle through items to be added (backwards!) and eliminate any dupes
	pos = pAddListContents->GetTailPosition();
	while (pos != NULL)
	{
		pBldSlob = (CBuildSlob *) pAddListContents->GetPrev(pos);
		pItem = (CProjItem *) pBldSlob->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			FileRegHandle hndFileReg = pItem->GetFileRegHandle();
			ASSERT(hndFileReg); // if in file reg, check if in this group
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
#if 0
				// new behaviour: duplicate: remove original, replace in map
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
				if (pDupItem->GetContainer()==GetProjItem())
					{	// if removing an existing item, move into UndoSlob
						pBldSlob->MoveInto(NULL);
					}
				else	// if dup is also from AddList, just delete it
#endif
					{
						theUndoSlob.Pause();
						pAddList->Remove(pBldSlob);	// removes dependency
						delete pBldSlob;			// prevent memory leaks
						theUndoSlob.Resume();
					}
			}
			else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
			{
				// keep the original in this case
				theUndoSlob.Pause();
				pAddList->Remove(pBldSlob);	// removes dependency
				delete pBldSlob;			// prevent memory leaks
				theUndoSlob.Resume();
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
			}
		}
		else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			BOOL bReject = FALSE;
			CProjItem * pContainer = GetProjItem();
			while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				if (pContainer == pItem)
				{
					// can't add group to itself or its children
					theUndoSlob.Pause();
					pAddList->Remove(pBldSlob);
					delete pBldSlob;				// prevent memory leaks
					theUndoSlob.Resume();
					bReject = TRUE;
					break;
				}
				pContainer = (CProjItem *)pContainer->GetContainer();

			}
			// reject duplicates
			if (!bReject)
			{
				// reject duplicates in group content
				CObList ol;
				pItem->FlattenSubtree( ol, CProjItem::flt_Normal | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeDependencies | CProjItem::flt_RespectTargetExclude | CProjItem::flt_ExcludeProjDeps);
				POSITION pos = ol.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					// the contained project item
					CProjItem * pContainedItem = (CProjItem *)ol.GetNext(pos);
					ASSERT(pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
					if (!pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
						continue;

					FileRegHandle hndFileReg = pContainedItem->GetFileRegHandle();
					ASSERT(hndFileReg); // if in file reg, check if in this group
					if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
					{
						theUndoSlob.Pause();
						pContainedItem->MoveInto(NULL);
						theUndoSlob.Resume();
					}
					else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
					{
						theUndoSlob.Pause();
						pContainedItem->MoveInto(NULL);
						theUndoSlob.Resume();
					}
					else
					{
						mapFileRegs.SetAt((void *)hndFileReg, (void *)pContainedItem);
					}
				}
				ol.RemoveAll();
			}
		}
		else
		{
			// ignore all non-fileitems
			theUndoSlob.Pause();
			pAddList->Remove(pBldSlob); 	// removes dependency
			delete pBldSlob;				// prevent memory leaks
			theUndoSlob.Resume();
		}	
	}

}

void CBuildSlob::GetGlyphTipText(CString & str)
{
	str.Empty();
	const CPath * pPath = m_pItem->GetFilePath();
	if ((pPath != NULL) && (g_pSccManager->IsActive() == S_OK))
	{
		VERIFY(SUCCEEDED(g_pSccManager->GetStatusText(*pPath, str)));
	}
}

///////////////////////////////////////////////////////////////////////////////
HCURSOR CBuildSlob::GetCursor(int ddcCursorStyle)
{
	int iCursors = 0;	// At the moment we only have 1 set of cursors!

	switch (ddcCursorStyle)
	{
		case DDC_SINGLE:
			return g_Cursors.GetDDCur(iCursors);

		case DDC_COPY_SINGLE:
			return g_Cursors.GetDDCopyCur(iCursors);

		case DDC_MULTI:
			return g_Cursors.GetDDMultiCur(iCursors);

		case DDC_COPY_MULTI:
			return g_Cursors.GetDDMultiCopyCur(iCursors);

		default:
			ASSERT(FALSE);
			return NULL;
	}
}

CSlobDragger *CBuildSlob::CreateDragger(CSlob *pDragObject, CPoint screenPoint)
{
	if (g_pProjWksWinIFace == NULL)
		return NULL;

	CSlobDraggerEx *pSlobDraggerEx = NULL;
	VERIFY(SUCCEEDED(g_pProjWksWinIFace->CreateDragger(&pSlobDraggerEx)));

	pSlobDraggerEx->AddItem(this);
	return pSlobDraggerEx;
}

void CBuildSlob::DoDrop(CSlob *pSlob, CSlobDragger *pDragger)
{
	ASSERT(g_pProjWksWinIFace != NULL);

	if (!m_pItem->IsKindOf(RUNTIME_CLASS(CProjContainer)))
	{
		CBuildSlob * pContainer = (CBuildSlob *)GetContainer();
		ASSERT(pContainer != NULL);
		pContainer->DoDrop(pSlob, pDragger);
		return;
	}

    GetBuildNode()->HoldUpdates();

	CProject* pProject = m_pItem->GetProject();
	if (NULL!=pProject)
		pProject->BeginBatch();

	// Remove any unneeded slobs identified in PrepareDrop
	while (!m_DeathRow.IsEmpty())
 		((CSlob *)m_DeathRow.RemoveHead())->MoveInto(NULL);
	
	POSITION pos = pSlob->GetHeadPosition();
	while (pos != NULL)
	{
		CSlob* pItemSlob = pSlob->GetNext(pos);
		
		CProjItem * pItem = (CProjItem *)((CBuildSlob *)pItemSlob)->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)))
		{
			// convert to CFileItem and drop
			// must do this here so undo works properly
			g_pProjWksWinIFace->DeselectSlob(pItemSlob); // must unselect!
			CFileItem * pNewItem = new CFileItem;
			pNewItem->SetFile(pItem->GetFilePath());
			pItemSlob = new CBuildSlob(pNewItem, NULL);
			// old one is cleaned up elsewhere
		}
		if (CanAdd(pItemSlob))
		{
			pItemSlob->MoveInto(this);
		}
		else
		{
			pItemSlob->MoveInto(NULL);
		}
	}

	if (NULL!=pProject)
		pProject->EndBatch();

    GetBuildNode()->EnableUpdates();
}

void CBuildSlob::DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint)
{
	pDragger->Show(TRUE);
}

void RecordContents(CBuildSlob * pBldSlob, CMapPtrToPtr & mapFiles, BOOL bRecurse = TRUE)
{
#ifdef _DEBUG
	void * pVoid;
#endif
	CProjItem * pItem;
 	FileRegHandle hndFileReg;
	CObList * pGrpContents = pBldSlob->GetContentList();
	POSITION pos = pGrpContents->GetHeadPosition();
	while (pos != NULL)
	{
		pBldSlob = (CBuildSlob *) pGrpContents->GetNext(pos);
		pItem = (CFileItem *) pBldSlob->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			VERIFY((hndFileReg = pItem->GetFileRegHandle()) != 0);
			ASSERT(!mapFiles.Lookup((void *)hndFileReg, pVoid));
			mapFiles.SetAt((void *)hndFileReg, (void *)pBldSlob);
		}
		else if (bRecurse && pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			RecordContents(pBldSlob, mapFiles);
		}
	}
}

void CBuildSlob::FlattenContents(CObList & ol, BOOL bItemsOnly /* = TRUE */)
{
	CBuildSlob * pBldSlob;
	CProjItem * pItem;
	CObList * pListContents = GetContentList();
	POSITION pos = pListContents->GetHeadPosition();
	while (pos != NULL)
	{
		pBldSlob = (CBuildSlob *) pListContents->GetNext(pos);
		pItem = (CProjItem *) pBldSlob->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			if (!bItemsOnly)
				ol.AddTail(pBldSlob);
			pBldSlob->FlattenContents(ol, bItemsOnly);
		}
		else
		{
			ol.AddTail(pBldSlob);
		}
	}
}

void CBuildSlob::PrepareDrop(CDragNDrop *pInfo)
{
	ASSERT(g_pProjWksWinIFace);
	CSlob* pDragSlob;
 	
	pDragSlob = pInfo->m_dragSlob;

	CMapPtrToPtr mapFileRegs;
	CMapPtrToPtr mapProjFileRegs;
	CProjItem * pItem;
    CBuildSlob * pDupItem;
	CObList * pAddListContents = pDragSlob->GetContentList();
	CTargetItem * pTarget = GetProjItem()->GetTarget();
	ASSERT(pTarget);
	CBuildSlob * pProjContainer = this;

	while (pProjContainer->GetContainer() != NULL)
	{
		pProjContainer = (CBuildSlob *)pProjContainer->GetContainer();
	}

 	FileRegHandle hndFileReg;
	ASSERT(!theUndoSlob.IsRecording());	// no need for pause/resume for Remove()

	CProject * pProject = GetProjItem()->GetProject();	
	ASSERT((pProjContainer->GetProjItem() == pTarget) || 
		(pProjContainer->GetProjItem() == pProject));

	if (!pProject->AreFilesUnique(pDragSlob))
	{
		InformationBox(IDS_DUPES_IN_SELECTION);
	}

	CBuildSlob * pBldSlob;
	::RecordContents(this, mapFileRegs, FALSE); // immediate contents
	::RecordContents(pProjContainer, mapProjFileRegs, TRUE); // proj contents

	// Can't delete slobs just yet, so just keep track of which ones to
	// delete later in DoDrop()
	ASSERT(m_DeathRow.IsEmpty());

	// Now cycle through items to be added (backwards!) and reject any we can't drop
	POSITION pos = pAddListContents->GetTailPosition();
	while (pos != NULL)
	{
		pBldSlob = (CBuildSlob *) pAddListContents->GetPrev(pos);
		pItem = (CProjItem *) pBldSlob->GetProjItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)))
		{
			CMultiSlob * pSelection;
			if (SUCCEEDED(g_pProjWksWinIFace->GetSelectedSlob(&pSelection)) && pSelection != NULL && pSelection->GetContentList()->GetCount() == 1)
			{
				// UNDONE: this doesn't work
				CSlob * pProjSlob = pBldSlob->GetContainer()->GetContainer();
				g_pProjWksWinIFace->SelectSlob(pProjSlob, FALSE); // must select something valid
			}
			g_pProjWksWinIFace->DeselectSlob(pBldSlob); // must unselect!
		}
		if ((pItem->IsKindOf(RUNTIME_CLASS(CFileItem))) ||
			(pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile))))
		{
			FileRegHandle hndFileReg = pItem->GetFileRegHandle();
			ASSERT(hndFileReg); // if in file reg, check if in this group
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				// duplicate: remove from group
				if (pBldSlob == pDupItem)
				{
					// Dropping into the same container
					// so we just remove from add list
					pDragSlob->Remove(pBldSlob);
				}
				else
				{
					// replace duplicate with pItem
					if (pDupItem->GetContainer() == this)
					{
						// remove duplicate from group
						m_DeathRow.AddHead((void *)pDupItem);
					}
					else
					{
						// the dupe is something we were adding,
						// so we must remove it from the list
						pDragSlob->Remove(pDupItem);

						// only delete it if we're doing a move
						// or copying a clone
						if (pDupItem->GetContainer()==NULL)
						{
							delete pDupItem;	// delete clone	
						}
						else if (!pInfo->IsCopy())
						{
							m_DeathRow.AddHead((void *)pDupItem);
						}
					}
					mapFileRegs.SetAt((void *)hndFileReg, (void *)pBldSlob);
				}			
			}
			else if (mapProjFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				if (pDupItem != pBldSlob)
				{
					VERIFY(mapProjFileRegs.RemoveKey((void *)hndFileReg));
					// remove duplicate from project
					m_DeathRow.AddHead((void *)pDupItem);
					mapFileRegs.SetAt((void *)hndFileReg, (void *)pBldSlob);
				}
				else if (pInfo->IsCopy())
				{
					// don't allow copy of this item within the project
					// so we just remove from add list
					pDragSlob->Remove(pBldSlob);
				}
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pBldSlob);
			}
		}
		else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			BOOL bReject = FALSE;
			CProjItem * pContainer = GetProjItem();
			ASSERT(pContainer != NULL);
			if (pContainer == pItem->GetContainer())
			{
				// can't add group to container it is already in
				pDragSlob->Remove(pBldSlob);
				bReject = TRUE;
			}
			else
			{
				while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
				{
					if (pContainer == pItem)
					{
						// can't add group to itself or its children
						pDragSlob->Remove(pBldSlob);
						bReject = TRUE;
						break;
					}
					pContainer = (CProjItem *)pContainer->GetContainer();
				}
			}
			// reject duplicates
			if (!bReject)
			{
				// reject duplicates in group content
				CObList ol;
				pBldSlob->FlattenContents(ol, TRUE);
				POSITION pos = ol.GetTailPosition();
				while (pos != (POSITION)NULL)
				{
					CBuildSlob * pContainedSlob = (CBuildSlob *)ol.GetPrev(pos);
					CProjItem * pContainedItem = pContainedSlob->GetProjItem();
					// the contained project item
					CBuildSlob * pDupeSlob;
					CBuildSlob * pProjDupeSlob;
					if (!pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
						continue;

					FileRegHandle hndFileReg = pContainedItem->GetFileRegHandle();
					ASSERT(hndFileReg); // if in file reg, check if in this group
					BOOL bInGroup = (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupeSlob));
					BOOL bInProj = (mapProjFileRegs.Lookup((void *)hndFileReg, (void * &) pProjDupeSlob));
					if (bInGroup && !bInProj)
					{
						// the dupe is something we were adding,
						// so we must remove it from the list
						pDragSlob->Remove(pDupeSlob);

						// only delete it if we're doing a move
						// or copying a clone
						if (pDupeSlob->GetContainer()==NULL)
						{
							delete pDupeSlob;	// delete clone	
						}
						else if (!pInfo->IsCopy())
						{
							m_DeathRow.AddHead((void *)pDupeSlob);
						}
					}
					else if (bInProj)
					{
						if (pProjDupeSlob != pContainedSlob)
						{
							VERIFY(mapProjFileRegs.RemoveKey((void *)pProjDupeSlob));
							m_DeathRow.AddHead((void *)pProjDupeSlob);
							if (bInGroup)
							{
								ASSERT(pProjDupeSlob == pDupeSlob);
							}
							mapFileRegs.SetAt((void *)hndFileReg, (void *)pContainedSlob);
					
						}
						else if (pInfo->IsCopy())
						{
							// don't allow copy of file already in project
							m_DeathRow.AddHead((void *)pContainedSlob);
						}
					}
					else
					{
						mapFileRegs.SetAt((void *)hndFileReg, (void *)pContainedSlob);
					}
				}
				ol.RemoveAll();
			}
		}
		else
		{
			// ignore all non-fileitems
			pDragSlob->Remove(pBldSlob); 	// removes dependency
		}	
	}

	if (pAddListContents->IsEmpty())
	{
		// Kill death row residents here, since we will never get to DoDrop
		while (!m_DeathRow.IsEmpty())
 			((CSlob *)m_DeathRow.RemoveHead())->MoveInto(NULL);
	}
	mapFileRegs.RemoveAll();
	mapProjFileRegs.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\configs.cpp ===
/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - "Project Configurations" dialog box.

#include "stdafx.h"
#pragma hdrstop
#include "bldslob.h"
#include "vwslob.h"
#include "configs.h"
#include "prjdlg.h"
#include "targdlg.h"
#include "awiface.h"
#include "targctrl.h"

#include <prjapi.h>
#include <prjguid.h>
#include "oleref.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// Subprojects dialog.

class CSubprojectCheckList : public CCheckList
{
public:
	
	struct CSubprojectCheckItem
	{
		HFILESET m_hFileSet;
		HPROJDEP m_hProjDep;
		BOOL m_bChecked : 1;
		BOOL m_bOriginalCheck : 1;
	};

	afx_msg void OnDestroy();
	
	void ResetContent();
	int AddItem(const TCHAR* szItemText, BOOL bChecked, HFILESET hFileSet, HPROJDEP hProjDep);
	
	void SetCheck(int nItem, int bCheck);
	int GetCheck(int nItem);
	
	void SetOriginalCheck(int nItem, int bCheck);
	int GetOriginalCheck(int nItem);
	
	void SetFileSet(int nItem, HFILESET hFileSet);
	HFILESET GetFileSet(int nItem);

	void SetProjDep(int nItem, HPROJDEP hProjDep);
	HPROJDEP GetProjDep(int nItem);

	int m_nMaxWidth;

	DECLARE_MESSAGE_MAP()
};

class CSubprojectsDlg : public C3dDialog
{
// Construction
public:
	CSubprojectsDlg(HFILESET hProject, CWnd* pParent = NULL);

// Dialog Data
public:
	CSubprojectCheckList m_subprojects;

// Overrides
protected:

// Implementation
protected:
	BOOL OnAccept();
	void OnSelProject();
	
	HFILESET m_hProject;

	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual void OnOK();
#if 0
	afx_msg void OnNew();
#endif

	void FillCurrent();
	void FillAvailable();

	DECLARE_MESSAGE_MAP()
};


void ChangeOKtoClose(CDialog* pDialog)
{
	CString str;
	VERIFY(str.LoadString(IDS_CLOSE));
	pDialog->SetDlgItemText(IDOK, str);
	pDialog->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - construction
CProjectConfigurationsDlg::CProjectConfigurationsDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(IDD_PROJECTS, pParent)
{
}

CProjectConfigurationsDlg::~CProjectConfigurationsDlg()
{
}

/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - message map, data exchange.
void CProjectConfigurationsDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);

	DDX_Control(pDX, IDC_CONFIGURATIONS_TREE, m_ConfigurationsTree);
}

BEGIN_MESSAGE_MAP(CProjectConfigurationsDlg, C3dDialog)
	ON_COMMAND(IDC_ADD, OnAddConfiguration)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CONFIGURATIONS_TREE, OnSelectConfiguration)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - initialization

BOOL CProjectConfigurationsDlg::OnInitDialog()
{
	if (!C3dDialog::OnInitDialog())
		return FALSE;

	// Fill the tree.
	FillTree();

	return TRUE;
}

void CProjectConfigurationsDlg::OnOK()
{
	// Flush the undo buffer
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	VERIFY (SUCCEEDED (pProjSysIFace->FlushUndo ()));

	CObList * plstCombos;
	POSITION pos;
	plstCombos = CConfigCombo::GetCombos();
	pos = plstCombos->GetHeadPosition();
	while (pos != NULL)
	{
		CConfigCombo * pTargetCombo = (CConfigCombo *)plstCombos->GetNext(pos);
		pTargetCombo->RefreshTargets();
	}
	
	C3dDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - message handlers
void CProjectConfigurationsDlg::OnAddConfiguration()
{
	// Get the projects name..
	HTREEITEM hItem = m_ConfigurationsTree.GetSelectedItem();
	if (IsConfig(hItem))
		hItem = m_ConfigurationsTree.GetParentItem(hItem);

	CString	strProject = GetProjectName(hItem);

	// Let the user create a new configuration.
	CNewProjectCopyDlg dlg(strProject, this);

	if (dlg.DoModal() == IDOK)
	{
		// don't do FillTree() here, because it will fully expand trees

		// Enumerate the children of this project tree item, and delete each one.
		HTREEITEM hConfigItem = m_ConfigurationsTree.GetChildItem(hItem);
		while (hConfigItem != NULL)
		{
			m_ConfigurationsTree.DeleteItem(hConfigItem);

			// Get the next item in the tree.
			hConfigItem = m_ConfigurationsTree.GetChildItem(hItem);
		}

		HFILESET hFileSet = (HFILESET)m_ConfigurationsTree.GetItemData(hItem);
		HBUILDER hBld = g_BldSysIFace.GetBuilderFromFileSet(hFileSet);

		// Get the fileset name.
		CString strFileset;

		if (!g_BldSysIFace.GetFileSetName(hFileSet, strFileset, hBld))
			return;

		// Now get the configurations for this project.
		CStringList slConfigurations;
		if (!g_BldSysIFace.GetFileSetTargets(hFileSet, slConfigurations))
			return;

		HTREEITEM hTreeConfiguration;

		// And add them to the tree.
		while (!slConfigurations.IsEmpty())
		{
			CString strConfiguration = slConfigurations.RemoveHead();

			// Get the HBLDTARGET for this configuration.
			HBLDTARGET hConfiguration = g_BldSysIFace.GetTarget(strConfiguration, NO_BUILDER);
			ASSERT(hConfiguration != NULL);

			// Remove the fileset name from the configuration name.
			ASSERT(strConfiguration.GetLength() > strFileset.GetLength() + 3);
			LPCTSTR pszConfiguration = (LPCTSTR)strConfiguration + strFileset.GetLength() + 3;

			// Add the configuration to the tree.
			hTreeConfiguration = m_ConfigurationsTree.InsertItem(pszConfiguration, hItem);
			VERIFY(m_ConfigurationsTree.SetItemData(hTreeConfiguration, (ULONG)hConfiguration));
		}

		// And expand the fileset.
		m_ConfigurationsTree.Expand(hItem, TVE_EXPAND);
	}
}

void CProjectConfigurationsDlg::OnRemove()
{
	// Get the selected item.
	HTREEITEM hItem = m_ConfigurationsTree.GetSelectedItem();
	BOOL bConfig = IsConfig(hItem);
	LPCTSTR pszItemName = bConfig ? GetConfigName(hItem) : GetProjectName(hItem);
	UINT nMsg = bConfig ? IDS_DEL_CONFIG : IDS_DEL_PROJECT;

	// Confirm the action.
	CString strMsg;
	AfxFormatString1(strMsg, nMsg, pszItemName);
	if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONQUESTION) == IDYES)
	{
		CWaitCursor curWait;

		if (bConfig)
		{
			// Get the HBLDTARGET.
			HBLDTARGET hConfig = GetConfig(hItem);
			HBUILDER hBld = g_BldSysIFace.GetBuilder(hConfig);

			// Delete the target.
			g_BldSysIFace.DeleteTarget(hConfig, hBld);
			CProject *pProject = g_BldSysIFace.CnvHBuilder(hBld);
			pProject->InformDependants(SN_ALL);
		}
		else
		{
			// Enumerate the children of this project node, and delete each one.
			HTREEITEM hConfigItem = m_ConfigurationsTree.GetChildItem(hItem);
			HBLDTARGET hConfig = GetConfig(hConfigItem);
			HBUILDER hBld = g_BldSysIFace.GetBuilder(hConfig);
			CProject *pProject = g_BldSysIFace.CnvHBuilder(hBld);
			IBSProject *pBSProj = pProject->GetInterface();
			COleRef<IPkgProject> pPkgProj;
			pBSProj->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
			pBSProj->Release();
			BOOL retVal =SUCCEEDED(g_pProjWksIFace->DeleteProject(pPkgProj, FALSE));

			while (hConfigItem != NULL)
			{

				// Delete the tree item (so we don't have to do FillTree(), which fully expands trees)
				m_ConfigurationsTree.DeleteItem(hConfigItem);

				// Get the next item in the tree.
				hConfigItem = m_ConfigurationsTree.GetChildItem(hItem);
			}
			m_nFileset--;
		}

		// Delete the tree item (so we don't have to do FillTree(), which fully expands trees)
		m_ConfigurationsTree.DeleteItem(hItem);
	}
}

/*
void CProjectConfigurationsDlg::OnDependencies()
{
	// Get the selected project.
	HTREEITEM hItem = m_ConfigurationsTree.GetSelectedItem();
	if (IsConfig(hItem))
		hItem = m_ConfigurationsTree.GetParentItem(hItem);

	CSubprojectsDlg dlg(GetProject(hItem), this);
	dlg.DoModal();
}
*/

void CProjectConfigurationsDlg::OnSelectConfiguration(NMHDR* pNMHDR, LRESULT* pResult)
{
	EnableButtons();
}

/////////////////////////////////////////////////////////////////////////////
// CProjectConfigurationsDlg - helpers
void CProjectConfigurationsDlg::EnableButtons()
{
	
	HTREEITEM hItem = m_ConfigurationsTree.GetSelectedItem();
	BOOL bConfig = IsConfig(hItem);
	BOOL bEnableRemove;
	HBUILDER hBld;

	if ( bConfig )
	{
		// Enable if there is atleast one more config let after we delete this one.
		bEnableRemove = m_ConfigurationsTree.GetNextSiblingItem(hItem) != NULL 
			|| m_ConfigurationsTree.GetPrevSiblingItem(hItem) != NULL;
		hBld = g_BldSysIFace.GetBuilder(GetConfig(hItem));

	}	
	else
	{
		// If this is a target it shouldn't be the last one.
		bEnableRemove = m_nFileset > 1;
		hBld = g_BldSysIFace.GetBuilderFromFileSet(GetProject(hItem));
	}

	// Can't remove the last configuration, nor a project.
	GetDlgItem(IDC_REMOVE)->EnableWindow(bEnableRemove);

	// Can't add target to projects with unsupported project types.
	CProject * pProject = g_BldSysIFace.CnvHBuilder(hBld);
	CProjType * pProjType = pProject->GetProjType();
	GetDlgItem(IDC_ADD)->EnableWindow(pProjType->IsSupported());

	// The rules for dependencies are so "magic," we'll leave
	// button enabled, and display a message box if we can't do it.
}

void CProjectConfigurationsDlg::FillTree()
{
	DWORD dwSelected = 0;
	// BLOCK: Get the selected item.
	{
		HTREEITEM hItem = m_ConfigurationsTree.GetSelectedItem();
		if (hItem != NULL)
			dwSelected = m_ConfigurationsTree.GetItemData(hItem);
		else
			dwSelected = (DWORD)g_BldSysIFace.GetActiveTarget();
	}

	// Clear the tree.
	m_ConfigurationsTree.DeleteAllItems();
	m_nFileset = 0;
	
	// Select this item.
	HTREEITEM hSelItem = NULL;

	// Fill the tree with project configurations.
	HBUILDER hBld;
	HFILESET hFileSet;
	CString strProject;
	// iterate over all projects
	g_BldSysIFace.InitBuilderEnum();
	while ((hBld = g_BldSysIFace.GetNextBuilder(strProject, FALSE /* REVIEW */)) != NO_BUILDER)
	{
		g_BldSysIFace.InitFileSetEnum(hBld);
		while ((hFileSet = g_BldSysIFace.GetNextFileSet(hBld)) != NULL)
		{
			// Get the fileset name.
			CString strFileset;
			if (!g_BldSysIFace.GetFileSetName(hFileSet, strFileset, hBld))
				continue;

			// Insert the item.
			HTREEITEM hTreeFileset = m_ConfigurationsTree.InsertItem(strFileset);
			VERIFY(m_ConfigurationsTree.SetItemData(hTreeFileset, (ULONG)hFileSet));

			// Select this item?
			if (dwSelected == (DWORD)hFileSet)
				hSelItem = hTreeFileset;

			// Now get the configurations for this project.
			CStringList slConfigurations;
			if (!g_BldSysIFace.GetFileSetTargets(hFileSet, slConfigurations))
				continue;

			HTREEITEM hTreeConfiguration = NULL;

			// And add them to the tree.
			while (!slConfigurations.IsEmpty())
			{
				CString strConfiguration = slConfigurations.RemoveHead();

				// Get the HBLDTARGET for this configuration.
				HBLDTARGET hConfiguration = g_BldSysIFace.GetTarget(strConfiguration, hBld);
				ASSERT(hConfiguration != NULL);

				// Remove the fileset name from the configuration name.
				ASSERT(strConfiguration.GetLength() > strFileset.GetLength() + 3);
				LPCTSTR pszConfiguration = (LPCTSTR)strConfiguration + strFileset.GetLength() + 3;

				// Add the configuration to the tree.
				hTreeConfiguration = m_ConfigurationsTree.InsertItem(pszConfiguration, hTreeFileset);
				VERIFY(m_ConfigurationsTree.SetItemData(hTreeConfiguration, (ULONG)hConfiguration));

				// Select this item?
				if (dwSelected == (DWORD)hConfiguration)
					hSelItem = hTreeConfiguration;
			}

			// And expand the fileset.
			m_ConfigurationsTree.Expand(hTreeFileset, TVE_EXPAND);
			m_nFileset++;

			// make a selection in any case
			if (hSelItem == NULL)
				hSelItem = hTreeConfiguration;
		}
	}

	// Select an item?
	if (hSelItem != NULL)
	{
		// Select the new item.
		m_ConfigurationsTree.Select(hSelItem, TVGN_CARET);
		m_ConfigurationsTree.EnsureVisible(hSelItem);
	}

	// Enable/Disable the buttons.
	EnableButtons();
}

void CProjectConfigurationsDlg::CalculateInvalidDependencies(HBLDTARGET hConfig, CStringList& rslConfigs)
{
	// Get the configurations name.
	CString strConfigName;
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hConfig);
	VERIFY(g_BldSysIFace.GetTargetName(hConfig, strConfigName, hBld));

	// Get the active project.
	CProject* pProject = g_BldSysIFace.CnvHBuilder(hBld);

	// BLOCK:
	{
		CTargetItem *pTarget = pProject->GetTarget(strConfigName);
		// Get the target items config array
		const CPtrArray* pConfigArray = pTarget->GetConfigArray();
		int nSize = pConfigArray->GetSize();

		// Look for valid configs for this target item and add to filter list
		ConfigurationRecord * pcr = NULL;
		for (int i = 0; i < nSize; i++)
		{
			pcr = (ConfigurationRecord*)pConfigArray->GetAt(i);
			if (pcr->IsValid())
			{
				CString str = pcr->GetConfigurationName();
				// add to filter list
				if (!rslConfigs.Find(str))
					rslConfigs.AddTail(str);
			}
		}
	}

	const CPtrArray & ppcr = *pProject->GetConfigArray();
	ConfigurationRecord * pcr;
	int ccr = ppcr.GetSize();

	// BLOCK:
	{
		for (int icr = 0; icr < ccr; icr++)
		{
			pcr = (ConfigurationRecord *)ppcr[icr];

			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(pcr);

//			if (pProject->TargetReachable(strConfigName))
//				rslConfigs.AddTail(pcr->GetConfigurationName());
 		}
	}

	// BLOCK:
	{
		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig(strConfigName);

		CObList ol;
		pProject->FlattenSubtree(ol, CProjItem::flt_Normal | CProjItem::flt_ExcludeGroups | CProjItem::flt_RespectItemExclude | 
						CProjItem::flt_ExcludeDependencies | CProjItem::flt_RespectTargetExclude);
		POSITION pos = ol.GetHeadPosition();
		while (pos != NULL)
		{
			CProjItem * pItem = (CProjItem *)ol.GetNext(pos);
			
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				/* 
				CString strTarget;

				((CTargetReference*)pItem)->GetStrProp(P_TargetRefName, strTarget);
				rslConfigs.AddTail(strTarget);
				*/
			}
		}
	}
}

BOOL CProjectConfigurationsDlg::IsConfig(HTREEITEM hItem)
{
	return !m_ConfigurationsTree.ItemHasChildren(hItem);
}

HBLDTARGET CProjectConfigurationsDlg::GetConfig(HTREEITEM hItem)
{
	ASSERT(IsConfig(hItem));

	// Get the HBLDTARGET from the item.
	return (HBLDTARGET) m_ConfigurationsTree.GetItemData(hItem);
}

LPCTSTR CProjectConfigurationsDlg::GetConfigName(HTREEITEM hItem)
{
	static CString strConfiguration;
	ASSERT(IsConfig(hItem));

	// Get the HBLDTARGET.
	HBLDTARGET hConfig = GetConfig(hItem);
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hConfig);

	// Get the name from the build system.
	if (g_BldSysIFace.GetTargetName(hConfig, strConfiguration, hBld))
		return strConfiguration;
	else
		return NULL;
}

HFILESET CProjectConfigurationsDlg::GetProject(HTREEITEM hItem)
{
	ASSERT(!IsConfig(hItem));

	// Get the HFILESET from the item.
	return (HFILESET) m_ConfigurationsTree.GetItemData(hItem);
}

LPCTSTR CProjectConfigurationsDlg::GetProjectName(HTREEITEM hItem)
{
	static CString strFileset;
	ASSERT(!IsConfig(hItem));

	// Get the HFILESET.
	HFILESET hFileset = GetProject(hItem);
	HBUILDER hBld = g_BldSysIFace.GetBuilderFromFileSet(hFileset);

	// Get the name from the build system.
	if (g_BldSysIFace.GetFileSetName(hFileset, strFileset, hBld))
		return strFileset;
	else
		return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSubprojectsCheckList

BEGIN_MESSAGE_MAP(CSubprojectCheckList, CCheckList)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

void CSubprojectCheckList::OnDestroy()
{
	ResetContent();
	CCheckList::OnDestroy();
}

void CSubprojectCheckList::ResetContent()
{
	m_nMaxWidth = 0;
	int nItemCount = GetCount();
	for (int i = 0; i < nItemCount; i += 1)
		delete (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(i);
	
	if (m_hWnd != NULL)
		CCheckList::ResetContent();
}

int CSubprojectCheckList::AddItem(const TCHAR* szItemText, BOOL bChecked, HFILESET hFileSet, HPROJDEP hProjDep)
{
	CSubprojectCheckItem* pItem = new CSubprojectCheckItem;
	pItem->m_hFileSet = hFileSet;
	pItem->m_hProjDep = hProjDep;
	pItem->m_bChecked = bChecked;
	pItem->m_bOriginalCheck = bChecked;

	CClientDC dc(this);
	int nItem = CCheckList::AddString(szItemText);

	int width = dc.GetTextExtent(szItemText, _tcslen(szItemText)).cx;
	if (width > m_nMaxWidth)
	{
		// might need horz scrollbars
		m_nMaxWidth = width;
		SetHorizontalExtent(width + 14); // add width of checkbox
	}

	CCheckList::SetItemDataPtr(nItem, pItem);

	return nItem;
}

void CSubprojectCheckList::SetCheck(int nItem, int bCheck /*=TRUE*/)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	ASSERT(pItem != NULL);
	pItem->m_bChecked = bCheck;
	InvalidateCheck(nItem);
}

int CSubprojectCheckList::GetCheck(int nItem)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	ASSERT(pItem != NULL);
	return pItem->m_bChecked ? 1 : 0;
}

void CSubprojectCheckList::SetOriginalCheck(int nItem, int bCheck /*=TRUE*/)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	ASSERT(pItem != NULL);
	pItem->m_bOriginalCheck = bCheck;
}

int CSubprojectCheckList::GetOriginalCheck(int nItem)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	return pItem->m_bOriginalCheck ? 1 : 0;
}

void CSubprojectCheckList::SetFileSet(int nItem, HFILESET hFileSet)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	ASSERT(pItem != NULL);
	pItem->m_hFileSet = hFileSet;
}

HFILESET CSubprojectCheckList::GetFileSet(int nItem)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	return pItem->m_hFileSet;
}

void CSubprojectCheckList::SetProjDep(int nItem, HPROJDEP hProjDep)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	ASSERT(pItem != NULL);
	pItem->m_hProjDep = hProjDep;
}

HPROJDEP CSubprojectCheckList::GetProjDep(int nItem)
{
	CSubprojectCheckItem* pItem = (CSubprojectCheckItem*)CCheckList::GetItemDataPtr(nItem);
	return pItem->m_hProjDep;
}


/////////////////////////////////////////////////////////////////////////////
// CSubprojectsDlg dialog

CSubprojectsDlg::CSubprojectsDlg(HFILESET hProject, CWnd* pParent /*=NULL*/)
	: C3dDialog(IDD_SUBPROJECTS, pParent), m_hProject(hProject)
{
}

BEGIN_MESSAGE_MAP(CSubprojectsDlg, C3dDialog)
	ON_CBN_SELCHANGE(IDC_PROJECT, OnSelProject)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSubprojectsDlg message handlers

void FillProjectCombo(CComboBox* pCombo, HFILESET hFilesetSelect)
{
	pCombo->ResetContent();

	HBUILDER hBld;
	HFILESET hFileSet;
	CString strSelect, strProject;
	// iterate over all projects
	g_BldSysIFace.InitBuilderEnum();
	while ((hBld = g_BldSysIFace.GetNextBuilder(strProject, FALSE /* REVIEW */)) != NO_BUILDER)
	{
		// Fill the tree with project configurations.
		g_BldSysIFace.InitFileSetEnum(hBld);
		while (hFileSet = g_BldSysIFace.GetNextFileSet(hBld))
		{
			// Get the fileset name.
			CString strFileset;
			if (!g_BldSysIFace.GetFileSetName(hFileSet, strFileset, hBld))
				continue;

			int nItem = pCombo->AddString(strFileset);
			pCombo->SetItemData(nItem, (ULONG)hFileSet);
		
			if (hFilesetSelect == hFileSet)
				strSelect = strFileset;
		}
	}
	pCombo->SelectString(-1,strSelect);
}

BOOL CSubprojectsDlg::OnInitDialog()
{
	C3dDialog::OnInitDialog();

	m_subprojects.SubclassDlgItem(IDC_SUBPROJECTS, this);

	FillProjectCombo((CComboBox*)GetDlgItem(IDC_PROJECT), m_hProject);
	
	m_subprojects.ResetContent();
	FillCurrent();
	FillAvailable();

	return TRUE;
}

BOOL CSubprojectsDlg::OnAccept()
{
	BOOL bAnyChanges = FALSE;
	int nItemCount = m_subprojects.GetCount();
	HBUILDER  hProjBld = g_BldSysIFace.GetBuilderFromFileSet(m_hProject);
	CProject * pTopProject = g_BldSysIFace.CnvHBuilder(hProjBld);
	for (int i = 0; i < nItemCount; i += 1)
	{
		BOOL bChecked = m_subprojects.GetCheck(i);
		BOOL bOriginalCheck = m_subprojects.GetOriginalCheck(i);
		if (bChecked == bOriginalCheck)
			continue;
		
		bAnyChanges = TRUE;

		HFILESET hFileSet = m_subprojects.GetFileSet(i);
		HBUILDER hBld = g_BldSysIFace.GetBuilderFromFileSet(hFileSet);
		CProject * pSubProject = g_BldSysIFace.CnvHBuilder(hBld);
		if (bChecked)
		{

 			if (g_BldSysIFace.AddProjectDependency(m_hProject, hFileSet, hProjBld, hBld) == NULL)
			{
  				AfxMessageBox(IDS_ERR_NEWDEP, MB_ICONEXCLAMATION);
				
				m_subprojects.SetCurSel(i);
				m_subprojects.SetFocus();
				return FALSE;
   			}

		}
		else
		{
			CString strSub;
			CProjectDependency * pProjDep = g_BldSysIFace.CnvHProjDep(m_hProject, m_subprojects.GetProjDep(i));
			pProjDep->GetStrProp(P_ProjItemName,strSub);

			if (!g_BldSysIFace.RemoveProjectDependency(m_subprojects.GetProjDep(i), m_hProject, hProjBld))
			{
				MessageBeep(0); // no message would make any more sense here...
				m_subprojects.SetCurSel(i);
				m_subprojects.SetFocus();
				return FALSE;
			}
			// search list for the dep
			CString strTop; pTopProject->GetName(strTop);
			::RemoveDep( strTop, strSub );
		}
		SetWorkspaceDocDirty();
	}
	
	if (bAnyChanges)
		ChangeOKtoClose(this);

	return TRUE;
}

void CSubprojectsDlg::OnOK()
{
	if (!OnAccept())
		return;

	// Flush the undo buffer
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	VERIFY (SUCCEEDED (pProjSysIFace->FlushUndo ()));
	
	C3dDialog::OnOK();
}

void CSubprojectsDlg::OnSelProject()
{
	CComboBox* pCombo = (CComboBox*)GetDlgItem(IDC_PROJECT);

	if (!OnAccept())
	{
		int nItemCount = pCombo->GetCount();
		for (int i = 0; i < nItemCount; i += 1)
		{
			if (m_hProject == (HFILESET)pCombo->GetItemData(i))
			{
				pCombo->SetCurSel(i);
				break;
			}
		}
		return;
	}
	
	int nItem = pCombo->GetCurSel();
	ASSERT(nItem >= 0);
	HFILESET hFileSet = (HFILESET)pCombo->GetItemData(nItem);
	ASSERT(hFileSet != NULL);
	
	m_hProject = hFileSet;
	m_subprojects.ResetContent();
	FillCurrent();
	FillAvailable();
}

extern 	BOOL SelectFilesetInCombo(CComboBox* pCombo, HFILESET hFileset);

void CSubprojectsDlg::FillCurrent()
{
	g_BldSysIFace.InitProjectDepEnum(m_hProject);
	for (;;)
	{
		HPROJDEP hProjDep = g_BldSysIFace.GetNextProjectDep(m_hProject);
		if (hProjDep == NULL)
			break;

		CString strSubproject;
		HFILESET hFileSet = g_BldSysIFace.GetDependantProject(hProjDep, m_hProject, ACTIVE_BUILDER);
		if (hFileSet)
		{
			g_BldSysIFace.GetFileSetName(hFileSet, strSubproject, ACTIVE_BUILDER);
			m_subprojects.AddItem(strSubproject, TRUE, NULL, hProjDep);
		}
	}
}

void CSubprojectsDlg::FillAvailable()
{
	CStringList slInvalid;

	HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();

	CString strFileSet;
 	CTargetItem * pSelectedTarget = g_BldSysIFace.CnvHFileSet(hBld, m_hProject);

	HFILESET hFileSet;
	CString strProject;
	// iterate over all projects
	g_BldSysIFace.InitBuilderEnum();
	while ((hBld = g_BldSysIFace.GetNextBuilder(strProject, TRUE /* REVIEW */)) != NO_BUILDER)
	{
		g_BldSysIFace.InitFileSetEnum(hBld);
		for (;;)
		{
			hFileSet = g_BldSysIFace.GetNextFileSet(hBld);
			if (hFileSet == NULL)
				break;

			if (hFileSet == m_hProject)
				continue;

	 		CTargetItem * pTarget = g_BldSysIFace.CnvHFileSet(hBld, hFileSet);

			if (pTarget->IsTargetReachable(pSelectedTarget))
				continue;

			if (pSelec