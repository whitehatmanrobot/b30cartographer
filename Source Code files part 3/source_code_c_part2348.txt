s the argument
;                is the stack top.  For fFATN2 the numerator
;                is next to stack top, the denominator is
;                the stack top.
;                For single argument functions the sign is
;                in bit 2 of CL.  For fFATN2 the numerator
;                sign is bit 2 of CH, the denominator
;                sign is bit 2 of CL.
;
;		 Note:
;		 _clog calls fFATN2 with the signs of the arguments
;		 in bit 0 of CL and CH respectively.  This should
;		 work since fFATN2 tests for sign of numerator and
;		 denominator by using "or CL,CL" and "or CH,CH"
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFASN
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	xchg	ch, cl			; sign(num.)=sign(arg)
	jmp	short fFPATAN


lab fFACS
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	fxch				; num.=sqrt(1-arg^2), den.=arg
	jmp	short fFPATAN


lab fFATN
	fabs
	fld1				; denominator is 1
	mov	ch, cl
	xor	cl, cl			; sign of denominator is +ve
	jmp	short fFPATAN


labelNP _fFATN2, PUBLIC
lab fFATN2
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	fabs
	fxch
	fabs
	fxch

lab fFPATAN
	fpatan				; compute partial arctangent
	or	cl, cl			; if denominator was +ve
	JSZ	PatanNumeratorTest	;    bypass -ve denominator adjust
	fldpi
	fsubrp	st(1), st(0)		; change Patan to pi - Patan

lab PatanNumeratorTest
	or	ch, ch			; if numerator was +ve
	JSZ	PatanDone		;    bypass -ve numerator adjust
	fchs				; change Patan to -Patan

lab PatanDone
	ret

page

lab AugmentSinCos
	fabs				; NOS=x = |input|
	fld	st(0)			; NOS=x, TOS=x
	fld	st(0)			; NNOS=x, NOS=x, TOS=x
	fld1				; NNNOS=x, NNOS=x, NOS=x, TOS=1
	fsubrp	st(1),st(0)		; NNOS=x, NOS=x, TOS=1-x
	fxch				; NNOS=x, NOS=1-x, TOS=x
	fld1				; NNNOS=x, NNOS=1-x, NOS=x, TOS=1
	fadd				; NNOS=x, NOS=1-x, TOS=1+x
	fmul				; NOS=x, TOS=1-x^2
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 1		; if 1-x^2 < 0
	JSNZ	DescriminantNeg 	;    return a NAN
	xor	ch, ch			; sign of TOS is +ve
	fsqrt				; NOS=x, TOS=sqrt(1-x^2)
	ret

lab DescriminantNeg
	pop	rax			; remove return address from stack
	jmp	_rtindfpop		; replace top of stack with a NAN

page
;----------------------------------------------------------
;
;       SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The signs of the last, second to last
;                arguments are in CH, CL respectively.
;
;       OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rtpiby2, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_piby2]		; push pi/2 onto stack
	ret


lab _rtforatn20
	fstp	st(0)			; remove ST(0)
	or	cl ,cl			; if denominator is +ve
	JSZ	zeronpop		;    return zero
	fstp	st(0)
	fldpi				; push pi onto stack
	or	ch, ch			; if numerator was +ve
	JSZ	postv
	fchs
lab postv
	ret

lab zeronpop
    fstp    st(0)
    fldz                ; push 0.0 onto stack
    or  ch, ch          ; if numerator was +ve
    JSZ postv
    fchs
    ret


lab _rtforatn200
lab indfpop
	fstp	st(0)			; remove ST(0)
lab indfnpop
	jmp	_rtindfnpop		; return real indefinite


lab _rtforatnby0
	fstp	st(0)			; remove an argument before returning
	mov	cl, ch			; cl is sign(TOS)
	jmp	short _rtsignpiby2


lab _rtforatninf
lab _rtsignpiby2
	call	_rtpiby2		; push pi/2 onto stack
	jmp	_rtchsifneg		; return with sign change if negative

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\asin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ASIN_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\adj_fdiv.asm ===
title   adj_fdiv   - routines to compensate for incorrect Pentium FDIV
;*** 
;adj_fdiv - routines to compensate for incorrect Pentium FDIV
;
;   Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Workarounds to correct for broken FDIV
;
;Revision History:
;
;   12/06/94	Jamie MacCalman
;		initial version, based on Intel fix
;   12/09/94	Jamie MacCalman
;		added _adj_fpremX & _safe_fdivX entry points
;   12/13/94	Jamie MacCalman
;		upgraded to V.3 of Intel's workarounds
;   12/19/94	Jamie MacCalman
;		upgraded to V.4 of Intel's workarounds
;   12/27/94	Jamie MacCalman
;		upgraded to V.5 (aka "V1.0") of Intel's workarounds
;    1/13/95	Jamie MacCalman
;		added underscores to fdivp_sti_st & fdivrp_sti_st for ANSI conformance
;
;  The following code is a PRELIMINARY IMPLEMENTATION of a
;  software patch for the floating point divide instructions.
;
;


	include cruntime.inc
	include mrt386.inc
	include elem87.inc

;
;  Stack variables for divide routines.
;

DENOM		EQU	0
NUMER		EQU	12
PREV_CW		EQU	28
PATCH_CW 	EQU	32

DENOM_SAVE	EQU	32

MAIN_DENOM	EQU	4
MAIN_NUMER	EQU	16

SPILL_SIZE	EQU	12
MEM_OPERAND	EQU	8
STACK_SIZE	EQU	44
SPILL_MEM_OPERAND	EQU	20

ONESMASK	EQU	0e000000h

SINGLE_NAN	EQU	07f800000h
DOUBLE_NAN	EQU	07ff00000h

ILLEGAL_OPC	EQU	6

;
; FPREM constants
;

FPREM_FLT_SIZE		EQU	12
FPREM_DENOM			EQU 0
FPREM_DENOM_SAVE	EQU	FPREM_DENOM + FPREM_FLT_SIZE
FPREM_NUMER			EQU FPREM_DENOM_SAVE + FPREM_FLT_SIZE
FPREM_PREV_CW		EQU FPREM_NUMER + FPREM_FLT_SIZE
FPREM_PATCH_CW		EQU FPREM_PREV_CW + 4
FPREM_SW			EQU	FPREM_PATCH_CW + 4
FPREM_STACK_SIZE	EQU FPREM_SW + 4
FPREM_RET_SIZE		EQU	4
FPREM_PUSH_SIZE		EQU	4

FPREM_MAIN_FUDGE	EQU	FPREM_RET_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE

FPREM_MAIN_DENOM		EQU FPREM_DENOM + FPREM_MAIN_FUDGE
FPREM_MAIN_DENOM_SAVE	EQU	FPREM_DENOM_SAVE + FPREM_MAIN_FUDGE
FPREM_MAIN_NUMER		EQU FPREM_NUMER + FPREM_MAIN_FUDGE
FPREM_MAIN_PREV_CW		EQU	FPREM_PREV_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_PATCH_CW		EQU	FPREM_PATCH_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_FPREM_SW		EQU	FPREM_SW + FPREM_MAIN_FUDGE

FPREM_ONESMASK	EQU     700h


.data

fdiv_risc_table	DB	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fdiv_scale_1  	DD	03f700000h		;0.9375
fdiv_scale_2	DD	03f880000h		;1.0625
one_shl_63  	DD	05f000000h

fprem_risc_table 	DB 	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fprem_scale 		DB 	0, 0, 0, 0, 0, 0, 0eeh, 03fh
one_shl_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 043h
one_shr_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 03bh
one 			DB 	0, 0, 0, 0, 0, 0, 0f0h, 03fh
half 			DB 	0, 0, 0, 0, 0, 0, 0e0h, 03fh
big_number		DB	0, 0, 0, 0, 0, 0, 0ffh, 0ffh, 0feh, 07fh

ifdef	DEBUG
	public	fpcw
	public	fpsw
fpcw	dw	0
fpsw	dw	0
endif

FPU_STATE	STRUC
	CONTROL_WORD	DW	?
	reserved_1	DW	?
	STATUS_WORD	DD	?
	TAG_WORD	DW	?
	reserved_3	DW	?
	IP_OFFSET	DD	?
	CS_SLCT		DW	?
	OPCODE		DW	?
	DATA_OFFSET	DD	?
	OPERAND_SLCT	DW	?
	reserved_4	DW	?
FPU_STATE	ENDS

ENV_SIZE	EQU	28



dispatch_table DD	offset FLAT:label0
	DD	offset FLAT:label1
	DD	offset FLAT:label2
	DD	offset FLAT:label3
	DD	offset FLAT:label4
	DD	offset FLAT:label5
	DD	offset FLAT:label6
	DD	offset FLAT:label7
	DD	offset FLAT:label8
	DD	offset FLAT:label9
	DD	offset FLAT:label10
	DD	offset FLAT:label11
	DD	offset FLAT:label12
	DD	offset FLAT:label13
	DD	offset FLAT:label14
	DD	offset FLAT:label15
	DD	offset FLAT:label16
	DD	offset FLAT:label17
	DD	offset FLAT:label18
	DD	offset FLAT:label19
	DD	offset FLAT:label20
	DD	offset FLAT:label21
	DD	offset FLAT:label22
	DD	offset FLAT:label23
	DD	offset FLAT:label24
	DD	offset FLAT:label25
	DD	offset FLAT:label26
	DD	offset FLAT:label27
	DD	offset FLAT:label28
	DD	offset FLAT:label29
	DD	offset FLAT:label30
	DD	offset FLAT:label31
	DD	offset FLAT:label32
	DD	offset FLAT:label33
	DD	offset FLAT:label34
	DD	offset FLAT:label35
	DD	offset FLAT:label36
	DD	offset FLAT:label37
	DD	offset FLAT:label38
	DD	offset FLAT:label39
	DD	offset FLAT:label40
	DD	offset FLAT:label41
	DD	offset FLAT:label42
	DD	offset FLAT:label43
	DD	offset FLAT:label44
	DD	offset FLAT:label45
	DD	offset FLAT:label46
	DD	offset FLAT:label47
	DD	offset FLAT:label48
	DD	offset FLAT:label49
	DD	offset FLAT:label50
	DD	offset FLAT:label51
	DD	offset FLAT:label52
	DD	offset FLAT:label53
	DD	offset FLAT:label54
	DD	offset FLAT:label55
	DD	offset FLAT:label56
	DD	offset FLAT:label57
	DD	offset FLAT:label58
	DD	offset FLAT:label59
	DD	offset FLAT:label60
	DD	offset FLAT:label61
	DD	offset FLAT:label62
	DD	offset FLAT:label63


fpcw	dw	0



CODESEG


;
;  PRELIMINARY VERSION for register-register divides.
;


					; In this implementation the
					; fdiv_main_routine is called,
					; therefore all the stack frame
					; locations are adjusted for the
					; return pointer.

fdiv_main_routine PROC	NEAR

	fld     tbyte ptr [esp+MAIN_NUMER]	; load the numerator
	fld     tbyte ptr [esp+MAIN_DENOM]	; load the denominator
retry:

;  The following three lines test for denormals and zeros.
;  A denormal or zero has a 0 in the explicit digit to the left of the
;  binary point.  Since that bit is the high bit of the word, adding
;  it to itself will produce a carry if and only if the number is not
;  denormal or zero.
;
	mov 	eax, [esp+MAIN_DENOM+4]	; get mantissa bits 32-64
	add 	eax,eax			; shift the one's bit onto carry
	jnc 	denormal		; if no carry, we're denormal

;  The following three lines test the three bits after the four bit 
;  pattern (1,4,7,a,d).  If these three bits are not all one, then
;  the denominator cannot expose the flaw.  This condition is tested by
;  inverting the bits and testing that all are equal to zero afterward.

	xor 	eax, ONESMASK		; invert the bits that must be ones
	test	eax, ONESMASK		; and make sure they are all ones
	jz  	scale_if_needed		; if all are one scale numbers
	fdivp	st(1), st		; use of hardware is OK.
	ret

;
;  Now we test the four bits for one of the five patterns.
;
scale_if_needed:
	shr	eax, 28			; keep first 4 bits after point
	cmp	byte ptr fdiv_risc_table[eax], 0	; check for (1,4,7,a,d)
	jnz	divide_scaled		; are in potential problem area
	fdivp	st(1), st		; use of hardware is OK.
	ret

divide_scaled:
	mov	eax, [esp + MAIN_DENOM+8]	; test denominator exponent
	and	eax, 07fffh             ; if pseudodenormal ensure that only
	jz	invalid_denom		; invalid exception flag is set
	cmp	eax, 07fffh             ; if NaN or infinity  ensure that only
	je	invalid_denom		; invalid exception flag is set
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;
	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

;  The following lines check the numerator exponent before scaling.
;  This in order to prevent undeflow when scaling the numerator,
;  which will cause a denormal exception flag to be set when the
;  actual divide is preformed. This flag would not have been set
;  normally. If there is a risk of underflow, the scale factor is
;  17/16 instead of 15/16.
;
 	mov	eax, [esp+MAIN_NUMER+8]	; test numerator exponent
 	and	eax, 07fffh
 	cmp	eax, 00001h
 	je	small_numer

	fmul	fdiv_scale_1		; scale denominator by 15/16
	fxch
	fmul	fdiv_scale_1		; scale numerator by 15/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

small_numer:
	fmul	fdiv_scale_2		; scale denominator by 17/16
	fxch
	fmul	fdiv_scale_2		; scale numerator by 17/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal:
	mov	eax, [esp+MAIN_DENOM]	; test for whole mantissa == 0
	or	eax, [esp+MAIN_DENOM+4]	; test for whole mantissa == 0
	jnz	denormal_divide_scaled	; denominator is not zero
invalid_denom:				; zero or invalid denominator
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal_divide_scaled:
	mov	eax, [esp + MAIN_DENOM + 8]	; get exponent 
	and	eax, 07fffh		; check for zero exponent
	jnz	invalid_denom		; 
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;

	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

	mov	eax, [esp + MAIN_NUMER +8]	; test numerator exponent
	and	eax, 07fffh		; check for denormal numerator
	je	denormal_numer	
	cmp	eax, 07fffh		; NaN or infinity
	je	invalid_numer
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jnc	invalid_numer		; if there is no carry, we have an
					; invalid numer
	jmp	numer_ok

denormal_numer:
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jc	invalid_numer		; if there is a carry, we have an
					; invalid numer
	
numer_ok:
	fxch
	fstp	st			; pop numerator
	fld 	st			; make copy of denominator
	fmul	dword ptr[one_shl_63]	; make denominator not denormal
	fstp	tbyte ptr [esp+MAIN_DENOM]	; save modified denominator
	fld 	tbyte ptr [esp+MAIN_NUMER]	; load numerator
	fxch				; restore proper order
	fwait

;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	jmp	retry			; start the whole thing over

invalid_numer:
;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;
	fldcw	[esp + PREV_CW]
	fdivp	st(1), st		; use of hardware is OK.
	ret

fdiv_main_routine	ENDP

fdivr_st	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdivr_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	add	esp, STACK_SIZE
ENDM

fdivrp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM

fdiv_st		MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdiv_sti	MACRO	reg_index, reg_index_minus1
	fxch	st(reg_index)
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	add	esp, STACK_SIZE
ENDM

fdivp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM 


	public  _adj_fdiv_r
_adj_fdiv_r      PROC    NEAR

	sub	esp, STACK_SIZE			; added back at end of fdiv_x macros
	and eax, 0000003FH			; upper 26 bits could be anything
	jmp	dword ptr dispatch_table[eax*4]



label0::
	fdiv	st,st(0)		; D8 F0 	FDIV	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label1::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label2::
	fdivr	st,st(0)		; D8 F8		FDIVR	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label3::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label4::
	fdiv 	st(0),st		; DC F8/D8 F0	FDIV	ST(0),ST
	add	esp, STACK_SIZE
	ret
label5::
	fdivp 	st(0),st		; DE F8		FDIVP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label6::
	fdivr 	st(0),st		; DC F0/DE F0	FDIVR	ST(0),ST
	add	esp, STACK_SIZE
	ret
label7::
	fdivrp 	st(0),st		; DE F0		FDIVRP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label8::
	fdiv_st 1,0
	ret
label9::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label10::
	fdivr_st 1,0
	ret
label11::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label12::
	fdiv_sti 1,0
	ret
label13::
	fdivp_sti 1,0
	ret
label14::
	fdivr_sti 1,0
	ret
label15::
	fdivrp_sti 1,0
	ret
label16::
	fdiv_st 2,1
	ret
label17::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label18::
	fdivr_st 2,1
	ret
label19::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label20::
	fdiv_sti 2,1
	ret
label21::
	fdivp_sti 2,1
	ret
label22::
	fdivr_sti 2,1
	ret
label23::
	fdivrp_sti 2,1
	ret
label24::
	fdiv_st 3,2
	ret
label25::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label26::
	fdivr_st 3,2
	ret
label27::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label28::
	fdiv_sti 3,2
	ret
label29::
	fdivp_sti 3,2
	ret
label30::
	fdivr_sti 3,2
	ret
label31::
	fdivrp_sti 3,2
	ret
label32::
	fdiv_st 4,3
	ret
label33::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label34::
	fdivr_st 4,3
	ret
label35::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label36::
	fdiv_sti 4,3
	ret
label37::
	fdivp_sti 4,3
	ret
label38::
	fdivr_sti 4,3
	ret
label39::
	fdivrp_sti 4,3
	ret
label40::
	fdiv_st 5,4
	ret
label41::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label42::
	fdivr_st 5,4
	ret
label43::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label44::
	fdiv_sti 5,4
	ret
label45::
	fdivp_sti 5,4
	ret
label46::
	fdivr_sti 5,4
	ret
label47::
	fdivrp_sti 5,4
	ret
label48::
	fdiv_st 6,5
	ret
label49::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label50::
	fdivr_st 6,5
	ret
label51::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label52::
	fdiv_sti 6,5
	ret
label53::
	fdivp_sti 6,5
	ret
label54::
	fdivr_sti 6,5
	ret
label55::
	fdivrp_sti 6,5
	ret
label56::
	fdiv_st 7,6
	ret
label57::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label58::
	fdivr_st 7,6
	ret
label59::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label60::
	fdiv_sti 7,6
	ret
label61::
	fdivp_sti 7,6
	ret
label62::
	fdivr_sti 7,6
	ret
label63::
	fdivrp_sti 7,6
	ret
_adj_fdiv_r      ENDP



_fdivp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivp_sti macro
	fdivp_sti 1, 0
	ret
_fdivp_sti_st	ENDP

_fdivrp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivrp_sti macro
	fdivrp_sti 1, 0
	ret
_fdivrp_sti_st	ENDP


;;; _adj_fdiv_m32 - FDIV m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32
_adj_fdiv_m32	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack			; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32:
	fdiv	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdiv_m32	ENDP
	

;;; _adj_fdiv_m64 - FDIV m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m64
_adj_fdiv_m64	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64:
	fdiv	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdiv_m64	ENDP

;;; _adj_fdiv_m16i - FDIV m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m16i
_adj_fdiv_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16i		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m16i	ENDP

;;; _adj_fdiv_m32i - FDIV m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32i
_adj_fdiv_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32i		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m32i	ENDP



;;; _adj_fdivr_m32 - FDIVR m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32
_adj_fdivr_m32	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32r		; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32r:
	fdivr	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdivr_m32	ENDP


;;; _adj_fdivr_m64 - FDIVR m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m64
_adj_fdivr_m64	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64r		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64r:
	fdivr	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdivr_m64	ENDP


;;; _adj_fdivr_m16i - FDIVR m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m16i
_adj_fdivr_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16ir		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m16i	ENDP


;;; _adj_fdivr_m32i - FDIVR m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32i
_adj_fdivr_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32ir		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m32i	ENDP


;;; _safe_fdiv - FDIV fix
;;
;;	Pentium-safe version of FDIV, aka FDIVP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(1), Denominator in ST(0)
;;
;;	Output: Result of FDIV in ST(0)


	PUBLIC  _safe_fdiv
_safe_fdiv      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdiv	ENDP


;;; _safe_fdivr - FDIVR fix
;;
;;	Pentium-safe version of FDIVR, aka FDIVRP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(0), Denominator in ST(1)
;;
;;	Output: Result of FDIVR in ST(0)

	public  _safe_fdivr
_safe_fdivr      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+NUMER]
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdivr	ENDP



;;; _adj_fprem - FPREM FIX
;;
;;	Based on PRELIMINARY Intel code.


_fprem_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if denominator is unnormal

rem_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem_large	 	; if ex > ey + 63, case of large arguments 
rem_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h		; keep sy
	or		ecx, ebx		; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem_patch_loop 
rem_large:
	test	edx, 02h		; is denominator already saved
	jnz 	already_saved
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved:
	; Save user's precision control and institute 80.  The fp ops in
	; rem_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz 	rem_no_sub
	fsub	st, st(1)
rem_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub	ecx, 1			; decrement the loop counter
	jnz 	rem_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem_done
	fchs
	jmp  	rem_done
remainder_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem                           ; and finally do a remainder
; prem_main_routine end
rem_done:
	test	edx, 03h
	jz  	rem_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem_exit:
	pop 	ecx
	pop 	ebx
	pop 	eax
	ret
_fprem_common	ENDP




    PUBLIC  _adj_fprem
_adj_fprem	PROC	NEAR
	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	xor 	edx, edx
; prem_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      fprem_denormal
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

fprem_denormal:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]				; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             		; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]			; pc=80

	fstp	st			; Toss numerator
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder_hardware_ok_l:
    fprem              		; and finally do a remainder 

    add     esp, FPREM_STACK_SIZE
	pop 	edx
    ret

_adj_fprem	ENDP



;
; FPREM1 code begins here
;


_fprem1_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder1_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder1_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder1_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if denominator is unnormal

rem1_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem1_large	 	; if ex > ey + 63, case of large arguments 
rem1_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder1_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h				; keep sy
	or		ecx, ebx				; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem1_patch_loop 
rem1_large:
	test	ebx, 02h		; is denominator already saved
	jnz 	already_saved1
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved1:
	; Save user's precision control and institute 80.  The fp ops in
	; rem1_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem1_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz	rem1_no_sub
	fsub	st, st(1)
rem1_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub 	ecx, 1			; decrement the loop counter
	jnz 	rem1_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem1
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem1_done
	fchs
	jmp 	rem1_done
remainder1_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem1                           ; and finally do a remainder
; prem1_main_routine end
rem1_done:
	test	edx, 03h
	jz  	rem1_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale1
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale1:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem1_exit:
	pop	ecx
	pop	ebx
	pop	eax
	ret
_fprem1_common	ENDP

	PUBLIC	_adj_fprem1
_adj_fprem1	PROC	NEAR

	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	mov 	edx, 0
; prem1_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      denormal1
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

denormal1:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder1_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem1_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem1_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done1

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem1_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]			; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             	; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]		;  pc=80
	fstp	st							; Toss numerator
	fmul	qword ptr one_shl_64		; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done1:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder1_hardware_ok_l:
    fprem              		; and finally do a remainder 
    add     esp, FPREM_STACK_SIZE
	pop	edx
    ret
_adj_fprem1	ENDP

	PUBLIC	_safe_fprem
_safe_fprem	PROC	NEAR

    call _adj_fprem
    ret

_safe_fprem	ENDP

	PUBLIC	_safe_fprem1
_safe_fprem1	PROC	NEAR

    call _adj_fprem1
    ret

_safe_fprem1	ENDP



;;; _adj_fpatan - FPATAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fpatan
_adj_fpatan	PROC	NEAR

	fpatan
	ret

_adj_fpatan	ENDP


;;; _adj_fptan - FPTAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fptan
_adj_fptan	PROC	NEAR

	fptan
	ret

_adj_fptan	ENDP


	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\atan_pentium4.asm ===
;/* File: "atan_wmt.asm". */
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;//  Contents:      atan.
;//
;//  Purpose:       Libm 
;//

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST	SEGMENT PARA PUBLIC USE32 'CONST'
        ALIGN 16

EXTRN C _atan_table:QWORD

_atn TEXTEQU <_atan_table>

;/*
;//   FUNCTION:     double atan(double x)
;//
;//   DESCRIPTION:
;//
;//      1. For |x| < 2^(-27), where atan(x) ~= x, return x.
;//      2. For |x| >= 0.1633123935319536975596774e+17, where atan(x) ~= +-Pi/2, return +-Pi/2.
;//      3. In interval [0.0,0.03125] polynomial approximation of atan(x)=x-x*P(x^2).
;//      4. In interval [0.03125,0.375] polynomial approximation of atan(x)=x-x*D(x^2).
;//      5. In interval [0.375,8.0] we compute ind and eps such, that x=0.03125*ind+eps and 0.0<eps<0.03125.
;//         Let s=0.03125*ind, then atan(x)=atan(s)+atan(t), where t=((x-s)/(1+x*s)). For lo and hi part of
;//         atan(s) we have table (see file atan_table.c): atn[ind]+atn[ind+1]=atan(s).
;//         atan(t) is approximated atan(t)=t-t*P(t^2).
;//      6. In interval [8.0,0.1633123935319536975596774e+17] atan(x)=Pi/2+atan(-1/x).
;//         atan(-1/x) is approximated atan(t)=t-t*P(t^2), where t=-1/x.
;//      7. For x < 0.0 atan(x) = -atan(|x|).
;//      8. Special cases:
;//         atan(+0)   = +0;
;//         atan(-0)   = -0;
;//         atan(+INF) = +Pi/2;
;//         atan(-INF) = -Pi/2;
;//         atan(NaN)  = NaN.
;//
;//   KEYS OF COMPILER: -c -w -Zl -Di386 /QIfdiv-
;*/

_mexp   DQ  07ff0000000000000H, 07ff0000000000000H
_mabs   DQ  07fffffffffffffffH, 07fffffffffffffffH
_pi_2d  DQ  03ff921fb54442d18H, 0bff921fb54442d18H
_cntshf DQ  00000000000040201H, 00000000000040201H
_d1400  DQ  03fd5555555555552H, 00000000000000000H
_d1213  DQ  03fc249249246aa76H, 0bfc99999999992acH
_d1011  DQ  03fb745d15933de8aH, 0bfbc71c71b835923H
_d89    DQ  03fb110f5eeb76ecaH, 0bfb3b1390a3b9899H
_d67    DQ  03faae4492fe3a600H, 0bfae1c1704144b68H
_d45    DQ  03fa51fa164891abeH, 0bfa8171d55d53138H
_d23    DQ  03f974721481ca2a2H, 0bfa124ce2388f2cbH
_d01    DQ  03f66107c30e0b8a5H, 0bf866e5652b14bbdH
_p60    DQ  03fd55555555554ebH, 00000000000000000H
_p45    DQ  03fc249249014497eH, 0bfc9999999976718H
_p23    DQ  03fb7453ba342480fH, 0bfbc71c4eebfb10eH
_p01    DQ  03fae9be97b0f8d08H, 0bfb39ad683f878c6H
_zero   DQ  00000000000000000H, 00000000000000000H
_onen   DQ  0bff0000000000000H, 0bff0000000000000H
_one    DQ  03ff0000000000000H, 03ff0000000000000H
_cnst8  DQ  04020000000000000H, 04020000000000000H
_in3    DQ  04020000000000000H, 04020000000000000H
_in2    DQ  03fd8000000000000H, 03fd8000000000000H
_in1    DQ  03fa0000000000000H, 03fa0000000000000H
_in0    DQ  03e40000000000000H, 03e40000000000000H
_in     DQ  0434d02967c31cdb5H, 0434d02967c31cdb5H
_minval DQ  00010000000000000H, 00010000000000000H
libm_small  DQ  00200000000000000H 
CONST	ENDS

_x      TEXTEQU     <esp+4>
XMMWORD TEXTEQU <OWORD>

_TEXT   SEGMENT PARA PUBLIC USE32 'CODE'
        ALIGN       4

PUBLIC C _atan_pentium4, _CIatan_pentium4
_CIatan_pentium4  PROC NEAR
	push	    ebp
	mov 	    ebp, esp 
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm7, qword ptr [esp]
	call        start
	leave
	ret
_atan_pentium4   label proc
        movq        xmm7, QWORD PTR [_x]            ;  x
start:
        unpcklpd    xmm7, xmm7
        movapd      xmm2, xmm7
        andpd       xmm2, XMMWORD PTR _mabs         ; |x|
        comisd      xmm2, XMMWORD PTR _in           ; |x| < 0.1633123935319536975596774e+17 ?
        jp          x_nan
        jae         bigx
        comisd      xmm2, XMMWORD PTR _in1          ; |x| < 0.03125 ?
        jae         xge0_03125
        comisd      xmm2, XMMWORD PTR _in0          ; |x| < 2^(-27) ?
        jb          retx                            ; atan(x) ~= x

        ; 2^(-27) < |x| < 0.03125, atan(x)=x-x*P(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)
        mulsd       xmm5, xmm7                      ; x * P(x^2)
        subsd       xmm7, xmm5                      ; x - x * P(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_03125:                                         ; |x| >= 0.03125
        comisd    xmm2, XMMWORD PTR _in2            ; |x| < 0.375 ?
        jae       xge0_375

        ; 0.03125 < |x| < 0.375, atan(x)=x-x*D(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _d01          ; calculate D(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d67
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d89
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1011
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1213
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1400
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; D(x^2)
        mulsd       xmm5, xmm7                      ; x * D(x^2)
        subsd       xmm7, xmm5                      ; x - x * D(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_375:                                           ; |x| >= 0.375
        movq        xmm6, xmm7                      ; x
        xorpd       xmm6, xmm2                      ; sign x
        comisd      xmm2, XMMWORD PTR _in3          ; |x| < 8.0 ?
        jae         xge8_0

;       0.375 < |x| < 8.0:
;       atan(|x|)=atan(s)+atan(t), s=ind*0.03125, t=(|x|-s)/(1+|x|*s)

        movq        xmm0, XMMWORD PTR _cnst8
        movq        xmm5, XMMWORD PTR _cntshf
        movq        xmm3, xmm2                      ; calculate ind
        addsd       xmm3, xmm0
        psrlq       xmm3, 44
        psubd       xmm3, xmm5
        movd        eax,  xmm3                      ; ind
        lea         eax,  DWORD PTR [eax+eax*2]     ; ind*3
        movq        xmm5, QWORD PTR _atn[eax*8+16]  ; s
        movq        xmm3, xmm2                      ; |x|
        subsd       xmm2, xmm5                      ; |x|-s
        mulsd       xmm3, xmm5                      ; |x|*s
        addsd       xmm3, XMMWORD PTR _one          ; 1+|x|*s
        divsd       xmm2, xmm3                      ; (|x|-s)/(1+|x|*s)
        unpcklpd    xmm2, xmm2
        jmp         clcpol

xge8_0:                                             ; |x| > 8.0

;       8.0 < |x| < 0.1633123935319536975596774e+17:
;       atan(|x|)=Pi/2+atan(-1/|x|)

        mov         eax, 768                        ; ind*3 - entry point in table, where lo and hi part of Pi/2
        movq        xmm0, xmm2                      ; |x|
        movq        xmm2, XMMWORD PTR _onen
        divsd       xmm2, xmm0                      ;-1/|x|
        unpcklpd    xmm2, xmm2

clcpol:
        movq        xmm0, QWORD PTR _atn[0+eax*8]   ; atn[ind+0] - hi part of atan(s) or Pi/2
        movq        xmm4, QWORD PTR _atn[8+eax*8]   ; atn[ind+1] - lo part of atan(s) or Pi/2
        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)

;       atan(|x|) = atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)

        mulsd       xmm5, xmm2                      ; |x|*P(x^2)
        subsd       xmm5, xmm4                      ; |x|*P(x^2)-atn[ind+1]
        subsd       xmm5, xmm2                      ; (|x|*P(x^2)-atn[ind+1])-|x|
        subsd       xmm0, xmm5                      ; atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)
        orpd        xmm0, xmm6                      ; sign x
        movq        QWORD PTR [_x], xmm0
        fld         QWORD PTR [_x]
        ret

retx:                                               ; |x| < 2^(-27): atan(x) ~= x
        comisd      xmm2, XMMWORD PTR _zero         ; x == 0 ?
        jne         notzero
        fld         QWORD PTR [_x]                  ; x == +0.0 or -0.0
        ret

notzero:
        comisd      xmm2, XMMWORD PTR _minval       ; x < minval ?
        jae         ge_minval
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        sub         esp, 8
        fstp        QWORD PTR [esp]                 ; should be flag UNDERFLOW
        fld         QWORD PTR [esp]
        add         esp, 8
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

ge_minval:                                          ; minval < x < 2^(-27)
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

bigx:                                               ; |x| > 0.1633123935319536975596774e+17
        movq        xmm0, xmm2                      ; |x|
        movq        xmm3, QWORD PTR _mexp
        andpd       xmm0, xmm3
        ucomisd     xmm0, xmm3
        jp          x_nan

        mov         eax, DWORD PTR [_x+4]           ; x
        shr         eax, 31                         ; sign x
        fld         QWORD PTR libm_small
        fadd        QWORD PTR _pi_2d[eax*8]         ; should be inexact result
        ret                                         ; return +-Pi/2

x_nan:
        mov         edx, 1003
        ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
        sub         esp, 16
        mov         DWORD PTR [esp+12],edx
        mov         edx, esp
        add         edx, 16+4
        mov         DWORD PTR [esp+8],edx
        mov         DWORD PTR [esp+4],edx
        mov         DWORD PTR [esp],edx
        call        NEAR PTR __libm_error_support
        add         esp, 16

        fld         QWORD PTR [_x]
        ret                                         ; return same nan

        ALIGN       4

_CIatan_pentium4  ENDP

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ceil_pentium4.asm ===
; file: ceil_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double ceil (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The ceil function returns the smallest integer value not less than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  ceil(NaN) = that NaN
;  ceil(INF) = that INF
;  ceil(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<ceil>
_FUNC_DEF_ equ	<_ceil_default>
_FUNC_P4_  equ	<_ceil_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One  DQ 03ff0000000000000H,03ff0000000000000H
_Bns  DQ 00000000000000433H,00000000000000433H
_Zero DQ 00000000000000000H,00000000000000000H
_S    DQ 000000000000007ffH,00000000000000000H

;-- 8x-aligned data ---------------------------------------------------------

_NegZero DQ 08000000000000000H

      codeseg
      ALIGN 16

; double ceil (double x);

; Stack frame locations

ceil_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>

PUBLIC _ceil_pentium4
_ceil_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [ceil_x]           ;
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)
    movd      eax, xmm0                          ;
    andpd     xmm0, XMMWORD PTR _S               ;
    psubd     xmm2, xmm0                         ;
    psrlq     xmm1, xmm2                         ;

    test      eax, 0800H                         ;
    je        SHORT positive                     ;
    cmp       eax, 0bffH                         ;
    jl        SHORT ret_zero                     ;
    psllq     xmm1, xmm2                         ;
    cmp       eax, 0c32H                         ;
    jg        SHORT return_x                     ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1004
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

positive:

    movq      xmm0, QWORD PTR [ceil_x]           ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 6                      ; !<=

    cmp       eax, 03ffH                         ;
    jl        SHORT ret_one                      ;
    cmp       eax, 0432H                         ;
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ;
    addsd     xmm1, xmm0                         ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

ret_zero:

    fld       QWORD PTR _NegZero                 ;
    ret                                          ;

ret_one:

    cmppd     xmm3, XMMWORD PTR _Zero, 6         ; !<=
    andpd     xmm3, XMMWORD PTR _One             ;
    movq      QWORD PTR [ceil_x], xmm3           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

_ceil_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\atan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for atan() function
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ	<atan>
_FUNC_DEF_ equ	<_atan_default>
_FUNC_P4_  equ	<_atan_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIatan>
_FUNC_DEF_ equ	<_CIatan_default>
_FUNC_P4_  equ	<_CIatan_pentium4>
	include	disp_pentium4.inc

        .data

_NAME_ db 'atan',0,0,0,0

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte
extrn   _DEFAULT_CW_in_mem:word

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+infinity            -                 pi/2
;-infinity            -                -pi/2
;QNaN                DOMAIN_QNAN        QNaN            | ? to distinguish them???
;SNaN                DOMAIN             indefinite      | ? it costs 14 bytes per function
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public _atan_default,_CIatan_default
_CIatan_default proc
        sub     esp,DBLSIZE+4                 ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_atan_default label   proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
; fpatan is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

        fld1                                  ; load 1.0
        fpatan                                ; fpatan(x,1.0)

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        jmp     _math_exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_piby2]
        test    eax,80000000H
        jz      exit                          ; return pi/2
        fchs
        jmp     exit                          ; return  -pi/2

        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_CIatan_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\common.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list
              .const
staticQ One,                    03FF0000000000000R
globalW _DEFAULT_CW_in_mem      027fh
globalT _pi_by_2_to_61          0403ec90fdaa22168c235R        ; (2**61) * pi
staticQ DblMax,                 07fefffffffffffffR
staticQ DblMin,                 00010000000000000R
staticQ IeeeAdjO,               0c098000000000000R
staticQ IeeeAdjU,               04098000000000000R
staticQ _infinity,              07ff0000000000000R
staticQ _zero,                  00000000000000000R

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _startTwoArgErrorHandling:near

;***********************************************************
;
;                           _twoToTOS
;
;***********************************************************
; Recieves:
;        TOS is not NaN
; Retunns:
;        2^TOS
; Note:
;        uses 3 entries of FPU stack

_twoToTOS        proc
        fld     st(0)                         ; duplicate stack top
        frndint                               ; N = round(y)
        fsubr   st(1), st
        fxch
        fchs                                  ; g = y - N where abs(g) < 1
        f2xm1                                 ; 2**g - 1
        fld1
        fadd                                  ; 2**g
        fscale                                ; (2**g) * (2**N) - gives 2**y
        fstp    st(1)
        ret                                   ; pop extra stuff from fp stack
_twoToTOS        endp


;***********************************************************
;
;                           _load_CW
;
;***********************************************************
;        receives current control word on stack
;        and it's known that it differs from default
; Purpose:
;       load default CW, but take precision from current CW (bits 8 and 9)
; Note:
;       value of edx is destroyed
;
_load_CW        proc
        mov     edx,[esp+4]
        and     edx,0300H                     ; all bits except precision are zero
        or      edx,DEFAULT_CW_without_precision
        mov     [esp+6],dx                    ; use 2 free bytes in stack
        fldcw   [esp+6]
        ret
_load_CW        endp

;***********************************************************
;
;                           _convertTOStoQNaN
;
;***********************************************************
; Recieves:
;        TOS is QNaN or SNaN
;        eax is high dword of TOS
; Retunns:
;        if TOS=QNaN
;            eax=DOMAIN_QNAN
;        else (TOS=SNaN)
;            eax=DOMAIN
;        TOS=QNaN

_convertTOStoQNaN  proc
        test    eax, 00080000H                ; test weather arg is QNaN or SNaN
        jz      tosIsSNaN
        mov     eax,DOMAIN_QNAN               ; TOS is QNaN
        ret
tosIsSNaN:
        fadd    [One]                         ; convert SNaN to QNan
        mov     eax,DOMAIN                    ; TOS was SNaN
        ret                                   ; _cdecl return

_convertTOStoQNaN  endp



;***********************************************************
;
;                           _fload_withFB
;
;***********************************************************
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
; In other words, when arg is 53-bit SNaN convert it to 64-bit SNaN
;
; edx points to argument (in double precision)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_fload_withFB   proc                          ; load with feed back
        mov     eax, [edx+4]                  ; get exponent field
        and     eax, 07ff00000h
        cmp     eax, 07ff00000h               ; check for special exponent
        je      fpload_special
        fld     qword ptr[edx]                ; ZF=0
        ret                                   ; _cdecl return

; have special argument (NaN or INF)
fpload_special:                               ; convert to long double
        mov     eax,[edx+4]                   ; high dword of double
        sub     esp,LDBLSIZE
        or      eax, 7fff0000h                ; preserve sign, set max long double exp
        mov     [esp+6],eax                   ; store sign and power
        mov     eax,[edx+4]                   ; low dword of double
        mov     ecx,[edx]
        shld    eax,ecx,11
        shl     ecx,11

        mov     [esp+4],eax
        mov     [esp],ecx
        fld     tbyte ptr [esp]
        add     esp,LDBLSIZE
        test    eax,0                         ; ZF=1
        mov     eax,[edx+4]                   ; high dword of double

        ret                                   ; _cdecl return
_fload_withFB  endp

;***********************************************************
;
;                   _checkTOS_withFB
;
;***********************************************************
; Test first argument on INTEGER stack and set registers and flags exactly like _fload_withFB
;
; we have on stack : ret_value(4 bytes), arg1(8 bytes)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_checkTOS_withFB        proc
        mov     eax, [esp+8]                  ; get high dword
        and     eax,07ff00000h
        cmp     eax,07ff00000h                ; check for special exponent
                                              ; and set ZF
        je      special_exp
        ret                                   ; _cdecl return
special_exp:
        mov     eax, [esp+8]                  ; get exponent field
        ret                                   ; _cdecl return

_checkTOS_withFB  endp


;***********************************************************
;
;                        _fast_exit
;
;***********************************************************
;   called after execution of each math function (sin,cos, ....),
;         and if __fastflag!=0
;
_fast_exit      proc
        cmp     word ptr[esp],default_CW
        je      fast_exit_CW_is_restored
        fldcw   [esp]
fast_exit_CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_fast_exit      endp


;***********************************************************
;
;                        _math_exit
;
;***********************************************************
; called after execution of each math function (sin,cos, ....)
; and if __fastflag=0.
; The purpose is to check inexact exception.
; ecx        points to function name
; edx   function id (for example OP_LOG)

_math_exit      proc
        mov     ax,word ptr[esp]
        cmp     ax,default_CW
        je      CW_is_restored                ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                        ; test if inexact exception is masked
        jz      restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_math_exit      endp


;***********************************************************
;
;                        _check_overflow_exit
;
;***********************************************************
;
_check_overflow_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jmp     _check_overflow_start
_check_overflow_exit        endp


;***********************************************************
;
;                        _check_range_exit
;
;***********************************************************
; called after execution of math functions, which may generate
; overflow/underflow, and if __fastflag=0.
; used in exp() and pow() functions
; The purpose is to check inexact overflow/underflow and inexact exception
; ecx        points to function name
; edx   function id (for example OP_EXP)

_check_range_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jz      haveunderflow
_check_overflow_start        label        proc
        cmp     eax,7ff00000H
        jz      haveoverflow

; check INEXACT(precision) exception
        mov     ax,word ptr[esp]             ; saved CW
        cmp     ax,default_CW
        je      CW_is_restored               ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                       ; test if inexact exception is masked
        jnz     restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
have_error:
        cmp     edx,OP_POW
        je      have_error_in_pow
        call    _startOneArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret
have_error_in_pow:
        call    _startTwoArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret

restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return

; this code is taken from previous version, to receive
; exactly the same result as before. But we may simplify it...
haveunderflow:                                ; underflow is detected
        fld     IeeeAdjU
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMin]
        fstsw   ax
        sahf
        mov     eax,UNDERFLOW
        JSAE    have_error
        fmul    [_zero]
        jmp     short have_error

haveoverflow:                                 ; overflow is detected
        fld     IeeeAdjO
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMax]
        fstsw   ax
        sahf
        mov     eax,OVERFLOW
        JSBE    have_error
        fmul    [_infinity]
        jmp     short have_error

_check_range_exit        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\cpu_disp.c ===
/**
*** Copyright  (C) 1985-1998 Intel Corporation.
***
*** The information and source code contained herein is the exclusive property
*** of Intel Corporation and may not be disclosed, examined, or
*** reproduced in whole or in part without explicit written authorization from
*** the Company.
***
*** static char sccs_id[] = "@(#)cpu_disp.c     1.9 06/06/00 14:08:14";
***
**/

#include <sect_attribs.h>
#include <cruntime.h>
#include <internal.h>

#define CPU_HAS_SSE2(x)   (((x) & (1 << 26)) != 0)

#ifdef _MSC_VER

int __sse2_available_init(void);

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __sse2_available_init;

#pragma data_seg()

#endif /* _MSC_VER */

int __sse2_available;
int __use_sse2_mathfcns;

static int
has_osfxsr_set()
{
    int ret = 0;

    __try {
        __asm movapd xmm0, xmm1;
        ret = 1;
    }
    __except(1) {
    }

    return ret;
}

__declspec(naked) int __sse2_available_init()
{
    int cpu_feature;

    __asm
    {
        push    ebp
        mov     ebp, esp
        sub     esp, __LOCAL_SIZE
        push    ebx
        push    edi
        push    esi

        pushfd                  /* if we can't write to bit 21  */
        pop     eax             /* of the eflags, then we don't */
        mov     ecx, eax        /* have a cpuid instruction.    */
        xor     eax, 0x200000
        push    eax
        popfd
        pushfd
        pop     edx
        sub     edx, ecx
        je      DONE            /* CPUID not available */

        push    ecx             /* restore eflags */
        popfd
        mov     eax, 1
        cpuid
DONE :
        mov     cpu_feature, edx
    }

    __use_sse2_mathfcns = __sse2_available = 0;

    if (CPU_HAS_SSE2(cpu_feature)) {
        if (has_osfxsr_set()) {
            __sse2_available = 1;
#if !defined(_SYSCRT)
            /*
             * The VC++ CRT will automatically enable the SSE2 implementations
             * when possible.  The system CRT will not, so existing apps don't
             * start seeing different results on a Pentium4.
             */
            __use_sse2_mathfcns = 1;
#endif
        }
    }

    __asm
    {
        xor     eax, eax
        pop     esi
        pop     edi
        pop     ebx
        leave
        ret
    }
}

_CRTIMP int __cdecl _set_SSE2_enable(int flag)
{
    return __use_sse2_mathfcns = flag ? __sse2_available : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\debug.c ===
/*****************************************************************/
/*            Copyright (c) 1998 Intel Corporation               */        
/*                                                               */
/* All rights reserved.  No part of this program or publication  */
/* may be reproduced, transmitted, transcribed, stored in a      */
/* retrieval system, or translated into any language or computer */
/* language, in any form or by any means, electronic, mechanical */
/* magnetic, optical, chemical, manual, or otherwise, without    */
/* the prior written permission of Intel Corporation.            */
/*                                                               */
/*****************************************************************/
/*          INTEL CORPORATION PROPRIETARY INFORMATION            */
/*                                                               */
/*                                                               */
/*****************************************************************/

/*++

  Module Name:

    debug.c

Abstract:

    This module provides handy routines for debugging

Author:

Revision History:

--*/


#include <wtypes.h>
#include <stdio.h>
#include <conio.h>
#include "fpieee.h"
#include "xmmi_types.h"
#include "temp_context.h"
#include "filter.h"
#include "debug.h"


ULONG   DebugFlag = 0;
ULONG   Console = 0;
ULONG   DebugImm8 = 0;
ULONG   NotOk = 0;

#define DUMP_HEXL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %x ", i, pxmmi->u.ul[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_FS(pxmmi, num)    { \
    PRINTF(("in Fflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %f ", i, pxmmi->u.fs[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_HEXLL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %I64x ", i, pxmmi->u.ull[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_DS(pxmmi, num)    { \
    PRINTF(("in Dflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %e ", i, pxmmi->u.fd[i])); \
    } \
    PRINTF(("\n")); }


void
print_Rounding(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->RoundingMode == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Ieee->RoundingMode == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Ieee->RoundingMode == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Ieee->RoundingMode == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = UNKNOWN\n"));
              }
          }
      }
  }

}

void
print_Precision(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Ieee->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Ieee->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Ieee->Precision = INCORRECT\n"));
          }
      }
  }

}

void
print_CauseEnable(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEmv->Ieee->Cause:     P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Cause.Inexact, XmmiEnv->Ieee->Cause.Underflow,
      XmmiEnv->Ieee->Cause.Overflow, XmmiEnv->Ieee->Cause.ZeroDivide,
      XmmiEnv->Ieee->Cause.InvalidOperation));
  PRINTF(("XmmiEnv->Ieee->Enable: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Enable.Inexact, XmmiEnv->Ieee->Enable.Underflow,
      XmmiEnv->Ieee->Enable.Overflow, XmmiEnv->Ieee->Enable.ZeroDivide,
      XmmiEnv->Ieee->Enable.InvalidOperation));

}

void
print_Status(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEnv->Ieee->Status: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Status.Inexact, XmmiEnv->Ieee->Status.Underflow,
      XmmiEnv->Ieee->Status.Overflow, XmmiEnv->Ieee->Status.ZeroDivide,
      XmmiEnv->Ieee->Status.InvalidOperation));

}

void
print_Operations(PXMMI_ENV XmmiEnv) {

    switch (XmmiEnv->Ieee->Operation) {
    case OP_ADDPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPS\n"));
      break;
    case OP_ADDSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSS\n"));
      break;
    case OP_SUBPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPS\n"));
      break;
    case OP_SUBSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSS\n"));
      break;
    case OP_MULPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPS\n"));
      break;
    case OP_MULSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSS\n"));
      break;
    case OP_DIVPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPS\n"));
      break;
    case OP_DIVSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSS\n"));
      break;
    case OP_MAXPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPS\n"));
      break;
    case OP_MAXSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSS\n"));
      break;
    case OP_MINPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPS\n"));
      break;
    case OP_MINSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSS\n"));
      break;
    case OP_CVTPI2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPI2PS\n"));
      break;
    case OP_CVTSI2SS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSI2SS\n"));
      break;
    case OP_CVTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PI\n"));
      break;
    case OP_CVTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SI\n"));
      break;
    case OP_CVTTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2PI\n"));
      break;
    case OP_CVTTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSS2SI\n"));
      break;
    case OP_COMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISS\n"));
      break;
    case OP_UCOMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISS\n"));
      break;
    case OP_CMPPS:
    case OP_CMPSS: 
    case OP_CMPPD:  
    case OP_CMPSD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CMPPS/CMPSS/CMPPD/CMPSD "));

      switch (XmmiEnv->Imm8 & 0x07) {

        case IMM8_EQ:
          PRINTF(("EQ\n"));
          break;
        case IMM8_UNORD:
          PRINTF(("UNORD\n"));
          break;
        case IMM8_NEQ:
          PRINTF(("NEQ\n"));
          break;
        case IMM8_ORD:
          PRINTF(("ORD\n"));
          break;
        case IMM8_LT:
          PRINTF(("LT\n"));
          break;
        case IMM8_LE:
          PRINTF(("LE\n"));
          break;
        case IMM8_NLT:
          PRINTF(("NLT\n"));
          break;
        case IMM8_NLE:
          PRINTF(("NLE\n"));
          break;
        default:
          ; // will never occur

      }
      break;
    case OP_SQRTPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPS\n"));
      break;
    case OP_SQRTSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSS\n"));
      break;
    case OP_ADDPD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPD\n"));
      break;
    case OP_ADDSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSD\n"));
      break;        
    case OP_SUBPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPD\n"));
      break;        
    case OP_SUBSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSD\n"));
      break;        
    case OP_MULPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPD\n"));
      break;
    case OP_MULSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSD\n"));
      break;        
    case OP_DIVPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPD\n"));
      break;
    case OP_DIVSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSD\n"));
      break;        
    case OP_SQRTPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPD\n"));
      break;       
    case OP_SQRTSD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSD\n"));
      break;        
    case OP_MAXPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPD\n"));
      break;        
    case OP_MAXSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSD\n"));
      break;        
    case OP_MINPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPD\n"));
      break;        
    case OP_MINSD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSD\n"));
      break;                
    case OP_COMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISD\n"));
      break;        
    case OP_UCOMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISD\n"));
      break;
    case OP_CVTPD2PI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PI\n"));
      break;
    case OP_CVTSD2SI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SI\n"));
      break;
    case OP_CVTTPD2PI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2PI\n"));
      break;
    case OP_CVTTSD2SI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSD2SI\n"));
      break;
    case OP_CVTPS2PD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PD\n"));
      break;        
    case OP_CVTSS2SD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SD\n"));
      break;        
    case OP_CVTPD2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PS\n"));
      break;        
    case OP_CVTSD2SS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SS\n"));
      break;        
    case OP_CVTDQ2PS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTDQ2PS\n"));
      break;
    case OP_CVTTPS2DQ: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2DQ\n"));
      break;
    case OP_CVTPS2DQ:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2DQ\n"));
      break;
    case OP_CVTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2DQ\n"));
      break;        
    case OP_CVTTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2DQ\n"));
      break;
        
    default:
      PRINTF(("XmmiEnv->Ieee->Operation %d = UNKNOWN\n",
          XmmiEnv->Ieee->Operation));
    }
}

void
print_Operand1(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand1.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand1.OperandValid));

    if (!XmmiEnv->Ieee->Operand1.OperandValid) return;

    if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand1.Value.Fp32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.U32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.I32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand1.Value.Fp64Value,
            XmmiEnv->Ieee->Operand1.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = INCORRECT\n"));
    }

}

void
print_Operand2(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand2.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand2.OperandValid));

    if (!XmmiEnv->Ieee->Operand2.OperandValid) return;

    if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand2.Value.Fp32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.U32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.I32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand2.Value.Fp64Value,
            XmmiEnv->Ieee->Operand2.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = INCORRECT\n"));
    }
 
}

void
print_Result(PXMMI_ENV XmmiEnv, BOOL Exception) {

    PRINTF(("XmmiEnv->Ieee->Result.OperandValid = %x\n",
        XmmiEnv->Ieee->Result.OperandValid));

    if (XmmiEnv->Ieee->Result.OperandValid) {
        if (XmmiEnv->Ieee->Result.Format == _FpFormatFp32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp32Value = %f = %x\n",
                (float)XmmiEnv->Ieee->Result.Value.Fp32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatU32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatU32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.U32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.U32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatI32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatI32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.I32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.I32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatFp64) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp64\n"));
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp64Value = %e = %I64x\n",
                (double)XmmiEnv->Ieee->Result.Value.Fp64Value,
                XmmiEnv->Ieee->Result.Value.U64Value));
        } else {
            PRINTF(("XmmiEnv->Ieee->Result.Format = INCORRECT\n"));
        }
    }

    if (!Exception) {
        if (XmmiEnv->Ieee->Operation == _FpCodeCompare) {
            PRINTF(("XmmiEnv->EFlags = %x\n", XmmiEnv->EFlags)); 
        }
    }

}


void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}


void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv) {
    

  // print input values
  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  if (XmmiEnv->Rc == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Rc = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Rc == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Rc = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Rc == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Rc = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Rc == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Rc = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Rc = UNKNOWN\n"));
              }
          }
      }
  }

  if (XmmiEnv->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Precision = INCORRECT\n"));
          }
      }
  }

  print_Operations(XmmiEnv);
  print_Operand1(XmmiEnv);
  print_Operand2(XmmiEnv);

}


void
dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXLL(xmmi128, 2);
    DUMP_DS(xmmi128, 2);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (+0, -0)\n"));
    DUMP_HEXLL(reg0, 2);
    DUMP_DS(reg0, 2);

    PRINTF(("xmmi reg1: (+1.5*2^1022, +denormalized finite)\n"));
    DUMP_HEXLL(reg1, 2);
    DUMP_DS(reg1, 2);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite)\n"));
    DUMP_HEXLL(reg2, 2);
    DUMP_DS(reg2, 2);

    PRINTF(("xmmi reg3: (-normalized finite, +infinites)\n"));
    DUMP_HEXLL(reg3, 2);
    DUMP_DS(reg3, 2);

    PRINTF(("xmmi reg4: (-infinity, +1.1111110...011*2^-1022)\n"));
    DUMP_HEXLL(reg4, 2);
    DUMP_DS(reg4, 2);

    PRINTF(("xmmi reg5: (SNan, SNan)\n"));
    DUMP_HEXLL(reg5, 2);
    DUMP_DS(reg5, 2);

    PRINTF(("xmmi reg6: (QNan, QNan)\n"));
    DUMP_HEXLL(reg6, 2);
    DUMP_DS(reg6, 2);

    PRINTF(("xmmi reg7: (+1.375*2^1022, +1.11111110...01 * 2^-1022)\n"));
    DUMP_HEXLL(reg7, 2);
    DUMP_DS(reg7, 2);

}

void
dump_Data(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXL(xmmi128, 4);
    DUMP_FS(xmmi128, 4);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (n, n, n, n)\n"));
    DUMP_HEXL(reg0, 4);
    DUMP_FS(reg0, 4);

    PRINTF(("xmmi reg1: (+0, -0, +denormalized finite, n)\n"));
    DUMP_HEXL(reg1, 4);
    DUMP_FS(reg1, 4);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite, -normalized finite, n)\n"));
    DUMP_HEXL(reg2, 4);
    DUMP_FS(reg2, 4);

    PRINTF(("xmmi reg3: (+infinites, -infinites, n, 1000003)\n"));
    DUMP_HEXL(reg3, 4);
    DUMP_FS(reg3, 4);

    PRINTF(("xmmi reg4: (n, n, n, n)\n"));
    DUMP_HEXL(reg4, 4);
    DUMP_FS(reg4, 4);

    PRINTF(("xmmi reg5: (SNan, SNan, n, n)\n"));
    DUMP_HEXL(reg5, 4);
    DUMP_FS(reg5, 4);

    PRINTF(("xmmi reg6: (QNan, QNan, 7ec00000, n)\n"));
    DUMP_HEXL(reg6, 4);
    DUMP_FS(reg6, 4);

    PRINTF(("xmmi reg7: (n, n, 7eb00000, 100004)\n"));
    DUMP_HEXL(reg7, 4);
    DUMP_FS(reg7, 4);

}

void
dump_OpLocation(POPERAND Operand) {

    if (!Operand->Op.OperandValid) {
        PRINTF(("Operand Invalid\n")) 
        return;
    }

    switch (Operand->OpLocation) {
    case ST0:
        PRINTF(("OpLocation = ST0 "));
        break;
    case ST1:
        PRINTF(("OpLocation = ST1 "));
        break;
    case ST2:
        PRINTF(("OpLocation = ST2 "));
        break;
    case ST3:
        PRINTF(("OpLocation = ST3 "));
        break;
    case ST4:
        PRINTF(("OpLocation = ST4 "));
        break;
    case ST5:
        PRINTF(("OpLocation = ST5 "));
        break;
    case ST6:
        PRINTF(("OpLocation = ST6 "));
        break;
    case ST7:
        PRINTF(("OpLocation = ST7 "));
        break;
    case REG:
        PRINTF(("OpLocation = REG "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case RS:
        PRINTF(("OpLocation = RS "));
        break;
    case M16I:
        PRINTF(("OpLocation = M16I "));
        break;
    case M32I:
        PRINTF(("OpLocation = M32I "));
        break;
    case M64I:
        PRINTF(("OpLocation = M64I "));
        break;
    case M32R:
        PRINTF(("OpLocation = M32R "));
        break;
    case M64R:
        PRINTF(("OpLocation = M64R "));
        break;
    case M80R:
        PRINTF(("OpLocation = M80R "));
        break;
    case M80D:
        PRINTF(("OpLocation = M80D "));
        break;
    case Z80R:
        PRINTF(("OpLocation = Z80R "));
        break;
    case M128_M32R:
        PRINTF(("OpLocation = M128_M32R "));
        break;
    case M128_M64R:
        PRINTF(("OpLocation = M128_M64R "));
        break;
    case MMX:
        PRINTF(("OpLocation = MMX "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI:
        PRINTF(("OpLocation = XMMI "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI2:
        PRINTF(("OpLocation = XMMI2 "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case IMM8:
        PRINTF(("OpLocation = IMM8 "));
        break;
    case M64R_64:
        PRINTF(("OpLocation = M64R_64 "));
        break;
    case M128_M32I:
        PRINTF(("OpLocation = M128_M32I "));
        break;
    case XMMI_M32I:
        PRINTF(("OpLocation = XMMI_M32I "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case LOOKUP:
        PRINTF(("OpLocation = LOOKUP "));
        break;
    case INV:
        PRINTF(("OpLocation = INV "));
        break;
    default:
        PRINTF(("?"));
    }

    PRINTF(("\n"));

}

void
dump_XmmiFpEnv(
    PXMMI_FP_ENV XmmiFpEnv) {
    
    POPERAND Operand;
    XMMI_ENV XmmiEnv;
    _FPIEEE_RECORD ieee;

    XmmiEnv.Ieee = &ieee;
    XmmiEnv.Ieee->Operation = XmmiFpEnv->OriginalOperation;
    XmmiEnv.Imm8 = XmmiFpEnv->Imm8;
    print_Operations(&XmmiEnv);
        
    Operand = &XmmiFpEnv->Operand1;
    PRINTF(("Operand1: "));
    dump_OpLocation(Operand);

    Operand = &XmmiFpEnv->Operand2;
    PRINTF(("Operand2: "));
    dump_OpLocation(Operand);

}

void
dump_Control(PTEMP_EXCEPTION_POINTERS p) {

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PULONG istream;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    istream = (PULONG) pctxt->Eip;

    PRINTF(("EIP %x ExceptionRecord %x ContextRecord %x ExtendedArea %x\n",
             istream, exc, pctxt, pExtendedArea));
    PRINTF(("MXCsr: %x, CW: %x\n", pExtendedArea->MXCsr, pExtendedArea->ControlWord));

}

void
dump_Format(_FPIEEE_VALUE *Operand) {

    _U64 u64;
    _I64 i64;
    _FP80 fp80;
    _FP128 fp128;
    ULONG i;

    if (!Operand->OperandValid) {
        PRINTF(("Operand Invalid\n")); 
    }

    PRINTF(("Format/Value: "));
    switch (Operand->Format) {
    case _FpFormatFp32:
         PRINTF(("_FpFormatFp32 %f", Operand->Value.Fp32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatFp64:
         PRINTF(("_FpFormatFp64 %e\n", Operand->Value.Fp64Value));
         for (i=0; i < 3; i++) {
             PRINTF((" = (hex) %x\n", Operand->Value.U64Value.W[i]));
         }
         break;
    case _FpFormatFp80:
         fp80 = Operand->Value.Fp80Value;
         PRINTF(("_FpFormatFp80 (hex)"));        
         for (i=0; i < 5; i++) {
             PRINTF((" %x", fp80.W[i]));
         }
         break;
    case _FpFormatFp128:
         fp128 = Operand->Value.Fp128Value;
         PRINTF(("_FpFormatFp128 (hex)"));        
         for (i=0; i < 4; i++) {
             PRINTF((" %x", fp128.W[i]));
         }
         break;
    case _FpFormatI16:
         PRINTF(("_FpFormatI16 %d\n", Operand->Value.I16Value));
         break;
    case _FpFormatI32:
         PRINTF(("_FpFormatI32 %d", Operand->Value.I32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatI64:
         i64 = Operand->Value.I64Value;
         PRINTF(("_FpFormatI64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", i64.W[i]));
         }
         break;
    case _FpFormatU16:
         PRINTF(("_FpFormatU16 h%u\n", Operand->Value.U16Value));
         break;
    case _FpFormatU32:
         PRINTF(("_FpFormatU32 l%u\n", Operand->Value.U32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatU64:
         u64 = Operand->Value.U64Value;
         PRINTF(("_FpFormatU64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", u64.W[i]));
         }
         break;
    case _FpFormatCompare:
         PRINTF(("_FpFormatCompare %x\n", Operand->Value.CompareValue));
         break;
    case _FpFormatString:
         PRINTF(("_FpFormatString %s\n", Operand->Value.StringValue));
         break;

    default:
         PRINTF(("?"));
         break;

    }

    PRINTF(("\n"));

    return;

}

void
dump_fpieee_record(_FPIEEE_RECORD *pieee) {

    XMMI_ENV XmmiEnv;

    XmmiEnv.Ieee = pieee;
    PRINTF(("OPERATION: 0x%x\n", pieee->Operation));

    print_Rounding(&XmmiEnv);
    print_Precision(&XmmiEnv);
    print_CauseEnable(&XmmiEnv);
    print_Status(&XmmiEnv);
        
    PRINTF(("Operand 1:\n"));
    dump_Format(&pieee->Operand1);
    PRINTF(("Operand 2: \n"));
    dump_Format(&pieee->Operand2);

    PRINTF(("Result:"));
    dump_Format(&pieee->Result);

}

void 
print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);

  PRINTF(("\n"));

}

void 
print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}


void
print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags)
 {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\cos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_COS_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\atan_table.c ===
/* File: "atan_table.c". */

/*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
//
//  Contents:      Table for functhion atan (see file atan.c and atan_wmt.asm).
//
//  Purpose:       Libm.
//
//
*/

const double _atan_table[] = {
     3.12398332171142101287841796875e-02,    2.131540661249275652049909770325e-10,    3.12500e-02,
     6.24188096262514591217041015625e-02,    3.697058893522750114230051136063e-10,    6.25000e-02,
     9.34767806902527809143066406250e-02,    4.683366825902205526870604788232e-10,    9.37500e-02,
     1.24354993924498558044433593750e-01,    6.222628769869212554138710255732e-10,    1.25000e-01,
     1.54996741563081741333007812500e-01,    3.608592409707065624334921910556e-10,    1.56250e-01,
     1.85347948223352432250976562500e-01,    1.772342332635049398728544644515e-09,    1.87500e-01,
     2.15357698500156402587890625000e-01,    1.197581645436569002166489650499e-09,    2.18750e-01,
     2.44978662580251693725585937500e-01,    5.466124604464965437112758109141e-10,    2.50000e-01,
     2.74167448282241821289062500000e-01,    2.837416976310309398342175801554e-09,    2.81250e-01,
     3.02884865552186965942382812500e-01,    2.822784439618173282005558213292e-09,    3.12500e-01,
     3.31096075475215911865234375000e-01,    1.228916183079104412756944545469e-09,    3.43750e-01,
     3.58770668506622314453125000000e-01,    1.763949905942795063926460499777e-09,    3.75000e-01,
     3.85882668197154998779296875000e-01,    1.200918777118398609607231411754e-09,    4.06250e-01,
     4.12410438060760498046875000000e-01,    3.536626808852916289667126937047e-09,    4.37500e-01,
     4.38336558640003204345703125000e-01,    1.217954601099912924214771330029e-09,    4.68750e-01,
     4.63647607713937759399414062500e-01,    1.286868356814842168961214402029e-09,    5.00000e-01,
     4.88333947956562042236328125000e-01,    3.099843481630836835747064837358e-09,    5.31250e-01,
     5.12389458715915679931640625000e-01,    1.594822026734960395584259254421e-09,    5.62500e-01,
     5.35811230540275573730468750000e-01,    7.420188126538616318707691407099e-09,    5.93750e-01,
     5.58599308133125305175781250000e-01,    7.210437130795726966401661270346e-09,    6.25000e-01,
     5.80756351351737976074218750000e-01,    2.215932423129055725001500862099e-09,    6.56250e-01,
     6.02287344634532928466796875000e-01,    1.500431253215325819204232909999e-09,    6.87500e-01,
     6.23199328780174255371093750000e-01,    1.153891675621381599060374595087e-09,    7.18750e-01,
     6.43501102924346923828125000000e-01,    5.868937462974684228717322638042e-09,    7.50000e-01,
     6.63202986121177673339843750000e-01,    6.584915582023410560238275873263e-09,    7.81250e-01,
     6.82316549122333526611328125000e-01,    5.752414551645101856711152993143e-09,    8.12500e-01,
     7.00854405760765075683593750000e-01,    2.123685096774357531786751268090e-09,    8.43750e-01,
     7.18829996883869171142578125000e-01,    2.737755334274436026525904653951e-09,    8.75000e-01,
     7.36257426440715789794921875000e-01,    2.540712341947913396089146662832e-09,    9.06250e-01,
     7.53151275217533111572265625000e-01,    5.744661277952473745269028881600e-09,    9.37500e-01,
     7.69526474177837371826171875000e-01,    6.227820888580648160985654018868e-09,    9.68750e-01,
     7.85398162901401519775390625000e-01,    4.960467898402702208198757210493e-10,    1.00000e+00,
     8.00781562924385070800781250000e-01,    2.253658389748251166028452574564e-09,    1.03125e+00,
     8.15691918134689331054687500000e-01,    5.181534079966773338745645846567e-09,    1.06250e+00,
     8.30144390463829040527343750000e-01,    4.388234867630905473345013524770e-09,    1.09375e+00,
     8.44153985381126403808593750000e-01,    7.320445987092503982716475065259e-10,    1.12500e+00,
     8.57735492289066314697265625000e-01,    1.646976974689393634401636258728e-09,    1.15625e+00,
     8.70903454720973968505859375000e-01,    2.354678984634313737597814094030e-09,    1.18750e+00,
     8.83672110736370086669921875000e-01,    5.917087395273464170528949437663e-09,    1.21875e+00,
     8.96055378019809722900390625000e-01,    6.551534233274410093029937827025e-09,    1.25000e+00,
     9.08066816627979278564453125000e-01,    2.273925746984707125349512590406e-09,    1.28125e+00,
     9.19719599187374114990234375000e-01,    6.163042702238369079821089425988e-09,    1.31250e+00,
     9.31026540696620941162109375000e-01,    3.271650007157030305038895044289e-09,    1.34375e+00,
     9.42000038921833038330078125000e-01,    1.457630626407859045534593586072e-09,    1.37500e+00,
     9.52652096748352050781250000000e-01,    4.111357358345352207769909959585e-09,    1.40625e+00,
     9.62994329631328582763671875000e-01,    1.049607619051523960997099925814e-09,    1.43750e+00,
     9.73037928342819213867187500000e-01,    6.858995333578316940744079860537e-09,    1.46875e+00,
     9.82793718576431274414062500000e-01,    4.670897793571648111014666014497e-09,    1.50000e+00,
     9.92272108793258666992187500000e-01,    3.583932702000201676434503589257e-09,    1.53125e+00,
     1.00148312747478485107421875000e+00,    8.219449881844110845301437412509e-09,    1.56250e+00,
     1.01043644547462463378906250000e+00,    4.415428828550118277573210101588e-09,    1.59375e+00,
     1.01914133131504058837890625000e+00,    1.295130914625943666702306364877e-08,    1.62500e+00,
     1.02760674059391021728515625000e+00,    9.913158540718138781765724473397e-09,    1.65625e+00,
     1.03584124147891998291015625000e+00,    1.152988019367453822032544397905e-08,    1.68750e+00,
     1.04385308921337127685546875000e+00,    1.039209569213430778015756976209e-08,    1.71875e+00,
     1.05165021121501922607421875000e+00,    1.333354441385648562086299829630e-09,    1.75000e+00,
     1.05924019217491149902343750000e+00,    7.449679592682189804327891757113e-09,    1.78125e+00,
     1.06663036346435546875000000000e+00,    1.851388094329176347420279866865e-09,    1.81250e+00,
     1.07382771372795104980468750000e+00,    8.187892256056230171157143093471e-09,    1.84375e+00,
     1.08083899319171905517578125000e+00,    7.349449255711375479217199820270e-09,    1.87500e+00,
     1.08767065405845642089843750000e+00,    7.919106542905609278549419916748e-09,    1.90625e+00,
     1.09432889521121978759765625000e+00,    1.210997013229513206461023521251e-08,    1.93750e+00,
     1.10081967711448669433593750000e+00,    1.126340195293153417684743910042e-08,    1.96875e+00,
     1.10714870691299438476562500000e+00,    1.088109611825144046017853704007e-08,    2.00000e+00,
     1.11332146823406219482421875000e+00,    1.066480928312016123954471335648e-08,    2.03125e+00,
     1.11934322118759155273437500000e+00,    1.405475076614440095064569287758e-08,    2.06250e+00,
     1.12521903216838836669921875000e+00,    7.651926474267472354793458802278e-09,    2.09375e+00,
     1.13095372915267944335937500000e+00,    1.482648100311155851553632780475e-08,    2.12500e+00,
     1.13655199110507965087890625000e+00,    1.489301596741226207440196119733e-08,    2.15625e+00,
     1.14201828837394714355468750000e+00,    1.097493308804676433616846293427e-08,    2.18750e+00,
     1.14735691249370574951171875000e+00,    8.141471637937760575662511675050e-09,    2.21875e+00,
     1.15257199108600616455078125000e+00,    6.129661353489368612612751379749e-09,    2.25000e+00,
     1.15766748785972595214843750000e+00,    6.656769276927379159572038936973e-09,    2.28125e+00,
     1.16264721751213073730468750000e+00,    5.527676601269576108270774250510e-09,    2.31250e+00,
     1.16751483082771301269531250000e+00,    1.424834750241433964256123253258e-08,    2.34375e+00,
     1.17227387428283691406250000000e+00,    6.845639472538094944133704614971e-09,    2.37500e+00,
     1.17692771553993225097656250000e+00,    5.186029634961463187726083501939e-10,    2.40625e+00,
     1.18147960305213928222656250000e+00,    1.909616480075475539707852321316e-09,    2.43750e+00,
     1.18593266606330871582031250000e+00,    1.271992558884159172963360952599e-08,    2.46875e+00,
     1.19028994441032409667968750000e+00,    5.272207636248046274829318337601e-09,    2.50000e+00,
     1.19455431401729583740234375000e+00,    2.140227396707584909847208775055e-09,    2.53125e+00,
     1.19872856140136718750000000000e+00,    6.535408980289369957115321521420e-09,    2.56250e+00,
     1.20281538367271423339843750000e+00,    6.977198096471879240373377633244e-09,    2.59375e+00,
     1.20681735873222351074218750000e+00,    1.155302901965332408005655763031e-08,    2.62500e+00,
     1.21073698997497558593750000000e+00,    7.468868748272727604040307287924e-09,    2.65625e+00,
     1.21457666158676147460937500000e+00,    9.811984937110373652926690293626e-09,    2.68750e+00,
     1.21833869814872741699218750000e+00,    5.819464992428498234448426570259e-09,    2.71875e+00,
     1.22202531993389129638671875000e+00,    3.277098340655022993922570490883e-09,    2.75000e+00,
     1.22563867270946502685546875000e+00,    4.242763244518118341144662912366e-09,    2.78125e+00,
     1.22918082773685455322265625000e+00,    8.410234901274410412884989594487e-09,    2.81250e+00,
     1.23265379667282104492187500000e+00,    1.417428114670811737511913702246e-09,    2.84375e+00,
     1.23605948686599731445312500000e+00,    2.612084627456326971109078698703e-09,    2.87500e+00,
     1.23939976096153259277343750000e+00,    8.369044500402396194457257207079e-09,    2.90625e+00,
     1.24267642199993133544921875000e+00,    9.779659899699352145777694333653e-09,    2.93750e+00,
     1.24589119851589202880859375000e+00,    1.021388557297760889923466396129e-08,    2.96875e+00,
     1.24904575943946838378906250000e+00,    1.295878604204085457728109012308e-08,    3.00000e+00,
     1.25214172899723052978515625000e+00,    8.741573416471721248374162284960e-09,    3.03125e+00,
     1.25518065690994262695312500000e+00,    7.846187711282708199415876872025e-09,    3.06250e+00,
     1.25816404819488525390625000000e+00,    1.252056463778502262154196628145e-08,    3.09375e+00,
     1.26109337806701660156250000000e+00,    4.185423817751440881247335772010e-09,    3.12500e+00,
     1.26397003233432769775390625000e+00,    5.054011716071304844264195262485e-09,    3.15625e+00,
     1.26679538190364837646484375000e+00,    5.551103661141789592586819428842e-09,    3.18750e+00,
     1.26957073807716369628906250000e+00,    1.085534696510658459004780444988e-08,    3.21875e+00,
     1.27229738235473632812500000000e+00,    1.285398101317119374982248049407e-08,    3.25000e+00,
     1.27497655153274536132812500000e+00,    6.723153879304604699213464023845e-09,    3.28125e+00,
     1.27760942280292510986328125000e+00,    7.434089310438806796214328210783e-09,    3.31250e+00,
     1.28019715845584869384765625000e+00,    6.584012759248711064053626364991e-09,    3.34375e+00,
     1.28274087607860565185546875000e+00,    3.665665095507416501136495530625e-09,    3.37500e+00,
     1.28524164855480194091796875000e+00,    7.470486111767017009769765205919e-09,    3.40625e+00,
     1.28770053386688232421875000000e+00,    7.628518782370858406087463234843e-09,    3.43750e+00,
     1.29011854529380798339843750000e+00,    5.694900512274118337353804509427e-09,    3.46875e+00,
     1.29249666631221771240234375000e+00,    1.477567555500747671407081684585e-09,    3.50000e+00,
     1.29483583569526672363281250000e+00,    9.114595638024382007616089537116e-09,    3.53125e+00,
     1.29713699221611022949218750000e+00,    1.349669599669199502665650520093e-08,    3.56250e+00,
     1.29940104484558105468750000000e+00,    1.147679758986937059227915110913e-09,    3.59375e+00,
     1.30162882804870605468750000000e+00,    5.960490089117285850366685592141e-09,    3.62500e+00,
     1.30382120609283447265625000000e+00,    5.878161128489539301878008334584e-09,    3.65625e+00,
     1.30597898364067077636718750000e+00,    1.324843697720655978211778739786e-08,    3.68750e+00,
     1.30810298025608062744140625000e+00,    1.226106884751302716449107062469e-09,    3.71875e+00,
     1.31019392609596252441406250000e+00,    8.951593109842375189171905312273e-09,    3.75000e+00,
     1.31225259602069854736328125000e+00,    8.275016105071470064554145959456e-09,    3.78125e+00,
     1.31427970528602600097656250000e+00,    8.864547056389410047056937889374e-09,    3.81250e+00,
     1.31627595424652099609375000000e+00,    1.427042673943814755137727468444e-08,    3.84375e+00,
     1.31824204325675964355468750000e+00,    7.760077406304642702327136253116e-09,    3.87500e+00,
     1.32017861306667327880859375000e+00,    1.262921005512445307883014395673e-08,    3.90625e+00,
     1.32208633422851562500000000000e+00,    3.472858124168611993312009390952e-09,    3.93750e+00,
     1.32396580278873443603515625000e+00,    1.114432779750422544163364758367e-08,    3.96875e+00,
     1.32581765949726104736328125000e+00,    4.170771417695957960428475631184e-09,    4.00000e+00,
     1.32764247059822082519531250000e+00,    8.562541371162473394290094300359e-09,    4.03125e+00,
     1.32944083213806152343750000000e+00,    4.081431296441402128141829549292e-09,    4.06250e+00,
     1.33121328055858612060546875000e+00,    1.420136831552919347675057084008e-08,    4.09375e+00,
     1.33296039700508117675781250000e+00,    2.332364690796037369733155809370e-09,    4.12500e+00,
     1.33468267321586608886718750000e+00,    6.442354753983593217476570076898e-09,    4.15625e+00,
     1.33638064563274383544921875000e+00,    5.438341998417537726877161967895e-09,    4.18750e+00,
     1.33805480599403381347656250000e+00,    9.046037814385648659622761501864e-09,    4.21875e+00,
     1.33970564603805541992187500000e+00,    1.356094411940642875258955574110e-08,    4.25000e+00,
     1.34133365750312805175781250000e+00,    2.285596037267486062179053583112e-09,    4.28125e+00,
     1.34293927252292633056640625000e+00,    5.554870562188788912498970827328e-09,    4.31250e+00,
     1.34452295303344726562500000000e+00,    1.173381403717569307500270273711e-08,    4.34375e+00,
     1.34608514606952667236328125000e+00,    1.231072725868565967825177962565e-08,    4.37500e+00,
     1.34762628376483917236328125000e+00,    2.272218287547117422631062509978e-09,    4.40625e+00,
     1.34914675354957580566406250000e+00,    1.026664321996712870251856126637e-08,    4.43750e+00,
     1.35064698755741119384765625000e+00,    9.544908659820431810059953309619e-09,    4.46875e+00,
     1.35212737321853637695312500000e+00,    7.702418280236022941389812850984e-09,    4.50000e+00,
     1.35358829796314239501953125000e+00,    2.298311106522236589881694951011e-09,    4.53125e+00,
     1.35503011941909790039062500000e+00,    1.096875641746231101174713542048e-08,    4.56250e+00,
     1.35645322501659393310546875000e+00,    1.212201701673204195192859245690e-08,    4.59375e+00,
     1.35785797238349914550781250000e+00,    4.832000329604677385964058528746e-09,    4.62500e+00,
     1.35924468934535980224609375000e+00,    9.116804692809882842286486387302e-09,    4.65625e+00,
     1.36061373353004455566406250000e+00,    6.602682522350465783445563760715e-09,    4.68750e+00,
     1.36196543276309967041015625000e+00,    3.877573446682057410929518329238e-10,    4.71875e+00,
     1.36330009996891021728515625000e+00,    3.907837370041422778250991189943e-10,    4.75000e+00,
     1.36461804807186126708984375000e+00,    8.691123502302366102158347386489e-09,    4.78125e+00,
     1.36591960489749908447265625000e+00,    4.860289062625101607000745385741e-09,    4.81250e+00,
     1.36720505356788635253906250000e+00,    5.791195446259436674713169620190e-09,    4.84375e+00,
     1.36847469210624694824218750000e+00,    6.310345929394450693694852955619e-09,    4.87500e+00,
     1.36972880363464355468750000000e+00,    9.189514516165813329271081407916e-09,    4.90625e+00,
     1.37096767127513885498046875000e+00,    1.044676754867526478916455067153e-08,    4.93750e+00,
     1.37219156324863433837890625000e+00,    1.444291066122994092077186874377e-08,    4.96875e+00,
     1.37340076267719268798828125000e+00,    4.267823172872990676444961148651e-09,    5.00000e+00,
     1.37459550797939300537109375000e+00,    1.527387122824184692078603101451e-09,    5.03125e+00,
     1.37577605247497558593750000000e+00,    6.914999640531745497463320512676e-09,    5.06250e+00,
     1.37694266438484191894531250000e+00,    3.818378486586558829857026629662e-10,    5.09375e+00,
     1.37809556722640991210937500000e+00,    9.061011323442859641291551522494e-10,    5.12500e+00,
     1.37923499941825866699218750000e+00,    7.047511712721813814391809872058e-09,    5.15625e+00,
     1.38036119937896728515625000000e+00,    1.200237518564746200539758407614e-08,    5.18750e+00,
     1.38147440552711486816406250000e+00,    3.752431303860485847154508830984e-09,    5.21875e+00,
     1.38257481157779693603515625000e+00,    9.912328922024811167768568512557e-09,    5.25000e+00,
     1.38366265594959259033203125000e+00,    8.461972007611136551662947080744e-09,    5.28125e+00,
     1.38473814725875854492187500000e+00,    2.387134272079734864149462150428e-09,    5.31250e+00,
     1.38580147922039031982421875000e+00,    4.908768598138564463776776339150e-09,    5.34375e+00,
     1.38685286045074462890625000000e+00,    9.806976825422688109704248603488e-09,    5.37500e+00,
     1.38789249956607818603515625000e+00,    6.444437697102163472927543094628e-09,    5.40625e+00,
     1.38892057538032531738281250000e+00,    9.687117337622079724907822955494e-09,    5.43750e+00,
     1.38993729650974273681640625000e+00,    4.142746755845765070359169866481e-10,    5.46875e+00,
     1.39094282686710357666015625000e+00,    1.353147719826124443836432060856e-10,    5.50000e+00,
     1.39193734526634216308593750000e+00,    1.149271815404143250733190405928e-08,    5.53125e+00,
     1.39292106032371520996093750000e+00,    3.465104850475983881869885279409e-09,    5.56250e+00,
     1.39389412105083465576171875000e+00,    8.751972846933355826997338259422e-10,    5.59375e+00,
     1.39485669136047363281250000000e+00,    9.981895149582312209204422264489e-09,    5.62500e+00,
     1.39580896496772766113281250000e+00,    3.673990225978010422888335299850e-09,    5.65625e+00,
     1.39675107598304748535156250000e+00,    1.096911042189325662689037157861e-08,    5.68750e+00,
     1.39768320322036743164062500000e+00,    1.279477068249628351462798799313e-08,    5.71875e+00,
     1.39860551059246063232421875000e+00,    1.679496962688451331611428233573e-09,    5.75000e+00,
     1.39951811730861663818359375000e+00,    1.163902146698957855756715392016e-08,    5.78125e+00,
     1.40042120218276977539062500000e+00,    1.394951087425882225980348078085e-08,    5.81250e+00,
     1.40131491422653198242187500000e+00,    6.633460392900879147180110239037e-09,    5.84375e+00,
     1.40219937264919281005859375000e+00,    1.453627420047443672943364926769e-08,    5.87500e+00,
     1.40307474136352539062500000000e+00,    1.489477349711843444848571805625e-08,    5.90625e+00,
     1.40394115447998046875000000000e+00,    1.191512705053974257955257371087e-08,    5.93750e+00,
     1.40479874610900878906250000000e+00,    7.040537971277288777775128203578e-09,    5.96875e+00,
     1.40564763545989990234375000000e+00,    1.392036987860844340199580798810e-08,    6.00000e+00,
     1.40648797154426574707031250000e+00,    1.377265262781251842762842030113e-08,    6.03125e+00,
     1.40731988847255706787109375000e+00,    1.516454832781008004109129588904e-10,    6.06250e+00,
     1.40814347565174102783203125000e+00,    8.812392852367568475736726912337e-09,    6.09375e+00,
     1.40895888209342956542968750000e+00,    1.346304412954022002507925692872e-08,    6.12500e+00,
     1.40976624190807342529296875000e+00,    3.293815482142621061407439716301e-10,    6.15625e+00,
     1.41056562960147857666015625000e+00,    1.291535597312565950651550805849e-08,    6.18750e+00,
     1.41135720908641815185546875000e+00,    3.046912056781504556598516301656e-09,    6.21875e+00,
     1.41214105486869812011718750000e+00,    9.739797095250426171858489159963e-09,    6.25000e+00,
     1.41291730105876922607421875000e+00,    1.024031168077398483141533761956e-08,    6.28125e+00,
     1.41368605196475982666015625000e+00,    9.483176298330940700362142113524e-09,    6.31250e+00,
     1.41444741189479827880859375000e+00,    1.033869222335914782699115849033e-08,    6.34375e+00,
     1.41520148515701293945312500000e+00,    1.366085396849313009758338943949e-08,    6.37500e+00,
     1.41594839096069335937500000000e+00,    3.432973375068371408689440807613e-09,    6.40625e+00,
     1.41668820381164550781250000000e+00,    6.417824622786507475303697774616e-09,    6.43750e+00,
     1.41742104291915893554687500000e+00,    2.794932855413679169126588151130e-09,    6.46875e+00,
     1.41814699769020080566406250000e+00,    7.094306537397978039700989523716e-10,    6.50000e+00,
     1.41886615753173828125000000000e+00,    6.511618638791985801618497405100e-09,    6.53125e+00,
     1.41957862675189971923828125000e+00,    9.896556194686557004717711949810e-09,    6.56250e+00,
     1.42028449475765228271484375000e+00,    1.374603985595606071085278554348e-08,    6.59375e+00,
     1.42098386585712432861328125000e+00,    4.364874928050023392461446666118e-09,    6.62500e+00,
     1.42167679965496063232421875000e+00,    1.112308502143230238342818370506e-08,    6.65625e+00,
     1.42236341536045074462890625000e+00,    2.184350807916878859325266118764e-09,    6.68750e+00,
     1.42304377257823944091796875000e+00,    3.750899549292036644030269089181e-09,    6.71875e+00,
     1.42371796071529388427734375000e+00,    1.069120023462447529661072975031e-08,    6.75000e+00,
     1.42438608407974243164062500000e+00,    1.474877843219146090565202646625e-09,    6.78125e+00,
     1.42504818737506866455078125000e+00,    1.271139062462222761511135154115e-08,    6.81250e+00,
     1.42570438981056213378906250000e+00,    5.071595443040728669327516512176e-09,    6.84375e+00,
     1.42635473608970642089843750000e+00,    1.233054621889336855972812656957e-08,    6.87500e+00,
     1.42699933052062988281250000000e+00,    7.287424870077642925112396819355e-09,    6.90625e+00,
     1.42763823270797729492187500000e+00,    6.103270472013076602528007488299e-09,    6.93750e+00,
     1.42827151715755462646484375000e+00,    8.725177533766308578803575218566e-09,    6.96875e+00,
     1.42889925837516784667968750000e+00,    1.381556484973878257453719835909e-08,    7.00000e+00,
     1.42952154576778411865234375000e+00,    3.878408183331421157737222813987e-09,    7.03125e+00,
     1.43013842403888702392578125000e+00,    4.890586035833613242167706359834e-09,    7.06250e+00,
     1.43074996769428253173828125000e+00,    1.182210199236867169011076347577e-08,    7.09375e+00,
     1.43135626614093780517578125000e+00,    3.562621093048238216840177931212e-09,    7.12500e+00,
     1.43195736408233642578125000000e+00,    2.550855547300852132957145207900e-09,    7.15625e+00,
     1.43255333602428436279296875000e+00,    2.928837471379335503148003066060e-10,    7.18750e+00,
     1.43314424157142639160156250000e+00,    2.089160561552372671877910995624e-09,    7.21875e+00,
     1.43373014032840728759765625000e+00,    1.215630169904281565966988736486e-08,    7.25000e+00,
     1.43431112170219421386718750000e+00,    3.847142280027166839044400023082e-09,    7.28125e+00,
     1.43488721549510955810546875000e+00,    9.079536390908432116337422093224e-09,    7.31250e+00,
     1.43545849621295928955078125000e+00,    1.404952806211560556946013416408e-08,    7.34375e+00,
     1.43602503836154937744140625000e+00,    3.955616146055021283715500878067e-09,    7.37500e+00,
     1.43658687174320220947265625000e+00,    7.722515695860274460544521388517e-09,    7.40625e+00,
     1.43714407086372375488281250000e+00,    8.613979178524680791921236062657e-09,    7.43750e+00,
     1.43769669532775878906250000000e+00,    3.856753838848147089954125263076e-09,    7.46875e+00,
     1.43824478983879089355468750000e+00,    4.659431704406716747935481585539e-09,    7.50000e+00,
     1.43878841400146484375000000000e+00,    6.428527409096803478729704302162e-09,    7.53125e+00,
     1.43932762742042541503906250000e+00,    3.687602194584522205654788432971e-09,    7.56250e+00,
     1.43986247479915618896484375000e+00,    4.995962512345000737858412162894e-09,    7.59375e+00,
     1.44039301574230194091796875000e+00,    3.163461276481761353139212686569e-09,    7.62500e+00,
     1.44091929495334625244140625000e+00,    5.069541396358720258230994326320e-09,    7.65625e+00,
     1.44144137203693389892578125000e+00,    1.877242963101349535406770464928e-09,    7.68750e+00,
     1.44195927679538726806640625000e+00,    1.375263542407784571763662797591e-08,    7.71875e+00,
     1.44247309863567352294921875000e+00,    4.734282970760733099377292525125e-10,    7.75000e+00,
     1.44298283755779266357421875000e+00,    1.045580022307847213187143258234e-08,    7.78125e+00,
     1.44348858296871185302734375000e+00,    1.955330641876895861323269134488e-09,    7.81250e+00,
     1.44399034976959228515625000000e+00,    6.994297172085502553694421170635e-09,    7.84375e+00,
     1.44448819756507873535156250000e+00,    1.216657763016328285985080370259e-08,    7.87500e+00,
     1.44498218595981597900390625000e+00,    3.355001307363149651861224256277e-09,    7.90625e+00,
     1.44547232985496520996093750000e+00,    1.044838491216955419489400858952e-08,    7.93750e+00,
     1.44595870375633239746093750000e+00,    3.046649524822425965668741214886e-09,    7.96875e+00,
     1.44644132256507873535156250000e+00,    9.683056448848404342475880416525e-09,    8.00000e+00,
     1.5707963267948965579989817342720925807952880859375,       /* hi part of Pi/2 */
     0.6123233995736765886130329661375005291048747229615e-16,   /* lo part of Pi/2 */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\debug.h ===
/***
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
* Module Name:
*
*    debug.h
*
* Abstract:
*
*    This module contains XMMI debugging definitions.
*   
* Author:
*
*    Ping L. Sager
*
* Revision History:
*
--*/

#include <stdio.h>
#include <conio.h>

extern
ULONG DebugImm8;
extern 
ULONG DebugFlag;
extern 
ULONG Console;
extern
ULONG NotOk;

//Debugging
#define XMMI_INFO        0x00000001
#define XMMI_ERROR       0x00000002
#define XMMI_WARNING     0x00000004


void print_Rounding(PXMMI_ENV XmmiEnv);

void print_Precision(PXMMI_ENV XmmiEnv);

void print_CauseEnable(PXMMI_ENV XmmiEnv);

void print_Status(PXMMI_ENV XmmiEnv);

void print_Operations(PXMMI_ENV XmmiEnv);

void print_Operand1(PXMMI_ENV XmmiEnv);

void print_Operand2(PXMMI_ENV XmmiEnv);

void print_Result(PXMMI_ENV XmmiEnv, BOOL Exception);

void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
    
void dump_Data(PTEMP_EXCEPTION_POINTERS p);

void dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p);

void dump_Control(PTEMP_EXCEPTION_POINTERS p);

void dump_XmmiFpEnv(PXMMI_FP_ENV XmmiFpEnv);

void dump_fpieee_record(_FPIEEE_RECORD *pieee);

void dump_OpLocation(POPERAND Operand);

void dump_Format(_FPIEEE_VALUE *Operand);

void print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);

void print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\exp_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  exp_wmt.asm
;
;  double exp(double);
;
;  Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a new version using just one table. Reduction by log2/64    ;;
;; A non-standard table is used. Normally, we store T,t where          ;;
;; T+t  =  exp(jlog2/64) to high precision. This implementation        ;;
;; stores  T,d where d = t/T. This shortens the latency by 1 FP op     ;;
;; This version uses two tricks from Andrey. First, we merge two       ;;
;; integer-based tests for exception filtering into 1. Second, instead ;;
;; of using sign(X)2^52 as a shifter, we use S = 2^52 * 1.10000..000   ;;
;; as the shifter. This will give bit pattern of the 2's complement of ;;
;; N in trailing bits of S + W, W = X * 64/log2.                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

smask   DQ 8000000000000000H, 8000000000000000H ; mask to get sign bit
emask   DQ 0FFF0000000000000H, 0FFF0000000000000H
mmask   DQ 00000000FFFFFFC0H, 00000000FFFFFFC0H ; mask off bottom 6 bits
bias    DQ 000000000000FFC0H, 000000000000FFC0H	; 1023 shifter left 6 bits
Shifter DQ 4338000000000000H, 4338000000000000H	; 2^52+2^51|2^52+2^51
twom60  DQ 3C30000000000000H, 3C30000000000000H ; 2^(-60)


cv      DQ 40571547652b82feH, 40571547652b82feH		; invL|invL
        DQ 3F862E42FEFA0000H, 3F862E42FEFA0000H         ; log2_hi|log2_hi
        DQ 3D1CF79ABC9E3B3AH, 3D1CF79ABC9E3B3AH         ; log2_lo|log2_lo

	DQ 3F811074B1D108E5H, 3FC555555566A45AH		; p2|p4
	DQ 3FA5555726ECED80H, 3FDFFFFFFFFFE17BH		; p1|p3

;-------Table d, T  so that movapd gives [ T | d ]
;-------Note that the exponent field of T is set to 000
Tbl_addr  DQ 0000000000000000H, 0000000000000000H
          DQ 3CAD7BBF0E03754DH, 00002C9A3E778060H
          DQ 3C8CD2523567F613H, 000059B0D3158574H
          DQ 3C60F74E61E6C861H, 0000874518759BC8H
          DQ 3C979AA65D837B6CH, 0000B5586CF9890FH
          DQ 3C3EBE3D702F9CD1H, 0000E3EC32D3D1A2H
          DQ 3CA3516E1E63BCD8H, 00011301D0125B50H
          DQ 3CA4C55426F0387BH, 0001429AAEA92DDFH
          DQ 3CA9515362523FB6H, 000172B83C7D517AH
          DQ 3C8B898C3F1353BFH, 0001A35BEB6FCB75H
          DQ 3C9AECF73E3A2F5FH, 0001D4873168B9AAH
          DQ 3C8A6F4144A6C38DH, 0002063B88628CD6H
          DQ 3C968EFDE3A8A894H, 0002387A6E756238H
          DQ 3C80472B981FE7F2H, 00026B4565E27CDDH
          DQ 3C82F7E16D09AB31H, 00029E9DF51FDEE1H
          DQ 3C8B3782720C0AB3H, 0002D285A6E4030BH
          DQ 3C834D754DB0ABB6H, 000306FE0A31B715H
          DQ 3C8FDD395DD3F84AH, 00033C08B26416FFH
          DQ 3CA12F8CCC187D29H, 000371A7373AA9CAH
          DQ 3CA7D229738B5E8BH, 0003A7DB34E59FF6H
          DQ 3C859F48A72A4C6DH, 0003DEA64C123422H
          DQ 3CA8B846259D9205H, 0004160A21F72E29H
          DQ 3C4363ED60C2AC12H, 00044E086061892DH
          DQ 3C6ECCE1DAA10379H, 000486A2B5C13CD0H
          DQ 3C7690CEBB7AAFB0H, 0004BFDAD5362A27H
          DQ 3CA083CC9B282A09H, 0004F9B2769D2CA6H
          DQ 3CA509B0C1AAE707H, 0005342B569D4F81H
          DQ 3C93350518FDD78EH, 00056F4736B527DAH
          DQ 3C9063E1E21C5409H, 0005AB07DD485429H
          DQ 3C9432E62B64C035H, 0005E76F15AD2148H
          DQ 3CA0128499F08C0AH, 0006247EB03A5584H
          DQ 3C99F0870073DC06H, 0006623882552224H
          DQ 3C998D4D0DA05571H, 0006A09E667F3BCCH
          DQ 3CA52BB986CE4786H, 0006DFB23C651A2EH
          DQ 3CA32092206F0DABH, 00071F75E8EC5F73H
          DQ 3CA061228E17A7A6H, 00075FEB564267C8H
          DQ 3CA244AC461E9F86H, 0007A11473EB0186H
          DQ 3C65EBE1ABD66C55H, 0007E2F336CF4E62H
          DQ 3C96FE9FBBFF67D0H, 00082589994CCE12H
          DQ 3C951F1414C801DFH, 000868D99B4492ECH
          DQ 3C8DB72FC1F0EAB4H, 0008ACE5422AA0DBH
          DQ 3C7BF68359F35F44H, 0008F1AE99157736H
          DQ 3CA360BA9C06283CH, 00093737B0CDC5E4H
          DQ 3C95E8D120F962AAH, 00097D829FDE4E4FH
          DQ 3C71AFFC2B91CE27H, 0009C49182A3F090H
          DQ 3C9B6D34589A2EBDH, 000A0C667B5DE564H
          DQ 3C95277C9AB89880H, 000A5503B23E255CH
          DQ 3C8469846E735AB3H, 000A9E6B5579FDBFH
          DQ 3C8C1A7792CB3387H, 000AE89F995AD3ADH
          DQ 3CA22466DC2D1D96H, 000B33A2B84F15FAH
          DQ 3CA1112EB19505AEH, 000B7F76F2FB5E46H
          DQ 3C74FFD70A5FDDCDH, 000BCC1E904BC1D2H
          DQ 3C736EAE30AF0CB3H, 000C199BDD85529CH
          DQ 3C84E08FD10959ACH, 000C67F12E57D14BH
          DQ 3C676B2C6C921968H, 000CB720DCEF9069H
          DQ 3C93700936DF99B3H, 000D072D4A07897BH
          DQ 3C74A385A63D07A7H, 000D5818DCFBA487H
          DQ 3C8E5A50D5C192ACH, 000DA9E603DB3285H
          DQ 3C98BB731C4A9792H, 000DFC97337B9B5EH
          DQ 3C74B604603A88D3H, 000E502EE78B3FF6H
          DQ 3C916F2792094926H, 000EA4AFA2A490D9H
          DQ 3C8EC3BC41AA2008H, 000EFA1BEE615A27H
          DQ 3C8A64A931D185EEH, 000F50765B6E4540H
          DQ 3C77893B4D91CD9DH, 000FA7C1819E90D8H


ONE_val  DQ 3ff0000000000000H ; 1.0

EMIN     DQ 0010000000000000H

MAX_ARG  DQ 40862e42fefa39efH

MIN_ARG  DQ 0c086232bdd70000H

INF      DQ 7ff0000000000000H

ZERO     DQ 0

XMAX	 DQ 7fefffffffffffffH

XMIN	 DQ 0010000000000000H

Sm_Thres    DQ 3C3000003C300000H  ; DP 2^(-60)
Del_Thres   DQ 045764CA045764CAH  ; DP 1080*log(2) - 2^(-60), hi part

ALIGN 16
CONST ENDS

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _exp_pentium4, _CIexp_pentium4 
_CIexp_pentium4 PROC NEAR
	push	    ebp
	mov         ebp, esp
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm0, qword ptr [esp]
	call        start
	leave
	ret
_exp_pentium4 label proc
	; load *|x in XMM0
    	movlpd xmm0, 4[esp]  
start:
	unpcklpd xmm0,xmm0

        ; load Inv_L pair
        movapd xmm1, QWORD PTR [cv]
        ; load Shifter
        movapd xmm6, QWORD PTR [Shifter]
        ; load L_hi pair
        movapd xmm2, QWORD PTR [cv+16]
        ; load L_lo pair
        movapd xmm3, QWORD PTR [cv+32]

	pextrw eax, xmm0,3
        and eax,7FFFH 
	; x>=2^{10} ? (i.e. 2^{10}-eps-x<0)
	mov edx, 408fH
	sub edx, eax
	; avoid underflow on intermediate calculations (|x|<2^{-54} ?)
	sub eax, 3c90H
	or edx, eax
	cmp edx, 80000000H
	; small input or UF/OF
	jae RETURN_ONE

	; xmm1=Inv_L*x|Inv_L*x
	mulpd  xmm1,xmm0
	; xmm1=Inv_L*x+Shifter| Inv_L*x+Shifter
	addpd  xmm1,xmm6
        ; xmm7 contains bit pattern of N
        movapd xmm7,xmm1
	; xmm1=N
	subpd xmm1,xmm6

	; xmm2=L_hi*round_to_int(Inv_L*x)|L_hi*round_to_int(Inv_L*x) ; N_L_hi
	mulpd xmm2,xmm1

        ; [p2|p4]
        MOVAPD xmm4,[cv+48]

	; xmm3=L_lo*round_to_int(Inv_L*x)|L_lo*round_to_int(Inv_L*x) ; N_L_lo
	mulpd xmm3,xmm1

        ; [p1|p3]
        MOVAPD xmm5,[cv+64]

	; xmm0=x-xmm2	   ; R := X |-| N_L_hi
	subpd xmm0,xmm2

        ; set eax <-- n, ecx <--j
        movd   eax,xmm7
        mov    ecx,eax
        and    ecx,0000003FH
      
        ; get offset for [T,d]
        shl ecx,4
        ; eax,edx <-- m
        sar eax,6
        mov edx,eax

	; xmm0-=xmm3       ; R := R |-| N_L_lo
	subpd xmm0,xmm3
        
        ; xmm2 <- [T,d]
        movapd xmm2,[ecx+Tbl_addr]
        
	; xmm4=p2*R|p4*R
	mulpd xmm4,xmm0

        MOVAPD xmm1,xmm0
        MULPD  xmm0,xmm0

	; xmm5=p1+p2*R|p3+p4*R
	addpd xmm5,xmm4
        MULSD xmm0,xmm0       
        
        ; get xmm1 <-- [R|R+d]
        addsd    xmm1,xmm2

        ; xmm2 <-- [T|T]
        unpckhpd xmm2,xmm2
        ; xmm7 <-- exponent of 2^m
        movdqa   xmm6,[mmask]
        pand     xmm7,xmm6
        movdqa   xmm6,[bias]
        paddq    xmm7,xmm6
        psllq    xmm7,46

	; xmm5=[P_hi | P_lo]
	mulpd xmm0,xmm5
        ; xmm1 <- [R |d+R+P_lo]
	addsd xmm1,xmm0
       
        ; xmm2 is 2^m T
        ORPD     xmm2,xmm7

        ; xmm5 <- [P_hi | P_hi]
        unpckhpd xmm0,xmm0

        ; xmm5 <-- [P_hi | d+R+P ]
        addsd    xmm0,xmm1

        ; make sure -894 <= m <= 1022 
        ; before we use the exponent in xmm7
        ; test by unsigned comp of  m+894 with 1022+894
        add edx,894
        cmp edx,1916

        ja  ADJUST

        mulsd    xmm0,xmm2
        sub esp, 16
        addsd    xmm0,xmm2

        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret

ADJUST:
;---xmm5 contains [*| d+R+P]
;---xmm2 contains [*| T ] where is exponent field is not correct
;---eax still contain the correct m
;---so we split m into m1 and m2, m1+m2 = m. Make T with exponent 2^m1 by
;---integer manipulation, and multiply final result by 2^m2

	; overflow or underflow
	sub esp,18

	fstcw WORD PTR [esp+16]
	mov dx,WORD PTR [esp+16]
	; set pc=64 bits
	or dx,300H 
	mov WORD PTR [esp],dx
	fldcw WORD PTR [esp]

        ; eax <-- m1 = m/2, edx <-- m2 = m - m1
        mov edx,eax
        sar eax,1
        sub edx,eax

        ; T with exponent field zerorized
        movdqa xmm6,[emask]
        pandn  xmm6,xmm2
        add    eax,1023
        movd   xmm3,eax
        psllq  xmm3,52
	; xmm6=T*2^m1
        ORPD   xmm6,xmm3

        add    edx,1023
        movd   xmm4,edx
        psllq  xmm4,52

	; load P on FP stack
	movlpd QWORD PTR [esp], xmm0
	fld QWORD PTR [esp]

	; load T'=T*2^m1 on FP stack
	movlpd QWORD PTR [esp+8], xmm6
	fld QWORD PTR [esp+8]

	; T'*P
	fmul st(1), st(0)
	; T'+T'*P
	faddp st(1), st(0)

	; load 2^m2 on FP stack
	movlpd QWORD PTR [esp], xmm4
	fld QWORD PTR [esp]

        ; final calculation: 2^m2*(T'+T'*P)
	fmulp st(1), st(0)

	; store result in memory, then xmm0
	fstp QWORD PTR [esp]
	movlpd xmm0, QWORD PTR [esp] 

	; restore FPCW
	fldcw WORD PTR [esp+16]
	add esp,18

;	mov ecx, DWORD PTR [esp+8]
;	; if 0<x<2^{10}*ln2, return
;	cmp ecx, 40862e42H
;	jb RETURN
;	ja CONT0
	pextrw ecx, xmm0, 3
	and ecx, 7ff0H
	cmp ecx, 7ff0H
	jae OVERFLOW
	cmp ecx, 0
	jz UNDERFLOW
	jmp RETURN

	; load lower 32 bits of x
;	mov edx, DWORD PTR [esp+4]
;	cmp edx, 0fefa39efH
;	jb RETURN
;	jmp OVERFLOW

CONT0:
	; OF/UF
	; OF ?
	cmp ecx,80000000H
	jb OVERFLOW

	; x<(2-2^{10})*ln2 ?
	cmp ecx, 0c086232bH
	jb RETURN
	ja UNDERFLOW
	mov edx, DWORD PTR [esp+4]
	cmp edx, 0fefa39efH
	jb RETURN
	jmp UNDERFLOW		

OVERFLOW:
	;OF
	mov edx,14
	jmp CALL_LIBM_ERROR

UNDERFLOW:
	mov edx, 15

CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16
	mov DWORD PTR [esp+4],edx
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
	movlpd xmm0, QWORD PTR [esp+16]
    	add esp, 28

RETURN:
        sub esp, 16
        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret


SPECIAL_CASES: 
;  code to be added, but OK for now
;  Need to resolve several cases
;
;  Case 1: Argument is close to zero ( |X| < 2^(-60) )
;  Compute 1 + X and return the result
;  This will allow the appropriate action to take place.
;  For example, in directed rounding, the correct number below/above 1 is returned.
;  If X is denormalized, and that DAE is set, then we will be consistant with DAE,
;  that is X is treated as zero and directed rounding will not affect the result.
;  This action also takes care of the case X = 0.
;
;  Case 2: |X| is large but finite
;  Generate overflow/underflow by a simple arithmetic operation. This is also a place
;  holder for various exception handling protocol.
;
;  Case 3: X is +-inf. Return +inf or +0 exactly without exception
;
;  Case 4: X is s/q NaN
;


OF_UF:
	; x=infinity/NaN ?
	cmp eax, 7ff00000H
	jae INF_NAN

        mov eax,[esp+8]
	cmp eax,80000000H
	jae UF

	movlpd xmm0, QWORD PTR [XMAX]
	mulsd xmm0, xmm0
	mov edx,14
	jmp CALL_LIBM_ERROR

UF:	movlpd xmm0, QWORD PTR [XMIN]
	mulsd xmm0, xmm0
	mov edx,15
	jmp CALL_LIBM_ERROR

INF_NAN:
	; load lower 32 bits of x
	mov edx, DWORD PTR [esp+4]
	cmp eax, 7ff00000H
	ja NaN_arg
	cmp edx,0
	jnz NaN_arg

	mov eax,DWORD PTR [esp+8]
	cmp eax,7ff00000H
	jne INF_NEG

	; +INF
	fld QWORD PTR [INF]
	ret

INF_NEG:
	; -INF
	fld QWORD PTR [ZERO]
	ret

NaN_arg:   
        ; movlpd xmm0, 4[esp]
        ; addsd xmm0,xmm0
	; sub esp, 16
	; movlpd 4[esp],xmm0
	   
    	; fld  QWORD PTR [esp+4]            ; return x
	; add esp, 16
    	; ret
	mov edx,1002
	jmp CALL_LIBM_ERROR
 
RETURN_ONE:
        ; load hi-part of x
        mov eax,[esp+8]
        and eax,7FFFFFFFH
	; large absolute value (>=2^{10}) ?
        cmp eax, 40900000H
	jae OF_UF

	; small inputs, return 1
	movlpd xmm0, 4[esp]
	; set D flag
	addsd xmm0, QWORD PTR [ONE_val]
	sub esp, 16
	movlpd 4[esp],xmm0
	   
    	fld  QWORD PTR [esp+4]            ; return x
	add esp, 16
	ret

_CIexp_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\filter.c ===
/***
* filter.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       05-21-98  JWM   FP regs now saved/restored in logical, not physical,
*                       order
*       09-11-98  JWM   Katmai support added
*       10-11-99  PML   Protect against corrupting stack frames (vs7#6472)
*       10-15-99  PML   Pop register file, not just change Top ptr (vs7#5422)
*       11-30-99  PML   Compile /Wp64 clean.
*       04-24-00  PML   _fninit before handling SIMD exceptions (vs7#91746)
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include "filter.h"

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation,
    int pop);

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation);

void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop);

int _AdjustLocation(
    int location,
    int pop);

int _PreventStackOverwrite(
    PCONTEXT pctxt,
    int location);

int _IsMemoryLocation(int location);

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location,
    _FP80 *pval);

void _SetTag(
#ifdef _XBOX
    USHORT *pTagWord,
#else
    ULONG *pTagWord,
#endif
    int reg,
    int value);

static _FP80 _zero80 = { 0, 0, 0, 0, 0 };



//
// Define macros for IEEE scaling
// These should be called with all exceptions masked
//


#define SCALE(Operand, adj)          \
    _asm{fild   adj}                 \
    _asm{fld    tbyte ptr Operand}   \
    _asm{fscale}                     \
    _asm{fstp   st(1)}               \
    _asm{fstp   tbyte ptr Operand}



#define FP80_TO_FP64(p64, p80)  \
    _asm{fld    tbyte ptr p80}  \
    _asm{fstp   qword ptr p64}


#define FP80_TO_FP32(p32, p80)  \
    _asm {fld   tbyte ptr p80}  \
    _asm{fstp   dword ptr p32}


static int const _ieee_adj_single = 192;
static int const _ieee_adj_double = 1536;


//
// Define masks for instruction decoding
// x87 instruction form:
//    -------------------------------------------------
//    |      |          |   op  |            |        |
//    | MOD  | OPCODE2  | or REG| 1 1 0 1 1  | OPCODE1|
//    |or op |          | or R/M|  (ESC)     |        |
//    -------------------------------------------------
//    |<-2-->|<---3---->|<--3-->|<---5------>|<--3--->|

#define MASK_OPCODE2    0x3800
#define MASK_REG        0x0700
#define MASK_MOD        0xc000


#define ESC_PREFIX      0xd8
#define MASK_OPCODE1    0x07


typedef struct {
    ULONG   Opcode1:3;
    ULONG   Escape:5;
    ULONG   Reg:3;
    ULONG   Opcode2:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} X87INSTR, *PX87INSTR;


// define masks for C3,C2,C0 in fp status word

#define C3  (1 << 14)
#define C2  (1 << 10)
#define C0  (1 << 8)

typedef struct {
    ULONG Invalid:1;
    ULONG Denormal:1;
    ULONG ZeroDivide:1;
    ULONG Overflow:1;
    ULONG Underflow:1;
    ULONG Inexact:1;
    ULONG StackFault:1;
    ULONG ErrorSummary:1;
    ULONG CC0:1;
    ULONG CC1:1;
    ULONG CC2:1;
    ULONG Top:3;
    ULONG CC3:1;
    ULONG B:1;
    ULONG Pad:16;
} X87STATUS, *PX87STATUS;


//
// Define Tag word values
//

#define TAG_VALID       0x0
#define TAG_ZERO        0x1
#define TAG_SPECIAL     0x2
#define TAG_EMPTY       0x3



// Sanitize status word macro

#define SANITIZE_STATUS_WORD(pFSave) (pFSave->StatusWord &= ~0xff)




//
// Instruction Information structure
//

typedef struct {
    unsigned long Operation:12;       // Fp Operation code
    unsigned long Op1Location:5;      // Location of 1st operand
    unsigned long Op2Location:5;      // Location of 2nd operand
    unsigned long ResultLocation:5;   // Location of result
    int           PopStack:3;         // # of pops done by the instruction
                                      // (if <0 implies a push)
    unsigned long NumArgs:2;          // # of args to the instruction
} INSTR_INFO, *PINSTR_INFO;


//
// The following table contains instruction information for most
// of the x87 instructions. It is indexed with a 7-bit code (3 last
// bits of 1st byte of the instruction (OPCODE1), 1 bit that
// indicates the presence of a MOD field and 3 bits for OPCODE2.
// Reserved instructions, instructions that are not generated by the
// compiler, and some of the instructions that do not raise IEEE
// exceptions have OP_UNSPEC (unspecified) as Operation code
//

//  By convention FLD instructions and some others (FXTRACT, FSINCOS)
//  have a negative pop value (i.e., they push the stack instead of
//  popping it). In that case the location code specifies the register
//  number after pushing the stack


static INSTR_INFO instr_info_table[128] = {

 {OP_ADD,   ST0,  M32R, ST0,   0, 2 }, // FADD  single real
 {OP_MUL,   ST0,  M32R, ST0,   0, 2 }, // FMUL  single real
 {OP_COMP,  ST0,  M32R, RS,    0, 2 }, // FCOM  single real
 {OP_COMP,  ST0,  M32R, RS,    1, 2 }, // FCOMP single real
 {OP_SUB,   ST0,  M32R, ST0,   0, 2 }, // FSUB  single real
 {OP_SUB,   M32R, ST0,  ST0,   0, 2 }, // FSUBR single real
 {OP_DIV,   ST0,  M32R, ST0,   0, 2 }, // FDIV  single real
 {OP_DIV,   M32R, ST0,  ST0,   0, 2 }, // FDIVR single real

 {OP_ADD,   ST0,  REG,  ST0,   0, 2 }, // FADD  ST, ST(i)
 {OP_MUL,   ST0,  REG,  ST0,   0, 2 }, // FMUL  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FCOM  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FCOMP ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUB  ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUBR ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIV  ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIVR ST, ST(i)

 {OP_CVT,   M32R, INV,  ST0,  -1, 1 }, // FLD   single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32R,  0, 1 }, // FST   single real
 {OP_CVT,   ST0,  INV,  M32R,  1, 1 }, // FSTP  single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDCW
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTCW

 {OP_CVT,   REG,  INV,  ST0,  -1, 1 }, // FLD   ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FXCH
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FNOP or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  Z80R, RS,    0, 2 }, // FTST (only this may raise IEEE exc)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDxx (no IEEE exceptions)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386

 {OP_ADD,   ST0,  M32I, ST0,   0, 2 }, // FIADD  short integer
 {OP_MUL,   ST0,  M32I, ST0,   0, 2 }, // FIMUL  short integer
 {OP_COMP,  ST0,  M32I, RS,    0, 2 }, // FICOM  short integer
 {OP_COMP,  ST0,  M32I, RS,    1, 2 }, // FICOMP short integer
 {OP_SUB,   ST0,  M32I, ST0,   0, 2 }, // FISUB  short integer
 {OP_SUB,   M32I, ST0,  ST0,   0, 2 }, // FISUBR short integer
 {OP_DIV,   ST0,  M32I, ST0,   0, 2 }, // FIDIV  short integer
 {OP_DIV,   M32I, ST0,  ST0,   0, 2 }, // FIDIVR short integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 2 }, // FUCOMPP
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_CVT,   M32I, INV,  ST0,  -1, 1 }, // FILD  short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32I,  0, 1 }, // FIST  short integer
 {OP_CVT,   ST0,  INV,  M32I,  1, 1 }, // FISTP short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   M80R, INV,  ST0,  -1, 1 }, // FLD   extended real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M80R,  1, 1 }, // FSTP  extended real

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FCLEX, FINIT, or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M64R, ST0,   0, 2 }, // FADD  double real
 {OP_MUL,   ST0,  M64R, ST0,   0, 2 }, // FMUL  double real
 {OP_COMP,  ST0,  M64R, RS,    0, 2 }, // FCOM  double real
 {OP_COMP,  ST0,  M64R, RS,    1, 2 }, // FCOMP double real
 {OP_SUB,   ST0,  M64R, ST0,   0, 2 }, // FSUB  double real
 {OP_SUB,   M64R, ST0,  ST0,   0, 2 }, // FSUBR double real
 {OP_DIV,   ST0,  M64R, ST0,   0, 2 }, // FDIV  double real
 {OP_DIV,   M64R, ST0,  ST0,   0, 2 }, // FDIVR double real

 {OP_ADD,   REG,  ST0,  REG,   0, 2 }, // FADD  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   0, 2 }, // FMUL  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_SUB,   REG,  ST0,  REG,   0, 2 }, // FSUBR ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   0, 2 }, // FSUB  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   0, 2 }, // FDIVR ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   0, 2 }, // FDIV  ST(i), ST

 {OP_CVT,   M64R, INV,  ST0,  -1, 1 }, // FLD   double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M64R,  0, 1 }, // FST   double real
 {OP_CVT,   ST0,  INV,  M64R,  1, 1 }, // FSTP  double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FRSTOR
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSAVE
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FFREE ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  REG,   0, 1 }, // FST   ST(i)
 {OP_CVT,   ST0,  INV,  REG,   1, 1 }, // FSTP  ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FUCOM ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FUCOMP ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M16I, ST0,   0, 2 }, // FIADD  word integer
 {OP_MUL,   ST0,  M16I, ST0,   0, 2 }, // FIMUL  word integer
 {OP_COMP,  ST0,  M16I, RS,    0, 2 }, // FICOM  word integer
 {OP_COMP,  ST0,  M16I, RS,    1, 2 }, // FICOMP word integer
 {OP_SUB,   ST0,  M16I, ST0,   0, 2 }, // FISUB  word integer
 {OP_SUB,   M16I, ST0,  ST0,   0, 2 }, // FISUBR word integer
 {OP_DIV,   ST0,  M16I, ST0,   0, 2 }, // FIDIV  word integer
 {OP_DIV,   M16I, ST0,  ST0,   0, 2 }, // FIDIVR word integer

 {OP_ADD,   REG,  ST0,  REG,   1, 2 }, // FADDP  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   1, 2 }, // FMULP  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 0 }, // FCOMPP (or reserved)
 {OP_SUB,   REG,  ST0,  REG,   1, 2 }, // FSUBRP ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   1, 2 }, // FSUBP  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   1, 2 }, // FDIVRP ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   1, 2 }, // FDIVP  ST(i), ST

 {OP_CVT,   M16I, INV,  ST0,  -1, 1 }, // FILD  word integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M16I,  0, 1 }, // FIST  word integer
 {OP_CVT,   ST0,  INV,  M16I,  1, 1 }, // FISTP word integer
 {OP_CVT,   M80D, INV,  ST0,  -1, 0 }, // FBLD  packed decimal
 {OP_CVT,   M64I, INV,  ST0,  -1, 1 }, // FILD  long integer
 {OP_CVT,   ST0,  INV,  M80D,  1, 1 }, // FBSTP packed decimal
 {OP_CVT,   ST0,  INV,  M64I,  1, 1 }, // FISTP long integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW AX or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
};



extern int fpieee_flt_simd(unsigned long exc_code, PEXCEPTION_POINTERS p,
           int (__cdecl *handler) (_FPIEEE_RECORD *));



/***
* _fpieee_flt - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/
int _fpieee_flt(unsigned long exc_code,
                PEXCEPTION_POINTERS p,
                int (__cdecl *handler) (_FPIEEE_RECORD *))
{
    PEXCEPTION_RECORD pexc;
    PCONTEXT pctxt;
    PFLOATING_SAVE_AREA pFloatSave;
    _FPIEEE_RECORD ieee;
    ULONG *pinfo;
    X87INSTR instr;
    PINSTR_INFO ptable;
    int ret, index;
    int mod;
#ifdef _XBOX
    USHORT cw, sw;
#else
    ULONG cw, sw;
#endif

    ULONG op1Location, op2Location, resultLocation;
    ULONG newOp1Location, newOp2Location, newResultLocation;



    //
    // If the exception is not an IEEE exception, continue search
    // for another handler
    //


    if (exc_code != STATUS_FLOAT_DIVIDE_BY_ZERO &&
        exc_code != STATUS_FLOAT_INEXACT_RESULT &&
        exc_code != STATUS_FLOAT_INVALID_OPERATION &&
        exc_code != STATUS_FLOAT_OVERFLOW &&
        exc_code != STATUS_FLOAT_UNDERFLOW &&
        exc_code != STATUS_FLOAT_MULTIPLE_FAULTS &&
        exc_code != STATUS_FLOAT_MULTIPLE_TRAPS) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    _asm{fninit}

    /* Handle Katmai exceptions separately */
    if (exc_code == STATUS_FLOAT_MULTIPLE_FAULTS ||
        exc_code == STATUS_FLOAT_MULTIPLE_TRAPS) {
        return fpieee_flt_simd(exc_code, p, handler);
    }


    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    pctxt = p->ContextRecord;
    pFloatSave = &pctxt->FloatSave;



    //
    // Check for software generated exception
    //
    // By convention the first argument to the exception is
    // 0 for h/w exception. For s/w exceptions it points
    // to the _FPIEEE_RECORD
    //

    if (pinfo[0]) {

        /*
         * we have a software exception:
         * the first parameter points to the IEEE structure
         */

        if ((ret = handler((_FPIEEE_RECORD *)(pinfo[0]))) ==
             EXCEPTION_CONTINUE_EXECUTION) {

            //
            // Sanitize status word only if there is continuation
            //

            SANITIZE_STATUS_WORD(pFloatSave);
        }

        return ret;
    }


    //
    // If control reaches here, then we have to deal with a
    // hardware exception
    //


    //
    // If the first byte of the instruction does not contain
    // the ESCAPE bit pattern (1101) there may be an instruction
    // prefix for segment override or address size. The filter
    // routine does not handle this.
    //

    if ((*(UCHAR *)(pFloatSave->ErrorOffset)&~MASK_OPCODE1) != ESC_PREFIX) {

        _ASSERT(0);
        return EXCEPTION_CONTINUE_SEARCH;
    }

    *(USHORT *)&instr = *(USHORT *)(pFloatSave->ErrorOffset);

    mod = instr.Mod == 0x3 ? 1 : 0;
    index = instr.Opcode1 << 4 | mod << 3 | instr.Opcode2;
    ptable = instr_info_table + index;

    ieee.Operation = ptable->Operation;


    cw = pFloatSave->ControlWord;
    sw = pFloatSave->StatusWord;



    //
    // decode fp environment information
    //


    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        ieee.RoundingMode = _FpRoundNearest;
        break;

    case IRC_DOWN:
        ieee.RoundingMode = _FpRoundMinusInfinity;
        break;

    case IRC_UP:
        ieee.RoundingMode = _FpRoundPlusInfinity;
        break;

    case IRC_CHOP:
        ieee.RoundingMode = _FpRoundChopped;
        break;
    }

    switch (cw & IMCW_PC) {
    case IPC_64:
        ieee.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        ieee.Precision = _FpPrecision53;
        break;
    case IPC_24:
        ieee.Precision = _FpPrecision24;
        break;
    }

    ieee.Enable.Inexact = cw & IEM_INEXACT ? 0 : 1;
    ieee.Enable.Underflow = cw & IEM_UNDERFLOW ? 0 : 1;
    ieee.Enable.Overflow = cw & IEM_OVERFLOW ? 0 : 1;
    ieee.Enable.ZeroDivide = cw & IEM_ZERODIVIDE ? 0 : 1;
    ieee.Enable.InvalidOperation = cw & IEM_INVALID ? 0 : 1;

    ieee.Status.Inexact = sw & ISW_INEXACT ? 1 : 0;
    ieee.Status.Underflow = sw & ISW_UNDERFLOW ? 1 : 0;
    ieee.Status.Overflow = sw & ISW_OVERFLOW ? 1 : 0;
    ieee.Status.ZeroDivide = sw & ISW_ZERODIVIDE ? 1 : 0;
    ieee.Status.InvalidOperation = sw & ISW_INVALID ? 1 : 0;

    ieee.Cause.Inexact = ieee.Enable.Inexact && ieee.Status.Inexact;
    ieee.Cause.Underflow = ieee.Enable.Underflow && ieee.Status.Underflow;
    ieee.Cause.Overflow = ieee.Enable.Overflow && ieee.Status.Overflow;
    ieee.Cause.ZeroDivide = ieee.Enable.ZeroDivide && ieee.Status.ZeroDivide;
    ieee.Cause.InvalidOperation = ieee.Enable.InvalidOperation && ieee.Status.InvalidOperation;

    //
    // If location is REG, the register number is
    // encoded in the instruction
    //

    op1Location = ptable->Op1Location == REG ?
                  instr.Reg :
                  ptable->Op1Location;


    op2Location = ptable->Op2Location == REG ?
                  instr.Reg :
                  ptable->Op2Location;

    resultLocation = ptable->ResultLocation == REG ?
                  instr.Reg :
                  ptable->ResultLocation;


    switch (exc_code) {
    case STATUS_FLOAT_INVALID_OPERATION:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:

        //
        // Invalid Operation and Divide by zero are detected
        // before the operation begins; therefore the NPX
        // register stack and memory have not been updated
        //

        _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, op2Location);

        _FillOperand(&ieee.Result, pFloatSave, resultLocation);

        //
        // The previous call was only good for setting the
        // result Format. Since the
        // operation has not begun yet, the result location
        // may contain an incorrect value.
        // For this reason, set OperandValid to 0
        //

        ieee.Result.OperandValid = 0;


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            resultLocation = _PreventStackOverwrite(pctxt,
                                                    resultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          resultLocation,
                          ptable->PopStack);
        }

        break;


    case STATUS_FLOAT_OVERFLOW:
    case STATUS_FLOAT_UNDERFLOW:

        //
        // Overflow and Underflow exception
        // A result has already been computed and the stack has
        // been adjusted, unless the destination is memory (FST instruction)
        //

        if (_IsMemoryLocation(ptable->ResultLocation)) {
            _FP80 tmp;
            _FP32 ftmp;
            _FP64 dtmp;

            int adj;

            //
            // FST(P) instruction (takes only one argument)
            //

            _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
            tmp = _GetFpRegVal(pFloatSave, 0);

            ieee.Result.OperandValid = 1;

            if (resultLocation == M32R) {
                ieee.Result.Format = _FpFormatFp32;
                adj = _ieee_adj_single;
            }
            else {
                ieee.Result.Format = _FpFormatFp64;
                adj = _ieee_adj_double;
            }

            if (exc_code == STATUS_FLOAT_OVERFLOW) {
                adj = -adj;
            }

            SCALE(tmp, adj)

            if (resultLocation == M32R){
                FP80_TO_FP32(ftmp,tmp)
                ieee.Result.Value.Fp32Value = ftmp;
            }
            else {
                FP80_TO_FP64(dtmp,tmp)
                ieee.Result.Value.Fp64Value = dtmp;
            }
            _asm{fnclex}


            if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

                resultLocation = _PreventStackOverwrite(pctxt,
                                                        resultLocation);

                _UpdateFpCtxt(pFloatSave,
                              &ieee.Result,
                              resultLocation,
                              ptable->PopStack);
            }

            break;
        }


        // NO BREAK

    case STATUS_FLOAT_INEXACT_RESULT:

        //
        // Stack has already been adjusted, so we should compute
        // the new location of operands and result
        //


        newOp1Location = _AdjustLocation(op1Location, ptable->PopStack);
        newOp2Location = _AdjustLocation(op2Location, ptable->PopStack);
        newResultLocation = _AdjustLocation(resultLocation, ptable->PopStack);

        if (newOp1Location == newResultLocation)
            newOp1Location = INV;

        if (newOp2Location == newResultLocation)
            newOp2Location = INV;

        _FillOperand(&ieee.Result, pFloatSave, newResultLocation);
        _FillOperand(&ieee.Operand1, pFloatSave, newOp1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, newOp2Location);


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            newResultLocation = _PreventStackOverwrite(pctxt,
                                                       newResultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          newResultLocation,
                          0);

            //
            // no need to adjust the stack
            //
        }

        break;
    }

    if (ret == EXCEPTION_CONTINUE_EXECUTION) {


        SANITIZE_STATUS_WORD(pFloatSave);


        //
        // make fp control word changes take effect on continuation
        //

        cw = pFloatSave->ControlWord;

        switch (ieee.RoundingMode) {
        case _FpRoundNearest:
            cw = cw & ~ IMCW_RC | IRC_NEAR & IMCW_RC;
            break;
        case _FpRoundMinusInfinity:
            cw = cw & ~ IMCW_RC | IRC_DOWN & IMCW_RC;
            break;
        case _FpRoundPlusInfinity:
            cw = cw & ~ IMCW_RC | IRC_UP & IMCW_RC;
            break;
        case _FpRoundChopped:
            cw = cw & ~ IMCW_RC | IRC_CHOP & IMCW_RC;
            break;
        }
        switch (ieee.Precision) {
        case _FpPrecisionFull:
            cw = cw & ~ IMCW_PC | IPC_64 & IMCW_PC;
            break;
        case _FpPrecision53:
            cw = cw & ~ IMCW_PC | IPC_53 & IMCW_PC;
            break;
        case _FpPrecision24:
            cw = cw & ~ IMCW_PC | IPC_24 & IMCW_PC;
            break;
        }

        ieee.Enable.Inexact ? (cw &= ~IEM_INEXACT)
                    : (cw |= IEM_INEXACT);
        ieee.Enable.Underflow ? (cw &= ~IEM_UNDERFLOW)
                    : (cw |= IEM_UNDERFLOW);
        ieee.Enable.Overflow ? (cw &= ~IEM_OVERFLOW)
                   : (cw |= IEM_OVERFLOW);
        ieee.Enable.ZeroDivide ? (cw &= ~IEM_ZERODIVIDE)
                     : (cw |= IEM_ZERODIVIDE);
        ieee.Enable.InvalidOperation ? (cw &= ~IEM_INVALID)
                           : (cw |= IEM_INVALID);

        pFloatSave->ControlWord = cw;


    }


    return ret;
}





/***
* _FillOperand - Fill in operand information
*
*Purpose:
*   Fill in a _FPIEEE_VALUE record based on the information found in
*   the floating point context and the location code
*
*
*Entry:
*    _FPIEEE_VALUE *pOperand        pointer to the operand to be filled in
*    PFLOATING_SAVE_AREA pFloatSave pointer to the floating point context
*    int location                   location code of the operand
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/



void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location)
{
    int c0,c2,c3;

    //
    // Assume valid operand (this is almost always the case)
    //

    pOperand->OperandValid = 1;


    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _GetFpRegVal(pFloatSave, location);
        break;

    case M80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = *(_FP80 *)(pFloatSave->DataOffset);
        break;

    case M16I:
        pOperand->Format = _FpFormatI16;
        pOperand->Value.I16Value = *(_I16 *)(pFloatSave->DataOffset);
        break;

    case M32I:
        pOperand->Format = _FpFormatI32;
        pOperand->Value.I32Value = *(_I32 *)(pFloatSave->DataOffset);
        break;

    case M64I:
        pOperand->Format = _FpFormatI64;
        pOperand->Value.I64Value = *(_I64 *)(pFloatSave->DataOffset);
        break;

    case M64R:
        pOperand->Format = _FpFormatFp64;
        pOperand->Value.Fp64Value = *(_FP64 *)(pFloatSave->DataOffset);
        break;

    case M32R:
        pOperand->Format = _FpFormatFp32;
        pOperand->Value.Fp32Value = *(_FP32 *)(pFloatSave->DataOffset);
        break;

    case M80D:
        pOperand->Format = _FpFormatBcd80;
        pOperand->Value.Bcd80Value = *(_BCD80 *)(pFloatSave->DataOffset);
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        pOperand->Format = _FpFormatCompare;
        c0 = pFloatSave->StatusWord & C0 ? (1<<0) : 0;
        c2 = pFloatSave->StatusWord & C2 ? (1<<2) : 0;
        c3 = pFloatSave->StatusWord & C0 ? (1<<3) : 0;

        switch(c0 | c2 | c3) {
        case 0x000:

            // ST > SRC

            pOperand->Value.CompareValue = _FpCompareGreater;
            break;

        case 0x001:

            // ST < SRC

            pOperand->Value.CompareValue = _FpCompareLess;
            break;

        case 0x100:

            // ST = SRC

            pOperand->Value.CompareValue = _FpCompareEqual;
            break;

        default:

            pOperand->Value.CompareValue = _FpCompareUnordered;
            break;
        }

        break;


    case Z80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _zero80;
        break;

    case INV:

        pOperand->OperandValid = 0;
        break;


    case REG:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        pOperand->OperandValid = 0;
        break;

    }
}




/***
* _UpdateFpCtxt - Update fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation and
*   adjust the fp stack accordingly
*
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location                      location code for destination in the
*                                     floating point context
*   int pop                           # of times the stack should be popped
*                                     (if negative, the stack is pushed)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location,
    int pop)
{
    if (pop < 0) {
        _AdjustStack(pFloatSave, pop);
    }

    _UpdateResult(pFloatSave, pOperand, location);

    if (pop > 0) {
        _AdjustStack(pFloatSave, pop);
    }
}




/***
* _UpdateResult -  Update result information in the fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location)                     location code for destination in the
*                                     floating point context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location)
{

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        _SetFpRegVal(pFloatSave,location,&pOperand->Value.Fp80Value);
        break;

    case M80R:
        *(_FP80 *)(pFloatSave->DataOffset) = pOperand->Value.Fp80Value;
        break;

    case M16I:
        *(_I16 *)(pFloatSave->DataOffset) = pOperand->Value.I16Value;
        break;

    case M32I:
        *(_I32 *)(pFloatSave->DataOffset) = pOperand->Value.I32Value;
        break;

    case M64I:
        *(_I64 *)(pFloatSave->DataOffset) = pOperand->Value.I64Value;
        break;

    case M64R:
        *(_FP64 *)(pFloatSave->DataOffset) = pOperand->Value.Fp64Value;
        break;

    case M32R:
        *(_FP32 *)(pFloatSave->DataOffset) = pOperand->Value.Fp32Value;
        break;

    case M80D:
        *(_BCD80 *)(pFloatSave->DataOffset) = pOperand->Value.Bcd80Value;
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        switch (pOperand->Value.CompareValue) {
        case _FpCompareEqual:
            // C3,C2,C0 <- 100
            pFloatSave->StatusWord |= C3;
            pFloatSave->StatusWord &= (~C2 & ~C0);
            break;
        case _FpCompareGreater:
            // C3,C2,C0 <- 000
            pFloatSave->StatusWord &= (~C3 & ~C2 & ~C0);
            break;
        case _FpCompareLess:
            // C3,C2,C0 <- 001
            pFloatSave->StatusWord |= C0;
            pFloatSave->StatusWord &= (~C3 & ~C2);
            break;
        case _FpCompareUnordered:
            // C3,C2,C0 <- 111
            pFloatSave->StatusWord |= (C3 | C2 | C0);
            break;
        }


    case INV:

        break;

    case REG:
    case Z80R:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        break;

    }
}




/***
* _AdjustStack -
*
*Purpose:
*  Pop (or push) the image of the fp stack in the fp context
*
*Entry:
*  PFLOATING_SAVE_AREA pFloatSaveArea:  pointer to the fp context
*  int pop:     Number of times to pop the stack
*               (if pop<0 stack should be pushed once)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop)
{
    PX87STATUS pStatus;
    _FP80 tempRegFile[8];
    int i;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (pop > 0) {

        // stack should be popped

        for (i=0; i<pop; i++) {

            //
            // mark register as invalid
            //

            _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_EMPTY);

            pStatus->Top++;
        }

        // pop (rotate) register save area

        memcpy(tempRegFile, pFloatSave->RegisterArea, pop * sizeof(_FP80));
        memmove(pFloatSave->RegisterArea,
                ((_FP80 *)pFloatSave->RegisterArea) + pop,
                (8 - pop) * sizeof(_FP80));
        memcpy(((_FP80 *)pFloatSave->RegisterArea) + (8 - pop),
               tempRegFile,
               pop * sizeof(_FP80));

    }

    else if (pop < 0) {

        // stack should be pushed once (e.g., fsincos, fxtract)

        //
        // mark register as valid
        //

        pStatus->Top--;

        _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_VALID);

        // push (rotate) register save area just once

        memmove(((_FP80 *)pFloatSave->RegisterArea) + 1,
                pFloatSave->RegisterArea,
                7 * sizeof(_FP80));

    }
}



/***
* _AdjustLocation -
*
*Purpose:
*   Modify location code based on stack adjustment
*
*Entry:
*   int location:   old location code
*   int pop:        stack adjustment factor (>0 for pop, <0 for push)
*
*Exit:
*   returns new location code
*
*Exceptions:
*
*******************************************************************************/


int _AdjustLocation(int location, int pop)
{

    int newlocation;

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        newlocation = location - pop;
        if (newlocation < 0 || newlocation > 7) {
            newlocation = INV;
        }
        break;

    default:
        newlocation = location;
    }

    return newlocation;

}


/***
* _PreventStackOverwrite -
*
*Purpose:
*  Checks if a memory result location is to a stale stack address, where
*  writing to that address would corrupt some newer stack frame.  This can
*  happen when a pending exception was for an FST to a stack local, but the
*  exception wasn't triggered until after the enclosing function exited and
*  the stack local no longer exists, so that it's memory is now being used
*  by an exception handling routine.
*
*Entry:
*  int location:    result location code
*
*Exit:
*  Returns a location code of INV if stack corruption would occur, otherwise
*  returns the entry location code unchanged.
*
*Exceptions:
*
*******************************************************************************/

int _PreventStackOverwrite(PCONTEXT pctxt, int location)
{
    if (_IsMemoryLocation(location)) {

        if (pctxt->Esp > pctxt->FloatSave.DataOffset) {

            //
            // Memory result location is below ESP of FP instr where pending
            // exception was raised
            //

            uintptr_t curESP;
            _asm {
                push    esp
                pop     eax
                mov     curESP, eax
            }

            if (curESP <= pctxt->FloatSave.DataOffset + sizeof(M80R)) {

                //
                // Memory result is in the stack frame of an exception
                // handling function - suppress the update.
                //

                location = INV;
            }
        }
    }

    return location;
}

/***
* _IsMemoryLocation -
*
*Purpose:
*  Returns true if the location code specifies a memory location,
*  otherwise it returns false.
*
*
*Entry:
*  int location:    location code
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int _IsMemoryLocation(int location)
{
    switch (location) {
    case M80R:
    case M16I:
    case M32I:
    case M64I:
    case M64R:
    case M32R:
    case M80D:
        return 1;
    }

    return 0;

}







/***
* _GetFpRegVal - Get floating point register value
*
*Purpose:
* Return the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
*
*Exit:
* returns the register value in _FP80 format
*
*Exceptions:
*
*******************************************************************************/

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation)
{
    if (stackLocation>=0 && stackLocation<8)
        return *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation);
    else
        return _zero80;
}



/***
* _SetFpRegVal - Set floating point register value
*
*Purpose:
* Set the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
* _FP80 *pval                     pointer to the new value
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation,
    _FP80 *pval)
{
    PX87STATUS pStatus;
    int n;
    int tag;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (stackLocation>=0 && stackLocation<8) {
        *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation) = *pval;

        n = (pStatus->Top+stackLocation) % 8;

        //
        // Update tag word
        //

        switch (pval->W[4] & 0x7fff) { // check value of the exponent

        case 0:
            if (*(ULONG *)pval == 0 && *((ULONG *)pval+1) == 0) {
                // zero
                tag = TAG_ZERO;
            }
            else {
                // denormal or invalid
                tag = TAG_SPECIAL;
            }
            break;


        case 0x7fff:
            // infinity or NaN
            tag = TAG_SPECIAL;
            break;

        default:
            // valid
            tag = TAG_VALID;
        }

        _SetTag(&pFloatSave->TagWord, n, tag);
    }
}



/***
* _SetTag -
*
*Purpose:
* Set tag of register 'reg' in  tag word to 'value'
*
*
*Entry:
*   ULONG *pTagWord        pointer to the tagword to be modified
*   int reg                absolute register number (NOT relative to stack top)
*   int value              new tag value (empty, valid, zero, special)
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetTag(
#ifdef _XBOX
    USHORT *pTagWord,
#else
    ULONG *pTagWord,
#endif
    int reg,
    int value)
{
#ifdef _XBOX
    USHORT mask;
#else
    ULONG mask;
#endif
    int shift;

    shift = reg << 1;
    mask = 0x3 << shift;
    value <<= shift;

    *pTagWord = *pTagWord & ~mask | value & mask;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\filter.h ===
/***
* filter.h - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       03-01-98  PLS   move the definitions from filter.c to filter.h, so
*                       filter_simd.c can use it.
*******************************************************************************/


//
// Location codes
//
//
// By convention the first eight location codes contain the number of
// a floating point register, i.e., ST0 through ST7 have the values
// 0 to 7 respectively. The other codes have arbitrary values:
//
//  CODE    MEANING
//   STi    (0<=i<8) Floating point stack location ST(i)
//   REG    FP stack location is in the REG field of the instruction
//   RS     FP status register
//   M16I   Memory location (16bit int)
//   M32I   Memory location (32bit int)
//   M64I   Memory location (64bit int)
//   M32R   Memory location (32bit real)
//   M64R   Memory location (64bit real)
//   M80R   Memory location (80bit real)
//   M80D   Memory location (80bit packed decimal)
//   Z80R   Implied Zero Operand
//   M128R_M32R  Memory location (128bit memory location, 32bit real)
//   M128R_M64R  Memory location (128bit memory location, 64bit real) 
//   MMX    64-bit multimedia register
//   XMMI   128-bit multimedia register
//   IMM8   immedidate 8-bit operand
//   INV    Invalid, unavailable, or unused
//

#define ST0         0x00
#define ST1         0x01
#define ST2         0x02
#define ST3         0x03
#define ST4         0x04
#define ST5         0x05
#define ST6         0x06
#define ST7         0x07
#define REG         0x08
#define RS          0x09
#define M16I        0x0a
#define M32I        0x0b
#define M64I        0x0c
#define M32R        0x0d
#define M64R        0x0e
#define M80R        0x0f
#define M80D        0x10
#define Z80R        0x11
#define M128_M32R   0x12 //Xmmi
#define M128_M64R   0x13 //Xmmi
#define MMX         0x14 //Xmmi
#define XMMI        0x15 //Xmmi
#define IMM8        0x16 //Xmmi
#define XMMI2       0x17 //Xmmi2
#define M64R_64     0x19 //Xmmi2
#define M128_M32I   0x1a //Xmmi2
#define XMMI_M32I   0x1b //Xmmi2
#define LOOKUP      0x1e //Xmmi2
#define INV         0x1f
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\filter_simd.c ===
/***
* filter_simd.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Handles XMMI SIMD numeric exceptions
*
*Revision History:
*       03-01-98  PLS   written.  
*       01-11-99  PLS   added XMMI2 support.
*       01-12-99  PLS   included XMMI2 conversion support.
*       11-30-99  PML   Compile /Wp64 clean.
*       07-31-00  PLS   Placeholder for DAZ bit set
*       11-02-00  PLS   DAZ is supported by XMMI Emulation Code, 
*                       remove DAZ placeholder
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include <fpieee.h>
#include "filter.h"
#include "xmmi_types.h"
#include "temp_context.h"
#ifdef _XMMI_DEBUG
#include "debug.h"
#endif

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

#define InitExcptFlags(flags)       { \
        (flags).Inexact = 0; \
        (flags).Underflow = 0; \
        (flags).Overflow = 0; \
        (flags).ZeroDivide = 0; \
        (flags).InvalidOperation = 0; \
} 

__inline
void
FxSave(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit  0h
    }
}

__inline
void
FxRstor(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxrstor [eax]
        _emit  0fh
        _emit  0aeh
        _emit  8h
    }
}

extern 
ULONG 
XMMI_FP_Emulation(
    PXMMI_ENV XmmiEnv);

extern 
ULONG 
XMMI2_FP_Emulation(
    PXMMI_ENV XmmiEnv);

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt);

ULONG
LoadImm8(
    PXMMIINSTR Instr);

void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv);

void 
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags);

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv);

static ULONG  ax0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib0 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib8 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  d32  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  reg  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );

//
//The following 4 tables are used to parse the instructions - 0F/F3 0F/66 0F/F2 0F Opcodes.
//(XMMI/XMMI2 Opcodes are sparse.  Instead of having 1 big table, 4 tables are created,
// grouped by opcodes).
//Note: For the Scalar form of the instruction, it is always looked up in the table as 
//      XXXXPS for XMMI, XXXXPD for XMMI2. fScalar indicates if the instruction is a 
//      scalar or not. instrIndex indicates if the instruction is a XMMI or XMMI2.  
//      Scalar operation code == non-Scalar operation code + 1 (1st col in the table), 
//      Scalar operand location: scalar form of the non-Scalar operand.
//Note: The NumArgs is a 2 bit fields in the table, the actual value is NumArgs+1.
//
//
//InstInfoTableX is added to assist the parsing of the XMMI2 conversion instructions.
//Scalar rule does not apply to some of the XMMI2 conversion instructions.  Additional
//information is needed to parse the instruction.  In such case, one of the 4 tables
//(based on the Opcode) is looked up, if Op1Location has a value of LOOKUP, then,
//Op2Location is used as index to InstInfoTableX.  The entry in InstInfoTableX describes
//the real parsing rule for the instruction.  
//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO. 
//
//Note: the size is 5, therefore, the max entries in this table can only be 32.
//

//
// Opcode 5x table
//
static XMMI_INSTR_INFO InstInfoTable5X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  XMMI,       0,     XMMI, 3},               // OP_SQRTSS    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  XMMI2,      0,     XMMI2,1},               // OP_SQRTSD    F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_ADDSS     F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_ADDSD     F2 58 (XMMI2)
 {OP_MULPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MULSS     F3 59 (XMMI)
 {OP_MULPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MULSD     F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,0,         0,     0,    0},               // OP_CVTSS2SD  F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  XMMI2,      0,     XMMI, 1},               // OP_CVTSD2SS  F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,4,         0,     0,    0},               // OP_CVTTPS2DQ F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,6,         0,     0,    0},               // NONE               (XMMI2)
 {OP_SUBPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_SUBSS     F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_SUBSD     F2 5C (XMMI2)
 {OP_MINPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MINSS     F3 5D (XMMI)
 {OP_MINPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MINSD     F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_DIVSS     F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_DIVSD     F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MAXSS     F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MAXSD     F2 5F (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  M128_M32R,  0,     XMMI, 3},               // OP_SQRTSS    M32R    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  M128_M64R,  0,     XMMI2,1},               // OP_SQRTSD    M64R_64 F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_ADDSS     M32R    F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_ADDSD     M64R_64 F2 58 (XMMI2)
 {OP_MULPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MULSS     M32R    F3 59 (XMMI)
 {OP_MULPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MULSD     M64R_64 F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,2,         0,     0,    0},               // OP_CVTSS2SD  M32R    F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  M128_M64R,  0,     XMMI, 1},               // OP_CVTSD2SS  M64R_64 F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,8,         0,     0,    0},               // OP_CVTTPS2DQ         F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,10,        0,     0,    0},               // NONE                       (XMMI2)
 {OP_SUBPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_SUBSS     M32R    F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_SUBSD     M64R_64 F2 5C (XMMI2)
 {OP_MINPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MINSS     M32R    F3 5D (XMMI)
 {OP_MINPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MINSD     M64R_64 F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_DIVSS     M32R    F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_DIVSD     M64R_64 F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MAXSS     M32R    F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MAXSD     M64R_64 F2 5F (XMMI2)
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode Cx table
//
static XMMI_INSTR_INFO InstInfoTableCX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, XMMI,       HAS_IMM8, XMMI, 3},            // OP_CMPSS  F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,XMMI2,      HAS_IMM8, XMMI2,1},            // OP_CMPSD  F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, M128_M32R,  HAS_IMM8,  XMMI, 3},           // OP_CMPSS  M32R    F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,M128_M64R,  HAS_IMM8,  XMMI2,1},           // OP_CMPSD  M64R_64 F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode 2x table
//
static XMMI_INSTR_INFO InstInfoTable2X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  MMX,        0,     XMMI, 1},               // OP_CVTSI2SS  REG F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  XMMI,       0,     MMX,  1},               // OP_CVTTSS2SI REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  XMMI2,      0,     MMX,  1},               // OP_CVTTSD2SI REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  XMMI,       0,     MMX,  1},               // OP_CVTSS2SI  REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  XMMI2,      0,     MMX,  1},               // OP_CVTSD2SI  REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_UCOMISD,   XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)
 {OP_COMISS,    XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_COMISD,    XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  M64I,       0,     XMMI, 1},               // OP_CVTSI2SS  M32I     F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  M64R,       0,     MMX,  1},               // OP_CVTTSS2SI M32R REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTTSD2SI M64_64R REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  M64R,       0,     MMX,  1},               // OP_CVTSS2SI  M32R REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTSD2SI  M64_64R REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_UCOMISD,   XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
 {OP_COMISS,    XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_COMISD,    XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
                                                                 // MMX -> REG
                                                                 // M64R      -> M32R
                                                                 // M128_M64R -> M64R_64
                                                                 // M64I      -> M32I
};

//
// Opcode Ex table
//
static XMMI_INSTR_INFO InstInfoTableEX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,12,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,14,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
};

//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO 
//
//
static XMMI_INSTR_INFO InstInfoTableX[16] = {
 {OP_CVTPS2PD,  INV,  XMMI,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  XMMI,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTPS2PD,  INV,  M64R,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  M32R,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTDQ2PS,  INV,  XMMI_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  XMMI,       0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  XMMI,       0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTDQ2PS,  INV,  M128_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  M128_M32R,  0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  M128_M32R,  0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTTPD2DQ, INV,  XMMI2,      0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)    
 {OP_CVTPD2DQ,  INV,  XMMI2,      0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    

 {OP_CVTTPD2DQ, INV,  M128_M64R,  0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)     
 {OP_CVTPD2DQ,  INV,  M128_M64R,  0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    
};

//The following table is used to parse Mod/RM byte to compute the data memory reference
/* Mod | Reg | R/M */
/* 7-6 | 5-3 | 2-0 */

/* Reg: EAX ECX EDX EBX ESP EBP ESI EDI */
/*      000 001 010 011 100 101 110 111 */
/* Mod: R/M:     Ea            Routine  */
/* 00   000      [EAX]         ax0      */
/*      001      [ECX]         cx0      */
/*      010      [EDX]         dx0      */
/*      011      [EBX]         bx0      */
/*      100      +SIB          sib0     */
/*      101      disp32        d32      */
/*      110      [ESI]         si0      */
/*      111      [EDI]         di0      */
/* 01   000      disp8[EAX]    ax8      */
/*      001      disp8[ECX]    cx8      */
/*      010      disp8[EDX]    dx8      */
/*      011      disp8[EBX]    bx8      */
/*      100      disp8+SIB     sib8     */
/*      101      disp8[EBP]    bp8      */
/*      110      disp8+[ESI]   si8      */
/*      111      disp8+[EDI]   di8      */
/* 10   000      disp32[EAX]   ax32     */
/*      001      disp32[ECX]   cx32     */
/*      010      disp32[EDX]   dx32     */
/*      011      disp32[EBX]   bx32     */
/*      100      disp32+SIB    sib32    */
/*      101      disp32[EBP]   bp32     */
/*      110      disp32+[ESI]  si32     */
/*      111      disp32+[EDI]  di32     */
/* 11   000-111  Regs          reg      */
typedef (*codeptr)();
static codeptr modrm32[256] = {
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
};


/***
* fpieee_flt_simd - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/

int fpieee_flt_simd(unsigned long exc_code,
                    PTEMP_EXCEPTION_POINTERS p,
                    int (__cdecl *handler) (_FPIEEE_RECORD *))
{

    PEXCEPTION_RECORD pexc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    _FPIEEE_RECORD FpieeeRecord;
    ULONG Status = EXCEPTION_CONTINUE_EXECUTION;
    ULONG *pinfo;
    PUCHAR istream;
    UCHAR ibyte;
    BOOLEAN fPrefix,fScalar,fDecode, fMod;
    MXCSRReg MXCsr;
    XMMI_FP_ENV XmmiFpEnv;
    XMMI_ENV XmmiEnv;
    PXMMI_INSTR_INFO ptable;
    PXMMI_INSTR_INFO instr_info_table;
    PXMMIINSTR instr;
    ULONG instrIndex, index, pair, InstLen = 0, Offset = 0;
    PXMMI_EXCEPTION_FLAGS OFlags, Flags;
    ULONG DataOffset;

#ifdef _XMMI_DEBUG
    DebugFlag=7;
#endif

    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    
    //Check for software generated exception
    
    //
    //By convention the first argument to the exception is 0 for h/w exception. 
    //For s/w exceptions it points to the _FPIEEE_RECORD
    //
    if (pinfo[0]) {

        //  
        //We have a software exception:
        //the first parameter points to the IEEE structure
        //
        return handler((_FPIEEE_RECORD *)(pinfo[0]));

    }

    //
    //If control reaches here, then we have to deal with a hardware exception
    //First check to see if the context record has XMMI saved area.
    //
    pctxt = (PTEMP_CONTEXT) p->ContextRecord;
    
    if ((pctxt->ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
#ifdef _XMMI_DEBUG
        fprintf(stderr, "No Context_Extended_Registers area\n");
#else        
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
        
    } else {
        //For NT
        pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    }
 
#ifdef _XMMI_DEBUG
    dump_Control(p);
#endif //_XMMI_DEBUG

    //
    //Save the original DataOffset.
    //Unlike X87 (X87: The memory reference is provided via DataOffset), XMMI's 
    //memory reference is derived from parsing the instruction by this routine.
    //
    DataOffset = pExtendedArea->DataOffset;

    //
    //Check Instruction prefixes and/or 2 byte opcode starts with 0F
    //The only prefix we support is F3 (Scalar form of the XMMI instruction) for XMMI.
    //Additional prefix we support is 66 and F2 (Scalar form of the XMMI2 instruction) for XMMI2.
    //There may other instruction prefix, such as, segment override or address size. 
    //However, the filter routine does not handle this type (same as x87).
    //
    //Default to Katmai Instruction set
    instrIndex = XMMI_INSTR;
    fDecode = FALSE;      //Default to no error seen
    __try {

        //
        //Read instruction prefixes
        //
        fPrefix = TRUE;   //Default to prefix scan
        fScalar = FALSE;  //Default to non-scalar instruction

        //
        //Unlike X87 (X87: the EIP is from: istream = (PUCHAR) pExtendedArea->ErrorOffset),
        //EIP is from trap frame's EIP.
        //
        istream = (PUCHAR) pctxt->Eip;

        while (fPrefix) {
            ibyte = *istream;
            istream++;
            switch (ibyte) {
                case 0xF3:  // rep or XMMI scaler
                    fScalar = TRUE;
                    InstLen++;
                    break;

                case 0x66:  // operand size or XMMI2
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0xF2:  // rep or XMMI2 scaler
                    fScalar = TRUE;
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override

                    //
                    //We don't support this.  X87 does not support this either. 
                    //
                    fDecode = TRUE;
                    break;

                case 0x67:  // address size
                case 0xF0:  // lock
 
                    fDecode = TRUE;         
                    break;
                    
                default:    // stop the prefix scan
                    fPrefix = FALSE;
                    break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 1 %x\n", istream));  
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }

    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 1, %x EIP: %x \n", istream, pctxt->Eip));  
        istream = (PUCHAR) pctxt->Eip;
        DPrint(XMMI_WARNING, ("%x\n", *istream));  
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Get the next opcode
    //
    __try {

        //
        // instr points to the real Opcode (istream points to the byte after 0F)
        //
        instr = (PXMMIINSTR) istream;

        //
        // If we get here, ibyte can only point to 0F, for,
        // there are only 4 valid cases: 
        // 66 0F, F2 0F, F3 0F or 0F
        //
        if (ibyte != 0x0F) {
            fDecode = TRUE;
            goto tryExit;
        }
        
        //5x
        if (instr->Opcode1b == 5) {
            instr_info_table = InstInfoTable5X;
        //Cx
        } else {
            if (instr->Opcode1b == 0x0C) {
                instr_info_table = InstInfoTableCX;
            //2x
            } else {
                if (instr->Opcode1b == 2) {
                    instr_info_table = InstInfoTable2X;
                } else {
                    if (instr->Opcode1b == 0x0E) {
                        instr_info_table = InstInfoTableEX;
                    } else {
                        fDecode = TRUE;
                        goto tryExit;
                    }
                }
            }    
        }

        //
        //Pick up the Mod field: Register Ref (0) or Memory Ref (1)
        //
        fMod = instr->Mod == 0x3 ? 0 : 1;

        //
        //fScalar indicates XMMI/XMMI2 instruction is a scalar form or not.
        //1st byte of the Opcode tells which table it is.
        //2nd byte of the Opcode tells which entry it is in the table.
        //Compute the index, if it is a memory ref, index will be at the second half of the table.
        //ie. ADDPS 58 - for reg, index = 8*2
        //    ADDPD 58 - for reg, index = 8*2+1
        //    ADDPS 58 - for mem, index = 18h*2
        //    ADDPD 58 - for mem, index = 18h*2+1

        index = instr->Opcode1a | fMod << 4;
        
        //
        //Check to see if the Opcode byte is valid.
        //
        if (index > INSTR_IN_OPTABLE) {
            fDecode = TRUE;
            goto tryExit;
        }

        ptable = &instr_info_table[index*INSTR_SET_SUPPORTED+instrIndex];
        if (ptable->Operation == OP_UNSPEC) {
            fDecode = TRUE;
            goto tryExit;
        } else {

            //
            // Odd ball instructions, perform further look up.
            //
            if (ptable->Op1Location == LOOKUP) {
                if (fScalar) {
                    ptable = &InstInfoTableX[ptable->Op2Location+1];
                } else {
                    ptable = &InstInfoTableX[ptable->Op2Location];
                }

                //
                //All bets are off.
                //
                fScalar = 0;
                instrIndex = XMMI2_OTHER;
            }

        }

        //
        // Adjust and Save the Operation, Take fScalar into account.
        //
        XmmiFpEnv.OriginalOperation = ptable->Operation + fScalar;

        //
        //At this point, we have a valid XMMI instruction that this routine supports.
        //
        //nF3 + 0F OpCode Mod/RM
        //nF2 + 0F OpCode 
        //n66 + 0F Opcode
        //      0F Opcode
        InstLen = InstLen + 3;

        //
        //We need to compute the memory reference if the data is a memory reference type.
        //
        if (fMod) {
            
            istream = (PUCHAR) instr;
            
            //
            //instr points to the opcode, we want the Mod/RM byte in ibyte.
            //
            istream++;
            ibyte = *istream;

            //
            //point to the byte after Mod/RM
            //
            istream++;

            //
            //Parse the instruction to calculate the memory reference, store the result
            //in DataOffset.
            //
            Offset = (*modrm32[ibyte])(&pExtendedArea->DataOffset, pctxt, istream);
            PRINTF(("pExtendedArea->DataOffset %x\n", pExtendedArea->DataOffset));  
        }

        //
        //Load Operand 1 for instruction with 2 operands, 
        //or none for instruction with 1 operand.
        //
        LoadOperand(fScalar, ptable->Op1Location, instr->Reg, &XmmiFpEnv.Operand1, pctxt); 

        //
        //Load Operand 2
        //
        if (ptable->Op1Location == INV) { //instruction with 1 operand
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand1, pctxt);
            XmmiFpEnv.Operand2.Op.OperandValid = 0;
        } else {                          //instruction with 2 operands
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand2, pctxt); 
        }

        //
        //Load Result, init to Operand1
        //
        LoadOperand(fScalar, ptable->ResultLocation, instr->Reg, &XmmiFpEnv.Result, pctxt); 
    
        InstLen = InstLen + Offset;

        //
        //Pick up imm8 if any.
        //
        if (ptable->Op3Location == HAS_IMM8) {
            istream = istream + Offset;
            XmmiFpEnv.Imm8 = *istream;
            InstLen++;
        }


tryExit: ;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 2, %x\n", istream)); 
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }
   
    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 2, %x Inst: %x, %x\n", istream, instr, *instr)); 
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    //Set up XmmiEnv environment from fp & mxcsr for Emulation.
    //

    //decode fp environment information
    switch (pExtendedArea->ControlWord & IMCW_PC) {
    case IPC_64:
        XmmiEnv.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        XmmiEnv.Precision = _FpPrecision53;
        break;
    case IPC_24:
        XmmiEnv.Precision = _FpPrecision24;
        break;
    }

    //decode mxcsr
    MXCsr.u.ul = pExtendedArea->MXCsr;
    switch (MXCsr.u.mxcsr.Rc & MaskCW_RC) {
    case rc_near:
        XmmiEnv.Rc = _FpRoundNearest;
        break;
    case rc_down:
        XmmiEnv.Rc = _FpRoundMinusInfinity;
        break;
    case rc_up:
        XmmiEnv.Rc = _FpRoundPlusInfinity;
        break;
    case rc_chop:
        XmmiEnv.Rc = _FpRoundChopped;
        break;
    }

    //and the rest.
    XmmiEnv.Masks = (MXCsr.u.ul & MXCSR_MASKS_MASK) >> 7;
    XmmiEnv.Fz    = MXCsr.u.mxcsr.Fz;
    XmmiEnv.Daz   = MXCsr.u.mxcsr.daz;
    XmmiEnv.EFlags = pctxt->EFlags;
    XmmiEnv.Imm8 = XmmiFpEnv.Imm8;
    Flags = (PXMMI_EXCEPTION_FLAGS) &XmmiEnv.Flags;

    //
    //Set up XmmiFpEnv environment for this routine.
    //

    //Save the original exception flags
    XmmiFpEnv.IFlags = MXCsr.u.ul & MXCSR_FLAGS_MASK;
    XmmiFpEnv.OFlags = 0;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv.OFlags;

#ifdef _XMMI_DEBUG
    dump_XmmiFpEnv(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    pair = ptable->NumArgs + 1;
    if (fScalar) pair = 1;

    //
    // Loop through SIMD.  1 data item at a time.
    //
    for ( index=0; index < pair; index++ ) {    

        //
        // ieee field does not have denormal bit defined. Emulator returns
        // all Exception flags bits through this XmmiEnv.Flags field.
        //
        XmmiEnv.Flags = 0;

        //
        // Set up ieee Input Operands
        //
        InitExcptFlags(FpieeeRecord.Cause);
        InitExcptFlags(FpieeeRecord.Enable);
        InitExcptFlags(FpieeeRecord.Status);
        FpieeeRecord.RoundingMode = XmmiEnv.Rc; 
        FpieeeRecord.Precision = XmmiEnv.Precision;
        FpieeeRecord.Operation = XmmiFpEnv.OriginalOperation;

        FpieeeRecord.Operand1.OperandValid = XmmiFpEnv.Operand1.Op.OperandValid; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Operand1.Format = XmmiFpEnv.Operand1.Op.Format;
       
        if (XmmiFpEnv.Operand2.Op.OperandValid) {
            FpieeeRecord.Operand2.OperandValid = XmmiFpEnv.Operand2.Op.OperandValid; 
            if (instrIndex == XMMI2_INSTR) {
                FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
            } else {
                if (instrIndex == XMMI_INSTR) {
                    FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
                             break;
                    }
                }
            }
            FpieeeRecord.Operand2.Format = XmmiFpEnv.Operand2.Op.Format;
        } else {
            FpieeeRecord.Operand2.OperandValid = 0;
        }

        FpieeeRecord.Result.OperandValid = 0; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Result.Format = XmmiFpEnv.Result.Op.Format;

        XmmiEnv.Ieee = (_PFPIEEE_RECORD) &FpieeeRecord;

#ifdef _XMMI_DEBUG
        PRINTF(("INPUT #%d:\n", index));
#endif _XMMI_DEBUG

        //
        // Perform Emulation
        //
        // Note: Cause will be all zeros for denormal.  
        //       Raised     - Denormal
        //       Not Raised - no exception
        //
        if ((instrIndex == XMMI2_INSTR) || (instrIndex == XMMI2_OTHER)) {
            XmmiFpEnv.Raised[index] = XMMI2_FP_Emulation(&XmmiEnv);
        } else {
            XmmiFpEnv.Raised[index] = XMMI_FP_Emulation(&XmmiEnv);
        }

        //
        // Remember the exceptions. 
        //
        XmmiFpEnv.Flags[index] = XmmiEnv.Flags;

        if (XmmiFpEnv.Raised[index] == ExceptionRaised) {

#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d: ExceptionRaised\n", index));
            print_FPIEEE_RECORD_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
            
            //
            //ORed the flags.
            //
            if (Flags->pe) OFlags->pe = 1;
            if (Flags->ue) OFlags->ue = 1;
            if (Flags->oe) OFlags->oe = 1; 
            if (Flags->ze) OFlags->ze = 1;
            if (Flags->de) OFlags->de = 1;
            if (Flags->ie) OFlags->ie = 1;

            //
            // invoke the user-defined exception handler
            //
            Status = handler(&FpieeeRecord);        

            //
            // return if not EXCEPTION_CONTINUE_EXECUTION
            //
            if (Status != EXCEPTION_CONTINUE_EXECUTION) {
                return (Status);
            }

            //
            // Adjust the compare result.
            //
            AdjustExceptionResult(XmmiFpEnv.OriginalOperation, &XmmiEnv);

        } else {
#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d:No ExceptionRaised\n", index));
            print_FPIEEE_RECORD_NO_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
        }

        //
        // Or the result piece together
        //
        XmmiFpEnv.Result.Op.OperandValid = FpieeeRecord.Result.OperandValid;
        XmmiFpEnv.EFlags = XmmiEnv.EFlags;
        if (XmmiFpEnv.Result.Op.OperandValid) {
            if (instrIndex == XMMI2_INSTR) {
                XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
            } else {
                if (instrIndex == XMMI_INSTR) {
                    XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;
                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
                             break;
                    }
                }
            }
        }
    } // End of Loop through SIMD.  1 data item at a time.

    //
    // Update the result from XmmiFpEnv to the context
    // 
    UpdateResult(&XmmiFpEnv.Result, pctxt, XmmiFpEnv.EFlags);

#ifdef _XMMI_DEBUG
    //
    // Valid the processor MXCSR and the emulator MXCSR 
    //
    NotOk = ValidateResult(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    //
    //Update EIP
    //
    istream = (PUCHAR) pctxt->Eip;
    istream = istream + InstLen;
    (PUCHAR) pctxt->Eip = istream;

    //
    //Place the original one back.
    //
    pExtendedArea->DataOffset = DataOffset;


    return Status;

}

/***
* LoadOperand - Load in operand information
*
*Purpose:
*   Fill in data in the internal operand structure based on the information 
*   found in the floating point context and the location code
*
*Entry:
*    fScalar             Packed or Scalar
*    opLocation          type of the operand
*    opReg               reg number
*    pOperand            pointer to the operand to be filled in
*    pExtendedArea       pointer to the floating point context extended area
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG index;
    PXMMI128 Fp128;
    
    //
    // If location is REG, the register number is
    // encoded in the instruction
    //
    pOperand->OpLocation = OpLocation;
    if (pOperand->OpLocation == INV) {
        pOperand->Op.OperandValid = 0;
        return;
    }

    //
    // Change to the sclar form if it is a scalr instruction.
    //
    if ((OpLocation == XMMI) || (OpLocation == MMX) || (OpLocation == XMMI2) || OpLocation == XMMI_M32I) {
 
        if (fScalar) {
            if (OpLocation == MMX) {
                pOperand->OpLocation = REG;
                }
            }
        pOperand->OpReg = OpReg;

    } else {
        if ((fScalar) && (OpLocation != INV)) {
            if (OpLocation == M128_M32R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M128_M64R) {
                pOperand->OpLocation = M64R_64;
            }

            if (OpLocation == M64R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M64I) {
                pOperand->OpLocation = M32I;
            }
        }
    }


    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];

    //
    // Init to 0
    //
    for ( index=0; index < 4; index++ ) {   
        pOperand->Op.Value.Fp128Value.W[index] = 0;
    }

    //
    // Assume valid operand (this is almost always the case)
    //
    pOperand->Op.OperandValid = 1;

    //
    // Load up value from the context area.  We need to be careful about accessing
    // the value, make sure there is no compiler intermediate data type conversion
    // via X87 floating point instruction.  If there is, X87 floating point inst
    // can screw us up when encountering a bad input value.  Bad input value may
    // be changed by the processor due to the processor is executing a masked 
    // X87 floating point inst.
    //
    switch (pOperand->OpLocation) {

        case M128_M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M64R:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M64R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M64R_64:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case M64I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case XMMI:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;

        case XMMI2:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp64;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;
         
        case XMMI_M32I:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.U32Value = Fp128->u.ul[0];
             break;

        case MMX:
             X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             MmxArea = &X87Area->Mm[OpReg];
             pOperand->Op.Value.U64Value = MmxArea->Mmx.u.u64;
             break;

        case REG:
             pOperand->Op.Format = _FpFormatI32;
             switch (OpReg) {
             case 0x0:
                  pOperand->Op.Value.U32Value = pctxt->Eax;
                  break;
             case 0x1:
                  pOperand->Op.Value.U32Value = pctxt->Ecx;
                  break;
             case 0x2:
                  pOperand->Op.Value.U32Value = pctxt->Edx;
                  break;
             case 0x3:
                  pOperand->Op.Value.U32Value = pctxt->Ebx;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pOperand->Op.Value.U32Value = pctxt->Ebp;
                  break;
             case 0x6:
                  pOperand->Op.Value.U32Value = pctxt->Esi;
                  break;
             case 0x7:
                  pOperand->Op.Value.U32Value = pctxt->Edi;
                  break;
             }
        break;
    }

    return;

}


/***
* LoadImm8 - Pick up imm8 from the instruction stream
*
*Purpose:
*    Return the offset of imm8 from the beginning of the Instruction stream 
*    pointer.  This routine is not used.
*
*Entry:
*    Instr - pointer to the Opcode (after f3/0f)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

ULONG
LoadImm8(
    PXMMIINSTR Instr)

{

    PUCHAR pInstr;
    ULONG  Offset;

#ifdef _XMMI_DEBUG
    if (Console) return DebugImm8;
#endif //_XMMI_DEBUG

    //Assume 32-bit. pInstr points to the Opcode C2 after (f3/0f)
    pInstr = (PUCHAR) Instr;
    //Opcode, ModR/M
    Offset=2;
    //For Mod = 01, 10, 11
    if (Instr->Mod != 3) {
        //Notes #1 PPro 2-5
        if (Instr->RM == 4)  Offset=Offset+1; //SIB
        if (Instr->Mod == 0) Offset=Offset+0;
        if (Instr->Mod == 1) Offset=Offset+1;
        if (Instr->Mod == 2) Offset=Offset+4;
        //Notes #2 PPro 2-5
        if ((Instr->Mod == 0) && (Instr->RM == 5)) Offset=Offset+4; //SIB
        //Notes #3 PPro 2-5
        if ((Instr->Mod == 1) && (Instr->RM == 0)) Offset=Offset+1; //SIB
    }
    
    //imm8 
    return *(pInstr+Offset);

}

/***
* AdjustExceptionResult -  Adjust exception result returned from user's handler
*
*Purpose:
*    This routine is called after the exception is raised from the Emulation
*    the result is passed onto user's handler, and the user returns 
*    EXCEPTION_CONTINUE_EXECUTION.  Go ahead to adjust the result.
*
*Entry:
*   OriginalOperation - Original operation Opcode
*   XmmiEnv - Pointer to Emulation result
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv)


{

    // 
    //When the exception is raised, the user handler is invoked with the result.
    //If the user expects us to Adjust the result, user handler would have to
    //set the Result.OperandValid to 1.  From emulator's view point, the
    //Result.OperandValid is 0.
    //
    if (!XmmiEnv->Ieee->Result.OperandValid) return;
    if (XmmiEnv->Ieee->Result.Format != _FpCodeCompare) return;

    switch (OriginalOperation) {
        case OP_COMISS:
        case OP_UCOMISS:
        case OP_COMISD:
        case OP_UCOMISD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  // OF, SF, AF = 000, ZF, PF, CF = 100
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;
                  break;
             case _FpCompareGreater:
                  // OF, SF, AF = 000, ZF, PF, CF = 000
                  XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;
                  break;
             case _FpCompareLess:
                  // OF, SF, AF = 000, ZF, PF, CF = 001
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;
                  break;
             case _FpCompareUnordered:
                  // OF, SF, AF = 000, ZF, PF, CF = 111
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;
                  break;
             }
             break;

        case OP_CMPPS:
        case OP_CMPSS:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  }
                  break;
             }

        case OP_CMPPD:
        case OP_CMPSD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  }
                  break;
             }

             break;
    }

    return;

}

/***
* UpdateResult -  Update result information in the extended floating point context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*   pOperand Pointer to the result
*   pctxt    Pointer to the context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG OpReg;

    OpReg = pOperand->OpReg;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];

    switch (pOperand->OpLocation) {

        case M128_M32R:
        case M128_M64R:
        case M128_M32I:
             *(_FP128 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.Fp128Value;
             break;

        case M64R_64:
        case M64R:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32R:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case M64I:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32I:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case XMMI:
        case XMMI2:
        case XMMI_M32I:
             XmmiArea->Xmmi[OpReg].u.fp128 = pOperand->Op.Value.Fp128Value;
             break;

        case MMX:
             MmxArea = &X87Area->Mm[OpReg];
             MmxArea->Mmx.u.u64 = pOperand->Op.Value.U64Value;
             break;

        case REG:

             switch (OpReg) {
             case 0x0:
                  pctxt->Eax = pOperand->Op.Value.U32Value;
                  break;
             case 0x1:
                  pctxt->Ecx = pOperand->Op.Value.U32Value;
                  break;
             case 0x2:
                  pctxt->Edx = pOperand->Op.Value.U32Value;
                  break;
             case 0x3:
                  pctxt->Ebx = pOperand->Op.Value.U32Value;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pctxt->Ebp = pOperand->Op.Value.U32Value;
                  break;
             case 0x6:
                  pctxt->Esi = pOperand->Op.Value.U32Value;
                  break;
             case 0x7:
                  pctxt->Edi = pOperand->Op.Value.U32Value;
                  break;
             }

        case RS:
             pctxt->EFlags = EFlags;
        break;
    }
    
}

/***
* ValidateResult -  Validate the emulation result with the MXCSR
*
*Purpose:
*   We are about to dismiss the exception, perform validation to
*   see if the processor agrees with our Emulation
*
*Entry:
*   XmmiFpEnv - pointer to the data about the exception.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv)

{

    PXMMI_EXCEPTION_FLAGS IFlags;
    PXMMI_EXCEPTION_FLAGS OFlags;
    BOOLEAN Flag;

    Flag = FALSE;
    IFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->IFlags;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->OFlags;

/*    DPrint(XMMI_WARNING, ("Checking MXCSR Exception Flags\n"));  */
    if (IFlags->ie != OFlags->ie) {
/*        DPrint(XMMI_WARNING, ("ie: Processor %x, Emulator %x\n", IFlags->ie, OFlags->ie));  */
        Flag=TRUE;
    }

    if (IFlags->de != OFlags->de) {
/*        DPrint(XMMI_WARNING, ("de: Processor %x, Emulator %x\n", IFlags->de, OFlags->de)); */
        Flag=TRUE;
    }

    if (IFlags->ze != OFlags->ze) {
/*        DPrint(XMMI_WARNING, ("ze: Processor %x, Emulator %x\n", IFlags->ze, OFlags->ze));  */
        Flag=TRUE;
    }

    if (IFlags->oe != OFlags->oe) {
/*        DPrint(XMMI_WARNING, ("oe: Processor %x, Emulator %x\n", IFlags->oe, OFlags->oe));  */
        Flag=TRUE;
    }

    if (IFlags->ue != OFlags->ue) {
/*        DPrint(XMMI_WARNING, ("ue: Processor %x, Emulator %x\n", IFlags->ue, OFlags->ue));  */
        Flag=TRUE;
    }

    if (IFlags->pe != OFlags->pe) {
/*        DPrint(XMMI_WARNING, ("pe: Processor %x, Emulator %x\n", IFlags->pe, OFlags->pe));  */
        Flag=TRUE;
    }

    if (!Flag) {
/*        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags Ok, Prc:0x%x, Em:0x%x\n\n",  */
/*            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  */
    }

    if (Flag) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n\n", 
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
        PRINTF(("WARNING: Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n",   
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
#else
        _ASSERT(0);
#endif
    }

    return Flag;

}


/*
 *  mod r/m byte decoder support
 */

/*-----------------------------------------------------------------
 *  Routine:  ax0
 */
ULONG
ax0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax0\n"));
    *DataOffset = GET_REG(Eax);
    return 0;

} /* End ax0(). */


/*-----------------------------------------------------------------
 *  Routine:  ax8
 */
ULONG
ax8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax8\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_UBYTE(eip);
    return 1;

} /* End ax8(). */


/*-----------------------------------------------------------------
 *  Routine:  ax32
 */
ULONG
ax32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax32\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_ULONG(eip);
    return 4;

} /* End ax32(). */


/*-----------------------------------------------------------------
 *  Routine:  cx0
 */
ULONG
cx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("cx0\n"));
    *DataOffset = GET_REG(Ecx);
    return 0;

} /* End cx0(). */


/*-----------------------------------------------------------------
 *  Routine:  cx8
 */
ULONG
cx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{   
    PRINTF(("cx8\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_UBYTE(eip);
    return 1;

} /* End cx8(). */


/*-----------------------------------------------------------------
 *  Routine:  cx32
 */
ULONG
cx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    
    PRINTF(("cx32\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_ULONG(eip);
    return 4;

} /* End cx32(). */


/*-----------------------------------------------------------------
 *  Routine:  dx0
 */
ULONG
dx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx0\n"));
    *DataOffset = GET_REG(Edx);
    return 0;

} /* End dx0(). */


/*-----------------------------------------------------------------
 *  Routine:  dx8
 */
ULONG
dx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx8\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_UBYTE(eip);
    return 1;

} /* End dx8(). */


/*-----------------------------------------------------------------
 *  Routine:  dx32
 */
ULONG
dx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx32\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_ULONG(eip);
    return 4;

} /* End dx32(). */

/*-----------------------------------------------------------------
 *  Routine:  bx0
 */
ULONG
bx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx0\n"));
    *DataOffset = GET_REG(Ebx);
    return 0;

} /* End bx0(). */


/*-----------------------------------------------------------------
 *  Routine:  bx8
 */
ULONG
bx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx8\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_UBYTE(eip);
    return 1;

} /* End bx8(). */


/*-----------------------------------------------------------------
 *  Routine:  bx32
 */
ULONG
bx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx32\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_ULONG(eip);
    return 4;

} /* End bx32(). */


/*
 *  A "mod r/m" byte indicates an s-i-b byte is present.  Assume the register
 *  from the mod r/m byte is not relevant (does not participate in a memory
 *  reference) and calculate the EA based on the s-i-b byte.
 */
/* SS  | Index | Base */
/* 7-6 |  5-3  |  2-0 */
/* Base: EAX ECX EDX EBX ESP EBP ESI EDI */
/*       000 001 010 011 100 101 110 111 */
/* SS: Index:    
/* 00   000      [EAX]         
/*      001      [ECX]         
/*      010      [EDX]         
/*      011      [EBX]         
/*      100      none         
/*      101      [EBP]        
/*      110      [ESI]         
/*      111      [EDI]         
/* 01   000      [EAX*2]    
/*      001      [ECX*2]    
/*      010      [EDX*2]    
/*      011      [EBX*2]    
/*      100      none     
/*      101      [EBP*2]    
/*      110      [ESI*2]   
/*      111      [EDI*2]   
/* 10   000      [EAX*4]    
/*      001      [ECX*4]    
/*      010      [EDX*4]    
/*      011      [EBX*4]    
/*      100      none     
/*      101      [EBP*4]    
/*      110      [ESI*4]   
/*      111      [EDI*4]   
/* 11   000      [EAX*8]    
/*      001      [ECX*8]    
/*      010      [EDX*8]    
/*      011      [EBX*8]    
/*      100      none     
/*      101      [EBP*8]    
/*      110      [ESI*8]   
/*      111      [EDI*8]   
/*Note: Mod=00, no base, Mod=01/10, base is EBP

/*-----------------------------------------------------------------
 *  Routine:  sib0
 */
ULONG
sib0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib0\n"));

    //(Base+Index*Scale)+disp0
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        //index=GET_REG(index), upon return, index has the value of the register
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    //mod=00, there is no base.
    if (sib == EBP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + index*scale;
        return 5;
    }

    if (sib == ESP_INDEX) {
        *DataOffset = GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += index*scale;
    }
    return 1;

} /* End sib0(). */


/*-----------------------------------------------------------------
 *  Routine:  sib8
 */
ULONG
sib8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib8\n"));

    //(Base+Index*Scale)+disp8
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_UBYTE(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_UBYTE(eip + 1) + index*scale;
    }
    return 2;

} /* End sib8(). */


/*-----------------------------------------------------------------
 *  Routine:  sib32
 */
ULONG
sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib32\n"));

    //(Base+Index*Scale)+disp32
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    index =((sib >> 3)&0x7);
    //Get index: 000-111
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_ULONG(eip + 1) + index*scale;
    }
    return 5;

} /* End sib32(). */

/*-----------------------------------------------------------------
 *  Routine:  d32
 */
ULONG
d32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("d32\n"));

    *DataOffset = GET_USER_ULONG(eip);
    return 4;

} /* End d32(). */

/*-----------------------------------------------------------------
 *  Routine:  bp8
 */
ULONG
bp8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp8%x\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_UBYTE(eip);
    return 1;

} /* End bp8(). */


/*-----------------------------------------------------------------
 *  Routine:  bp32
 */
ULONG
bp32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp32\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_ULONG(eip);
    return 4;

} /* End bp32(). */

/*-----------------------------------------------------------------
 *  Routine:  si0
 */
ULONG
si0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si0\n"));

    *DataOffset = GET_REG(Esi);
    return 0;

} /* End si0(). */


/*-----------------------------------------------------------------
 *  Routine:  si8
 */
ULONG
si8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si8\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_UBYTE(eip);
    return 1;

} /* End si8(). */


/*-----------------------------------------------------------------
 *  Routine:  si32
 */
ULONG
si32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si32\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_ULONG(eip);
    return 4;

} /* End si32(). */

/*-----------------------------------------------------------------
 *  Routine:  di0
 */
ULONG
di0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di0\n"));

    *DataOffset = GET_REG(Edi);
    return 0;

} /* End di0(). */


/*-----------------------------------------------------------------
 *  Routine:  di8
 */
ULONG
di8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di8%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_UBYTE(eip);
    return 1;

} /* End di8(). */

/*-----------------------------------------------------------------
 *  Routine:  di32
 */
ULONG
di32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di32%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_ULONG(eip);
    return 4;

} /* End di32(). */


/*-----------------------------------------------------------------
 *  Routine:  reg
 */
ULONG
reg( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("reg, should never be called\n"));

    return 0;

} /* End reg(). */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\disp_pentium4.inc ===
.XMM

	CODESEG

	ALIGN	4

ifndef XBOX
	extrn	__use_sse2_mathfcns:dword
endif ; XBOX

	ifdef	_FUNC_DEF_EXTERN_
	extrn	_FUNC_DEF_:proc
	endif

ifndef XBOX
	ifdef	_FUNC_P4_EXTERN_
	extrn	_FUNC_P4_:proc
	endif
endif ; XBOX

	PUBLIC	_FUNC_

_FUNC_	PROC NEAR

ifdef XBOX

    jmp _FUNC_DEF_

else

 	cmp	DWORD PTR __use_sse2_mathfcns, 0
 	je	_FUNC_DEF_	; not P4 go to MS code

	sub	esp, 8
	stmxcsr	dword ptr [esp+4]
	mov	eax, dword ptr [esp+4]
	and	eax, 01f80h	;mscxr mask
	cmp	eax, 01f80h
	jne	short jnedef	;if unmasked, we vector off to the MS code 

	;check if any x87 FP exceptions are unmasked
	fnstcw	word ptr [esp]
	mov	ax, word ptr [esp]
	and	ax, 07fh
	cmp	ax, 07fh
jnedef:	lea	esp, [esp+8]	;(release stack, preserve CC)
	jne	_FUNC_DEF_	;if unmasked, we vector off to the MS code 

	jmp	_FUNC_P4_	; ok to go to Intel code

endif ; XBOX

_FUNC_	ENDP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\floor_pentium4.asm ===
; file: floor_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double floor (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The floor functions return the largest integer value not greater than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  floor(NaN) = that NaN
;  floor(INF) = that INF
;  floor(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<floor>
_FUNC_DEF_ equ	<_floor_default>
_FUNC_P4_  equ	<_floor_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One     DQ 03ff0000000000000H,03ff0000000000000H
_Bns     DQ 00000000000000433H,00000000000000433H
_NegOne  DQ 0bff0000000000000H,04330000000000000H
_NegZero DQ 08000000000000000H,08000000000000000H
_S       DQ 000000000000007ffH,00000000000000000H

      codeseg
      ALIGN 16

; double floor (double x);

; Stack frame locations

floor_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>  

PUBLIC _floor_pentium4
_floor_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [floor_x]          ; X
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)    ; sign(X) | exp(X) in XMM reg
    movd      eax, xmm0                          ; sign(X) | exp(X) in eax reg
    andpd     xmm0, XMMWORD PTR _S               ; exp(X) (+3ff)
    psubd     xmm2, xmm0                         ; exp(X)
    psrlq     xmm1, xmm2                         ; truncate the fraction (shift right)

    test      eax, 0800h                         ;
    jne       SHORT negat                        ; if (X<0.0) goto negat
    cmp       eax, 03ffh                         ;**** POSITIVE X *****
    jl        SHORT ret_zero                     ; if (X<1.0) return zero
    psllq     xmm1, xmm2                         ; truncate the fraction (integer part)
    cmp       eax, 0432h                         ; if X is integer, return X
    jg        SHORT return_x
    movq      QWORD PTR [floor_x], xmm1          ; save integer part
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1005
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

negat:        ; **** NEGATIVE X ****

    movq      xmm0, QWORD PTR [floor_x]          ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 1                      ; if X<integer part, form Mask

    cmp       eax, 0bffh                         ; if X > -1.0 return -1.0
    jl        SHORT ret_neg_one                  ;
    cmp       eax, 0c32h                         ; if X is integer, return X
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ; Mask & One
    subsd     xmm1, xmm0                         ; if X<integer part,
    movq      QWORD PTR [floor_x], xmm1          ;        return (int.part-1.0)
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

ret_zero:

    fldz                                         ;
    ret                                          ;

ret_neg_one:

    cmppd     xmm3, XMMWORD PTR _NegZero, 1      ; case for X = Negative Zero
    orpd      xmm3, XMMWORD PTR _NegZero         ; return X, if X == Negative Zero
    andpd     xmm3, XMMWORD PTR _NegOne          ; if X==NegZero, xmm3=0.0
    movq      QWORD PTR [floor_x], xmm3          ;
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

_floor_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\frnd.c ===
/***
*frnd.c -
*
*   Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*
*Revision History:
*
*   10-20-91  GDP   written
*   09-05-94  SKS   Change #ifdef i386 to #ifdef _M_IX86
*/

/***
*double _frnd(double x) - round to integer
*
*Purpose:
*   Round to integer according to the current rounding mode.
*   NaN's or infinities are NOT handled
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/


double _frnd(double x)
{
    double result;

#if defined _M_IX86 || defined _X86SEG_
    _asm {
	fld x
	frndint
	fstp result
    }
#else
    #error Only 386 platform supported
#endif

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clrfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }
    return status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _ctrlfp(unsigned int newctrl, unsigned int _mask)
{
    short	oldCw;
    short	newCw;

    _asm {
	fstcw	oldCw
    }
    newCw = (short) ((newctrl & _mask) | (oldCw & ~_mask));
    
    _asm {
	fldcw	newCw
    }
    return oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static unsigned long over[3] = { 0x0, 0x80000000, 0x4410 };
static unsigned long under[3] = { 0x1, 0x80000000, 0x3000 };


void _set_statfp(unsigned int sw)
{
    int itmp;
    double tmp;

    if (sw & ISW_INVALID) {
	_asm {
	    fld tbyte ptr over
	    fistp   itmp
	    fwait
	}
    }
    if (sw & ISW_OVERFLOW) {   // will also trigger precision
	_asm {
	    fstsw ax
	    fld tbyte ptr over
	    fstp    tmp
	    fwait
	    fstsw  ax
	}
    }
    if (sw & ISW_UNDERFLOW) {  // will also trigger precision
	_asm {
	    fld tbyte ptr under
	    fstp tmp
	    fwait
	}
    }
    if (sw & ISW_ZERODIVIDE) {
	_asm {
	    fldz
	    fld1
	    fdivrp  st(1), st
	    fstp st(0)
	    fwait
	}
    }
    if (sw & ISW_INEXACT) {
	_asm {
	    fldpi
	    fstp tmp
	    fwait
	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\fsqrt.c ===
/***
*fsqrt.c - square root helper
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Square root helper routine to be used with the i386
*
*Revision History:
*   10-20-91	GDP	written
*
*******************************************************************************/

double _fsqrt(double x)
{
    double result;
    _asm{
	fld	x
	fsqrt
	fstp	result
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ftol2.asm ===
page    ,132
        title   ftol2    - truncate TOS to 32-bit integer
;*** 
;ftol2.asm - truncate TOS to 32-bit integer
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   01/26/01    Phil Lucido
;               Optimized version from Intel to avoid Pentium FLDCW stalls.
;
;*******************************************************************************


.xlist
        include i386\cruntime.inc
.list

        CODESEG

        public  _ftol2
_ftol2  proc

tmp1    equ     <[esp+24]>
tmp2    equ     <[esp+16]>
tmp3    equ     <[esp]>

        push    ebp
        mov     ebp,esp
        sub     esp,32
        and     esp,0fffffff0h

        fld     st(0)           ; duplicate FPU stack top
        fst     dword ptr tmp1  ; store single to get the sign
        fistp   qword ptr tmp2  ; sto as int
        fild    qword ptr tmp2  ; ld int, cvt to fp
        mov     edx,tmp1        ; get the sign (not fwd problem)
        mov     eax,tmp2        ; low dword of integer
        test    eax,eax
        je      integer_QnaN_or_zero

   arg_is_not_integer_QnaN:
        fsubp   st(1),st        ; TOS=d-round(d),
                                ; { st(1)=st(1)-st & pop ST}
        test    edx,edx         ; whats sign of integer
        jns     positive        ; number is negative
        fstp    dword ptr tmp3  ; result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        xor     ecx,80000000h
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        adc     eax,0           ; inc eax (add CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        adc     edx,0
        jmp     localexit       

   positive:
        fstp    dword ptr tmp3  ; 17-18 result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        sbb     eax,0           ; dec eax (subtract CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        sbb     edx,0
        jmp     localexit      

   integer_QnaN_or_zero: ; load the upper 32 bits of the converted integer
        mov     edx,tmp2+4      ; high dword of integer (fwd problem)
        test    edx,7fffffffh
        jnz     arg_is_not_integer_QnaN
        fstp    dword ptr tmp1
        fstp    dword ptr tmp1

   localexit:
        leave
        ret

_ftol2  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
	include i386\cruntime.inc
.list

	CODESEG

	public	_ftol
_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*
*/

#include <trans.h>
#include <float.h>

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);



/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }

    return _abstract_sw(status);
}



/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    short	oldCw;
    short	newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
	fstcw	oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);
    
    _asm {
	fldcw	newCw
    }
    return newabs;
}					/* _controlfp() */


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
	abstr |= _PC_64;
	break;
    case IPC_53:
	abstr |= _PC_53;
	break;
    case IPC_24:
	abstr |= _PC_24;
	break;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0x1002;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
	cw |= IPC_64;
	break;
    case _PC_53:
	cw |= IPC_53;
	break;
    case _PC_24:
	cw |= IPC_24;
	break;
    }


    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _EM_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _EM_INEXACT;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ieee87.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*       04-01-02  GDP   Rewritten to use abstract control and status words
*       10-30-92  GDP   _fpreset now resets saved fp context if called from a
*                       signal handler.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       04-11-95  JWM   _fpreset() now resets default precision.
*       05-10-96  BWT   Fix POSIX build.
*
*/

#include <trans.h>
#include <float.h>
#include <windows.h>
#include <signal.h>

extern void _setdefaultprecision();

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);


/***
* _statusfp() -
*
*Purpose:
*       return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short   status;

    _asm {
        fstsw   status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*       return abstract status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short   status;

    _asm {
        fnstsw  status
        fnclex
    }

    return _abstract_sw(status);
}



/***    _control87
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    short   oldCw;
    short   newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
        fstcw   oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);

    _asm {
        fldcw   newCw
    }
    return newabs;
}                   /* _controlfp() */


/***    _controlfp
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       cannot change denormal mask (ignores _EM_DENORMAL)
*       This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}




/***
* _fpreset() - reset fp system
*
*Purpose:
*       reset fp environment to the default state
*       Also reset saved fp environment if invoked from a user's
*       signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
#define TAG_ALL_EMPTY ((unsigned int) 0xffff);

void _fpreset()
{
#ifndef _POSIX_
    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;
#endif

    _asm {
        fninit
    }
    _setdefaultprecision();     // reset precision, usually down to 53 bits
#ifndef _POSIX_
    if (excptrs &&
        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

        FLOATING_SAVE_AREA *pFloatSave = &excptrs->ContextRecord->FloatSave;
        pFloatSave->StatusWord = 0;
        pFloatSave->TagWord = TAG_ALL_EMPTY;
    }
#endif
}







/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
        abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
        abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
        abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
        abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
        abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
        abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        abstr |= _RC_NEAR;
        break;
    case IRC_UP:
        abstr |= _RC_UP;
        break;
    case IRC_DOWN:
        abstr |= _RC_DOWN;
        break;
    case IRC_CHOP:
        abstr |= _RC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
        abstr |= _PC_64;
        break;
    case IPC_53:
        abstr |= _PC_53;
        break;
    case IPC_24:
        abstr |= _PC_24;
        break;
    }


    //
    // Infinity control (bit can be programmed but has no effect)
    //

    if (cw & IMCW_IC) {
        abstr |= _IC_AFFINE;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:  abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
        cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
        cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
        cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
        cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
        cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
        cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
        cw |= IRC_NEAR;
        break;
    case _RC_UP:
        cw |= IRC_UP;
        break;
    case _RC_DOWN:
        cw |= IRC_DOWN;
        break;
    case _RC_CHOP:
        cw |= IRC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
        cw |= IPC_64;
        break;
    case _PC_53:
        cw |= IPC_53;
        break;
    case _PC_24:
        cw |= IPC_24;
        break;
    }


    //
    // Set Infinity mode
    //

    if (abstr & _MCW_IC) {
        cw |= IIC_AFFINE;
    }

    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
        abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
        abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
        abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
        abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
        abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
        abstr |= _SW_DENORMAL;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\ldsplit.asm ===
page	,132
	title	ldsplit	 - split long double
;*** 
;ldsplit.asm - split long double into two doubles
;
;	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Helper for handling 10byte long double quantities if there is no
;   compiler support.
;
;Revision History:
;
;   04/21/92	GDP	written
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

.data

labelB TagTable
			; C2 C1 C0 C3	 Meaning
	db	2 * 4	;  0  0  0  0  +Unnormal=>   NAN
	db	1 * 4	;  0  0  0  1  +Zero	=>   Zero
	db	2 * 4	;  0  0  1  0  +NAN	=>   NAN
	db	2 * 4	;  0  0  1  1	Empty	=>   NAN
	db	2 * 4	;  0  1  0  0  -Unnormal=>   NAN
	db	1 * 4	;  0  1  0  1  -Zero	=>   Zero
	db	2 * 4	;  0  1  1  0  -NAN	=>   NAN
	db	2 * 4	;  0  1  1  1	Empty	=>   NAN
	db	0 * 4	;  1  0  0  0  +Normal	=>   Valid
	db	4 * 4	;  1  0  0  1  +Denormal=>   Denormal
	db	3 * 4	;  1  0  1  0  +Infinity=>   Infinity
	db	2 * 4	;  1  0  1  1	Empty	=>   NAN
	db	0 * 4	;  1  1  0  0  -Normal	=>   Valid
	db	4 * 4	;  1  1  0  1  -Denormal=>   Zero
	db	3 * 4	;  1  1  1  0  -Infinity=>   Infinity
	db	2 * 4	;  1  1  1  1	Empty	=>   NAN

; factor = 2^64
staticQ factor,	      043F0000000000000R

LDBIAS		equ	3fffh
DBIAS		equ	3ffh
MAX_BIASED_DEXP equ	7feh

CODESEG



table:
	dd	valid
	dd	zero
	dd	nan
	dd	inf
	dd	denorm



;***
;int _ldsplit(pld, pd1, pd2) - split long double
;
;Purpose:
;   partition a long double quantity ld into two double quantities
;   d1, d2 and an integer scaling factror s. The mantissa of d1 has
;   the high order word of the mantissa of ld. Respectively, the
;   mantissa of d2 has the low order word of the mantissa of ld.
;   The following relation should be satisfied:
;
;	    ld == ((long double)d1 + (long double)d2) * 2^s
;
;   s is 0, unless d1 or d2 cannot be expressed as normalized
;   doubles; in that case s != 0, and .5 <= d1 < 1
;
;
;Entry:
;   pld     pointer to the long double argument
;   pd1     pointer to d1
;   pd2     pointer to d2
;
;Exit:
;   *pd1, *pd2 are updated
;   return value is equal to s
;
;
;Exceptions:
;   This function should raise no IEEE exceptions.
;   special cases:
;     ld is QNAN or SNAN: d1 = QNAN, d2 = 0, s = 0
;     ls is INF:	  d1 = INF, d2 = 0, s = 0
;
;
;******************************************************************************/


_ldsplit proc	uses ebx edx edi, pld:dword, pd1:dword, pd2:dword
	local	ld:tbyte
	local	exp_adj:dword
	local	retvalue:dword
	local	denorm_adj:dword

	mov	[retvalue], 0		; default return value
	mov	[denorm_adj], 0
	mov	ebx, [pld]
	fld	tbyte ptr [ebx]
	fxam
	fstsw	ax
	fstp	[ld]			; store to local area
	shl	ah, 1
	sar	ah, 1
	rol	ah, 1
	and	ah, 0fh
	mov	al, ah
	mov	ebx, dataoffset TagTable	; Prepare for XLAT
	xlat
	movzx	eax, al
	mov	ebx, OFFSET table
	add	ebx, eax

	mov	edx, pd1	    ; edx points to the high order double
	mov	edi, pd2	    ; edi points to the low order double

	jmp	[ebx]

lab valid
	; have a valid normalized non-special long double

	mov	eax, dword ptr [ld]
	or	eax, eax
	jz	d2zero

				    ; compute mantissa an exponent for d2
	mov	[exp_adj], 31	    ; adjustment to be subtracted from exp of *pd2

	;
	; compute mantissa of d2
	; shift left low order word of ld, until a '1' is hit
	;

	cmp	eax, 0ffffh
	ja	shl16done
	sal	eax, 16
	add	[exp_adj], 16

lab shl16done
	cmp	eax, 0ffffffh
	ja	shl8done
	sal	eax, 8
	add	[exp_adj], 8

lab shl8done
lab shiftloop
	inc	[exp_adj]
	sal	eax, 1
	jnc	shiftloop

	; now eax contains the mantissa for d2
	; exp_adj is the difference of the
	; exponents of d1 and d2
	; exp_adj should be in the range
	;	  32 <= exp_adj <= 63
	; By convention, if exp_adj is 0 then
	; d2 is zero

lab setd2man
	mov	dword ptr [edi+4], 0
	shld	dword ptr [edi+4], eax, 20
	shl	eax, 20
	mov	[edi], eax

	;
	; set mantissa of d1
	;

lab setd1man
	mov	eax, dword ptr [ld+4]
	sal	eax, 1			    ; get rid of explicit bit
	mov	dword ptr [edx+4], 0
	shld	dword ptr [edx+4], eax, 20
	shl	eax, 20
	mov	[edx], eax

				    ; check if exponent is in range
	mov	ax, word ptr [ld+8]

	and	ax, 07fffh		; clear sign bit
	movzx	eax, ax

	sub	eax, LDBIAS - DBIAS

	cmp	eax, MAX_BIASED_DEXP
	ja	expoutofrange


	cmp	eax, [exp_adj]
	jb	expoutofrange


	;
	; set exponent of d1
	;

lab setexp1
	mov	ebx, eax		; save exp value
	shl	eax, 20
	or	dword ptr [edx+4], eax


	cmp	[exp_adj], 0
	je	exp2zero
	sub	ebx, [exp_adj]
	je	exp2zero
lab setexp2
	shl	ebx, 20
	or	dword ptr [edi+4], ebx
	mov	[retvalue], 0


lab setsign				; set correct signs and return
					; at this point eax contains
					; the return value
	mov	bx, word ptr [ld+8]
	and	bx, 1 SHL 15		; get sign

	or	[edi+6], bx		; set sign bit
	or	[edx+6], bx		; set sign bit

	mov	eax, [retvalue]
	add	eax, [denorm_adj]
	ret


lab d2zero
	mov	[exp_adj], 0
	jmp	setd2man

lab exp2zero
	mov	ebx, 0
	jmp	setexp2



lab expoutofrange
	mov	ebx, DBIAS
	mov	ecx, ebx
	sub	ecx, [exp_adj]

	shl	ebx, 20
	or	dword ptr [edx+4], ebx

	shl	ecx, 20
	or	dword ptr [edi+4], ecx

	sub	eax, DBIAS		; unbias exp
	mov	[retvalue], eax		; this is the return value
	jmp	short setsign


lab zero
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 0
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab nan
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff80000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab inf
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff00000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab denorm

	;
	; We have a long double denormal
	; so we know for sure that this is out of the double
	; precision range, and the return value of _ldsplit
	; should be non-zero.
	; Multiply the denormal by 2^64, then adjust the
	; return value by subtracting 64
	;


	; this assumes denormal exception masked
	fld	[ld]
	fmul	[factor]
	fstp	[ld]
	mov	[denorm_adj], 64
	jmp	valid



_ldsplit endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\huge.asm ===
page	,132
	title   HUGE    - HUGE value
;*** 
;huge.asm - defines HUGE
;
;	Copyright (c) 1984-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines HUGE
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   12/21/84	Greg Whitten
;		add assumes so that C can find variable
;
;   09/23/87	Barry C. McCord
;		add _matherr_flag for the sake of the
;		C floating-point intrinsic functions
;
;   08/29/88	Bill Johinston
;		386 version
;
;   08/27/91	JeffRob
;		ANSI naming
;
;   09/06/91	GeorgioP
;		define HUGE as positive infinity
;
;   09/06/91	GeorgioP
;		define _HUGE_dll
;
;   04/05/93	SteveSa
;		undefine _HUGE_dll
;   10/14/93	GregF
;		Restored _HUGE_DLL for _NTSDK
;
;*******************************************************************************


.xlist
	include i386\cruntime.inc
	include i386\mrt386.inc
.list

	.data

ifdef	_NTSDK
ifdef	CRTDLL
globalQ _HUGE_dll, 7ff0000000000000R
else
globalQ _HUGE, 7ff0000000000000R
endif
else
globalQ _HUGE, 7ff0000000000000R
endif

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\genexcep.asm ===
.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

_exception struc        ; struct _exception {
typ     dd      ?       ;   int type;           /* exception type - see below */
nam     dd      ?       ;   char *name;         /* name of function where error occured */
arg1    dq      ?       ;   double arg1;        /* first argument to function */
arg2    dq      ?       ;   double arg2;        /* second argument (if any) to function */
retval  dq      ?       ;   double retval;      /* value to be returned by function */
_exception ends         ; }

Except_struct_size      equ  ((size _exception) + ISIZE - 1) and (not (ISIZE-1))

Except_struct           equ  [ebp-Except_struct_size]

        CODESEG

extrn        _87except:proc

;***********************************************************
;
;                _startTwoArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;
; Note:
;   we could use this procedure instead of _startOneArgErrorHandling,
;   but not always we can assume that there is something on stack below param1
;

_startTwoArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword,
        param2:qword

        local        arg_to_except87:_exception

; store second argument to _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
        mov     eax,dword ptr [param2]        ; load arg2
        mov     dword ptr [arg_to_except87.arg2],eax
        mov     eax,dword ptr [param2+4]
        mov     dword ptr [arg_to_except87.arg2+4],eax
        jmp     _ContinueErrorHandling
_startTwoArgErrorHandling endp


;***********************************************************
;
;                _startOneArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;

_startOneArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword

        local        arg_to_except87:_exception

; prepare _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
_ContinueErrorHandling        label        proc
        fstp    [arg_to_except87.retval]      ; store return value
        mov     [arg_to_except87.nam],ecx     ; pointer to function name
        mov     eax,dword ptr [param1]        ; load arg1
        mov     ecx,dword ptr [param1+4]
        mov     dword ptr [arg_to_except87.arg1],eax
        mov     dword ptr [arg_to_except87.arg1+4],ecx

; push on stack args for _87except()
        lea     eax,[savCW]                   ; load control word
        lea     ecx,arg_to_except87
        push    eax                           ; &(CW)
        push    ecx                           ; &(_exception structure)
        push    edx                           ; function number
        call    _87except
        add     esp,12                        ; clear arguments if _cdecl
        fld     [arg_to_except87.retval]      ; this assumes that user
                                              ; does not want to return a
                                              ; signaling NaN
; Now it's time to restore saved CW
        cmp     word ptr[savCW],default_CW
        je      CW_is_restored                ; it's usualy taken
        fldcw   word ptr[savCW]
CW_is_restored:
        ret                                   ; _cdecl return

_startOneArgErrorHandling        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\libm_error.c ===
//     
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, James
// Edwards, and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version.
// 2/12/01: Updated to be NT double precision specific.

#include <errno.h>
#include <stdio.h>
#include "libm_support.h"

/************************************************************/
/* matherrX function pointers and setusermatherrX functions */
/************************************************************/
int (*_pmatherr)(struct EXC_DECL_D*) = MATHERR_D;

/***********************************************/
/* error-handling function, libm_error_support */
/***********************************************/
void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
{

struct _exception exc;

const char double_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F}; 
const char double_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F};
const char double_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char double_neg_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF}; 
const char double_neg_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF};
const char double_neg_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

#define RETVAL_HUGE_VALD *(double *)retval = *(double *) double_inf
#define RETVAL_NEG_HUGE_VALD *(double *)retval = *(double *) double_neg_inf
#define RETVAL_HUGED *(double *)retval = (double) *(float *)float_huge
#define RETVAL_NEG_HUGED *(double *)retval = (double) *(float *) float_neg_huge 
#define RETVAL_ZEROD *(double *)retval = *(double *)double_zero 
#define RETVAL_NEG_ZEROD *(double *)retval = *(double *)double_neg_zero 
#define RETVAL_ONED *(double *)retval = 1.0 

#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!_pmatherr(&exc))

#define NAMED exc.name  

//
// These should work OK for MS because they are ints -
// leading underbars are not necessary.
//

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6

#define SINGD exc.type = SING
#define DOMAIND exc.type = DOMAIN 
#define OVERFLOWD exc.type = OVERFLOW 
#define UNDERFLOWD exc.type = UNDERFLOW 
#define TLOSSD exc.type = TLOSS 

#define INPUT_XD (exc.arg1=*(double*)arg1)
#define INPUT_YD (exc.arg1=*(double*)arg2)
#define INPUT_RESD (*(double *)retval)

#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr) 
#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)

  switch(input_tag)
  {
  case log_zero:
    /* log(0) */
    {
       SINGD; NAMED="log"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log_negative:
    /* log(x < 0) */
    {
       DOMAIND; NAMED="log";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    } 
  case log10_zero:
    /* log10(0) */
    {
       SINGD; NAMED="log10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log10_negative:
    /* log10(x < 0) */
    {
       DOMAIND; NAMED="log10";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_overflow:
    /* exp overflow */
    {
       OVERFLOWD; NAMED="exp";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       UNDERFLOWD; NAMED="exp"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       DOMAIND; NAMED="pow";
       RETVAL_ONED;
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       OVERFLOWD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       UNDERFLOWD; NAMED = "pow"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       SINGD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       DOMAIND; NAMED = "pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case pow_nan_to_zero:
    /* pow(NaN,0.0) */
    /* Special Error */
    {
       DOMAIND; NAMED = "pow"; INPUT_XD; INPUT_YD;
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log2_zero:
    /* log2(0) */
    {
       SINGD; NAMED="log2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log2_negative:
    /* log2(negative) */
    {
       DOMAIND; NAMED="log2";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_underflow:
    /* exp2 underflow */
    {
       UNDERFLOWD; NAMED="exp2"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_overflow:
    /* exp2 overflow */
    {
       OVERFLOWD; NAMED="exp2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp10_overflow:
    /* exp10 overflow */
    {
       OVERFLOWD; NAMED="exp10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log_nan:
    /* log(NaN) */
    {
       DOMAIND; NAMED="log";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case log10_nan:
    /* log10(NaN) */
    {
       DOMAIND; NAMED="log10";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_nan:
    /* exp(NaN) */
    {
       DOMAIND; NAMED="exp";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case atan_nan:
    /* atan(NaN) */
    {
       DOMAIND; NAMED="atan";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case ceil_nan:
    /* ceil(NaN) */
    {
       DOMAIND; NAMED="ceil";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case floor_nan:
    /* floor(NaN) */
    {
       DOMAIND; NAMED="floor";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_nan:
    /* pow(NaN,*) or pow(*,NaN) */
    {
       DOMAIND; NAMED="pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case modf_nan:
    /* modf(NaN) */
    {
       DOMAIND; NAMED="modf";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  }
  return;
  }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\libm_support.h ===
//  
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, 
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

typedef enum
{
  logl_zero=0,   logl_negative,                  /*  0,  1 */
  log_zero,      log_negative,                   /*  2,  3 */
  logf_zero,     logf_negative,                  /*  4,  5 */
  log10l_zero,   log10l_negative,                /*  6,  7 */
  log10_zero,    log10_negative,                 /*  8,  9 */
  log10f_zero,   log10f_negative,                /* 10, 11 */
  expl_overflow, expl_underflow,                 /* 12, 13 */
  exp_overflow,  exp_underflow,                  /* 14, 15 */
  expf_overflow, expf_underflow,                 /* 16, 17 */
  powl_overflow, powl_underflow,                 /* 18, 19 */
  powl_zero_to_zero,                             /* 20     */
  powl_zero_to_negative,                         /* 21     */
  powl_neg_to_non_integer,                       /* 22     */
  powl_nan_to_zero,                              /* 23     */
  pow_overflow,  pow_underflow,                  /* 24, 25 */
  pow_zero_to_zero,                              /* 26     */ 
  pow_zero_to_negative,                          /* 27     */
  pow_neg_to_non_integer,                        /* 28     */
  pow_nan_to_zero,                               /* 29     */
  powf_overflow, powf_underflow,                 /* 30, 31 */
  powf_zero_to_zero,                             /* 32     */
  powf_zero_to_negative,                         /* 33     */ 
  powf_neg_to_non_integer,                       /* 34     */ 
  powf_nan_to_zero,                              /* 35     */
  atan2l_zero,                                   /* 36     */
  atan2_zero,                                    /* 37     */
  atan2f_zero,                                   /* 38     */
  expm1l_overflow,                               /* 39     */
  expm1l_underflow,                              /* 40     */
  expm1_overflow,                                /* 41     */
  expm1_underflow,                               /* 42     */
  expm1f_overflow,                               /* 43     */
  expm1f_underflow,                              /* 44     */
  hypotl_overflow,                               /* 45     */
  hypot_overflow,                                /* 46     */
  hypotf_overflow,                               /* 47     */
  sqrtl_negative,                                /* 48     */
  sqrt_negative,                                 /* 49     */
  sqrtf_negative,                                /* 50     */
  scalbl_overflow, scalbl_underflow,             /* 51,52  */
  scalb_overflow,  scalb_underflow,              /* 53,54  */
  scalbf_overflow, scalbf_underflow,             /* 55,56  */
  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */ 
  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */ 
  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */ 
  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
  j0l_gt_loss,                                   /* 93 */ 
  j0_gt_loss,                                    /* 94 */
  j0f_gt_loss,                                   /* 95 */
  j1l_gt_loss,                                   /* 96 */
  j1_gt_loss,                                    /* 97 */
  j1f_gt_loss,                                   /* 98 */
  jnl_gt_loss,                                   /* 99 */
  jn_gt_loss,                                    /* 100 */
  jnf_gt_loss,                                   /* 101 */
  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */   
  fmodl_by_zero,                                 /* 120 */
  fmod_by_zero,                                  /* 121 */
  fmodf_by_zero,                                 /* 122 */
  remainderl_by_zero,                            /* 123 */
  remainder_by_zero,                             /* 124 */
  remainderf_by_zero,                            /* 125 */
  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
  acoshl_lt_one,                                 /* 135 */
  acosh_lt_one,                                  /* 136 */
  acoshf_lt_one,                                 /* 137 */
  log1pl_zero,   log1pl_negative,                /* 138, 139 */
  log1p_zero,    log1p_negative,                 /* 140, 141 */
  log1pf_zero,   log1pf_negative,                /* 142, 143 */
  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
  logbl_zero,   logb_zero, logbf_zero,           /* 150, 151,152 */
  nextafterl_overflow,   nextafter_overflow,  
  nextafterf_overflow,                           /* 153, 154,155 */
  ilogbl_zero,  ilogb_zero, ilogbf_zero,         /* 156, 157,158 */
  exp2l_overflow, exp2l_underflow,               /* 159, 160 */
  exp2_overflow,  exp2_underflow,                /* 161, 162 */
  exp2f_overflow, exp2f_underflow,               /* 163, 164 */
  exp10l_overflow, exp10_overflow,
  exp10f_overflow,                               /* 165, 166, 167 */
  log2l_zero,    log2l_negative,                 /* 168, 169 */
  log2_zero,     log2_negative,                  /* 170, 171 */
  log2f_zero,    log2f_negative,                 /* 172, 173 */

  log_nan = 1000,                                /* 1000 */
  log10_nan,                                     /* 1001 */
  exp_nan,                                       /* 1002 */
  atan_nan,                                      /* 1003 */
  ceil_nan,                                      /* 1004 */
  floor_nan,                                     /* 1005 */
  pow_nan,                                       /* 1006 */
  modf_nan                                       /* 1007 */
} error_types;

void __libm_error_support(void*,void*,void*,error_types);

#define BIAS_64  1023
#define EXPINF_64  2047

#define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI

static const unsigned INF[] = {
    DOUBLE_HEX(7ff00000, 00000000),
    DOUBLE_HEX(fff00000, 00000000)
};
static const unsigned BIG[] = {
    DOUBLE_HEX(7fe00000, 00000000),
    DOUBLE_HEX(00200000, 00000000)
};
static const unsigned ZERO[] = {
    DOUBLE_HEX(00000000, 00000000),
    DOUBLE_HEX(80000000, 00000000)
};

static const unsigned INF_32[] = {0x7f800000,0xff800000 };
static const unsigned NAN_32[] = {0x7fc00000,0xffc00000};
static const unsigned ZERO_32[] = { 0, 0x80000000 };

static const float libm_largef[] = { 1.0e+30f, -1.0e+30f };
static const float libm_smallf[] = { 1.0e-30f, -1.0e-30f };
static const double libm_small[] = { 1.0e-300, -1.0e-300 };

#define INVALID    (*((double*)&ZERO[0]) * *((double*)&INF[0]))
#define INVALID_32    *(float *)&ZERO_32[0] * *(float *)&INF_32[0]
#define LIBM_OVERFLOW (*((double*)&BIG[0]) * *((double*)&BIG[0]))
#define LIBM_UNDERFLOW (*((double*)&BIG[2]) * *((double*)&BIG[2]))
#define LIBM_OVERFLOWF (libm_largef[0] * libm_largef[0])
#define LIBM_UNDERFLOWF (libm_smallf[0] * libm_smallf[0])
#define PINF       *((double*)&INF[0]) 
#define NINF       -PINF 
#define PINF_DZ    (1.0/(*((double*)&ZERO[0])) 


struct _exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};

#define	MATHERR_D	_matherr

#define	EXC_DECL_D	_exception

extern int MATHERR_D(struct EXC_DECL_D*);

/* Set these appropriately to make thread Safe */
#define ERRNO_RANGE  errno = ERANGE
#define ERRNO_DOMAIN errno = EDOM

extern int (*_pmatherr)(struct EXC_DECL_D*);

// This is a run-time variable and may affect
// floating point behavior of the libm functions


#define BIAS_32  127
#define BIAS_64  1023
#define BIAS_80  16383
#define BIAS_128 16383

#define MAXEXP_32  254
#define MAXEXP_64  2046
#define MAXEXP_80  32766
#define MAXEXP_128 32766

#define EXPINF_32  255
#define EXPINF_64  2047
#define EXPINF_80  32767
#define EXPINF_128 32767

/*****************************/
/* memory format definitions */
/*****************************/

/*/// if you use /Zp2 option, or the following pragma... then the
//// 80 bit FP objects will occupy only 10 bytes in memory - otherwise
//// more generous alignments will "waste" memory.
//// Use of -DPACKFP80 is NOT recommended.
//// The same effect can be obtained using /Zp2 (again, NOT recommended).
//// Otherwise the alignment will be a word, forcing the size to be
//// 12 bytes (this means some memory will be wasted in exchange
//// for better performance).
//// Unfortunately, because -DPACKFP80 is implemented the same as /Zp2,
//// all structures will be packed tighter in the entire program. */
#ifdef PACKFP80
#pragma warning(disable:4103)
#pragma pack(2)
#endif

struct fp32 { /*// sign:1 exponent:8 significand:23 (implied leading 1)*/
  unsigned significand:23;
  unsigned exponent:8;
  unsigned sign:1;
};

struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
  unsigned lo_significand:32;
  unsigned hi_significand:20;
  unsigned exponent:11;
  unsigned sign:1;
};

struct fp80 { /*/ sign:1 exponent:15 significand:64 (NO implied bits) */
  unsigned         lo_significand;
  unsigned         hi_significand;
  unsigned         exponent:15;
  unsigned         sign:1;
};

#ifdef __cplusplus
  extern "C" {
#endif

  #define NONZERO_SIGNIFICAND(X) ((X)->hi_significand != 0 || (X)->lo_significand != 0)
  #define ZERO_SIGNIFICAND(X)    ((X)->hi_significand == 0 && (X)->lo_significand == 0)
  #define SET_ZERO_SIGNIFICAND(X) (X)->hi_significand = 0; (X)->lo_significand = 0
  #define SET_LO_SIGNIFICAND(X, LO) (X)->lo_significand = (LO)
  #define SET_HI_SIGNIFICAND(X, HI) (X)->hi_significand = (HI)
  #define SET_SIGNIFICAND(X, HI, LO) (X)->hi_significand = (HI);(X)->lo_significand = (LO)
  #define SIGNIFICAND_EQUAL(X, HI, LO) (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand == 0x ## LO))
  #define SIGNIFICAND_GREATER(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand > 0x ## LO))
  #define SIGNIFICAND_GREATER_EQ(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >= 0x ## LO))
  #define SIGNIFICAND_LESS(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand < 0x ## LO))
  #define SIGNIFICAND_LESS_EQ(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <= 0x ## LO))
  #define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
  #define ISSIGNIFICAND_EQUAL(X, Y) (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand == (Y)->lo_significand))
  #define ISSIGNIFICAND_GREATER(X, Y) ((X)->hi_significand > (Y)->hi_significand) || \
    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand > (Y)->lo_significand))
  #define ADD_ULP(X) if(!++(X)->lo_significand) { \
                           if(!++(X)->hi_significand) { \
                                 (X)->exponent++; }}
  #define SUB_ULP(X) if(!(X)->lo_significand--) { \
                           if(!(X)->hi_significand--) { \
                                 (X)->exponent--; }}
  #define CLEAR_LOW_BITS(X,MASK) (X)->lo_significand &= 0x ## MASK
  #define FIX_N_HI_BITS(X, NBIT) (X)->lo_significand = 0; (X)->hi_significand &= (0xfffff << (20 - NBIT))
  #define HI_BITS_TO_INTEGER(X, NBIT) (1 << (NBIT)) | ((X)->hi_significand >> (20 - (NBIT)))
  #ifdef BIG_ENDIAN
    #define DOUBLE_HEX(HI, LO) 0x ## HI, 0x ## LO
    #define HI_WORD(NUM) (*((unsigned *)(NUM))) & 0x7fffffff
  #else
    #define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI
    #define HI_WORD(NUM) (*(((unsigned *)(NUM))+1)) & 0x7fffffff
  #endif

#define SIGN_EXPAND(val,num)  ((val) << (32-(num))) >> (32-(num)) /* sign expand of 'num' LSBs */

#define VALUE_EQUAL(X,EXP,HI,LO) (((X)->exponent == (EXP)) && SIGNIFICAND_EQUAL(X, HI, LO))

#define VALUE_GREATER(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER(X, HI, LO))))
#define VALUE_GREATER_EQ(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER_EQ(X, HI, LO))))
#define VALUE_LESS(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS(X, HI, LO))))
#define VALUE_LESS_EQ(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS_EQ(X, HI, LO))))

#define ISVALUE_EQUAL(X, Y) \
    (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_EQUAL(X, Y))
#define ISVALUE_GREATER(X, Y) \
    (((X)->exponent > (Y)->exponent) || (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_GREATER(X, Y)))

#define VALUE_GREATERF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand > 0x##SIG)))
#define VALUE_GREATER_EQF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand >= 0x##SIG)))
#define VALUE_LESSF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand < 0x##SIG)))
#define VALUE_LESS_EQF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand <= 0x##SIG)))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\log10.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_LOG10_ equ 1
include log.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\log.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-28-01  PML   Check for negative denormal.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

ifdef   _LOG10_
    _FUNC_     equ      <log10>
    _FUNC_DEF_ equ      <_log10_default>
    _FUNC_P4_  equ      <_log10_pentium4>
else
    _FUNC_     equ      <log>
    _FUNC_DEF_ equ      <_log_default>
    _FUNC_P4_  equ      <_log_pentium4>
endif
    _FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

ifdef   _LOG10_
    _FUNC_     equ      <_CIlog10>
    _FUNC_DEF_ equ      <_CIlog10_default>
    _FUNC_P4_  equ      <_CIlog10_pentium4>
else
    _FUNC_     equ      <_CIlog>
    _FUNC_DEF_ equ      <_CIlog_default>
    _FUNC_P4_  equ      <_CIlog_pentium4>
endif
        include disp_pentium4.inc

        .data
extrn   _infinity:tbyte
extrn   _minfinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _DEFAULT_CW_in_mem:word

ifdef   _LOG10_
    LOG_name db 'log10',0,0,0
    _FUNC_      equ <_log10_default>
    _IFUNC_     equ <_CIlog10_default>
else
    LOG_name db 'log',0
    _FUNC_      equ <_log_default>
    _IFUNC_     equ <_CIlog_default>
endif
;page

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn        _convertTOStoQNaN:near
extrn        _checkTOS_withFB:near
extrn        _math_exit:near
extrn        _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;0.0 or -0.0         SING             minfinity
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           ??               +infinity
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           QNaN=indefinite
;indefinite is  like QNaN
;denormal(53)        fld converts it to normal (64 bits)
;denormal(64)        like normal number (64 bits)


        public        _IFUNC_,_FUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        mov     eax,[esp+0ch]                 ; eax contains high dword
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
; fyl2x is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:
        test    eax,7ff00000h
        jz      test_if_x_zero
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x

normal:
ifdef _LOG10_
        fldlg2
else
        fldln2                                ; y=load loge(2)
endif
        fxch
        fyl2x                                 ; y*log2(x)

exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        jmp     _math_exit

x_is_denormal:                                ; denormal is like normal
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x
        jmp     normal

inf_or_nan:                                   ; we differ inf and NaN
        test    eax,000fffffH                 ; eax=high
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:                                   ; -inf and neg is the same
        fstp    ST(0)
        fld     [_indefinite]                 ; log(infinity)=indefinite
        mov     eax,DOMAIN
        jmp     _ErrorHandling

not_infinity:                                 ; argument is QNaN or SNaN
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _ErrorHandling
test_if_x_zero:                               ; test if TOS is zero
        test    eax,000fffffH
        jnz     x_is_denormal                 ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     x_is_denormal                 ; denormal operand

        fstp    ST(0)                         ; log(0)=-infinity
        fld     tbyte ptr[_minfinity]
        mov     eax,SING
;        jmp     _ErrorHandling

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\log_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  log_wmt.asm
;
;  double log(double);
;
;  Initial version: 12/15/2000
;  Updated with bug fixes: 2/20/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  


CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
Magic   DQ  428FFFFFFFFFF80FH, 428FFFFFFFFFF80FH ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFFFFE00000H, 7FFFFFFFFFE00000H ; mask of bottom 21 bits
LOG_2   DQ  3FE62E42FEFA3800H, 3D2EF35793C76730H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
place_R DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  3FC24998090DC555H,  0BFCFFFFFFF201E13H      ; p6,p3 ->[p3|p6]
        DQ 0BFC555C54DD57D75H,   3FD55555555555A7H      ; p5,p2 ->[p2|p5]
        DQ  3FC9999998867A53H,  0BFE000000000001CH      ; p4,p1 ->[p1|p4]

;-------Table B-----------
B_Tbl     DQ 3FF0000000000000H, 3FF0000000000000H
          DQ 3FEF820000000000H, 3FEF820000000000H
          DQ 3FEF080000000000H, 3FEF080000000000H
          DQ 3FEE920000000000H, 3FEE920000000000H
          DQ 3FEE1E0000000000H, 3FEE1E0000000000H
          DQ 3FEDAE0000000000H, 3FEDAE0000000000H
          DQ 3FED420000000000H, 3FED420000000000H
          DQ 3FECD80000000000H, 3FECD80000000000H
          DQ 3FEC720000000000H, 3FEC720000000000H
          DQ 3FEC0E0000000000H, 3FEC0E0000000000H
          DQ 3FEBAC0000000000H, 3FEBAC0000000000H
          DQ 3FEB4E0000000000H, 3FEB4E0000000000H
          DQ 3FEAF20000000000H, 3FEAF20000000000H
          DQ 3FEA980000000000H, 3FEA980000000000H
          DQ 3FEA420000000000H, 3FEA420000000000H
          DQ 3FE9EC0000000000H, 3FE9EC0000000000H
          DQ 3FE99A0000000000H, 3FE99A0000000000H
          DQ 3FE9480000000000H, 3FE9480000000000H
          DQ 3FE8FA0000000000H, 3FE8FA0000000000H
          DQ 3FE8AC0000000000H, 3FE8AC0000000000H
          DQ 3FE8620000000000H, 3FE8620000000000H
          DQ 3FE8180000000000H, 3FE8180000000000H
          DQ 3FE7D00000000000H, 3FE7D00000000000H
          DQ 3FE78A0000000000H, 3FE78A0000000000H
          DQ 3FE7460000000000H, 3FE7460000000000H
          DQ 3FE7020000000000H, 3FE7020000000000H
          DQ 3FE6C20000000000H, 3FE6C20000000000H
          DQ 3FE6820000000000H, 3FE6820000000000H
          DQ 3FE6420000000000H, 3FE6420000000000H
          DQ 3FE6060000000000H, 3FE6060000000000H
          DQ 3FE5CA0000000000H, 3FE5CA0000000000H
          DQ 3FE58E0000000000H, 3FE58E0000000000H
          DQ 3FE5560000000000H, 3FE5560000000000H
          DQ 3FE51E0000000000H, 3FE51E0000000000H
          DQ 3FE4E60000000000H, 3FE4E60000000000H
          DQ 3FE4B00000000000H, 3FE4B00000000000H
          DQ 3FE47A0000000000H, 3FE47A0000000000H
          DQ 3FE4460000000000H, 3FE4460000000000H
          DQ 3FE4140000000000H, 3FE4140000000000H
          DQ 3FE3E20000000000H, 3FE3E20000000000H
          DQ 3FE3B20000000000H, 3FE3B20000000000H
          DQ 3FE3820000000000H, 3FE3820000000000H
          DQ 3FE3520000000000H, 3FE3520000000000H
          DQ 3FE3240000000000H, 3FE3240000000000H
          DQ 3FE2F60000000000H, 3FE2F60000000000H
          DQ 3FE2CA0000000000H, 3FE2CA0000000000H
          DQ 3FE29E0000000000H, 3FE29E0000000000H
          DQ 3FE2740000000000H, 3FE2740000000000H
          DQ 3FE24A0000000000H, 3FE24A0000000000H
          DQ 3FE2200000000000H, 3FE2200000000000H
          DQ 3FE1F80000000000H, 3FE1F80000000000H
          DQ 3FE1D00000000000H, 3FE1D00000000000H
          DQ 3FE1A80000000000H, 3FE1A80000000000H
          DQ 3FE1820000000000H, 3FE1820000000000H
          DQ 3FE15C0000000000H, 3FE15C0000000000H
          DQ 3FE1360000000000H, 3FE1360000000000H
          DQ 3FE1120000000000H, 3FE1120000000000H
          DQ 3FE0EC0000000000H, 3FE0EC0000000000H
          DQ 3FE0CA0000000000H, 3FE0CA0000000000H
          DQ 3FE0A60000000000H, 3FE0A60000000000H
          DQ 3FE0840000000000H, 3FE0840000000000H
          DQ 3FE0620000000000H, 3FE0620000000000H
          DQ 3FE0420000000000H, 3FE0420000000000H
          DQ 3FE0200000000000H, 3FE0200000000000H
          DQ 3FE0000000000000H, 3FE0000000000000H

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F8FBEA8B13C0000H, 3CDEC927B17E4E13H
          DQ 3F9F7A9B16780000H, 3D242AD9271BE7D7H
          DQ 3FA766D923C20000H, 3D1FF0A82F1C24C1H
          DQ 3FAF0C30C1114000H, 3D31A88653BA4140H
          DQ 3FB345179B63C000H, 3D3D4203D36150D0H
          DQ 3FB6EF528C056000H, 3D24573A51306A44H
          DQ 3FBA956D3ECAC000H, 3D3E63794C02C4AFH
          DQ 3FBE2507702AE000H, 3D303B433FD6EEDCH
          DQ 3FC0D79E7CD48000H, 3D3CB422847849E4H
          DQ 3FC299D30C606000H, 3D3D4D0079DC08D9H
          DQ 3FC44F8B726F8000H, 3D3DF6A4432B9BB4H
          DQ 3FC601B076E7A000H, 3D3152D7D4DFC8E5H
          DQ 3FC7B00916515000H, 3D146280D3E606A3H
          DQ 3FC9509AA0044000H, 3D3F1E675B4D35C6H
          DQ 3FCAF6895610D000H, 3D375BEBBA042B64H
          DQ 3FCC8DF7CB9A8000H, 3D3EEE42F58E1E6EH
          DQ 3FCE2A877A6B2000H, 3D3823817787081AH
          DQ 3FCFB7D86EEE3000H, 3D371FCF1923FB43H
          DQ 3FD0A504E97BB000H, 3D303094E6690C44H
          DQ 3FD1661CAECB9800H, 3D2D1C000C076A8BH
          DQ 3FD22981FBEF7800H, 3D17AF7A7DA9FC99H
          DQ 3FD2E9E2BCE12000H, 3D24300C128D1DC2H
          DQ 3FD3A71C56BB4800H, 3D08C46FB5A88483H
          DQ 3FD4610BC29C5800H, 3D385F4D833BCDC7H
          DQ 3FD51D1D93104000H, 3D35B0FAA20D9C8EH
          DQ 3FD5D01DC49FF000H, 3D2740AB8CFA5ED3H
          DQ 3FD68518244CF800H, 3D28722FF88BF119H
          DQ 3FD73C1800DC0800H, 3D3320DBF75476C0H
          DQ 3FD7E9883FA49800H, 3D3FAFF96743F289H
          DQ 3FD898D38A893000H, 3D31F666071E2F57H
          DQ 3FD94A0428036000H, 3D30E7BCB08C6B44H
          DQ 3FD9F123F4BF6800H, 3D36892015F2401FH
          DQ 3FDA99FCABDB8000H, 3D11E89C5F87A311H
          DQ 3FDB44977C148800H, 3D3C6A343FB526DBH
          DQ 3FDBEACD9E271800H, 3D268A6EDB879B51H
          DQ 3FDC92B7D6BB0800H, 3D10FE9FFF876CC2H
          DQ 3FDD360E90C38000H, 3D342CDB58440FD6H
          DQ 3FDDD4AA04E1C000H, 3D32D8512DF01AFDH
          DQ 3FDE74D262788800H, 3CFEB945ED9457BCH
          DQ 3FDF100F6C2EB000H, 3D2CCE779D37F3D8H
          DQ 3FDFACC89C9A9800H, 3D163E0D100EC76CH
          DQ 3FE02582A5C9D000H, 3D222C6C4E98E18CH
          DQ 3FE0720E5C40DC00H, 3D38E27400B03FBEH
          DQ 3FE0BF52E7353800H, 3D19B5899CD387D3H
          DQ 3FE109EB9E2E4C00H, 3D12DA67293E0BE7H
          DQ 3FE15533D3B8D400H, 3D3D981CA8B0D3C3H
          DQ 3FE19DB6BA0BA400H, 3D2B675885A4A268H
          DQ 3FE1E6DF676FF800H, 3D1A58BA81B983AAH
          DQ 3FE230B0D8BEBC00H, 3D12FC066E48667BH
          DQ 3FE2779E1EC93C00H, 3D36523373359B79H
          DQ 3FE2BF29F9841C00H, 3CFD8A3861D3B7ECH
          DQ 3FE30757344F0C00H, 3D309BE85662F034H
          DQ 3FE34C80A8958000H, 3D1D4093FCAC34BDH
          DQ 3FE39240DDE5CC00H, 3D3493DBEAB758B3H
          DQ 3FE3D89A6B1A5400H, 3D28C7CD5FA81E3EH
          DQ 3FE41BCFF4860000H, 3D076FD6B90E2A84H
          DQ 3FE4635BCF40DC00H, 3D2CE8D5D412CAADH
          DQ 3FE4A3E862342400H, 3D224FA993F78464H
          DQ 3FE4E8D015786C00H, 3D38B1C0D0303623H
          DQ 3FE52A6D269BC400H, 3D30022268F689C9H
          DQ 3FE56C91D71CF800H, 3CE07BAFD1366E9EH
          DQ 3FE5AB505B390400H, 3CD5627AF66563FAH
          DQ 3FE5EE82AA241800H, 3D2202380CDA46BEH
          DQ 3FE62E42FEFA3800H, 3D2EF35793C76730H
  
ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM


_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _log_pentium4, _CIlog_pentium4
_CIlog_pentium4 PROC NEAR
push        ebp
mov         ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret

;----------------------;
;--Argument Reduction--;
;----------------------;
_log_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF..FE00000
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to B
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H                   ;... eax is offset
movapd    xmm4, QWORD PTR [eax+B_Tbl]     ;... [B|B]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [B*Y_hi|B*Y_hi]
subpd     xmm6,xmm3            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0                       ;... [p3 R | p6 R]
mulpd     xmm3,xmm3                       ;... [R^2|R^2]
addpd     xmm1,xmm2                       ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3                       ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG_2]         ;... loading [L_lo|L_hi]
                                          ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5                       ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5                       ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6                       ;... [W_lo|W_hi]
addpd     xmm7,xmm4                       ;... [A_lo|A_hi]

mulpd     xmm1,xmm0                       ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0                       ;... [R^2|R^5]
addpd     xmm1,xmm2                       ;... [p1+.. | p4+...]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
unpckhpd  xmm1,xmm1            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0       ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:

;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
ret

INPUT_NaN:

; movlpd xmm0, QWORD PTR [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd    QWORD PTR [esp+4], xmm0       ; return result
; fld       QWORD PTR [esp+4]             ;
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 2
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY       ;...branch back

INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 3

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]
;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
fld       QWORD PTR [esp+16]             ;
add esp,28
ret


NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR


_CIlog_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\pow.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;   Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-25-01  PML   Fix pow(+/-0,-denorm)
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ  <pow>
_FUNC_DEF_ equ  <_pow_default>
_FUNC_P4_  equ  <_pow_pentium4>
_FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

_FUNC_     equ  <_CIpow>
_FUNC_DEF_ equ  <_CIpow_default>
_FUNC_P4_  equ  <_CIpow_pentium4>
        include disp_pentium4.inc

        .data
globalQ _half,           03fe0000000000000R
POW_name db 'pow',0

extrn   _infinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword


        CODESEG

extrn   _startTwoArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _check_range_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near
extrn   _powhlp:near
extrn   _twoToTOS:near

; arg1(base)   arg2(exponent)       ErrorType        result
;-----------------------------------------------------------
;infinity      not NaN                               called powhlp()
;not NaN       infinity                              called powhlp()
;QNaN          not SNaN             DOMAIN_QNAN      QNaN
;SNaN          any                  DOMAIN               
;
;*0           *0                    -                 1
;*0           positive,not odd      -                +0
;+0           positive, odd         -                +0
;-0           positive, odd         -                -0
;*0           negative,not odd      SING             infinity
;+0           negative, odd         SING             infinity
;-0           negative, odd         SING             -infinity
;negative     non-integer           DOMAIN           indefinite
;indefinite is                  like QNaN
;denormal(53)                   fld converts it to normal (64 bits)
;
; * in table above stands for both + and -
;
; if exponent field of result is 0, error type is set to UNDERFLOW
; if result is infinity, error type is set to OVERFLOW

        public        _CIpow_default,_pow_default
_CIpow_default proc
        sub     esp,2*DBLSIZE+4               ; prepare place for argument
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fst     qword ptr [esp+8]             ; exponent
        mov     eax,[esp+12]                  ; high dword of exponent
        call    start
        add     esp,2*DBLSIZE+4               ; clean stack
        ret

_pow_default label        proc

        lea     edx,[esp+12]                  ; load exponent(arg2)
        call    _fload_withFB
start:
        mov     ecx,eax                       ; make copy of eax
        push    eax                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; edx is destroyed
CW_is_set_to_default:
; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes), arg2(8bytes)
        and     ecx,7ff00000H
        lea     edx,[esp+8]                   ; edx points to arg1(base)

        cmp     ecx,7ff00000H
        je      special_exponent

        call    _fload_withFB                 ; edx already initialized
        jz      special_base
        test    eax,7ff00000H
        jz      test_if_we_have_zero_base
base_is_not_zero:
        mov     cl,[esp+15]                   ; cl will contain sign
        and     cl,80H                        ; test sign of base
        jnz     test_if_exp_is_int
normal:                                       ; denormal is like normal
        fyl2x                                 ; compute y*log2(x)
        call    _twoToTOS
        cmp     cl,1                          ; power was odd and base<0 ?
        jnz     exit
        fchs                                  ; if yes, we should change sign
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[POW_name]
        mov     edx,OP_POW
        jmp     _check_range_exit

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit

        lea     ecx,[POW_name]
        mov     edx,OP_POW
        call    _startTwoArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; some special cases
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1.One of arguments is NaN
exponent_is_NAN:
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1 to FPU stack
        test    byte ptr[esp+22],08H          ; test if arg2(exponent) is SNaN
        jnz     SNaN_detected
        inc     ecx                           ; ecx!=0 when one of args is QNaN
        jmp     test_base

SNaN_detected:
        fadd
        mov     eax,DOMAIN
        jmp     _ErrorHandling

base_is_NAN:
        test    byte ptr[esp+14],08H          ; is it SNaN
        jnz     SNaN_detected
one_of_args_is_QNaN:
        fadd                                  ; one of args is QNaN, and second is not SNaN
        mov     eax,DOMAIN_QNAN
        jmp     _ErrorHandling

special_base:
; both arguments are loaded to FPU stack
        xor     ecx,ecx
        jmp     test_base

special_exponent:
; only one argument is loaded to FPU stack
        xor     ecx,ecx                       ; we use ecx to set flags
        and     eax,000fffffH                 ; eax=high
        or      eax,[esp+16]                  ; test whether mantissa is zero
        jne     exponent_is_NAN
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1(base) to FPU stack
test_base:                                    ; arg2 may be inf, QNaN or normal
; both arguments are loaded to FPU stack
        mov     eax,[esp+12]                  ; arg1 high
        mov     edx,eax
        and     eax,7ff00000H
        and     edx,000fffffH                 ; test mantissa of arg2
        cmp     eax,7ff00000H
        jne     end_of_tests
        or      edx,[esp+8]
        jnz     base_is_NAN                   ; arg1 is NaN,

end_of_tests:
        test    ecx,ecx
        jnz     one_of_args_is_QNaN           ; base is QNaN

; one of args is infinity and second is not NaN. In this case we use powhlp()
;_usepowhlp
        sub     esp, SBUFSIZE+8               ; get storage for _retval and savebuf
        mov     ecx, esp
        push    ecx                           ; push address for result

        sub     esp, 16
        fstp    qword ptr [esp]
        fstp    qword ptr [esp+8]

        fsave   [ecx+8]
        call    _powhlp
        add     esp, 16                       ; clear arguments if _cdecl.
        pop     ecx
        frstor  [ecx+8]
        fld     qword ptr [ecx]               ; load result on the NDP stack
        add     esp, SBUFSIZE+8               ; get rid of storage

        test    eax,eax
        jz      _fast_exit
        mov     eax,DOMAIN
        jmp     _ErrorHandling



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2.  Base has zero exponent field
;
test_if_we_have_zero_base:
        mov     eax,[esp+12]
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     base_is_not_zero

; at this point we have two arguments on FPU stack.
; We know that TOS is zero, and arg2 is not special.
; We disinguish 3 cases:
;  (1) exponent is zero
;  (2) exponent is odd
;  (3) none of above

        fstp    st(0)                         ; remove zero from FPU stack
        mov     eax,[esp+20]                  ; test if arg2 is also zero
        and     eax,7fffffffh
        or      eax,[esp+16]
        jz      zero_to_zero
; check whether exponent is odd
        call    _test_whether_TOS_is_int
; cl=1 if exponent is odd,  2 - if even and 0 otherwise
        mov     ch,[esp+15]
        shr     ch,7                          ; ch==1 iff base is negative
        test    [esp+23],80H                  ; check sign of exponent
        jz      exp_is_positive
; exponent is negative
        fld     [_infinity]
        test    cl,ch
        jz      ret_inf
        fchs                                  ; base <0 and exponent is negative odd
ret_inf:
        mov     eax,SING
        jmp     _ErrorHandling

exp_is_positive:                              ; eax=error_code
        fldz
        test    cl,ch
        jz      _fast_exit
        fchs                                  ; base <0 and exponent positive is odd
        jmp     _fast_exit                    ; return -0.0

zero_to_zero:                                 ; arg1 and arg2 are zero
        fstp    st(0)                         ; remove useless argument from FPU stack
        fld1
        jmp     _fast_exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;3. Base is negative.
;
;   If exponent is not integer it's a DOMAIN error
;

test_if_exp_is_int:
        fld     st(1)
        call    _test_whether_TOS_is_int
        fchs
        test    cl,cl
        jnz     normal
        fstp    st(0)
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
        jmp     _ErrorHandling

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                _test_whether_TOS_is_int
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; returns in cl : 0,1,2 if TOS is non-int, odd int or even int respectively
;
_test_whether_TOS_is_int:
        fld     st(0)                         ; duplicate stack top
        frndint
        fcomp                                 ; is TOS integer???
        mov     cl,0                          ; prepare return value
        fstsw   ax
        sahf
        jne     _not_int                      ; TOS is not integer
        fmul    [_half]
        inc     cl                            ; cl>0, when exponent is integer
        fld     st(0)                         ; (exponent/2)
        frndint
        fcompp                                ; check if (exponent/2)==(int)(exponent/2)
        fstsw   ax
        sahf
        jne     _odd
        inc     cl                            ; sign that exponent is even
_odd:
        ret

_not_int:
        fstp    st(0)
        ret
_CIpow_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\modf_pentium4.asm ===
; file: modf_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double modf (double x, double *iptr)
; Returns the value of the signed fractional part of argument
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The modf functions break the argument value into integral and fractional parts,
;  each of which has the same type and sign as the argument. They store the integral
;  part (in floating-point format) in the object pointed to by iptr.
;
; Special cases:
;  modf(NaN,iptr) = that NaN and stores that NaN in the *iptr object
;  modf(INF,iptr) = 0 at the sign of x and stores that INF in the *iptr object
;
; Accuracy:
;  The result is always exact.

.xlist
        include cruntime.inc
.list

_FUNC_     equ  <modf>
_FUNC_DEF_ equ  <_modf_default>
_FUNC_P4_  equ  <_modf_pentium4>
_FUNC_DEF_EXTERN_ equ 1
        include disp_pentium4.inc

EXTRN C __libm_error_support : NEAR

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_Mantissa DQ 0000fffffffffffffH,0000fffffffffffffH
_Bns      DQ 00000000000000433H,00000000000000433H
_Sign     DQ 08000000000000000H,08000000000000000H
_Zero     DQ 00000000000000000H,00000000000000000H

      codeseg
      ALIGN 16

; double modf (double x, double *iptr);

; Stack frame locations

modf_x      TEXTEQU <esp+4>
modf_iptr   TEXTEQU <esp+12>
modf_result TEXTEQU <modf_x>
XMMWORD     TEXTEQU <OWORD>

PUBLIC _modf_pentium4
_modf_pentium4 PROC NEAR

    movq      xmm0, QWORD PTR [modf_x]           ; x
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm3, xmm0                         ; x
    movapd    xmm1, xmm0                         ; x
    movapd    xmm4, xmm0                         ; x
    movapd    xmm6, xmm0
    psllq     xmm0, 1  ; exp(x)                  ; remove sign
    psrlq     xmm0, 53 ; exp(x)                  ; exp(x)
    psrlq     xmm3, 52 ; exp(x)                  ; sign(x) | exp(x)
    andpd     xmm4, XMMWORD PTR _Sign            ; sign(x)
    movd      eax, xmm0                          ; exp(x)
    psubd     xmm2, xmm0                         ;
    mov       ecx, DWORD PTR [modf_iptr]         ; iptr
    psrlq     xmm1, xmm2                         ; truncate
    psllq     xmm1, xmm2                         ; t = trunc(x)
    movd      edx, xmm3                          ; sign(x) | exp(x)

    cmp       eax, 03ffH                         ; if abs(x) < 1.0
    jl        SHORT ret_z                        ; case A
    cmp       eax, 0432H                         ; if abs(x) >=2**53
    jg        SHORT ret_xm                       ; case B

    movq      QWORD PTR [ecx], xmm1              ; *iptr = t
    subsd     xmm6, xmm1
    orpd      xmm6, xmm4                         ; set sign if frac = 0.0

    movq      QWORD PTR [modf_result], xmm6
    fld       QWORD PTR [modf_result]            ; return signed result
    ret                                          ;

ret_z: ; case A: |x|<1.0

    movq      QWORD PTR [ecx], xmm4              ; *iptr = properly-signed 0.0
    fld       QWORD PTR [modf_x]                 ;  return (X)
    ret                                          ;

ret_xm: ; case B: exp(x) >= 53

    cmp       eax, 07ffH                         ; check Inf (NaN)
    movq      xmm0, QWORD PTR [modf_x]           ; x
    je        SHORT ret_inf_nan                  ;

    movq      QWORD PTR [ecx], xmm0              ;

    cmp       edx, 800H                          ;
    fldz                                         ; if x is positive, return 0.0
    jl        SHORT return                       ;

    fchs                                         ; if x is negative, return -0.0

return:

    ret                                          ;

ret_inf_nan:

    movapd    xmm1, xmm0 
    addsd     xmm0, xmm0  
    movq      QWORD PTR [ecx], xmm0              ;
    andpd     xmm0, XMMWORD PTR _Mantissa        ;
    cmppd     xmm0, XMMWORD PTR _Zero, 4         ; Mask = (x == Inf) ? 0 : 1
    pextrw    eax,  xmm0, 0                      ; eax=(x==INF)? 0:1

    andpd     xmm0, xmm1                         ; t = Mask & x
    orpd      xmm0, xmm4                         ; t |= Sign(x)

    mov       edx, 1007
    cmp       eax, 0
    ; if NaN, call libm_error_support
    jnz       CALL_LIBM_ERROR

    movq      QWORD PTR [modf_result], xmm0      ;
    fld       QWORD PTR [modf_result]            ; return (t)
    ret                                          ;

CALL_LIBM_ERROR:
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 28
    movlpd    QWORD PTR [esp+16], xmm0
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx,16
    mov       DWORD PTR [esp+8],edx
    add       edx,16+8
    mov       DWORD PTR [esp+4],edx
    sub       edx, 8
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
;   movlpd    xmm0, QWORD PTR [esp+16]

;   movlpd    QWORD PTR [esp+16], xmm0           ; return result
    fld       QWORD PTR [esp+16]                 ;
    add       esp,28
    ret

_modf_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\log10_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;    log10_wmt.asm
;
;    double log10(double);
;
;    Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a second implementation of the branch-free log10 function     ;;
;; In this version, we use a trick to get the index j = 0,1,...,64 that  ;;
;; does not require integer testing. By adding 2^(42)-1 (FP) to Y, the   ;;
;; least 4 bits contains dob't cares and the 7 bits following that has   ;;
;; the range 0 to 64. Hence obtaining, say, the 16 lsb and masking off   ;;
;; everything except bit 4 through 10 gives the shifted index.           ;;
;; This saves an integer shift as well.                                  ;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
CC      DQ  3FDBC00000000000H, 3FDBC00000000000H ; pair of C           
Magic   DQ  428FFFFFFFFFF810H, 428FFFFFFFFFF810H ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFF80000000H, 7FFFFFFF80000000H ; maks of bottom 31 bits
LOG10_2 DQ  3FD34413509F7800H, 3D1FEF311F12B358H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
place_R DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  40358914C697CEF9H, 0C00893096429813DH       ; p6,p3 ->[p3|p6]   
        DQ 0C025C9806A358455H,  3FFC6A02DC9635D2H       ; p5,p2 ->[p2|p5]   
        DQ  4016AB9F7E1899F7H, 0BFF27AF2DC77B135H       ; p4,p1 ->[p1|p4]  
        DQ  3F5A7A6CBF2E4108H,  0000000000000000H       ; p0,0  -> [0|p0]

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F7C03A80AE40000H, 3D3E05382D51F71BH
          DQ 3F8B579DB6DE0000H, 3D386B09FEFB3005H
          DQ 3F9470AEDE968000H, 3D39FC780C91E11DH
          DQ 3F9ADA2E8E3E0000H, 3D351BD19E6E701AH
          DQ 3FA0ADD8F759C000H, 3D1B2A51090000A1H
          DQ 3FA3FAF7C6630000H, 3D083662F181F53FH
          DQ 3FA7171E59EFC000H, 3D16BD1A3FCF54DBH
          DQ 3FAA3E9002C70000H, 3D21D257C8D0D386H
          DQ 3FAD32332DC34000H, 3D1B7ADBF8D9441FH
          DQ 3FB0281170D6A000H, 3D1BF38B28AF5076H
          DQ 3FB19C1FECF16000H, 3D3EE03F1E5355D4H
          DQ 3FB3151BFD65C000H, 3D37E280048C6795H
          DQ 3FB4932780C56000H, 3D2FC4ACCD62A5F3H
          DQ 3FB605735EE98000H, 3D17C3CF23A17D9FH
          DQ 3FB76B778D4AA000H, 3D1C03E812A06E7AH
          DQ 3FB8D60B4EE4C000H, 3D3900E5CC4E4C82H
          DQ 3FBA33B422244000H, 3D36F17034675735H
          DQ 3FBB95B654A78000H, 3D290E5E24764EC7H
          DQ 3FBCEA2602E9E000H, 3CEBD129822ECBCBH
          DQ 3FBE42B4C16CA000H, 3D25E50FF38D4DE9H
          DQ 3FBF8D05B16A6000H, 3D2A8EA5A2B777A7H
          DQ 3FC06D9BC53C2000H, 3D32818DEEE1FA45H
          DQ 3FC10D3EACDE0000H, 3D1E8A45CB83F0AEH
          DQ 3FC1B83F1574D000H, 3D010B19F193FFD4H
          DQ 3FC251FE054FD000H, 3CFEAC09402877C0H
          DQ 3FC2F7301CF4E000H, 3D30F5C70D1A6341H
          DQ 3FC394700F795000H, 3D1FE93F791A7264H
          DQ 3FC4297453B4A000H, 3D3ECE09C5BC4B34H
          DQ 3FC4CA24FAFEC000H, 3D2E204342E66851H
          DQ 3FC5627512093000H, 3D30DFECB3AA172DH
          DQ 3FC5F21A1AF60000H, 3D3FEF1B2D3E6113H
          DQ 3FC68DA216900000H, 3CED942CFC9699D0H
          DQ 3FC720586C280000H, 3D3D20A8624054CDH
          DQ 3FC7B495FF1C5000H, 3D25012C689133C5H
          DQ 3FC83FA266CEA000H, 3D20C6C18687239FH
          DQ 3FC8CC0E0C56F000H, 3D36E3B4A1CFA0DFH
          DQ 3FC959DFEFE7D000H, 3D2420027AFFE0E5H
          DQ 3FC9E91F47D2C000H, 3D35330E6CF22420H
          DQ 3FCA6EA48B034000H, 3D33EBACB92B5B7FH
          DQ 3FCB00B7C552F000H, 3D3DF4694C64AA73H
          DQ 3FCB88E67CF97000H, 3D32FF232278A072H
          DQ 3FCC06E3BA2E4000H, 3D32CB15CD55BD7CH
          DQ 3FCC919DD46C0000H, 3D0EB64694E6AC72H
          DQ 3FCD11FB61139000H, 3D1A34DB91AE960BH
          DQ 3FCD9F59ABFD1000H, 3D207B23BCD76C73H
          DQ 3FCE163D527E6000H, 3D319D69F22E93E4H
          DQ 3FCE9A2CDC02A000H, 3D20EBF59081F187H
          DQ 3FCF1F5876949000H, 3D07AFEBEA179000H
          DQ 3FCF99801FDB7000H, 3D22737DF7F29668H
          DQ 3FD00A5B4509D000H, 3D1F6B5B2353257FH
          DQ 3FD0488037FBE800H, 3D1B6A93B9B912C6H
          DQ 3FD087315621A800H, 3D3261DA7DBFF3AEH
          DQ 3FD0C6711D6AB800H, 3D35E94A8D30C132H
          DQ 3FD0FFD9CDD2A800H, 3D16350EF6F19D80H
          DQ 3FD1402FBEC27800H, 3D313C204222BA8BH
          DQ 3FD17A9719699000H, 3D21F279212D5C99H
          DQ 3FD1B57A30AC5800H, 3D3DCF3E62FF847EH
          DQ 3FD1F0DB153AB800H, 3D27582E230C0EDFH
          DQ 3FD2260E4F424800H, 3D157E1028A41FF9H
          DQ 3FD26262A6117800H, 3D12B01A2E0C1912H
          DQ 3FD29871C043D800H, 3D2B3969AC9E3779H
          DQ 3FD2D5C1760B8000H, 3D3AEADEBE0F08BFH
          DQ 3FD30CB3A7BB3000H, 3D38929919B6D832H
          DQ 3FD34413509F7800H, 3D1FEF311F12B358H

;-----------------
CB_Tbl    DQ 3FDBC00000000000H, 3FDBC00000000000H  
          DQ 3FDB510000000000H, 3FDB510000000000H  
          DQ 3FDAE8F000000000H, 3FDAE8F000000000H  
          DQ 3FDA80E000000000H, 3FDA80E000000000H  
          DQ 3FDA1FC000000000H, 3FDA1FC000000000H  
          DQ 3FD9BEA000000000H, 3FD9BEA000000000H  
          DQ 3FD95D8000000000H, 3FD95D8000000000H  
          DQ 3FD9035000000000H, 3FD9035000000000H  
          DQ 3FD8A92000000000H, 3FD8A92000000000H  
          DQ 3FD855E000000000H, 3FD855E000000000H  
          DQ 3FD7FF2800000000H, 3FD7FF2800000000H  
          DQ 3FD7AF6000000000H, 3FD7AF6000000000H  
          DQ 3FD75F9800000000H, 3FD75F9800000000H  
          DQ 3FD70FD000000000H, 3FD70FD000000000H  
          DQ 3FD6C38000000000H, 3FD6C38000000000H  
          DQ 3FD67AA800000000H, 3FD67AA800000000H  
          DQ 3FD631D000000000H, 3FD631D000000000H  
          DQ 3FD5EC7000000000H, 3FD5EC7000000000H  
          DQ 3FD5A71000000000H, 3FD5A71000000000H  
          DQ 3FD5652800000000H, 3FD5652800000000H  
          DQ 3FD5234000000000H, 3FD5234000000000H  
          DQ 3FD4E4D000000000H, 3FD4E4D000000000H  
          DQ 3FD4A66000000000H, 3FD4A66000000000H  
          DQ 3FD46B6800000000H, 3FD46B6800000000H  
          DQ 3FD42CF800000000H, 3FD42CF800000000H  
          DQ 3FD3F57800000000H, 3FD3F57800000000H  
          DQ 3FD3BA8000000000H, 3FD3BA8000000000H  
          DQ 3FD3830000000000H, 3FD3830000000000H  
          DQ 3FD34EF800000000H, 3FD34EF800000000H  
          DQ 3FD3177800000000H, 3FD3177800000000H  
          DQ 3FD2E37000000000H, 3FD2E37000000000H  
          DQ 3FD2B2E000000000H, 3FD2B2E000000000H  
          DQ 3FD27ED800000000H, 3FD27ED800000000H  
          DQ 3FD24E4800000000H, 3FD24E4800000000H  
          DQ 3FD21DB800000000H, 3FD21DB800000000H  
          DQ 3FD1F0A000000000H, 3FD1F0A000000000H  
          DQ 3FD1C38800000000H, 3FD1C38800000000H  
          DQ 3FD1967000000000H, 3FD1967000000000H  
          DQ 3FD1695800000000H, 3FD1695800000000H  
          DQ 3FD13FB800000000H, 3FD13FB800000000H  
          DQ 3FD112A000000000H, 3FD112A000000000H  
          DQ 3FD0E90000000000H, 3FD0E90000000000H  
          DQ 3FD0C2D800000000H, 3FD0C2D800000000H  
          DQ 3FD0993800000000H, 3FD0993800000000H  
          DQ 3FD0731000000000H, 3FD0731000000000H  
          DQ 3FD0497000000000H, 3FD0497000000000H  
          DQ 3FD026C000000000H, 3FD026C000000000H  
          DQ 3FD0009800000000H, 3FD0009800000000H  
          DQ 3FCFB4E000000000H, 3FCFB4E000000000H  
          DQ 3FCF6F8000000000H, 3FCF6F8000000000H  
          DQ 3FCF2A2000000000H, 3FCF2A2000000000H  
          DQ 3FCEE4C000000000H, 3FCEE4C000000000H  
          DQ 3FCE9F6000000000H, 3FCE9F6000000000H  
          DQ 3FCE5A0000000000H, 3FCE5A0000000000H  
          DQ 3FCE1B9000000000H, 3FCE1B9000000000H  
          DQ 3FCDD63000000000H, 3FCDD63000000000H  
          DQ 3FCD97C000000000H, 3FCD97C000000000H  
          DQ 3FCD595000000000H, 3FCD595000000000H  
          DQ 3FCD1AE000000000H, 3FCD1AE000000000H  
          DQ 3FCCE36000000000H, 3FCCE36000000000H  
          DQ 3FCCA4F000000000H, 3FCCA4F000000000H  
          DQ 3FCC6D7000000000H, 3FCC6D7000000000H  
          DQ 3FCC2F0000000000H, 3FCC2F0000000000H  
          DQ 3FCBF78000000000H, 3FCBF78000000000H  
          DQ 3FCBC00000000000H, 3FCBC00000000000H  

ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _log10_pentium4, _CIlog10_pentium4
_CIlog10_pentium4 PROC NEAR
push	    ebp
mov	    ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret


;----------------------;
;--Argument Reduction--;
;----------------------;

_log10_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm2, QWORD PTR [CC]            ;... pair of CC
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF8000..00
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to CB
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H        ;... eax is offset
movapd    xmm4, QWORD PTR [eax+CB_Tbl]    ;... [CB|CB]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [CB*Y_hi|CB*Y_hi]
subpd     xmm6,xmm2            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0            ;... [p3 R | p6 R]
mulpd     xmm3,xmm3            ;... [R^2|R^2]
addpd     xmm1,xmm2            ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3            ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG10_2]       ;... loading [L_lo|L_hi]
                               ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5            ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5            ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6            ;... [W_lo|W_hi]
addpd     xmm7,xmm4            ;... [A_lo|A_hi]

mulpd     xmm1,xmm0            ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0            ;... [R^2|R^5]
addpd     xmm1,xmm2            ;... [p1+.. | p4+...]
movapd    xmm2, QWORD PTR [coeff+48]      ;... [0|p0]
mulpd     xmm2,xmm0            ;... [0|p0 R]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
addpd     xmm1,xmm2            ;... [P_hi|P_lo]
unpckhpd  xmm0,xmm0            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0      ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:
;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
	ret

INPUT_NaN:

; movlpd xmm0, [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 8
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY         ;...branch back


INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 9

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
fld       QWORD PTR [esp+16]             ;
add esp,28
ret



NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR
  

_CIlog10_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\sin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_SIN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\tan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_TAN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\pow_pentium4.asm ===
; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  pow_p4.asm
;
;  double pow(double,double);
;
;  Initial version: 01/10/2001
;  Update (bug fixes): 02/26/2001
;  Updated the underflow/overflow path 
;       to restore edi, esi in the correct order: 03/07/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  x=2^k*1.b1 b2...b6 b7 .. b52   x1=1.b1..b52
;;     f1=(b1 b2 ..b7 +1)/2
;;  x2=x1*rcp_t1[f1]=b'0.b'1 b'2 ... b'52 b'53  (b'53=0 if b'0=1)
;;     f2=(b'7 ..b'14 +1)/2
;;  x3=x2*rcp_t2[f2]=b"0.b"1 b"2 ... b"52 b"53   (b"53=0 if b"0=1)
;;     f3=(b"13 ..b"21+1)/2
;;  R=x3*rcp_t3[f3]
;;  rcp=rcp_t1[f1]*rcp_t2[f2]*rcp_t3[f3]  (exact multiplication)
;;  E=exact_mul(rcp*x1)-R
;;  R'=RN(R+E)
;;
;;  H=RN(RN(k+T1[f1]+T2[f2]+T3[f3]+R)+E)  (high part of log2(x) approximation)
;;  Rl+El=exact(k+T1[f1]+T2[f2]+T3[f3]+R+E)-H
;;
;;  Exponential evaluation started with approximate argument yH*HH (exact 
;;  product of the most significant 26 bits of y and H)
;;  Correction added to exponential reduced argument: 
;;    yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+El)+Pl14),
;;  where Pl14=cl1*R'+...+cl4*R'^4
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR

  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
    ALIGN 16

rcp_t1	DQ 03ff0000000000000H, 03fefc08000000000H
	DQ 03fef820000000000H, 03fef448000000000H
	DQ 03fef07c000000000H, 03feecc0000000000H
	DQ 03fee914000000000H, 03fee574000000000H
	DQ 03fee1e0000000000H, 03fede5c000000000H
	DQ 03fedae8000000000H, 03fed77c000000000H
	DQ 03fed41c000000000H, 03fed0cc000000000H
	DQ 03fecd84000000000H, 03feca4c000000000H
	DQ 03fec71c000000000H, 03fec3f8000000000H
	DQ 03fec0e0000000000H, 03febdd4000000000H
	DQ 03febad0000000000H, 03feb7d8000000000H
	DQ 03feb4e8000000000H, 03feb204000000000H
	DQ 03feaf28000000000H, 03feac58000000000H
	DQ 03fea990000000000H, 03fea6d0000000000H
	DQ 03fea41c000000000H, 03fea16c000000000H
	DQ 03fe9ec8000000000H, 03fe9c2c000000000H
	DQ 03fe9998000000000H, 03fe9710000000000H
	DQ 03fe948c000000000H, 03fe9210000000000H
	DQ 03fe8f9c000000000H, 03fe8d30000000000H
	DQ 03fe8acc000000000H, 03fe8870000000000H
	DQ 03fe8618000000000H, 03fe83c8000000000H
	DQ 03fe8180000000000H, 03fe7f40000000000H
	DQ 03fe7d04000000000H, 03fe7ad4000000000H
	DQ 03fe78a4000000000H, 03fe767c000000000H
	DQ 03fe745c000000000H, 03fe7244000000000H
	DQ 03fe7030000000000H, 03fe6e20000000000H
	DQ 03fe6c18000000000H, 03fe6a14000000000H
	DQ 03fe6818000000000H, 03fe6620000000000H
	DQ 03fe642c000000000H, 03fe6240000000000H
	DQ 03fe6058000000000H, 03fe5e74000000000H
	DQ 03fe5c98000000000H, 03fe5ac0000000000H
	DQ 03fe58ec000000000H, 03fe5720000000000H
	DQ 03fe5554000000000H, 03fe5390000000000H
	DQ 03fe51d0000000000H, 03fe5014000000000H
	DQ 03fe4e60000000000H, 03fe4cac000000000H
	DQ 03fe4afc000000000H, 03fe4954000000000H
	DQ 03fe47b0000000000H, 03fe460c000000000H
	DQ 03fe4470000000000H, 03fe42d8000000000H
	DQ 03fe4140000000000H, 03fe3fb0000000000H
	DQ 03fe3e24000000000H, 03fe3c98000000000H
	DQ 03fe3b14000000000H, 03fe3990000000000H
	DQ 03fe3814000000000H, 03fe3698000000000H
	DQ 03fe3520000000000H, 03fe33b0000000000H
	DQ 03fe3240000000000H, 03fe30d0000000000H
	DQ 03fe2f68000000000H, 03fe2e04000000000H
	DQ 03fe2ca0000000000H, 03fe2b40000000000H
	DQ 03fe29e4000000000H, 03fe288c000000000H
	DQ 03fe2734000000000H, 03fe25e4000000000H
	DQ 03fe2494000000000H, 03fe2344000000000H
	DQ 03fe21fc000000000H, 03fe20b4000000000H
	DQ 03fe1f70000000000H, 03fe1e30000000000H
	DQ 03fe1cf0000000000H, 03fe1bb4000000000H
	DQ 03fe1a7c000000000H, 03fe1944000000000H
	DQ 03fe1810000000000H, 03fe16e0000000000H
	DQ 03fe15b0000000000H, 03fe1484000000000H
	DQ 03fe135c000000000H, 03fe1234000000000H
	DQ 03fe1110000000000H, 03fe0ff0000000000H
	DQ 03fe0ed0000000000H, 03fe0db4000000000H
	DQ 03fe0c98000000000H, 03fe0b80000000000H
	DQ 03fe0a68000000000H, 03fe0954000000000H
	DQ 03fe0844000000000H, 03fe0734000000000H
	DQ 03fe0624000000000H, 03fe0518000000000H
	DQ 03fe0410000000000H, 03fe0308000000000H
	DQ 03fe0204000000000H, 03fe0100000000000H
	DQ 03fe0000000000000H, 0

log2_t1 DQ 0, 0
	DQ 03f86fdf461d20000H, 03d3c9efc46d9f6f7H
	DQ 03f96e625317a0000H, 03d453f0e645614dbH
	DQ 03fa11a6297920000H, 03d4d925cd7d436d6H
	DQ 03fa6bb01a01f0000H, 03d3c995e7439db70H
	DQ 03fac4eb3635c8000H, 03d4a8192bdcad609H
	DQ 03fb0ea8b80338000H, 03d4e1797942f1be5H
	DQ 03fb3a9f062a90000H, 03d3011ef2e155a44H
	DQ 03fb665684ff80000H, 03d3084f28da93fafH
	DQ 03fb919bc335d0000H, 03d246082ed03fe7fH
	DQ 03fbbc6b9d7c04000H, 03d45b7e842652658H
	DQ 03fbe7272e1dc8000H, 03d4a2ea92333a25cH
	DQ 03fc08cd7820ec000H, 03d3543c511b40206H
	DQ 03fc1dc8f3a33c000H, 03d45598cab6d744cH
	DQ 03fc32b7a27af4000H, 03d07aba1fd6522b1H
	DQ 03fc476564c740000H, 03d4dc39f249b8f70H
	DQ 03fc5c04864906000H, 03d28c5d47e5f3668H
	DQ 03fc707a4ef786000H, 03d4f86ea591de6f8H
	DQ 03fc84c59fac38000H, 03d435cd351b14a77H
	DQ 03fc98e556aacc000H, 03d341c88d156ee10H
	DQ 03fcacf30032be000H, 03d2e3733debf9165H
	DQ 03fcc0d3213ae6000H, 03d4b15bcb18be2edH
	DQ 03fcd49f9d6d66000H, 03d30b557c2a12d29H
	DQ 03fce83c98a2d0000H, 03d442af5d10d18f2H
	DQ 03fcfbc44e396e000H, 03d47b3f928665437H
	DQ 03fd078d40936e000H, 03d38f1f608125902H
	DQ 03fd112ce25b29000H, 03d3c851c0f45bae5H
	DQ 03fd1ac0b77e3f000H, 03d3f97100b047ea3H
	DQ 03fd243a590d2b000H, 03d3c9b75e8e9d45dH
	DQ 03fd2db57ad935000H, 03cf934f5238ac23eH
	DQ 03fd37158be940000H, 03d4a16d142e3f4deH
	DQ 03fd40684445fb000H, 03d469ba14bfbfc6dH
	DQ 03fd49ad4a118d000H, 03d45cd377302cca5H
	DQ 03fd52d5be2114000H, 03d3a83640f883e4bH
	DQ 03fd5bfe367828000H, 03d49755c3dea7d5aH
	DQ 03fd6517e94738000H, 03d4e8a28223a67c4H
	DQ 03fd6e22792ef1000H, 03d314f240e7e9039H
	DQ 03fd771d87fd10000H, 03d258aaf31d36edbH
	DQ 03fd8008b6b297000H, 03d1605b88ccad976H
	DQ 03fd88e3a58a56000H, 03d2097ff572e71dfH
	DQ 03fd91bd19e695000H, 03d4dbb3ee4f6c667H
	DQ 03fd9a85babbe1000H, 03d4d889a0a61b2d6H
	DQ 03fda33d25fcb1000H, 03d4f5875d92c8dd6H
	DQ 03fdabe2f8ec96000H, 03d3c773190e2cc83H
	DQ 03fdb4865273ed000H, 03d4ab54a099e1f60H
	DQ 03fdbd07e0e781000H, 03d268ac21c0dcf20H
	DQ 03fdc5960ba6e1000H, 03d43b4bd96cb81feH
	DQ 03fdce1168b913000H, 03d2fada3055d19e2H
	DQ 03fdd679920231000H, 03d18ed5096e87504H
	DQ 03fddece20dffc000H, 03d43e26c2ced8aaaH
	DQ 03fde71ebad35f000H, 03d011609e08e95e1H
	DQ 03fdef6b3d3444000H, 03d40b35b2d1614faH
	DQ 03fdf7a349e747000H, 03d4a6e7081d99120H
	DQ 03fdffd6c9e8cc000H, 03cfa67452e86699dH
	DQ 03fe03fa97e79f000H, 03d275e12e74f8beeH
	DQ 03fe080748d542800H, 03d3b8c3b78ce0adbH
	DQ 03fe0c11650cf0000H, 03d461752eb1152a5H
	DQ 03fe1010826b18000H, 03d4ea3c98a07d258H
	DQ 03fe140ccdd4ae800H, 03d1fcada197ed2c1H
	DQ 03fe180633d744800H, 03d22551707e07a41H
	DQ 03fe1bf426e8e9800H, 03d376aff6c055f55H
	DQ 03fe1fdef5db3a000H, 03d4442de8501d871H
	DQ 03fe23c68c8201000H, 03d270c749129a57aH
	DQ 03fe27a23a05a8000H, 03d4cb0ea30b214a6H
	DQ 0bfda8f9d1c354000H, 0bd4604f54f4f9853H
	DQ 0bfda1506aee3b000H, 0bd44ff93dbb28c80H
	DQ 0bfd99ae48aa53000H, 0bd0e6ed7003dfdf5H
	DQ 0bfd9213957df2000H, 0bd3e186ac01b3f7fH
	DQ 0bfd8a9228a043000H, 0bd49bc20cf8dd883H
	DQ 0bfd8306ebf51c000H, 0bd45c8266e480596H
	DQ 0bfd7b83a057f9000H, 0bd35f4f79f443745H
	DQ 0bfd741a637fca000H, 0bd4025f49ff0180dH
	DQ 0bfd6cb99e7aa4000H, 0bd412b5ad5a7002aH
	DQ 0bfd654f5e853d000H, 0bd44c7008c4a72a7H
	DQ 0bfd5dfff91d34000H, 0bd3f544ed390ba95H
	DQ 0bfd56b9933779000H, 0bd391dc031bae772H
	DQ 0bfd4f69f5d830000H, 0bd38f36dd24bae46H
	DQ 0bfd483602143d000H, 0bce09c599a327931H
	DQ 0bfd410b98a0d4000H, 0bd156a3c28e8042aH
	DQ 0bfd39d83e4060000H, 0bd447f1643c10456H
	DQ 0bfd32c15f8b57000H, 0bd0d6ee2e01d9231H
	DQ 0bfd2ba1c0891f000H, 0bd3795076c3da632H
	DQ 0bfd249f2ada03000H, 0bd2a7809feb5964fH
	DQ 0bfd1d9406c900000H, 0bd4546d73ea7c032H
	DQ 0bfd16935d34fb000H, 0bd2151c6348d84a4H
	DQ 0bfd0fb093a3fd000H, 0bd2bacac000943a5H
	DQ 0bfd08c588cda7000H, 0bd43c72c4f78dfa1H
	DQ 0bfd01d228cf40000H, 0bd3c6972c813e541H
	DQ 0bfcf5faa7e71a000H, 0bd3d157620c552c1H
	DQ 0bfce867e093dc000H, 0bd366fa6f3fffcc0H
	DQ 0bfcdac50fe6d4000H, 0bd2b6484bb8f2009H
	DQ 0bfccd398e83e8000H, 0bd05f5cde492c839H
	DQ 0bfcbfc5c1d5be000H, 0bd2784900e42b538H
	DQ 0bfcb26a0fb83e000H, 0bd4a5b99e91f69b7H
	DQ 0bfca4fed5abba000H, 0bd45976e8062c61fH
	DQ 0bfc97d45e2448000H, 0bd401c636755cd02H
	DQ 0bfc8a9ad0948a000H, 0bd4c89ba64f25a55H
	DQ 0bfc7d520a4220000H, 0bd216a44d008a53dH
	DQ 0bfc704b6c17f0000H, 0bd413a806d56d6eeH
	DQ 0bfc633609cb64000H, 0bd33f125177ec11cH
	DQ 0bfc563adff6b0000H, 0bd4d0837079422c3H
	DQ 0bfc495a582ff2000H, 0bd3ebd9313709ef4H
	DQ 0bfc3c6b62529a000H, 0bd42d2b08296bf5cH
	DQ 0bfc2f9786ad2e000H, 0bd3b5188c2483623H
	DQ 0bfc22df302746000H, 0bd3048e3c2505d3dH
	DQ 0bfc1618c543b8000H, 0bd45b8d6a3b61bd1H
	DQ 0bfc096e5a2260000H, 0bd4bde98232d61f6H
	DQ 0bfbf9c0b5c568000H, 0bd4d3483b7a56256H
	DQ 0bfbe089492ee4000H, 0bd405589fcd57f86H
	DQ 0bfbc78bae5580000H, 0bd35351d0387c197H
	DQ 0bfbaec8bfaf64000H, 0bd3d13cbabea0e44H
	DQ 0bfb95eb24969c000H, 0bd3727fab299d747H
	DQ 0bfb7d49341a08000H, 0bd4eeef8bcf7aa55H
	DQ 0bfb64e3caa930000H, 0bd31aad2031e3ecaH
	DQ 0bfb4c647d2ea8000H, 0bceb43c4115c4fb7H
	DQ 0bfb3422b94a24000H, 0bd421b493a67e318H
	DQ 0bfb1bc75cf5a4000H, 0bd4d7db2139e8397H
	DQ 0bfb03aa8f8dc8000H, 0bd153121e9af5428H
	DQ 0bfad6e8ef48f8000H, 0bd38293c51765dbcH
	DQ 0bfaa6fbed7680000H, 0bd2b1c66db7cd724H
	DQ 0bfa778fdc1828000H, 0bd34378af2af5332H
	DQ 0bfa47f2e22550000H, 0bd2a424693c56dcdH
	DQ 0bfa18249a5368000H, 0bd441b0d5fdf534bH
	DQ 0bf9d1b35ee200000H, 0bd431fb72db4f24dH
	DQ 0bf97427d317a0000H, 0bd4700f14b03b093H
	DQ 0bf9163d20d100000H, 0bd46e8b9664fe33fH
	DQ 0bf872c1f4cf00000H, 0bd2b4934580fe573H
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0H, 0H


rcp_t2	DQ 03ff0000000000000H, 03fefff4000000000H
	DQ 03feffe4000000000H, 03feffd4000000000H
	DQ 03feffc4000000000H, 03feffb4000000000H
	DQ 03feffa4000000000H, 03feff94000000000H
	DQ 03feff84000000000H, 03feff74000000000H
	DQ 03feff64000000000H, 03feff54000000000H
	DQ 03feff44000000000H, 03feff34000000000H
	DQ 03feff24000000000H, 03feff14000000000H
	DQ 03feff04000000000H, 03fefef4000000000H
	DQ 03fefee4000000000H, 03fefed4000000000H
	DQ 03fefec4000000000H, 03fefeb4000000000H
	DQ 03fefea4000000000H, 03fefe94000000000H
	DQ 03fefe84000000000H, 03fefe74000000000H
	DQ 03fefe64000000000H, 03fefe54000000000H
	DQ 03fefe44000000000H, 03fefe34000000000H
	DQ 03fefe24000000000H, 03fefe14000000000H
	DQ 03fefe04000000000H, 03fefdf4000000000H
	DQ 03fefde4000000000H, 03fefdd4000000000H
	DQ 03fefdc4000000000H, 03fefdb4000000000H
	DQ 03fefda4000000000H, 03fefd94000000000H
	DQ 03fefd84000000000H, 03fefd74000000000H
	DQ 03fefd64000000000H, 03fefd54000000000H
	DQ 03fefd44000000000H, 03fefd34000000000H
	DQ 03fefd28000000000H, 03fefd18000000000H
	DQ 03fefd08000000000H, 03fefcf8000000000H
	DQ 03fefce8000000000H, 03fefcd8000000000H
	DQ 03fefcc8000000000H, 03fefcb8000000000H
	DQ 03fefca8000000000H, 03fefc98000000000H
	DQ 03fefc88000000000H, 03fefc78000000000H
	DQ 03fefc68000000000H, 03fefc58000000000H
	DQ 03fefc48000000000H, 03fefc38000000000H
	DQ 03fefc28000000000H, 03fefc18000000000H
	DQ 03ff0100000000000H, 03ff00fc000000000H
	DQ 03ff00f8000000000H, 03ff00f4000000000H
	DQ 03ff00f0000000000H, 03ff00ec000000000H
	DQ 03ff00e8000000000H, 03ff00e4000000000H
	DQ 03ff00e0000000000H, 03ff00dc000000000H
	DQ 03ff00d8000000000H, 03ff00d4000000000H
	DQ 03ff00d0000000000H, 03ff00cc000000000H
	DQ 03ff00c8000000000H, 03ff00c4000000000H
	DQ 03ff00c0000000000H, 03ff00bc000000000H
	DQ 03ff00b8000000000H, 03ff00b4000000000H
	DQ 03ff00b0000000000H, 03ff00ac000000000H
	DQ 03ff00a8000000000H, 03ff00a4000000000H
	DQ 03ff00a0000000000H, 03ff009c000000000H
	DQ 03ff0098000000000H, 03ff0094000000000H
	DQ 03ff0090000000000H, 03ff008c000000000H
	DQ 03ff0088000000000H, 03ff0084000000000H
	DQ 03ff0080000000000H, 03ff007c000000000H
	DQ 03ff0078000000000H, 03ff0074000000000H
	DQ 03ff0070000000000H, 03ff006c000000000H
	DQ 03ff0068000000000H, 03ff0064000000000H
	DQ 03ff0060000000000H, 03ff005c000000000H
	DQ 03ff0058000000000H, 03ff0054000000000H
	DQ 03ff0050000000000H, 03ff004c000000000H
	DQ 03ff0048000000000H, 03ff0044000000000H
	DQ 03ff0040000000000H, 03ff003c000000000H
	DQ 03ff0038000000000H, 03ff0034000000000H
	DQ 03ff0030000000000H, 03ff002c000000000H
	DQ 03ff0028000000000H, 03ff0024000000000H
	DQ 03ff0020000000000H, 03ff001c000000000H
	DQ 03ff0018000000000H, 03ff0014000000000H
	DQ 03ff0010000000000H, 03ff000c000000000H
	DQ 03ff0008000000000H, 03ff0004000000000H
	DQ 03ff0000000000000H, 0


log2_t2 DQ 0, 0
	DQ 03f2150297c800000H, 03d210909f6306155H
	DQ 03f34332be0000000H, 03d09518ce032f41dH
	DQ 03f3fbe9f60c00000H, 03d4ac9bc570c3b37H
	DQ 03f45a537a3600000H, 03d4325006127af86H
	DQ 03f4b6b4dcbc00000H, 03d3c621fbc9e2ad6H
	DQ 03f5098c916300000H, 03d3f7aec2cad082aH
	DQ 03f537c0264100000H, 03d4bdf2754a94bbeH
	DQ 03f565f52d1000000H, 03d46f089976214ecH
	DQ 03f5942ba5e700000H, 03d2645f4fefad48aH
	DQ 03f5c26390dc00000H, 03d394ecb87dff47fH
	DQ 03f5f09cee0700000H, 03d415d326245addfH
	DQ 03f60f6bdebf80000H, 03d492366d5b7121cH
	DQ 03f62689ffae00000H, 03d3360481790324fH
	DQ 03f63da8d9da00000H, 03d31fe61b7973265H
	DQ 03f654c86d4f00000H, 03d4d5202bf82be32H
	DQ 03f66be8ba1980000H, 03d3a5f8d1a33f641H
	DQ 03f68309c04400000H, 03d4f65693283bc5bH
	DQ 03f69a2b7fdb00000H, 03d4b05a072311cdeH
	DQ 03f6b14df8ea00000H, 03d2da3ce84a38084H
	DQ 03f6c8712b7c00000H, 03d385b88ccf9e4bcH
	DQ 03f6df95179d00000H, 03d4138577c1eb13eH
	DQ 03f6f6b9bd5880000H, 03d4eb2dd71123ec2H
	DQ 03f706ef8e5d40000H, 03d4d0d7b6d01207aH
	DQ 03f712829ae740000H, 03d44fe53f52c6d10H
	DQ 03f71e16045000000H, 03d3f031f657d9491H
	DQ 03f729a9ca9d40000H, 03d45d9663a7e7da0H
	DQ 03f7353dedd500000H, 03d418e26d5dfd1bfH
	DQ 03f740d26dfd00000H, 03d38dc829af0262cH
	DQ 03f74c674b1b00000H, 03d408e4eb4d165e5H
	DQ 03f757fc853500000H, 03d3092346f3f705eH
	DQ 03f763921c5080000H, 03d4e3fa9e85711eeH
	DQ 03f76f281073c0000H, 03d4d59479023862bH
	DQ 03f77abe61a480000H, 03d40c38980430771H
	DQ 03f786550fe880000H, 03d1f92db260b1230H
	DQ 03f791ec1b4580000H, 03d150038c4b502c5H
	DQ 03f79d8383c140000H, 03d48cd3d7b281721H
	DQ 03f7a91b496200000H, 03d42c11f472c64baH
	DQ 03f7b4b36c2d40000H, 03d4d0945eaf29dd2H
	DQ 03f7c04bec2940000H, 03d21e7318833be77H
	DQ 03f7cbe4c95b40000H, 03d462d58105ef8bfH
	DQ 03f7d77e03c980000H, 03d4f85219e901c30H
	DQ 03f7e3179b7a00000H, 03d3c51fbafc4227cH
	DQ 03f7eeb1907240000H, 03d400766896bf3baH
	DQ 03f7fa4be2b840000H, 03d43558362ba179cH
	DQ 03f802f3492900000H, 03d2a3ccb5f4b8d2aH
	DQ 03f8074d69a3c0000H, 03d490b788dcc06d5H
	DQ 03f80d1b1320e0000H, 03d2b412556cf5977H
	DQ 03f812e8eb4fc0000H, 03d45c237732b1f78H
	DQ 03f818b6f23380000H, 03d45669defd365c1H
	DQ 03f81e8527cf00000H, 03d4589b8de73054bH
	DQ 03f824538c2540000H, 03d28fab914103d9cH
	DQ 03f82a221f3900000H, 03d47df970829f58aH
	DQ 03f82ff0e10d60000H, 03d4b0d87d80e4623H
	DQ 03f835bfd1a560000H, 03cf61343d497e17fH
	DQ 03f83b8ef103a0000H, 03d49f7f4ef56f96bH
	DQ 03f8415e3f2b60000H, 03d4859d5f817f2faH
	DQ 03f8472dbc1f80000H, 03d3b2734e7bf7114H
	DQ 03f84cfd67e2e0000H, 03d3753903d1eeba1H
	DQ 03f852cd427880000H, 03d23a058a8f8ba37H
	DQ 03f8589d4be340000H, 03d37c2ec6bdcca43H
	DQ 03f85e6d842620000H, 03d43701d45acf2c4H
	DQ 03f8643deb4420000H, 03d3d6b197832ab27H
	DQ 03f86a0e814020000H, 03d411a9b5557b8ccH
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0bf76adca91cc0000H, 0bd37a1a05bc6b74bH
	DQ 0bf7651cf479c0000H, 0bd461bfa6c8b2465H
	DQ 0bf75f5d28ee00000H, 0bd48fc8fd49e79d0H
	DQ 0bf7599d4678c0000H, 0bd4925a3c7b88c7cH
	DQ 0bf753dd4d1940000H, 0bd4b4606033fb2beH
	DQ 0bf74e1d3ccf00000H, 0bd20210971a52753H
	DQ 0bf7485d1598c0000H, 0bd4812a07c384c12H
	DQ 0bf7429cd77640000H, 0bd4c07239b769baaH
	DQ 0bf73cdc8266c0000H, 0bd44838a3ea90181H
	DQ 0bf7371c166980000H, 0bd288537c7f77e67H
	DQ 0bf7315b937d80000H, 0bd4575a30536968cH
	DQ 0bf72b9af9a280000H, 0bd2c45e11e2e7675H
	DQ 0bf725da48d740000H, 0bd4f8176c38b4ce6H
	DQ 0bf72019811bc0000H, 0bd1a700bd79ac8a3H
	DQ 0bf71a58a26e80000H, 0bd46fb3522850043H
	DQ 0bf71497accf40000H, 0bd4f08e7ddd3e76fH
	DQ 0bf70ed6a03d40000H, 0bd4ff2a8fb0fa804H
	DQ 0bf709157cb7c0000H, 0bd4e2fc0aec80d04H
	DQ 0bf70354423e00000H, 0bd4e332fcfabff4fH
	DQ 0bf6fb25e19f00000H, 0bd21aebe490c8214H
	DQ 0bf6efa310d600000H, 0bd4543b144a21404H
	DQ 0bf6e420122080000H, 0bd45215e0a197589H
	DQ 0bf6d89ce57d00000H, 0bd30cd2d2dbef9ddH
	DQ 0bf6cd198ae980000H, 0bd4370f2ebb44e84H
	DQ 0bf6c196026500000H, 0bd4a99c21180f792H
	DQ 0bf6b6124bee80000H, 0bd11b04ea788b3a9H
	DQ 0bf6aa8e678380000H, 0bd3d2d0d040e5bb2H
	DQ 0bf69f0a552380000H, 0bd201eaa7eae8a79H
	DQ 0bf6938614cc80000H, 0bd2b467aacd98f5bH
	DQ 0bf68801a67d00000H, 0bd4b3840d3f33c6bH
	DQ 0bf67c7d0a3480000H, 0bd25ec92da83377dH
	DQ 0bf670f83ff080000H, 0bd33ab2631d4676dH
	DQ 0bf6657347b000000H, 0bd38fd1349b69dfeH
	DQ 0bf659ee217180000H, 0bd41a8baa44fb97dH
	DQ 0bf64e68cd3380000H, 0bd4d828cbc5c5ff3H
	DQ 0bf642e34af500000H, 0bd44361aa8b3c316H
	DQ 0bf6375d9ab400000H, 0bd49e932f704de99H
	DQ 0bf62bd7bc6f80000H, 0bd42bd57c254b5e3H
	DQ 0bf62051b02600000H, 0bd167df372942ee0H
	DQ 0bf614cb75d580000H, 0bd3c729ec54d36cdH
	DQ 0bf609450d7d00000H, 0bd490ea5c63bcdf1H
	DQ 0bf5fb7cee3700000H, 0bd2d803cea0e76a9H
	DQ 0bf5e46f655d00000H, 0bd4d398b96b4f4d5H
	DQ 0bf5cd61806b00000H, 0bd4ea2cca3058bbdH
	DQ 0bf5b6533f5e00000H, 0bd3f3e6ba7bbdd88H
	DQ 0bf59f44a23200000H, 0bd442ddc05082614H
	DQ 0bf58835a8e500000H, 0bd40498534d8fe6dH
	DQ 0bf57126537400000H, 0bd2fa2a0fd4fca1cH
	DQ 0bf55a16a1db00000H, 0bd4efd6c9949b49bH
	DQ 0bf54306941900000H, 0bd4975aa0b715781H
	DQ 0bf52bf62a2a00000H, 0bd4b3ae86d7c16e7H
	DQ 0bf514e5640c00000H, 0bd3064bec2477c3fH
	DQ 0bf4fba8837600000H, 0bd20f3d834ceb438H
	DQ 0bf4cd85866800000H, 0bd433742d88c7aa2H
	DQ 0bf49f61d0ea00000H, 0bd48f98b25223470H
	DQ 0bf4713d62f600000H, 0bd4957c30af53ad3H
	DQ 0bf443183c8600000H, 0bd48218d1305b92fH
	DQ 0bf414f25d9400000H, 0bd492239f241b9b9H
	DQ 0bf3cd978c3800000H, 0bcd0642236ea2a75H
	DQ 0bf37148ec2800000H, 0bd40dfe447087803H
	DQ 0bf314f8daf400000H, 0bd3e3bcf284f9cb2H
	DQ 0bf2714eb11800000H, 0bd4e94d8dd523885H
	DQ 0bf1715193b000000H, 0bd17d35d328b2afeH
	DQ 0, 0

rcp_t3	DQ 03ff7154740000000H, 03ff71545c0000000H
	DQ 03ff7154440000000H, 03ff7154300000000H
	DQ 03ff7154180000000H, 03ff7154000000000H
	DQ 03ff7153e80000000H, 03ff7153d40000000H
	DQ 03ff7153bc0000000H, 03ff7153a40000000H
	DQ 03ff71538c0000000H, 03ff7153780000000H
	DQ 03ff7153600000000H, 03ff7153480000000H
	DQ 03ff7153300000000H, 03ff7153180000000H
	DQ 03ff7153040000000H, 03ff7152ec0000000H
	DQ 03ff7152d40000000H, 03ff7152bc0000000H
	DQ 03ff7152a80000000H, 03ff7152900000000H
	DQ 03ff7152780000000H, 03ff7152600000000H
	DQ 03ff71524c0000000H, 03ff7152340000000H
	DQ 03ff71521c0000000H, 03ff7152040000000H
	DQ 03ff7151ec0000000H, 03ff7151d80000000H
	DQ 03ff7151c00000000H, 03ff7151a80000000H
	DQ 03ff7151900000000H, 03ff71517c0000000H
	DQ 03ff7151640000000H, 03ff71514c0000000H
	DQ 03ff7151340000000H, 03ff71511c0000000H
	DQ 03ff7151080000000H, 03ff7150f00000000H
	DQ 03ff7150d80000000H, 03ff7150c00000000H
	DQ 03ff7150ac0000000H, 03ff7150940000000H
	DQ 03ff71507c0000000H, 03ff7150640000000H
	DQ 03ff7150500000000H, 03ff7150380000000H
	DQ 03ff7150200000000H, 03ff7150080000000H
	DQ 03ff714ff00000000H, 03ff714fdc0000000H
	DQ 03ff714fc40000000H, 03ff714fac0000000H
	DQ 03ff714f940000000H, 03ff714f800000000H
	DQ 03ff714f680000000H, 03ff714f500000000H
	DQ 03ff714f380000000H, 03ff714f240000000H
	DQ 03ff714f0c0000000H, 03ff714ef40000000H
	DQ 03ff714edc0000000H, 03ff714ec40000000H
	DQ 03ff714eb00000000H, 03ff714e980000000H
	DQ 03ff714e800000000H, 03ff714e680000000H
	DQ 03ff714e540000000H, 03ff714e3c0000000H
	DQ 03ff714e240000000H, 03ff714e0c0000000H
	DQ 03ff714df80000000H, 03ff714de00000000H
	DQ 03ff714dc80000000H, 03ff714db00000000H
	DQ 03ff714d980000000H, 03ff714d840000000H
	DQ 03ff714d6c0000000H, 03ff714d540000000H
	DQ 03ff714d3c0000000H, 03ff714d280000000H
	DQ 03ff714d100000000H, 03ff714cf80000000H
	DQ 03ff714ce00000000H, 03ff714ccc0000000H
	DQ 03ff714cb40000000H, 03ff714c9c0000000H
	DQ 03ff714c840000000H, 03ff714c6c0000000H
	DQ 03ff714c580000000H, 03ff714c400000000H
	DQ 03ff714c280000000H, 03ff714c100000000H
	DQ 03ff714bfc0000000H, 03ff714be40000000H
	DQ 03ff714bcc0000000H, 03ff714bb40000000H
	DQ 03ff714ba00000000H, 03ff714b880000000H
	DQ 03ff714b700000000H, 03ff714b580000000H
	DQ 03ff714b400000000H, 03ff714b2c0000000H
	DQ 03ff714b140000000H, 03ff714afc0000000H
	DQ 03ff714ae40000000H, 03ff714ad00000000H
	DQ 03ff714ab80000000H, 03ff714aa00000000H
	DQ 03ff714a880000000H, 03ff714a740000000H
	DQ 03ff714a5c0000000H, 03ff714a440000000H
	DQ 03ff714a2c0000000H, 03ff714a140000000H
	DQ 03ff714a000000000H, 03ff7149e80000000H
	DQ 03ff7149d00000000H, 03ff7149b80000000H
	DQ 03ff7149a40000000H, 03ff71498c0000000H
	DQ 03ff7149740000000H, 03ff71495c0000000H
	DQ 03ff7149480000000H, 03ff7149300000000H
	DQ 03ff7149180000000H, 03ff7149000000000H
	DQ 03ff715a380000000H, 03ff715a2c0000000H
	DQ 03ff715a240000000H, 03ff715a180000000H
	DQ 03ff715a0c0000000H, 03ff715a000000000H
	DQ 03ff7159f40000000H, 03ff7159e80000000H
	DQ 03ff7159dc0000000H, 03ff7159d00000000H
	DQ 03ff7159c40000000H, 03ff7159bc0000000H
	DQ 03ff7159b00000000H, 03ff7159a40000000H
	DQ 03ff7159980000000H, 03ff71598c0000000H
	DQ 03ff7159800000000H, 03ff7159740000000H
	DQ 03ff7159680000000H, 03ff7159600000000H
	DQ 03ff7159540000000H, 03ff7159480000000H
	DQ 03ff71593c0000000H, 03ff7159300000000H
	DQ 03ff7159240000000H, 03ff7159180000000H
	DQ 03ff71590c0000000H, 03ff7159000000000H
	DQ 03ff7158f80000000H, 03ff7158ec0000000H
	DQ 03ff7158e00000000H, 03ff7158d40000000H
	DQ 03ff7158c80000000H, 03ff7158bc0000000H
	DQ 03ff7158b00000000H, 03ff7158a40000000H
	DQ 03ff7158980000000H, 03ff7158900000000H
	DQ 03ff7158840000000H, 03ff7158780000000H
	DQ 03ff71586c0000000H, 03ff7158600000000H
	DQ 03ff7158540000000H, 03ff7158480000000H
	DQ 03ff71583c0000000H, 03ff7158300000000H
	DQ 03ff7158280000000H, 03ff71581c0000000H
	DQ 03ff7158100000000H, 03ff7158040000000H
	DQ 03ff7157f80000000H, 03ff7157ec0000000H
	DQ 03ff7157e00000000H, 03ff7157d40000000H
	DQ 03ff7157cc0000000H, 03ff7157c00000000H
	DQ 03ff7157b40000000H, 03ff7157a80000000H
	DQ 03ff71579c0000000H, 03ff7157900000000H
	DQ 03ff7157840000000H, 03ff7157780000000H
	DQ 03ff71576c0000000H, 03ff7157640000000H
	DQ 03ff7157580000000H, 03ff71574c0000000H
	DQ 03ff7157400000000H, 03ff7157340000000H
	DQ 03ff7157280000000H, 03ff71571c0000000H
	DQ 03ff7157100000000H, 03ff7157040000000H
	DQ 03ff7156fc0000000H, 03ff7156f00000000H
	DQ 03ff7156e40000000H, 03ff7156d80000000H
	DQ 03ff7156cc0000000H, 03ff7156c00000000H
	DQ 03ff7156b40000000H, 03ff7156a80000000H
	DQ 03ff7156a00000000H, 03ff7156940000000H
	DQ 03ff7156880000000H, 03ff71567c0000000H
	DQ 03ff7156700000000H, 03ff7156640000000H
	DQ 03ff7156580000000H, 03ff71564c0000000H
	DQ 03ff7156400000000H, 03ff7156380000000H
	DQ 03ff71562c0000000H, 03ff7156200000000H
	DQ 03ff7156140000000H, 03ff7156080000000H
	DQ 03ff7155fc0000000H, 03ff7155f00000000H
	DQ 03ff7155e40000000H, 03ff7155d80000000H
	DQ 03ff7155d00000000H, 03ff7155c40000000H
	DQ 03ff7155b80000000H, 03ff7155ac0000000H
	DQ 03ff7155a00000000H, 03ff7155940000000H
	DQ 03ff7155880000000H, 03ff71557c0000000H
	DQ 03ff7155700000000H, 03ff7155680000000H
	DQ 03ff71555c0000000H, 03ff7155500000000H
	DQ 03ff7155440000000H, 03ff7155380000000H
	DQ 03ff71552c0000000H, 03ff7155200000000H
	DQ 03ff7155140000000H, 03ff71550c0000000H
	DQ 03ff7155000000000H, 03ff7154f40000000H
	DQ 03ff7154e80000000H, 03ff7154dc0000000H
	DQ 03ff7154d00000000H, 03ff7154c40000000H
	DQ 03ff7154b80000000H, 03ff7154ac0000000H
	DQ 03ff7154a40000000H, 03ff7154980000000H
	DQ 03ff71548c0000000H, 03ff7154800000000H
	DQ 03ff7154740000000H, 0

log2_t3	DQ 0, 0
	DQ 03eb80000c0000000H, 03d4722f0009be959H
	DQ 03ec80001a0000000H, 03d45e6576cb6dc2eH
	DQ 03ed10001a0000000H, 03d480762a98bdb6aH
	DQ 03ed7000300000000H, 03d231a4c495ec799H
	DQ 03edd0004b0000000H, 03d4926846928cda3H
	DQ 03ee1800368000000H, 03d4527509fdde667H
	DQ 03ee4000470000000H, 03d44fbd1292ae6daH
	DQ 03ee70005d8000000H, 03d4ef91cb226fd03H
	DQ 03eea000778000000H, 03d40978c9dc43b2eH
	DQ 03eed000948000000H, 03d33ae75bbe97951H
	DQ 03eef800af0000000H, 03d2d81b9a1639c05H
	DQ 03ef140068c000000H, 03d3d3aa4a1dd8452H
	DQ 03ef2c007b8000000H, 03d4d7bbe110bfb09H
	DQ 03ef4400900000000H, 03d43fbcb9ab61086H
	DQ 03ef5c00a60000000H, 03d421d94dff79062H
	DQ 03ef7000b98000000H, 03d43b8e9647408a2H
	DQ 03ef8800d24000000H, 03d4fd8ce39e1fdd4H
	DQ 03efa000ecc000000H, 03d439ab84e20bc42H
	DQ 03efb80108c000000H, 03d3dfd83269c6ac2H
	DQ 03efcc01214000000H, 03d3ca32ecd8004e0H
	DQ 03efe401400000000H, 03d47b472936c6005H
	DQ 03effc01608000000H, 03d31736ce8ef8e21H
	DQ 03f00a00c14000000H, 03d0617cfc138ccabH
	DQ 03f01400cfe000000H, 03d4e6d11d620108aH
	DQ 03f02000e26000000H, 03d2451827455b88dH
	DQ 03f02c00f58000000H, 03d435e7b8e426950H
	DQ 03f03801098000000H, 03d3296f937d77647H
	DQ 03f044011e4000000H, 03d2b6df6e16cae71H
	DQ 03f04e01302000000H, 03d2ff9376a2ea421H
	DQ 03f05a01464000000H, 03d438ebd204c10d2H
	DQ 03f066015d4000000H, 03d2b09d7e2fc6debH
	DQ 03f07201750000000H, 03d099925641f4f35H
	DQ 03f07c01896000000H, 03cedfbf4f07288e3H
	DQ 03f08801a28000000H, 03d32a0616748ca2aH
	DQ 03f09401bc6000000H, 03d49cc1e9cba43abH
	DQ 03f0a001d72000000H, 03d41ebd38173f5dbH
	DQ 03f0ac01f2a000000H, 03d41af6954471a92H
	DQ 03f0b6020a2000000H, 03d44a88bd59f4b89H
	DQ 03f0c202272000000H, 03d137160b27044e6H
	DQ 03f0ce0244c000000H, 03d47d7f6c97ef2fcH
	DQ 03f0da02634000000H, 03d44e605e1bb0db2H
	DQ 03f0e4027d4000000H, 03d459d8417d4ebcfH
	DQ 03f0f0029d4000000H, 03cf5ca7f05f05027H
	DQ 03f0fc02bde000000H, 03d4363b1c234f566H
	DQ 03f104016fb000000H, 03d3b7b6ed1035771H
	DQ 03f109017df000000H, 03d38699e204367efH
	DQ 03f10f018f6000000H, 03d44924bd9581118H
	DQ 03f11501a14000000H, 03d2252e80eb13b47H
	DQ 03f11b01b37000000H, 03d4c3c3381ce38a0H
	DQ 03f12101c61000000H, 03d4b88d24672a90dH
	DQ 03f12601d5e000000H, 03d4e1fc955055fefH
	DQ 03f12c01e94000000H, 03d36e18a547f3bc2H
	DQ 03f13201fd0000000H, 03ce9cbf2c6119ad4H
	DQ 03f13802111000000H, 03d4d03232a579871H
	DQ 03f13d02222000000H, 03d4d5c820ab96aa1H
	DQ 03f14302370000000H, 03d2ff6235a37497cH
	DQ 03f149024c3000000H, 03d4a4461e61bb95eH
	DQ 03f14f0261d000000H, 03d4431272c3ec2f0H
	DQ 03f15402742000000H, 03d424e2b9e3a8113H
	DQ 03f15a028a7000000H, 03d4a40baad7a3180H
	DQ 03f16002a13000000H, 03d33b2fef1b1988bH
	DQ 03f16602b85000000H, 03d01893f34559377H
	DQ 03f16c02cfc000000H, 03d4ffe120fb3ef44H
	DQ 03f17102e3b000000H, 03d120082c162d124H
	DQ 03f17702fbe000000H, 03d3e587c5b282967H
	DQ 03f17d03148000000H, 03d1df8f956673eacH
	DQ 03f183032d7000000H, 03d4ff8cd42de4f13H
	DQ 03f1880342a000000H, 03c83f84104915062H
	DQ 03f18e035c5000000H, 03d3484a765ad0e81H
	DQ 03f19403766000000H, 03d4c2a7e827b5b7cH
	DQ 03f19a0390e000000H, 03d45b9d9e619a5feH
	DQ 03f19f03a74000000H, 03d4389fde2d65d47H
	DQ 03f1a503c27000000H, 03d4b2175bb6d7bccH
	DQ 03f1ab03de1000000H, 03d34c0cf5c760a80H
	DQ 03f1b103fa1000000H, 03d046edae6d3e9a5H
	DQ 03f1b704166000000H, 03d4fd521af377bfcH
	DQ 03f1bc042e6000000H, 03d0cf59fe6ab1bfdH
	DQ 03f1c2044b7000000H, 03d3ccd20cc753db5H
	DQ 03f1c80468f000000H, 03d152df2a92669ccH
	DQ 03f1ce0486c000000H, 03d4e8cfdbe6ff5d7H
	DQ 03f1d3049ff000000H, 03d4e51b637245449H
	DQ 03f1d904be9000000H, 03d30855ccdda9dd0H
	DQ 03f1df04dd8000000H, 03d49dc0197d07430H
	DQ 03f1e504fce000000H, 03d431dc9bd27e20aH
	DQ 03f1ea05175000000H, 03d40ae402534fea4H
	DQ 03f1f005376000000H, 03d47fa77710aad2aH
	DQ 03f1f60557e000000H, 03d2bbdb4e113204bH
	DQ 03f1fc0578b000000H, 03d4d8d3b6e50d246H
	DQ 03f20102ccf800000H, 03d4bd3fc06a15de9H
	DQ 03f20382daf800000H, 03d4d93a1498ec6c9H
	DQ 03f20682ebf800000H, 03d33cb6df935a7f0H
	DQ 03f20982fd2000000H, 03d4de1089920cfdaH
	DQ 03f20c830e8000000H, 03d4985b012a6b1acH
	DQ 03f20f031d2000000H, 03d4913e1b9ba2290H
	DQ 03f212032ee000000H, 03d1624a57980edbcH
	DQ 03f2150340c800000H, 03d441ee709125ff3H
	DQ 03f2180352e800000H, 03d3a45e575f48b5dH
	DQ 03f21a83622800000H, 03d3501dd1e238a6cH
	DQ 03f21d8374a000000H, 03d4191bc1ea6aa2cH
	DQ 03f22083875000000H, 03ce323237921f7b0H
	DQ 03f223839a2800000H, 03d46b179d0781ff4H
	DQ 03f22683ad3800000H, 03d44c09dda134362H
	DQ 03f22903bd4000000H, 03d4652e31de50175H
	DQ 03f22c03d0b000000H, 03d137d77dcd68a32H
	DQ 03f22f03e44800000H, 03d4636fb2840cc02H
	DQ 03f23203f81800000H, 03d41a8e1979c27f4H
	DQ 03f2348408c000000H, 03d410dbf84163334H
	DQ 03f237841ce800000H, 03d4a8e042a7d4e75H
	DQ 03f23a84314800000H, 03d3772593772be29H
	DQ 03f23d8445d800000H, 03d223d4b2e8c031dH
	DQ 03f24004572000000H, 03d0c8072ca9dad06H
	DQ 03f243046c0800000H, 03d315a83ee313d33H
	DQ 03f24604812000000H, 03d473dc4088b7c68H
	DQ 03f24904967000000H, 03d3af34ea9dceae1H
	DQ 03f24c04abf000000H, 03d36c20ba0653485H
	DQ 03f24e84be0000000H, 03d39a63c847be3ffH
	DQ 03f25184d3d800000H, 03d48ca7750a55975H
	DQ 03f25484e9e800000H, 03d38db2a2d1381bbH
	DQ 03f25785002800000H, 03d2ef2461fbe7983H
	DQ 03f25a0512d800000H, 03d2c153bc40c395cH
	DQ 03f25d05297000000H, 03d4064fc5a39c232H
	DQ 03f26005404000000H, 03d070d1f7c4b597eH
	DQ 03f26305573800000H, 03d4a28e9bdbbc457H
	DQ 03f265856a8800000H, 03d474989ecc252f3H
	DQ 03f2688581e000000H, 03d4e13090fc01d57H
	DQ 03f26b85997000000H, 03d391227c8678403H
	DQ 03f26e85b13000000H, 03d155e22f244140dH
	DQ 0bf170fd210000000H, 0bd24caa429329aeeH
	DQ 0bf16dfd2ce000000H, 0bd4cb96d8562dc37H
	DQ 0bf16bfd34d000000H, 0bd2813e19b9dbfb8H
	DQ 0bf168fd409000000H, 0bd34c1a453011cc5H
	DQ 0bf165fd4c3000000H, 0bd4cd61ac43e09bcH
	DQ 0bf162fd57c000000H, 0bd4d64cef90ca8baH
	DQ 0bf15ffd634000000H, 0bd3819d713b1c267H
	DQ 0bf15cfd6ea000000H, 0bd319cda711db032H
	DQ 0bf159fd79e000000H, 0bd43a950c71a6171H
	DQ 0bf156fd851000000H, 0bd393b25eece00b9H
	DQ 0bf153fd902000000H, 0bd43ab308b5fe712H
	DQ 0bf151fd977000000H, 0bd4ca5e736256734H
	DQ 0bf14efda26000000H, 0bd40886b3b9c924dH
	DQ 0bf14bfdad3000000H, 0bd428441ff31aa38H
	DQ 0bf148fdb7f000000H, 0bd14cb421675c431H
	DQ 0bf145fdc29000000H, 0bcf8fb590baebb8dH
	DQ 0bf142fdcd1000000H, 0bd3a1f2ca38e93f3H
	DQ 0bf13ffdd78000000H, 0bd2dc25e83d52ed1H
	DQ 0bf13cfde1d000000H, 0bd3fd5b6efa081f3H
	DQ 0bf13afde8a000000H, 0bd49d89dd4f2bf07H
	DQ 0bf137fdf2d000000H, 0bd3e4f3d5d3a13b4H
	DQ 0bf134fdfce000000H, 0bd428fd96a5f7723H
	DQ 0bf131fe06e000000H, 0bd20452b288690a5H
	DQ 0bf12efe10c000000H, 0bd1d5f7c7e56ea2dH
	DQ 0bf12bfe1a8000000H, 0bd415fc47d421debH
	DQ 0bf128fe243000000H, 0bd3a598ca8dc214bH
	DQ 0bf125fe2dc000000H, 0bd4712f1d7350f14H
	DQ 0bf122fe374000000H, 0bd3e24878efa43e1H
	DQ 0bf120fe3d8000000H, 0bd48adffee23f9f0H
	DQ 0bf11dfe46d000000H, 0bd4d81e00aec2d96H
	DQ 0bf11afe501000000H, 0bd406eddef9956b1H
	DQ 0bf117fe593000000H, 0bd4174f65e105551H
	DQ 0bf114fe624000000H, 0bcf284c306b71311H
	DQ 0bf111fe6b2000000H, 0bd4dcc69dfedbec3H
	DQ 0bf10efe740000000H, 0bd323b7cee38aa4bH
	DQ 0bf10bfe7cc000000H, 0bd144104fd28c140H
	DQ 0bf108fe856000000H, 0bd34171a36d6a695H
	DQ 0bf106fe8b1000000H, 0bd4354a0acea06cdH
	DQ 0bf103fe939000000H, 0bd2eb1b1fae67526H
	DQ 0bf100fe9bf000000H, 0bd343a73fc467e03H
	DQ 0bf0fbfd486000000H, 0bd4aa705ed090ecaH
	DQ 0bf0f5fd58c000000H, 0bd4949cd0d4cde8eH
	DQ 0bf0effd690000000H, 0bd2816308340bd3dH
	DQ 0bf0e9fd790000000H, 0bcfb47fd2e8624a6H
	DQ 0bf0e3fd88c000000H, 0bd338fca5233867dH
	DQ 0bf0ddfd986000000H, 0bcf9cf14342e7c21H
	DQ 0bf0d9fda2a000000H, 0bd3388827d84b6e0H
	DQ 0bf0d3fdb1e000000H, 0bd3b3e0a6d6a2247H
	DQ 0bf0cdfdc0e000000H, 0bd4f92aec1df2a86H
	DQ 0bf0c7fdcfc000000H, 0bd4f9f3aa2200d30H
	DQ 0bf0c1fdde8000000H, 0bd3b894b32ad9b9fH
	DQ 0bf0bbfded0000000H, 0bd3405d8d2c46051H
	DQ 0bf0b5fdfb4000000H, 0bd445a0bd420a715H
	DQ 0bf0affe096000000H, 0bd39940136e0a90fH
	DQ 0bf0abfe12a000000H, 0bd46b0a6f2af86bbH
	DQ 0bf0a5fe206000000H, 0bd4bf4a2ca335408H
	DQ 0bf09ffe2e0000000H, 0bd3ea2d6b12e4d93H
	DQ 0bf099fe3b6000000H, 0bd40c6fd5fb7f840H
	DQ 0bf093fe48a000000H, 0bce555685c9c3116H
	DQ 0bf08dfe558000000H, 0bd4dfc70dfa2e7c3H
	DQ 0bf087fe626000000H, 0bd337897b84ac785H
	DQ 0bf081fe6f0000000H, 0bd1ca71ac6acd2d7H
	DQ 0bf07bfe7b6000000H, 0bd370c682f1de078H
	DQ 0bf077fe838000000H, 0bd45185d76c79d4cH
	DQ 0bf071fe8fa000000H, 0bd33bb0cdd985699H
	DQ 0bf06bfe9b8000000H, 0bd3976c00642b301H
	DQ 0bf065fea72000000H, 0bd4db1e6f5a163e7H
	DQ 0bf05ffeb2a000000H, 0bd4cc11808263596H
	DQ 0bf059febe0000000H, 0bd33d1dff912d171H
	DQ 0bf053fec92000000H, 0bd24a5ae52911a3aH
	DQ 0bf04dfed40000000H, 0bd3d050f249f8edcH
	DQ 0bf047fedec000000H, 0bd27d102dd924b0eH
	DQ 0bf043fee5c000000H, 0bd3e62957baad081H
	DQ 0bf03dfef02000000H, 0bd4376ad4524f2a0H
	DQ 0bf037fefa6000000H, 0bd2752913877e949H
	DQ 0bf031ff046000000H, 0bd292cb26a5ff847H
	DQ 0bf02bff0e2000000H, 0bd44da42ec6a2baeH
	DQ 0bf025ff17c000000H, 0bd4181e4056b600bH
	DQ 0bf01fff212000000H, 0bd4c420ca7722725H
	DQ 0bf019ff2a6000000H, 0bd451ab99454bc09H
	DQ 0bf015ff306000000H, 0bd4f4702fac61211H
	DQ 0bf00fff396000000H, 0bd23ccbf691e23e3H
	DQ 0bf009ff420000000H, 0bd48b7d85ede8a3bH
	DQ 0bf003ff4a8000000H, 0bd4a94f94a602836H
	DQ 0beffbfea5c000000H, 0bd35151ebd4248b6H
	DQ 0befeffeb60000000H, 0bd31312ebaebde60H
	DQ 0befe3fec5c000000H, 0bd44bf0e08b2a851H
	DQ 0befd7fed54000000H, 0bd3dfbe044563cddH
	DQ 0befcbfee44000000H, 0bd47553a6bb2cf4dH
	DQ 0befc3feee4000000H, 0bd02b3272c9e1514H
	DQ 0befb7fefc8000000H, 0bd4655cdd79568b8H
	DQ 0befabff0a8000000H, 0bd4998c8c6a29955H
	DQ 0bef9fff184000000H, 0bd35e84003879074H
	DQ 0bef93ff258000000H, 0bd34cfa09595f318H
	DQ 0bef87ff324000000H, 0bd47f3d66389e086H
	DQ 0bef7bff3ec000000H, 0bd43982f0dd1df79H
	DQ 0bef6fff4ac000000H, 0bd4d54d70b7407c7H
	DQ 0bef63ff568000000H, 0bd4529cb1e4119e9H
	DQ 0bef5bff5e0000000H, 0bd4ea8cf63b0e57aH
	DQ 0bef4fff694000000H, 0bd1a872dd1f9867bH
	DQ 0bef43ff73c000000H, 0bd46113f80238647H
	DQ 0bef37ff7e0000000H, 0bd46e9d9772d7da6H
	DQ 0bef2bff880000000H, 0bd276ac184b1770cH
	DQ 0bef1fff918000000H, 0bd171e07ff78e451H
	DQ 0bef13ff9a8000000H, 0bd3c0a102a88bdf6H
	DQ 0bef07ffa34000000H, 0bd2cfa098be9e4a8H
	DQ 0beef7ff570000000H, 0bd3d205955bedc7eH
	DQ 0beee7ff618000000H, 0bd47b79acbd1c3d4H
	DQ 0beecfff710000000H, 0bd37b870ff9b8582H
	DQ 0beeb7ff7f8000000H, 0bd3c31fb1038dd6dH
	DQ 0bee9fff8d0000000H, 0bd4e6de6a68aa227H
	DQ 0bee87ff9a0000000H, 0bd4cdaf09ce4e699H
	DQ 0bee6fffa68000000H, 0bd32c03059eee94bH
	DQ 0bee57ffb20000000H, 0bd1fead0c4719fccH
	DQ 0bee3fffbc8000000H, 0bd39656642e976adH
	DQ 0bee2fffc30000000H, 0bd46c7329db21925H
	DQ 0bee17ffcc8000000H, 0bd389eab4517a5ceH
	DQ 0bedffffaa0000000H, 0bd3fdf0e3da560d7H
	DQ 0bedcfffba0000000H, 0bd0a7c3d4511fbcbH
	DQ 0bed9fffc80000000H, 0bd0780884d13df75H
	DQ 0bed6fffd40000000H, 0bd3ec0a3e439ae99H
	DQ 0bed3fffdf0000000H, 0bd36c139bbface01H
	DQ 0bed0fffe80000000H, 0bd4578e60a3c176bH
	DQ 0becbfffe00000000H, 0bd3b5254714383f2H
	DQ 0bec7fffe80000000H, 0bd4764e185e2f8bbH
	DQ 0bec1ffff20000000H, 0bd4c67c0d84712a6H
	DQ 0beb7ffff40000000H, 0bd3f05250dd0685fH
	DQ 0bea7ffff80000000H, 0bd40b553538e0e0cH
	DQ 0, 0


;   log2 polynomial coefficients
clv     DQ 03fc47fd462b3b816H, 03e79c3a6966457eeH	; c1|c3
	DQ 0bfb550472a8bb463H, 0bfd62e4346694107H	; c2|c4


;-------Table T, D  so that movapd gives [ D | T ]
;-------Note that the exponent field of T is set to 000  (instead of 3ffH)
exp2_tbl DQ 03ff0000000000000H, 00000000000000000H
	 DQ 03ff0163da9fb3335H, 03c9b61299ab8cdb7H
	 DQ 03ff02c9a3e778061H, 0bc719083535b085dH
	 DQ 03ff04315e86e7f85H, 0bc90a31c1977c96eH
	 DQ 03ff059b0d3158574H, 03c8d73e2a475b465H
	 DQ 03ff0706b29ddf6deH, 0bc8c91dfe2b13c26H
	 DQ 03ff0874518759bc8H, 03c6186be4bb284ffH
	 DQ 03ff09e3ecac6f383H, 03c91487818316135H
	 DQ 03ff0b5586cf9890fH, 03c98a62e4adc610aH
	 DQ 03ff0cc922b7247f7H, 03c901edc16e24f71H
	 DQ 03ff0e3ec32d3d1a2H, 03c403a1727c57b52H
	 DQ 03ff0fb66affed31bH, 0bc6b9bedc44ebd7bH
	 DQ 03ff11301d0125b51H, 0bc96c51039449b39H
	 DQ 03ff12abdc06c31ccH, 0bc51b514b36ca5c7H
	 DQ 03ff1429aaea92de0H, 0bc932fbf9af1369eH
	 DQ 03ff15a98c8a58e51H, 03c82406ab9eeab09H
	 DQ 03ff172b83c7d517bH, 0bc819041b9d78a75H
	 DQ 03ff18af9388c8deaH, 0bc911023d1970f6bH
	 DQ 03ff1a35beb6fcb75H, 03c8e5b4c7b4968e4H
	 DQ 03ff1bbe084045cd4H, 0bc995386352ef607H
	 DQ 03ff1d4873168b9aaH, 03c9e016e00a2643cH
	 DQ 03ff1ed5022fcd91dH, 0bc91df98027bb78bH
	 DQ 03ff2063b88628cd6H, 03c8dc775814a8494H
	 DQ 03ff21f49917ddc96H, 03c82a97e9494a5edH
	 DQ 03ff2387a6e756238H, 03c99b07eb6c70572H
	 DQ 03ff251ce4fb2a63fH, 03c8ac155bef4f4a4H
	 DQ 03ff26b4565e27cddH, 03c82bd339940e9d9H
	 DQ 03ff284dfe1f56381H, 0bc9a4c3a8c3f0d7dH
	 DQ 03ff29e9df51fdee1H, 03c8612e8afad1255H
	 DQ 03ff2b87fd0dad990H, 0bc410adcd6381aa3H
	 DQ 03ff2d285a6e4030bH, 03c90024754db41d4H
	 DQ 03ff2ecafa93e2f56H, 03c71ca0f45d52383H
	 DQ 03ff306fe0a31b715H, 03c86f46ad23182e4H
	 DQ 03ff32170fc4cd831H, 03c8a9ce78e18047cH
	 DQ 03ff33c08b26416ffH, 03c932721843659a5H
	 DQ 03ff356c55f929ff1H, 0bc8b5cee5c4e4628H
	 DQ 03ff371a7373aa9cbH, 0bc963aeabf42eae1H
	 DQ 03ff38cae6d05d866H, 0bc9e958d3c9904bcH
	 DQ 03ff3a7db34e59ff7H, 0bc75e436d661f5e2H
	 DQ 03ff3c32dc313a8e5H, 0bc9efff8375d29c3H
	 DQ 03ff3dea64c123422H, 03c8ada0911f09ebbH
	 DQ 03ff3fa4504ac801cH, 0bc97d023f956f9f3H
	 DQ 03ff4160a21f72e2aH, 0bc5ef3691c309278H
	 DQ 03ff431f5d950a897H, 0bc81c7dde35f7998H
	 DQ 03ff44e086061892dH, 03c489b7a04ef80cfH
	 DQ 03ff46a41ed1d0057H, 03c9c944bd1648a76H
	 DQ 03ff486a2b5c13cd0H, 03c73c1a3b69062f0H
	 DQ 03ff4a32af0d7d3deH, 03c99cb62f3d1be56H
	 DQ 03ff4bfdad5362a27H, 03c7d4397afec42e2H
	 DQ 03ff4dcb299fddd0dH, 03c98ecdbbc6a7833H
	 DQ 03ff4f9b2769d2ca7H, 0bc94b309d25957e3H
	 DQ 03ff516daa2cf6642H, 0bc8f768569bd93eeH
	 DQ 03ff5342b569d4f82H, 0bc807abe1db13cacH
	 DQ 03ff551a4ca5d920fH, 0bc8d689cefede59aH
	 DQ 03ff56f4736b527daH, 03c99bb2c011d93acH
	 DQ 03ff58d12d497c7fdH, 03c8295e15b9a1de7H
	 DQ 03ff5ab07dd485429H, 03c96324c054647acH
	 DQ 03ff5c9268a5946b7H, 03c3c4b1b816986a2H
	 DQ 03ff5e76f15ad2148H, 03c9ba6f93080e65dH
	 DQ 03ff605e1b976dc09H, 0bc93e2429b56de47H
	 DQ 03ff6247eb03a5585H, 0bc9383c17e40b496H
	 DQ 03ff6434634ccc320H, 0bc8c483c759d8932H
	 DQ 03ff6623882552225H, 0bc9bb60987591c33H
	 DQ 03ff68155d44ca973H, 03c6038ae44f73e64H
	 DQ 03ff6a09e667f3bcdH, 0bc9bdd3413b26455H
	 DQ 03ff6c012750bdabfH, 0bc72895667ff0b0cH
	 DQ 03ff6dfb23c651a2fH, 0bc6bbe3a683c88aaH
	 DQ 03ff6ff7df9519484H, 0bc883c0f25860ef6H
	 DQ 03ff71f75e8ec5f74H, 0bc816e4786887a99H
	 DQ 03ff73f9a48a58174H, 0bc90a8d96c65d53bH
	 DQ 03ff75feb564267c9H, 0bc90245957316dd3H
	 DQ 03ff780694fde5d3fH, 03c9866b80a02162cH
	 DQ 03ff7a11473eb0187H, 0bc841577ee04992fH
	 DQ 03ff7c1ed0130c132H, 03c9f124cd1164dd5H
	 DQ 03ff7e2f336cf4e62H, 03c705d02ba15797eH
	 DQ 03ff80427543e1a12H, 0bc927c86626d972aH
	 DQ 03ff82589994cce13H, 0bc9d4c1dd41532d7H
	 DQ 03ff8471a4623c7adH, 0bc88d684a341cdfbH
	 DQ 03ff868d99b4492edH, 0bc9fc6f89bd4f6baH
	 DQ 03ff88ac7d98a6699H, 03c9994c2f37cb53aH
	 DQ 03ff8ace5422aa0dbH, 03c96e9f156864b26H
	 DQ 03ff8cf3216b5448cH, 0bc70d55e32e9e3aaH
	 DQ 03ff8f1ae99157736H, 03c85cc13a2e3976cH
	 DQ 03ff9145b0b91ffc6H, 0bc9dd6792e582523H
	 DQ 03ff93737b0cdc5e5H, 0bc675fc781b57ebbH
	 DQ 03ff95a44cbc8520fH, 0bc764b7c96a5f039H
	 DQ 03ff97d829fde4e50H, 0bc9d185b7c1b85d0H
	 DQ 03ff9a0f170ca07baH, 0bc9173bd91cee632H
	 DQ 03ff9c49182a3f090H, 03c7c7c46b071f2beH
	 DQ 03ff9e86319e32323H, 03c7824ca78e64c6eH
	 DQ 03ffa0c667b5de565H, 0bc9359495d1cd532H
	 DQ 03ffa309bec4a2d33H, 03c96305c7ddc36abH
	 DQ 03ffa5503b23e255dH, 0bc9d2f6edb8d41e1H
	 DQ 03ffa799e1330b358H, 03c9bcb7ecac563c6H
	 DQ 03ffa9e6b5579fdbfH, 03c90fac90ef7fd31H
	 DQ 03ffac36bbfd3f37aH, 0bc8f9234cae76cd0H
	 DQ 03ffae89f995ad3adH, 03c97a1cd345dcc81H
	 DQ 03ffb0e07298db666H, 0bc9bdef54c80e424H
	 DQ 03ffb33a2b84f15fbH, 0bc62805e3084d707H
	 DQ 03ffb59728de5593aH, 0bc9c71dfbbba6de3H
	 DQ 03ffb7f76f2fb5e47H, 0bc75584f7e54ac3aH
	 DQ 03ffba5b030a1064aH, 0bc9efcd30e54292eH
	 DQ 03ffbcc1e904bc1d2H, 03c823dd07a2d9e84H
	 DQ 03ffbf2c25bd71e09H, 0bc9efdca3f6b9c72H
	 DQ 03ffc199bdd85529cH, 03c811065895048ddH
	 DQ 03ffc40ab5fffd07aH, 03c9b4537e083c60aH
	 DQ 03ffc67f12e57d14bH, 03c92884dff483cacH
	 DQ 03ffc8f6d9406e7b5H, 03c71acbc48805c44H
	 DQ 03ffcb720dcef9069H, 03c7503cbd1e949dbH
	 DQ 03ffcdf0b555dc3faH, 0bc8dd83b53829d72H
	 DQ 03ffd072d4a07897cH, 0bc9cbc3743797a9cH
	 DQ 03ffd2f87080d89f2H, 0bc9d487b719d8577H
	 DQ 03ffd5818dcfba487H, 03c82ed02d75b3706H
	 DQ 03ffd80e316c98398H, 0bc911ec18beddfe8H
	 DQ 03ffda9e603db3285H, 03c9c2300696db532H
	 DQ 03ffdd321f301b460H, 03c92da5778f018c2H
	 DQ 03ffdfc97337b9b5fH, 0bc91a5cd4f184b5bH
	 DQ 03ffe264614f5a129H, 0bc97b627817a1496H
	 DQ 03ffe502ee78b3ff6H, 03c839e8980a9cc8fH
	 DQ 03ffe7a51fbc74c83H, 03c92d522ca0c8de1H
	 DQ 03ffea4afa2a490daH, 0bc9e9c23179c2893H
	 DQ 03ffecf482d8e67f1H, 0bc9c93f3b411ad8cH
	 DQ 03ffefa1bee615a27H, 03c9dc7f486a4b6b0H
	 DQ 03fff252b376bba97H, 03c93a1a5bf0d8e43H
	 DQ 03fff50765b6e4540H, 03c99d3e12dd8a18aH
	 DQ 03fff7bfdad9cbe14H, 0bc9dbb12d0063509H
	 DQ 03fffa7c1819e90d8H, 03c874853f3a5931eH
	 DQ 03fffd3c22b8f71f1H, 03c62eb74966579e7H
	

Shifter  DQ 04338000000000000H, 04338000000000000H	; 2^52+2^51|2^52+2^51
SIGMASK  DQ 0000fffffffffffffH, 0000fffffffffffffH
ONEMASK  DQ 03ff0000000000000H, 03ff0000000000000H
ABSVALMASK DQ 7fffffffffffffffH, 7fffffffffffffffH

	; exponential polynomial coefficients
cev     DQ 03f55d87fe78a6731H, 03fac6b08d704a0bfH  ; c3|c5
	DQ 03f83b2ab6fba4e77H, 03fcebfbdff82c58eH  ; c2|c4
	DQ 03fe62e42fefa39efH  ; c1




HALFSIG  DQ 0fffffffff8000000H
LHN      DQ 0bff7154740000000H   ; -log2(e) rounded to 27 bits
sNaN     DQ 07ff0000000000001H
INF      DQ 07ff0000000000000H
NEG_INF  DQ 0fff0000000000000H
NEG_ZERO DQ 08000000000000000H
EMIN     DQ 00010000000000000H
QIND     DQ 0fff8000000000000H	; QNAN indefinite

    ALIGN 16
CONST ENDS


$movsd MACRO op1, op2
LOCAL begin_movsd, end_movsd
begin_movsd:
movupd op1, op2
end_movsd:
org begin_movsd
db 0F2h
org end_movsd
ENDM



_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _pow_pentium4, _CIpow_pentium4 
_CIpow_pentium4 PROC NEAR
	push   ebp
	mov    ebp,esp
        sub     esp,16               ; prepare place for argument
        and     esp,0fffffff0h
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fstp    qword ptr [esp+8]             ; exponent
        call    _pow_pentium4
	leave
        ret
_pow_pentium4   label proc
   ; load first argument
   movlpd xmm0, QWORD PTR [esp+4]
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   ; xmm7=first argument, with exponent set to 0+bias
   orpd xmm7, xmm2
   ; extract sign/exponent + next 4 bits
   pextrw ecx, xmm4, 3

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; check sign/exponent of x
   mov edx, 7fefH
   ; x infinity/NaN or negative ?
   sub edx, ecx
   ; x denormal ?
   sub ecx, 0010H
   or ecx, edx
   cmp ecx, 80000000H
   jae SPECIAL_X

   mov ecx, 0
   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 3fe7fH
BACK_MAIN:
BACK_DENORMAL:
   movd xmm1, edx
   ; get k (exponent) + j (j=0 if mantissa<1.5, 1 otherwise)
   psubq xmm0, xmm1
   psrlq xmm0, 8
   ; convert to DP format
   cvtdq2pd xmm0, xmm0
   
   ; xmm1=mask for splitting argments in high/low parts
   movlpd xmm1, QWORD PTR [HALFSIG]

   ; copy r1 to xmm3, set exponent to 0+bias
   $movsd xmm3, xmm7 ;andpd xmm3, xmm7
   ; extract bits 7..14
   psrlq xmm7, 64-12-14
   pextrw eax, xmm7, 0

   ; set exponent of argument to 0+bias
   andpd xmm4, QWORD PTR [SIGMASK]

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; load second reciprocal value (based on 7 bit index)
   ; get r2=x*rcp_t1*rcp_t2
   mulsd xmm3, QWORD PTR [rcp_t2+eax*4]
   ; rcp_t1*rcp_t2 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t2+eax*4]
   add eax, eax
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t2+eax*4]
  
   orpd  xmm4, QWORD PTR [ONEMASK]
   ; add k
   addsd xmm6, xmm0
   ; get xH = high part of x
   andpd xmm1, xmm4

   ; copy r2 to xmm2
   $movsd xmm2, xmm3
   ; extract bits 13...21
   psrlq xmm3, 64-12-21
   pextrw eax, xmm3, 0

   ; xmm0 = mask for splitting term in high/low parts
   movlpd xmm0, QWORD PTR [HALFSIG]
   ; get xL = low part of x
   subsd xmm4, xmm1
   ; xmm7=-log2(e) in double precision (scaling factor for reduced argument)
   movlpd xmm7, QWORD PTR [LHN]

   and eax, 1ffH
   add eax, 1
   and eax, 3feH
   ; load third reciprocal value (based on 8 bit index)
   ; get rcp_t1*rcp_t2*rcp_t3 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t3+eax*4]
   ; get r3=x*rcp_t1*rcp_t2*rcp_t3
   mulsd xmm2, QWORD PTR [rcp_t3+eax*4]
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t3+eax*8] 


   ; xmm0=rcp_H
   andpd xmm0, xmm5
   ; xmm5=rcp_L
   subsd xmm5, xmm0
   ; reduced argument 
   addsd xmm7, xmm2

   ; copy rcp_H
   $movsd xmm3, xmm0
   ; rcp_H*xH
   mulsd xmm0, xmm1
   ; xH*rcp_L
   mulsd xmm1, xmm5
   ; rcp_H*xL
   mulsd xmm3, xmm4

   ; calculate rounding error for reduced argument: R-rcp_H*xH
   subsd xmm2, xmm0
   ; rcp_L*xL
   mulsd xmm4, xmm5
   ; copy xmm6=D1+D2+D3|k+T1+T2+T3
   $movsd xmm0, xmm6
   ; R-rcp_H*xH-rcp_L*xH
   subsd xmm2, xmm1
   ; add reduced argument to high order term: xmm6=D1+D2+D3|k+T1+T2+T3+Rh
   addsd xmm6, xmm7
  
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   ; get sign/exponent
   pextrw eax, xmm1, 3

   ; R-rcp_H*xH-rcp_L*xH-rcp_H*xL
   subsd xmm2, xmm3
   ; get -Rh
   subsd xmm0, xmm6
   ; xmm3=HALFSIG mask
   movlpd xmm3, QWORD PTR [HALFSIG]

   ; get exponent for log2(x)
   pextrw edx, xmm6, 3

   ; E=R-rcp_H*xH-rcp_L*xH-rcp_H*xL-rcp_L*xL
   subsd xmm2, xmm4
 ; xmm4=k+T1+T2+T3+Rh
 $movsd xmm4, xmm6
   ; get Rl=R-Rh
   addsd xmm0, xmm7
   ; R=R-E
   subsd xmm7, xmm2
 ; xmm6=D1+D2+D3|k+T1+T2+T3+Rh+Eh
 subsd xmm6, xmm2
   ; xmm7=R|R
   unpcklpd xmm7, xmm7

   ; check if y is infinity/NaN
   and eax, 7ff0H
   cmp eax, 7ff0H
   jae SPECIAL_Y
   and edx, 7ff0H
   sub eax, 3ff0H
   add eax, edx
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; small input or UF/OF
   jae RETURN_ONE

BACK_XY_CHECK:
 ; -Eh
 subsd xmm4, xmm6
 ; -El
 subsd xmm2, xmm4
   ; xmm4=HALFSIG mask
   movlpd xmm4, QWORD PTR [HALFSIG]
   ; yH
   andpd xmm3, xmm1
   ; HH (high part of k+T1+T2+T3+Rh+Eh)
   andpd xmm4, xmm6

   ; add correction to reduced argument: Rl+El
   subsd xmm0, xmm2

   xorpd xmm2, xmm2
   mov edx, 4060H ;70H
   pinsrw xmm2, edx, 3

   ; copy yH
   $movsd xmm5, xmm3 
   ; yH*HH
   mulsd xmm3, xmm4
   ; HL
   subsd xmm6, xmm4
   ; yL
   subsd xmm1, xmm5
	
   ; get 2^7*(yH*HH)
   mulsd xmm3, xmm2  ;paddd xmm3, xmm2

   ; yH*HL
   mulsd xmm5, xmm6
   ; xmm2=cl1|cl3
   movapd xmm2, QWORD PTR [clv]
   ; HH*yL
   mulsd xmm4, xmm1

   ; get int(2^7*H)
   cvtsd2si eax, xmm3
   ; HL*yL
   mulsd xmm6, xmm1
   ; xmm1=cl2|cl4
   movapd xmm1, QWORD PTR [clv+16]

   ; yH*HL+yL*HH
   addsd xmm5, xmm4
   ; get D1+D2+D3
   pshufd xmm4, xmm6, 0eeH
   ; yH*HL+yL*HH+yL*HL
   addsd xmm5, xmm6

   ; underflow/possible overflow condition ?
   mov edx, 1ff7fH
   ; eax>=(2^10-1)*2^7
   sub edx, eax
   ; eax+bias*2^7<=59*2^7 ?
   add eax, 1e1ffH
   or edx, eax
   ; restore eax value
   sub eax, 1e1ffH
   ; check sign bit
   cmp edx, 0
   jle UF_OF_CASES


   ; get table index, and exponent of result
   ; ecx contains expected sign of the result, scaled by 2^11
   add ecx, eax
   and eax, 7fH
   ; get exponent of result (scaled by 2^7)
   and ecx, 0ffffff80h
   ; add exponent bias*2^7
   add ecx, 1ff80h

   ; D1+D2+D3+(Rl+El)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]


   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; xmm7=0
   xorpd xmm7, xmm7
   mov edx, 3f80H
   ; Pl14
   addsd xmm2, xmm1
   ; xmm7=scaling constant 
   pinsrw xmm7, edx, 3 
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k 
   movd xmm1, ecx

UF_BACK:
   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k|2^k
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3  

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
sub esp, 16
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6
   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4

   ; T+P15*(T*2^k)+D*2^k
   addsd xmm0, xmm3

	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret



SPECIAL_X:
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm3, QWORD PTR [ABSVALMASK]
   ; load low half of y in eax
   movd eax, xmm1
   $movsd xmm2, xmm1
   ; eliminate sign, load high half of y in ecx
   andpd xmm1, xmm3
   psrlq xmm1, 32
   movd ecx, xmm1
   ; y infinity/NaN ?
   cmp ecx, 7ff00000H
   jae Y_INF_NAN_CHECK_X
   ; y=+/- 0?
   or eax, ecx
   cmp eax, 0
   jz Y_ZERO

   ; denormal, positive x ? 
   cmp edx, 0
   jge DENORMAL_POS_X
   ; reconstruct sign/expon from edx=7fefH-s/exp
   neg edx
   add edx, 7fefH

   ; y integer ?
   ; xmm3=0fff00..0
   psllq xmm3,64-12
   ; set exponent of y to all 1's
   orpd xmm2, xmm3
   ; load bias-12
   mov ecx, 3ffH-12
   movd xmm3, ecx
   ; get exponent+64-52
   psrlq xmm1, 32-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; if exponent+12<0, set shift count to 0
   pmaxsw xmm1, xmm3
   ; get fractional tail of y
   psllq xmm2, xmm1
   ; fractional tail=0 ? (i.e. y integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2    

   ; take absolute value of x
   mov ecx, edx
   and edx, 7fffH
   ; check if x infinity/NaN
   cmp edx, 7ff0H
   jae INF_NAN_X

   ; x negative, finite
   ; y not integer ?
   and eax, 0ffH
   cmp eax, 0ffH
   jnz RET_INVALID

   ; y integer
   ; y odd integer ?
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=100..0
   movlpd xmm3, QWORD PTR [NEG_ZERO]
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an odd integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   ; if eax!=ffH, set ecx=2^11, else set ecx=0
   mov ecx, 3ff01H
   ; set ecx=2^11*2^7 if y is an odd integer
   add ecx, eax
   and ecx, 40000H

   ; x denormal ?
   cmp edx, 0010H
   jb DENORMAL_X

   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 0bfe7fH

   ; load constants, return to main path
   movlpd xmm3, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]
      
   jmp BACK_MAIN

Y_INF_NAN_CHECK_X:
   ; x NaN?
   movlpd xmm7, QWORD PTR [esp+4]
   movlpd xmm4, QWORD PTR [esp+4]
   movd edx, xmm7
   psrlq xmm7, 32
   movd eax, xmm7

   mov ecx, eax
   and eax, 7fffffffH
   cmp eax, 7ff00000H
   jb Y_INF_NAN
   ja X_NAN

   cmp edx, 0
   ja X_NAN
   jmp Y_INF_NAN

DENORMAL_POS_X:
   mov ecx, 0
DENORMAL_X:
   ; xmm0=2^64
   xorpd xmm0, xmm0
   mov eax, (3ffH+64)*16
   pinsrw xmm0, eax, 3 
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   ; scale x by 2^64
   mulsd xmm0, xmm4

   ; x=+/-0 ?
   movd edx, xmm4
   psrlq xmm4, 32
   movd eax, xmm4
   cmp edx, 0
   jz ZERO_X

BACK_DEN:
   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   andpd xmm0, QWORD PTR [ABSVALMASK]
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   orpd xmm7, xmm2

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; 2^8*(bias+64-0.5-2^{-8})
   mov edx, 43e7fH 
   jmp BACK_DENORMAL

ZERO_X:
   mov edx, eax
   and edx, 7fffffffH
   cmp edx, 0
   jnz BACK_DEN

   ; get sign of y
   mov edx, DWORD PTR [esp+16]
   and edx, 80000000H
   cmp edx, 0
   jz ZERO_X_POS_Y 

   ; return -infinity if (y odd and x=-0), +infinity otherwise
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   mov edx, 7ff00000H
   ; set sign of infinity
   or edx, eax
   ; load result
   movd xmm0, edx
   psllq xmm0, 32

   ; raise divide by zero
   movlpd xmm1, QWORD PTR [ONEMASK]
   movlpd xmm2, QWORD PTR [esp+4]
   divsd xmm1, xmm2

   mov edx, 27
   jmp CALL_LIBM_ERROR


ZERO_X_POS_Y:

   ; x=-0, and y odd integer ?
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   cmp eax, 0
   jnz RET_NEG_ZERO

   ; return +0
   fldz
   ret


INF_NAN_X:
	; y finite, not zero
	; x NaN ?
        movlpd xmm3, QWORD PTR [SIGMASK]
	xorpd xmm1, xmm1
	; get significand bits
        andpd xmm3, xmm4
	; significand bits = 0 ?
	pcmpeqd xmm1, xmm3
	pmovmskb ecx, xmm1
	and ecx, 0ffH
	cmp ecx, 0ffH
        jnz X_NAN

	; x=+infinity ?
	pextrw ecx, xmm4, 3
	and ecx, 8000H
	cmp ecx,0
	jz X_INF

	; x=-infinity
	; y integer ?
   	and eax, 0ffH
   	cmp eax, 0ffH
	jnz X_NINF
	; y odd integer ?
	movlpd xmm1, QWORD PTR [esp+12]
	movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an even integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   cmp eax, 0ffH
   jz X_NINF

   ; x=-infinity, y an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ?
   jz RET_NINF
   ; y<0, return -0

RET_NEG_ZERO:
   fld [NEG_ZERO]
   ret	
    

RET_NINF:
   fld [NEG_INF]
   ret

X_NINF:
   ; x=-infinity, y not an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ? (return infinity)
   jz RET_INF
   ; y<0, return 0
   fldz
   ret
 
X_INF:
	; y<0 ?
	movlpd xmm1, QWORD PTR [esp+12]
	pextrw eax, xmm1, 3
	and eax, 8000H
	cmp eax, 0
	jz RET_INF

	; y<0, return 0
	fldz
	ret


X_NAN:
    addsd xmm4, xmm4
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm4
;   fld    QWORD PTR [esp+4]
; add esp, 16	
;   ret
    $movsd xmm0, xmm4
    mov edx, 1006
    jmp CALL_LIBM_ERROR

RET_INVALID:
    ; x=-0?
    movlpd xmm2, QWORD PTR [esp+4]
    movd eax, xmm2
    psrlq xmm2, 32
    movd edx, xmm2
    and edx, 7fffffffH
    or eax, edx
    mov ecx, 0
    cmp eax, 0
    jz ZERO_X

    ; raise INVALID exception
    movlpd xmm1, QWORD PTR [sNaN]
    movlpd xmm0, QWORD PTR [QIND]
    mulsd xmm1, xmm1
    mov edx, 28
    jmp CALL_LIBM_ERROR


SPECIAL_Y:

    ; load x, y
    movlpd xmm4, QWORD PTR [esp+4]
    movlpd xmm2, QWORD PTR [esp+12]
    ; x=+/-1 ?
    ; load lower bits of x
    movd eax, xmm4
    cmp eax, 0
    jnz Y_INF_NAN

    psrlq xmm4, 32
    movd edx, xmm4
    ; x=1 ?
    cmp edx, 3ff00000H
    jz RET_ONE
	
    ; x=-1 ?
    cmp edx, 0bff00000H
    jnz Y_INF_NAN

    ; y=NaN ? (xmm1 contains y)
    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y=+/-infinity, return 1    
    fld1
    ret 


Y_INF_NAN:

    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    and eax, 0ffH
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y infinity, get sign
    pextrw eax, xmm2, 3
    ; get x
    movlpd xmm4, QWORD PTR [esp+4]
    and eax, 8000H
    ; x=-1 ? (ecx,edx=high, low parts of x)
    xor ecx, 0bff00000H
    or  edx, ecx
    cmp edx, 0
    ; if x=-1, return 1
    jz RET_ONE     
    cmp eax, 0
    jz Y_INF

    ; |x|<1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jb RET_INF

    ; |x|>1, y=-infinity, return 0
    fldz 
    ret


Y_INF:
    ; y=+infinity
    ; |x|>=1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jae RET_INF

    ; |x|<1, return 0
    fldz
    ret
    
RET_INF:
    fld QWORD PTR [INF]
    ret  


RET_Y_NAN:
    addsd xmm2, xmm2
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm2
;   fld QWORD PTR [esp+4]
; add esp, 16
;   ret
    $movsd xmm0, xmm2
    mov edx, 1006
    jmp CALL_LIBM_ERROR

Y_ZERO: 

    ; x=0 ?
    movd eax, xmm4
    psrlq xmm4, 32
    movd edx, xmm4
    and edx, 7fffffffH
    mov ecx, eax
    or eax, edx
    movlpd xmm0, QWORD PTR [ONEMASK]
    mov edx, 26
    cmp eax, 0
    jz CALL_LIBM_ERROR

    ; x=NaN ?
    movd eax, xmm4
    mov edx, 29
    and eax, 7fffffffH
    cmp eax, 7ff00000H
    ; x=NaN
    ja CALL_LIBM_ERROR
    ; x!=NaN
    jb Y_ZERO_RET
    ; x=NaN ?
    cmp ecx,0
    ja CALL_LIBM_ERROR
    
Y_ZERO_RET:
    ; return 1 for any x
  sub esp, 16
    movlpd QWORD PTR [esp+4], xmm0
    fld QWORD PTR [esp+4]
  add esp, 16

    ret

RET_ONE:
    ; used for x=+/-1, special y
;     fld1
;     ret


     movlpd xmm1, QWORD PTR [QIND]
     movlpd xmm0, QWORD PTR [esp+12]
     ; set Invalid flag, if necessary
     addsd xmm0, xmm1
     
     mov edx, 28
     ; jmp cALL_LIBM_ERROR


CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16+8
	mov DWORD PTR [esp+4],edx
	sub edx, 8
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]

;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
	fld       QWORD PTR [esp+16]             ;
	add esp,28
	ret


UF_OF_CASES:
   cmp eax,0
   jle UNDERFLOW_CASES

   ; if eax>=2^11*2^7, oF occurs
   cmp eax, 40000H
   jae RET_INF_OF

   push esi
   ; overflow
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+bias)*2^7
   add ecx, 3ff00h
   ; edx+=(bias+(-bias)-1)*2^7  ; the same -1
   sub edx, 128
   and edx, 0ffffff80H
   push edi
   mov edi, 3ff0H
   jmp OF_CONT


UNDERFLOW_CASES:

   cmp eax, (2-1024)*256
   jle RET_ZERO_UF

   push esi
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+1-bias)*2^7
   add ecx, 80h
   ; edx=exponent*2^7
   and edx, 0ffffff80H
   ; edx+=(bias+bias-1)*2^7
   add edx, 3fe80H
   push edi
   mov edi, 0

OF_CONT:
   ; D1+D2+D3+(Rl+E)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]

   ; esi=edx-bias*2^7
   mov esi, edx
   sub esi, 1ff80H

   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; Pl14
   addsd xmm2, xmm1
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k2 
   movd xmm1, edx
   ; edx=-(edx-bias*2^7)/2^7
   sub edx, 1ff80H
   neg edx
   sar edx, 7

   add edx, 2
   ; if edx>=32, set edx to 64+
   mov eax, edx
   and eax, 32
   add edx, eax

   ; xmm7=0
   xorpd xmm7, xmm7
   mov eax, 3f80H
   ; xmm7=scaling constant 
   pinsrw xmm7, eax, 3 

   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12+4+4]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k2|2^k2
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3 

   ; xmm7=2^k'
   movd  xmm7, ecx
   psllq xmm7, 52-7 

   movd xmm2, edx
   pcmpeqd xmm1, xmm1
   psllq xmm1, xmm2

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6

   ; Th
   andpd xmm1, xmm3

   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4
   ; xmm6=0
   xorpd xmm6, xmm6

   pcmpeqd xmm4, xmm4
   psllq xmm4, xmm2

   ; Tl
   subsd xmm3, xmm1
   ; xmm2=Th
   $movsd xmm2, xmm1

   ; (Th+(P15*(T*2^k)+D*2^k)_high)_high
   addsd xmm1, xmm0
   andpd xmm1, xmm4
   ; xmm6=(possible OF)?1:0
   pinsrw xmm6, edi, 3
   pop edi

   ; -(P15*(T*2^k)+D*2^k)_high
   subsd xmm2, xmm1

   ; (P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm2

   ; Tl+(P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm3

   cmp esi, 0
   jg  SCALE2

   pop esi
   ; final scaling by 2^k'
   mulsd xmm0, xmm7
   mulsd xmm1, xmm7

   ; final addition
   addsd xmm0, xmm1

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


SCALE2: 
   pop esi

   ; final addition
   addsd xmm0, xmm1
   ; final scaling by 2^k'
   mulsd xmm0, xmm7

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


RET_ZERO_UF:

   movlpd xmm0, QWORD PTR [EMIN]
   ; sign
   movd xmm1, ecx
   mulsd xmm0, xmm0

   ; set sign
   psllq xmm1, 63-18
   orpd xmm0, xmm1

   mov edx, 25
   jmp CALL_LIBM_ERROR

RET_INF_OF:

   mov edx, 24

   ; check sign
   cmp ecx, 0
   jz RET_INF_OF2

   movlpd xmm0, QWORD PTR [NEG_INF]
   jmp CALL_LIBM_ERROR

RET_INF_OF2:

   movlpd xmm0, QWORD PTR [INF]
   jmp CALL_LIBM_ERROR


RETURN_ONE:
   ; y|y
   pshufd xmm4, xmm1, 44H
   ; y*log2(x)_high
   mulpd xmm4, xmm6
   ; get exponent
   pextrw eax, xmm4, 3
   and eax, 7ff0H
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; if no OF/UF occurs, return to main path
   jb BACK_XY_CHECK




CONT_OF_UF:
   ; overflow/underflow ?
   cmp eax, 80000000H
   jb OF_UF

RET_ONE2:
   ; return +/- 1
   or ecx, 1ff80H
   movd xmm0, ecx
   psllq xmm0, 52-7

sub esp, 16
   movlpd [esp+4], xmm0
   fld QWORD PTR [esp+4]
add esp, 16
   ret

OF_UF:

   movlpd xmm4, [esp+4]
   pextrw edx, xmm4, 3
   and edx, 7ff0H
   sub edx, 3ff0H

   pextrw eax, xmm1, 3
   xor eax, edx
   and eax, 8000H
   cmp eax, 0
   jnz RET_ZERO_UF
   jmp RET_INF_OF


_CIpow_pentium4 ENDP

    ALIGN 16
_TEXT ENDS

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\temp_context.h ===
//
// This is a temp file that defines to be defined data structures - WINNT.H
//

#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define MAXIMUM_SUPPORTED_EXTENSION     512

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _TEMP_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} TEMP_CONTEXT, *PTEMP_CONTEXT;


typedef struct _TEMP_EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PTEMP_CONTEXT ContextRecord;
} TEMP_EXCEPTION_POINTERS, *PTEMP_EXCEPTION_POINTERS;


#define SIZE_OF_X87_REGISTERS       128
#define SIZE_OF_XMMI_REGISTERS      128
#define SIZE_OF_FX_REGISTERS        128
#define NUMBER_OF_REGISTERS         8


typedef struct _FLOATING_EXTENDED_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   X87RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   XMMIRegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
} FLOATING_EXTENDED_SAVE_AREA, *PFLOATING_EXTENDED_SAVE_AREA;


typedef struct _MMX_AREA {
    MMX64    Mmx;
    _U64     Reserved;
} MMX_AREA, *PMMX_AREA;

typedef struct _X87_AREA {
    MMX_AREA Mm[NUMBER_OF_REGISTERS];
} X87_AREA, *PX87_AREA;

typedef struct _XMMI_AREA {
    XMMI128  Xmmi[NUMBER_OF_REGISTERS];
} XMMI_AREA, *PXMMI_AREA;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\trig.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sin(), cos() and tan() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _pi_by_2_to_61:tbyte
extrn   _DEFAULT_CW_in_mem:word


ifdef           _COS_
    _NAME_ db 'cos',0
    _FUNC_    equ <cos>
    _IFUNC_   equ <_CIcos>
elseifdef       _TAN_
    _NAME_ db 'tan',0
    _FUNC_    equ <tan>
    _IFUNC_   equ <_CItan>
elseifdef       _SIN_
    _SIN_  equ 1
    _NAME_ db 'sin',0
    _FUNC_    equ <sin>
    _IFUNC_   equ <_CIsin>
endif
        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default

; fsin/fcos/fptan are not affected by precizion bits.
; So we may ignore user's CW

        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

ifdef         _COS_
        fcos
        fstsw   ax
elseifdef _SIN_
        fsin
        fstsw   ax
elseifdef _TAN_
        fptan
        fstsw   ax
endif
        sahf
        jp      reduce_arg
ifdef    _TAN_
        fstp    st(0)
endif
exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


reduce_arg:
        fld     TBYTE PTR [_pi_by_2_to_61]
        fxch    st(1)
redux_loop:
        fprem1
        fstsw   ax
        sahf
        jp      redux_loop

;reapply
        fstp    st(1)
ifdef         _COS_
        fcos
elseifdef _SIN_
        fsin
elseifdef _TAN_
        fptan
        fstp    st(0)
endif
        jmp     exit

not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\sqrt.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sqrt() function
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword

_NAME_  db 'sqrt',0,0,0,0

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; MUST BE MODIFIED
; arg                ErrorType        result
;-------------------------------------------
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           indefinite
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           -                infinity
;+0.0                -                +0.0
;-0.0                -                -0.0
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public sqrt,_CIsqrt
_CIsqrt        proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

sqrt        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        mov     eax,[esp+0ch]                 ; eax contains high dword

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        test    eax,80000000h
        jnz     test_if_x_zero
x_is_denormal:                                ; denormal is like normal
        fsqrt
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        jmp     _math_exit

test_if_x_zero:                               ; x <= 0
        test    eax,7ff00000H
        jnz     negative_x
        test    eax,000fffffH
        jnz     negative_x                    ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     negative_x                    ; denormal operand
        jmp     exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax,000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag,0
        jnz     _fast_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
_CIsqrt        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\testfdiv.c ===
/***
*testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*	Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Detects early steppings of Pentium with incorrect FDIV tables using
*	'official' Intel test values. Returns 1 if flawed Pentium is detected,
*	0 otherwise.
*
*Revision History:
*	12-19-94  JWM	file added
*	12-22-94  JWM	Now safe for TNT, et al
*	01-13-95  JWM	underscores added for ANSI compatibility
*	12-12-95  SKS	Skip redundant Pentium test on uni-processor systems
*	12-13-95  SKS	Call LoadLibrary() rather than GetModuleHandle()
*			since "kernel32.dll" is always going to be present.
*	01-18-96  JWM	Now handles possible failure of SetThreadAffinityMask(),
*			incorporating various suggestions of MarkL.
*	05-29-96  JWM	No longer loops through affinity mask; instead, uses MarkL's
*			new IsProcessorFeaturePresent() API if possible, only tests
*			1st processor if not.
*
*******************************************************************************/

#include <windows.h>

int _ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}

/* 
 * Multiprocessor Pentium test: returns 1 if any processor is a flawed
 * Pentium, 0 otherwise.
 */

int _ms_p5_mp_test_fdiv(void)
{

    #define PF_FLOATING_POINT_PRECISION_ERRATA 0
    HINSTANCE LibInst;
    FARPROC pIsProcessorFeaturePresent;

#ifndef _XBOX
    if ((LibInst = GetModuleHandle("KERNEL32")) &&
         (pIsProcessorFeaturePresent = GetProcAddress(LibInst, "IsProcessorFeaturePresent")))
        return (*pIsProcessorFeaturePresent)(PF_FLOATING_POINT_PRECISION_ERRATA);
    else
#endif // XBOX
        return _ms_p5_test_fdiv();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\triga.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for asin() and acos() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

ifdef         _ACOS_
    _NAME_ db 'acos',0,0,0,0
    _FUNC_    equ <acos>
    _IFUNC_   equ <_CIacos>
elseifdef _ASIN_
    _SIN_  equ 1
    _NAME_ db 'asin',0,0,0,0
    _FUNC_    equ <asin>
    _IFUNC_   equ <_CIasin>
endif

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; arg                ErrorType        result
;------------------------------------------------
; |x| >1             DOMAIN           indefinite
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        cmp     eax,3ff00000H                 ; check if |x|>=1
        jae     x_huge

        fld1                                  ; load 1.0
        fadd    st, st(1)                     ; 1+x
        fld1                                  ; load 1.0
        fsub    st, st(2)                     ; 1-x
        fmul                                  ; (1+x)(1-x)
        fsqrt                                 ; sqrt((1+x)(1-x))
ifdef        _ACOS_
        fxch
endif
        fpatan                                ; fpatan(x,sqrt((1+x)(1-x)))

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


x_huge: ja      not_in_range
        mov     eax,[esp+0cH]
        mov     ecx,eax
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     not_in_range
        and     ecx,80000000H
        fstp    st(0)                         ; remove TOS
ifdef        _ASIN_
        fld     _piby2                        ; asin(1) = pi/2
        jz      exit
        fchs                                  ; asin(-1) = -pi/2
        jmp     exit
elseifdef _ACOS_
        jz      ret_zero
        fldpi
        jmp     exit
ret_zero:
        fldz
        jmp     exit
endif



not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
not_in_range:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  //_WCONIO_DEFINED

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\xmmi_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI_FP_emulate () - XMMI FP instruction emulation for the FP IEEE filter *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Mar 1998; modified Jun 1998; added DAZ Oct 2000 *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

// #define _DEBUG_FPU
// #define _XMMI_DEBUG

// XMMI_FP_Emulation () receives the input operands of a XMMI FP instruction 
// (operating on single-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *_PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp32Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler, the caller of XMMI_FP_emulate should
//       interpret the result for a compare instruction (CMPPS, CMPPS, COMISS,
//       UCOMISS); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPS, OP_ADDSS to _FpCodeAdd
//     from OP_SUBPS, OP_SUBSS to _FpCodeSubtract
//     from OP_MULPS, OP_MULSS to _FpCodeMultiply
//     from OP_DIVPS, OP_DIVSS to _FpCodeDivide
//     from OP_CMPPS, OP_CMPSS to _FpCodeCompare
//     from OP_COMISS, OP_UCOMISS to _FpCodeCompare
//     from OP_CVTPI2PS, OP_CVTSI2SS to _FpCodeConvert
//     from OP_CVTPS2PI, OP_CVTSS2SI to _FpCodeConvert
//     from OP_CVTTPS2PI, OP_CVTTSS2SI to _FpCodeConvertTrunc
//     from OP_MAXPS, OP_MAXSS to _FpCodeMax
//     from OP_MINPS, OP_MINSS to _FpCodeMin
//     from OP_SQRTPS, OP_SQRTSS to _FpCodeSquareRoot
//
//
//   - for ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS:
//
//     - execute the operation with x86 instructions (fld, 
//       faddp/fsubp/fmulp/fdivp, and fstp), using the user
//       rounding mode, 24-bit significands, and 11-bit exponents for results
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if any input operand is a NaN:
//       - if both operands are NaNs, return the first operand ("quietized" 
//         if SNaN)
//       - if only one operand is a NaN, return it ("quietized" if SNaN)
//       - set the invalid flag if needed, and return NoExceptionRaised
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the divide by zero flag is set (for DIVPS and DIVSS only) and the
//       divide by zero exceptions are enabled, take a divide by zero trap 
//       (i.e. return RaiseException with the IEEE record filled out 
//       appropriately)
//     - if the result is a NaN (QNaN Indefinite), the operation must have been
//       Inf - Inf, Inf * 0, Inf / Inf, or 0 / 0; set the invalid status flag
//       and return NoExceptionRaised
//     - determine whether the result is tiny or huge
//     - if the underflow traps are enabled and the result is tiny, take an
//       underflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - if the overflow traps are enabled and the result is huge, take an
//       overflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - re-do the operation with x86 instructions, using the user rounding
//       mode, 53-bit significands, and 11-bit exponents for results (this will
//       allow rounding to 24 bits without a double rounding error - needed for
//       the case the result requires denormalization) [cannot denormalize
//       without a possible double rounding error starting from a 24-bit
//       significand]
//     - round to 24 bits (or to less than 24 bits if denormalization is 
//       needed), for the case an inexact trap has to be taken, or if no
//       exception occurs
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately); if the flush-to-zero mode is enabled and
//       the result is tiny, the result is flushed to zero
//     - if no exception has to be raised, the flush-to-zero mode is enabled,
//       and the result is tiny, then the result is flushed to zero; set the 
//       status flags and return NoExceptionRaised
//
//   - for CMPPS, CMPSS
//
//     - for EQ, UNORD, NEQ, ORD, SNaN operands signal invalid
//     - for LT, LE, NLT, NLE, QNaN/SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN and the compare type is EQ, LT, LE, or ORD, 
//       set the result to "false", set the value of the invalid status flag,
//       and return NoExceptionRaised
//     - if any operand is a NaN and the compare type is NEQ, NLT, NLE, or
//       UNORD, set the result to "false", set the value of the invalid status 
//       flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for COMISS, UCOMISS
//
//     - for COMISS, QNaN/SNaN operands (one or both) signal invalid
//     - for UCOMISS, SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set OF, SF, AF = 000, ZF, PF, CF = 111,
//       set the value of the invalid status flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and set EFlags,
//       set the value of the invalid status flag, and return NoExceptionRaised
//
//   - for CVTPI2PS, CVTSI2SS
//
//     - execute the operation with x86 instructions (fild and fstp), using the
//       user rounding mode, 24-bit significands, and an 8-bit exponent for
//       the result
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       set the result and take an inexact trap (i.e. return RaiseException
//       with the IEEE record filled out appropriately)
//     - if no exception has to be raised, set the result, the value of the
//       inexact status flag and return NoExceptionRaised
//
//   - for CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI
//
//     - execute the operation with x86 instructions (fld and fistp), using
//       the user rounding mode for CVT* and chop for CVTT*
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately) [the invalid operation condition occurs for 
//       any input operand that does not lead through conversion to a valid
//       32-bit signed integer; the result is in such cases the Integer
//       Indefinite value]
//     - set the result value
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the value of the invalid status
//       flag and of the inexact status flag and return NoExceptionRaised
//
//   - for MAXPS, MAXSS, MINPS, MINSS
//
//     - check for invalid exception (QNaN/SNaN operands signal invalid)
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set the result to the value of the second 
//       operand, set the invalid status flag to 1, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for SQRTPS, SQRTSS
//
//     - execute the operation with x86 instructions (fld, fsqrt, and fstp),
//       using the user rounding mode, 24-bit significands, and an 8-bit
//       exponent for the result
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the status flags and return
//       NoExceptionRaised
//


#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01


// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA
static unsigned POSINFFA[] = {0x7f800000};
#define POSINFF *(float *)POSINFFA
static unsigned NEGINFFA[] = {0xff800000};
#define NEGINFF *(float *)NEGINFFA

#ifdef _XMMI_DEBUG
static unsigned QNANINDEFFA[] = {0xffc00000};
#define QNANINDEFF *(float *)QNANINDEFFA
#endif


// 64-bit constants
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000}; 
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0xe0000000, 0x47efffff}; 
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int issnanf (float f);
static int isnanf (float f);
static float quietf (float f);
static int isdenormalf (float f);



ULONG
XMMI_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd1, opd2, res;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  double dbl_res24; // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned int cmp_res;


  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps


#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) printf ("XMMI_FP_Emulate WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) printf ("XMMI_FP_Emulate WARNING: tag_word = %x\n", *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n",
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPS:
    case OP_ADDSS:
    case OP_SUBPS:
    case OP_SUBSS:
    case OP_MULPS:
    case OP_MULSS:
    case OP_DIVPS:
    case OP_DIVSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPS:
        case OP_ADDSS:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPS:
        case OP_SUBSS:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPS:
        case OP_MULSS:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPS:
        case OP_DIVSS:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnanf (opd1) || isnanf (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnanf (opd1) && isnanf (opd2))
            XmmiEnv->Ieee->Result.Value.Fp32Value = quietf (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; 
                // conversion to single precision is exact
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 4: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = (float)dbl_res24;
      if (isnanf (res)) {
#ifdef _XMMI_DEBUG
        if (res != QNANINDEFF)
            fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR: "
                "res = %f = %x is not QNaN Indefinite\n", 
                 (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_res24 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // check if the result is tiny
      // Note: (dbl_res24 == 0.0 && sw & _SW_INEXACT) cannot occur
      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < 0.0 ||
            0.0 < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (NEGINFF < dbl_res24 && dbl_res24 < -MAX_SINGLE_NORMAL || 
          MAX_SINGLE_NORMAL < dbl_res24 && dbl_res24 < POSINFF) { 
        result_huge = 1;
      }

      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack single precision format, and the 
      // user's rounding mode; exceptions must have been disabled; an inexact
      // exception may be reported on the 24-bit faddp, fsubp, fmulp, or fdivp,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the fstp

      // check whether there is a underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        dbl_res24 = TWO_TO_192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        dbl_res24 = TWO_TO_M192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 24 bits, may set the inexact 
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 24 bits, may set the inexact
                                //  status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROF;
          else if (res < 0.0)
            res = NZEROF;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 24-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _XMMI_DEBUG
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROF;
        else if (res < 0.0)
          res = NZEROF;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPS:
    case OP_CMPSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnanf (opd1) || isnanf (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 11: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 12: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISS:
    case OP_UCOMISS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISS:

          if (isnanf (opd1) || isnanf (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISS:

          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 14: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 15: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPI2PS:
    case OP_CVTSI2SS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PI:
    case OP_CVTSS2SI:
    case OP_CVTTPS2PI:
    case OP_CVTTSS2SI:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2PI:
        case OP_CVTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2PI:
        case OP_CVTTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_MAXPS:
    case OP_MAXSS:
    case OP_MINPS:
    case OP_MINSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPS:
        case OP_MAXSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPS:
        case OP_MINSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnanf (opd1) || isnanf (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 23: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 24: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 25: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPS:
    case OP_SQRTSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  DWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 27: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code %d\n", XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}



static int
issnanf (float f)

{

  // checks whether f is a signaling NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7fc00000) == 0x7f800000) && ((fp[0] & 0x003fffff) != 0))
    return (1);
  else
    return (0);

}


static int
isnanf (float f)

{

  // checks whether f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7f800000) == 0x7f800000) && ((fp[0] & 0x007fffff) != 0))
    return (1);
  else
    return (0);

}


static float
quietf (float f)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  *fp = *fp | 0x00400000;
  return (f);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\xmmi2_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI2_FP_emulate(): WNI FP instruction emulation for the FP IEEE filter   *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Nov 1999; added DAZ Oct 2000                    *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

//#define _DEBUG_FPU

// XMMI2_FP_Emulation () receives the input operands of an XMMI2 FP instruction 
// (operating on double-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp64Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler,the caller of XMMI2_FP_emulate should
//       interpret the result for a compare instruction (CMPPD, CMPPD, COMISD,
//       UCOMISD); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPD, OP_ADDSD to _FpCodeAdd
//     from OP_SUBPD, OP_SUBSD to _FpCodeSubtract
//     from OP_MULPD, OP_MULSD to _FpCodeMultiply
//     from OP_DIVPD, OP_DIVSD to _FpCodeDivide
//     from OP_CMPPD, OP_CMPSD to _FpCodeCompare
//     from OP_COMISD, OP_UCOMISD to _FpCodeCompare
//     from OP_CVTDQ2PS, OP_CVTPS2DQ, OP_CVTPD2PI, OP_CVTSD2SI, OP_CVTPD2DQ,
//         OP_CVTPS2PD, OP_CVTSS2SD, OP_CVTPD2PS, OP_CVTSD2SS to _FpCodeConvert
//     from OP_CVTTPS2DQ, OP_CVTTPD2PI, OP_CVTTSD2SI, OP_CVTTPD2DQ
//         to _FpCodeConvertTrunc
//     from OP_MAXPD, OP_MAXSD to _FpCodeMax
//     from OP_MINPD, OP_MINSD to _FpCodeMin
//     from OP_SQRTPD, OP_SQRTSD to _FpCodeSquareRoot
//
//

#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01

// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA

// 64-bit constants
static unsigned ZERODA[] = {0x00000000, 0x00000000};
#define  ZEROD *(double *) ZERODA
static unsigned NZERODA[] = {0x00000000, 0x80000000};
#define  NZEROD *(double *) NZERODA
static unsigned POSINFDA[] = {0x00000000, 0x7ff00000};
#define POSINFD *(float *)POSINFDA
static unsigned NEGINFDA[] = {0x00000000, 0xfff00000};
#define NEGINFD *(float *)NEGINFDA
#ifdef _DEBUG_FPU
static unsigned QNANINDEFDA[] = {0x00000000, 0xffc00000};
#define QNANINDEFD *(float *)QNANINDEFDA
#endif
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000};
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0x70000000, 0x47efffff};
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A

// 80-bit constants
static unsigned POSINFDEA[] = {0x00000000, 0x80000000, 0x00007fff};
#define POSINFDE *(float *)POSINFDEA
static unsigned NEGINFDEA[] = {0x00000000, 0x80000000, 0x0000ffff};
#define NEGINFDE *(float *)NEGINFDEA
static unsigned MIN_DOUBLE_NORMALA [] = {0x00000000, 0x80000000, 0x00003c01}; 
    // +1.0 * 2^-1022
#define MIN_DOUBLE_NORMAL *(double *)MIN_DOUBLE_NORMALA
static unsigned MAX_DOUBLE_NORMALA [] = {0xfffff800, 0xffffffff, 0x000043fe}; 
    // +1.1...1*2^1023
#define MAX_DOUBLE_NORMAL *(double *)MAX_DOUBLE_NORMALA
static unsigned TWO_TO_1536A[] = {0x00000000, 0x80000000, 0x000045ff};
#define TWO_TO_1536 *(double *)TWO_TO_1536A
static unsigned TWO_TO_M1536A[] = {0x00000000, 0x80000000, 0x000039ff};
#define TWO_TO_M1536 *(double *)TWO_TO_M1536A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int iszerod (double);
static int isinfd (double);
static int issnand (double);
static int isnand (double);
static double quietd (double);
static int isdenormald (double);
static int isdenormalf (float f);



ULONG
XMMI2_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd24, res24;
  double opd1, opd2, res, dbl_res24;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  char dbl_ext_res64[10];
      // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  double dbl_res64;
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned short sw1, sw2, sw3, sw4;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned __int64 cmp_res;

  unsigned char min_double_normal[10];
  unsigned char max_double_normal[10];
  unsigned char posinfde[10];
  unsigned char neginfde[10];
  unsigned char two_to_1536[10];
  unsigned char two_to_m1536[10];

  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps

#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0)
      printf ("XMMI2_FP_Emulation WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff)
      printf ("XMMI2_FP_Emulation WARNING: tag_word = %x\n",
      *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
   printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n", 
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPD:
    case OP_ADDSD:
    case OP_SUBPD:
    case OP_SUBSD:
    case OP_MULPD:
    case OP_MULSD:
    case OP_DIVPD:
    case OP_DIVSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPD:
        case OP_ADDSD:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPD:
        case OP_SUBSD:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPD:
        case OP_MULSD:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPD:
        case OP_DIVSD:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }

          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnand (opd1) || isnand (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnand (opd1) && isnand (opd2))
            XmmiEnv->Ieee->Result.Value.Fp64Value = quietd (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64;
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 4: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = dbl_res64;
      if (isnand (res)) {
#ifdef _DEBUG_FPU
      if (res != QNANINDEFD)
          fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation"
             " () ERROR: res = %f = %x is not QNaN Indefinite\n", 
              (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_ext_res64 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // Note: (dbl_ext_res64 == 0.0 && sw & _SW_INEXACT) cannot occur

      // check if the result is tiny
      // if (-MIN_DOUBLE_NORMAL < dbl_ext_res64 && dbl_ext_res64 < 0.0 ||
      //     0.0 < dbl_ext_res64 && dbl_ext_res64 < MIN_DOUBLE_NORMAL)
      //   result_tiny = 1;

      memcpy (min_double_normal,  (char *)MIN_DOUBLE_NORMALA, 10);
      memcpy (max_double_normal,  (char *)MAX_DOUBLE_NORMALA, 10);
      memcpy (posinfde,  (char *)POSINFDEA, 10);
      memcpy (neginfde,  (char *)NEGINFDEA, 10);
      memcpy (two_to_1536, (char *)TWO_TO_1536A, 10);
      memcpy (two_to_m1536, (char *)TWO_TO_M1536A, 10);

      __asm {

        // -MIN_DOUBLE_NORMAL < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR min_double_normal;
        fchs; // -1.0*2^e_min in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < 0.0
        fldz;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // 0.0 < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fldz; // 0.0 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < MIN_DOUBLE_NORMAL
        fld  TBYTE PTR min_double_normal; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_tiny = 1;
      }

      // check if the result is huge
      // if (NEGINFD<dbl_ext_res64 && dbl_ext_res64<-MAX_DOUBLE_NORMAL ||
      //     MAX_DOUBLE_NORMAL<dbl_ext_res64 && dbl_ext_res64<POSINFD)
      //   result_huge = 1;

      __asm {

        // NEGINFD < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR neginfde; // -inf in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < -MAX_DOUBLE_NORMAL
        fld  TBYTE PTR max_double_normal;
        fchs;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // MAX_DOUBLE_NORMAL < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR max_double_normal; // +1.1...1*2^e_max in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < POSINFD
        fld  TBYTE PTR posinfde; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_res_ext24 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_huge = 1;
      }


      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack double precision format, and the 
      // user's rounding mode; exceptions must have been disabled before calling
      // this function; an inexact exception may be reported on the 64-bit
      // faddp, fsubp, fdivp, or on both the 64-bit and 53-bit conversions,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the conversion from dbl_res to res

      // check whether there is an underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {

        // dbl_ext_res64 = TWO_TO_1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {

        // dbl_ext_res64 = TWO_TO_M1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_m1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // set user rounding mode, 64-bit precision (to avoid a double rounding
      // error in case the result requires denormalization), and disable all
      // exceptions 
      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)
      // may set P, U or O; may also involve denormalizing the result

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 64 bits, may set the inexact 
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 64 bits, may set the inexact
                                //  status flag
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 64 bits, exact
            // store result
            fstp  QWORD PTR res;
          }

          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 64 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      if ((sw & _SW_INEXACT) && result_tiny) sw = sw | _SW_UNDERFLOW;

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROD;
          else if (res < 0.0)
            res = NZEROD;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp64Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 53-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _DEBUG_FPU
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROD;
        else if (res < 0.0)
          res = NZEROD;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPD:
    case OP_CMPSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnand (opd1) || isnand (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffffffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 11: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 12: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation ()"
            " ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISD:
    case OP_UCOMISD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISD:

          if (isnand (opd1) || isnand (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISD:

          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 14: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 15: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () "
            "ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTDQ2PS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res24; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2DQ:
    case OP_CVTTPS2DQ:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal [ignored] or invalid
                             // status flags
        fistp DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PI:
    case OP_CVTSD2SI:
    case OP_CVTPD2DQ:
    case OP_CVTTPD2PI:
    case OP_CVTTSD2SI:
    case OP_CVTTPD2DQ:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPD2PI:
        case OP_CVTSD2SI:
        case OP_CVTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPD2PI:
        case OP_CVTTSD2SI:
        case OP_CVTTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PD:
    case OP_CVTSS2SD:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC); // redun.

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal or invalid
                             // status flags; exact
        fstp QWORD PTR res; // store as a double; exact
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid or denormal exceptions;
      // the instruction did not lead to an enabled exception; return result

      XmmiEnv->Ieee->Result.Value.Fp64Value = res;
      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PS:
    case OP_CVTSD2SS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags; exact
        fstp DWORD PTR res24; // store as a single; may set the underflow/
                              // overflow and/or the inexact status flags
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if opd1 is 0.0, inf, or NaN
      if (isnand (opd1) || isinfd (opd1) || iszerod (opd1)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // at this point, there are no enabled I, or D exceptions, and the input
      // operand is not 0, infinity, or NaN; the instruction
      // might lead to an enabled underflow, enabled underflow and inexact,
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, the result
      // is res24

      // check whether there is an underflow, overflow, or inexact trap to be
      // taken

      // calculate the result to 24 bits, with 'unbounded' exponent
      __asm {
        fnclex;
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags (same as above)
        fld1; // +1.0
        fmulp st(1), st(0); // rounded to 24 bits; may set P
        fstp QWORD PTR dbl_res24; // store as a double; may set the underflow/
                              // overflow and/or the inexact status flags,
                              // but no new trap flags are set here
      }

      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (dbl_res24 < -MAX_SINGLE_NORMAL || MAX_SINGLE_NORMAL < dbl_res24) {
        result_huge = 1;
      }

      // if the underflow traps are enabled and the result is tiny, take
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }


      // at this point, there are no enabled exceptions, or an enabled 
      // inexact exception; return the result from res24

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) &&
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1;
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res24 > 0.0) // it might already be +0.0 from fmulp and/or fstp
            res24 = ZEROF;
          else if (res24 < 0.0) // it might already be -0.0 from fmulp/fstp
            res24 = NZEROF;
          // else leave res24 unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if it got here, then there is no trap to be taken
 
      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res24 > 0.0)
          res24 = ZEROF;
        else if (res24 < 0.0)
          res24 = NZEROF;
        // else leave res24 unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24;

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow,
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n",
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);
      break;

    case OP_MAXPD:
    case OP_MAXSD:
    case OP_MINPD:
    case OP_MINSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPD:
        case OP_MAXSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPD:
        case OP_MINSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnand (opd1) || isnand (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 23: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 24: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 25: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, 
            "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPD:
    case OP_SQRTSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  QWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 27: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, 
         "XMMI2_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, 
          "XMMI2_FP_Emulation internal error: unknown operation code %d\n", 
          XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}


static int
iszerod (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x0) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
isinfd (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x7ff80000) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
issnand (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff80000) == 0x7ff00000) && 
      (((dp[1] & 0x0007ffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isnand (double d)

{

  unsigned int *qp;

  qp = (unsigned int *)&d;

  if (((qp[1] & 0x7ff00000) == 0x7ff00000) &&
      (((qp[1] & 0x000fffff) != 0x00000000) || qp[0] != 0x00000000))
    return (1);
  else
    return (0);

}


static double
quietd (double d)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value d is a NaN

  unsigned int *dp;

  dp = (unsigned int *)&d;

  dp[1] = dp[1] | 0x00080000;
  return (d);

}


static int
isdenormald (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff00000) == 0x0) && 
      (((dp[1] & 0x000fffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (_pctype[a] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( _pctype[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


#if defined(_M_IA64)
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );
#else
_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );
#endif // defined(_M_IA64)

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\xmmi_types.h ===
/******************************Intel Confidential******************************/
/*++ 

Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.

Module Name:

    xmmi_types.h

Abstract:

    This module contains the xmmi data definitions.
   
Author:

    Ping L. Sager

Revision History:

--*/

//Debug
#ifdef _DEBUG
//Uncomment this line to debug.  This switch is also used to generated test cases.
//#define _XMMI_DEBUG
#endif

#ifndef _XMMI_TYPES_H
#define _XMMI_TYPES_H

#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN       1
#endif

#define XMMI_INSTR          0
#define XMMI2_INSTR         1
#define XMMI2_OTHER         2
#define INSTR_SET_SUPPORTED 2   
#define INSTR_IN_OPTABLE    32

#define NoExceptionRaised   0
#define ExceptionRaised     1

//
// Definitions used to parse the memory references
// 
#define EAX_INDEX           0
#define ECX_INDEX           1
#define EDX_INDEX           2
#define EBX_INDEX           3
#define ESP_INDEX           4
#define EBP_INDEX           5
#define ESI_INDEX           6
#define EDI_INDEX           7

#define GET_REG(r)      (pctxt->r)
#define GET_REG_VIA_NDX(l,n) { \
    switch((n)&7) {   \
    case EAX_INDEX: l = pctxt->Eax; break; \
    case ECX_INDEX: l = pctxt->Ecx; break; \
    case EDX_INDEX: l = pctxt->Edx; break; \
    case EBX_INDEX: l = pctxt->Ebx; break; \
    case ESP_INDEX: l = pctxt->Esp; break; \
    case EBP_INDEX: l = pctxt->Ebp; break; \
    case ESI_INDEX: l = pctxt->Esi; break; \
    case EDI_INDEX: l = pctxt->Edi; break; \
    default: l=0; }                        \
}

#define GET_USER_UBYTE(p)   (*((UCHAR *)(p)))
#define GET_USER_ULONG(p)   (*((ULONG *)(p)))

//
// XMMI Instruction register set
//
typedef enum _XMMI_REGISTER_SET {
    xmmi0 =  0, 
    xmmi1 =  1, 
    xmmi2 =  2, 
    xmmi3 =  3,
    xmmi4 =  4, 
    xmmi5 =  5, 
    xmmi6 =  6, 
    xmmi7 =  7
} XMMI_REGISTER_SET;

#define MaskCW_RC   3   /* Rounding Control */
typedef enum _XMMI_ROUNDING_CONTROL {
    rc_near = 0,        /*   near */
    rc_down = 1,        /*   down */
    rc_up   = 2,        /*   up   */
    rc_chop = 3         /*   chop */
} XMMI_ROUNDING_CONTROL;


#define HAS_IMM8            1

#pragma pack(1)

//
// Instruction Information Table structure
//

typedef struct {
    ULONG Operation:12;       // Fp Operation code
    ULONG Op1Location:5;      // Location of 1st operand
    ULONG Op2Location:5;      // Location of 2nd operand
    ULONG Op3Location:3;      // imm8
    ULONG ResultLocation:5;   // Location of result
    ULONG NumArgs:2;          // # of args to the instruction 
} XMMI_INSTR_INFO, *PXMMI_INSTR_INFO;

//
// Instruction format
//

typedef struct {
    ULONG   Opcode1a:4;
    ULONG   Opcode1b:4;
    ULONG   RM:3;
    ULONG   Reg:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} XMMIINSTR, *PXMMIINSTR;


#ifdef LITTLE_ENDIAN

//
// Single Precision Type
//
typedef struct _FP32_TYPE {
    ULONG Significand:23;
    ULONG Exponent:8;   
    ULONG Sign:1;
} FP32_TYPE, *PFP32_TYPE;

//
// Double Precision Type
//
typedef struct _FP64_TYPE {
    ULONG SignificandLo;
    ULONG SignificandHi:20;
    ULONG Exponent:11;
    ULONG Sign:1;
} FP64_TYPE, *PFP64_TYPE;

//
// Exception Flags
//
typedef struct _XMMI_EXCEPTION_FLAGS {
    ULONG   ie:1;
    ULONG   de:1;
    ULONG   ze:1;
    ULONG   oe:1;
    ULONG   ue:1;
    ULONG   pe:1;
} XMMI_EXCEPTION_FLAGS, *PXMMI_EXCEPTION_FLAGS;

//
// Exception Masks
//
typedef struct _XMMI_EXCEPTION_MASKS {
    ULONG   im:1;
    ULONG   dm:1;
    ULONG   zm:1;
    ULONG   om:1;
    ULONG   um:1;
    ULONG   pm:1;
} XMMI_EXCEPTION_MASKS, *PXMMI_EXCEPTION_MASKS;

//
// Control/Status register
//
typedef struct _MXCSR {
    ULONG   ie:1;                      /* bit  0,  invalid operand exception */  
    ULONG   de:1;                      /* bit  1,  denormalized operand exception */       
    ULONG   ze:1;                      /* bit  2,  divide-by-zero exception */   
    ULONG   oe:1;                      /* bit  3,  numeric overflow exception */
    ULONG   ue:1;                      /* bit  4,  numeric underflow exception */
    ULONG   pe:1;                      /* bit  5,  inexact precision result exception */                                        
    ULONG   daz:1;                     /* bit  6,  reserved field before WMT C-Step */
    ULONG   im:1;                      /* bit  7,  invalid operand mask */
    ULONG   dm:1;                      /* bit  8,  denormalized operand mask */
    ULONG   zm:1;                      /* bit  9,  divide-by-zero mask */
    ULONG   om:1;                      /* bit  10, numeric overflow mask */
    ULONG   um:1;                      /* bit  11, numeric underflow mask */
    ULONG   pm:1;                      /* bit  12, inexact precision result mask */
    ULONG   Rc:2;                      /* bits 13-14, rounding control */
    ULONG   Fz:1;                      /* bit  15, flush to zero */
    ULONG   reserved2:16;              /* bits 16-31, reserved field */
} MXCSR, *PMXCSR;

#endif /* LITTLE_ENDIAN */

#pragma pack()

typedef struct _MXCSRReg {
    union {
        ULONG ul;
        MXCSR mxcsr;
    } u;
} MXCSRReg, *PMXCSRReg;

#define MXCSR_FLAGS_MASK 0x0000003f
#define MXCSR_MASKS_MASK 0x00001f80

//
// Define XMMI data types
//

/* type of 32 bit items */
typedef struct _XMMI32 {
    union {        
        ULONG     ul[1];
        USHORT    uw[2];
        UCHAR     ub[4];       
        LONG      l[1];        
        SHORT     w[2];        
        CHAR      b[4];       
        float     fs[1];      
        FP32_TYPE fp32;   
    } u;
} XMMI32, *PXMMI32;  

/* type of 64 bit items */
typedef struct _MMX64 {
    union {       
        DWORDLONG dl;       
        __int64   ull;
        ULONG     ul[2];        
        USHORT    uw[4];        
        UCHAR     ub[8];        
        LONGLONG  ll;        
        LONG      l[2];        
        SHORT     w[4];       
        CHAR      b[8];        
        float     fs[2];        
        FP32_TYPE fp32[2];        
        double    fd;        
        FP64_TYPE fp64;  
        _U64      u64;
    } u;
} MMX64, *PMMX64;  

/* type of 128 bit items */  
typedef struct _XMMI128 {   
    union {        
        DWORDLONG dl[2];       
        __int64   ull[2];
        ULONG     ul[4];        
        USHORT    uw[8];        
        UCHAR     ub[16];        
        LONGLONG  ll[2];        
        LONG      l[4];        
        SHORT     w[8];        
        CHAR      b[16];        
        float     fs[4];       
        FP32_TYPE fp32[4];        
        double    fd[2];       
        FP64_TYPE fp64[2];
        _FP128    fp128;
    } u;
} XMMI128, *PXMMI128;  


//
// Define fp enviornment data structure to store fp internal states for each data item in SIMD
//
typedef struct _XMMI_ENV {
    ULONG Masks;                  //Mask values from MxCsr
    ULONG Flags;                  //Exception flags
    ULONG Fz;                     //Flush to Zero
    ULONG Daz;                    //denormals are zero
    ULONG Rc;                     //Rounding
    ULONG Precision;              //Precision
    ULONG Imm8;                   //imm8 predicate
    ULONG EFlags;                 //EFLAGS
    _FPIEEE_RECORD *Ieee;         //Value description
} XMMI_ENV, *PXMMI_ENV;
    
// 
// Define fp environment data structure to keep track of fp internal states for SIMD
//
typedef struct _OPERAND {
    ULONG   OpLocation;               //Location of the operand
    ULONG   OpReg;                    //Register Number
    _FPIEEE_VALUE Op;                 //Value description
} OPERAND, *POPERAND;

typedef struct _XMMI_FP_ENV {
    ULONG IFlags;                     //Exception Flag values from the Processor MXCsr
    ULONG OFlags;                     //Exception Flag values from the Emulator (ORed)
    ULONG Raised[4];                  //Exception is raised or not for each data item
    ULONG Flags[4];                   //Exception Flag values for each data item
    ULONG OriginalOperation;          //Original opcode
    ULONG Imm8;                       //imm8 encoding
    ULONG EFlags;                     //EFlags values from the Emulator (ORed)
    OPERAND Operand1;                 //Operand1 (128 bits)
    OPERAND Operand2;                 //Operand2 (128 bits)
    OPERAND Result;                   //Result   (128 bits)
} XMMI_FP_ENV, *PXMMI_FP_ENV;
   
//
// encodings of imm8 for CMPPS, CMPSS
//

#define IMM8_EQ    0x00
#define IMM8_LT    0x01
#define IMM8_LE    0x02
#define IMM8_UNORD 0x03
#define IMM8_NEQ   0x04
#define IMM8_NLT   0x05
#define IMM8_NLE   0x06
#define IMM8_ORD   0x07

#ifdef _XMMI_DEBUG

#define DPrint(l,m)                { \
    if (l & DebugFlag) {             \
        printf m;                    \
        if (Console) _cprintf m;     \
    }                                \
}

#define PRINTF(m)                  { \
    printf m;                        \
    if (Console) _cprintf m;         \
}

#else

    #define DPrint(l,m)
    #define PRINTF(m)


#endif // DEBUG

#endif /* _XMMI_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\dvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *	File name : dvec.h  class definitions
 *
 *	Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *	Facilitates an easy transition to compiler intrinsics
 *	or assembly language.
 *
 */

#ifndef DVEC_H_INCLUDED
#define DVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <fvec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */


/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

/* EMM Functionality Intrinsics */

class I8vec16;			/* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;			/* 16 elements, each element a signed char data type */
class Iu8vec16;			/* 16 elements, each element an unsigned char data type */
class I16vec8;			/* 8 elements, each element a signed or unsigned short */
class Is16vec8;			/* 8 elements, each element a signed short */
class Iu16vec8;			/* 8 elements, each element an unsigned short */
class I32vec4;			/* 4 elements, each element a signed or unsigned long */
class Is32vec4;			/* 4 elements, each element a signed long */
class Iu32vec4;			/* 4 elements, each element a unsigned long */
class I64vec2;			/* 2 element, each a __m64 data type */
class I128vec1;			/* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

inline const __m128i get_mask128()
{
	static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
	return mask128;
}


/* M128 Class:
 * 1 element, a __m128i data type
 * Contructors & Logical Operations
 */

class M128
{
protected:
		__m128i vec;

public:
	M128()									{ }
	M128(__m128i mm)						{ vec = mm; }

	operator __m128i() const					{ return vec; }

	/* Logical Operations */
	M128& operator&=(const M128 &a)					{ return *this = (M128) _mm_and_si128(vec,a); }
	M128& operator|=(const M128 &a)					{ return *this = (M128) _mm_or_si128(vec,a); }
	M128& operator^=(const M128 &a)					{ return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)	{ return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)	{ return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)	{ return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)	{ return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128
{
public:
	I128vec1()								{ }
	I128vec1(__m128i mm) : M128(mm)				{ }

	I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
	I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
	I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
	I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class:
 * 2 elements, each element signed or unsigned 64-bit integer
 */
class I64vec2 : public M128
{
public:
	I64vec2() { }
	I64vec2(__m128i mm) : M128(mm) { }

	I64vec2(__m64 q1, __m64 q0)
	{
		_MM_2QW(0,vec) = *(__int64*)&q0;
		_MM_2QW(1,vec) = *(__int64*)&q1;
	}

	/* Assignment Operator */
	I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

	/* Logical Assignment Operators */
	I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
	I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
	I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I64vec2& operator +=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_add_epi64(vec,a); }
	I64vec2& operator -=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sub_epi64(vec,a); }

	/* Shift Logical Operators */
	I64vec2 operator<<(const I64vec2 &a) 			{ return _mm_sll_epi64(vec,a); }
	I64vec2 operator<<(int count) 					{ return _mm_slli_epi64(vec,count); }
	I64vec2& operator<<=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sll_epi64(vec,a); }
	I64vec2& operator<<=(int count) 				{ return *this = (I64vec2) _mm_slli_epi64(vec,count); }
	I64vec2 operator>>(const I64vec2 &a) 			{ return _mm_srl_epi64(vec,a); }
	I64vec2 operator>>(int count) 					{ return _mm_srli_epi64(vec,count); }
	I64vec2& operator>>=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_srl_epi64(vec,a); }
	I64vec2& operator>>=(int count) 				{ return *this = (I64vec2) _mm_srli_epi64(vec,count); }

	/* Element Access for Debug, No data modified */
	const __int64& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	__int64& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class:
 * 4 elements, each element either a signed or unsigned int
 */
class I32vec4 : public M128
{
public:
	I32vec4() { }
	I32vec4(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I32vec4& operator= (const M128 &a)				{ return *this = (I32vec4) a; }

	/* Logicals Operators */
	I32vec4& operator&=(const M128 &a)				{ return *this = (I32vec4) _mm_and_si128(vec,a); }
	I32vec4& operator|=(const M128 &a)				{ return *this = (I32vec4) _mm_or_si128(vec,a); }
	I32vec4& operator^=(const M128 &a)				{ return *this = (I32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec4& operator +=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_add_epi32(vec,a); }
	I32vec4& operator -=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	I32vec4 operator<<(const I32vec4 &a) 			{ return _mm_sll_epi32(vec,a); }
	I32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	I32vec4& operator<<=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sll_epi32(vec,a); }
	I32vec4& operator<<=(int count) 				{ return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class:
 * 4 elements, each element signed integer
 */
class Is32vec4 : public I32vec4
{
public:
	Is32vec4() { }
	Is32vec4(__m128i mm) : I32vec4(mm) { }
	Is32vec4(int i3, int i2, int i1, int i0)
	{
		_MM_4DW(0,vec) = i0;
		_MM_4DW(1,vec) = i1;
		_MM_4DW(2,vec) = i2;
		_MM_4DW(3,vec) = i3;
	}

	/* Assignment Operator */
	Is32vec4& operator= (const M128 &a)		{ return *this = (Is32vec4) a; }

	/* Logical Operators */
	Is32vec4& operator&=(const M128 &a)		{ return *this = (Is32vec4) _mm_and_si128(vec,a); }
	Is32vec4& operator|=(const M128 &a)		{ return *this = (Is32vec4) _mm_or_si128(vec,a); }
	Is32vec4& operator^=(const M128 &a)		{ return *this = (Is32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec4& operator +=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_add_epi32(vec,a); }
	Is32vec4& operator -=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Is32vec4 operator<<(const M128 &a) 		{ return _mm_sll_epi32(vec,a); }
	Is32vec4 operator<<(int count) 			{ return _mm_slli_epi32(vec,count); }
	Is32vec4& operator<<=(const M128 &a)	{ return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
	Is32vec4& operator<<=(int count) 		{ return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec4 operator>>(const M128 &a) 		{ return _mm_sra_epi32(vec,a); }
	Is32vec4 operator>>(int count) 			{ return _mm_srai_epi32(vec,count); }
	Is32vec4& operator>>=(const M128 &a)	{ return *this = (Is32vec4) _mm_sra_epi32(vec,a); }
	Is32vec4& operator>>=(int count) 		{ return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec4 &a)
	{
		os << "[3]:" << _MM_4DW(3,a)
			<< " [2]:" << _MM_4DW(2,a)
			<< " [1]:" << _MM_4DW(1,a)
			<< " [0]:" << _MM_4DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}

	/* Element Access for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b) 	    	{ return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)			{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b) 		{ return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)		{ return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class:
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4
{
public:
	Iu32vec4() { }
	Iu32vec4(__m128i mm) : I32vec4(mm) { }
	Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
	{
		_MM_4UDW(0,vec) = ui0;
		_MM_4UDW(1,vec) = ui1;
		_MM_4UDW(2,vec) = ui2;
		_MM_4UDW(3,vec) = ui3;
	}

	/* Assignment Operator */
	Iu32vec4& operator= (const M128 &a)		{ return *this = (Iu32vec4) a; }

	/* Logical Assignment Operators */
	Iu32vec4& operator&=(const M128 &a)		{ return *this = (Iu32vec4) _mm_and_si128(vec,a); }
	Iu32vec4& operator|=(const M128 &a)		{ return *this = (Iu32vec4) _mm_or_si128(vec,a); }
	Iu32vec4& operator^=(const M128 &a)		{ return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec4& operator +=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
	Iu32vec4& operator -=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Iu32vec4 operator<<(const M128 &a) 				{ return _mm_sll_epi32(vec,a); }
	Iu32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	Iu32vec4& operator<<=(const M128 &a)			{ return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
	Iu32vec4& operator<<=(int count) 				{ return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
	Iu32vec4 operator>>(const M128 &a) 				{ return _mm_srl_epi32(vec,a); }
	Iu32vec4 operator>>(int count) 					{ return _mm_srli_epi32(vec,count); }
	Iu32vec4& operator>>=(const M128 &a)			{ return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
	Iu32vec4& operator>>=(int count) 				{ return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec4 &a)
	{
		os << "[3]:" << _MM_4UDW(3,a)
			<< " [2]:" << _MM_4UDW(2,a)
			<< " [1]:" << _MM_4UDW(1,a)
			<< " [0]:" << _MM_4UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)	{ return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class:
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128
{
public:
	I16vec8() { }
	I16vec8(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I16vec8& operator= (const M128 &a)		{ return *this = (I16vec8) a; }

	/* Logical Assignment Operators */
	I16vec8& operator&=(const M128 &a)		{ return *this = (I16vec8) _mm_and_si128(vec,a); }
	I16vec8& operator|=(const M128 &a)		{ return *this = (I16vec8) _mm_or_si128(vec,a); }
	I16vec8& operator^=(const M128 &a)		{ return *this = (I16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec8& operator +=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_add_epi16(vec,a); }
	I16vec8& operator -=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_sub_epi16(vec,a); }
	I16vec8& operator *=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	I16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	I16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	I16vec8& operator<<=(const M128 &a)				{ return *this = (I16vec8)_mm_sll_epi16(vec,a); }
	I16vec8& operator<<=(int count) 				{ return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class:
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8
{
public:
	Is16vec8() { }
	Is16vec8(__m128i mm) : I16vec8(mm) { }
	Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
	 {
		_MM_8W(0,vec) = s0;
		_MM_8W(1,vec) = s1;
		_MM_8W(2,vec) = s2;
		_MM_8W(3,vec) = s3;
		_MM_8W(4,vec) = s4;
		_MM_8W(5,vec) = s5;
		_MM_8W(6,vec) = s6;
		_MM_8W(7,vec) = s7;
	}

	/* Assignment Operator */
	Is16vec8& operator= (const M128 &a)		{ return *this = (Is16vec8) a; }

	/* Logical Assignment Operators */
	Is16vec8& operator&=(const M128 &a)		{ return *this = (Is16vec8) _mm_and_si128(vec,a); }
	Is16vec8& operator|=(const M128 &a)		{ return *this = (Is16vec8) _mm_or_si128(vec,a); }
	Is16vec8& operator^=(const M128 &a)		{ return *this = (Is16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec8& operator +=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_add_epi16(vec,a); }
	Is16vec8& operator -=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_sub_epi16(vec,a); }
	Is16vec8& operator *=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Is16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Is16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	Is16vec8& operator<<=(const M128 &a)			{ return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
	Is16vec8& operator<<=(int count) 				{ return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
	/* Shift Arithmetic Operators */
	Is16vec8 operator>>(const M128 &a) 				{ return _mm_sra_epi16(vec,a); }
	Is16vec8 operator>>(int count) 				{ return _mm_srai_epi16(vec,count); }
	Is16vec8& operator>>=(const M128 &a)			{ return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
	Is16vec8& operator>>=(int count) 				{ return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec8 &a)
	{
		os << "[7]:" << _MM_8W(7,a)
			<< " [6]:" << _MM_8W(6,a)
			<< " [5]:" << _MM_8W(5,a)
			<< " [4]:" << _MM_8W(4,a)
			<< " [3]:" << _MM_8W(3,a)
			<< " [2]:" << _MM_8W(2,a)
			<< " [1]:" << _MM_8W(1,a)
			<< " [0]:" << _MM_8W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mullo_epi16(a,b); }


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_min_epi16(a,b); }


/* Iu16vec8 Class:
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8
{
public:
	Iu16vec8() { }
	Iu16vec8(__m128i mm) : I16vec8(mm) { }
	Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
	{
		_MM_8UW(0,vec) = s0;
		_MM_8UW(1,vec) = s1;
		_MM_8UW(2,vec) = s2;
		_MM_8UW(3,vec) = s3;
		_MM_8UW(4,vec) = s4;
		_MM_8UW(5,vec) = s5;
		_MM_8UW(6,vec) = s6;
		_MM_8UW(7,vec) = s7;
	}

	/* Assignment Operator */
	Iu16vec8& operator= (const M128 &a)		{ return *this = (Iu16vec8) a; }
	/* Logical Assignment Operators */
	Iu16vec8& operator&=(const M128 &a)		{ return *this = (Iu16vec8) _mm_and_si128(vec,a); }
	Iu16vec8& operator|=(const M128 &a)		{ return *this = (Iu16vec8) _mm_or_si128(vec,a); }
	Iu16vec8& operator^=(const M128 &a)		{ return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu16vec8& operator +=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
	Iu16vec8& operator -=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }
	Iu16vec8& operator *=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Iu16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Iu16vec8 operator<<(int count) 					{ return _mm_slli_epi16(vec,count); }
	Iu16vec8& operator<<=(const M128 &a)			{ return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
	Iu16vec8& operator<<=(int count) 				{ return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
	Iu16vec8 operator>>(const M128 &a) 				{ return _mm_srl_epi16(vec,a); }
	Iu16vec8 operator>>(int count) 					{ return _mm_srli_epi16(vec,count); }
	Iu16vec8& operator>>=(const M128 &a)			{ return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
	Iu16vec8& operator>>=(int count) 				{ return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu16vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UW(7,a))
			<< " [6]:" << unsigned short(_MM_8UW(6,a))
			<< " [5]:" << unsigned short(_MM_8UW(5,a))
			<< " [4]:" << unsigned short(_MM_8UW(4,a))
			<< " [3]:" << unsigned short(_MM_8UW(3,a))
			<< " [2]:" << unsigned short(_MM_8UW(2,a))
			<< " [1]:" << unsigned short(_MM_8UW(1,a))
			<< " [0]:" << unsigned short(_MM_8UW(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}

	/* Element Access for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class:
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128
{
public:
	I8vec16() { }
	I8vec16(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I8vec16& operator= (const M128 &a)		{ return *this = (I8vec16) a; }

	/* Logical Assignment Operators */
	I8vec16& operator&=(const M128 &a)		{ return *this = (I8vec16) _mm_and_si128(vec,a); }
	I8vec16& operator|=(const M128 &a)		{ return *this = (I8vec16) _mm_or_si128(vec,a); }
	I8vec16& operator^=(const M128 &a)		{ return *this = (I8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec16& operator +=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_add_epi8(vec,a); }
	I8vec16& operator -=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_sub_epi8(vec,a); }

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)	{ return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class:
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16
{
public:
	Is8vec16() { }
	Is8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Is8vec16& operator= (const M128 &a)		{ return *this = (Is8vec16) a; }

	/* Logical Assignment Operators */
	Is8vec16& operator&=(const M128 &a)		{ return *this = (Is8vec16) _mm_and_si128(vec,a); }
	Is8vec16& operator|=(const M128 &a)		{ return *this = (Is8vec16) _mm_or_si128(vec,a); }
	Is8vec16& operator^=(const M128 &a)		{ return *this = (Is8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec16& operator +=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_add_epi8(vec,a); }
	Is8vec16& operator -=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Is8vec16 &a)
	{
		 os << "[15]:"  << short(_MM_16B(15,a))
			<< " [14]:" << short(_MM_16B(14,a))
			<< " [13]:" << short(_MM_16B(13,a))
			<< " [12]:" << short(_MM_16B(12,a))
			<< " [11]:" << short(_MM_16B(11,a))
			<< " [10]:" << short(_MM_16B(10,a))
			<< " [9]:" << short(_MM_16B(9,a))
			<< " [8]:" << short(_MM_16B(8,a))
		      << " [7]:" << short(_MM_16B(7,a))
			<< " [6]:" << short(_MM_16B(6,a))
			<< " [5]:" << short(_MM_16B(5,a))
			<< " [4]:" << short(_MM_16B(4,a))
			<< " [3]:" << short(_MM_16B(3,a))
			<< " [2]:" << short(_MM_16B(2,a))
			<< " [1]:" << short(_MM_16B(1,a))
			<< " [0]:" << short(_MM_16B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

	/* Element Access for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class:
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16
{
public:
	Iu8vec16() { }
	Iu8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Iu8vec16& operator= (const M128 &a)		{ return *this = (Iu8vec16) a; }

	/* Logical Assignment Operators */
	Iu8vec16& operator&=(const M128 &a)		{ return *this = (Iu8vec16) _mm_and_si128(vec,a); }
	Iu8vec16& operator|=(const M128 &a)		{ return *this = (Iu8vec16) _mm_or_si128(vec,a); }
	Iu8vec16& operator^=(const M128 &a)		{ return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu8vec16& operator +=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
	Iu8vec16& operator -=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec16 &a)
	{
		 os << "[15]:"  << unsigned short(_MM_16UB(15,a))
			<< " [14]:" << unsigned short(_MM_16UB(14,a))
			<< " [13]:" << unsigned short(_MM_16UB(13,a))
			<< " [12]:" << unsigned short(_MM_16UB(12,a))
			<< " [11]:" << unsigned short(_MM_16UB(11,a))
			<< " [10]:" << unsigned short(_MM_16UB(10,a))
			<< " [9]:" << unsigned short(_MM_16UB(9,a))
			<< " [8]:" << unsigned short(_MM_16UB(8,a))
		      << " [7]:" << unsigned short(_MM_16UB(7,a))
			<< " [6]:" << unsigned short(_MM_16UB(6,a))
			<< " [5]:" << unsigned short(_MM_16UB(5,a))
			<< " [4]:" << unsigned short(_MM_16UB(4,a))
			<< " [3]:" << unsigned short(_MM_16UB(3,a))
			<< " [2]:" << unsigned short(_MM_16UB(2,a))
			<< " [1]:" << unsigned short(_MM_16UB(1,a))
			<< " [0]:" << unsigned short(_MM_16UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b) 	{ return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); }

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 )))));	\
}
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)


#undef IVEC128_SELECT


class F64vec2
{
protected:
   	 __m128d vec;
public:

	/* Constructors: __m128d, 2 doubles */
	F64vec2() {}

	/* initialize 2 DP FP with __m128d data type */
	F64vec2(__m128d m)					{ vec = m;}

	/* initialize 2 DP FPs with 2 doubles */
	F64vec2(double d1, double d0)		                { vec= _mm_set_pd(d1,d0); }

	/* Explicitly initialize each of 2 DP FPs with same double */
	EXPLICIT F64vec2(double d)	{ vec = _mm_set1_pd(d); }

	/* Conversion functions */
	operator  __m128d() const	{ return vec; }		/* Convert to __m128d */

 	/* Logical Operators */
	friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
	friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
	friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

	/* Arithmetic Operators */
	friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
	friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); }
	friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); }
	friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

	F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
	F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }
	F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); }
	F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
	F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
	F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
	F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

	/* Horizontal Add */
	friend double add_horizontal(F64vec2 &a)
	{
		F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
		return ftemp[0];
	}

	/* And Not */
	friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

	/* Square Root */
	friend F64vec2 sqrt(const F64vec2 &a)		{ return _mm_sqrt_pd(a); }

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
			friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b)
			{ return _mm_cmpeq_ps(a,b);} */
	#define F64vec2_COMP(op) \
	friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
		F64vec2_COMP(eq)					// expanded to cmpeq(a,b)
		F64vec2_COMP(lt)					// expanded to cmplt(a,b)
		F64vec2_COMP(le)					// expanded to cmple(a,b)
		F64vec2_COMP(gt)					// expanded to cmpgt(a,b)
		F64vec2_COMP(ge)					// expanded to cmpge(a,b)
		F64vec2_COMP(ngt)					// expanded to cmpngt(a,b)
		F64vec2_COMP(nge)					// expanded to cmpnge(a,b)
		F64vec2_COMP(neq)					// expanded to cmpneq(a,b)
		F64vec2_COMP(nlt)					// expanded to cmpnlt(a,b)
		F64vec2_COMP(nle)					// expanded to cmpnle(a,b)
	#undef F64vec2_COMP

	/* Min and Max */
	friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
	friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
	#define F64vec2_COMI(op) \
	friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
		F64vec2_COMI(eq)					// expanded to comieq(a,b)
		F64vec2_COMI(lt)					// expanded to comilt(a,b)
		F64vec2_COMI(le)					// expanded to comile(a,b)
		F64vec2_COMI(gt)					// expanded to comigt(a,b)
		F64vec2_COMI(ge)					// expanded to comige(a,b)
		F64vec2_COMI(neq)					// expanded to comineq(a,b)
	#undef F64vec2_COMI

        /* Compare lower DP FP values */
	#define F64vec2_UCOMI(op) \
	friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
		F64vec2_UCOMI(eq)					// expanded to ucomieq(a,b)
		F64vec2_UCOMI(lt)					// expanded to ucomilt(a,b)
		F64vec2_UCOMI(le)					// expanded to ucomile(a,b)
		F64vec2_UCOMI(gt)					// expanded to ucomigt(a,b)
		F64vec2_UCOMI(ge)					// expanded to ucomige(a,b)
		F64vec2_UCOMI(neq)					// expanded to ucomineq(a,b)
	#undef F64vec2_UCOMI

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F64vec2 &a)
	{
	/* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */
	  double *dp = (double*)&a;
		os <<	" [1]:" << *(dp+1)
			<< " [0]:" << *dp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const double& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
	/* Element Access and Modification*/
	double& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)
{ return _mm_movemask_pd(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)
{ a = _mm_loadu_pd(p); }

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)
{ _mm_storeu_pd(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a)
{ _mm_stream_pd(p,a);}

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d) 	   \
{																\
	F64vec2 mask = _mm_cmp##op##_pd(a,b);						\
	return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d))));	\
}
F64vec2_SELECT(eq)		// generates select_eq(a,b)
F64vec2_SELECT(lt)		// generates select_lt(a,b)
F64vec2_SELECT(le)		// generates select_le(a,b)
F64vec2_SELECT(gt)		// generates select_gt(a,b)
F64vec2_SELECT(ge)		// generates select_ge(a,b)
F64vec2_SELECT(neq)		// generates select_neq(a,b)
F64vec2_SELECT(nlt)		// generates select_nlt(a,b)
F64vec2_SELECT(nle)		// generates select_nle(a,b)
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{

	return _mm_cvttsd_si32(a);

}

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{
	return _mm_cvtps_pd(a);
}

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{
	return _mm_cvtpd_ps(a);
}

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{
	return _mm_cvtsi32_sd(a,b);
}

#pragma pack(pop) /* 16-B aligned */
#endif // DVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\emmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * emmintrin.h
 *
 * Principal header file for Willamette New Instruction intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _EMM_FUNCTIONALITY is defined; if it is, the C implementation
 * will be used (the "functional intrinsics").
 */

#ifndef _INCLUDED_EMM
#define _INCLUDED_EMM

/*
 * the __m128 & __m64 types are required for the intrinsics
 */
#include <xmmintrin.h>

#ifdef __ICL
#ifdef _EMM_FUNCTIONALITY
#include "emm_func.h"
#else
typedef long long __m128d;
typedef long long __m128i;
#endif
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];    
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;
#endif

/*
 * Macro function for shuffle
 */
#define _MM_SHUFFLE2(x,y) (((x)<<1) | (y))

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * DP, arithmetic
 */

extern __m128d _mm_add_sd(__m128d a, __m128d b);
extern __m128d _mm_add_pd(__m128d a, __m128d b);
extern __m128d _mm_sub_sd(__m128d a, __m128d b);
extern __m128d _mm_sub_pd(__m128d a, __m128d b);
extern __m128d _mm_mul_sd(__m128d a, __m128d b);
extern __m128d _mm_mul_pd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_sd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_pd(__m128d a);
extern __m128d _mm_div_sd(__m128d a, __m128d b);
extern __m128d _mm_div_pd(__m128d a, __m128d b);
extern __m128d _mm_min_sd(__m128d a, __m128d b);
extern __m128d _mm_min_pd(__m128d a, __m128d b);
extern __m128d _mm_max_sd(__m128d a, __m128d b);
extern __m128d _mm_max_pd(__m128d a, __m128d b);

/*
 * DP, logicals
 */

extern __m128d _mm_and_pd(__m128d a, __m128d b);
extern __m128d _mm_andnot_pd(__m128d a, __m128d b);
extern __m128d _mm_or_pd(__m128d a, __m128d b);
extern __m128d _mm_xor_pd(__m128d a, __m128d b);

/*
 * DP, comparisons
 */

extern __m128d _mm_cmpeq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpeq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmple_sd(__m128d a, __m128d b);
extern __m128d _mm_cmple_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_sd(__m128d a, __m128d b);
extern int _mm_comieq_sd(__m128d a, __m128d b);
extern int _mm_comilt_sd(__m128d a, __m128d b);
extern int _mm_comile_sd(__m128d a, __m128d b);
extern int _mm_comigt_sd(__m128d a, __m128d b);
extern int _mm_comige_sd(__m128d a, __m128d b);
extern int _mm_comineq_sd(__m128d a, __m128d b);
extern int _mm_ucomieq_sd(__m128d a, __m128d b);
extern int _mm_ucomilt_sd(__m128d a, __m128d b);
extern int _mm_ucomile_sd(__m128d a, __m128d b);
extern int _mm_ucomigt_sd(__m128d a, __m128d b);
extern int _mm_ucomige_sd(__m128d a, __m128d b);
extern int _mm_ucomineq_sd(__m128d a, __m128d b);

/*
 * DP, converts
 */

extern __m128d _mm_cvtepi32_pd(__m128i a);
extern __m128i _mm_cvtpd_epi32(__m128d a);
extern __m128i _mm_cvttpd_epi32(__m128d a);
extern __m128 _mm_cvtepi32_ps(__m128i a);
extern __m128i _mm_cvtps_epi32(__m128 a);
extern __m128i _mm_cvttps_epi32(__m128 a);
extern __m128 _mm_cvtpd_ps(__m128d a);
extern __m128d _mm_cvtps_pd(__m128 a);
extern __m128 _mm_cvtsd_ss(__m128 a, __m128d b);
extern __m128d _mm_cvtss_sd(__m128d a, __m128 b);

extern int _mm_cvtsd_si32(__m128d a);
extern int _mm_cvttsd_si32(__m128d a);
extern __m128d _mm_cvtsi32_sd(__m128d a, int b);

extern __m64 _mm_cvtpd_pi32(__m128d a);
extern __m64 _mm_cvttpd_pi32(__m128d a);
extern __m128d _mm_cvtpi32_pd(__m64 a);

/*
 * DP, misc
 */

extern __m128d _mm_unpackhi_pd(__m128d a, __m128d b);
extern __m128d _mm_unpacklo_pd(__m128d a, __m128d b);
extern int _mm_movemask_pd(__m128d a);
extern __m128d _mm_shuffle_pd(__m128d a, __m128d b, int i);

/*
 * DP, loads
 */

extern __m128d _mm_load_pd(double const*dp);
extern __m128d _mm_load1_pd(double const*dp);
extern __m128d _mm_loadr_pd(double const*dp);
extern __m128d _mm_loadu_pd(double const*dp);
extern __m128d _mm_load_sd(double const*dp);
extern __m128d _mm_loadh_pd(__m128d a, double const*dp);
extern __m128d _mm_loadl_pd(__m128d a, double const*dp);

/*
 * DP, sets
 */

extern __m128d _mm_set_sd(double w);
extern __m128d _mm_set1_pd(double a);
extern __m128d _mm_set_pd(double z, double y);
extern __m128d _mm_setr_pd(double y, double z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d a, __m128d b);;

/* 
 * DP, stores
 */

extern void _mm_store_sd(double *dp, __m128d a);
extern void _mm_store1_pd(double *dp, __m128d a);
extern void _mm_store_pd(double *dp, __m128d a);
extern void _mm_storeu_pd(double *dp, __m128d a);
extern void _mm_storer_pd(double *dp, __m128d a);
extern void _mm_storeh_pd(double *dp, __m128d a);
extern void _mm_storel_pd(double *dp, __m128d a);

/*
 * Integer, arithmetic
 */

extern __m128i _mm_add_epi8(__m128i a, __m128i b);
extern __m128i _mm_add_epi16(__m128i a, __m128i b);
extern __m128i _mm_add_epi32(__m128i a, __m128i b);
extern __m64 _mm_add_si64(__m64 a, __m64 b);
extern __m128i _mm_add_epi64(__m128i a, __m128i b);
extern __m128i _mm_adds_epi8(__m128i a, __m128i b);
extern __m128i _mm_adds_epi16(__m128i a, __m128i b);
extern __m128i _mm_adds_epu8(__m128i a, __m128i b);
extern __m128i _mm_adds_epu16(__m128i a, __m128i b);
extern __m128i _mm_avg_epu8(__m128i a, __m128i b);
extern __m128i _mm_avg_epu16(__m128i a, __m128i b);
extern __m128i _mm_madd_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epu8(__m128i a, __m128i b);
extern __m128i _mm_min_epi16(__m128i a, __m128i b);
extern __m128i _mm_min_epu8(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epu16(__m128i a, __m128i b);
extern __m128i _mm_mullo_epi16(__m128i a, __m128i b);
extern __m64 _mm_mul_su32(__m64 a, __m64 b);
extern __m128i _mm_mul_epu32(__m128i a, __m128i b);
extern __m128i _mm_sad_epu8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi16(__m128i a, __m128i b);
extern __m128i _mm_sub_epi32(__m128i a, __m128i b);
extern __m64 _mm_sub_si64(__m64 a, __m64 b);
extern __m128i _mm_sub_epi64(__m128i a, __m128i b);
extern __m128i _mm_subs_epi8(__m128i a, __m128i b);
extern __m128i _mm_subs_epi16(__m128i a, __m128i b);
extern __m128i _mm_subs_epu8(__m128i a, __m128i b);
extern __m128i _mm_subs_epu16(__m128i a, __m128i b);

/*
 * Integer, logicals
 */

extern __m128i _mm_and_si128(__m128i a, __m128i b);
extern __m128i _mm_andnot_si128(__m128i a, __m128i b);
extern __m128i _mm_or_si128(__m128i a, __m128i b);
extern __m128i _mm_xor_si128(__m128i a, __m128i b);

/*
 * Integer, shifts
 */

extern __m128i _mm_slli_si128(__m128i a, int imm);
extern __m128i _mm_slli_epi16(__m128i a, int count);
extern __m128i _mm_sll_epi16(__m128i a, __m128i count);
extern __m128i _mm_slli_epi32(__m128i a, int count);
extern __m128i _mm_sll_epi32(__m128i a, __m128i count);
extern __m128i _mm_slli_epi64(__m128i a, int count);
extern __m128i _mm_sll_epi64(__m128i a, __m128i count);
extern __m128i _mm_srai_epi16(__m128i a, int count);
extern __m128i _mm_sra_epi16(__m128i a, __m128i count);
extern __m128i _mm_srai_epi32(__m128i a, int count);
extern __m128i _mm_sra_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_si128(__m128i a, int imm);
extern __m128i _mm_srli_epi16(__m128i a, int count);
extern __m128i _mm_srl_epi16(__m128i a, __m128i count);
extern __m128i _mm_srli_epi32(__m128i a, int count);
extern __m128i _mm_srl_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_epi64(__m128i a, int count);
extern __m128i _mm_srl_epi64(__m128i a, __m128i count);

/*
 * Integer, comparisons
 */

extern __m128i _mm_cmpeq_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi32(__m128i a, __m128i b);

/*
 * Integer, converts
 */

extern __m128i _mm_cvtsi32_si128(int a);
extern int _mm_cvtsi128_si32(__m128i a);

/*
 * Integer, misc
 */

extern __m128i _mm_packs_epi16(__m128i a, __m128i b);
extern __m128i _mm_packs_epi32(__m128i a, __m128i b);
extern __m128i _mm_packus_epi16(__m128i a, __m128i b);
extern int _mm_extract_epi16(__m128i a, int imm);
extern __m128i _mm_insert_epi16(__m128i a, int b, int imm);
extern int _mm_movemask_epi8(__m128i a);
extern __m128i _mm_shuffle_epi32(__m128i a, int imm);
extern __m128i _mm_shufflehi_epi16(__m128i a, int imm);
extern __m128i _mm_shufflelo_epi16(__m128i a, int imm);
extern __m128i _mm_unpackhi_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi64(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi64(__m128i a, __m128i b);

/*
 * Integer, loads
 */

extern __m128i _mm_load_si128(__m128i const*p);
extern __m128i _mm_loadu_si128(__m128i const*p);
extern __m128i _mm_loadl_epi64(__m128i const*p);

/*
 * Integer, sets
 */

extern __m128i _mm_set_epi64(__m64 q1, __m64 q0);
extern __m128i _mm_set_epi32(int i3, int i2, int i1, int i0);
extern __m128i _mm_set_epi16(short w7, short w6, short w5, short w4,
                             short w3, short w2, short w1, short w0);
extern __m128i _mm_set_epi8(char b15, char b14, char b13, char b12, 
                            char b11, char b10, char b9, char b8, 
                            char b7, char b6, char b5, char b4, 
                            char b3, char b2, char b1, char b0);
extern __m128i _mm_set1_epi64(__m64 q);
extern __m128i _mm_set1_epi32(int i);
extern __m128i _mm_set1_epi16(short w);
extern __m128i _mm_set1_epi8(char b);
extern __m128i _mm_setl_epi64(__m128i q);
extern __m128i _mm_setr_epi64(__m64 q0, __m64 q1);
extern __m128i _mm_setr_epi32(int i0, int i1, int i2, int i3);
extern __m128i _mm_setr_epi16(short w0, short w1, short w2, short w3, 
                              short w4, short w5, short w6, short w7);
extern __m128i _mm_setr_epi8(char b15, char b14, char b13, char b12, 
                             char b11, char b10, char b9, char b8, 
                             char b7, char b6, char b5, char b4, 
                             char b3, char b2, char b1, char b0);
extern __m128i _mm_setzero_si128();

/*
 * Integer, stores
 */

extern void _mm_store_si128(__m128i *p, __m128i b);
extern void _mm_storeu_si128(__m128i *p, __m128i b);
extern void _mm_storel_epi64(__m128i *p, __m128i q);
extern void _mm_maskmoveu_si128(__m128i d, __m128i n, char *p);

/*
 * Integer, moves
 */

extern __m128i _mm_move_epi64(__m128i q);
extern __m128i _mm_movpi64_epi64(__m64 q);
extern __m64 _mm_movepi64_pi64(__m128i q);

/*
 * Cacheability support
 */

extern void _mm_stream_pd(double *dp, __m128d a);;
extern void _mm_stream_si128(__m128i *p, __m128i a);
extern void _mm_clflush(void const*p);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *p, int i);
extern void _mm_pause(void);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_EMM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         //XMMI
    _FpCodeFmax,         //XMMI
    _FpCodeConvertTrunc, //XMMI
    _XMMIAddps,          //XMMI
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         //XMMI2 
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   //66 2D
    _XMMI2Cvtsd2si,   //F2
    _XMMI2Cvttpd2pi,  //66 2C
    _XMMI2Cvttsd2si,  //F2
    _XMMI2Cvtps2pd,   //0F 5A
    _XMMI2Cvtss2sd,   //F3
    _XMMI2Cvtpd2ps,   //66
    _XMMI2Cvtsd2ss,   //F2
    _XMMI2Cvtdq2ps,   //0F 5B
    _XMMI2Cvttps2dq,  //F3
    _XMMI2Cvtps2dq,   //66
    _XMMI2Cvttpd2dq,  //66 0F E6
    _XMMI2Cvtpd2dq,   //F2 
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\fvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *
 *	File name : fvec.h  Fvec class definitions
 *
 *	Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *
 *	Facilitates an easy transition to compiler intrinsics
 *
 *	or assembly language.
 *
 *	F32vec4:	4 packed single precision
 *				32-bit floating point numbers
*/

#ifndef FVEC_H_INCLUDED
#define FVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <ivec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class F32vec4
{
protected:
   	 __m128 vec;
public:

	/* Constructors: __m128, 4 floats, 1 float */
	F32vec4() {}

	/* initialize 4 SP FP with __m128 data type */
	F32vec4(__m128 m)					{ vec = m;}

	/* initialize 4 SP FPs with 4 floats */
	F32vec4(float f3, float f2, float f1, float f0)		{ vec= _mm_set_ps(f3,f2,f1,f0); }

	/* Explicitly initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec4(float f)	{ vec = _mm_set_ps1(f); }

	/* Explicitly initialize each of 4 SP FPs with same double */
	EXPLICIT F32vec4(double d)	{ vec = _mm_set_ps1((float) d); }

	/* Assignment operations */

	F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

	F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to __m128 */

 	/* Logical Operators */
	friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
	friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
	friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
	friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); }
	friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); }
	friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

	F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
	F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
	F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
	F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }
	F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); }
	F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
	F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

	/* Horizontal Add */
	friend float add_horizontal(F32vec4 &a)
	{
		F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
		return ftemp[0];
	}

	/* Square Root */
	friend F32vec4 sqrt(const F32vec4 &a)		{ return _mm_sqrt_ps(a); }
	/* Reciprocal */
	friend F32vec4 rcp(const F32vec4 &a)		{ return _mm_rcp_ps(a); }
	/* Reciprocal Square Root */
	friend F32vec4 rsqrt(const F32vec4 &a)		{ return _mm_rsqrt_ps(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
	friend F32vec4 rcp_nr(const F32vec4 &a)
	{
		F32vec4 Ra0 = _mm_rcp_ps(a);
		return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */
	friend F32vec4 rsqrt_nr(const F32vec4 &a)
	{
		static const F32vec4 fvecf0pt5(0.5f);
		static const F32vec4 fvecf3pt0(3.0f);
		F32vec4 Ra0 = _mm_rsqrt_ps(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b)
	{ return _mm_cmpeq_ps(a,b);} */
	#define Fvec32s4_COMP(op) \
	friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
		Fvec32s4_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s4_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s4_COMP(le)					// expanded to cmple(a,b)
		Fvec32s4_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s4_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s4_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s4_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s4_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s4_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s4_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s4_COMP

	/* Min and Max */
	friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
	friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec4 &a)
	{
	/* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "[3]:" << *(fp+3)
			<< " [2]:" << *(fp+2)
			<< " [1]:" << *(fp+1)
			<< " [0]:" << *fp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const float& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
	/* Element Access and Modification*/
	float& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)
{ return _mm_movemask_ps(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)
{ a = _mm_loadu_ps(p); }

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)
{ _mm_storeu_ps(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a)
{ _mm_stream_ps(p,a);}

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)
{
	F32vec4 mask = _mm_cmpeq_ps(a,b);
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 	   \
{																\
	F32vec4 mask = _mm_cmp##op##_ps(a,b);						\
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	\
}
Fvec32s4_SELECT(eq)			// generates select_eq(a,b)
Fvec32s4_SELECT(lt)			// generates select_lt(a,b)
Fvec32s4_SELECT(le)			// generates select_le(a,b)
Fvec32s4_SELECT(gt)			// generates select_gt(a,b)
Fvec32s4_SELECT(ge)			// generates select_ge(a,b)
Fvec32s4_SELECT(neq)		// generates select_neq(a,b)
Fvec32s4_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s4_SELECT(nle)		// generates select_nle(a,b)
Fvec32s4_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s4_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits	of each vec of a */
inline int move_mask(const I8vec8 &a)								{ return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)	{ _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)
{

	return _mm_cvtt_ss2si(a);

}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{

	__m64 result;
	result = _mm_cvtt_ps2pi(a);
	return Is32vec2(result);

}

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{

	__m128 result;
	result = _mm_cvt_si2ss(a,i);
	return F32vec4(result);

}

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b)
{

	__m128 result;
	result = _mm_cvt_pi2ps(a,b);
	return F32vec4(result);
}

class F32vec1
{
protected:
   	 __m128 vec;
public:

	/* Constructors: 1 float */
	F32vec1() {}

	F32vec1(int i)		{ vec = _mm_cvt_si2ss(vec,i);};

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(float f)	{ vec = _mm_set_ss(f); }

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(double d)	{ vec = _mm_set_ss((float) d); }

	/* initialize with __m128 data type */
	F32vec1(__m128 m)	{ vec = m; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to float */

 	/* Logical Operators */
	friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
	friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
	friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
	friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
	friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
	friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

	F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
	F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
	F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
	F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
	F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


	/* Square Root */
	friend F32vec1 sqrt(const F32vec1 &a)		{ return _mm_sqrt_ss(a); }
	/* Reciprocal */
	friend F32vec1 rcp(const F32vec1 &a)		{ return _mm_rcp_ss(a); }
	/* Reciprocal Square Root */
	friend F32vec1 rsqrt(const F32vec1 &a)		{ return _mm_rsqrt_ss(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
	friend F32vec1 rcp_nr(const F32vec1 &a)
	{
		F32vec1 Ra0 = _mm_rcp_ss(a);
		return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
	friend F32vec1 rsqrt_nr(const F32vec1 &a)
	{
		static const F32vec1 fvecf0pt5(0.5f);
		static const F32vec1 fvecf3pt0(3.0f);
		F32vec1 Ra0 = _mm_rsqrt_ss(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
	{ return _mm_cmpeq_ss(a,b);} */
	#define Fvec32s1_COMP(op) \
	friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
		Fvec32s1_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s1_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s1_COMP(le)					// expanded to cmple(a,b)
		Fvec32s1_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s1_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s1_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s1_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s1_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s1_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s1_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s1_COMP

	/* Min and Max */
	friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
	friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec1 &a)
	{
	/* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "float:" << *fp;
		return os;
	}
#endif

};

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
	F32vec1 mask = _mm_cmpeq_ss(a,b);
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d) 	   \
{													   \
	F32vec1 mask = _mm_cmp##op##_ss(a,b);						                   \
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));	                                           \
}
Fvec32s1_SELECT(eq)			// generates select_eq(a,b)
Fvec32s1_SELECT(lt)			// generates select_lt(a,b)
Fvec32s1_SELECT(le)			// generates select_le(a,b)
Fvec32s1_SELECT(gt)			// generates select_gt(a,b)
Fvec32s1_SELECT(ge)			// generates select_ge(a,b)
Fvec32s1_SELECT(neq)		// generates select_neq(a,b)
Fvec32s1_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s1_SELECT(nle)		// generates select_nle(a,b)
Fvec32s1_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s1_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
	return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */
#endif /* FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long SynchronizationObject[4];
    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\makefile.inc ===
clean: 
       -del /q $(CRT_FILES1) 2>nul
       -del /q $(CRT_FILES2) 2>nul
       -del /q $(CRT_FILES3) 2>nul

#
# Inference rules.  
#

.SUFFIXES:.h

{..\}.h{$(CRT_INC_PATH)}.h:
   ..\compfile  $** $@

{.\sys}.h{$(CRT_INC_PATH)\sys}.h:
   ..\compfile  $** $@

$(CRT_INC_PATH)\conio.h: ..\conio.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\direct.h: ..\direct.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\dos.h: ..\dos.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\io.h: ..\io.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\malloc.h: ..\malloc.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\process.h: ..\process.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\stdio.h: ..\stdio.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\stdlib.h: ..\stdlib.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\tchar.h: ..\tchar.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\time.h: ..\time.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\wchar.h: ..\wchar.x
   hsplit -ts noxbox -o tmp.x nul -i $** 
   ..\compfile  tmp.x $@
   del tmp.x

$(CRT_INC_PATH)\algorithm : ..\algorithm
	..\compfile $** $@

$(CRT_INC_PATH)\bitset : ..\bitset
	..\compfile $** $@

$(CRT_INC_PATH)\cassert : ..\cassert
	..\compfile  $** $@

$(CRT_INC_PATH)\cctype : ..\cctype
	..\compfile  $** $@

$(CRT_INC_PATH)\cerrno : ..\cerrno
	..\compfile  $** $@

$(CRT_INC_PATH)\cfloat : ..\cfloat
	..\compfile  $** $@

$(CRT_INC_PATH)\ciso646 : ..\ciso646
	..\compfile  $** $@

$(CRT_INC_PATH)\climits : ..\climits
	..\compfile  $** $@

$(CRT_INC_PATH)\clocale : ..\clocale
	..\compfile  $** $@

$(CRT_INC_PATH)\cmath : ..\cmath
	..\compfile  $** $@

$(CRT_INC_PATH)\complex : ..\complex
	..\compfile  $** $@

$(CRT_INC_PATH)\csetjmp : ..\csetjmp
	..\compfile  $** $@

$(CRT_INC_PATH)\csignal : ..\csignal
	..\compfile  $** $@

$(CRT_INC_PATH)\cstdarg : ..\cstdarg
	..\compfile  $** $@

$(CRT_INC_PATH)\cstddef : ..\cstddef
	..\compfile  $** $@

$(CRT_INC_PATH)\cstdio : ..\cstdio
	..\compfile  $** $@

$(CRT_INC_PATH)\cstdlib : ..\cstdlib
	..\compfile  $** $@

$(CRT_INC_PATH)\cstring : ..\cstring
	..\compfile  $** $@

$(CRT_INC_PATH)\ctime : ..\ctime
	..\compfile  $** $@

$(CRT_INC_PATH)\cwctype : ..\cwctype
	..\compfile  $** $@

$(CRT_INC_PATH)\deque : ..\deque
	..\compfile  $** $@

$(CRT_INC_PATH)\exception : ..\exception
	..\compfile  $** $@

$(CRT_INC_PATH)\fstream : ..\fstream
	..\compfile  $** $@

$(CRT_INC_PATH)\functional : ..\functional
	..\compfile  $** $@

$(CRT_INC_PATH)\iomanip : ..\iomanip
	..\compfile  $** $@

$(CRT_INC_PATH)\ios : ..\ios
	..\compfile  $** $@

$(CRT_INC_PATH)\iosfwd : ..\iosfwd
	..\compfile  $** $@

$(CRT_INC_PATH)\iostream : ..\iostream
	..\compfile  $** $@

$(CRT_INC_PATH)\istream : ..\istream
	..\compfile  $** $@

$(CRT_INC_PATH)\iterator : ..\iterator
	..\compfile  $** $@

$(CRT_INC_PATH)\limits : ..\limits
	..\compfile  $** $@

$(CRT_INC_PATH)\list : ..\list
	..\compfile  $** $@

$(CRT_INC_PATH)\locale : ..\locale
	..\compfile  $** $@

$(CRT_INC_PATH)\map : ..\map
	..\compfile  $** $@

$(CRT_INC_PATH)\memory : ..\memory
	..\compfile  $** $@

$(CRT_INC_PATH)\new : ..\new
	..\compfile  $** $@

$(CRT_INC_PATH)\numeric : ..\numeric
	..\compfile  $** $@

$(CRT_INC_PATH)\ostream : ..\ostream
	..\compfile  $** $@

$(CRT_INC_PATH)\queue : ..\queue
	..\compfile  $** $@

$(CRT_INC_PATH)\set : ..\set
	..\compfile  $** $@

$(CRT_INC_PATH)\sstream : ..\sstream 
	..\compfile  $** $@

$(CRT_INC_PATH)\stack : ..\stack
	..\compfile  $** $@

$(CRT_INC_PATH)\stdexcept : ..\stdexcept
	..\compfile  $** $@

$(CRT_INC_PATH)\streambuf : ..\streambuf
	..\compfile  $** $@

$(CRT_INC_PATH)\string : ..\string
	..\compfile  $** $@

$(CRT_INC_PATH)\strstream : ..\strstream
	..\compfile  $** $@

$(CRT_INC_PATH)\typeinfo : ..\typeinfo
	..\compfile  $** $@

$(CRT_INC_PATH)\utility : ..\utility
	..\compfile  $** $@

$(CRT_INC_PATH)\valarray : ..\valarray
	..\compfile  $** $@

$(CRT_INC_PATH)\vector : ..\vector
	..\compfile  $** $@

$(CRT_INC_PATH)\xcomplex : ..\xcomplex
	..\compfile  $** $@

$(CRT_INC_PATH)\xiosbase : ..\xiosbase
	..\compfile  $** $@

$(CRT_INC_PATH)\xlocale : ..\xlocale
	..\compfile  $** $@

$(CRT_INC_PATH)\xlocinfo : ..\xlocinfo
	..\compfile  $** $@

$(CRT_INC_PATH)\xlocmon : ..\xlocmon
	..\compfile  $** $@

$(CRT_INC_PATH)\xlocnum : ..\xlocnum
	..\compfile  $** $@

$(CRT_INC_PATH)\xloctime : ..\xloctime
	..\compfile  $** $@

$(CRT_INC_PATH)\xmemory : ..\xmemory
	..\compfile  $** $@

$(CRT_INC_PATH)\xstddef : ..\xstddef
	..\compfile  $** $@

$(CRT_INC_PATH)\xstring : ..\xstring
	..\compfile  $** $@

$(CRT_INC_PATH)\xtree : ..\xtree
	..\compfile  $** $@

$(CRT_INC_PATH)\xutility : ..\xutility
	..\compfile  $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP void *  __cdecl calloc(size_t, size_t);
_CRTIMP void    __cdecl free(void *);
_CRTIMP void *  __cdecl malloc(size_t);
_CRTIMP void *  __cdecl realloc(void *, size_t);
_CRTIMP void    __cdecl _aligned_free(void *);
_CRTIMP void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);
_CRTIMP int     __cdecl _resetstkoflw (void);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#if     defined(_M_MRX000) || defined(_M_PPC) || defined(_M_ALPHA)
#pragma intrinsic(_alloca)
#endif

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\ivec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef IVEC_H_INCLUDED
#define IVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <mmintrin.h>
#include <assert.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class I8vec8;			/* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;			/* 8 elements, each element a signed char data type */
class Iu8vec8;			/* 8 elements, each element an unsigned char data type */
class I16vec4;			/* 4 elements, each element a signed or unsigned short */
class Is16vec4;			/* 4 elements, each element a signed short */
class Iu16vec4;			/* 4 elements, each element an unsigned short */
class I32vec2;			/* 2 elements, each element a signed or unsigned long */
class Is32vec2;			/* 2 elements, each element a signed long */
class Iu32vec2;			/* 2 elements, each element a unsigned long */
class I64vec1;			/* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type
 * Contructors & Logical Operations
 */
class M64
{
protected:
		__m64 vec;

public:
	M64()									{ }
	M64(__m64 mm)							{ vec = mm; }
	M64(__int64 mm)							{ _MM_QW = mm; }
	M64(int i)								{ vec = _m_from_int(i); }

	operator __m64() const					{ return vec; }

	/* Logical Operations */
	M64& operator&=(const M64 &a)					{ return *this = (M64) _m_pand(vec,a); }
	M64& operator|=(const M64 &a)					{ return *this = (M64) _m_por(vec,a); }
	M64& operator^=(const M64 &a)					{ return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)	{ return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)	{ return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)	{ return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)		{ return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64
{
public:
	I64vec1()								{ }
	I64vec1(__m64 mm) : M64(mm)				{ }
	EXPLICIT I64vec1(int i) : M64(i)		{ }
	EXPLICIT I64vec1(__int64 mm) : M64(mm)	{ }

	I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
	I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
	I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
	I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

	/* Shift Logical Operations */
	I64vec1 operator<<(const M64 &a)				{ return _m_psllq(vec, a); }
	I64vec1 operator<<(int count) 				    { return _m_psllqi(vec, count); }
	I64vec1& operator<<=(const M64 &a)				{ return *this = (I64vec1) _m_psllq(vec, a); }
	I64vec1& operator<<=(int count) 				{ return *this = (I64vec1) _m_psllqi(vec, count); }
	I64vec1 operator>>(const M64 &a)				{ return _m_psrlq(vec, a); }
	I64vec1 operator>>(int count) 					{ return _m_psrlqi(vec, count); }
	I64vec1& operator>>=(const M64 &a)				{ return *this = (I64vec1) _m_psrlq(vec, a); }
	I64vec1& operator>>=(int count) 				{ return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class:
 * 2 elements, each element either a signed or unsigned int
 */
class I32vec2 : public M64
{
public:
	I32vec2() { }
	I32vec2(__m64 mm) : M64(mm) { }
	EXPLICIT I32vec2(int i) : M64 (i) { }
	EXPLICIT I32vec2(__int64 i): M64(i) {}

	/* Assignment Operator */
	I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

	/* Logical Assignment Operators */
	I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
	I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
	I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec2& operator +=(const I32vec2 &a)			{ return *this = (I32vec2) _m_paddd(vec,a); }
	I32vec2& operator -=(const I32vec2 &a)			{ return *this = (I32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	I32vec2 operator<<(const I32vec2 &a) 			{ return _m_pslld(vec,a); }
	I32vec2 operator<<(int count) 				    { return _m_pslldi(vec,count); }
	I32vec2& operator<<=(const I32vec2 &a)			{ return *this = (I32vec2) _m_pslld(vec,a); }
	I32vec2& operator<<=(int count) 				{ return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* Is32vec2 Class:
 * 2 elements, each element a signed int
 */
class Is32vec2 : public I32vec2
{
public:
	Is32vec2() { }
	Is32vec2(__m64 mm) : I32vec2(mm) { }
	Is32vec2(signed int i0, signed int i1)
	{
		_MM_2DW(0,vec) = i1;
		_MM_2DW(1,vec) = i0;
	}
	EXPLICIT Is32vec2(int i) : I32vec2 (i)		{}
	EXPLICIT Is32vec2(__int64 i): I32vec2(i)	{}

	/* Assignment Operator */
	Is32vec2& operator= (const M64 &a)		{ return *this = (Is32vec2) a; }

	/* Logical Assignment Operators */
	Is32vec2& operator&=(const M64 &a)		{ return *this = (Is32vec2) _m_pand(vec,a); }
	Is32vec2& operator|=(const M64 &a)		{ return *this = (Is32vec2) _m_por(vec,a); }
	Is32vec2& operator^=(const M64 &a)		{ return *this = (Is32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec2& operator +=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_paddd(vec,a); }
	Is32vec2& operator -=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Is32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Is32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Is32vec2& operator<<=(const M64 &a)		{ return *this = (Is32vec2) _m_pslld(vec,a); }
	Is32vec2& operator<<=(int count) 		{ return *this = (Is32vec2) _m_pslldi(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec2 operator>>(const M64 &a) 		{ return _m_psrad(vec, a); }
	Is32vec2 operator>>(int count) 	  		{ return _m_psradi(vec, count); }
	Is32vec2& operator>>=(const M64 &a)		{ return *this = (Is32vec2) _m_psrad(vec, a); }
	Is32vec2& operator>>=(int count) 		{ return *this = (Is32vec2) _m_psradi(vec, count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec2 &a)
	{
		os << " [1]:" << _MM_2DW(1,a)
		<< " [0]:" << _MM_2DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckhdq(a,b); }

/* Iu32vec2 Class:
 * 2 elements, each element unsigned int
 */
class Iu32vec2 : public I32vec2
{
public:
	Iu32vec2() { }
	Iu32vec2(__m64 mm) : I32vec2(mm) { }
	Iu32vec2(unsigned int ui0, unsigned int ui1)
	{
		_MM_2UDW(0,vec) = ui1;
		_MM_2UDW(1,vec) = ui0;
	}

	EXPLICIT Iu32vec2(int i) : I32vec2 (i)		{ }
	EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)	{ }

	/* Assignment Operator */
	Iu32vec2& operator= (const M64 &a)		{ return *this = (Iu32vec2) a; }

	/* Logical Assignment Operators */
	Iu32vec2& operator&=(const M64 &a)		{ return *this = (Iu32vec2) _m_pand(vec,a); }
	Iu32vec2& operator|=(const M64 &a)		{ return *this = (Iu32vec2) _m_por(vec,a); }
	Iu32vec2& operator^=(const M64 &a)		{ return *this = (Iu32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec2& operator +=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_paddd(vec,a); }
	Iu32vec2& operator -=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Iu32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Iu32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Iu32vec2& operator<<=(const M64 &a)		{ return *this = (Iu32vec2) _m_pslld(vec,a); }
	Iu32vec2& operator<<=(int count) 		{ return *this = (Iu32vec2) _m_pslldi(vec,count); }
	Iu32vec2 operator>>(const M64 &a) 		{ return _m_psrld(vec,a); }
	Iu32vec2 operator>>(int count) 			{ return _m_psrldi(vec,count); }
	Iu32vec2& operator>>=(const M64 &a)		{ return *this = (Iu32vec2) _m_psrld(vec,a); }
	Iu32vec2& operator>>=(int count) 		{ return *this = (Iu32vec2) _m_psrldi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec2 &a)
	{
		os << " [1]:" << _MM_2UDW(1,a)
		<< " [0]:" << _MM_2UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* I16vec4 Class:
 * 4 elements, each element either a signed or unsigned short
 */
class I16vec4 : public M64
{
public:
	I16vec4() { }
	I16vec4(__m64 mm) : M64(mm) { }
	EXPLICIT I16vec4(__int64 i) : M64 (i) { }
	EXPLICIT I16vec4(int i) : M64 (i) { }

	/* Assignment Operator */
	I16vec4& operator= (const M64 &a)				{ return *this = (I16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator&=(const M64 &a)				{ return *this = (I16vec4) _m_pand(vec,a); }
	I16vec4& operator|=(const M64 &a)				{ return *this = (I16vec4) _m_por(vec,a); }
	I16vec4& operator^=(const M64 &a)				{ return *this = (I16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator +=(const I16vec4 &a)			{ return *this = (I16vec4)_m_paddw(vec,a); }
	I16vec4& operator -=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psubw(vec,a); }
	I16vec4& operator *=(const I16vec4 &a)			{ return *this = (I16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	I16vec4 operator<<(const I16vec4 &a) 			{ return _m_psllw(vec,a); }
	I16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	I16vec4& operator<<=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psllw(vec,a); }
	I16vec4& operator<<=(int count) 				{ return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b) 	{ return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* Is16vec4 Class:
 * 4 elements, each element signed short
 */
class Is16vec4 : public I16vec4
{
public:
	Is16vec4() { }
	Is16vec4(__m64 mm) : I16vec4(mm) { }
	Is16vec4(short i0, short i1, short i2, short i3)
	{
		_MM_4W(0,vec) = i3;
		_MM_4W(1,vec) = i2;
		_MM_4W(2,vec) = i1;
		_MM_4W(3,vec) = i0;
	}

	EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)	{ }
	EXPLICIT Is16vec4(int i) : I16vec4 (i)		{ }

	/* Assignment Operator */
	Is16vec4& operator= (const M64 &a)		{ return *this = (Is16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator&=(const M64 &a)		{ return *this = (Is16vec4) _m_pand(vec,a); }
	Is16vec4& operator|=(const M64 &a)		{ return *this = (Is16vec4) _m_por(vec,a); }
	Is16vec4& operator^=(const M64 &a)		{ return *this = (Is16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator +=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_paddw(vec,a); }
	Is16vec4& operator -=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_psubw(vec,a); }
	Is16vec4& operator *=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Is16vec4 operator<<(const M64 &a) 		{ return _m_psllw(vec,a); }
	Is16vec4 operator<<(int count) 			{ return _m_psllwi(vec,count); }
	Is16vec4& operator<<=(const M64 &a)		{ return *this = (Is16vec4)_m_psllw(vec,a); }
	Is16vec4& operator<<=(int count) 		{ return *this = (Is16vec4)_m_psllwi(vec,count); }
	/* Shift Arithmetic Operations */
	Is16vec4 operator>>(const M64 &a) 		{ return _m_psraw(vec,a); }
	Is16vec4 operator>>(int count) 			{ return _m_psrawi(vec,count); }
	Is16vec4& operator>>=(const M64 &a)		{ return *this = (Is16vec4) _m_psraw(vec,a); }
	Is16vec4& operator>>=(int count) 		{ return *this = (Is16vec4) _m_psrawi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec4 &a)
	{
		os << "[3]:" << _MM_4W(3,a)
			<< " [2]:" << _MM_4W(2,a)
			<< " [1]:" << _MM_4W(1,a)
			<< " [0]:" << _MM_4W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}

	/* Element Access for Debug */
	short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaddwd(a,b);}


/* Iu16vec4 Class:
 * 4 elements, each element unsigned short
 */
class Iu16vec4 : public I16vec4
{
public:
	Iu16vec4() { }
	Iu16vec4(__m64 mm) : I16vec4(mm) { }
	Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
	{
		_MM_4UW(0,vec) = ui3;
		_MM_4UW(1,vec) = ui2;
		_MM_4UW(2,vec) = ui1;
		_MM_4UW(3,vec) = ui0;
	}
	EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }
	EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }

	/* Assignment Operator */
	Iu16vec4& operator= (const M64 &a)		{ return *this = (Iu16vec4) a; }

	/* Logical Assignment Operators */
	Iu16vec4& operator&=(const M64 &a)		{ return *this = (Iu16vec4) _m_pand(vec,a); }
	Iu16vec4& operator|=(const M64 &a)		{ return *this = (Iu16vec4) _m_por(vec,a); }
	Iu16vec4& operator^=(const M64 &a)		{ return *this = (Iu16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu16vec4& operator +=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_paddw(vec,a); }
	Iu16vec4& operator -=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_psubw(vec,a); }
	Iu16vec4& operator *=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Iu16vec4 operator<<(const M64 &a) 				{ return _m_psllw(vec,a); }
	Iu16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	Iu16vec4& operator<<=(const M64 &a)				{ return *this = (Iu16vec4)_m_psllw(vec,a); }
	Iu16vec4& operator<<=(int count) 				{ return *this = (Iu16vec4)_m_psllwi(vec,count); }
	Iu16vec4 operator>>(const M64 &a) 				{ return _m_psrlw(vec,a); }
	Iu16vec4 operator>>(int count) 				    { return _m_psrlwi(vec,count); }
	Iu16vec4& operator>>=(const M64 &a)				{ return *this = (Iu16vec4) _m_psrlw(vec,a); }
	Iu16vec4& operator>>=(int count) 				{ return *this = (Iu16vec4) _m_psrlwi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu16vec4 &a)
	{
		os << "[3]:" << _MM_4UW(3,a)
			<< " [2]:" << _MM_4UW(2,a)
			<< " [1]:" << _MM_4UW(1,a)
			<< " [0]:" << _MM_4UW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* I8vec8 Class:
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64
{
public:
	I8vec8() { }
	I8vec8(__m64 mm) : M64(mm) { }
	EXPLICIT I8vec8(__int64 i) : M64 (i) { }
	EXPLICIT I8vec8(int i) : M64 (i) { }

	/* Assignment Operator */
	I8vec8& operator= (const M64 &a)		{ return *this = (I8vec8) a; }

	/* Logical Assignment Operators */
	I8vec8& operator&=(const M64 &a)		{ return *this = (I8vec8) _m_pand(vec,a); }
	I8vec8& operator|=(const M64 &a)		{ return *this = (I8vec8) _m_por(vec,a); }
	I8vec8& operator^=(const M64 &a)		{ return *this = (I8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec8& operator +=(const I8vec8 &a)	{ return *this = (I8vec8) _m_paddb(vec,a); }
	I8vec8& operator -=(const I8vec8 &a)	{ return *this = (I8vec8) _m_psubb(vec,a); }
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class:
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8
{
public:
	Is8vec8() { }
	Is8vec8(__m64 mm) : I8vec8(mm) { }
	Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
	 {
		_MM_8B(0,vec) = s7;
		_MM_8B(1,vec) = s6;
		_MM_8B(2,vec) = s5;
		_MM_8B(3,vec) = s4;
		_MM_8B(4,vec) = s3;
		_MM_8B(5,vec) = s2;
		_MM_8B(6,vec) = s1;
		_MM_8B(7,vec) = s0;
	}

	EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Is8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Is8vec8& operator= (const M64 &a)		{ return *this = (Is8vec8) a; }

	/* Logical Assignment Operators */
	Is8vec8& operator&=(const M64 &a)		{ return *this = (Is8vec8) _m_pand(vec,a); }
	Is8vec8& operator|=(const M64 &a)		{ return *this = (Is8vec8) _m_por(vec,a); }
	Is8vec8& operator^=(const M64 &a)		{ return *this = (Is8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec8& operator +=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_paddb(vec,a); }
	Is8vec8& operator -=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is8vec8 &a)
	{
		os << "[7]:" << short(_MM_8B(7,a))
			<< " [6]:" << short(_MM_8B(6,a))
			<< " [5]:" << short(_MM_8B(5,a))
			<< " [4]:" << short(_MM_8B(4,a))
			<< " [3]:" << short(_MM_8B(3,a))
			<< " [2]:" << short(_MM_8B(2,a))
			<< " [1]:" << short(_MM_8B(1,a))
			<< " [0]:" << short(_MM_8B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_psubsb(a,b); }

/* Iu8vec8 Class:
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8
{
public:
	Iu8vec8() { }
	Iu8vec8(__m64 mm) : I8vec8(mm) { }
	Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
	{
		_MM_8UB(0,vec) = s7;
		_MM_8UB(1,vec) = s6;
		_MM_8UB(2,vec) = s5;
		_MM_8UB(3,vec) = s4;
		_MM_8UB(4,vec) = s3;
		_MM_8UB(5,vec) = s2;
		_MM_8UB(6,vec) = s1;
		_MM_8UB(7,vec) = s0;
	}
	EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Iu8vec8& operator= (const M64 &a)		{ return *this = (Iu8vec8) a; }
	/* Logical Assignment Operators */
	Iu8vec8& operator&=(const M64 &a)		{ return *this = (Iu8vec8) _m_pand(vec,a); }
	Iu8vec8& operator|=(const M64 &a)		{ return *this = (Iu8vec8) _m_por(vec,a); }
	Iu8vec8& operator^=(const M64 &a)		{ return *this = (Iu8vec8) _m_pxor(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu8vec8& operator +=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_paddb(vec,a); }
	Iu8vec8& operator -=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UB(7,a))
			<< " [6]:" << unsigned short(_MM_8UB(6,a))
			<< " [5]:" << unsigned short(_MM_8UB(5,a))
			<< " [4]:" << unsigned short(_MM_8UB(4,a))
			<< " [3]:" << unsigned short(_MM_8UB(3,a))
			<< " [2]:" << unsigned short(_MM_8UB(2,a))
			<< " [1]:" << unsigned short(_MM_8UB(1,a))
			<< " [0]:" << unsigned short(_MM_8UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)		{ return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b) 		{ return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); }

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 )))));	\
}
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)

IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)


#undef IVEC_SELECT

inline static void empty(void) 		{ _m_empty(); }

#endif // IVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
#if     defined(_M_MRX000)
_CRTIMP int     __cdecl abs(int);
_CRTIMP double  __cdecl acos(double);
_CRTIMP double  __cdecl asin(double);
_CRTIMP double  __cdecl atan(double);
_CRTIMP double  __cdecl atan2(double, double);
_CRTIMP double  __cdecl cos(double);
_CRTIMP double  __cdecl cosh(double);
_CRTIMP double  __cdecl exp(double);
_CRTIMP double  __cdecl fabs(double);
_CRTIMP double  __cdecl fmod(double, double);
_CRTIMP long    __cdecl labs(long);
_CRTIMP double  __cdecl log(double);
_CRTIMP double  __cdecl log10(double);
_CRTIMP double  __cdecl pow(double, double);
_CRTIMP double  __cdecl sin(double);
_CRTIMP double  __cdecl sinh(double);
_CRTIMP double  __cdecl tan(double);
_CRTIMP double  __cdecl tanh(double);
_CRTIMP double  __cdecl sqrt(double);
#else
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
#endif
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
#if     defined(_M_ALPHA)
        double  __cdecl ceil(double);
        double  __cdecl floor(double);
#else
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
#endif
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if     defined(_M_MRX000)

/* MIPS fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( float );
_CRTIMP float  __cdecl asinf( float );
_CRTIMP float  __cdecl atanf( float );
_CRTIMP float  __cdecl atan2f( float , float );
_CRTIMP float  __cdecl cosf( float );
_CRTIMP float  __cdecl sinf( float );
_CRTIMP float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( float );
_CRTIMP float  __cdecl sinhf( float );
_CRTIMP float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( float );
_CRTIMP float  __cdecl logf( float );
_CRTIMP float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
_CRTIMP float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl hypotf(float, float);

#endif  /* _M_MRX000 */

#if     defined(_M_ALPHA)

/* ALPHA fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl _hypotf(float, float);

#endif  /* _M_ALPHA */

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_MRX000) && !defined(_M_ALPHA) && !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\mmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * Definitions and declarations for use with compiler intrinsics.
 */

#ifndef _MMINTRIN_H_INCLUDED
#define _MMINTRIN_H_INCLUDED

#if defined __cplusplus
extern "C" { /* Begin "C" */
/* Intrinsics use C name-mangling.
 */
#endif /* __cplusplus */

#ifdef __ICL
typedef unsigned long long __m64; 
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];    
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;
#endif

/* General support intrinsics */
void  _m_empty(void);
__m64 _m_from_int(int i);
int   _m_to_int(__m64 m);
__m64 _m_packsswb(__m64 m1, __m64 m2);
__m64 _m_packssdw(__m64 m1, __m64 m2);
__m64 _m_packuswb(__m64 m1, __m64 m2);
__m64 _m_punpckhbw(__m64 m1, __m64 m2);
__m64 _m_punpckhwd(__m64 m1, __m64 m2);
__m64 _m_punpckhdq(__m64 m1, __m64 m2);
__m64 _m_punpcklbw(__m64 m1, __m64 m2);
__m64 _m_punpcklwd(__m64 m1, __m64 m2);
__m64 _m_punpckldq(__m64 m1, __m64 m2);

/* Packed arithmetic intrinsics */
__m64 _m_paddb(__m64 m1, __m64 m2);
__m64 _m_paddw(__m64 m1, __m64 m2);
__m64 _m_paddd(__m64 m1, __m64 m2);
__m64 _m_paddsb(__m64 m1, __m64 m2);
__m64 _m_paddsw(__m64 m1, __m64 m2);
__m64 _m_paddusb(__m64 m1, __m64 m2);
__m64 _m_paddusw(__m64 m1, __m64 m2);
__m64 _m_psubb(__m64 m1, __m64 m2);
__m64 _m_psubw(__m64 m1, __m64 m2);
__m64 _m_psubd(__m64 m1, __m64 m2);
__m64 _m_psubsb(__m64 m1, __m64 m2);
__m64 _m_psubsw(__m64 m1, __m64 m2);
__m64 _m_psubusb(__m64 m1, __m64 m2);
__m64 _m_psubusw(__m64 m1, __m64 m2);
__m64 _m_pmaddwd(__m64 m1, __m64 m2);
__m64 _m_pmulhw(__m64 m1, __m64 m2);
__m64 _m_pmullw(__m64 m1, __m64 m2);

/* Shift intrinsics */
__m64 _m_psllw(__m64 m, __m64 count);
__m64 _m_psllwi(__m64 m, int count);
__m64 _m_pslld(__m64 m, __m64 count);
__m64 _m_pslldi(__m64 m, int count);
__m64 _m_psllq(__m64 m, __m64 count);
__m64 _m_psllqi(__m64 m, int count);
__m64 _m_psraw(__m64 m, __m64 count);
__m64 _m_psrawi(__m64 m, int count);
__m64 _m_psrad(__m64 m, __m64 count);
__m64 _m_psradi(__m64 m, int count);
__m64 _m_psrlw(__m64 m, __m64 count);
__m64 _m_psrlwi(__m64 m, int count);
__m64 _m_psrld(__m64 m, __m64 count);
__m64 _m_psrldi(__m64 m, int count);
__m64 _m_psrlq(__m64 m, __m64 count);
__m64 _m_psrlqi(__m64 m, int count);

/* Logical intrinsics */
__m64 _m_pand(__m64 m1, __m64 m2);
__m64 _m_pandn(__m64 m1, __m64 m2);
__m64 _m_por(__m64 m1, __m64 m2);
__m64 _m_pxor(__m64 m1, __m64 m2);

/* Comparison intrinsics */
__m64 _m_pcmpeqb(__m64 m1, __m64 m2);
__m64 _m_pcmpeqw(__m64 m1, __m64 m2);
__m64 _m_pcmpeqd(__m64 m1, __m64 m2);
__m64 _m_pcmpgtb(__m64 m1, __m64 m2);
__m64 _m_pcmpgtw(__m64 m1, __m64 m2);
__m64 _m_pcmpgtd(__m64 m1, __m64 m2);

/* Utility intrinsics */
__m64 _mm_setzero_si64();
__m64 _mm_set_pi32(int i1, int i0);
__m64 _mm_set_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_set_pi8(char b7, char b6, char b5, char b4,
                  char b3, char b2, char b1, char b0);
__m64 _mm_set1_pi32(int i);
__m64 _mm_set1_pi16(short s);
__m64 _mm_set1_pi8(char b);
__m64 _mm_setr_pi32(int i1, int i0);
__m64 _mm_setr_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_setr_pi8(char b7, char b6, char b5, char b4,
                   char b3, char b2, char b1, char b0);

/* Alternate intrinsic name definitions */
#define _mm_empty         _m_empty
#define _mm_cvtsi32_si64  _m_from_int
#define _mm_cvtsi64_si32  _m_to_int
#define _mm_packs_pi16    _m_packsswb
#define _mm_packs_pi32    _m_packssdw
#define _mm_packs_pu16    _m_packuswb
#define _mm_unpackhi_pi8  _m_punpckhbw
#define _mm_unpackhi_pi16 _m_punpckhwd
#define _mm_unpackhi_pi32 _m_punpckhdq
#define _mm_unpacklo_pi8  _m_punpcklbw
#define _mm_unpacklo_pi16 _m_punpcklwd
#define _mm_unpacklo_pi32 _m_punpckldq
#define _mm_add_pi8       _m_paddb
#define _mm_add_pi16      _m_paddw
#define _mm_add_pi32      _m_paddd
#define _mm_adds_pi8      _m_paddsb
#define _mm_adds_pi16     _m_paddsw
#define _mm_adds_pu8      _m_paddusb
#define _mm_adds_pu16     _m_paddusw
#define _mm_sub_pi8       _m_psubb
#define _mm_sub_pi16      _m_psubw
#define _mm_sub_pi32      _m_psubd
#define _mm_subs_pi8      _m_psubsb
#define _mm_subs_pi16     _m_psubsw
#define _mm_subs_pu8      _m_psubusb
#define _mm_subs_pu16     _m_psubusw
#define _mm_madd_pi16     _m_pmaddwd
#define _mm_mulhi_pi16    _m_pmulhw
#define _mm_mullo_pi16    _m_pmullw
#define _mm_sll_pi16      _m_psllw
#define _mm_slli_pi16     _m_psllwi
#define _mm_sll_pi32      _m_pslld
#define _mm_slli_pi32     _m_pslldi
#define _mm_sll_si64      _m_psllq
#define _mm_slli_si64     _m_psllqi
#define _mm_sra_pi16      _m_psraw
#define _mm_srai_pi16     _m_psrawi
#define _mm_sra_pi32      _m_psrad
#define _mm_srai_pi32     _m_psradi
#define _mm_srl_pi16      _m_psrlw
#define _mm_srli_pi16     _m_psrlwi
#define _mm_srl_pi32      _m_psrld
#define _mm_srli_pi32     _m_psrldi
#define _mm_srl_si64      _m_psrlq
#define _mm_srli_si64     _m_psrlqi
#define _mm_and_si64      _m_pand
#define _mm_andnot_si64   _m_pandn
#define _mm_or_si64       _m_por
#define _mm_xor_si64      _m_pxor
#define _mm_cmpeq_pi8     _m_pcmpeqb
#define _mm_cmpeq_pi16    _m_pcmpeqw
#define _mm_cmpeq_pi32    _m_pcmpeqd
#define _mm_cmpgt_pi8     _m_pcmpgtb
#define _mm_cmpgt_pi16    _m_pcmpgtw
#define _mm_cmpgt_pi32    _m_pcmpgtd


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MMINTRIN_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ostream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
        ostream(streambuf*);
        virtual ~ostream();

        ostream& flush();
        int  opfx();
        void osfx();

inline  ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline  ostream& operator<<(ios& (__cdecl * _f)(ios&));
        ostream& operator<<(const char *);
inline  ostream& operator<<(const unsigned char *);
inline  ostream& operator<<(const signed char *);
inline  ostream& operator<<(char);
        ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
        ostream& operator<<(short);
        ostream& operator<<(unsigned short);
        ostream& operator<<(int);
        ostream& operator<<(unsigned int);
        ostream& operator<<(long);
        ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
        ostream& operator<<(double);
        ostream& operator<<(long double);
        ostream& operator<<(const void *);
        ostream& operator<<(streambuf*);
inline  ostream& put(char);
        ostream& put(unsigned char);
inline  ostream& put(signed char);
        ostream& write(const char *,int);
inline  ostream& write(const unsigned char *,int);
inline  ostream& write(const signed char *,int);
        ostream& seekp(streampos);
        ostream& seekp(streamoff,ios::seek_dir);
        streampos tellp();

protected:
        ostream();
        ostream(const ostream&);        // treat as private
        ostream& operator=(streambuf*); // treat as private
        ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
        int do_opfx(int);               // not used
        void do_osfx();                 // not used

private:
        ostream(ios&);
        ostream& writepad(const char *, const char *);
        int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline  ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline  ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline  ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline  ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline  ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline  ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline  ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline  ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline  ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
        public:
                ostream_withassign();
                ostream_withassign(streambuf* _is);
                ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&           __cdecl dec(ios&);
_CRTIMP ios&           __cdecl hex(ios&);
_CRTIMP ios&           __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_OSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
#ifdef  _M_MRX000
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
#else
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\RTCAPI.H ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    // General User API

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    // User API
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    // Power User/library API


    /* Init functions */

    // These functions all call _CRT_RTC_INIT
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    // If you're not using the CRT, you have to implement _CRT_RTC_INIT
    // Just return either null, or your error reporting function
    // *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    // Compiler generated calls (unlikely to be used, even by power users...)
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif // _INC_RTCAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#elif   defined(_M_MRX000)

#if     _MSC_VER >= 1100
#define _setjmpex _setjmpexVfp
#endif

#define setjmp _setjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif   defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)_ADDRESSOF(v) + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef  _CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )

#elif   defined(_M_PPC)

/* Microsoft C8 front end (used in Motorola Merged compiler) */
/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
				     _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\mm3dnow.h ===
/**
*** Copyright (C) 1999 Advanced Micro Devices Inc.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Advanced Micro Devices and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * mm3dnow.h
 *
 */

#ifndef _MM3DNOW_H_INCLUDED
#define _MM3DNOW_H_INCLUDED

#include <mmintrin.h>
#include <xmmintrin.h>

#if defined __cplusplus
extern "C" { /* Intrinsics use C name-mangling.  */
#endif /* __cplusplus */

/* 3DNOW intrinsics */

void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(void*);

__m64 _m_from_float(float);
float _m_to_float(__m64);

/* Athlon DSP intrinsics */

__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MM3DNOW_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif



#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
namespace std {
        typedef void (__cdecl * new_handler) ();
        _CRTIMP2 new_handler __cdecl set_new_handler(new_handler) throw();
};
using std::new_handler;
using std::set_new_handler;
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;



#elif   defined(_M_MRX000)

#ifndef _INC_SETJMPEX
#if     _MSC_VER >= 1100
#define _setjmp  _setjmpVfp
#endif
#define setjmp  _setjmp
#endif

/*
 * All MIPS implementations need _JBLEN of 16
 */

#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif   defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef  _MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp  _setjmpex /* Alpha should always use setjmp as _setjmpex */
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/*
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
#ifdef _M_ALPHA64
#define _JBFILL 3
    unsigned __int64 Fp;
    unsigned __int64 Pc;
    unsigned __int64 Seb;
    unsigned long Type;
    unsigned long Type_Fill;
#else
#define _JBFILL 5
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
#endif
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[_JBFILL];
} _JUMP_BUFFER;
#undef _JBFILL

#elif   defined(_M_PPC)
/*
 * The Microsoft VC++ V4.0 compiler uses an intrinsic _setjmp.
 * The Motorola C8.5 compiler implements setjmp as a function.
 */

#if     _MSC_VER > 850
#ifndef _INC_SETJMPEX
#undef _setjmp
#define setjmp  _setjmp
#endif
#endif

/*
 * Min length is 240 bytes; round to 256 bytes.
 * Since this is allocated as an array of "double", the
 * number of entries required is 32.
 *
 * All PPC implementations need _JBLEN of 32
 */

#define _JBLEN  32
#define _JBTYPE double

/*
 * Define jump buffer layout for PowerPC setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    unsigned long Gpr1;
    unsigned long Gpr2;
    unsigned long Gpr13;
    unsigned long Gpr14;
    unsigned long Gpr15;
    unsigned long Gpr16;
    unsigned long Gpr17;
    unsigned long Gpr18;
    unsigned long Gpr19;
    unsigned long Gpr20;
    unsigned long Gpr21;
    unsigned long Gpr22;
    unsigned long Gpr23;
    unsigned long Gpr24;
    unsigned long Gpr25;
    unsigned long Gpr26;
    unsigned long Gpr27;
    unsigned long Gpr28;
    unsigned long Gpr29;
    unsigned long Gpr30;
    unsigned long Gpr31;
    unsigned long Cr;
    unsigned long Iar;
    unsigned long Type;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

// Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name.
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;

#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    unsigned long iAReserved[6];

    //
    // x86 C9.0 compatibility
    //

    unsigned long Registration;  // point to the UnwindData field.
    unsigned long TryLevel;      // ignored by setjmp
    unsigned long Cookie;        // set to "VC20" by setjmp
    unsigned long UnwindFunc;    // set to EM longjmp() by setjmp

    //
    // First dword is zero to indicate it's an exception registration
    // record prepared by EM setjmp function.
    // Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
    // EM setjmp.
    // Third dword is set to the setjmp site memory stack frame pointer.
    // Fourth dword is set to the setjmp site backing store frame pointer.
    //

    unsigned long UnwindData[6];

    //
    // floating point status register,
    // and preserved floating point registers fs0 - fs19
    //

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    //
    // return link and preserved branch registers bs0 - bs4
    //

    __int64 StIIP;     // continuation address
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    //
    // preserved general registers s0 - s3, sp, nats
    //

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    //
    // bsp, pfs, unat, lc
    //

    __int64 RsBSP;
    __int64 RsPFS;     // previous frame marker (cfm of setjmp's caller)
    __int64 ApUNAT;    // User Nat collection register (preserved)
    __int64 ApLC;      // loop counter

    __int64 IntSp;     // memory stack pointer
    __int64 IntNats;   // Nat bits of preserved integer regs s0 - s3
    __int64 Preds;     // predicates

} _JUMP_BUFFER;

#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the stdiostream and stdiobuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>
#include <stdio.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
        stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
        ~stdiobuf();
        int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
        FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {  // note: spec.'d as : public IOS...
public:
        stdiostream(FILE *);
        ~stdiostream();
        stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
        
private:
};

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STDIOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sources.inc ===
!if 0

   Sources file

!endif

TARGETNAME=
TARGETPATH=
TARGETTYPE=NOTARGET


SOURCES=

CRT_FILES1 = \
    $(CRT_INC_PATH)\assert.h \
    $(CRT_INC_PATH)\conio.h \
    $(CRT_INC_PATH)\crtdbg.h \
    $(CRT_INC_PATH)\ctype.h \
    $(CRT_INC_PATH)\direct.h \
    $(CRT_INC_PATH)\dos.h \
    $(CRT_INC_PATH)\eh.h \
    $(CRT_INC_PATH)\errno.h \
    $(CRT_INC_PATH)\excpt.h \
    $(CRT_INC_PATH)\fcntl.h \
    $(CRT_INC_PATH)\float.h \
    $(CRT_INC_PATH)\fpieee.h \
    $(CRT_INC_PATH)\fstream.h \
    $(CRT_INC_PATH)\io.h \
    $(CRT_INC_PATH)\iomanip.h \
    $(CRT_INC_PATH)\ios.h \
    $(CRT_INC_PATH)\iostream.h \
    $(CRT_INC_PATH)\istream.h \
    $(CRT_INC_PATH)\limits.h \
    $(CRT_INC_PATH)\locale.h \
    $(CRT_INC_PATH)\malloc.h \
    $(CRT_INC_PATH)\math.h \
    $(CRT_INC_PATH)\mbctype.h \
    $(CRT_INC_PATH)\mbstring.h \
    $(CRT_INC_PATH)\memory.h \
    $(CRT_INC_PATH)\minmax.h \
    $(CRT_INC_PATH)\new.h \
    $(CRT_INC_PATH)\ostream.h \
    $(CRT_INC_PATH)\process.h

CRT_FILES2 = \
    $(CRT_INC_PATH)\search.h \
    $(CRT_INC_PATH)\setjmp.h \
    $(CRT_INC_PATH)\setjmpex.h \
    $(CRT_INC_PATH)\share.h \
    $(CRT_INC_PATH)\signal.h \
    $(CRT_INC_PATH)\stdarg.h \
    $(CRT_INC_PATH)\stddef.h \
    $(CRT_INC_PATH)\stdexcpt.h \
    $(CRT_INC_PATH)\stdio.h \
    $(CRT_INC_PATH)\stdiostr.h \
    $(CRT_INC_PATH)\stdlib.h \
    $(CRT_INC_PATH)\streamb.h \
    $(CRT_INC_PATH)\string.h \
    $(CRT_INC_PATH)\strstrea.h \
    $(CRT_INC_PATH)\tchar.h \
    $(CRT_INC_PATH)\time.h \
    $(CRT_INC_PATH)\typeinfo.h \
    $(CRT_INC_PATH)\useoldio.h \
    $(CRT_INC_PATH)\use_ansi.h \
    $(CRT_INC_PATH)\varargs.h \
    $(CRT_INC_PATH)\wchar.h \
    $(CRT_INC_PATH)\wctype.h \
    $(CRT_INC_PATH)\sys\locking.h \
    $(CRT_INC_PATH)\sys\stat.h \
    $(CRT_INC_PATH)\sys\timeb.h \
    $(CRT_INC_PATH)\sys\types.h \
    $(CRT_INC_PATH)\sys\utime.h

STDHPP_FILES1 = \
    $(CRT_INC_PATH)\algorithm \
    $(CRT_INC_PATH)\bitset \
    $(CRT_INC_PATH)\cassert \
    $(CRT_INC_PATH)\cctype \
    $(CRT_INC_PATH)\cerrno \
    $(CRT_INC_PATH)\cfloat \
    $(CRT_INC_PATH)\ciso646 \
    $(CRT_INC_PATH)\climits \
    $(CRT_INC_PATH)\clocale \
    $(CRT_INC_PATH)\cmath \
    $(CRT_INC_PATH)\complex \
    $(CRT_INC_PATH)\csetjmp \
    $(CRT_INC_PATH)\csignal \
    $(CRT_INC_PATH)\cstdarg \
    $(CRT_INC_PATH)\cstddef \
    $(CRT_INC_PATH)\cstdio \
    $(CRT_INC_PATH)\cstdlib \
    $(CRT_INC_PATH)\cstring \
    $(CRT_INC_PATH)\ctime \
    $(CRT_INC_PATH)\ctime \
    $(CRT_INC_PATH)\cwctype \
    $(CRT_INC_PATH)\deque \
    $(CRT_INC_PATH)\exception \
    $(CRT_INC_PATH)\fstream \
    $(CRT_INC_PATH)\functional \
    $(CRT_INC_PATH)\iomanip \
    $(CRT_INC_PATH)\ios \
    $(CRT_INC_PATH)\iosfwd \
    $(CRT_INC_PATH)\iostream \
    $(CRT_INC_PATH)\istream \
    $(CRT_INC_PATH)\iterator

STDHPP_FILES2= \
    $(CRT_INC_PATH)\limits \
    $(CRT_INC_PATH)\list \
    $(CRT_INC_PATH)\locale \
    $(CRT_INC_PATH)\map \
    $(CRT_INC_PATH)\memory \
    $(CRT_INC_PATH)\new \
    $(CRT_INC_PATH)\numeric \
    $(CRT_INC_PATH)\ostream \
    $(CRT_INC_PATH)\queue \
    $(CRT_INC_PATH)\set \
    $(CRT_INC_PATH)\sstream \
    $(CRT_INC_PATH)\stack \
    $(CRT_INC_PATH)\stdexcept \
    $(CRT_INC_PATH)\streambuf \
    $(CRT_INC_PATH)\string \
    $(CRT_INC_PATH)\strstream \
    $(CRT_INC_PATH)\typeinfo \
    $(CRT_INC_PATH)\utility \
    $(CRT_INC_PATH)\valarray \
    $(CRT_INC_PATH)\vector \
    $(CRT_INC_PATH)\xcomplex \
    $(CRT_INC_PATH)\xiosbase \
    $(CRT_INC_PATH)\xlocale \
    $(CRT_INC_PATH)\xlocinfo \
    $(CRT_INC_PATH)\xlocmon \
    $(CRT_INC_PATH)\xlocnum \
    $(CRT_INC_PATH)\xloctime \
    $(CRT_INC_PATH)\xmemory \
    $(CRT_INC_PATH)\xstddef \
    $(CRT_INC_PATH)\xstring \
    $(CRT_INC_PATH)\xtree \
    $(CRT_INC_PATH)\xutility

NTTARGETFILE0= $(CRT_FILES1) $(CRT_FILES2) $(STDHPP_FILES1) $(STDHPP_FILES2)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stl.h ===
// stl.h supplemental header
#pragma once
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque
		: public deque<_Ty, allocator<_Ty> >
	{	// wrap new deque as old
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Deque()
		: deque<_Ty, _Alloc>()
		{	// construct empty deque
		}

	explicit Deque(size_type _Count)
		: deque<_Ty, _Alloc>(_Count, _Ty())
		{	// construct deque from _Count * _Ty()
		}

	Deque(size_type _Count, const _Ty& _Val)
		: deque<_Ty, _Alloc>(_Count, _Val)
		{	// construct deque from _Count * _Val
		}

	typedef const_iterator _Iter;

	Deque(_Iter _First, _Iter _Last)
		: deque<_Ty, _Alloc>(_First, _Last)
		{	// construct deque from [_First, _Last)
		}
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List
		: public list<_Ty, allocator<_Ty> >
	{	// wrap new list as old
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	List()
		: list<_Ty, _Alloc>()
		{	// construct empty list
		}

	explicit List(size_type _Count)
		: list<_Ty, _Alloc>(_Count, _Ty())
		{	// construct list from _Count * _Ty()
		}

	List(size_type _Count, const _Ty& _Val)
		: list<_Ty, _Alloc>(_Count, _Val)
		{	// construct list from _Count * _Val
		}

	typedef const_iterator _Iter;

	List(_Iter _First, _Iter _Last)
		: list<_Ty, _Alloc>(_First, _Last)
		{	// construct list from [_First, _Last)
		}
	};

		// TEMPLATE CLASS Map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Map
		: public map<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new map as old
public:
	typedef Map<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Map()
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Map(const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Map(_Iter _First, _Iter _Last)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Map(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Multimap
		: public multimap<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new multimap as old
public:
	typedef Multimap<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Multimap()
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Multimap(const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Multimap(_Iter _First, _Iter _Last)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Multimap(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Set
template<class _Kty,
	class _Pr = less<_Kty> >
	class Set
		: public set<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new set as old
public:
	typedef Set<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Set()
		: set<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Set(const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Set(_Iter _First, _Iter _Last)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Set(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multiset
template<class _Kty,
	class _Pr = less<_Kty> >
	class Multiset
		: public multiset<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new multiset as old
public:
	typedef Multiset<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Multiset()
		: multiset<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Multiset(const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Multiset(_Iter _First, _Iter _Last)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Multiset(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector
		: public vector<_Ty, allocator<_Ty> >
	{	// wrap new vector as old
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Vector()
		: vector<_Ty, _Alloc>()
		{	// construct empty vector
		}

	explicit Vector(size_type _Count)
		: vector<_Ty, _Alloc>(_Count, _Ty())
		{	// construct vector from _Count * _Ty()
		}

	Vector(size_type _Count, const _Ty& _Val)
		: vector<_Ty, _Alloc>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	Vector(_Iter _First, _Iter _Last)
		: vector<_Ty, _Alloc>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// CLASS bit_vector
class bit_vector
	: public vector<_Bool, _Bool_allocator>
	{	// wrap new vector<bool> as old
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _Alloc;
	typedef bit_vector _Myt;

	bit_vector()
		: vector<_Bool, _Bool_allocator>()
		{	// construct empty vector
		}

	explicit bit_vector(size_type _Count, const _Ty& _Val = _Ty())
		: vector<_Bool, _Bool_allocator>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	bit_vector(_Iter _First, _Iter _Last)
		: vector<_Bool, _Bool_allocator>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// TEMPLATE CLASS priority_queue
template<class _Container,
	class _Pr = less<_Container::value_type> >
	class Priority_queue
		: public priority_queue<_Container::value_type, _Container, _Pr>
	{	// wrap new priority_queue as old
public:
	typedef typename _Container::value_type _Ty;

	Priority_queue()
		: priority_queue<_Ty, _Container, _Pr>(_Pr())
		{	// construct empty queue from defaults
		}

	explicit Priority_queue(const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_Pred)
		{	// construct empty queue from comparator
		}

	typedef const _Ty *_Iter;

	Priority_queue(_Iter _First, _Iter _Last)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pr())
		{	// construct queue from [_First, _Last)
		}

	Priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS queue
template<class _Container>
	class Queue
		: public queue<_Container::value_type, _Container>
	{	// wrap new queue as old
	};

		// TEMPLATE CLASS stack
template<class _Container>
	class Stack
		: public stack<_Container::value_type, _Container>
	{	// wrap new stack as old
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif /* _STL_H_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the streambuf class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>        // need ios::seek_dir definition

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;        // pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef  _MT
    void setlock() { LockFlg--; }       // <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef  _MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef  _MT
    int LockFlg;                // <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;        // lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (int)(_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (int)(_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (int)(_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STREAMB

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

#ifdef  _M_MRX000
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
_CRTIMP char *  __cdecl _strset(char *, int);
_CRTIMP char *  __cdecl strcpy(char *, const char *);
_CRTIMP char *  __cdecl strcat(char *, const char *);
_CRTIMP int     __cdecl strcmp(const char *, const char *);
_CRTIMP size_t  __cdecl strlen(const char *);
#else
        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#endif
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#ifdef  _M_ALPHA
        /* memmove is available as an intrinsic in the Alpha compiler */
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


#if     defined(_DLL) && defined(_M_IX86)

#define __argc      (*__p___argc())     /* count of cmd line args */
#define __argv      (*__p___argv())     /* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())    /* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())   /* pointer to environment table */
#ifdef  _POSIX_
extern char ** environ;                 /* pointer to environment table */
#else
#define _wenviron   (*__p__wenviron())  /* pointer to wide environment table */
#endif  /* _POSIX_ */
#define _pgmptr     (*__p__pgmptr())    /* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())   /* points to the module (EXE) wide name */

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);


#else

_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

#endif


_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

#if     defined(_M_MRX000)
_CRTIMP int    __cdecl abs(int);
#else
        int    __cdecl abs(int);
#endif
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
#if     defined(_M_MRX000)
_CRTIMP long __cdecl labs(long);
#else
        long __cdecl labs(long);
#endif
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL && !STATIC_CPPLIB
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL && !STATIC_CPPLIB

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\strstrea.h ===
/***
*strstrea.h - definitions/declarations for strstreambuf, strstream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the strstream and strstreambuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER

// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <useoldio.h>
#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
                strstreambuf();
                strstreambuf(int);
                strstreambuf(char *, int, char * = 0);
                strstreambuf(unsigned char *, int, unsigned char * = 0);
                strstreambuf(signed char *, int, signed char * = 0);
                strstreambuf(void * (*a)(long), void (*f) (void *));
                ~strstreambuf();

        void    freeze(int =1);
        char * str();

virtual int     overflow(int);
virtual int     underflow();
virtual streambuf* setbuf(char *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int     sync();         // not in spec.

protected:
virtual int     doallocate();
private:
        int     x_dynamic;
        int     x_bufmin;
        int     _fAlloc;
        int     x_static;
        void * (* x_alloc)(long);
        void    (* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
                istrstream(char *);
                istrstream(char *, int);
                ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
                ostrstream();
                ostrstream(char *, int, int = ios::out);
                ~ostrstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char *  str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {    // strstreambase ???
public:
                strstream();
                strstream(char *, int, int);
                ~strstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\useoldio.h ===
/***
*useoldio.h - force the use of the Microsoft "classic" iostream libraries.
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Generates default library directives for the old ("classic") IOSTREAM
*       libraries.  The exact name of the library specified in the directive
*       depends on the compiler switches (-ML, -MT, -MD, -MLd, -MTd, and -MDd).
*
*       This header file is only included by other header files.
*
*       [Public]
*
****/

#ifndef _USE_OLD_IOSTREAMS
#define _USE_OLD_IOSTREAMS
#ifndef _M_IA64
/*
 * Warning C4995, '_OLD_IOSTREAMS_ARE_DEPRECATED' is a deprecated name, is 
 * being issued because the old I/O Streams headers iostreams.h et al will no
 * longer be supported from VC8.  Replace references such as #include 
 * <iostreams.h> with #include <iostreams>, using the new, more conformant, I/O
 * Streams headers.
 */

#pragma deprecated(_OLD_IOSTREAMS_ARE_DEPRECATED)
extern void _OLD_IOSTREAMS_ARE_DEPRECATED();
#endif  /* _M_IA64 */
#ifdef  _MT
#ifdef  _DLL
#ifdef  _DEBUG
#pragma comment(lib,"msvcirtd")
#else   /* _DEBUG */
#pragma comment(lib,"msvcirt")
#endif  /* _DEBUG */

#else   /* _DLL */
#ifdef  _DEBUG
#pragma comment(lib,"libcimtd")
#else   /* _DEBUG */
#pragma comment(lib,"libcimt")
#endif  /* _DEBUG */
#endif  /* _DLL */

#else   /* _MT */
#ifdef  _DEBUG
#pragma comment(lib,"libcid")
#else   /* _DEBUG */
#pragma comment(lib,"libci")
#endif  /* _DEBUG */
#endif

#endif  /* _USE_OLD_IOSTREAMS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX 
#define _X_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGE	_CATMASK(_X_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2 int __cdecl _Getdateorder();
_CRTIMP2 char *__cdecl _Getdays();
_CRTIMP2 char *__cdecl _Getmonths();
_CRTIMP2 void *__cdecl _Gettnames();

_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2 float __cdecl _Stof(const char *, char **, long);
_CRTIMP2 double __cdecl _Stod(const char *, char **, long);
_CRTIMP2 long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

		/* return values for _Stopfx/_Stoflt */
#define FL_ERR	0
#define FL_DEC	1
#define FL_HEX	2
#define FL_INF	3
#define FL_NAN	4
#define FL_NEG	8

_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double __cdecl _Atan(double, int);
_CRTIMP2 short __cdecl _Dint(double *, short);
_CRTIMP2 short __cdecl _Dnorm(unsigned short *);
_CRTIMP2 short __cdecl _Dscale(double *, long);
_CRTIMP2 double __cdecl _Dtento(double, long);
_CRTIMP2 short __cdecl _Dunscale(short *, double *);
_CRTIMP2 double __cdecl _Poly(double, const double *, int);

_CRTIMP2 int __cdecl _Stoflt(const char *, char **, long[], int);

extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;

		/* float declarations */
_CRTIMP2 float __cdecl _FAtan(float, int);
_CRTIMP2 short __cdecl _FDint(float *, short);
_CRTIMP2 short __cdecl _FDnorm(unsigned short *);
_CRTIMP2 short __cdecl _FDscale(float *, long);
_CRTIMP2 float __cdecl _FDtento(float, long);
_CRTIMP2 short __cdecl _FDunscale(short *, float *);
_CRTIMP2 float __cdecl _FPoly(float, const float *, int);

extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;

		/* long double functions */
_CRTIMP2 long double __cdecl _LAtan(long double, int);
_CRTIMP2 short __cdecl _LDint(long double *, short);
_CRTIMP2 short __cdecl _LDnorm(unsigned short *);
_CRTIMP2 short __cdecl _LDscale(long double *, long);
_CRTIMP2 long double __cdecl _LDtento(long double, long);
_CRTIMP2 short __cdecl _LDunscale(short *, long double *);
_CRTIMP2 long double __cdecl _LPoly(long double, const long double *, int);

extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __cdecl _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Log(double, int);
_CRTIMP2 double __cdecl _Sin(double, unsigned int);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FLog(float, int);
_CRTIMP2 float __cdecl _FSin(float, unsigned int);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LLog(long double, int);
_CRTIMP2 long double __cdecl _LSin(long double, unsigned int);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
_CRTIMP2 extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
_C_STD_END
#endif /* _YMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sdkinc\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };
#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP void __cdecl _ftime64(struct __timeb64 *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);

_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _utime64(const char *, struct __utimbuf64 *);
_CRTIMP int __cdecl _futime64(int, struct __utimbuf64 *);
_CRTIMP int __cdecl _wutime64(const wchar_t *, struct __utimbuf64 *);
#endif

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   // stdin
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       // stdout
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP2 wint_t __cdecl btowc(int);
_CRTIMP2 size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP2 size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP2 size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP2 int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#ifdef  _M_ALPHA
/* memmove is available as an intrinsic in the Alpha compiler */
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\xdkinc\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

#ifdef  _M_ALPHA
typedef struct {
    char *a0;           /* pointer to first homed integer argument */
    int offset;         /* byte offset of next parameter */
} va_list;
#else
typedef char *va_list;
#endif

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#elif   defined(_M_MRX000)      /* _MIPS_ */


#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]
/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif   defined(_M_ALPHA)

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */
extern void * __builtin_va_start(va_list, ...);

#define va_dcl long va_alist;
#define va_start(list) __builtin_va_start(list, va_alist, 0)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#elif   defined(_M_PPC)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (PPC architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
/* this is for LITTLE-ENDIAN PowerPC */

/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define _ALIGNIT(ap,t) \
        ((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#define _CPPLIB_VER	310

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	_MT	/* nontrivial locks if multithreaded */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */
 #else
  #define _TLS_QUAL
 #endif

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif

 #define _HAS_TEMPLATE_PARTIAL_ORDERING	0

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)
   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */
 #endif  /* _CRTIMP2 */

 #if defined(_DLL) && !defined(_STATIC_CPPLIB)
  #define _DLL_CPPLIB
 #endif


 #if (1300 <= _MSC_VER)
  #define _DEPRECATED	__declspec(deprecated)
 #else
  #define _DEPRECATED
 #endif

		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}

  #define _CSTD			::
   #define _C_STD_BEGIN	/* match _STD_BEGIN/END if *.c compiled as C++ */
   #define _C_STD_END

  #define _C_LIB_DECL	extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL }
  #define _EXTERN_C		extern "C" {
  #define _END_EXTERN_C }

 #else /* __cplusplus */
  #define _STD
  #define _STD_BEGIN
  #define _STD_END

  #define _CSTD
  #define _C_STD_BEGIN
  #define _C_STD_END

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _MAX_LOCK		3	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit
class _CRTIMP2 _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD
	explicit _Lockit();	// set default lock
	explicit _Lockit(int);	// set the lock
	~_Lockit();	// clear the lock

private:
	_Lockit(const _Lockit&);				// not defined
	_Lockit& operator=(const _Lockit&);	// not defined

	int _Locktype;
  #else /* _MULTI_THREAD */
   #define _LOCKIT(x)
	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2 _Mutex
	{	// lock under program control
public:
  #if _MULTI_THREAD
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	void *_Mtx;
  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
	_Init_locks();
	~_Init_locks();
 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */ 
	};
_STD_END
 #endif /* __cplusplus */


		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_EXTERN_C
_CRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));
_END_EXTERN_C

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#endif /* _YVALS */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\xmmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * xmmintrin.h
 *
 * Principal header file for Streaming SIMD Extensions intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _MM_FUNCTIONALITY is defined; if it is, the C/x87 implementation
 * will be used (the "faux intrinsics").
 *
 *
 * Note that the m128 datatype provided using _MM2_FUNCTIONALITY mode is
 *   implemented as struct, will not be 128b aligned, will be passed
 *   via the stack, etc.  MM_FUNCTIONALITY mode is not intended for
 *   performance, just semantics.
 *
 */

#ifndef _INCLUDED_MM2
#define _INCLUDED_MM2


/*
 * the m64 type is required for the integer Streaming SIMD Extensions intrinsics
 */
#ifndef _MMINTRIN_H_INCLUDED
#include <mmintrin.h>
#endif

#ifdef _MM2_FUNCTIONALITY
/* support old notation */
#ifndef _MM_FUNCTIONALITY
#define _MM_FUNCTIONALITY
#endif
#endif

#ifdef __ICL
#ifdef _MM_FUNCTIONALITY
#include "xmm_func.h"
#else
/* using real intrinsics */
typedef long long __m128;
#endif
#else

#if _MSC_VER >= 1300
typedef struct __declspec(intrin_type) __declspec(align(16)) __m128 {
    float       m128_f32[4];
} __m128;
#endif

#ifndef _INC_MALLOC
/* pick up _mm_malloc() and _mm_free() */
#include <malloc.h>
#endif
#endif

/*******************************************************/
/* MACRO for shuffle parameter for _mm_shuffle_ps().   */
/* Argument fp3 is a digit[0123] that represents the fp*/
/* from argument "b" of mm_shuffle_ps that will be     */
/* placed in fp3 of result. fp2 is the same for fp2 in */
/* result. fp1 is a digit[0123] that represents the fp */
/* from argument "a" of mm_shuffle_ps that will be     */
/* places in fp1 of result. fp0 is the same for fp0 of */
/* result                                              */
/*******************************************************/
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) (((fp3) << 6) | ((fp2) << 4) | \
                                     ((fp1) << 2) | ((fp0)))


/*******************************************************/
/* MACRO for performing the transpose of a 4x4 matrix  */
/* of single precision floating point values.          */
/* Arguments row0, row1, row2, and row3 are __m128     */
/* values whose elements form the corresponding rows   */
/* of a 4x4 matrix.  The matrix transpose is returned  */
/* in arguments row0, row1, row2, and row3 where row0  */
/* now holds column 0 of the original matrix, row1 now */
/* holds column 1 of the original matrix, etc.         */
/*******************************************************/
#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) {                 \
            __m128 tmp3, tmp2, tmp1, tmp0;                          \
                                                                    \
            tmp0   = _mm_shuffle_ps((row0), (row1), 0x44);          \
            tmp2   = _mm_shuffle_ps((row0), (row1), 0xEE);          \
            tmp1   = _mm_shuffle_ps((row2), (row3), 0x44);          \
            tmp3   = _mm_shuffle_ps((row2), (row3), 0xEE);          \
                                                                    \
            (row0) = _mm_shuffle_ps(tmp0, tmp1, 0x88);              \
            (row1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD);              \
            (row2) = _mm_shuffle_ps(tmp2, tmp3, 0x88);              \
            (row3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD);              \
        }


/* constants for use with _mm_prefetch */
#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

/* (this declspec not supported with 0.A or 0.B) */
#define _MM_ALIGN16 __declspec(align(16))

/* MACRO functions for setting and reading the MXCSR */
#define _MM_EXCEPT_MASK       0x003f
#define _MM_EXCEPT_INVALID    0x0001
#define _MM_EXCEPT_DENORM     0x0002
#define _MM_EXCEPT_DIV_ZERO   0x0004
#define _MM_EXCEPT_OVERFLOW   0x0008
#define _MM_EXCEPT_UNDERFLOW  0x0010
#define _MM_EXCEPT_INEXACT    0x0020

#define _MM_MASK_MASK         0x1f80
#define _MM_MASK_INVALID      0x0080
#define _MM_MASK_DENORM       0x0100
#define _MM_MASK_DIV_ZERO     0x0200
#define _MM_MASK_OVERFLOW     0x0400
#define _MM_MASK_UNDERFLOW    0x0800
#define _MM_MASK_INEXACT      0x1000

#define _MM_ROUND_MASK        0x6000
#define _MM_ROUND_NEAREST     0x0000
#define _MM_ROUND_DOWN        0x2000
#define _MM_ROUND_UP          0x4000
#define _MM_ROUND_TOWARD_ZERO 0x6000

#define _MM_FLUSH_ZERO_MASK   0x8000
#define _MM_FLUSH_ZERO_ON     0x8000
#define _MM_FLUSH_ZERO_OFF    0x0000

#define _MM_SET_EXCEPTION_STATE(mask)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (mask))
#define _MM_GET_EXCEPTION_STATE()                                   \
            (_mm_getcsr() & _MM_EXCEPT_MASK)

#define _MM_SET_EXCEPTION_MASK(mask)                                \
            _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (mask))
#define _MM_GET_EXCEPTION_MASK()                                    \
            (_mm_getcsr() & _MM_MASK_MASK)

#define _MM_SET_ROUNDING_MODE(mode)                                 \
            _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (mode))
#define _MM_GET_ROUNDING_MODE()                                     \
            (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_FLUSH_ZERO_MODE(mode)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (mode))
#define _MM_GET_FLUSH_ZERO_MODE(mode)                               \
            (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * FP, arithmetic
 */

extern __m128 _mm_add_ss(__m128 a, __m128 b);
extern __m128 _mm_add_ps(__m128 a, __m128 b);
extern __m128 _mm_sub_ss(__m128 a, __m128 b);
extern __m128 _mm_sub_ps(__m128 a, __m128 b);
extern __m128 _mm_mul_ss(__m128 a, __m128 b);
extern __m128 _mm_mul_ps(__m128 a, __m128 b);
extern __m128 _mm_div_ss(__m128 a, __m128 b);
extern __m128 _mm_div_ps(__m128 a, __m128 b);
extern __m128 _mm_sqrt_ss(__m128 a);
extern __m128 _mm_sqrt_ps(__m128 a);
extern __m128 _mm_rcp_ss(__m128 a);
extern __m128 _mm_rcp_ps(__m128 a);
extern __m128 _mm_rsqrt_ss(__m128 a);
extern __m128 _mm_rsqrt_ps(__m128 a);
extern __m128 _mm_min_ss(__m128 a, __m128 b);
extern __m128 _mm_min_ps(__m128 a, __m128 b);
extern __m128 _mm_max_ss(__m128 a, __m128 b);
extern __m128 _mm_max_ps(__m128 a, __m128 b);

/*
 * FP, logical
 */

extern __m128 _mm_and_ps(__m128 a, __m128 b);
extern __m128 _mm_andnot_ps(__m128 a, __m128 b);
extern __m128 _mm_or_ps(__m128 a, __m128 b);
extern __m128 _mm_xor_ps(__m128 a, __m128 b);

/*
 * FP, comparison
 */

extern __m128 _mm_cmpeq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpeq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmple_ss(__m128 a, __m128 b);
extern __m128 _mm_cmple_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ps(__m128 a, __m128 b);
extern int _mm_comieq_ss(__m128 a, __m128 b);
extern int _mm_comilt_ss(__m128 a, __m128 b);
extern int _mm_comile_ss(__m128 a, __m128 b);
extern int _mm_comigt_ss(__m128 a, __m128 b);
extern int _mm_comige_ss(__m128 a, __m128 b);
extern int _mm_comineq_ss(__m128 a, __m128 b);
extern int _mm_ucomieq_ss(__m128 a, __m128 b);
extern int _mm_ucomilt_ss(__m128 a, __m128 b);
extern int _mm_ucomile_ss(__m128 a, __m128 b);
extern int _mm_ucomigt_ss(__m128 a, __m128 b);
extern int _mm_ucomige_ss(__m128 a, __m128 b);
extern int _mm_ucomineq_ss(__m128 a, __m128 b);

/*
 * FP, conversions
 */

extern int _mm_cvt_ss2si(__m128 a);
extern __m64 _mm_cvt_ps2pi(__m128 a);
extern int _mm_cvtt_ss2si(__m128 a);
extern __m64 _mm_cvtt_ps2pi(__m128 a);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);

/*
 * FP, misc
 */

extern __m128 _mm_shuffle_ps(__m128 a, __m128 b, unsigned int imm8);
extern __m128 _mm_unpackhi_ps(__m128 a, __m128 b);
extern __m128 _mm_unpacklo_ps(__m128 a, __m128 b);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 a);


/*
 * Integer extensions
 */
extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);

/*
 * memory & initialization
 */

extern __m128 _mm_set_ss(float a);
extern __m128 _mm_set_ps1(float a);
extern __m128 _mm_set_ps(float a, float b, float c, float d);
extern __m128 _mm_setr_ps(float a, float b, float c, float d);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*a);
extern __m128 _mm_load_ps1(float const*a);
extern __m128 _mm_load_ps(float const*a);
extern __m128 _mm_loadr_ps(float const*a);
extern __m128 _mm_loadu_ps(float const*a);
extern void _mm_store_ss(float *v, __m128 a);
extern void _mm_store_ps1(float *v, __m128 a);
extern void _mm_store_ps(float *v, __m128 a);
extern void _mm_storer_ps(float *v, __m128 a);
extern void _mm_storeu_ps(float *v, __m128 a);
extern void _mm_prefetch(char const*a, int sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 a, __m128 b);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);

#ifdef __ICL
extern void* __cdecl _mm_malloc(int siz, int al);
extern void __cdecl _mm_free(void *p);
#endif

/* Alternate intrinsic names definition */
#define _mm_cvtss_si32    _mm_cvt_ss2si
#define _mm_cvtps_pi32    _mm_cvt_ps2pi
#define _mm_cvttss_si32   _mm_cvtt_ss2si
#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
#define _mm_cvtsi32_ss    _mm_cvt_si2ss
#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
#define _mm_extract_pi16  _m_pextrw
#define _mm_insert_pi16   _m_pinsrw
#define _mm_max_pi16      _m_pmaxsw
#define _mm_max_pu8       _m_pmaxub
#define _mm_min_pi16      _m_pminsw
#define _mm_min_pu8       _m_pminub
#define _mm_movemask_pi8  _m_pmovmskb
#define _mm_mulhi_pu16    _m_pmulhuw
#define _mm_shuffle_pi16  _m_pshufw
#define _mm_maskmove_si64 _m_maskmovq
#define _mm_avg_pu8       _m_pavgb
#define _mm_avg_pu16      _m_pavgw
#define _mm_sad_pu8       _m_psadbw
#define _mm_set1_ps       _mm_set_ps1
#define _mm_load1_ps      _mm_load_ps1
#define _mm_store1_ps     _mm_store_ps1

/******************************************************/
/* UTILITY INTRINSICS FUNCTION DEFINITIONS START HERE */
/******************************************************/

/*********************************************************/
/*  NAME : _mm_cvtpi16_ps                                */
/*  DESCRIPTION : Convert 4 16-bit signed integer values */
/*                to 4 single-precision float values     */
/*  IN : __m64 a                                         */
/*  OUT : none                                           */
/*  RETURN : __m128 : (float)a                           */
/*********************************************************/
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_cmpgt_pi16(_mm_setzero_si64(), a);

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/***********************************************************/
/*  NAME : _mm_cvtpu16_ps                                  */
/*  DESCRIPTION : Convert 4 16-bit unsigned integer values */
/*                to 4 single-precision float values       */
/*  IN : __m64 a                                           */
/*  OUT : none                                             */
/*  RETURN : __m128 : (float)a                             */
/***********************************************************/
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi16                             */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 16-bit integer values   */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (short)a                         */
/******************************************************/
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _mm_packs_pi32(_mm_cvtps_pi32(a), 
                        _mm_cvtps_pi32(_mm_movehl_ps(a, a)));
}


/******************************************************/
/*  NAME : _mm_cvtpi8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit integer values to 4 */
/*                single-precision float values       */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _mm_cmpgt_pi8(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_mm_unpacklo_pi8(a, ext_val));
}


/******************************************************/
/*  NAME : _mm_cvtpu8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit unsigned integer    */
/*                values to 4 single-precision float  */
/*                values                              */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_mm_unpacklo_pi8(a, _mm_setzero_si64()));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi8                              */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 8-bit integer values    */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (char)a                          */
/******************************************************/
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _mm_packs_pi16(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


/******************************************************/
/*  NAME : _mm_cvtpi32x2_ps                           */
/*  DESCRIPTION : Convert 4 32-bit integer values     */
/*                to 4 single-precision float values  */
/*  IN : __m64 a : operand 1                          */
/*       __m64 b : operand 2                          */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a,(float)b               */
/******************************************************/
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), 
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
}


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_MM2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _fstat64(int, struct __stat64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
_CRTIMP int __cdecl _stat64(const char *, struct __stat64 *);
#endif

#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\include\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\imt\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\sources.inc ===
TARGETPATH=obj
SOURCES =

LINKER_FLAGS=-ignore:4006
LIBRARIAN_FLAGS=-ignore:4006

!if $(FREEBUILD)
D=
!else
D=d
!endif

!IF "$(CRTLIBTYPE)" == "IMT"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libcimt$D
TARGETTYPE=LIBRARY

OBJLIBFILES=\
    ..\..\..\crtw32\iostream\imt\$O\iostream.lib

!ELSEIF "$(CRTLIBTYPE)" == "IST"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libci$D
TARGETTYPE=LIBRARY

OBJLIBFILES=\
    ..\..\..\crtw32\iostream\ist\$O\iostream.lib

!ELSEIF "$(CRTLIBTYPE)" == "PMT"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libcpmt$D
TARGETTYPE=LIBRARY

OBJLIBFILES=\
    ..\..\..\crtw32\stdcpp\pmt\$O\stdcpp.lib

!ELSEIF "$(CRTLIBTYPE)" == "PST"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libcp$D
TARGETTYPE=LIBRARY

OBJLIBFILES=\
    ..\..\..\crtw32\stdcpp\pst\$O\stdcpp.lib

!ELSEIF "$(CRTLIBTYPE)" == "MT"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libcmt$D
TARGETTYPE=LIBRARY

OBJLIBFILES = \
    ..\..\*\almap.lib \
    ..\..\..\crtw32\awxapi\mt\$O\awxapi.lib \
    ..\..\..\crtw32\convert\mt\$O\convert.lib \
    ..\..\..\crtw32\direct\mt\$O\direct.lib \
    ..\..\..\crtw32\dos\mt\$O\dos.lib \
    ..\..\..\crtw32\eh\mt\$O\eh.lib \
    ..\..\..\crtw32\exec\mt\$O\exec.lib \
    ..\..\..\crtw32\heap\mt\$O\heap.lib \
    ..\..\..\crtw32\helper\mt\$O\helper.lib \
    ..\..\..\crtw32\lowio\mt\$O\lowio.lib \
    ..\..\..\crtw32\mbstring\mt\$O\mbstring.lib \
    ..\..\..\crtw32\misc\mt\$O\misc.lib \
    ..\..\..\crtw32\startup\mt\$O\startup.lib \
    ..\..\..\crtw32\stdio\mt\$O\stdio.lib \
    ..\..\..\crtw32\string\mt\$O\string.lib \
    ..\..\..\crtw32\time\mt\$O\time.lib \
    ..\..\..\fpw32\conv\mt\$O\conv.lib \
    ..\..\..\fpw32\tran\mt\$O\tran.lib

!if !$(FREEBUILD)
OBJLIBFILES=$(OBJLIBFILES) \
    ..\..\..\crtw32\rtc\mt\$O\rtc.lib
!endif

!ELSEIF "$(CRTLIBTYPE)" == "ST"

LIBOUTPUT=$(XDK_LIB_PATH)
TARGETNAME=libc$D
TARGETTYPE=LIBRARY

OBJLIBFILES = \
    ..\..\*\almap.lib \
    ..\..\..\crtw32\awxapi\st\$O\awxapi.lib \
    ..\..\..\crtw32\convert\st\$O\convert.lib \
    ..\..\..\crtw32\direct\st\$O\direct.lib \
    ..\..\..\crtw32\dos\st\$O\dos.lib \
    ..\..\..\crtw32\eh\st\$O\eh.lib \
    ..\..\..\crtw32\exec\st\$O\exec.lib \
    ..\..\..\crtw32\heap\st\$O\heap.lib \
    ..\..\..\crtw32\helper\st\$O\helper.lib \
    ..\..\..\crtw32\lowio\st\$O\lowio.lib \
    ..\..\..\crtw32\mbstring\st\$O\mbstring.lib \
    ..\..\..\crtw32\misc\st\$O\misc.lib \
    ..\..\..\crtw32\startup\st\$O\startup.lib \
    ..\..\..\crtw32\stdio\st\$O\stdio.lib \
    ..\..\..\crtw32\string\st\$O\string.lib \
    ..\..\..\crtw32\time\st\$O\time.lib \
    ..\..\..\fpw32\conv\st\$O\conv.lib \
    ..\..\..\fpw32\tran\st\$O\tran.lib

!if !$(FREEBUILD)
OBJLIBFILES=$(OBJLIBFILES) \
    ..\..\..\crtw32\rtc\st\$O\rtc.lib
!endif

!ELSEIF "$(CRTLIBTYPE)" == "NT"

TARGETNAME=libcntpr
TARGETTYPE=LIBRARY
LIBOUTPUT=$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)

OBJLIBFILES = \
    ..\..\..\crtw32\convert\nt\$O\convert.lib \
    ..\..\..\crtw32\hack\nt\$O\hack.lib    \
    ..\..\..\crtw32\helper\nt\$O\helper.lib  \
    ..\..\..\crtw32\misc\nt\$O\misc.lib    \
    ..\..\..\crtw32\startup\nt\$O\startup.lib \
    ..\..\..\crtw32\stdio\nt\$O\stdio.lib   \
    ..\..\..\crtw32\string\nt\$O\string.lib

!ELSEIF "$(CRTLIBTYPE)" == "EXSUP"

TARGETNAME=exsup
TARGETTYPE=LIBRARY
LIBOUTPUT=$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)

OBJLIBFILES = \
    ..\..\..\crtw32\misc\nt\$(O)\exsup.obj \
    ..\..\..\crtw32\misc\nt\$(O)\exsup2.obj \
    ..\..\..\crtw32\misc\nt\$(O)\exsup3.obj \
    ..\..\..\crtw32\misc\nt\$(O)\sehsupp.obj \
    ..\..\..\crtw32\misc\nt\$(O)\setjmp.obj \
    ..\..\..\crtw32\misc\nt\$(O)\setjmp3.obj \
    ..\..\..\crtw32\misc\nt\$(O)\setjmpex.obj \
    ..\..\..\crtw32\misc\nt\$(O)\longjmp.obj

!ELSE
!ERROR Unsupported Library CRTLIBTYPE: $(CRTLIBTYPE)
!ENDIF

TARGETEXEFILES = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

DESTFILE = $(LIBOUTPUT)\$(TARGETNAME).$(TARGETEXT)

NTTARGETFILE1= $(DESTFILE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\mt\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)
OBJECTS = $(OBJECTS) $(OBJLIBFILES)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\ist\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\nt\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

$(DESTFILE): $(TARGET)
    chmode -r $@
    copy $? $@
    chmode +r $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\pmt\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\st\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)
OBJECTS = $(OBJECTS) $(OBJLIBFILES)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\oldnames\weak.asm ===
.386
.model flat, c

extern C alternate:PROC
extern C weak(alternate):PROC

    end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\lib\pst\makefile.inc ===
TARGET = $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)

$(DESTFILE): $(TARGET)
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\detab.c ===
/*
**	DETAB - replaces tabs with multiple spaces as appropriate
**		tab width defaults to 8 but may be anything
**		Steve Salisbury 1988-03-09 Wed
**
**	1989 Aug 30 Wed -- arg parsing was wrong
**	1989 Nov 01 Wed 12:00	add selection of non-space fill character
**	1991 Jan 14 Mon 18:20	fix selection of non-space fill character
**	1991 Jan 17 Thu 12:00	change message every 4KB to every 16KB
**				allow command line argument for input file
**				do not use big output buffer if stdout=con
**
**	cl -G2s -Oaltr detab.c -o detab.exr -link slibcr libh /nod:slibce;
**	cl detab -link slibcp libh /nod:slibce, detab;
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>

#define SPACE	' '
#define TAB	'\t'
#define TABWIDTH 8

#define REG register

#define NEWLINE(c)  ( (c) == '\n' || (c) == '\r' || (c) == '\f' )

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  8192
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

static	char	MsgInternalError [ ] = "detab: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "detab: cannot open `%s' for input\n" ;
static	char	MsgWriteError [ ] = "detab: error writing to `%s'\n" ;
static	char	MsgStdin [ ] = "<stdin>" ;
static	char	MsgStdout [ ] = "<stdout>" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;

int main ( int argc , char * * argv )
{
REG int column ;
REG int ch ;
REG int spcount ;
    FILE * input ;
    char * MsgInput ;
    int tabwidth = TABWIDTH ;
    int countflag = 0 ;
    long kilobytes ;
    unsigned bytecount ;
    char * cp ;
    int FillChar = SPACE ;	/* default character to use when detabbing */

    while ( -- argc > 0 && * ( cp = * ++ argv ) == '-' )
    {
	++cp;
	while (*cp)
	{
	    if ( * cp == 'k' )
		++ countflag , ++ cp ;
	    else if ( '0' <= * cp && * cp <= '9' )
	    {
		tabwidth = * cp ++ - '0' ;
		while ( '0' <= * cp && * cp <= '9' )
		    tabwidth = 10 * tabwidth + * cp ++ - '0' ;
	    }
	    else if ( * cp == 'c' )
	    {
		FillChar = * ++ cp ;
		++ cp ;
	    }
	    else
	    {
Usage :
		fprintf ( stderr ,

"Usage: detab [-cX -k -###] [inputfile]\n"
"where ### is the number of colums per tab stop (default=8)\n"
"-k selects progress reports (written to stderr) every 16 Kbytes\n"
"and X is the character to use for tabs (default is space)\n"
) ;

		exit ( 1 ) ;
	    }
	}
    }

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	goto Usage ;

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( _setmode ( _fileno(stdout) , O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( ! _isatty ( _fileno ( stdin ) )
      && setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    kilobytes = bytecount = 0 ;

    column = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == TAB )
	{
	    do
		putchar ( FillChar ) ;
	    while ( ++ column < tabwidth ) ;
	    column = 0 ;
	}
	else {
	    putchar ( ch ) ;
	    if ( NEWLINE(ch) )
		column = 0 ;
	    else if ( ++ column == tabwidth )
		column = 0 ;
	    else if ( column > tabwidth )
	    {
		fprintf ( stderr , MsgInternalError , "" , "column>tabwidth" ) ;
		return 1 ;
	    }
	}

	if ( ++ bytecount >= 16384 )
	{
	    bytecount -= 16384 ;

	    if ( countflag )
		fprintf ( stderr , "%ldK\r" , kilobytes += 16 ) ;

            if ( ferror ( stdout) )
	    {
		fprintf ( stderr , MsgWriteError , MsgStdout ) ;
		return 1 ;
	    }
	}
    }

    if ( ferror ( stdout) || fflush ( stdout ) )
    {
	fprintf ( stderr , MsgWriteError , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\i386mips.c ===
/*
**	I386MIPS - change the machine ID on a COFF object from I386 to R3000
**	Steve Salisbury, 03/24/1992
**
**	Modifications
**	-------------
**	10/20/1993 by Steve Salisbury
**		Change output machine type from R3000 to R4000
**		Add #defines for _M_IX86 and i386 to make #include's work
**		Fix dump of raw data
**
**	09/07/1994 by Steve Salisbury
**		Change include file to <windows.h>, remove #define _X86_
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

int main(int argc, char **argv);

IMAGE_FILE_HEADER ifh ;
IMAGE_SECTION_HEADER ish ;
IMAGE_RELOCATION reloc ;

const char * RelocName ( int reloctype ) ;

int main(int argc, char **argv)
{
	FILE *fileptr;
	char * name ;
	char * cp ;
	int errors = 0 ;
	int WriteFlag = 0 ;

	-- argc , ++ argv ;

	if ( setvbuf ( stderr , NULL , _IONBF , 0 ) )
	{
		printf ( "setvbuf error\n" ) ;
		exit ( 1 ) ;
	}

	if ( argc == 0 || ( cp = * argv ) && * cp == '-'
	&& ( * cp == 'h' || * cp == 'H' || * cp == '?' ) )
	{
		fprintf ( stderr ,
	"usage: i386mips [-w] <objectfile> ...\n"
	"each object file listed is converted from I386 to MIPS\n"
	"-w specifies that i386 objects should be changed to MIPS objects\n"
	"NOTE: This only works for files containing data but no code!\n"
		);
		exit ( 1 ) ;
	}

	if ( argc > 1 && ! strcmp ( "-w" , * argv ) )
	{
		-- argc , ++ argv ;
		WriteFlag = 1 ;
	}

	for ( ; * argv ; )
	{
		char * name ;
		int sect ;

		name = * argv ++ ;

		++ errors ; /* increment on principle */

		if ( WriteFlag )
		{
			if ( ( fileptr = fopen ( name , "r+b" ) ) == NULL )
			{
				fprintf ( stderr ,
		"i386mips: cannot open \"%s\" for modification\n" ,
					name ) ;
				continue ;
			}
		}
		else
		{
			if ( ( fileptr = fopen ( name , "rb" ) ) == NULL )
			{
				fprintf ( stderr ,
		"i386mips: cannot open \"%s\" for reading\n" ,
					name ) ;
				continue ;
			}
		}

		if ( 1 != fread ( & ifh , sizeof ( ifh ) , 1 , fileptr ) )
		{
			fprintf ( stderr ,
	"i386mips: cannot read first %d bytes from \"%s\"\n" ,
				sizeof ( ifh ) , name ) ;
			fclose ( fileptr ) ;
			continue ;
		}

		printf ( "Machine ID = 0x%X (%s)\n" ,
			ifh.Machine , 
			ifh.Machine == IMAGE_FILE_MACHINE_I386 ? "i386" :
			ifh.Machine == IMAGE_FILE_MACHINE_R4000 ? "MIPS" :
			ifh.Machine == IMAGE_FILE_MACHINE_R3000 ? "MIPS R3000 (ERROR)" :
			"?Unknown?" ) ;

		printf ( "%d Sections, TimeDate=%08lX, SizeOptHdr=%u, Flags=0x%X" ,
			ifh.NumberOfSections, ifh.TimeDateStamp, 
			ifh.SizeOfOptionalHeader , ifh.Characteristics);

		if ( ifh.Characteristics & IMAGE_FILE_RELOCS_STRIPPED )
			printf ( " NoRelocs" ) ;
		if ( ifh.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE )
			printf ( " EXECUTABLE" ) ;
		if ( ifh.Characteristics & IMAGE_FILE_LINE_NUMS_STRIPPED )
			printf ( " NoLineNums" ) ;
		if ( ifh.Characteristics & IMAGE_FILE_LOCAL_SYMS_STRIPPED )
			printf ( " NoLocalSyms" ) ;
		printf ( "\n" ) ;

		printf ( "\n" ) ;

		if ( WriteFlag )
		{
			if ( ifh.Machine != IMAGE_FILE_MACHINE_I386 )
			{
				if ( ifh.Machine == IMAGE_FILE_MACHINE_R4000 )
					fprintf ( stderr ,
		"i386mips: \"%s\" is already a MIPS COFF file (machine type = 0x%X)\n" ,
						name , ifh.Machine ) ;
				else
					fprintf ( stderr ,
		"i386mips: \"%s\" is not an i386 COFF file (machine type = 0x%X)\n" ,
						name , ifh.Machine ) ;

				fclose ( fileptr ) ;
				continue ;
			}

			if ( fseek ( fileptr , 0L , SEEK_SET ) )
			{
				fprintf ( stderr ,
		"i386mips: fseek() error on \"%s\"\n" , name  ) ;
				fclose ( fileptr ) ;
				continue ;
			}

			ifh.Machine = IMAGE_FILE_MACHINE_R4000 ;
		
			if ( 1 != fwrite ( & ifh.Machine , sizeof ( ifh.Machine ) , 1 , fileptr ) )
			{
				fprintf ( stderr ,
		"i386mips: cannot re-write first %d bytes of \"%s\"\n" ,
					sizeof ( ifh.Machine ) , name ) ;
				fclose ( fileptr ) ;
				continue ;
			}

			printf ( "Machine ID on \"%s\" changed from 0x%X (i386) to 0x%X (MIPS)\n" ,
				name , IMAGE_FILE_MACHINE_I386 , IMAGE_FILE_MACHINE_R4000 ) ;

			if ( fseek ( fileptr , (long) sizeof ( ifh ) , SEEK_SET ) )
			{
				fprintf ( stderr ,
			"i386mips: fseek() error on \"%s\" (@%ld)\n" , name , sizeof ( ifh )  ) ;
				fclose ( fileptr ) ;
				continue ;
			}
		}

		for ( sect = 1 ; sect <= ifh.NumberOfSections ; ++ sect )
		{
			int s ;
			long savedpos ;
			
			if ( 1 != fread ( & ish , sizeof ( ish ) , 1 , fileptr ) )
			{
				fprintf ( stderr ,
		"i386mips: cannot read section header %d from \"%s\"\n" ,
					sect , name ) ;
				fclose ( fileptr ) ;
				continue ;
			}

			printf ( "Section %d: \"%s\": VirtSize=0x%lX, VirtAdddr=0x%lX, SizeOfRawData=0x%lX\n" ,
				sect , ish.Name , ish.Misc.VirtualSize, ish.VirtualAddress, ish.SizeOfRawData);

			printf ( "PtrRawData=0x%lX, PtrRelocs=0x%lX, PtrLineNums=0x%lX\n" ,
				ish.PointerToRawData, ish.PointerToRelocations,
				ish.PointerToLinenumbers ) ;

			printf ( "#Relocs=%u, #LineNums=%u, Flags=0x%lX" ,
				ish.NumberOfRelocations, ish.NumberOfLinenumbers, ish.Characteristics);
			if ( ish.Characteristics & IMAGE_SCN_CNT_CODE )
				printf ( " Text" ) ;
			if ( ish.Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA )
				printf ( " Data" ) ;
			if ( ish.Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA )
				printf ( " BSS" ) ;
			printf ( "\n" ) ;

			printf ( "\n" ) ;

			savedpos = 0 ;

			if ( ish.PointerToRawData )
			{
				int b ;

				savedpos = ftell ( fileptr ) ;

				if ( fseek ( fileptr , ish.PointerToRawData , SEEK_SET ) )
				{
					fprintf ( stderr ,
			"i386mips: fseek() error on \"%s\" (Raw Data at 0x%lX)\n" , name ,
						ish.PointerToRawData ) ;
					fclose ( fileptr ) ;
					continue ;
				}

				printf ( "Raw Data for Section %d:" , sect ) ;

				for ( b = 0 ; b < ish.SizeOfRawData ; ++ b )
					printf ( "%s%02X" ,
						( b & 0xF ) ? " " : "\n\t" ,
						getc ( fileptr ) ) ;

				printf ( "\n\n" ) ;
			}
				
			if ( ish.NumberOfRelocations )
			{
				int r ;

				if ( ! savedpos )
					savedpos = ftell ( fileptr ) ;

				if ( fseek ( fileptr , ish.PointerToRelocations , SEEK_SET ) )
				{
					fprintf ( stderr ,
			"i386mips: fseek() error on \"%s\" (Relocs at 0x%lX)\n" , name ,
						ish.PointerToRelocations ) ;
					fclose ( fileptr ) ;
					continue ;
				}

				for ( r = 1 ; r <= ish.NumberOfRelocations ; ++ r )
				{
					if ( 1 != fread ( & reloc , sizeof ( reloc ) , 1 , fileptr ) )
					{
						fprintf ( stderr ,
				"i386mips: cannot read relocation %d in section %d from \"%s\"\n" ,
							r , sect , name ) ;
						fclose ( fileptr ) ;
						continue ;
					}

					printf ( "Relocation %d: Addr=0x%lX, Symbol=%ld, Type=0x%X  %s\n" ,
						r , reloc.VirtualAddress , reloc.SymbolTableIndex ,
						reloc.Type , RelocName ( reloc.Type ) ) ;

					if ( WriteFlag && reloc.Type == IMAGE_REL_I386_DIR32 )
					{
						if ( fseek ( fileptr , ish.PointerToRelocations , SEEK_SET ) )
						{
							fprintf ( stderr ,
					"i386mips: fseek() error on \"%s\" (Reloc %d in Section %d at 0x%lX)\n" , name ,
								sect , r , ish.PointerToRelocations ) ;
							fclose ( fileptr ) ;
							continue ;
						}

						reloc.Type = IMAGE_REL_MIPS_REFWORD ;
						
						if ( 1 != fwrite ( & reloc , sizeof ( reloc ) , 1 , fileptr ) )
						{
							fprintf ( stderr ,
					"i386mips: cannot re-write relocation %d in section %d from \"%s\"\n" ,
								r , sect , name ) ;
							fclose ( fileptr ) ;
							continue ;
						}
						
						if ( fseek ( fileptr , 0L , SEEK_CUR ) )
						{
							fprintf ( stderr ,
					"i386mips: fseek() error on \"%s\" (after Reloc %d in Section %d at 0x%lX)\n" , name ,
								sect , r , ish.PointerToRelocations ) ;
							fclose ( fileptr ) ;
							continue ;
						}

						printf ( "===> relocation changed to type %d (%s)\n" ,
							reloc.Type , RelocName ( reloc.Type ) ) ;
					}

				}

				printf ( "\n" ) ;
			}
				
			printf ( "\n" ) ;

			if ( ! savedpos )
				savedpos = ftell ( fileptr ) ;


			if ( savedpos && fseek ( fileptr , savedpos , SEEK_SET ) )
			{
				fprintf ( stderr ,
			"i386mips: fseek() error on \"%s\" (return to 0x%lX)\n" , name ,
					savedpos ) ;
				fclose ( fileptr ) ;
				continue ;
			}
		}

		if ( fclose ( fileptr ) )
		{
			fprintf ( stderr ,
	"i386mips: fclose () error on \"%s\"\n" , name  ) ;
			continue ;
		}

		-- errors ; /* undo increment on principle */

	}

	return errors ;
}

const char * RelocName ( int reloctype )
{
	char * name ;

	switch ( reloctype )
	{
	case 0 :
		name = "Absolute" ;
		break ;
	case 1 :
		name = "I386_DIR16 / MIPS_REFHALF" ;
		break ;
	case 2 :
		name = "I386_REL16 / MIPS_REFWORD" ;
		break ;
	case 3 :
		name = "MIPS_JMPADDR" ;
		break ;
	case 4 :
		name = "MIPS_REFHI" ;
		break ;
	case 5 :
		name = "MIPS_REFLO" ;
		break ;
	case 6 :
		name = "I386_DIR32 / MIPS_GPREL" ;
		break ;
	case 7 :
		name = "I386_DIR32NB / MIPS_LITERAL" ;
		break ;
	case 011 :
		name = "I386_SEG12" ;
		break ;
	case 024 :
		name = "I386_REL32" ;
		break ;
	case 042 :
		name = "MIPS_REFWORDNB" ;
		break ;
	case 045 :
		name = "MIPS_PAIR" ;
		break ;
	default :
		name = "*** ??? ***" ;
	}

	return name ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\trailing.c ===
/*
 *	Trailing - strip trailing tabs and blanks from input stream
 *	Assumes no sequence of tabs or spaces is more than MAXWHITE chars long.
 *	This filter also enforces that '\n' is preceeded by '\r'
 *
 *	Last Modified Mon 12 Oct 1987 by Steve Salisbury
 *	1988 Mar 09 Wed (SKS)	Reworked buffering, output counting
 *				check for buffer overflow
 *
 *	cl -Oaltr -G2s trailing.c -o trailing.exr -link slibcr libh /nod:slibce;
 *	cl trailing -link slibcp libh /nod:slibce, trailing;
 */

#define MAXWHITE	4096

#ifndef BIGBUFSIZE
#define BIGBUFSIZE	8192
#endif

#include <stdio.h>
#include <fcntl.h>

#define	REG	register

char InBuf [ BIGBUFSIZE ] ;
char OutBuf [ BIGBUFSIZE ] ;

char	Line [ MAXWHITE ] ;

int main ( int argc , char * * argv )
{
    FILE    * input ;
    FILE    * output ;
    char * inputname ;
    char * outputname ;
REG int     ch ;
REG char    * whiteptr ;
    int     ch_save ;
    int     kbytes = 0 ;
    int     numbytes = 0 ;
    int     countflag = 0 ;
    char    * arg ;

    if ( -1 == _setmode ( _fileno(stdin) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdin)\n" ) ;
	exit ( 1 ) ;
    }

    if ( -1 == _setmode ( _fileno(stdout) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdout)\n" ) ;
	exit ( 1 ) ;
    }

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * * argv == '-' )
    {
	arg = * argv ++ ;
	-- argc ;

	while ( * ++ arg )
	    switch ( * arg )
	    {
	    case 'k' :
		countflag = 1 ;
		break ;
	    default :
		goto Usage;
	    }
    }

    if ( argc > 2 )
    {
Usage:
	fprintf ( stderr , "Usage: trailing [-k] [input [output]]\n" ) ;
	fprintf ( stderr , "`-' for input means use standard input\n" ) ;
	exit ( 1 ) ;
    }

    if ( argc >= 1 && strcmp ( argv [ 0 ] , "-" ) )
    {
	input = fopen ( inputname = argv [ 0 ] , "rb" ) ;
	if ( ! input )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 0 ] ) ;
	    exit ( 2 ) ;
	}
    }
    else
    {
	input = stdin ;
	inputname = "<standard input>" ;
    }

    if ( argc == 2 && strcmp ( argv [ 1 ] , "-" ) )
    {
	output = fopen ( outputname = argv [ 1 ] , "wb" ) ;
	if ( ! output )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 1 ] ) ;
	    exit ( 3 ) ;
	}
    }
    else
    {
	output = stdout ;
	outputname = "<standard output>" ;
    }

    if ( setvbuf ( input , InBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf input)\n" ) ;
	exit ( 1 ) ;
    }

    if ( setvbuf ( output , OutBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf output)\n" ) ;
	exit ( 1 ) ;
    }

    whiteptr = Line ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == '\r' )
	{
	    /*
	    ** '\r' followed by '\n' gets swallowed
	    */
	    if ( ( ch = getc ( input ) ) != '\n' )
	    {
		ungetc ( ch , input ) ; /* pushback */
		ch = '\r' ;
	    }
	    else
		++ numbytes ;
	}

	if ( ch == ' ' || ch == '\t' )
	{
	    * whiteptr ++ = ch ;
	    if ( whiteptr > Line + sizeof ( Line ) )
	    {
		fprintf ( stderr , "trailing: too many spaces/tabs (%d)\n" ,
		     whiteptr - Line ) ;
		exit ( 4 ) ;
	    }
	}
	else if ( ch == '\n' )
	{
	    putc ( '\r' , output ) ;
	    putc ( '\n' , output ) ;
	    whiteptr = Line ;
	}
	else
	{
	    if ( whiteptr != Line )
	    {
		/*
		 * Flush the white space buffer
		 */
		ch_save = ch ;
		ch = whiteptr - Line ;
		whiteptr = Line ;
		do
		    putc ( * whiteptr ++ , output ) ;
		while ( -- ch ) ;
		whiteptr = Line ;
		ch = ch_save ;
	    }
	    putc ( ch , output ) ;
	}

	if ( ++ numbytes >= 4096 )
	{
	    numbytes -= 4096 ;
	    if ( countflag )
		fprintf ( stderr , "%uK\r" , 4 * ++ kbytes ) ;
	}
    }

    if ( fflush ( output ) )
    {
	fprintf ( stderr , "trailing: cannot flush %s\n" , argv [ 1 ] ) ;
	exit ( 4 ) ;
    }

    fclose ( input ) ;
    fclose ( output ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\errormes.h ===
/***
*Errormes.h - Error / Warning reporting used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Error / Warning reporting used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef ERRORMES_H
#define ERRORMES_H

/* error messages, parameters are strings holding the reason and text of the line that caused the error */
extern void error(char *, char *);

/* warning messages, parameters are strings holding the reason and text of the line that caused the error */
extern void warning(char *, char *);

extern FILE *errorfile;	/* file to output error/warning messages */

#endif /* ERRORMES_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\aliasobj.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include "prodids.h"
#include "version.h"


void
StoreName(PUCHAR sz, PIMAGE_SYMBOL psym, PULONG pcbStrings)
{
    memset((void *)&psym->N.Name, 0, (size_t)sizeof(psym->N.Name));
    if (strlen(sz) <= IMAGE_SIZEOF_SHORT_NAME) {
        strncpy((char *)psym->N.ShortName, (char *)sz, IMAGE_SIZEOF_SHORT_NAME);
    } else {
        psym->N.Name.Long = *pcbStrings;
        *pcbStrings += strlen(sz) + 1;
    }
}


int main(int argc, char **argv)
{
    PUCHAR szFrom, szTo, szFilename;
    FILE *pfile;
    IMAGE_FILE_HEADER hdr;
    IMAGE_SYMBOL sym;
    IMAGE_AUX_SYMBOL aux;
    ULONG cbStrings, foStringTable;
    IMAGE_SECTION_HEADER sec;
    DWORD dwProdid;

    if (argc != 4) {
        printf("usage: ALIASOBJ from-name to-name output-filename\n");
        exit(1);
    }
    szFrom = argv[1];
    szTo = argv[2];
    szFilename = argv[3];

    if ((pfile = fopen(szFilename, "wb")) == NULL) {
        printf("can't open file \"%s\"\n", szFilename);
        exit(1);
    }

    hdr.Machine = IMAGE_FILE_MACHINE_UNKNOWN;
    hdr.NumberOfSections = 1;
    hdr.TimeDateStamp = (DWORD) time(NULL);
    hdr.PointerToSymbolTable = sizeof(hdr) + sizeof(sec);
    hdr.NumberOfSymbols = 4;
    hdr.SizeOfOptionalHeader = 0;
    hdr.Characteristics = 0;

    fwrite(&hdr, sizeof(hdr), 1, pfile);

    // Generate one section header.  This is necessary because of a link bug (vce:182)
    // which fails for .obj's with 0 sections and unknown machine type.
    //
    memset(&sec, 0, sizeof(sec));
    strcpy(sec.Name, ".text");
    sec.Characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
    fwrite(&sec, sizeof(sec), 1, pfile);

    cbStrings = sizeof(ULONG);  // make room for stringtab size

#if     (rmj == 7) && (rmm == 0)

    dwProdid = DwProdidFromProdidWBuild(prodidAliasObj70, rup);

#else

#error  PRODID needs to be assigned

#endif

    memset(sym.N.ShortName, 0, sizeof(sym.N.ShortName));
    strncpy((char *) sym.N.ShortName, symProdIdentName, IMAGE_SIZEOF_SHORT_NAME);
    sym.Value = dwProdid;
    sym.SectionNumber = symProdIdentSection;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = symProdIdentClass;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szTo, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_EXTERNAL;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szFrom, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;
    sym.NumberOfAuxSymbols = 1;
    fwrite(&sym, sizeof(sym), 1, pfile);

    memset(&aux, 0, sizeof(aux));
    aux.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
    aux.Sym.TagIndex = 1;               // symtab index for extern
    fwrite(&aux, sizeof(aux), 1, pfile);

    // Write the string table.
    //
    foStringTable = ftell(pfile);
    fwrite(&cbStrings, sizeof(cbStrings), 1, pfile);
    if (strlen(szTo) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szTo, pfile);
        fputc(0, pfile);
    }
    if (strlen(szFrom) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szFrom, pfile);
        fputc(0, pfile);
    }
    assert(ftell(pfile) - foStringTable == cbStrings);

    fclose(pfile);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\pd.c ===
/*
 * Program:	Recursive Directory listing
 * Author:	Steve Salisbury
 *
 * Last Modified:
 *
 *	1995-03-08 Wed 16:00 PST
 *	**** >>>> Ported to Win32 <<<< ****
 */

#ifdef _WIN32
#define WIN32
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>


#ifdef _DEBUG
int DebugFlag ;
#define	DEBUG(n,x)	if ( DebugFlag & n ) printf x;
#else
#define	DEBUG(n,x)
#endif


#define ISSLASH(ch)	((ch) == '/' || (ch) == '\\')

#define	BL	' '
#define	NAMLEN	8
#define	EXTLEN	3

typedef unsigned char uchar ;
typedef unsigned short ushort ;
typedef unsigned int uint ;
typedef unsigned long ulong ;

#define	ATTRIB_READONLY		0x01
#define	ATTRIB_HIDDEN		0x02
#define	ATTRIB_SYSTEM		0x04
#define	ATTRIB_VOLUMELABEL	0x08
#define	ATTRIB_DIRECTORY	0x10
#define	ATTRIB_ARCHIVE		0x20

#define	ATTRIB_ALL	( ATTRIB_HIDDEN | ATTRIB_SYSTEM | ATTRIB_DIRECTORY )



void PrintFile ( WIN32_FIND_DATA * match ) ;

#define	MAXPATHLENGTH	(_MAX_PATH+4)

char	path [ MAXPATHLENGTH ] ;

char	current_dir [ MAXPATHLENGTH ] ;	/* Current Directory */

int	pathlength ;

uint	clustersize ;
uint	sectorsize ;
uint	availclusters ;
uint	totalclusters ;

int 	numfiles ;
int 	numdirs ;
long	numbytes ;
long	numclusters ;

uint	NewClusterSize ;	/* override actual cluster size */
uint	NewSectorSize ;		/* override actual sector size */

int 	maxwidth = 71 ;	/* Maximum width of an output line */

char	totalstring [] =
	"[ %s files, %s sub-dirs, %s bytes (%s allocated) ]\n" ;

int 	AltNameFlag ;		/* If non-zero, echo 8.3 names as well */
int 	DirOnlyFlag ;		/* If non-zero, only directories are listed */
int 	FileOnlyFlag ;		/* If non-zero, only files are listed */
int		TerseFlag ;			/* If non-zero, output is very terse */
int 	SummaryOnlyFlag ;	/* If non-zero, output ONLY summary information */
int 	NoSummaryFlag ;		/* If non-zero, do not output summary information */

uint	Exclude ;		/* file attributes to excluded from display */
uint	Require ;		/* file attributes to be required for display */


char * VolumeLabel ( char * driveString , unsigned * serialNum ) ;
void PrintDir ( void ) ;
void PrintFile ( WIN32_FIND_DATA * match ) ;
int get_drive ( void ) ;
void get_dir ( char * buffer , int drive ) ;
int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp ) ;
char * PrintWithCommas ( unsigned n ) ;


int main ( int argc , char * * argv )
{
	char	* ap ;		/* ap = *argv when parsing the switch args */
	char	* volume ;
	int 	drive = get_drive ( ) ;
	char	driveString [ _MAX_PATH ] ;
	uint	serialNum ;

	++ argv , -- argc ;

#ifdef _DEBUG
	if ( argc > 0 && argv [ 0 ] [ 0 ] == '-' && argv [ 0 ] [ 1 ] == 'D' )
	{
		char * endptr ;

		DebugFlag = strtoul ( argv [ 0 ] + 2 , & endptr , 0 ) ;
		printf("DebugFlag = 0x%x (%s)\n" , DebugFlag , * argv ) ;

		++ argv , -- argc ;
	}
#endif

	while ( argc > 0 && * ( ap = * argv ) == '-' )
	{
		while ( * ++ ap )
			if ( * ap == 'a' )
			{
				int flag ;

				if ( * ++ ap != '-' && * ap != '=' )
					goto Usage ;

				flag = * ap ;
				while ( * ++ ap )
				{
					if ( * ap == 'a' || * ap == 'A' )
						if ( flag == '-' )
							Exclude |= ATTRIB_ARCHIVE ;
						else
							Require |= ATTRIB_ARCHIVE ;
					else if ( * ap == 'r' || * ap == 'R' )
						if ( flag == '-' )
							Exclude |= ATTRIB_READONLY ;
						else
							Require |= ATTRIB_READONLY ;
					else if ( * ap == 'h' || * ap == 'H' )
						if ( flag == '-' )
							Exclude |= ATTRIB_HIDDEN ;
						else
							Require |= ATTRIB_HIDDEN ;
					else if ( * ap == 's' || * ap == 'S' )
						if ( flag == '-' )
							Exclude |= ATTRIB_SYSTEM ;
						else
							Require |= ATTRIB_SYSTEM ;
					else if ( * ap == '-' || * ap == '=' )
						flag = * ap ;
					else
						goto Usage ;
				}
				
				-- ap ;
			}
			else if ( * ap == 'c' )
			{	/* Use alternate cluster size */
				while ( isdigit ( * ++ ap ) )
					NewClusterSize = NewClusterSize * 10 + * ap - '0' ;
				printf ( "New ClusterSize = %u\n" , NewClusterSize ) ;
				-- ap ;
			}
			else if ( * ap == 'd' )
				/* Print directories but not files */
				++ DirOnlyFlag ;
			else if ( * ap == 'f' )
				/* Print directories but not files */
				++ FileOnlyFlag ;
			else if ( * ap == 's' )
			{	/* Use alternate sector size */
				while ( isdigit ( * ++ ap ) )
					NewSectorSize = NewSectorSize * 10 + * ap - '0' ;
				printf ( "NewSectorSize = %u\n" , NewSectorSize ) ;
				-- ap ;
			}
			else if ( * ap == 'z' )
				/* Display ONLY summary info. */
				++ SummaryOnlyFlag ;
			else if ( * ap == 'Z' )
				/* Display no summary info. */
				++ NoSummaryFlag ;
			else if ( * ap == 't' )
				/* Only file/dir names in output */
				++ TerseFlag ;
			else if ( * ap == 'x' )
				/* Show 8.3 names */
				++ AltNameFlag ;
			else
				goto Usage ;
		-- argc ;
		++ argv ;
	}

	if ( argc > 1 )
	{
Usage:
		puts (
#ifdef _DEBUG
			"usage: pd [-D#] [ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#else
			"usage: pd "    "[ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#endif

			"\twhere path is an optional Path to a directory\n"
#ifdef _DEBUG
			"\t`-D#' means print debugging information (# is a number\n"
			"\t\twhich is interpreted as a bit mask for debug info.)\n"
#endif
			"\t`-d' means print only directory names\n"
			"\t`-f' means print only file names\n"
			"\t`-t' means terse output (only file/directory name)\n"
			"\t`-x' means show 8.3 alternate names after long filenames\n"
			"\t`-z' means output only summary information\n"
			"\t`-Z' means do not output any summary information\n"
			"\t`-a-* means exclude files with attribute(s) * (out of ARHS)\n"
			"\t`-a=* means show only files with attribute(s) *\n"
			"\t        the possible attributes are ARHS\n"
			"\t`-c#' sets logical cluster size to # sectors\n"
			"\t`-s#' sets logical sector size to # bytes\n"
			) ;
		exit ( 1 ) ;
	}

	path [ 0 ] = drive + '@' ;
	path [ 1 ] = ':' ;
	path [ 2 ] = '\\' ;
	path [ 3 ] = '\0' ;

	strcpy ( driveString , path ) ;

	if ( argc == 1 )
	{
		char * arg = argv [ 0 ] ;

		if ( isalpha ( arg [ 0 ] ) && arg [ 1 ] == ':' )
		{
			drive = toupper ( * arg ) ;

			if ( isalpha ( drive ) )
				drive -= 'A' - 1 ;
			else
			{
				fprintf ( stderr , "pd: expected alphabetic character before :\n\t%s\n" , arg ) ;
				exit ( 1 ) ;
			}

			driveString [ 0 ] = path [ 0 ] = * arg ;

			if ( arg [ 2 ] )
				/* Specified Directory & Directory */
				strcpy ( path + 2 , arg + 2 ) ;
			else	/* Specified Drive, Current Directory */
				get_dir ( path + 3 , drive ) ;
		}
		else if ( ISSLASH ( arg [ 0 ] ) && ISSLASH ( arg [ 1 ] ) )
		{
			int n = 2 ;

			/*-
			 * Find the slash that terminates the server name
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected server name plus share point:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			/*-
			 * Find the slash that terminates the share point
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected share point name after server name:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			strcpy ( path , arg ) ;
			strcpy ( driveString , arg ) ;
			driveString [ n ] = '\0' ;
		}
		else	/* Current Drive, Specified Directory */
			strcpy ( path + 2 , arg ) ;
	}
	else	/* Current Drive & Directory */
		get_dir ( path + 3 , drive ) ;

	DEBUG(1, ("path = \"%s\"\n",path))
	DEBUG(1, ("driveString = \"%s\"\n",driveString))

	volume = VolumeLabel ( driveString , & serialNum ) ;

	if ( ! NoSummaryFlag )
	{
		printf ( "Directory %s  " , path ) ;

		if ( * volume )
			printf ( "(Volume = \"%s\", %04X-%04X)\n" , volume ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
		else
			printf ( "(No Volume Label, %04X-%04X)\n" ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
	}
	
	clustersize = get_free ( driveString , & availclusters , & sectorsize ,
		& totalclusters ) ;

	if ( NewClusterSize )
		clustersize = NewClusterSize ;

	if ( NewSectorSize )
		sectorsize = NewSectorSize ;

	if ( ! sectorsize )
	{
		fprintf ( stderr , "pd: warning: assuming 512 bytes/sector.\n" ) ;
		sectorsize = 512 ;
	}

	if ( ! clustersize )
	{
		fprintf ( stderr , "pd: warning: assuming 1 sector/cluster.\n" ) ;
		clustersize = 1 ;
	}

	pathlength = strlen ( path ) ;

	if ( path [ pathlength - 1 ] == '\\' )
		-- pathlength ;	/* Make "\" visible but not present */

	PrintDir ( ) ;

	if ( ! NoSummaryFlag )
		printf ( totalstring , PrintWithCommas ( numfiles ) ,
			PrintWithCommas ( numdirs ) ,
			PrintWithCommas ( numbytes ) ,
			PrintWithCommas ( numclusters * clustersize *
				sectorsize ) ) ;

	return 0 ;
}


/*
 * VolumeLabel -
 *	Get the volume Label
 *	This routine may NOT return NULL
 */

static	char	volume [ _MAX_PATH ] = "12345678901" ;

char * VolumeLabel ( char * driveString , unsigned * pSerialNumber )
{
	uint MaxCompLength ;
	uint FSflags ;

	if ( ! GetVolumeInformation ( driveString , volume , sizeof ( volume ) ,
		pSerialNumber , & MaxCompLength , & FSflags , NULL , 0 ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetVolumeInformation(%s)\n" ,
			GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	DEBUG(2, ("%s: \"%s\" : %04X-%04X; %d c; 0x%X\n",driveString,volume,
		(*pSerialNumber>>16)&0xFFFF,*pSerialNumber&0xFFFF,FSflags))

	return volume ;
}


/*
 * PrintDir -
 *	Print all the files in the current directory
 *	Then recursively print the sub-directories
 *	Ignore the "." and ".." special entries
 */

void PrintDir ( void )
{
	WIN32_FIND_DATA	match ;
	HANDLE handle ;
	int	flag ;

	path [ pathlength ] = '\\' ;
	path [ pathlength + 1 ] = '*' ;
	path [ pathlength + 2 ] = '\0' ;

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(4, ("PrintDir - opening handle %08X (files)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		DEBUG(4, ("PrintDir - FindFirst/NextFile(\"%s\") (files)\n",match.cFileName))

		/* Print everything in the directory except "." and ".." */
		if ( ATTRIB_DIRECTORY & ~ match . dwFileAttributes )
			PrintFile ( & match ) ;

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(4, ("PrintDir - closing handle %08X (files)\n",handle))

	path [ pathlength ] = '\\' ;	/* Restore to "...\*" */

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(8, ("PrintDir - opening handle %08X (dirs)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		char	* cp ;
		int	lensave ;

		DEBUG(8, ("PrintDir - FindFirst/NextFile(\"%s\") (dirs)\n",match.cFileName))

		/* Find all sub-directories except "." and ".." */

		if ( ( match . dwFileAttributes & ATTRIB_DIRECTORY )
		  && strcmp ( match . cFileName , "." )
		  && strcmp ( match . cFileName , ".." ) )
		{
			PrintFile ( & match ) ;

			cp = match . cFileName ;
			lensave = pathlength ;

			/* Add "\dirname" to the current Path */

			path [ pathlength ++ ] = '\\' ;

			while ( path [ pathlength ] = * cp ++ )
				++ pathlength ;

			PrintDir ( ) ;

			path [ pathlength = lensave ] = '\0' ;
		}

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(8, ("PrintDir - closing handle %08X (dirs)\n",handle))
}


/* static	char *	months [ ] = {
/*	"?00" , "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" ,
/*	"Aug" , "Sep" , "Oct" , "Nov" , "Dec" , "?13" , "?14" , "?15" } ;
 */

/* static	char *	weekdays [ ] = {
/*	"Sun" , "Mon" , "Tue" , "Wed" , "Thu" , "Fri" , "Sat" } ;
 */

static	char	monthstarts [ ] =
	/**** Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec */
	{ -1 , 0 , 3 , 3 , 6 , 1 , 4 , 6 , 2 , 5 , 0 , 3 , 5 , -1 , -1 , -1 } ;


/*
 * PrintFile -
 *	Print the information for the file described in "match"
 */

void PrintFile ( WIN32_FIND_DATA * match )
{
	int	year , month , day /* , wkday */ ;
	int	hour , minute , second ;
	long sec , clu ;
	char sizebuf [ 12 ] ;	/* Either size of file or else "****DIR****" */
	FILETIME lftime ;
	SYSTEMTIME systime ;

	/*
	 * If only directories are to be shown, do not list files
	 * and if only files are to be shown, do not list directories
	 */

	if ( ( DirOnlyFlag  && ! ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) )
	||   ( FileOnlyFlag &&	 ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) ) )
		return ;

	/*
	** Check the attribute filters
	*/

	if ( ( match -> dwFileAttributes & Exclude )
	|| ( match -> dwFileAttributes & Require ) != Require )
		return ;

	/*
	** At this point, count this file and its bytes
	*/

	if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
		++ numdirs ;
	else
		++ numfiles ;

	sec = ( match -> nFileSizeLow + sectorsize - 1 ) / sectorsize ;
	clu = ( sec + clustersize - 1 ) / clustersize ;

	numbytes += match -> nFileSizeLow ;
	numclusters += clu ;

	if ( SummaryOnlyFlag )
		return ;

	FileTimeToLocalFileTime ( & match -> ftLastWriteTime , & lftime ) ;
	FileTimeToSystemTime ( & lftime , & systime ) ;

	year = systime . wYear ;
	month = systime . wMonth ;
	day = systime . wDay ;
	hour = systime . wHour ;
	minute = systime . wMinute ;
	second = systime . wSecond ;

	/*
	 * 1980 Jan 01 was a Tuesday (2):
	 *	Add in the day of the month and the month offsets
	 *	Add 1 day for each year since 1980
 	 *	Add 1 for each leap year since 1980
	 */

/*	wkday = 2 + ( day - 1 ) + monthstarts [ month ] +
/*		/* year + leap years before the most recent */
/*		( year - 1980 ) + ( ( year - 1980 ) >> 2 ) +
/*		/* Add in the most recent leap day */
/*		( ( ( year & 3 ) != 0 || month > 2 ) ? 1 : 0 ) ;
/*	wkday %= 7 ;
 */

	if ( TerseFlag )
		printf ( "%s\\%s%s\n" ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ) ;
	else
	{
		char altbuf [ 24 ] ;	/* used to display alternate (8.3) name */

		if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
			strcpy ( sizebuf , "****DIR****" ) ;
		else if ( match -> nFileSizeLow <= 999999999L )
			strcpy ( sizebuf , PrintWithCommas ( match -> nFileSizeLow ) ) ;
		else	/* File too big for 9 digits */
			sprintf ( sizebuf , "%s K" , PrintWithCommas ( ( match -> nFileSizeLow + 1023 ) / 1024 ) ) ;

		if ( AltNameFlag && * match -> cAlternateFileName )
			sprintf ( altbuf , "  [%s]" , match->cAlternateFileName ) ;
		else
			altbuf [ 0 ] = '\0' ;

		printf ( "%11s %04d-%02d-%02d %02d:%02d:%02d %c%c%c%c  %s\\%s%s%s\n" ,
			sizebuf , year , month , day , hour , minute , second ,
			match -> dwFileAttributes & ATTRIB_ARCHIVE  ? 'A' : '-' ,
			match -> dwFileAttributes & ATTRIB_READONLY ? 'R' : '-' ,
			match -> dwFileAttributes & ATTRIB_HIDDEN ? 'H' : '-' ,
			match -> dwFileAttributes & ATTRIB_SYSTEM ? 'S' : '-' ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ,
			altbuf ) ;
	}
}

/*
 * Return the Current Disk Drive (1=A, 2=B, etc.)
 *	Note that DOS uses (0=A,1=B, etc.) for this call
 */

int get_drive ( void )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;
	int drive ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirector\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	drive = toupper ( CurDir [ 0 ] ) - ( 'A' - 1 ) ;

	DEBUG(1, ("get_drive => %d (%c:)\n", drive , CurDir [ 0 ]))

	return drive ;
}


/*
 * Store the Current Directory in the given char buffer
 *	The leading "\" in the path is not stored.
 *	The string is terminated by a null.
 */

void get_dir ( char * buffer , int drive )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirectory\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	strcpy ( buffer , CurDir + 3 ) ;
	DEBUG(1, ("get_dir => \"%s\"\n", buffer ))
}


/*
 * get_free - returns the number of sectors per cluster
 *	and stores the number of available clusters,
 *	the size of a sector (in bytes), and the total
 *	number of clusters on the current drive 
 */

int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp )
{
	unsigned int SectorsPerCluster , BytesPerSector , FreeClusters , Clusters ;

	if ( ! GetDiskFreeSpace ( driveString , & SectorsPerCluster ,
		& BytesPerSector , & FreeClusters , & Clusters ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetDiskFreeSpace ( %s )\n" ,
				GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	* availp = FreeClusters ;
	* totalp = Clusters ;
	* secsizep = BytesPerSector ;

	DEBUG(1, ("get_free => Clusters %d/%d, %d * %d\n",*availp,*totalp,*secsizep,SectorsPerCluster))

	return SectorsPerCluster ;
}


char * PrintWithCommas ( unsigned n )
{
static char buffers [ 16 ] [ 16 ] ;
static int bufnumber ;
	char * p = buffers [ bufnumber ++ % 16 ] ;

	if ( n <= 999 )
		sprintf ( p , "%d" , n ) ;
	else if ( n <= 999999 )
		sprintf ( p , "%d,%03d" , n / 1000 , n % 1000 ) ;
	else if ( n <= 999999999 )
		sprintf ( p , "%d,%03d,%03d" , n / 1000000 , n / 1000 % 1000 , n % 1000 ) ;
	else
		sprintf ( p , "%d,%03d,%03d,%03d" , n / 1000000000 , n / 1000000 % 1000 , n / 1000 % 1000 , n % 1000 ) ;

	return p ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\constant.h ===
/***
*Constant.h - Constants used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Constants used by the ifstripper, parser and symbol table
*
*Revision History:
*	09-30-92   MAL  Initial version
*
*******************************************************************************/

#ifndef CONSTANT_H
#define CONSTANT_H

#define TRUE  1
#define FALSE 0 		/* Boolean values */

#define IF          0           /* Tokens for preprocessor statements */
#define ELIF        1           /* These must not be re-ordered */
#define ELSE        2
#define ENDIF       3
#define IFDEF       4
#define IFNDEF      5
#define IF1         6
#define IF2         7
#define IFB         8
#define IFNB        9
#define IFIDN      10
#define IFDIF      11      /* CFW - added */
#define IFE        12      /* CFW - added */
#define maxkeyword 12
#define maxcomment  2      /* number of comment strings */
#define NORMAL    100
#define KEYWORD   101		/* Used only for skipto and copyto */

#define DEFINED    1
#define UNDEFINED  2
#define IGNORE     3
#define NOTPRESENT 4		/* Types of switches (symbols) */

#define MAXNAMELEN     65	/* Maximum length of a switch name */
#define MAXLINELEN    512	/* Maximum input line length */
#define MAXCONDLEN    512	/* Maximum length of a condition */
#define MAXFILENAMELEN 97	/* Maximum file name length */

#endif /* CONSTANT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\tolwrupr.c ===
/*
**  TOLWRUPR - translate [a-z] to [A-Z] or vice versa or both (!)
**
**	1994-08-19 Fri - original version, based on DTOX, which translated
**		If the output is the console, case line buffering is used.
**		CR+LF newlines (MS-DOS) to LF-only newlines (XENIX).
**
**	This program (tolwrupr) is equivalent to:
**
**		tolwrupr -L:	tr "[a-z]" "[A-Z]"
**		tolwrupr -U:	tr "[A-Z]" "[a-z]"
**		tolwrupr -X:	tr "[A-Z][a-z]" "[a-z][A-Z]"
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>

#define CR	'\r'
#define LF	'\n'

#define REG register

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  16384
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

int LineBuf;

static	char	MsgInternalError [ ] = "tolwrupr: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "tolwrupr: cannot open `%s' for input\n" ;
static	char	MsgStdin [ ] = "stdin" ;
static	char	MsgStdout [ ] = "stdout" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;
static	char	MsgFflush [ ] = "fflush" ;

static unsigned char map [ 256 ] ;


int main ( int argc , char * * argv ) ;

void Usage ( void ) ;


int main ( int argc , char * * argv )
{
REG int ch ;
    int countflag = 0 ;
    int toupperflag = -1 ;
    unsigned kilobytes ;
    unsigned bytecount ;
    char * MsgInput ;
    FILE * input ;
    char * cp ;

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * ( cp = * argv ) == '-' )
    {
	while ( * ++ cp )
	{
	    if ( * cp == 'k' )
	    {
	        if ( countflag != 0 )
		    Usage ( ) ;

	        countflag = 1 ;
	    }
	    else if ( * cp == 'L' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 0 ;
	    }
	    else if ( * cp == 'U' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 1 ;
	    }
	    else if ( * cp == 'X' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 2 ;
	    }
	    else
	    {
		Usage ( ) ;
	    }
	}

	-- argc ;
	++ argv ;
    }

    /*
     * Either -U or -L must be specified!
     */

    if ( toupperflag == -1 )
	Usage ( ) ;

    for ( ch = 0 ; ch < 256 ; ++ ch )
	map [ ch ] = ch ;

    /*
     * Set the case map
     */

    if ( toupperflag == 1 || toupperflag == 2 )
    {
    	for ( ch = 'a' ; ch <= 'z' ; ++ ch )
	    map [ ch ] -= 'a' - 'A' ;
    }

    if ( toupperflag == 0 || toupperflag == 2 )
    {
    	for ( ch = 'A' ; ch <= 'Z' ; ++ ch )
	    map [ ch ] += 'a' - 'A' ;
    }


    /*
     * Open the Input
     */

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , _O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	Usage ( ) ;

    if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    /* check for the need for line buffering */

    LineBuf = _isatty ( _fileno ( stdout ) ) ;

    /*
     * Process the Input
     */

    kilobytes = bytecount = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	ch = map [ ch ] ;

	putc ( ch , stdout ) ;

	if (ch == '\n' && LineBuf)
	    fflush ( stdout ) ;
	
	if ( countflag )
	    if ( ++ bytecount >= BIGBUFSIZE )
	    {
		bytecount -= BIGBUFSIZE ;
		fprintf ( stderr , "%uK\r" , kilobytes += ( BIGBUFSIZE / 1024 ) ) ;
	    }
    }

    if ( fflush ( stdout ) )
    {
	fprintf ( stderr , MsgInternalError , MsgFflush , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}


void Usage ( void )
{
    fprintf ( stderr ,
	"Usage: tolwrupr [-k] -(L|U|X) [ <InputFile> ]\n"
	"-k means echo progress in kilobytes to stderr\n"
	"-L means map lowercase characters to uppercase (tr \"[A-Z]\" \"[a-z]\")\n"
	"-U means map uppercase characters to lowercase (tr \"[a-z]\" \"[A-Z]\")\n"
	"-X means swap uppercase and lowercase (tr \"[a-z][A-Z]\" \"[A-Z][a-z]\")\n"
	"Exactly one of -L or -U or -X must be specified\n"
	) ;

    exit ( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\eval.h ===
/***
*Eval.h - If expression evaluator
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Evaluate complex if expressions
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

/* Take a pointer to workspace for a simplified condition and truth value, and pass in the condition string to simplify */
extern void evaluate(char *, int *, char *);

/* Produce the negative of a truth value,
   !DEFINED    == UNDEFINED
   !UNDEFINED  == DEFINED
   !IGNORE     == IGNORE
   !NOTPRESENT == NOTPRESENT */
extern int negatecondition(int);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\symtab.h ===
/***
*Symtab.h - symbol table storage used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Symbol table storage used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef SYMTAB_H
#define SYMTAB_H

/* read the symbol table from the named switch file */
extern void readsyms(char *);

/* add the named symbol to the table, with the given truth value */
extern void addsym(char *, int);

/* find the truth value for the named symbol */
extern int lookupsym(char *);

/* Check that the named identifier consists of valid characters */
extern int ident_only(char *);

#endif /* SYMTAB_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\eval.c ===
/***
*eval.c - if expression evaluator
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	produce truth values and simplified conditions from compound if
*	statements.
*
*Revision History:
*	09-30-92  MAL	Original version
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add support for more operators: == != < > <= >=
*			Add terseflag (-t) to suppress mesgs about directives
*	10-04-94  SKS	Add support for more operators: EQ NE LT GT LE NE
*			@ is an identifier character (e.g., MASM's @Version)
*   01-04-00  GB    Add support for internal crt builds
*
*******************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "eval.h"     /* Header for this module */
#include "symtab.h" 	 /* Symbol table access */
#include "constant.h" /* Constants for tokens etc */
#include "errormes.h" /* Errors and Warning messages */

/* Types */
typedef struct condrec
{
   int truth;
   char *condition;
} condrec, *cond;

/* Global variables */

extern int terseFlag;			/* controls display of forced directives */
extern char **comments;		         /* Language dependent comment strings */
extern int *commlen;                 /* Lengths of above strings */
extern int nonumbers;			     /* allow numeric expressions */
extern enum {NON_CRT = 0, CRT = 1} progtype;

char *operators[] = {
	"!", "(", ")", "||", "&&", "defined" ,
	"==" , "!=" , "<" , ">" , "<=" , ">=" ,
	"EQ" , "NE" , "LT" , "GT" , "LE" , "GE" };
int oplengths[] =   {
	1 , 1 , 1 , 2 , 2 , 7 ,
	2 , 2 , 1 , 1 , 2 , 2 ,
	2 , 2 , 2 , 2 , 2 , 2 };
                                                   /* # significant chars */
#define numoperators 18
	/* These tokens must be in the same order as 'operators' */
#define NOT			0
#define OPENPARENTHESIS		1
#define CLOSEPARENTHESIS	2
#define OR			3
#define AND			4
#define DEFINEDFN		5
#define	EQUALS			6
#define	NOTEQUALS		7
#define	LESSTHAN		8
#define	LESSOREQ		9
#define	GREATERTHAN		10
#define	GREATEROREQ		11
#define	EQUALS_ASM		12
#define	NOTEQUALS_ASM		13
#define	LESSTHAN_ASM		14
#define	LESSOREQ_ASM		15
#define	GREATERTHAN_ASM		16
#define	GREATEROREQ_ASM		17

#define UINT 100
#define ID 101
#define ENDOFLINE 102
#define UNKNOWN 103

/* Global state */
/* String holding input, the current pointer into it, and the current token */
char conditions[MAXLINELEN], *tokenptr, currenttoken[MAXCONDLEN];
int token = -1;

/* Function prototypes */
cond evaluateexpression(void);
cond orexpression(void);
cond andexpression(void);
cond unaryexpression(void);
cond parenthesesexpression(void);
cond atomicexpression(void);
cond createcondition(void);
void destroycondition(cond);
char *createstring(int);
void destroystring(char *);
void gettoken(void);
int issymbolchar(char);

/* CFW - added complex expression warning */
void evalwarn()
{
   warning("cannot parse expression - ignoring", conditions);
}


/*
 *	Comments may be in the input source which contain IFSTRIP Directives:
 *
 *	For C source they should look like:
 *
 *		#if foo>bar !*IFSTRIP=DEF*!		'!' here stands for '/'
 *
 *	and for Assembler source they should look like:
 *
 *		if foo ;;IFSTRIP=UND;;
 *
 *	Note that the directive and an optional preceding blank or tab
 *	are deleted from the input source.  The directive can thus be
 *	followed by a backslash to continue the line, another comment, etc.
 */

static char IfStripCStr[] =
 "/*IFSTRIP="; /* -*IFSTRIP=IGN*- */

static char IfStripAStr[] =
/*0123456789*- -* 0123456789012345 */
 ";;IFSTRIP="; /* ;;IFSTRIP=IGN;; */
	/* IGN may also be DEF or UND */

#define IFSTRIPVALOFF	10
#define IFSTRIPVALEND	13
#define	IFSTRIPVALLEN	15


void evaluate(char *outputstring, int *value, char *inputstring)
{
   int forcevalue = IGNORE;
   cond result;
   strcpy(conditions, inputstring);                /* Prepare the string for tokenising */
   tokenptr = conditions;
   gettoken();                                     /* Read in the first token of input */
   result = evaluateexpression();
   /* check for bad/complex expression */
   if (token != ENDOFLINE)
   {
	  char *adir = NULL;
	  char *cdir = NULL;
	  
	  if(((cdir = strstr(inputstring, IfStripCStr)) && cdir[IFSTRIPVALEND] == '*' && cdir[IFSTRIPVALEND+1] == '/')
	  || ((adir = strstr(inputstring, IfStripAStr)) && adir[IFSTRIPVALEND] == ';' && adir[IFSTRIPVALEND+1] == ';'))
	  {
	  	char *pstr;
		char *ifstr;

		/* fprintf(stderr,"<< evaluate(): (%s)\n", inputstring); */

		pstr = ifstr = ( adir ? adir : cdir ) ;

		/*
		 * Have recognized the /-*-IFSTRIP= directive, interpret its argument
		 * and remove the directive comment from the input/output text.
		 * Back up exactly one white space character (blank or tab) if possible.
		 */

		if(pstr > inputstring && (pstr[-1] == '\t' || pstr[-1] == ' '))
			-- pstr;

		if(!memcmp(ifstr+IFSTRIPVALOFF, "DEF", 3))	/* DEFINED */
			forcevalue = DEFINED;
		else if(!memcmp(ifstr+IFSTRIPVALOFF, "UND", 3))	/* UNDEFINED */
			forcevalue = UNDEFINED;
		else if(memcmp(ifstr+IFSTRIPVALOFF, "IGN", 3))	/* IGNORE */
			warning("cannot recognize IFSTRIP: directive - ignoring", conditions);
		/* else "IGNORE" -- forcevalue is already set by default to IGNORE */

		if(!terseFlag)					
			warning("ifstrip directive forced evaluation", conditions);

		/* remove the directive comment (and preceding blank or tab) from the input line */
		strcpy(pstr, ifstr + IFSTRIPVALLEN);	/* "C" comments have closing -*-/- */

		/* fprintf(stderr,">> evaluate(): (%s)\n", inputstring); */
	  }
	  else
	      evalwarn();

      if (result)
      {
         destroycondition(result);
         result = NULL;
      }
   }
   /* bad/complex expression, return IGNORE and entire expression */
   if (!result)
   {
      *value = forcevalue;
      strcpy(outputstring, inputstring);
      return;
   }
   *value = result -> truth;
   if(!result -> condition)
      * outputstring = '\0';
   else
      strcpy(outputstring, result -> condition);
   /* Convert from internal to external representation */
   destroycondition(result);
}

cond evaluateexpression()
{
   return orexpression();
}

cond orexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = andexpression();
   if (!condition1)
      return NULL;
   while (token == OR)
   {
      gettoken();
      condition2 = andexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:                             /* DEFINED || x == DEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
         case UNDEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* UNDEFINED || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* UNDEFINED || UNDEFINED == UNDEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case IGNORE:                        /* UNDEFINED || IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* IGNORE || UNDEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case IGNORE:                        /* IGNORE || IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" || ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " || ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond andexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = unaryexpression();
   if (!condition1)
      return NULL;
   while (token == AND)
   {
      gettoken();
      condition2 = unaryexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* DEFINED && DEFINED == DEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case UNDEFINED:                     /* DEFINED && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* DEFINED && IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case UNDEFINED:                           /* UNDEFINED && x == UNDEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
        case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE && DEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case UNDEFINED:                     /* IGNORE && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* IGNORE && IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" && ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " && ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond unaryexpression()
{
   cond condition1;
   char *output;
   switch (token)
   {
      case NOT:
         gettoken();
         condition1 = unaryexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition) + 1);
            *output = '!';
            strcpy(output + 1, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         else
            condition1 -> truth = negatecondition(condition1 -> truth);
         break;
      case DEFINEDFN:
         gettoken();
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition)
                                  + (sizeof("defined ") - 1));
            strcpy(output, "defined ");
            strcat(output, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         break;
      default:
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         break;
   }
   return condition1;
}

cond parenthesesexpression()
{
   cond condition1;
   char *output;
   if (token == OPENPARENTHESIS)
   {
      gettoken();
      condition1 = evaluateexpression();
      if (!condition1)
         return NULL;
      if (token != CLOSEPARENTHESIS)
      {
         /* check for bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
      }
      gettoken();
      if ((condition1 -> truth) == IGNORE)
      {
         output = createstring(strlen(condition1 -> condition) + 2);
         *output = '(';
         strcpy(output + 1, condition1 -> condition);
         strcat(output, ")");
         destroystring(condition1 -> condition);
         condition1 -> condition = output;
      }
   }
   else
      condition1 = atomicexpression();
   return condition1;
}

cond atomicexpression()
{
   cond condition1 = createcondition();

   switch (token)
   {
      case UINT:
         if ( progtype == 1)
            condition1 -> truth = DEFINED;
         else
            condition1 -> truth = (atoi(currenttoken) == 0) ? UNDEFINED : DEFINED;
         break;
      case ID:
         condition1 -> truth = lookupsym(currenttoken);
         if ((condition1 -> truth) == NOTPRESENT)
         {
            warning("Switch unlisted - ignoring", currenttoken);
            condition1 -> truth = IGNORE;
         }
         if ((condition1 -> truth) == IGNORE) {
            condition1 -> condition = createstring(strlen(currenttoken));
            strcpy(condition1 -> condition, currenttoken);
         }
         break;
      default:
         /* bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
         break;
   }
   gettoken();
   return condition1;
}

/* Negate condition (MAL) */
__inline int negatecondition(int condvalue)        /* inline for speed */
{
   switch (condvalue)
   {
      case DEFINED:
         return UNDEFINED;
      case UNDEFINED:
         return DEFINED;
      default:
         return condvalue;
   };
}

/* Allocate the memory for an empty condition structure and return a pointer to it */
__inline cond createcondition()
{
   cond retvalue;
   retvalue = (cond) malloc(sizeof(condrec));
   if (retvalue == NULL)
      error("Memory overflow","");
   retvalue -> condition = NULL;
   return retvalue;
}

/* Destroy a condition structure */
__inline void destroycondition(cond condition1)
{
   if (condition1 -> condition)
      free(condition1 -> condition);

   free(condition1);
}

/* Allocate the memory for a string of given length (not including terminator) and return the pointer */
__inline char *createstring(int length)
{
   char *retvalue;
   retvalue = (char *) malloc(length + 1);
   if (retvalue == NULL)
      error("Memory overflow","");
   return retvalue;
}

/* Destroy a string */
__inline void destroystring(char *string)
{
   free(string);
}

int iscomment(char *tokenptr)
{
   int cindex;

   for (cindex = 0; cindex < maxcomment; cindex++)
   {
      if (commlen[cindex] &&
		  !_strnicmp(tokenptr, comments[cindex], commlen[cindex]))
         return TRUE;
   }
   return FALSE;
}

void gettoken()
{
   int numofwhitespace, comparetoken = 0, found = FALSE, isnumber = TRUE;
   char *digitcheck;

   numofwhitespace = strspn(tokenptr, " \t");

   /* CFW - skips comments, assumes comment is last thing on line */
   if (numofwhitespace == (int) strlen(tokenptr))
      token = ENDOFLINE;
   else
   {
      tokenptr += numofwhitespace;
      if (iscomment(tokenptr))
	  {
         token = ENDOFLINE;
	  }
      else
      {

         do
         {
	    if (!_strnicmp(tokenptr, operators[comparetoken], oplengths[comparetoken]))
               found = TRUE;
            else
               comparetoken++;
         } while ( (!found) && (comparetoken < numoperators) );
         if (found)
         {
            tokenptr += oplengths[comparetoken];
            token = comparetoken;
            /* currenttoken is left blank for all but UINTs and IDs */
         }
         else
         {
            digitcheck = tokenptr;
            if (!nonumbers && isdigit(*digitcheck))
            {
               while (isdigit(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               tokenptr = digitcheck;
               token = UINT;
            }
            else if (issymbolchar(*digitcheck))
            {
               while (issymbolchar(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               *(currenttoken + (digitcheck - tokenptr)) = '\0';
               tokenptr = digitcheck;
               token = ID;
            }
            else
               token = UNKNOWN;
         }
      }
   }
}

__inline int issymbolchar(char c)
{
   return (iscsym(c) || (c == '$') || (c == '?') || (c == '@'));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\include\DataPacket.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _DATAPACKET_H_
#define _DATAPACKET_H_

#include <windows.h>

CONST INT PACKET_DATA_SIZE = 300;
CONST INT PACKET_MSG_SIZE = 200;

// Command Constants.
CONST DWORD DO_WRITEPERBOXDATA			= 1; // write generated eeprom data
CONST DWORD DO_VERIFYPERBOXDATA			= 2; // set hard drive password and clear mfg region
CONST DWORD DO_LOCK_HARDDRIVE			= 3; // set hard drive password, don't clear mfg region
CONST DWORD ERROR_FATAL					= 4;	
CONST DWORD ERROR_WARN					= 5;	


typedef struct 
_DATA_PACKET
{
         
   CHAR  szMessage[PACKET_MSG_SIZE];
   DWORD dwCommand;
   BYTE  byteData[PACKET_DATA_SIZE];
   ULONG ulDataSize;
   BOOL  bDevKit;
   DWORD dwStatus;
} DATA_PACKET, *PDATA_PACKET;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\symtab.c ===
/***
*symtab.c - Ifdef symbol table storage module
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Store the symbols from the switches file.
*
*Revision History:
*	??-??-88   PHG	Initial version
*
*******************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <ctype.h>
#include "constant.h"
#include "errormes.h"
#include "symtab.h"

/* Internal constants */
#define MAXSYMBOLS    512	/* Maximum number of symbols (switches) */
#define IDENT_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_$?"

/* Symbol record */
struct symrec {
	char *name;		/* name of the symbol */
	int type;		/* type of symbol (DEFINED, UNDEFINED, IGNORE)*/
};

/* Internal variables */
int numsyms;			/* Number of symbols */
struct symrec symtable[MAXSYMBOLS];
				/* Symbol table */
/* Procedures */
int compsym(const struct symrec *, const struct symrec *);

/* Compare two records for alphabetical order */
int compsym(rec1, rec2)
const struct symrec *rec1, *rec2;
{
	return strcmp(rec1->name, rec2->name);
}

/* Add symbol to symbol table */
void addsym(symbol, type)
char *symbol;
int type;
{
	if (lookupsym(symbol) != NOTPRESENT) {
		fprintf(stderr, "fatal error: symbol \"%s\" already in symbol table.\n", symbol);
		exit(1);
	}
	symtable[numsyms].name = _strdup(symbol);
	symtable[numsyms].type = type;
	++numsyms;
}

/* Read switches from a file into symbol table */
void readsyms(filename)
char *filename;
{
	FILE *f;
	char name[MAXNAMELEN];
	f = fopen(filename, "r");
	if (f == NULL) {
		fprintf(stderr, "fatal error: cannot open switch file \"%s\".\n", filename);
		exit(1);
	}
	numsyms = 0;

	do {
		if ( fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, DEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, UNDEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL)
			break;
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, IGNORE);
		}
	} while (name[0] != '-');

	fclose(f);
}

/* Lookup symbol in symbol table */
int lookupsym(name)
char *name;
{
	struct symrec srchrec;
	struct symrec *recfound;

	srchrec.name = name;
	recfound = (struct symrec *) _lfind( (const void *)&srchrec, (const void *)symtable,
		&numsyms, sizeof(struct symrec), compsym);
	if (recfound == NULL)
		return NOTPRESENT;
	else
		return recfound->type;
}

/* Check if token is identifier only (must have no whitespace) */
int ident_only(token)
char *token;
{
	/* is an identifier if all characters are in IDENT_CHARS
	   and first character is not a digit */
	return (strspn(token, IDENT_CHARS) == strlen(token) &&
			!isdigit(token[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\ifstrip\ifstrip.c ===
/***
*ifstrip.c - Ifdef stripping tool
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Strip in/out conditional code from sources.
*	Refer to ifstrip.doc for more information.
*
*Revision History:
*	??-??-88  PHG	Initial version
*	05-10-90  JCR	Accept .cxx/.hxx files, misc cleanup, etc.
*	09-18-92  MAL	Rewritten to cope with nested IFs, ELIFs etc.
*	09-30-92  MAL	Added support for IF expressions, modularized code
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add terseflag (-t) to suppress mesgs about directives
*	10-05-94  SKS	Fix bug: Add missing space to keyword "ifndef "
*	01-04-99  GB    Added support for internal CRT builds.
*
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <search.h>
#include <direct.h>
#include <io.h>
#include <errno.h>
#include <fcntl.h>
#include "constant.h"                              /* Program constants used by modules */
#include "errormes.h"                              /* Error and warning reporting */
#include "symtab.h"                                /* Symbol table handling */
#include "eval.h"                                  /* If expression evaluation */

/* Global constants */
/* CFW - added ifdef, ifndef asm keywords, added IFE, added IFDIF */
char *syntaxstrings[2][maxkeyword + 1] =
       { {"#if ", "#elif ", "#else ", "#endif ", "#ifdef ", "#ifndef ", "",     "",     "",     "",      "",       "",        "" },
          {"if ",  "",       "else ",  "endif ",  "ifdef ",  "ifndef ",   "if1 ", "if2 ", "ifb ", "ifnb ", "ifidn ", "ifdif ", "ife " } };
       /* Language dependent if constructs, must be in the order c, asm and the keywords in the
          same order as the tokens stored in constant.h - All strings must be followed by a
          space, and those not available in a language should be empty */
int syntaxlengths[2][maxkeyword + 1] = { {3, 5, 5, 6, 6, 7, 0, 0, 0, 0, 0, 0, 0},
                                         {2, 0, 4, 5, 5, 6, 3, 3, 3, 4, 5, 5, 3} };
       /* The lengths of the above strings minus spaces. Unused keywords marked with 0 */

/* CFW - added comment stuff */
char *commentstrings[2][maxcomment] = { {"/* ", "// "}, {"; ",  ""} };      
int commentlengths[2][maxcomment] =   { {2,     2    }, {1,     0} };
      /* must ignore comments in IF statements */

/* Global variables */
int terseFlag = FALSE;			/* TRUE means do not echo forced directives */
int warnings = TRUE;          /* TRUE == print warnings */
int currdir = FALSE;		      /* Put in current dir, use source extension */
int isasm;			            /* TRUE == is assembler file */
char **syntax;   		         /* Language dependent syntax for output / matching */
int *synlen;			         /* Lengths of above strings */
char **comments;		         /* Language dependent comment strings */
int *commlen;                 /* Lengths of above strings */
char extension[5] = ".new";	/* Extension for output file */
FILE *outfile;			         /* Current output file */
char *curr_file;		         /* Name of current input file */
FILE *infile;			         /* Current input file */
FILE *errorfile;			      /* file to output error/warning messages */
int linenum;			         /* Line number of current input file */
int nonumbers;			    	 /* allow numeric expressions */
enum {NOCOMMENT, CSTYLE, CPPSTYLE} commstyle = NOCOMMENT;  /* type of comment to put after #else/#endif */
enum {NON_CRT = 0, CRT=1} progtype = NON_CRT;
char _inputline[MAXLINELEN];

/* Functions */
void setfiletype(char *);
void makenewname(char *, char *);
void usage(void);
void stripprog(void);
void putstring(char *);
void putline(char *);
char *getstring(char *, int, FILE *);
char *cleanse(char *inputstring);
void stripifdef(int, char *);
void definedif(void);
void undefinedif(void);
void undefinedifsubpart(int, char *);
void ignoredif(int, char *);
void ignoredifsubpart(int, char *, char *);
void skipto(int *, char *, int);
void copyto(int *, char *, int);
char *parseline(char *, int *);
void stripif(int, char *);

/* Print message and terminate */
void error(reason, line)
char *reason;
char *line;
{
	fprintf(errorfile, "%s(%d): %s\nfatal error: %s\n\n",
	curr_file, linenum, line, reason);
	exit(1);
}

/* Print message and return */
void warning(reason, line)
char *reason;
char *line;
{
	if (warnings)
		fprintf(errorfile, "%s(%d): %s\nwarning: %s\n\n", curr_file, linenum, line, reason);
}

/* Get a string from the input file, returns as fgets (MAL) */
char *getstring(char *line, int n, FILE *fp)
{
   char *returnvalue;
   int linelength;
   linenum++;
   returnvalue = fgets(line, n, fp);
   if (returnvalue != NULL)
   {
      linelength = strlen(line);
      if (line[linelength-1] == '\n')
         line[linelength-1] = '\0';                /* Strip trailing newline */
      else
         error("Line too long",line);
   }
   strcpy(_inputline, line);
   return returnvalue;
}

/* Put a string to the output file (MAL) */
void putstring(char *string)
{
   if ( fputs(string, outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put a line to the output file (MAL) */
void putline(char *line)
{
   putstring(line);
   if ( fputc('\n', outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put commented line like "#endif //CONDITION" based on comstytle flag
 * keyword = keyword to put
 * condition = condition to put
 */
void putcommentedline(int keyword, char *condition)
{
   if (progtype == CRT) {
       putline(_inputline);
       return;
   }
   putstring(syntax[keyword]);
   switch (commstyle) {
   case CSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" /* ");
     putstring(condition);
	 if (isasm)
	   putline("");
	 else
       putline(" */");
     break;
   case CPPSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" // ");
     putline(condition);
     break;
   case NOCOMMENT:
     putline("");
   }
}

/* Set file type (assembler or C, treat C++ as C) */
/* Language strings added (MAL) */
void setfiletype(filename)
char *filename;
{
	char *p;

	p = strrchr(filename, '.');
	if (p == NULL)
		error("file must have an extension", "");
	if ( (_stricmp(p, ".c")   == 0) || (_stricmp(p, ".h")	== 0) ||
	     (_stricmp(p, ".cpp") == 0) || (_stricmp(p, ".hpp") == 0) ||
	     (_stricmp(p, ".cxx") == 0) || (_stricmp(p, ".hxx") == 0) ||
         (_stricmp(p, ".s") == 0) )
		isasm = FALSE;
	else if  ( (_stricmp(p, ".asm") == 0) || (_stricmp(p, ".inc") == 0) )
		isasm = TRUE;
	else
		error("cannot determine file type", "");
	syntax = syntaxstrings[(isasm) ? 1 : 0];     /* Choose correct set of syntax strings */
	synlen = syntaxlengths[(isasm) ? 1 : 0];     /* and lengths */
   comments = commentstrings[(isasm) ? 1 : 0];  /* Choose correct comment set */
   commlen = commentlengths[(isasm) ? 1 : 0];   /* and lengths */
}

/* Make output file name */
void makenewname(filename, newname)
char *filename, *newname;
{
	char *p;

	if (!currdir) {
		/* put on new extension */
		strcpy(newname, filename);
		p = strrchr(newname, '.');
		if (p == NULL)
			error("file must have an extension", "");
		strcpy(p, extension);
	}
	else {
		/* strip off directory specifier */
		p = strrchr(filename, '\\');
		if (p == NULL)
			error("file must not be in current directory", "");
		strcpy(newname, p+1);
	}
}

/* Strip the ifs within a program or block of program text (MAL) */
void stripprog()
{
   char inputline[MAXLINELEN], *condition;
   int linetype;
   while ( getstring(inputline, MAXLINELEN, infile) != NULL )
   {
      condition = parseline(inputline, &linetype); /* Get the line token and condition pointer */
      switch (linetype)
      {
      case NORMAL:
         putline(inputline);
         break;
      case IFDEF:
      case IFNDEF:
         stripifdef(linetype, condition);
         break;
      case IF:
      case IFE:
         stripif(linetype, condition);
         break;
      case IF1:
      case IF2:
      case IFB:
      case IFNB:
      case IFIDN:
         /* CFW - ignore special assembler directives */
         ignoredif(linetype, condition);
         break;
      default:
         error("Error in program structure - ELSE / ELIF / ENDIF before IF","");
      }
   }
}

// CFW - cleanse condition strings of any trailing junk such as comments
char *cleanse(char *inputstring)
{
	char *linepointer = inputstring;

	while (__iscsym(*linepointer))
      linepointer++;

	*linepointer = '\0';

	return inputstring;
}


/* Strip an if depending on the statement if(n)def and the value of its condition (MAL) */
void stripifdef(int iftype, char *condition)
{
   int condvalue;
   condvalue = lookupsym(cleanse(condition)); /* Find the value of the condition from the symbol table */
   if (iftype == IFNDEF)
      condvalue = negatecondition(condvalue); /* Negate the condition for IFNDEFs */
   switch (condvalue)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif(); /* CFW - changed definedif to undefinedif call */
         break;
      case NOTPRESENT:
         warning("Switch unlisted - ignoring", condition);
         /* Drop through to IGNORE case */
      case IGNORE:
         ignoredif(iftype, condition);
   }
}

void stripif(int linetype, char *condition)
{
   char newcondition[MAXLINELEN];                  /* IGNORE conditions can be MAXLINELEN long */
   int truth;
   evaluate(newcondition, &truth, condition);      /* Get the truth value and new condition. */
   /* CFW - added IFE */
   if (linetype == IFE)
      truth = negatecondition(truth);
   switch (truth)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif();
         break;
      case IGNORE:
         ignoredif(linetype, newcondition);
         break;
   }
}

/* Strip a defined if (MAL) */
void definedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   copyto(&keyword, condition, KEYWORD);           /* Copy up to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)
      skipto(&keyword, condition, ENDIF);          /* Skip forward to the ENDIF if not there already */
}

/* Strip an undefined if (MAL) */
void undefinedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   skipto(&keyword, condition, KEYWORD);           /* Skip to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)                           /* No need to recurse if at ENDIF */
      undefinedifsubpart(keyword, condition);      /* Deal with the ELSE / ELIF */
}

/* Deal with the subparts of an undefined if (MAL) */
void undefinedifsubpart(int keyword, char *condition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXCONDLEN];
   char nextcondition[MAXCONDLEN];
   switch (keyword)
   {
      case ELIF:
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               break;
            case UNDEFINED:
               skipto(&nextkeyword, nextcondition, KEYWORD);
               if (keyword != ENDIF)               /* No need to recurse at ENDIF */
                  undefinedifsubpart(nextkeyword, nextcondition);
               break;
            case IGNORE:
               stripifdef(IFDEF, newcondition);
         }
         break;
      case ELSE:
         copyto(&nextkeyword, nextcondition, ENDIF);
   }
}

/* Strip an ignored if (MAL) */
void ignoredif(int linetype, char *condition)
{
   char *controlcondition;
   int nextkeyword;
   char nextcondition[MAXLINELEN];                 /* IGNORE conditions may be a line long */
   if ( progtype == CRT){
       putline(_inputline);
   } else {
       putstring(syntax[linetype]);                          /* Use IF to cope with any expression */
       putline(condition);
   }
   controlcondition = _strdup(condition);
   copyto(&nextkeyword, nextcondition, KEYWORD);
   ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
   free(controlcondition);
}

/* Deal with the subparts of an ignored if (MAL) */
/* See design document for explanation of actions! */
/* controlcondition is controlling condition of the if */
void ignoredifsubpart(int keyword, char *condition, char *controlcondition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXLINELEN];   /* IGNORE conditions may be a line long */
   char nextcondition[MAXLINELEN];  /* IGNORE conditions may be a line long */
   switch (keyword)
   {
      case ELIF:
         /* CFW - replaced lookupsym with evaluate */
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               putcommentedline(ELSE, controlcondition);              /* ELSIF DEFINED == ELSE */
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               if (progtype == CRT)
                  putline(_inputline);
               else
                  putline(syntax[ENDIF]);
               break;
            case UNDEFINED:                        /* ELSIF UNDEFINED skipped */
               skipto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
               break;
            case IGNORE:
               if ( progtype == CRT)
                  putline(_inputline);
               else {
                  putstring(syntax[ELIF]);            /* ELSIF IGNORED copied like IF */
                  putline(newcondition);
               }
			   controlcondition = _strdup(newcondition);  // new controlling condition.
               copyto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
			   free(controlcondition);
         }
         break;
      case ELSE:
         putcommentedline(ELSE, controlcondition);
         copyto(&nextkeyword, nextcondition, ENDIF);
         putcommentedline(ENDIF, controlcondition);
         break;
      case ENDIF:
         putcommentedline(ENDIF, controlcondition);
   }
}

/* Skip to the target keyword. Returns the keyword found and any condition following it. (MAL) */
void skipto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, ifdepth = 0, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               break;                              /* Ignore a normal line */
            case IFDEF:
            case IFNDEF:
            case IF:
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
            case IFE:
               ifdepth++;
               break;                              /* Register nested if, do not need to test for stripping */
        		case ENDIF:
               if (ifdepth > 0)
               {
                  ifdepth--;                       /* Back up a level if in a nested if */
                  break;
               }
               /* Else drop through to default case */
            default:
               if ( (ifdepth == 0) && ((linetype == target) || (target == KEYWORD)) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return keyword token */
   strcpy(condition, conditioninline);
}

/* Copy to the target keyword. Returns the keyword found and any condition following it.
   Any if statements inside the area being copied are stripped as usual. (MAL) */
void copyto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               putline(currline);                  /* Copy a normal line */
               break;
            case IFDEF:
            case IFNDEF:
               stripifdef(linetype, conditioninline);    /* Strip a nested if(n)def */
               break;
            case IF:
            case IFE:
               stripif(linetype, conditioninline);
               break;
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
               /* CFW - ignore special assembler directives */
               ignoredif(linetype, conditioninline);
               break;
            default:
               if ( (linetype == target) || (target == KEYWORD) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return line token */
   strcpy(condition, conditioninline);
}

/* Parse a line of text returning a condition pointer into the line and placing a line type in
   the integer location supplied (MAL) */
char *parseline(char *inputline, int *linetype)
{
   int numofwhitespace, comparetoken = 0, found = FALSE;
   char *linepointer = inputline;
   numofwhitespace = strspn(inputline, " \t");
   if (*(numofwhitespace + inputline) == '\0')
   {
      *linetype = NORMAL;                          /* Empty line */
      return NULL;
   }
   linepointer += numofwhitespace;
   do
   {
      if (synlen[comparetoken] != 0)
         {
	 if ( (!_strnicmp(linepointer, syntax[comparetoken], (size_t) synlen[comparetoken])) &&
              ( isspace( *(linepointer + synlen[comparetoken]) ) || !*(linepointer + synlen[comparetoken]) ) )
            found = TRUE;
         else
            comparetoken++;
         }
      else
         comparetoken++;
   } while ( (!found) && (comparetoken <= maxkeyword) );
   if (found)
   {
      linepointer += synlen[comparetoken];
      if (*linepointer)
         linepointer += strspn(linepointer, " \t");
      *linetype = comparetoken;
      return linepointer;
   }
   else
   {
      *linetype = NORMAL;
      return NULL;
   }
}

/* Print program usage and quit */
void usage()
{
	fprintf(stderr, "Usage: ifstrip [-n] [-w] [-x[ext]] [-f switchfile] file ...\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    -n  produce no output files\n");
	fprintf(stderr, "    -w  suppresses warning levels\n");
	fprintf(stderr, "    -f  next argument is the switch file\n");
	fprintf(stderr, "    -e  next argument is the error/warning file\n");
	fprintf(stderr, "    -c  comment retained else/endifs with switch condition\n");
	fprintf(stderr, "    -C  save as -C, but C++ style (//) comments\n");
	fprintf(stderr, "    -z  treat numbers (e.g., #if 0) like identifiers\n");
	fprintf(stderr, "    -x  specify extension to use on output files\n");
	fprintf(stderr, "        none means use source extension but put in\n");
	fprintf(stderr, "        current directory (source must be in other dir)\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    file list may contain wild cards\n");
	exit(1);
}



int exclude(struct _finddata_t f_data)
{
    if ( f_data.attrib & _A_SUBDIR )
    {
        printf("%s is a directory\n", f_data.name);
        return 1;
    }
    return 0;
}



void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/* Main program - parse command line, process each file */
void main(argc, argv)
int argc;
char *argv[];
{
	char *errorfilename;
	char *switchfilename = "switches";
	char outfilename[MAXFILENAMELEN];
    int ferrorfile = FALSE;
	int nooutput = FALSE;
	struct _finddata_t f_data;
	long h_find;
    char base_dir[256], curr_dir[256];
    int i;

	for (i = 1; i < argc; ++i) {
		if (argv[i][0] != '-')
			break;
		switch (argv[i][1]) {
		case 'w':
			warnings = FALSE;
			break;
		case 'f':
			++i;
			switchfilename = argv[i];
			break;
		case 't':
			++ terseFlag;
			break;
		case 'z':
		    nonumbers = TRUE;
			break;

      case 'e':
         ++i;
         errorfilename = argv[i];
         ferrorfile = TRUE;
         break;
		case 'x':
			if (argv[i][2] == '\0')
				currdir = TRUE;
			else if (argv[i][2] == '.')
				strncpy(extension, argv[i]+2, 4);
                                /* period was supplied */
			else
				strncpy(extension+1, argv[i]+2, 3);
                                /* period not supplied */
			break;
		case 'n':
			nooutput = TRUE;
			break;
        case 'c':
            commstyle = CSTYLE;
            break;
        case 'C':
            commstyle = CPPSTYLE;
            break;
        case 'a':
            progtype = CRT;
            break;
		default:
			fprintf(errorfile, "unknown switch \"%s\"\n", argv[i]);
			usage();
		}
	}

	if (i >= argc)
		usage();

   if (ferrorfile)
   {
      errorfile = fopen(errorfilename, "a");
      if (errorfile == NULL)
      {
         fprintf(stderr, "cannot open \"%s\" for error, using stderr\n",
                           errorfilename);
         ferrorfile = FALSE;
         errorfile = stderr;
      }
   }
   else
      errorfile = stderr;

	readsyms(switchfilename);

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
	for ( ; i < argc; ++i) {
        gdir(curr_dir, argv[i]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[i], &f_data)) == -1)
			continue;
        do
		{
			if ( exclude(f_data) != 1)
			{
                curr_file = f_data.name;
                linenum = 0;
                setfiletype(curr_file);
                if (nooutput)
                    strcpy(outfilename, "nul");
                else
                    makenewname(curr_file, outfilename);
                infile = fopen(curr_file, "r");
                if (infile == NULL) {
                    printf("%s which is %s is somewhat wrong, and the length is %d\n",f_data.name, strerror(errno),  strlen(f_data.name));
                    error("cannot open file for input", "");
                }
                outfile = fopen(outfilename, "w");
                if (outfile == NULL) {
                    fprintf(stderr, "cannot open \"%s\" for output\n",
                        outfilename);
                    exit(1);
                }
                stripprog();
                fclose(infile);
                fclose(outfile);
            }
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
   if (ferrorfile)
   	fclose(errorfile);

   exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\libw32\tools\source\striphdr\striphdr.c ===
/***************************************************************************
*striphdr.c -  Program to read source files and produce alphabetised
*                    listing of header blocks, telling which files they came
*                    from.
*
*	Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Author:         Tom Corbett, Brian Lewis - Microsoft Corp.
*
*Usage: striphdr [switches] file {file ...}
*  Accepts native code or C source; determines source
*     type based on filename suffix.
*  Wildcards may be used in the file names.
*
*  switches:
*
*  -m        process module headers only
*  -b        process both procedure and module headers
*            [default is procedure headers only]
*  -l        process only first line of each header
*  -n        process none of header (i.e. lists only function name)
*  -s <name> process named section only (may be used with -l)
*            [default is to process whole header]
*  -d        delete processed section from input file
*  -q        quiet, do not print headers (useful only with -d)
*  -x <ext>  gives extension for output file when -d used
*            [default: .new]
*  -r        remove revision histories from file headers
*              (equivalent to -m -d -q -s "Revision History")
*
*Purpose:
*   Given a list of Native code and/or C sources, strip out routine or module
*   headers and produce an alphabetised listing of the headers, telling where
*   (filename) each header came from. Optionally, delete part or all of the
*   headers from the source file.
*
*   For each file on the command line (wildcards may be used), striphdr reads
*   the file, and records information from the file and/or procedure headers.
*   This information is then sorted by procedure name/file name, and printed
*   to stdout, with an indication of which file each procedure is from.  If
*   the -d flag is activated, the information is also deleted from the input
*   file and the new file placed in a file with the same name but the
*   extension .new (this extension can be changed with the -x switch).  The
*   actual input file is also left as is. When using the -d switch, -q will
*   eliminate the output, so that only the deleting action takes place.  By
*   default only the procedure headers are scanned, the -m and -b switches
*   change this.  By default all the information in a header is printed or
*   deleted, the -l, -n, and -s switches change this.  The -r switch is an
*   abbreviation which will remove revision histories from the file headers.
*
*   Input filenames with suffixes of .c or .h are assumed to contain C source,
*   and suffixes of .asm or .inc imply native code source. Routine or module
*   names must be on the first or second line following the start of header;
*   if on the second line then the first line must contain only whitespace
*   after an optional '*' (if C source) or ';' (if native code source).
*   Routine names can contain a return type and parameters; multiple entry
*   point should be seperated by commas.  Header start and end symbols must
*   start in the left-most column. Module headers and routine headers are
*   marked in the same manner; position relative to the beginning of file is
*   used to determine which header type is appropriate.
*
*   Source is detabbed (1 tab assumed to equal 4 spaces in C, 8 spaces in native
*   code) and routine names are parsed to ensure that the correct name is
*   grabbed for sorting.
*
*   C Headers are started with a '/' characters in the first column followed
*   by at least 3 '*' characters, and are ended with at least 4 '*' characters
*   followed by a '/'. Each line within a header must begin with a '*', except
*   lines beginning with '#if', '#else', or '#endif'. Module headers must be
*   preceded with nothing except (perhaps) blank lines; if any non-blank lines
*   are found prior to the first header in a module, it is assumed that the
*   header belongs to a routine, otherwise, to the entire module.
*
*   Native code headers are started by a ';' followed by at least 3 '*'
*   characters, and the header  end is denoted by a ';' followed by at least
*   4 '*' characters. There must be a ';' character in the left-most column of
*   every line of the header block; the only exception to this is that the '
*   if', 'else', and 'endif' switches are allowed inside header blocks. Module
*   headers can be preceded with any number of blank lines, a TITLE statement,
*   a NAME statement, and/or a PAGE statement; if anything else is
*   encountered, subsequent headers will be assumed to be routine headers.
*
*   Sections within a header must have a title beginning on the 2nd
*   character of the line, and the section is assumed to extend to the next
*   line with a non-blank character in position 2.
*
*   No non-header comments should begin in column 1 with '/***' in C or
*   ';***' in native code; this will confuse striphdr.
*
*
*Revision History:
*
*   01-01-83  TOMC Created [tomc]
*   09-09-85  BL   Modified to allow the option of stripping module headers
*                  instead of routine headers via the -m switch
*   09-30-85  BL   Modified to accept either C Source or native code source.
*                  Modified to detab C Source assuming 3 spaces per tab.
*                  Modified to parse C Routine names properly, allowing
*                  types, macros, etc. to precede routine names.
*                  Modified to make the sorting be case insensitive.
*   11-12-85  BL   Fixed bug that caused 1st char to always be removed from
*                  headers, and that caused problems when a blank line follows
*                  header starts.
*   06-01-87  PHG  fixed GetNonBlank()
*                  allowed 'title' and 'Title" as well as 'TITLE'
*                  allowed NAME, PAGE as well as TITLE
*                  made tab expansion for both ASM and C files
*                  both C and ASM procedure names can have args,
*                  multiple entries
*                  simplified some code and a few minor bug fixes
*                  added -b, -n, -s, -d, -q, -x, -r switches
*   05-10-90  JCR  Accept .cxx/.hxx files (C++ support), misc cleanup
*   04-06-95  SKS  Accept .cpp/.hpp as equivalent to .cxx/.hxx, respectively
***************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <direct.h>


#define TRUE 1
#define FALSE 0
#define NAMBUFSZ 20000      /* size of buffer for holding all procedure names */
#define LINEBUFSZ 250       /* maximum size of 1 physical line */
#define MAXENT 3000         /* maximum number of procedure entry points */
#define MAXFUNCS 2000       /* maximum number of function headers */

/* abort codes */
#define NMBUFOV 0           /* name buffer table overflow */
#define FILENF 1            /* file not found */
#define FUNCSOV 2           /* function table overflow */
#define ENTOV 3             /* entry table overflow */
#define FILENO 4            /* cannot open file */
#define OUTSPACE 5          /* out of disk space */

/* tab sizes, pagelength */
#define TABSIZE_C 4
#define TABSIZE_ASM 8       /* tab sizes for code */
#define PAGELEN 60	    /* pagelength for page breaks; 60 for HP LaserJet */

struct {
	char *entname;          /* name of entry point */
	int funcid;             /* function index for this entry point */
	char printed;           /* flag to ensure each entry printed just once */
} 
entry [MAXENT];
int nentries;               /* number of entries parsed so far */

struct {
	char *filename;         /* name of file which contains this function */
	long filepos;           /* seek position on file "temp" */
	int nlines;             /* number of lines in function header */
} 
func [MAXFUNCS];
int nfuncs;                 /* number of function parsed so far */

long ofpos;                 /* output file seek position */
char linebuf[LINEBUFSZ];
char nambuf[NAMBUFSZ];      /* buffer for holding function names */
int nambufi;                /* next free byte in nambuf */
char fEof;
FILE *ofd;                  /* output file descriptor */
FILE *ifd;                  /* input file descriptor */
FILE *cfd;                  /* copy file descriptor */
FILE *fopen();
int outline;                /* output line number (1..PAGELEN) for page ejects */
int fDelete = FALSE;        /* TRUE if copy and delete instead of display */
int fGetModNams = FALSE;    /* TRUE if strip module names */
int fGetProcNams = TRUE;    /* TRUE if strip procedure names */
int fC_Source;              /* TRUE if we're processing C source, false if .asm */
int fDoAll = TRUE;          /* TRUE if we process all of header */
int fDoFirst = FALSE;       /* TRUE if we process first line of header */
int fDoSection = FALSE;     /* TRUE if we process named section of header */
int fQuiet = FALSE;         /* TRUE is quiet mode */
char SectionHead[80];       /* Section name */
char CopyExt[4] = "new";    /* extension of new files */
char *szFilenameCur;        /* name of file being read (for error reporting) */



/*** 
*MyAbort(code, s) - abort program with message
*Purpose:
*   abort the program with correct message.
*
*Entry:
*   code = error code
*   s = filename for code == FILENF
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void MyAbort(code, s)
int code;
char *s;
{
	fprintf(stderr, "Fatal Error - ");
	if (code == NMBUFOV)
		fprintf(stderr, "NAME Buffer overflow\n");
	if (code == FILENF)
		fprintf(stderr, "File not found: %s\n", s);
	if (code == FUNCSOV)
		fprintf(stderr, "Function table overflow\n");
	if (code == ENTOV)
		fprintf(stderr, "Entry table overflow\n");
	if (code == FILENO)
		fprintf(stderr, "Cannot open file: %s\n", s);
	if (code == OUTSPACE)
		fprintf(stderr, "Out of disk space\n", s);

	exit(code);
} /* MyAbort */


/***
*FindIfC(szFile) - find if filename if C or ASM
*
*Purpose:
*   Set global flag fC_Source to TRUE if the filename ends in
*   .c, .h, .cxx (.cpp), or .hxx (.hpp); FALSE if it ends in .asm or .inc.
*   The extension comparison is NOT case senstive.  If none of
*   these are found, don't set the flag,and return FALSE,
*   else return TRUE.
*
*Exit:
*   sets flag fC_Source
*   returns FALSE if neither C nor ASM source
*   returns TRUE if fC_Source set
********************************************************************/

FindIfC(szFile)
char *szFile;
{
	int cbFileName = strlen(szFile);
	char *pbPastName = szFile + cbFileName; /* points at NULL at string end */

	if ((!_stricmp (".c", pbPastName - 2)) ||
	    (!_stricmp (".h", pbPastName - 2)) ||
	    (!_stricmp (".s", pbPastName - 2)) ||
	    (!_stricmp (".cpp", pbPastName - 4)) ||
	    (!_stricmp (".hpp", pbPastName - 4)) ||
	    (!_stricmp (".cxx", pbPastName - 4)) ||
	    (!_stricmp (".hxx", pbPastName - 4)))
		fC_Source = TRUE;       /* file is assumed to be C source */

	else if ((!_stricmp (".asm", pbPastName - 4)) ||
	    (!_stricmp (".inc", pbPastName - 4)))
		fC_Source = FALSE;      /* file is assumed to be Native Code source */

	else return (FALSE);        /* didn't find an appropriate suffix */

	return (TRUE);

} /* FindIfC */


/***
*MakeCopyfileName(filename, copyname) - make copyfile name from input name
*
*Purpose:
*   Put the copy file suffix onto a file name
*
*Entry:
*   filename = input file name
*
*Exit:
*   copyname = filled in with copy file name
*
*Exceptions:
*
*******************************************************************************/

void MakeCopyfileName(filename, copyname)
char *filename, *copyname;
{
	char *p;

	strcpy(copyname, filename);
	p = copyname + strlen(copyname);
	while (*(--p) != '.')
		;                            /* p points to '.' */
	*(p+1) = '\0';                  /* cut off string after '.' */
	strcat(copyname, CopyExt);      /* put on copy file extension */
}



/***
*linelen(pLine)
*
*Purpose:
*       Return the number of characters in a passed line. The line terminator
*       ('\n') is not included in the count.
*
*Entry:
*       pLine = a pointer to the first char in the line.
*Exit:
*       returns the number of characters in the line (an int).
***************************************************************************/

int linelen(pLine)
char *pLine;
{
	register int index;

	for (index = 0; *(pLine + index) != '\n'; index++);
	return (index);
}



static int cLinesRead;
static char fInHeader = FALSE;

/***
*ReadLine(copyit) - read line and analyze it
*
*Purpose:
*   read 1 line from input file into 'linebuf'.
*   if copyit == TRUE, copy previous line to copy file
*
*Entry:
*   copyit = TRUE means copy the line to the copy file
*
*Exit:
*   returns     -1 for EOF,
*                   0 for vanilla lines,
*               if C Source,
*                   1 for lines which begin "/***"  (start of header)
*                   2 for lines which begin "/****" (end of header)
*               if Native Code Source,
*                   1 for lines which begin ";***"  (start of header)
*                   2 for lines which begin ";****" (end of header)
*
***************************************************************************/

int ReadLine(copyit)
int copyit;             /* TRUE = copy line to copy file */
{
	register int i;
	register int cbLine;

	if (copyit) {
		if (fputs(linebuf, cfd) == EOF)
			MyAbort(OUTSPACE);
	}                   /* copy previous line if requested */

	if ((fgets(linebuf, LINEBUFSZ, ifd)) == NULL) {
		fEof = TRUE;
		return(-1);
	}

	cLinesRead++;
	cbLine = linelen(linebuf);

	if ((linebuf[0] == ';') && (!fC_Source)) {  /* native code comment */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			/* know we have either start or end of a header */
			if (fInHeader) {
				fInHeader = FALSE;
				if (linebuf[4] == '*')
					return (2);             /* valid end of header */
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {      /* have a valid start of header */
				fInHeader = TRUE;
				return (1);
			}
	}

	else if ((linebuf[0] == '/') && (fC_Source)) {  /* C code comment? */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			if (fInHeader) {
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {
				fInHeader = TRUE;
				return (1);             /* valid start of header */
			}
	}

	else if ((linebuf[0] == '*') && (fC_Source)) {  /* C code comment? */
		for (i = 1; (i < cbLine) && (linebuf[i] == '*'); i++);

		if ((linebuf[i] == '/') && (i > 3)) {   /* have a valid end of header */
			if (fInHeader) {
				fInHeader = FALSE;
				return (2);
			}
			/* got a header terminator when we weren't within a header */
			fprintf(stderr, "Illegal termination to header for function: %s",
			entry[nentries].entname);
			fprintf(stderr, "  in line %d of file %s\n",
			cLinesRead, szFilenameCur);
		} /* if */
	}   /* else if */

	return(0); /* vanilla line */
} /* ReadLine */


/***
*WriteLine(pb, of) - write a line and expand tabs
*
*Purpose:
*   Write a zero terminated string to file 'of'.
*   If we're writing C Source header lines, detab them as we go.
*
*Entry:
*   pb = points to 1st byte of 0-terminated string.
*   of = aft index for destination file.
*
*Exit:
*   'ofpos' is bumped to reflect current output file position.
*
***************************************************************************/

void WriteLine(pb, of)
register char *pb;
FILE *of;
{
	register int linepos = 0;   /* column position on output line */
	int modTS;                  /* linepos mod tabSize */
	int cSpaces;                /* number of spaces to print to next tab stop */
	int index;                  /* 'for' index for printing spaces */
	int tabSize;                /* current tab size */

	if (fC_Source)
		tabSize = TABSIZE_C;
	else
		tabSize = TABSIZE_ASM;

	while (*pb != '\0') {
		if (*pb == '\t') {      /* if a tab character found */
			modTS = linepos % tabSize;  
			cSpaces = tabSize - modTS;
			for (index = 0; index < cSpaces; index++) {
				fputc(' ', of);
				linepos++;
			}
		}   /* if */
		else {
			fputc(*pb, of);
			linepos++;
		}
		pb++;
	}   /* while */

	if (ferror(of))
		MyAbort(OUTSPACE);
	ofpos = ftell(of);  /* update output file seek position for next line */
} /* WriteLine */


/***
*SwitchFound(s) - see if IF, ELSE, ENDIF switch on this line
*
*Purpose: return TRUE if an "if", "else", or "endif" are identified at
*   the start of string 's'. This is used to check to see if a
*   header line which doesn't start with ';' is an assembler switch.
*Entry:
*   s = pointer to a char which represents the string to be checked.
*   
*Exit:
*   returns TRUE if the string matches "if", "else", or "endif" of either
*   upper or lower case, FALSE otherwise.
***************************************************************************/

SwitchFound(s)
char *s;
{
	if (fC_Source) {
		/* strncmp returns 0 (which maps to FALSE) iff a match was found */
		if (strncmp(s, "#if", 3) &&
		    strncmp(s, "#IF", 3) &&
		    strncmp(s, "#else", 5) &&
		    strncmp(s, "#ELSE", 5) &&
		    strncmp(s, "#endif", 6) &&
		    strncmp(s, "#ENDIF", 6))
			return (FALSE);
	}
	else {
		if (strncmp(s, "if", 2) &&
		    strncmp(s, "IF", 2) &&
		    strncmp(s, "else", 4) &&
		    strncmp(s, "ELSE", 4) &&
		    strncmp(s, "endif", 5) &&
		    strncmp(s, "ENDIF", 5))
			return (FALSE);
	}
	return (TRUE);
}

/***
*GetNonBlank(copyit) - read line, find first non blank character
*
*Purpose:
*   Read in a line; return linebuf index if non-blank line found, -1 otherwise
*
*Entry:
*   copyit = TRUE means copy line to copy file
*
*Exit:
*   returns -1 if blank line read
*   return index of first non-whitespace char otherwise
*
***************************************************************************/
GetNonBlank(copyit)
int copyit;         /* copy lines to copy file if TRUE */
{
	register int i;
	register int cbLine;

	if (ReadLine(copyit) == -1) {
		return(-1);
	}

	cbLine = linelen(linebuf);

	for (i = 0; ((linebuf[i] == ' ') || (linebuf[i] == '\t')) &&
                    (i < cbLine); i++);

	if (i >= cbLine)
		return (-1);
	else
		return (i);

}   /* GetNonBlank */

/***
*ReadToHeader() - reads to beginning of next header
*
*Purpose:
*   Reads to beginning of next header or EOF 
*
*Entry:
*   
*Exit:
*   Returns -1 if at EOF, 0 if at a header
*
************************************************************************/

int ReadToHeader()
{
	while (!fEof && ReadLine(fDelete) != 1)
		;
	if (fEof)
		return -1;      /* at EOF */
	else
		return 0;       /* at beginning of header */
}



/***
*Get1stHdr() - read to first header
*
*Purpose:
*   Read lines until the first header is found. Return TRUE if this is
*   the header for the module, or FALSE if no module header is found.
*   
*   In C Sources, we assume that if the first non-blank line in the source
*       starts with  '/***', then it's the start of a module header.
*   In Native-Code Sources, we assume that there can exist any number
*       of blank lines, optionally followed by a TITLE statement, followed
*       by any number of blanks lines, and then by the module header if
*       it exists.
*
*Entry:
*       NONE
*Exit:
*       TRUE if module header found, FALSE otherwise. Note that if fEof is found,
*       FALSE is returned, and if !fEof and no module header is found, this 
*       routine will read in lines until the first routine header is found,or
*       fEof.
***************************************************************************/

Get1stHdr()
{
	register int index;
	register int i;

	while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
		;

	if (fEof) {
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

	/* now, index is set into linebuf for a non-blank character */
	if (fC_Source) {        /* if header exists, must be first non-blank line */
		if ((linebuf[0] == '/') && (linebuf[1] == '*') &&
		    (linebuf[2] == '*') && (linebuf[3] == '*')) {
			fInHeader = TRUE;
			return (TRUE);
		}
		else {
			/* read to start of first header, tell caller no module header found */
			ReadToHeader();
			fprintf(stderr, "warning: no file header on file ");
			fprintf(stderr, "%s\n", szFilenameCur);
			return (FALSE);
		}
	}

	/* must be native-code source - - - can have a TITLE line with blank
	                lines before and after it - - - all prior to module header       */

	for (i = 1; i <= 3; ++i) { /* do thrice, might have TITLE, NAME, and PAGE */
		if (strncmp("TITLE", linebuf + index, 5) == 0 ||
		    strncmp("title", linebuf + index, 5) == 0 ||
		    strncmp("Title", linebuf + index, 5) == 0 ||
		    strncmp("NAME", linebuf + index, 4) == 0 ||
		    strncmp("name", linebuf + index, 4) == 0 ||
		    strncmp("Name", linebuf + index, 4) == 0 ||
		    strncmp("PAGE", linebuf + index, 4) == 0 ||
		    strncmp("Page", linebuf + index, 4) == 0 ||
		    strncmp("page", linebuf + index, 4) == 0)
		{ /* found TITLE, NAME, or PAGE statement */
			while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
				;

			if (fEof) {
				fprintf(stderr, "warning: no file header on file ");
				fprintf(stderr, "%s\n", szFilenameCur);
				return (FALSE);
			}
		}
	}

	/* if there was a TITLE and/or NAME statement, we've eaten it, 
	                   and any following blank lines;
	               must now have module header, if it exists */

	if ((linebuf[0] == ';') && (linebuf[1] == '*') &&
	    (linebuf[2] == '*') && (linebuf[3] == '*')) {
		fInHeader = TRUE;
		return (TRUE);
	}
	else {
		/* read to start of first header, tell caller no module header found */
		ReadToHeader();
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

}   /* Get1stHdr */

/***
*AdvanceOne(s) - advance one char if one whitespace or comment token
*
*Purpose:
*   's' points to the first character in an input line; if it's a whitespace
*   token or a comment token, return a pointer to the next character in the
*   line, otherwise, return 's' unchanged.
*
*Entry:
*   s = ptr to first char in input line
*
*Exit:
*   returns ptr the next char if *s is whatspace, ';', or '*',
*   otherwise returns s
*
*******************************************************************************/

char *AdvanceOne(s)
char *s;
{
	if (*s == '*') {
		if (fC_Source)
			s++;
	}
	else if (*s == ';') {
		if (!fC_Source)
			s++;
	}
	else if ((*s == ' ') || (*s == '\t'))
		s++;
	return(s);
}   /* AdvanceOne */


/***
*FuncNamePtr(pbName) - find function name from this or next line
*
*Purpose:
*   Given a pointer into the current header line, return a pointer to
*   the first non-blank or comment symbol; if none found in the existing
*   line, read in another and try that one.
*   if a C routine line, skip any types, etc., and return a pointer to
*   the filename itself.
*
*   If a C routine line:
*   -------------------
*       Assumes that C routine names will end with a left paren.
*       Allows left parens in a summary of purpose if said summary is
*           preceded by a '-' which comes after the routine name.
*       Assumes that there are 1 or 0 spaces between the the routine name
*           and the mandatory left paren.
*
*Entry:
*       pbName = a pointer to the place to begin searching in linebuf.
*Exit:
*       Returns a pointer to the filename.
*
***************************************************************************/

char *FuncNamePtr(pbName)
register char *pbName;
{
	register int cbLine;
	char *pbTmp;
	int iStart;

	/* first, see if we have a blank line - if so, read in another one,
	                and assume that it has the filename; don't check that one ... */
	pbTmp = AdvanceOne(pbName);
	cbLine = linelen(pbTmp);
	for (iStart = 0; ((*(pbTmp+iStart) == ' ') || (*(pbTmp+iStart) == ' ')) &&
                    (iStart < cbLine); iStart++);
	    if (iStart >= cbLine) {
		if (ReadLine(fDelete) != 0) {   /* then we got a procedure end w/out a name! */
			if (fEof)
				fprintf(stderr, "EOF not expected\n");
			else
				fprintf(stderr, "Illegal header termination\n");
			fprintf(stderr,
			"  in line %d of file %s\n", cLinesRead, szFilenameCur);
			return((char *)-1);
		}
		pbName = linebuf;
	}

	/* now, assume that there is a filename somewhere at or after pbName */


	iStart = 0;

	while (*(pbName+iStart) != '(' && *(pbName+iStart) != '-' &&
	    *(pbName+iStart) != ',' && *(pbName+iStart) != '\n')
		++iStart;   /* search fwd for '(', '-', ',' or '\n' */
	do {
		--iStart;
	} 
	while ((*(pbName+iStart) == ' ' || *(pbName+iStart) == '\t') &&
	    iStart > 0);
	/* search back through whitespace */ 
	while (*(pbName+iStart) != ' ' && *(pbName+iStart) != '\t' &&
	    *(pbName+iStart) != ';' && *(pbName+iStart) != '*')
		--iStart;
	/* search back to beginning of name */
	++iStart;       /* point to first letter of name */
	return (pbName+iStart); /* return pointer to name */
}   /* FuncNamePtr */


/***
*MyReadFile(pbNam) - read file and remember headers
*
*Purpose:
*   Read one entire file, stripping out and remembering function headers
*   or module headers, as appropriate.
*
***************************************************************************/

void MyReadFile(char *pbNam)
{
	char CopyName[65];                  /* name of copy file */
	char *s, done, backout;
	int funci, svnfuncs, svnentries;
	int inmodhdr;                       /* TRUE if in module header, else FALSE */
	int insection;                      /* TRUE if in scetion to process */
	int onfirst;                        /* TRUE if on first line of header */

	szFilenameCur = pbNam;
	if ((ifd = fopen(pbNam, "r")) <= 0)
		MyAbort(FILENF, pbNam);
	linebuf[0] = '\0';                  /* make linebuf blank so file copying works */
	fEof = FALSE;
	cLinesRead = 0;

	if (!FindIfC(pbNam))    {           /* filename had invalid suffix */
		fprintf(stderr, "Illegal suffix for file %s", pbNam);
		fprintf(stderr, "; must have .c or .asm suffix\n");
		fclose(ifd);
		return;
	}

	if (fDelete) {
		MakeCopyfileName(pbNam, CopyName);  /* put the right extension on */
		cfd = fopen(CopyName, "w");
		if (cfd == NULL)
			MyAbort(FILENO, CopyName);        /* can't open file */
	}

	inmodhdr = Get1stHdr(); 
	if (inmodhdr && !fGetModNams) {
		/* don't want module header */
		ReadToHeader();                 /* skip module header */
		inmodhdr = FALSE;
	}

	/* we are currently at the beginning of a new header.
	        copy it to file TEMP, remember all entry points in NAMBUF.  */

	while (!fEof && (inmodhdr || fGetProcNams)) {
		svnfuncs = nfuncs;
		svnentries = nentries;
		if (++nfuncs >= MAXFUNCS)
			MyAbort(FUNCSOV);
		func[nfuncs].filename = pbNam;
		func[nfuncs].nlines = 0;
		func[nfuncs].filepos = ofpos;
		if (ReadLine(fDelete) == -1)
			done = TRUE;            /* got end-of-file */
		else
			done = FALSE;
		funci = nfuncs;
		s = linebuf;

		while (!done) {
			if (++nentries >= MAXENT)
				MyAbort(ENTOV);
			entry[nentries].entname = nambuf + nambufi;
			entry[nentries].printed = FALSE;
			entry[nentries].funcid = funci;
			s = FuncNamePtr(s);
			if (s == (char *)-1) {
				fprintf(stderr, "Error found in line %d of file %s\n",
				cLinesRead, szFilenameCur);
				s = linebuf;
			}
			while ((*s != '\0') &&  /* transfer function name to nambuf */
			(*s != ',') &&
			    (*s != '(') &&
			    (*s != ' ') &&
			    (*s != '\n') &&
			    (*s != '\t') &&
			    (nambufi < (NAMBUFSZ - 2))) {
				nambuf[nambufi++] = *(s++);
			}
			if (nambufi >= (NAMBUFSZ - 2))
				MyAbort(NMBUFOV, NULL);
			nambuf[nambufi++] = '\0';

			/* make all secondary entry points reference primary entry point */
			if (funci >= 0)
				funci = -1 - nentries;   

			/* next we see if another entry point exists */
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*s == '(') {
				do {
					++s;
				} 
				while (*s != ')' && *s != '\n');  /* skip param list */
				++s;                            /* goto next character */
			}
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*(s++) != ',')
				done = TRUE;                    /* no more entry pts */
			else {
				++s;
				done = FALSE;
			}
		} /* while !done */

		backout = FALSE;

		if (fDoAll || fDoFirst)
			insection = TRUE;
		else
			insection = FALSE;                  /* are we in the correct section */

		onfirst = TRUE;                         /* on first line */

		do {
			s = linebuf;

			if ((!fC_Source && (*s != ';') && !SwitchFound(s)) || 
			    (fC_Source && (*s != '*') && !SwitchFound(s))) {
				/* Illegal Header Format, leave garbage in file TEMP,
				                    but restore nfuncs and nentries to previous values
				                    and backout of this header gracefully. */
				fprintf(stderr, "Invalid Header for function: %s",
				entry[nentries].entname);
				fprintf(stderr, " in line %d", cLinesRead);
				fprintf(stderr, ", in file: %s\n", pbNam);
				nfuncs = svnfuncs;
				nentries = svnentries;
				backout = TRUE;
			}

			s = AdvanceOne(s);

			if (!fDoAll && fDoSection && !onfirst && *s != ' ' && *s != '\t' && *s != '\n') {
				/* now at a section beginning -- and it's significant */
				if (insection)
					insection = FALSE;          /* come to end of section */
				else if (strncmp(s, SectionHead, strlen(SectionHead)) == 0)
					insection = TRUE;           /* come to beginning of section */
			}

			/* if in the section, don't copy, but write to TEMP */
			if (insection) {
				WriteLine(s, ofd);
				func[nfuncs].nlines++;
				ReadLine(FALSE);
			}
			else {
				ReadLine(fDelete);
			}

			if (onfirst && !fDoAll)
				insection = FALSE;

			onfirst = FALSE;                    /* no longer on first line */
		} 
		while ((!fEof) && (!backout) && fInHeader);

		/* skip to start of next function header */
		if (fGetProcNams)
			ReadToHeader();
		inmodhdr = FALSE;

	} /* while !fEof etc. */

	while (!fEof) {
		ReadLine(fDelete);
	}                                       /* read rest of file */

	if (fInHeader) {
		/* Error: reached EOF with unterminated header */
		fInHeader = FALSE;
		fprintf(stderr,
		"Error: function %s not terminated before end-of-file in %s\n",
		entry[nentries].entname, szFilenameCur);
	}

	fclose(ifd);
	fclose(cfd);

} /* MyReadFile */


/***
*PrintSep() - print a seperator
*
*Purpose:
*   Output a some lines which mark function header boundaries.
*
***************************************************************************/

void PrintSep(void)
{
	printf("---------------------------------------");
	printf("----------------------------------------\n");
} /* PrintSep */


/***
*PrintEntry(i) - print out an entry point header/module header
*
*Purpose:
*   Prints the given header out
*
***************************************************************************/

PrintEntry(i)
int i;
{
	int linecnt, m, entrysize;
	if ((m = entry[i].funcid) >= 0)
		entrysize = 4 + func[m].nlines; /* primary entry point */
	else
		entrysize = 4; /* secondary entry point */
	if (outline + entrysize > PAGELEN && outline > 1) {
		while (outline > PAGELEN)
			outline -= PAGELEN;
		while (outline <= PAGELEN) {
			printf("\n");
			outline++;
		}
		outline = 1;
	}
	printf("\n");
	PrintSep();
	printf("%s - ", entry[i].entname);
	if (m < 0)
		printf("see %s\n", entry[-1-m].entname);
	else
		printf("File: %s\n", func[m].filename);
	PrintSep();
	outline = outline + 4;
	if (m < 0 || func[m].nlines == 0)
		return(0);
	fseek(ifd, func[m].filepos, 0);
	fEof = FALSE;
	linecnt = func[m].nlines;
	ReadLine(FALSE);
	do {
		WriteLine(linebuf, stdout);
		outline++;
		ReadLine(FALSE);
	}
	while ((!fEof) && ((--linecnt) > 0));
} /* PrintEntry */

#if 0
/***************************************************************************
*_stricmp(pbLeft, pbRight) - case insensitive string compare
*
*Purpose:
*   Case-insensitive string comparison.
*
*Entry:
*   pbLeft, pbRight = ptrs to strings to compare
*
*Exit:
*   Return 0 if left string == right string, -1 if left string less than
*   right string, 1 otherwise
*
*NOTE:
*       This routine is provided because not all C runtime libraries support
*       this; specifically, MS C for DOS does have this routine, but
*       on a 68k it doesn't seem to be there.
*
***************************************************************************/
char *malloc();
#define isLcase(c)   (((c) >= 'a') && ((c) <= 'z'))
#define upit(c)  ((isLcase(c))? (c) - 'a' + 'A' : (c))

_stricmp(pbLeft, pbRight)
char *pbLeft, *pbRight;
{
	int cbLeft = strlen(pbLeft);
	int cbRight = strlen(pbRight);
	char *pbUCleft = malloc(cbLeft +1);
	char *pbUCright = malloc(cbRight +1);
	register char *pbSrc;
	register char *pbDst;
	register int i, retval;

	pbDst = pbUCleft;
	pbSrc = pbLeft;
	for (i = 0; i <= cbLeft; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	pbDst = pbUCright;
	pbSrc = pbRight;
	for (i = 0; i <= cbRight; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	retval = strcmp(pbUCleft, pbUCright);

	free(pbUCright);
	free(pbUCleft);

	return(retval);
} /* strless */

#endif /* 0 */

/***************************************************************************
* SortFunctions()
*
* Purpose:
*   Print sorted list of functions headers.
*
***************************************************************************/
void SortFunctions(void)
{
	int i, j, low;
	ifd = fopen("temp", "r");
	i = -1;
	while (++i <= nentries) {
		low = 0;
		j = -1;
		while (++j <= nentries) {
			if (!entry[j].printed) {
				if (entry[low].printed)
					low = j;
				else if (0 > _stricmp(entry[j].entname, entry[low].entname))
					low = j;
			}
		}
		PrintEntry(low);
		entry[low].printed = TRUE;
	}
} /* SortFunctions */

/*** 
*UsageError() - print out usage
*Purpose:
*   prints out the usage guidelines
*
*Entry:
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void UsageError(void)
{
	printf("Usage: striphdr [switches] file {file ...}\n\n");
	printf("  Accepts native code or C source; determines source\n");
	printf("     type based on filename suffix.\n");
	printf("  Wildcards may be used in the file names.\n");
	printf("\n");
	printf("Switches:\n");
	printf("  -m        process module headers only\n");
	printf("  -b        processes both procedure and module headers\n");
	printf("            [default is procedure headers only]\n");
	printf("  -l        processes only first line of each header\n");
	printf("  -n        processes none of header (i.e. lists only function name)\n");
	printf("  -s <name> processes named section only (may be used with -l)\n");
	printf("            [default is to process whole header]\n");
	printf("  -d        delete processed section from input file\n");
	printf("  -q        quiet, do not print headers (useful only with -d)\n");
	printf("  -x <ext>  gives extension for output file when -d used\n");
	printf("            [default: .new]\n");
	printf("  -r        remove revision histories from file headers\n");
	printf("              (equivalent to -m -d -q -s \"Revision History\")\n");
	exit(-1);
} /* UsageError */


void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/***
*main() - parse command line and process all file
*
*Purpose:
*   To run the other procedures based on the command line.
*
*******************************************************************************/

int main(int argc, char *argv[])
{
	int filei;
	int fScanningSwitches = TRUE;
    char base_dir[256], curr_dir[256];
    long h_find;
    struct _finddata_t f_data;

	nfuncs = -1;
	nentries = -1;
	nambufi = 0;
	ofpos = 0;
	filei = 1;
	outline = 1;

	if (argc == 1)      /* no args given - print usage message and quit */
		UsageError();

	while (fScanningSwitches) {
		if (filei >= argc) {
			fScanningSwitches = FALSE;
		}
		else if (_stricmp("-d", argv[filei]) == 0) {
			fDelete = TRUE;
			filei++;
		}
		else if (_stricmp("-q", argv[filei]) == 0) {
			fQuiet = TRUE;
			filei++;
		}
		else if (_stricmp("-n", argv[filei]) == 0) {
			fDoFirst = fDoSection = fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-m", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			filei++;
		}
		else if (_stricmp("-b", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = TRUE;
			filei++;
		}
		else if (_stricmp("-l", argv[filei]) == 0) {
			fDoFirst = TRUE;
			fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-s", argv[filei]) == 0) {
			fDoSection = TRUE;
			fDoAll = FALSE;
			filei++;
			if (filei >= argc)
				UsageError();
			strcpy(SectionHead, argv[filei]);   /* copy section header in */
			filei++;
		}
		else if (_stricmp("-x", argv[filei]) == 0) {
			filei++;
			if (argv[filei][0] == '.')
				strncpy(CopyExt, argv[filei]+1, 3);     /* skip '.' */
			else
				strncpy(CopyExt, argv[filei], 3);
			CopyExt[3] = '\0';                  /* terminate string */
			filei++;
		}
		else if (_stricmp("-r", argv[filei]) == 0) {
			fDelete = TRUE;
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			fDoAll = FALSE;
			fDoSection = TRUE;
			fQuiet = TRUE;
			strcpy(SectionHead, "Revision History");
			filei++;
		}
		else if (*(argv[filei]) == '-')
			UsageError();
		else
			fScanningSwitches = FALSE;
	}

	if (filei >= argc)
		UsageError();                           /* no files specified */

	if (fQuiet)
		ofd = fopen("nul", "w");    /* in quiet mode, so no need to save the headers */
	else
		ofd = fopen("temp", "w");
	if (ofd == NULL)
		MyAbort(FILENO, "temp");                  /* can't open file */

	filei--;

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
    while (++filei < argc) {
        gdir(curr_dir, argv[filei]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[filei], &f_data)) == -1)
			continue;
        do
		{
       		MyReadFile(f_data.name);
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
	fclose(ofd);
	if (!fQuiet)
		SortFunctions();
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <stdafx.h>
#include <assert.h>
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\CNetwork.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#ifndef _CNETWORK_H_
#define _CNETWORK_H_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <XboxDbg.h>
#include "..\\include\\DataPacket.h"

typedef struct sockaddr_in SOCKADDER_IN;
typedef struct sockaddr SOCKADDR;
   
   CONST USHORT ADVERTISE_PORT = 5159;
   CONST USHORT COMMUNICATION_PORT = 5150;
   CONST USHORT COMMUNICATION_SERVICE_PORT = 5161;

   CONST USHORT SF_ADVERTISE_PORT = 5259;
   CONST USHORT SF_COMMUNICATION_PORT = 5250;
   CONST USHORT SF_COMMUNICATION_SERVICE_PORT = 5261;


// this enum must be kept sync'ed with the CNetErrorIDs array in CNetwork.cpp

typedef enum CNetErrors {
	CNetSuccess = 0,
	WSA_Error,
	InvalidSocket,
	NoServer,
	ConnectFailed,
	SendFailed,
	ReceiveFailed,
	XBCommandFailed,
};

typedef struct 
{
	char 	cSerialNumber[XBOX_SERIAL_NUMBER_LEN + 1]; // 12 char serial number + 0 termination
	DWORD	dwAVRegion;
	DWORD	dwGameRegion;
	BYTE	bMACAddress[ETHERNET_MAC_ADDR_LEN];
	char	bHDKey[(HARD_DRIVE_KEY_LEN*2)+1];
	char	cRecoveryKey[8/*RECOVERY_KEY_LEN*/ + 1];
	DWORD	dwOnlineKeyVersion;
	char	cOnlineKey[172/*ONLINE_KEY_LEN*/+1];

}GENDATA, *PGENDATA; 



class CNetWork {

private:
	char *	m_pszXBoxName;
public:
	CNetErrors InitXB(LPSTR szIpString,
		LPSTR szXboxName = "RR_XBServer",
		USHORT usPort = COMMUNICATION_PORT
		);


	CNetErrors  SendData( SOCKET sTarget, LPVOID pvData, INT iSize);
	CNetErrors  RecvData( SOCKET sTarget, LPVOID pvData, INT iSize);
	INT  CloseSocket( SOCKET sTarget );
	BOOL GetXboxIpFromName ( IN CHAR* szXboxName, OUT CHAR* szIp);
	

	~CNetWork();
	CNetWork();


	SOCKET	m_sXBClient;
	SOCKET  m_sSFClient;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RRConsole.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_RRCONSOLE_DIALOG            102
#define IDS_NOSERIAL                    102
#define IDS_SUCCESS                     103
#define IDS_SOCKINITERR                 104
#define IDS_INVALSOCKET                 105
#define IDS_NOXSERVER                   106
#define IDS_XCONNECTFAIL                107
#define IDS_SENDFAIL                    108
#define IDS_RCVFAILED                   109
#define IDS_NOGEN                       110
#define IDS_SENDGENFAIL                 111
#define IDS_HDUNLOCKFAIL                112
#define IDS_INVALSERIAL                 113
#define IDS_BADGEN                      114
#define IDS_XCOMMANDFAIL                115
#define IDS_SUCCESSFULOP                116
#define IDS_CAPOK                       117
#define IDS_CAPFAIL                     118
#define IDS_SERNO                       119
#define IDS_CONNEXTXBOX                 120
#define IDS_CANCEL                      121
#define IDS_QUIT                        122
#define IDS_UPDATE                      123
#define IDS_LOCK                        124
#define IDS_TITLE                       125
#define IDS_NOGENREC                    126
#define IDS_LOCKONLY                    127
#define IDR_MAINFRAME                   128
#define IDS_WARNMFR                     128
#define IDS_CAPWARN                     129
#define IDB_BITMAP1                     130
#define IDS_CANCELED                    130
#define IDS_REDSTR                      131
#define IDS_YELLOWSTR                   132
#define IDB_BITMAP2                     133
#define IDS_GREENSTR                    133
#define IDB_BITMAP3                     134
#define IDS_BADPARSE                    134
#define IDB_GREEN                       135
#define IDS_NETWORKERROR                135
#define IDB_YELLOW                      136
#define IDS_NOMEM                       136
#define IDB_RED                         137
#define IDS_FILENOTFOUND                138
#define IDS_UPDATEWARNING               139
#define IDC_SerialNumber                1000
#define IDC_BUTTON1                     1001
#define IDC_MBReplace                   1001
#define IDC_MONTHCALENDAR1              1002
#define IDC_UnlockHD                    1002
#define IDC_HDReplace                   1003
#define IDC_NewXbox                     1004
#define IDC_VerifyXBox                  1005
#define IDC_BUTTON2                     1006
#define IDC_VerifyOnly                  1006
#define IDC_ConnectXBOX                 1007
#define IDC_MAKETEST                    1008
#define IDC_DISPLAYEEPROM               1009
#define IDC_SERNO                       1010
#define IDC_TITLE                       1012
#define IDC_STOPNGO                     1013
#define IDRESET                         1018
#define IDC_UPDATEWARNING               1019
#define IDC_VERSION                     1020

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\RRConsole.h ===
// RRConsole.h : main header file for the RRCONSOLE application
//

#if !defined(AFX_RRCONSOLE_H__256848CF_3180_495B_A930_464E87FD03F8__INCLUDED_)
#define AFX_RRCONSOLE_H__256848CF_3180_495B_A930_464E87FD03F8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include "resource.h"		// main symbols
#include <init.h>
typedef LONG NTSTATUS; // for xconfig.h
#include <xconfig.h>
#include <cryptkeys.h>
#include <PerBoxData.h>
#include "CNetwork.h"

extern UINT CNetErrorIDs[];



/////////////////////////////////////////////////////////////////////////////
// CRRConsoleApp:
// See RRConsole.cpp for the implementation of this class
//

class CRRConsoleApp : public CWinApp
{
public:
	CRRConsoleApp();
	
	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRRConsoleApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CRRConsoleApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RRCONSOLE_H__256848CF_3180_495B_A930_464E87FD03F8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\RRConsole.cpp ===
// RRConsole.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "RRConsole.h"
#include "RRConsoleDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CRRConsoleApp

BEGIN_MESSAGE_MAP(CRRConsoleApp, CWinApp)
	//{{AFX_MSG_MAP(CRRConsoleApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRRConsoleApp construction

CRRConsoleApp::CRRConsoleApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRRConsoleApp object

CRRConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CRRConsoleApp initialization

BOOL CRRConsoleApp::InitInstance()
{
	int nResponse;

	// Standard initialization

	
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
	CRRConsoleDlg dlg;
	m_pMainWnd = &dlg;

	nResponse = dlg.DoModal();

	if(nResponse == IDCANCEL || nResponse == IDCLOSE)
	{
	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
//		ExitWindows(0,0);  // log user off
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\CNetwork.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
/*++
 Copyright (c) 2001, Microsoft.

    Author:  Dennis Krueger [a-denkru]
    Date:    6/26/2001

    Description:
        This is the cpp file for the Network class.

--*/
//#include "CNetwork.h"
#include "stdafx.h"
#include "RRConsole.h"



UINT CNetErrorIDs[] = {
	IDS_SUCCESS,
	IDS_SOCKINITERR,
	IDS_INVALSOCKET,
	IDS_NOXSERVER,
	IDS_XCONNECTFAIL,
	IDS_SENDFAIL,
	IDS_RCVFAILED,
	IDS_XCOMMANDFAIL
};


#define SITAddr 0x8e8e0101  // static ip address of 142.142.1.1






BOOL
CNetWork::
GetXboxIpFromName ( IN CHAR* szXboxName, OUT CHAR* szIp)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/26/2001

    Routine Description:
        This will get the Ip address of the Xbox specified.
    Arguments:
        The name. szIp will be the buffer containing the Ip.
        Buffer should be 16 bytes or larger. to contain aaa.bbb.ccc.ddd\0
    Return Value:
      True for success False for failure.

--*/
{

	BOOL bStatus = TRUE;
	szXboxName =0;
	SOCKET sBroadCast;
	BOOL   bBroadCast;
	SOCKADDER_IN sinCast;
	SOCKADDER_IN sddrFrom;
	SOCKADDER_IN sddrAccept;
	SOCKET sRead;
	INT iAddrLen;
	int Retry = 0;
	ULONG One = 1; // use as parameter for ioctlsocket

	WSADATA       wsd;
	char *szInBuffer = "Give me your IP";
	BYTE  byteIP[15] = "";
	IN_ADDR* inaddr = (IN_ADDR *)byteIP;


	if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {
		printf("Failed to load Winsock library!\n");
		exit(1);
	}
	// Create a broadcast socket.
	sBroadCast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (sBroadCast == SOCKET_ERROR) 
	{
	   
		printf("broadcast socket() failed: %d", WSAGetLastError());
		exit(1);
	}
	// Set this to a broadcast socket.
	bBroadCast = TRUE;
	// setsockopt goes here 
	sinCast.sin_family = AF_INET;
	sinCast.sin_addr.s_addr = INADDR_BROADCAST; //htonl(SITAddr);//bugbug test /*INADDR_BROADCAST ; SITAddr*///BUGBUG REVIEW
	sinCast.sin_port = htons(ADVERTISE_PORT);
	setsockopt(sBroadCast,SOL_SOCKET, SO_BROADCAST,
              (char *)&bBroadCast, sizeof(bBroadCast));
 
	if ( SOCKET_ERROR == sendto( sBroadCast,
                                szInBuffer,
                                strlen(szInBuffer),
                                0,
                                (SOCKADDR*)&sinCast,
                                sizeof(sinCast))) 
   {
		return FALSE;
   }


	closesocket(sBroadCast);

	// Do a recvfrom so we then broadcast out our IP
	sBroadCast = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sBroadCast == SOCKET_ERROR) 
	{
		printf("Opening socket() failed: %d\n", WSAGetLastError());
		bStatus = FALSE;
		goto exit;
	}
   
	sddrFrom.sin_family = AF_INET;
	sddrFrom.sin_addr.s_addr = htonl(SITAddr/*INADDR_ANY*/) ; // use static ip addr
	sddrFrom.sin_port = htons(ADVERTISE_PORT);

	if (bind(sBroadCast, (struct sockaddr *)&sddrFrom, sizeof(sddrFrom)) == SOCKET_ERROR)
	{
		printf("Bind() failed: %d", WSAGetLastError());
		return FALSE;

	}
   
	ioctlsocket(sBroadCast,FIONBIO,&One);
	listen(sBroadCast,1);
	iAddrLen = sizeof(sddrAccept);
retry:
	sRead = accept( sBroadCast,(SOCKADDR *)&sddrAccept,&iAddrLen);
	if(INVALID_SOCKET == sRead && Retry < 10)
	{
		Retry++;
		Sleep(500);
		goto retry;
	}
	closesocket(sBroadCast);
	if(INVALID_SOCKET == sRead)
	{
		char buffer[100];
		sprintf(buffer,"WSA Error = %d",WSAGetLastError());
		MessageBox(NULL,buffer,NULL,MB_OK);

		return FALSE;
	}

	// receive IP.
	recv( sRead, (CHAR *)byteIP, sizeof(byteIP),0);
	sprintf(szIp,"%s", inet_ntoa(*inaddr) );
	WSACleanup();

	exit:
	return bStatus;
}


// Below is network class.
CNetWork::CNetWork()
{
	;
}


CNetWork::~CNetWork()
{
   closesocket(m_sXBClient);
   closesocket(m_sSFClient);
   WSACleanup();
}



CNetErrors 
CNetWork::
SendData(SOCKET sTarget, LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;
   // Send the data 
   ret = send(sTarget,(const char*) pvData, iSize, 0);
   if (ret == SOCKET_ERROR ) 
   { // SOCKET_ERROR == -1
	   ret = SendFailed;
   }
   
   return CNetSuccess;
}


CNetErrors 
CNetWork::
RecvData(SOCKET sTarget, LPVOID pvData, INT iSize)
{
   
   INT ret;
   PDATA_PACKET p = (PDATA_PACKET)pvData;

   ret = recv( sTarget,(char *) pvData, iSize, 0);
   if (ret == SOCKET_ERROR) {
      return ReceiveFailed;
   }
   
   return CNetSuccess;
}


INT 
CNetWork::
CloseSocket( SOCKET sTarget )
{
   
   return closesocket( sTarget );

}


CNetErrors CNetWork::InitXB(LPSTR szIpString, LPSTR szXboxName, USHORT usPort)
{

   WSADATA       wsd;
   char          szIp[ 20 ];
   struct sockaddr_in server;
   struct hostent*    host = NULL;
   BOOL			bResult;

   // Get the Ip for the specified Xbox.
   if (NULL == szIpString[0] ) 
   {
      bResult = GetXboxIpFromName ( szXboxName, szIp);
	  if(FALSE == bResult)
	  {
		  return NoServer;
	  }

      strncpy(szIpString, szIp, strlen(szIp)+1);
   }
   
   if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) 
   {
		return WSA_Error;
   }
   
   // Create the socket, and attempt to connect to the server
   m_sXBClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (INVALID_SOCKET == m_sXBClient ) 
   {
		return InvalidSocket;
   }
 
   server.sin_family = AF_INET;
   server.sin_port = htons(usPort);
   server.sin_addr.s_addr = inet_addr( szIpString );
   // If the supplied server address wasn't in the form
   // "aaa.bbb.ccc.ddd" it's a hostname, so try to resolve it
   
   if (INADDR_NONE == server.sin_addr.s_addr) {
      host = gethostbyname( szIpString );
      if (	NULL == host) 
	  {
		 return NoServer;
      } else 
	  {
         CopyMemory(&server.sin_addr, host->h_addr, host->h_length);
      }
   }
   if (connect(m_sXBClient, (struct sockaddr *)&server, 
               sizeof(server)) == SOCKET_ERROR) 
   {
      return ConnectFailed;
   }
   
   
   return CNetSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\RRConsoleDlg.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
// RRConsoleDlg.cpp : 
//
/*++
 Copyright (c) 2001, Microsoft.

    Author:  Dennis Krueger [a-denkru]
    Date:    6/26/2001

    Description:
        This implements the primary functions of the RR Console.  The RRConsole is
		a client to the XBRRServer which serves commands on the XBox and accesses
		a private share named \\TestServer\Data\Working to access Genealogy data.
		This program takes genealogy data, generates a new EEProm image based on that
		data and updates the XBox using packetized commands to the XBox.

--*/
//===================================================================

#include "stdafx.h"
#include "RRConsole.h"
#include "RRConsoleDlg.h"
#include <string>

#include <av.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SUCCESS 0



/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRRConsoleDlg dialog

CRRConsoleDlg::CRRConsoleDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRRConsoleDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRRConsoleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_pBuffer = NULL;
}

void CRRConsoleDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRRConsoleDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRRConsoleDlg, CDialog)
	//{{AFX_MSG_MAP(CRRConsoleDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_ConnectXBOX, OnConnectXBOX)
	ON_BN_CLICKED(IDC_HDReplace, OnHDReplace)
	ON_BN_CLICKED(IDC_VerifyXBox, OnCompleteXBox)
//	ON_BN_CLICKED(IDCLOSE, OnClose)
	ON_BN_CLICKED(IDC_VerifyOnly, OnVerifyOnly)
	ON_BN_CLICKED(IDRESET, OnReset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRRConsoleDlg message handlers

BOOL CRRConsoleDlg::OnInitDialog()
{
	CFont TitleFont;
	
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// setup the localized button strings
	CString TempStr;
	TempStr.LoadString(IDS_SERNO);
	SetDlgItemText(IDC_SERNO,TempStr);
	TempStr.LoadString(IDS_CONNEXTXBOX);
	SetDlgItemText(IDC_ConnectXBOX,TempStr);
	TempStr.LoadString(IDS_CANCEL);
	SetDlgItemText(IDRESET,TempStr);
	TempStr.LoadString(IDS_QUIT);
	SetDlgItemText(IDCANCEL,TempStr);
	TempStr.LoadString(IDS_UPDATE);
	SetDlgItemText(IDC_HDReplace,TempStr);
	TempStr.LoadString(IDS_LOCK);
	SetDlgItemText(IDC_VerifyXBox,TempStr);
	TempStr.LoadString(IDS_LOCKONLY);
	SetDlgItemText(IDC_VerifyOnly,TempStr);


// fixup font for title line
	TitleFont.CreateFont(
				12,                        // nHeight
				0,                         // nWidth
				0,                         // nEscapement
				0,                         // nOrientation
				FW_BOLD,	               // nWeight
				FALSE,                     // bItalic
				FALSE,                     // bUnderline
				0,                         // cStrikeOut
				ANSI_CHARSET,              // nCharSet
				OUT_DEFAULT_PRECIS,        // nOutPrecision
				CLIP_DEFAULT_PRECIS,       // nClipPrecision
				DEFAULT_QUALITY,           // nQuality
				DEFAULT_PITCH | FF_SWISS,  // nPitchAndFamily
				"Arial");                 // lpszFacename

	GetDlgItem(IDC_TITLE)->SetFont(&TitleFont);
	TempStr.LoadString(IDS_TITLE);
	SetDlgItemText(IDC_TITLE,TempStr);


	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// set focus to serial number entry
	GetDlgItem(IDC_SerialNumber)->EnableWindow(TRUE);  // Disabled until connected
	GetDlgItem(IDC_SerialNumber)->SetFocus();
	m_pbmRed = new CBitmap;
	m_pbmRed->LoadBitmap(IDB_RED); // setup red stoplight
	return FALSE;  // return TRUE  unless you set the focus to a control
}


void CRRConsoleDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CRRConsoleDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CRRConsoleDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


CRRConsoleDlg::ShowErrorStr(UINT nID)
{
	UINT IconType;
	CString ErrString,CaptionString;
	ErrString.LoadString(nID);
	if(IDS_SUCCESS == nID || IDS_SUCCESSFULOP == nID)
	{
		IconType = MB_ICONINFORMATION;
		CaptionString.LoadString(IDS_CAPOK);
	} else
	{
		IconType = MB_ICONSTOP;
		CaptionString.LoadString(IDS_CAPFAIL);
	}
	
	MessageBox(ErrString,CaptionString,IconType);
	
}

char * FindTaggedData(char * pInputBuff,char * szTargetStr)
{
	char * pTemp;
	int iResult;
	int iLimit = strlen(pInputBuff);
	for(int i = 0; i < iLimit; i++)
	{
		if('<' == pInputBuff[i])
		{
			// found the start of a tag
			if('/' == pInputBuff[i+1])
				continue; // end of a tagged field
			iResult = strnicmp(&pInputBuff[i+1],szTargetStr,strlen(szTargetStr));
			if(0 == iResult)
			{
				// found the tag, copy the data for the client
				pTemp = pInputBuff + i + strlen(szTargetStr) + 1;
				return pTemp;
			}
		}
	}
	return NULL;
}


BOOL GetGenString(char *pInputBuff,char *pOutputBuff,int BuffSize,char * szTargetStr)
{
	int iLimit = strlen(pInputBuff);
	char * pTemp;
	BOOL	fResult = FALSE;
	pTemp = FindTaggedData(pInputBuff, szTargetStr);
	if(NULL == pTemp)
		return FALSE;
	while(*pTemp != '<')
	{
		*pOutputBuff++ = *pTemp++;
	}
	*pOutputBuff = 0x00; // delemit string
	return TRUE;
}

#define HDKEYSTR		"HDDKey>"
#define GAMEREGIONSTR	"GameRegionCode>"
#define AVREGIONSTR		"TVRegionCode>"
#define MACADDRSTR		"MACAddr>"

DWORD CRRConsoleDlg::GetGenealogyData(char * pSerialNumber)
{

	char	cHDKey[100];
	char	cAVRegion[20];
	char	cGameRegion[20];
	char	cMACAddr[20];
	CNetErrors cnError;
	BOOL	fResult;
	DWORD	dwFileSize;
	HANDLE  hGenSource;

	CString GenSourcePath;
	GenSourcePath = m_GenSource;
	BOOL	fTryAgain = TRUE;

	// returns here once if we need to try the alternate source path
GetGen:

	if("\\" != GenSourcePath.Right(1))
	{
		GenSourcePath += "\\";
	}
	GenSourcePath += pSerialNumber;
	GenSourcePath += ".xml";
	
	// make access path name

	hGenSource = CreateFile(GenSourcePath,
						GENERIC_READ | GENERIC_WRITE,
						0,				// don't share
						NULL,			// don't inherit security
						OPEN_EXISTING,	// must exist
						FILE_ATTRIBUTE_NORMAL, // nothing special about the file
						NULL			// No template
						);

	
	if(INVALID_HANDLE_VALUE == hGenSource 
						&& TRUE == fTryAgain
						&& TRUE == m_fAltExists)
	{
		// try alternate
		GenSourcePath = m_GenAltSource;
		fTryAgain = FALSE;
		goto GetGen;
	}
		
	if(INVALID_HANDLE_VALUE == hGenSource)
	{
		DWORD dwResult = GetLastError();
		if(ERROR_BAD_NETPATH == dwResult)
		{
			return IDS_NETWORKERROR;
		} else
		{
			return IDS_NOGENREC;
		}
	}
	
	dwFileSize = GetFileSize(hGenSource,NULL); // get the file size
	m_pBuffer = (char *) malloc(dwFileSize+10); // allocate buffer for file
	if(NULL == m_pBuffer)
	{
		// memory allocation failed, return error
		return IDS_NOMEM;
	}
	// read xml-formatted genealogy data into buffer
	fResult = ReadFile(hGenSource,m_pBuffer,dwFileSize,&m_dwFileSize,NULL);
	if(FALSE == fResult)
	{
		CloseHandle(hGenSource);
		free(m_pBuffer);
		m_pBuffer = NULL;
		return IDS_NOGENREC;
	}

	CloseHandle(hGenSource); // close the handle now so we don't have to do so in all the error cases
							// we'll reopen it for the write after successful completion
	
	fResult = GetGenString(m_pBuffer,cHDKey,sizeof(cHDKey),HDKEYSTR);
	if(FALSE == fResult)
	{
		return IDS_BADPARSE;
	}

	fResult = GetGenString(m_pBuffer,cGameRegion,sizeof(cGameRegion),GAMEREGIONSTR);
	if(FALSE == fResult)
	{
		return IDS_BADPARSE;
	}
	fResult = GetGenString(m_pBuffer,cAVRegion,sizeof(cAVRegion),AVREGIONSTR);
	if(FALSE == fResult)
	{
		return IDS_BADPARSE;
	}
	fResult = GetGenString(m_pBuffer,cMACAddr,sizeof(cMACAddr),MACADDRSTR);
	if(FALSE == fResult)
	{
		return IDS_BADPARSE;
	}
	// got the necessary values, copy into local GenData Structure

	strncpy(m_GenData.cSerialNumber,pSerialNumber,13); // serial number string
	
	char ** ppStopString = NULL;
	ULONG ulTemp = strtoul(cGameRegion,ppStopString,16); // convert GameRegion
	m_GenData.dwGameRegion = ulTemp;

	ulTemp = strtoul(cAVRegion,ppStopString,16); // convert avregion
	m_GenData.dwAVRegion = ulTemp;

	sscanf(cMACAddr, "%2x",	&m_GenData.bMACAddress[0]);
	sscanf(&cMACAddr[2], "%2x",	&m_GenData.bMACAddress[1]);
	sscanf(&cMACAddr[4], "%2x",	&m_GenData.bMACAddress[2]);
	sscanf(&cMACAddr[6], "%2x",	&m_GenData.bMACAddress[3]);
	sscanf(&cMACAddr[8], "%2x",	&m_GenData.bMACAddress[4]);
	sscanf(&cMACAddr[10], "%2x",	&m_GenData.bMACAddress[5]);

	strncpy(m_GenData.bHDKey,cHDKey,strlen(cHDKey));
	

	cnError = CNetSuccess;
	return cnError;
}


void CRRConsoleDlg::OnConnectXBOX() 
{
	// Set connect text and bmp
	CBitmap * pBitMap;

	GetDlgItem(IDC_ConnectXBOX)->EnableWindow(FALSE);	// disable button so no double-clicks
	pBitMap = new CBitmap;
	pBitMap->LoadBitmap(IDB_YELLOW); 
	((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*pBitMap);
	delete pBitMap;

	// setup source and update directory paths
	// build genealogy source and destination paths

	// first source path in form \\servername\data\working
	DWORD dwResult;
	dwResult = GetPrivateProfileString(
					"ClientConfig",		// section
					"GenSourcePath",		// key name caseinsensitive
					"Fail",		// Default Name
					m_GenSource,		// targer buffer
					sizeof(m_GenSource),
					IniName				// needs to be in Windows directory
					);

	if(0 == dwResult || !strcmp(m_GenSource,"Fail"))
	{
		((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*m_pbmRed);
		CString Errmsg;
		Errmsg.LoadString(IDS_FILENOTFOUND);
		Errmsg += " "; Errmsg += IniName;
		MessageBox(Errmsg,NULL,MB_OK);
		GetDlgItem(IDC_ConnectXBOX)->EnableWindow(TRUE);	// enable button so no double-clicks
		return;
	}

	// next get alternate source path if exists
	m_fAltExists = TRUE; 
	dwResult = GetPrivateProfileString(
					"ClientConfig",		//  section
					"GenAltSourcePath",		// key name caseinsensitive
					"Fail",		// Default Name
					m_GenAltSource,		// targer buffer
					sizeof(m_GenAltSource),
					IniName				// needs to be in Windows directory
					);

	if(0 == dwResult || !strcmp(m_GenSource,"Fail"))
	{
		m_fAltExists = FALSE;
	}

	// get update path in form \\servername\data\working
	dwResult = GetPrivateProfileString(
					"ClientConfig",		// No section
					"GenUpdatePath",		// key name caseinsensitive
					"Fail",		// Default Name
					m_GenUpdate,		// targer buffer
					sizeof(m_GenUpdate),
					IniName				// needs to be in Windows directory
					);

	if(0 == dwResult || 0x00 == m_GenUpdate[0] || !strcmp(m_GenSource,"Fail"))
	{
		
		((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*m_pbmRed);
		CFont WarningFont;
		WarningFont.CreateFont(
					16,                        // nHeight
					0,                         // nWidth
					0,                         // nEscapement
					0,                         // nOrientation
					FW_BOLD,	               // nWeight
					FALSE,                     // bItalic
					FALSE,                     // bUnderline
					0,                         // cStrikeOut
					ANSI_CHARSET,              // nCharSet
					OUT_DEFAULT_PRECIS,        // nOutPrecision
					CLIP_DEFAULT_PRECIS,       // nClipPrecision
					DEFAULT_QUALITY,           // nQuality
					DEFAULT_PITCH | FF_SWISS,  // nPitchAndFamily
					"Arial");                 // lpszFacename

		m_fNoUpdate = TRUE;  // set no update to TRUE
		GetDlgItem(IDC_UPDATEWARNING)->SetFont(&WarningFont);
		CString TempStr;
		TempStr.LoadString(IDS_UPDATEWARNING);
		SetDlgItemText(IDC_UPDATEWARNING,TempStr);
		GetDlgItem(IDC_UPDATEWARNING)->Invalidate(TRUE);
	}

	// initialize connection to XBox
	m_szXBIPString[0] = 0x00; // null string
	CNetErrors InitError = m_XBServer.InitXB(m_szXBIPString);
	// check CNet initialization errors and pass to dialog
	if(InitError != CNetSuccess)
	{
		((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*m_pbmRed);
		ShowErrorStr(CNetErrorIDs[InitError]);
		GetDlgItem(IDC_ConnectXBOX)->EnableWindow(TRUE);	// re-enable button so no double-clicks
		return;
	}

	GetDlgItem(IDC_SerialNumber)->EnableWindow(TRUE);	// Enable once connected
	GetDlgItem(IDC_SerialNumber)->SetFocus();			// set focus to serial number
	GetDlgItem(IDC_HDReplace)->EnableWindow(TRUE);		// enable hdkey button
	GetDlgItem(IDC_VerifyXBox)->EnableWindow(TRUE);		// Enable Commit button
	GetDlgItem(IDRESET)->EnableWindow(TRUE);
	GetDlgItem(IDC_VerifyOnly)->EnableWindow(TRUE);
	pBitMap = new CBitmap;
	pBitMap->LoadBitmap(IDB_GREEN); 
	((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*pBitMap);
	delete pBitMap; // release bitmap
	return;
}



void CRRConsoleDlg::OnHDReplace() 
{
	DATA_PACKET Packet;
	DWORD dwResult;
	CNetErrors cnError;
	HRESULT hResult;
    BYTE OutputBuffer[512];
    DWORD dwBufferSize = 512;
 	char SerialNumber[30];


	// get serial number
	int CharCount = ((CEdit *)GetDlgItem(IDC_SerialNumber))->GetLine(0,SerialNumber,sizeof(SerialNumber));
	SerialNumber[12] = 0x00; // ensure terminated string, truncate an <cr>s
	if(0 == CharCount)
	{
		// no serial number, fail
		ShowErrorStr(IDS_NOSERIAL);
		return;
	}
	if(CharCount < 12)
	{
		ShowErrorStr(IDS_INVALSERIAL);
		CEdit * pSerEdit = (CEdit *) GetDlgItem(IDC_SerialNumber);  // get handle to Serial Number edit box
		pSerEdit->SetSel(0,-1) ; // select all the characters
		pSerEdit->Clear();
		pSerEdit->SetFocus();			// set focus to serial number

		return;
	}

	dwResult = GetGenealogyData(SerialNumber);
	if(SUCCESS != dwResult)
	{
		// show error dialog
		ShowErrorStr(dwResult);
		return;
	}

	// create eeprom image
	hResult = GeneratePerBoxDataEx(
		m_GenData.bHDKey,
		m_GenData.dwGameRegion,
		m_GenData.dwAVRegion,
		m_GenData.bMACAddress,
		m_GenData.cSerialNumber,
		m_GenData.bHDKey,
		m_GenData.cRecoveryKey,
		&m_GenData.dwOnlineKeyVersion,
		m_GenData.cOnlineKey,
		OutputBuffer,
		&dwBufferSize
		);

	if(SUCCESS != hResult)
	{
		// show error dialog
		ShowErrorStr(IDS_BADGEN);
		return;
	}
	Packet.dwCommand = DO_WRITEPERBOXDATA;
	memcpy(Packet.byteData,OutputBuffer,dwBufferSize);
	Packet.ulDataSize = dwBufferSize;
	cnError = SendVerifyXBoxCommand(&Packet);
	if(CNetSuccess != cnError)
	{
		ShowErrorStr(CNetErrorIDs[cnError]);
		return;
	}

	
	if(FALSE == m_fNoUpdate)
	{
		// Update genealogy database if update path was found in .ini file
		dwResult = UpdateGenealogy();
	}

	if(dwResult)
	{
		ShowErrorStr(dwResult);
		return;
	}

	ResetDlgButtons();  // end of processing wrapup
	ShowErrorStr(IDS_SUCCESSFULOP);
	return;

}


CNetErrors CRRConsoleDlg::SendVerifyXBoxCommand(PDATA_PACKET pPacket)
{
	DATA_PACKET RPacket;
	CNetErrors cnError;
	
	cnError = m_XBServer.SendData(m_XBServer.m_sXBClient,pPacket,sizeof(DATA_PACKET));

	if(CNetSuccess != cnError)
	{
		return SendFailed;
	}

	cnError = m_XBServer.RecvData(m_XBServer.m_sXBClient,&RPacket,sizeof(DATA_PACKET));

	if(CNetSuccess != cnError)
	{
		return ReceiveFailed;
	}

	if(RPacket.dwCommand != pPacket->dwCommand || RPacket.dwStatus != 0)
	{
		return XBCommandFailed;
	}
	return CNetSuccess;
}

// assumes that the m_GenData has the current Genealogy

#define ONLINEKEYSTR "OnLineKey>"
#define RECOVERYKEYSTR "RecoveryKey>"

DWORD CRRConsoleDlg::UpdateGenealogy()
{

	char *	pTemp;
	BOOL	fResult;
	DWORD	dwBytesWritten;

	HANDLE  hGenData;
	// need to replace online key, recovery key, date

	// build up xml file
	
	// locate online key tag in buffer
	pTemp = FindTaggedData(m_pBuffer,ONLINEKEYSTR);
	if(NULL == pTemp)
	{
		return IDS_BADPARSE;
	}

	memcpy(pTemp,m_GenData.cOnlineKey,sizeof(m_GenData.cOnlineKey)-1);
	
	pTemp = FindTaggedData(m_pBuffer,RECOVERYKEYSTR);
	if(NULL == pTemp)
	{
		return IDS_BADPARSE;
	}
	memcpy(pTemp,m_GenData.cRecoveryKey,4);
	// write back to gendata directory
	// reopen the file
	// rebuild path
	CString sGenDataPath(m_GenUpdate);
	if("\\" != sGenDataPath.Right(1))
	{
		sGenDataPath += "\\";
	}
	sGenDataPath += m_GenData.cSerialNumber;
	sGenDataPath += ".xml";
	hGenData = CreateFile(sGenDataPath,
						GENERIC_READ | GENERIC_WRITE,
						0,				// don't share
						NULL,			// don't inherit security
						OPEN_EXISTING,	// must exist
						FILE_ATTRIBUTE_NORMAL, // nothing special about the file
						NULL			// No template
						);

	
	if(INVALID_HANDLE_VALUE == hGenData)
	{
		DWORD dwResult = GetLastError();
		if(ERROR_PATH_NOT_FOUND == dwResult)
		{
			return IDS_NETWORKERROR;
		} else
		{
			return IDS_NOGENREC;
		}
	}
	// now write the file
	fResult = WriteFile(hGenData,m_pBuffer,m_dwFileSize,&dwBytesWritten,NULL);
	
	// and close the handle
	CloseHandle(hGenData);
	// free the buffer
	free(m_pBuffer);
	m_pBuffer = NULL;
	return CNetSuccess;

}

void CRRConsoleDlg::ResetDlgButtons()
{
	CEdit * pSerEdit = (CEdit *) GetDlgItem(IDC_SerialNumber);  // get handle to Serial Number edit box
	
	GetDlgItem(IDC_ConnectXBOX)->EnableWindow(TRUE);	// Enable Connect button
	pSerEdit->SetSel(0,-1) ; // select all the characters
	pSerEdit->Clear();
	pSerEdit->SetFocus();	// reset focus for serial number input
	GetDlgItem(IDC_HDReplace)->EnableWindow(FALSE);		// disable hdkey button
	GetDlgItem(IDC_VerifyXBox)->EnableWindow(FALSE);		// disable newxkey button
	GetDlgItem(IDRESET)->EnableWindow(FALSE);
	GetDlgItem(IDC_VerifyOnly)->EnableWindow(FALSE);
	((CStatic *)GetDlgItem(IDC_STOPNGO))->SetBitmap(*m_pbmRed);
	// ensure file buffer freed
	if(NULL != m_pBuffer)
	{
		free(m_pBuffer);
		m_pBuffer = NULL;
	}

	return;

}

void CRRConsoleDlg::OnCompleteXBox() 
{
	CNetErrors cnError;
	DATA_PACKET Packet;
	CString MessageStr,CapStr;
	MessageStr.LoadString(IDS_WARNMFR);
	CapStr.LoadString(IDS_CAPWARN);
	int iResult = MessageBox(MessageStr,CapStr,MB_YESNO);
	if(IDNO == iResult)
	{
		ShowErrorStr(IDS_CANCELED);
		return;
	}
	Packet.dwCommand = DO_VERIFYPERBOXDATA;
	cnError = SendVerifyXBoxCommand(&Packet);

	if(CNetSuccess != cnError)
	{
		// had an error, display message box
		ShowErrorStr(CNetErrorIDs[cnError]);
	} else
	{
		ShowErrorStr(IDS_SUCCESSFULOP);
	}

	ResetDlgButtons();  // end of processing wrapup
	return;	
}


/*
void CRRConsoleDlg::OnClose() 
{
	CDialog::OnCancel();
}
*/

void CRRConsoleDlg::OnVerifyOnly() 
{
	CNetErrors cnError;
	DATA_PACKET Packet;
	
	Packet.dwCommand = DO_LOCK_HARDDRIVE;
	cnError = SendVerifyXBoxCommand(&Packet);

	if(CNetSuccess != cnError)
	{
		// had an error, display message box
		ShowErrorStr(CNetErrorIDs[cnError]);
	} else
	{
		ShowErrorStr(IDS_SUCCESSFULOP);
	}

	ResetDlgButtons();  // end of processing wrapup
	return;	
}

void CRRConsoleDlg::OnReset() 
{
	// TODO: Add your control notification handler code here
	ResetDlgButtons();  // end of processing wrapup
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\XBRRServer\CNetWork.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <xtl.h>
#include "..\\include\\datapacket.h"


typedef struct sockaddr_in SOCKADDER_IN;
typedef struct sockaddr SOCKADDR;

   CONST USHORT ADVERTISE_PORT = 5159;
   CONST USHORT COMMUNICATION_PORT = 5150;



class CNetWorkConnection{
public:

   INT SendData( LPVOID pvData, INT iSize);
   INT RecvData( LPVOID pvData, INT iSize);
   VOID SetConnection(SOCKET s){ sConnection = s; }

   ~CNetWorkConnection();
   CNetWorkConnection();
   CNetWorkConnection( SOCKET s){ sConnection = s;}

private:

   SOCKET sConnection;
};



class CNetWork {

private:
   DWORD  m_dwAcceptIndex;
   SOCKET sClient;

public:

   
   SOCKET Accept ( struct sockaddr FAR *addr, int FAR *addrlen );
   SOCKET Accept ( VOID );
   static DWORD WINAPI IpAdvertise( LPVOID lpParam );
   BOOL StartThread( LPTHREAD_START_ROUTINE lpStartAddress, LPVOID Param );

   ~CNetWork();
   CNetWork();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__220E7FD8_534A_4CF9_8A0F_BCFF4C09BDB0__INCLUDED_)
#define AFX_STDAFX_H__220E7FD8_534A_4CF9_8A0F_BCFF4C09BDB0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__220E7FD8_534A_4CF9_8A0F_BCFF4C09BDB0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	RRConsole.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\RRConsole\RRConsoleDlg.h ===
// RRConsoleDlg.h : header file
//

#if !defined(AFX_RRCONSOLEDLG_H__D8A8E625_4811_411D_B3D0_582CE9AC998E__INCLUDED_)
#define AFX_RRCONSOLEDLG_H__D8A8E625_4811_411D_B3D0_582CE9AC998E__INCLUDED_

#include "CNetwork.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRRConsoleDlg dialog

#define IniName "RRConsoleConfigV2.ini"
#define RED 0xFF0000

char * FindTaggedData(char * pInputBuff,char * szTargetStr);

class CRRConsoleDlg : public CDialog
{
// Construction
public:
	CBitmap * m_pbmRed;
	CRRConsoleDlg(CWnd* pParent = NULL);	// standard constructor
	void		ResetDlgButtons();
	DWORD		UpdateGenealogy();
	CNetErrors	SendVerifyXBoxCommand(PDATA_PACKET pPacket);
	CNetErrors	SendGenealogyData(char * pSerialNumber,GENDATA * pGenData);
	DWORD		GetGenealogyData(char * pSerialNumber);
	DWORD		GetHDKeyFromServer(char *, byte *);
	ShowErrorStr(UINT nID /* string id */);
	CNetErrors	UnlockHD(byte * HDKey);
	char *		m_pBuffer;
	DWORD		m_dwFileSize;
	void		OnOK() {;}; // disable OK default behavior

private:

	char		m_GenSource[MAX_PATH];
	char		m_GenAltSource[MAX_PATH];
	char 		m_GenUpdate[MAX_PATH];
	HICON		m_hIcon;
	CNetWork	m_XBServer;
	char		m_szXBIPString[20];
	char		m_szSFIPString[20];
	GENDATA		m_GenData;
	BOOL		m_fNoUpdate;
	BOOL		m_fAltExists;


// Dialog Data
	//{{AFX_DATA(CRRConsoleDlg)
	enum { IDD = IDD_RRCONSOLE_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRRConsoleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:


	// Generated message map functions
	//{{AFX_MSG(CRRConsoleDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnConnectXBOX();
	afx_msg void OnHDReplace();
	afx_msg void OnCompleteXBox();
	afx_msg void OnClose();
	afx_msg void OnVerifyOnly();
	afx_msg void OnReset();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RRCONSOLEDLG_H__D8A8E625_4811_411D_B3D0_582CE9AC998E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\XBRRServer\cnetwork.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================


#include <xtl.h>
#include <winsockx.h>
#include <tchar.h>
#include <stdio.h>
#include "CNetWork.h"


CNetWork::CNetWork()
{                                                  

	WSADATA       wsa;
	SOCKADDER_IN local;
	XNetStartupParams xnsp = {sizeof(XNetStartupParams ),
							 XNET_STARTUP_BYPASS_SECURITY};    
	// Must call to get the net stack working.
	XNetStartup(&xnsp);
	// Start the IpAdvertise thread.
	StartThread( IpAdvertise, (LPVOID)this);


	m_dwAcceptIndex = 0;
	if ( -1 == WSAStartup( MAKEWORD(2,2), &wsa) )
	{
		return; // failure, no recovery
	}
	// Create our listening socket
	sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sClient == SOCKET_ERROR) 
	{
		return; // fail, no recovery
	}
	local.sin_addr.s_addr = htonl(INADDR_ANY);
	local.sin_family = AF_INET;
	local.sin_port = htons( COMMUNICATION_PORT );


	if (bind(sClient, (struct sockaddr *)&local, sizeof(local)) == SOCKET_ERROR) 
	{
		return; // fail, no recovery
	}
	listen(sClient, 10);
}



CNetWork::~CNetWork()
{

   closesocket(sClient);
   WSACleanup();
   XNetCleanup();
}




SOCKET 
CNetWork::
Accept (struct sockaddr FAR *addr,
        int FAR *addrlen )
{
   return accept(sClient,addr, addrlen);
}


SOCKET 
CNetWork::
Accept ( VOID )
{
	SOCKET	AcceptReturned;
	CHAR	szIpString[18]= "";

	struct	sockaddr_in  client;
	int		iAddrSize;

	iAddrSize = sizeof(client);
	AcceptReturned = accept(sClient,(struct sockaddr *)&client, &iAddrSize);

	if (AcceptReturned == INVALID_SOCKET) 
	{
		return -1; // fail
	}
	XNetInAddrToString(client.sin_addr,szIpString,sizeof(szIpString)/sizeof(CHAR));
	++m_dwAcceptIndex;
   
   return AcceptReturned;
}

BOOL
CNetWork::
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
        The Thread Function address.
        The Paremer to the function.
    Return Value:

--*/

{
   HANDLE   hThread;
	hThread = CreateThread(NULL,
                          0,
                          lpStartAddress,
                          (LPVOID)Param,
                          0,
                          NULL);
   if (hThread == NULL) 
   {
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}





DWORD WINAPI
CNetWork::
IpAdvertise( LPVOID lpParam )
{
   
   INT  iRet;
   SOCKET sBroadCast;
   BOOL   bBroadCast = TRUE;
   SOCKADDER_IN sddrFrom;
   char szInBuffer[20] = "";  // This zeroes the entire buffer if you didn't know this trick.
   XNADDR  xna = {sizeof(XNADDR)};
   INT  iFromLen;
   WSADATA       wsd;
   BOOL bStatus = TRUE;
   BYTE    byteIP[15] = "";
   CHAR    szIpString[18]= "";


	iRet = WSAStartup(MAKEWORD (2,2), &wsd);
	if (iRet != 0) 
	{
		WSACleanup();
		return FALSE;
	}
	int iRetries = 0;
	while (1)
	{
		// Do a recvfrom so we then broadcast out our IP
		sBroadCast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
		if (sBroadCast == SOCKET_ERROR) 
		{
			bStatus = FALSE;
			if(iRetries++ > 5)
			{
				// if we get 5 failures in a row,
				bStatus = FALSE;
				break;
			}
			continue;
		}

		// Set this to a broadcast socket.
		setsockopt(sBroadCast,SOL_SOCKET, SO_BROADCAST,(char *)&bBroadCast, sizeof(bBroadCast));
		sddrFrom.sin_family = AF_INET;
		sddrFrom.sin_addr.s_addr = htonl(INADDR_ANY) ;
		sddrFrom.sin_port = htons(ADVERTISE_PORT);

		if ( SOCKET_ERROR == bind(sBroadCast, (SOCKADDR *)&sddrFrom, sizeof(sddrFrom)))
		{
			closesocket( sBroadCast);
			if(iRetries++ > 5)
			{
				// if we get 5 failures in a row,
				bStatus = FALSE;
				break;
			}
			continue;
		}


		iFromLen =  sizeof(sddrFrom);
		iRet = recvfrom( sBroadCast,
				szInBuffer,
				20,
				0,
				(SOCKADDR *)&sddrFrom,
				&iFromLen);
		if(SOCKET_ERROR == iRet)
		{
			if(iRetries++ > 5)
			{
				// if we get 5 failures in a row,
				bStatus = FALSE;
				break;
			}
		}
		// inet_ntoa should use XNetInAddrToString
		XNetInAddrToString(sddrFrom.sin_addr,szIpString,sizeof(szIpString)/sizeof(CHAR));
		closesocket( sBroadCast);

		// Do a send of our IP.
		sBroadCast = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		RtlZeroMemory( &sddrFrom, sizeof(sddrFrom));
		if (sBroadCast == SOCKET_ERROR) 
		{
			bStatus = FALSE;
			continue;
		}

		// Sleep 2 second so we have time on the other end
		// To setup a receive.
		Sleep(2000);
		sddrFrom.sin_family      = AF_INET;
		sddrFrom.sin_addr.s_addr = inet_addr( szIpString );
		sddrFrom.sin_port        = htons(ADVERTISE_PORT);

		if (connect(sBroadCast, (struct sockaddr *)&sddrFrom, 
				  sizeof(sddrFrom)) == SOCKET_ERROR) 
		{
			closesocket( sBroadCast);
			if(iRetries++ > 5)
			{
				// if we get 5 failures in a row,
				bStatus = FALSE;
				break;
			}
			continue;
		}
		XNetGetTitleXnAddr( &xna );
		RtlCopyMemory(byteIP, (BYTE*) &xna.ina, sizeof(xna.ina));
		XNetInAddrToString(xna.ina, szIpString,sizeof(szIpString)/sizeof(CHAR));
		iRet = send(sBroadCast,(CHAR*)byteIP,sizeof(byteIP)/sizeof(CHAR), 0);
		if(SOCKET_ERROR == iRet)
		{
			if(iRetries++ > 5)
			{
				// if we get 5 failures in a row,
				bStatus = FALSE;
				break;
			}
			continue;
		}
		closesocket( sBroadCast);
	} // while(1)

	WSACleanup();
	return bStatus;
}


CNetWorkConnection::~CNetWorkConnection() 
{
   if (0 != sConnection )
      closesocket(sConnection);
}

INT 
CNetWorkConnection::
SendData( LPVOID pvData, INT iSize)
{

   INT ret;
   INT retTot = 0;

   PDATA_PACKET p =(PDATA_PACKET)pvData;
   // Send the data 
   while(iSize) {
       ret = send(sConnection,(const char*) pvData, iSize, 0);
       if(ret <= 0)
           return ret;
       pvData = (void*)((BYTE*)pvData + ret);
       iSize -= ret;
       retTot += ret;
   }
   return retTot;
}


INT 
CNetWorkConnection::
RecvData( LPVOID pvData, INT iSize)
{
   
   INT ret;
   INT retTot = 0;

   PDATA_PACKET p = (PDATA_PACKET)pvData;
   while(iSize) {
       ret = recv( sConnection,(char*)pvData, iSize, 0);
       if(ret <= 0)
           return ret;
       pvData = (void*)((BYTE*)pvData + ret);
       iSize -= ret;
       retTot += ret;
   }
   return retTot;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\XBRRServer\xbrrserver.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "XBRRServer.h"


void 
__cdecl main()
{
	CNetWork cn;
	SOCKET   sAccept;
//_asm Int 3      
	while (1) 
	{
		// Accept will block then thread will start.
		if ( INVALID_SOCKET == (sAccept= cn.Accept()))
		{
			WSACleanup();
			DebugPrint("INVALID_SOCKET on calling accept....\n");
			return; // fatal error, server dies
		}
		DebugPrint("Starting Server Session\n");
		StartThread( ServerSession,(LPVOID)sAccept);
   }
}




DWORD WINAPI 
ServerSession(LPVOID lpParam)
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    4/25/2001

    Routine Description:
        This is the thread function that will Do the receving work.
        it handles a given client connection.  The parameter passed 
        in is the socket handle returned from an accept() call.  
        This function reads data from the client and writes it back.

    Arguments:
        A Variable void pointer.
    Return Value:

--*/

{
   
   HRESULT hr;
   SOCKET  RecvSocket = (SOCKET)lpParam;
   CNetWorkConnection cnc( (SOCKET)lpParam );
   DATA_PACKET InBuffer;
   // Read Command Buffer.
   ZeroMemory(&InBuffer, sizeof(InBuffer));
   if ( SOCKET_ERROR == cnc.RecvData(&InBuffer, sizeof(InBuffer)))
   {
//		DebugPrint("SOCKET_ERROR on Receive Data....\n");
		ExitThread(0);
   }
//	DebugPrint("Processing command %d\n",InBuffer.dwCommand);
	
   switch(InBuffer.dwCommand)
   {
		case DO_WRITEPERBOXDATA:
			DoWritePerBoxData( &cnc,&InBuffer );  
			break;

		case DO_VERIFYPERBOXDATA:
			DoVerifyPerBoxData( &cnc, &InBuffer );
			break;

		case DO_LOCK_HARDDRIVE:
			LockHardDrive( &cnc, &InBuffer  );
			break;

		default:
			ReturnInvalidCommandError(&cnc, &InBuffer);
			break;

   }
	
	ExitThread(0);
}

HRESULT ReturnInvalidCommandError(IN CNetWorkConnection *c, PDATA_PACKET pPacket)
{
	HRESULT hr = S_OK;

	pPacket->dwStatus = ERROR_BAD_COMMAND;
   if ( SOCKET_ERROR == c->SendData(pPacket, sizeof(DATA_PACKET)))
   {
      hr = E_FAIL;
   }
   return hr;
}


HRESULT
DoWritePerBoxData(IN CNetWorkConnection *c, IN DATA_PACKET * pDataPacket)
{
	HRESULT hr = S_OK;

	pDataPacket->dwStatus = 0; // set initial status to success

	// Do the WritePerBoxData

	hr = WritePerBoxData( pDataPacket->byteData , pDataPacket->ulDataSize );

	if ( FAILED( hr ) )
	{

	  hr = E_FAIL;
	  pDataPacket->dwStatus = E_FAIL;
	}


// Send the STATUS back

   if ( SOCKET_ERROR == c->SendData(pDataPacket, sizeof(DATA_PACKET)))
   {
      hr = E_FAIL;
   }

   return hr;
}

// locks hard drive and clears mfg region
HRESULT
DoVerifyPerBoxData(IN CNetWorkConnection *c, PDATA_PACKET pPacket)
{
   HRESULT hResult = VerifyPerBoxData();

   pPacket->dwStatus = hResult;

   if ( SOCKET_ERROR == c->SendData(pPacket, sizeof(DATA_PACKET)))
   {
		DebugPrint("Sendback of Verify failed\n");
	   hResult = E_FAIL;
   }

   return hResult;
}

// locks hard drive but does not clear mfg region

HRESULT
LockHardDrive(IN CNetWorkConnection *c, PDATA_PACKET pPacket)
{
   HRESULT hResult = VerifyPerBoxDataEx(FALSE); // don't reset mfg region

   pPacket->dwStatus = hResult;

   if ( SOCKET_ERROR == c->SendData(pPacket, sizeof(DATA_PACKET)))
   {
		DebugPrint("Sendback of Verify failed\n");
	   hResult = E_FAIL;
   } else
   {
	   DebugPrint("Sendback of Verify Succeeded\n");
   }

   return hResult;
}



BOOL
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param )
/*++
 Copyright (c) 2000, Microsoft.

    Author:  Wally W. Ho (wallyho)
    Date:    5/7/2001

    Routine Description:
        This routine creates a thread.
    Arguments:
        The Thread Function address.
        The Paremeter to the function.
    Return Value:

--*/

{
   HANDLE   hThread;
   hThread = CreateThread(NULL,
                          0,
                          lpStartAddress,
                          (LPVOID)Param,
                          0,
                          NULL);
   if (hThread == NULL) {
      return FALSE;
   }
   CloseHandle(hThread);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\XBRRServer\xbrrserver.h ===
#include <ntos.h>  //ntos has to come before xtl.h
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <tchar.h>
#include <cryptkeys.h>

#include "PerBoxData.h"
#include "CNetWork.h"
//#include "..\\include\\fileformat.h"


#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Globals

// Prototypes
// debugprint from xapi.lib
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


#define FATAL 1


DWORD WINAPI 
ServerSession(LPVOID lpParam);

BOOL
StartThread( LPTHREAD_START_ROUTINE lpStartAddress, 
             LPVOID Param );
BOOL
WriteEEPROM ( IN PDATA_PACKET dpData );

HRESULT
ReadEEPROM ( IN PDATA_PACKET dpData );


VOID DebugOut (PCHAR szMessage,...);

HRESULT ReturnInvalidCommandError(IN CNetWorkConnection *c, IN PDATA_PACKET pPacket);

HRESULT
DoWritePerBoxData(IN CNetWorkConnection *c, IN PDATA_PACKET pDataPacket);

HRESULT
DoVerifyPerBoxData(IN CNetWorkConnection *c, IN PDATA_PACKET pPacket);
 
HRESULT
LockHardDrive(IN CNetWorkConnection *c, IN PDATA_PACKET pPacket);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ClientServer\XBRRServer\writeperboxdata.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <ntos.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include "PerBoxData.h"
#include "cryptkeys.h"

// #define WRITE_EEPROM_IMAGE_TO_FILE 1

// #define DOUBLE_CHECK_EEPROM_KEY 1

// #define TEMP_CODE_FOR_TESTING 1

#define EEPROM_TAIL_PRESERVE_BYTES 2

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

HRESULT VerifyEEPROMData();

HRESULT WritePerBoxData(
    IN LPBYTE pbInputBuffer,
    IN DWORD dwInputBufferSize
    )
{
    BOOL bResult;
    HRESULT hr;
    PXBOX_ENCRYPTED_PER_BOX_DATA pData;
    char RecoveryKey[8];
    BYTE inputBuffer[sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER)];
    
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    BYTE buf2[XBOX_KEY_LENGTH];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    int i;

    if ( dwInputBufferSize != sizeof(inputBuffer) )
    {
        return NTE_BAD_LEN;
    }

    //
    // Don't attempt anything unless we have a valid EEPROM key
    //

    if (RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH )) {
        return NTE_BAD_KEY;
    }

    //
    // Copy input data into new buffer
    //
    RtlCopyMemory( inputBuffer, pbInputBuffer, sizeof(inputBuffer) );
    
    bResult = rc4HmacDecrypt(
                    (LPBYTE)FACTORY_RAND_KEY, FACTORY_RAND_KEY_LEN,
                    inputBuffer + sizeof(RC4_SHA1_HEADER), sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
                    inputBuffer );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }

    //
    // Setup pointer to decrypted data
    //
    pData = (PXBOX_ENCRYPTED_PER_BOX_DATA)(inputBuffer + sizeof(RC4_SHA1_HEADER));
    
#if DBG
    XDBGTRC("factory", "OnlineKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        pData->OnlineKey[0], pData->OnlineKey[1],
        pData->OnlineKey[2], pData->OnlineKey[3],
        pData->OnlineKey[4], pData->OnlineKey[5],
        pData->OnlineKey[6], pData->OnlineKey[7],
        pData->OnlineKey[8], pData->OnlineKey[9],
        pData->OnlineKey[10], pData->OnlineKey[11],
        pData->OnlineKey[12], pData->OnlineKey[13],
        pData->OnlineKey[14], pData->OnlineKey[15]
        );

    XDBGTRC("factory", "HardDriveKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        pData->HardDriveKey[0], pData->HardDriveKey[1],
        pData->HardDriveKey[2], pData->HardDriveKey[3],
        pData->HardDriveKey[4], pData->HardDriveKey[5],
        pData->HardDriveKey[6], pData->HardDriveKey[7],
        pData->HardDriveKey[8], pData->HardDriveKey[9],
        pData->HardDriveKey[10], pData->HardDriveKey[11],
        pData->HardDriveKey[12], pData->HardDriveKey[13],
        pData->HardDriveKey[14], pData->HardDriveKey[15]
        );

    ComputeRecoveryKey( pData->HardDriveKey, RecoveryKey );
    XDBGTRC("factory", "RecoveryKey: %.8s", RecoveryKey);

    XDBGTRC("factory", "MACAddress: %.6s", pData->MACAddress);

    XDBGTRC("factory", "XboxSerialNumber: %.12s", pData->XboxSerialNumber);
    
    XDBGTRC("factory", "GameRegion: %X", pData->GameRegion);

    XDBGTRC("factory", "AVRegion: %X", pData->AVRegion);
#endif

    //
    // Check some basic assumptions
    //
    ASSERT( sizeof(RC4_SHA1_HEADER) == sizeof(pEncryptedEEPROMData->EncHeader) );
    ASSERT( EEPROM_ENCRYPTED_SECTION_SIZE == sizeof(*pEncryptedEEPROMData) );

    // 
    // read EEPROM Data, some tail bytes need to be preserved.
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Make an attempt to unlock the HD before we try anything
    //

    UnlockXboxHardDrive(NULL, 0);


    //
    // Zero out the EEPROM buffer
    //
    RtlZeroMemory( buf, EEPROM_TOTAL_MEMORY_SIZE - EEPROM_TAIL_PRESERVE_BYTES );

    //
    // Get some pointers ready
    //
    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;
    
    //
    // Get encrypted EEPROM contents ready
    //
    pEncryptedEEPROMData->GameRegion = pData->GameRegion;
    pEncryptedEEPROMData->GameRegion |= XC_GAME_REGION_MANUFACTURING;
    RtlCopyMemory( pEncryptedEEPROMData->HardDriveKey, pData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) );

    //
    // Place in ROM slot for future use
    //
    ASSERT( XBOX_KEY_LENGTH == sizeof(pEncryptedEEPROMData->HardDriveKey) );
    RtlCopyMemory( (LPBYTE)(*XboxHDKey), pData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) );

    //
    // Encrypt the encrypted part and copy it into the EEPROM buffer
    //
    rc4HmacEncrypt(
        inputBuffer, (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    //
    // Get factory settings ready
    //
    RtlCopyMemory( factorySettings->SerialNumber, pData->XboxSerialNumber, sizeof(factorySettings->SerialNumber) );
    ASSERT( sizeof(factorySettings->SerialNumber) == sizeof(pData->XboxSerialNumber) );
    RtlCopyMemory( factorySettings->EthernetAddr, pData->MACAddress, sizeof(factorySettings->EthernetAddr) );
    ASSERT( sizeof(factorySettings->EthernetAddr) == sizeof(pData->MACAddress) );
    RtlCopyMemory( factorySettings->OnlineKey, pData->OnlineKey, sizeof(factorySettings->OnlineKey) );
    ASSERT( sizeof(factorySettings->OnlineKey) == sizeof(pData->OnlineKey) );

#if DBG
    ASSERT( XBOX_KEY_LENGTH == sizeof(factorySettings->OnlineKey) );
    RtlCopyMemory( buf2, factorySettings->OnlineKey, XBOX_KEY_LENGTH );
    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    ASSERT(RtlEqualMemory( buf2, factorySettings->OnlineKey, XBOX_KEY_LENGTH ));
    RtlZeroMemory( buf2, XBOX_KEY_LENGTH );
#endif

    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    factorySettings->AVRegion = pData->AVRegion;
    factorySettings->Checksum = ~XConfigChecksum(factorySettings, sizeof(*factorySettings));
    
    //
    // Get user Settings ready
    //
    if ( pData->GameRegion & XC_GAME_REGION_JAPAN )
    {
        userSettings->Language = XC_LANGUAGE_JAPANESE;
    }
    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));

    //
    // Copy EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    //
    // Zero out the memory
    //
    RtlZeroMemory( inputBuffer, sizeof(inputBuffer) );
    RtlZeroMemory( buf, sizeof(buf) );
    
    //
    // Verify the written data to double check
    //
    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Once again, try to unlock the HD in case the new key is the one we want
    // rather than the old key
    //

    UnlockXboxHardDrive(NULL, 0);

    
    return S_OK;
}


HRESULT VerifyEEPROMData()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // check checksums
    //
    if (XConfigChecksum(factorySettings, sizeof(*factorySettings)) != 0xffffffff ||
        XConfigChecksum(userSettings, sizeof(*userSettings)) != 0xffffffff)
    {
        return NTE_BAD_DATA;
    }

    //
    // Use the EEPROM-KEY to decrypt the EEPROM and verify the checksum
    //

    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}


HRESULT VerifyPerBoxData(void)
{
    return VerifyPerBoxDataEx(TRUE);
}

HRESULT VerifyPerBoxDataEx(BOOL fResetRegionBits)
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    
    //
    // Verify the EEPROM data first
    //
    hr = VerifyEEPROMData();
    if (FAILED(hr))
    {
        return hr;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //

    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    if ( !bResult )
    {
        return NTE_BAD_DATA;
    }

    if(fResetRegionBits) {
        //
        // Clear the manufacturing region flag
        //
        pEncryptedEEPROMData->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;
    }

    //
    // Double check the hard drive key
    //
    ASSERT( HARD_DRIVE_KEY_LEN == XBOX_KEY_LENGTH );
    if (!RtlEqualMemory( pEncryptedEEPROMData->HardDriveKey, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"HardDriveKey does not match");
        return NTE_BAD_KEY;        
    }
    
    //
    // Encrypt the encrypted part back again
    //
    rc4HmacEncrypt(
        (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    //
    // Compute Key to use to lock hard drive and lock it
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
                         
    HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );    
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}


BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

HRESULT UnlockXboxHardDrive (
    IN LPBYTE pbHardDriveKey,
    IN DWORD dwHardDriveKeySize
    )
{
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    if ( pbHardDriveKey == NULL )
    {
        //
        // Use the key the ROM read from the EEPROM
        //
        pbHardDriveKey = (LPBYTE)(*XboxHDKey);
        dwHardDriveKeySize = XBOX_KEY_LENGTH;
    }
    else
    {
        ASSERT( XBOX_KEY_LENGTH == dwHardDriveKeySize );
        if ( dwHardDriveKeySize != XBOX_KEY_LENGTH )
        {
            return NTE_BAD_LEN;
        }
    }
    
    //
    // Compute Key to use and unlock hard drive
    //
    XcHMAC( pbHardDriveKey, dwHardDriveKeySize,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
                         
    HDDisablePassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );

    return S_OK;
}



HRESULT DecryptDevKitEEPROM()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        return S_OK;
    }

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // if encrypted then decrypt the EEPROM
    //
    if ( !RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) )
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }

        //
        // Check that Hard drive key is the zero key
        //
        ASSERT( RtlEqualMemory( ZERO_KEY, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH ) );
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
        
        //
        // Save EEPROM Data into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\CreateCert\CreateCert.cpp ===
//===================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright 1998-1999. Microsoft Corporation. All Right Reserved.
// File: CreateCert.c
//
// This sample demonstrates how to create Certificates using CryptoAPI.
// The sample lets the user create Self-Signed Certificates or
// create Certificates signed by another Certificate.
//
// When a Self-Signed Certificate is created a file called
// SelfSigned.cer is created.  The file can be ran to trust
// the certificate as a Certificate Authority.
//
// When a non Self-Signed Certificate is created a file called
// Certificate.cer is created.  This can be used on Windows 2000
// to install the certificate under the "AddressBook" store for
// example.  Only the public key information is stored in the
// certificate.
//
//===================================================================
#include <windows.h>
#include <wincrypt.h>
#include <rpc.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "CreateCert.h"


#define KEY_USAGE_SIZE 5

// This is 1024 bits
#define PK_KEY_SIZE 0x04000000

// This is 2048 bits
//#define PK_KEY_SIZE 0x08000000

#define REPEAT_LOOP 1
#define VERIFY_LOOP 1000
#define SIGN_LOOP 1000

#define PROVIDER MS_ENHANCED_PROV
//#define PROVIDER MS_DEF_PROV

#define ENCODING (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

// This structure will be used to calculate
// the Enhanced Key Usage Extension from an
// integer
typedef struct tagEnhKeyUsage
{
   DWORD dwCount;
   LPSTR szUsage[KEY_USAGE_SIZE];
   DWORD dwValue[KEY_USAGE_SIZE];
} ENHKEYUSAGE;

// Every Enhanced Usage Extension has a
// corresponding number to it.  Just add
// the number to set the appropriate
// extension:
// Server Authentication   1
// Client Authentication   2
// Code Signing            4
// Email Protection        8
// Time Stamping           16
ENHKEYUSAGE g_EnhKeyUsage =
{
   KEY_USAGE_SIZE,
   {
      szOID_PKIX_KP_SERVER_AUTH,
      szOID_PKIX_KP_CLIENT_AUTH,
      szOID_PKIX_KP_CODE_SIGNING,
      szOID_PKIX_KP_EMAIL_PROTECTION,
      szOID_PKIX_KP_TIMESTAMP_SIGNING
   },
   { 1, 2, 4, 8, 16}
};

LPSTR g_szSigAlg[] = {
   szOID_RSA_MD5RSA,
   szOID_RSA_SHA1RSA
};

// Default store and empty string
LPSTR g_szMyStore = "MY";
LPSTR g_szEmpty = "";

HRESULT VerifyKeyPair( LPBYTE pbEncodedCert, DWORD dwCertSize, HCRYPTPROV hPrvProv );

int __cdecl main(int argc, char *argv[])
{
   BOOL bResult;
   DWORD dwUsage = 0;
   DWORD dwKeyType = AT_KEYEXCHANGE;
   DWORD dwProvNum = 0;
   LPSTR szSigAlg = g_szSigAlg[1];
   BOOL bExport = FALSE;
   BOOL bSelfSigned = TRUE;
   BOOL bIssuerUser = TRUE;
   BOOL bSubjectUser = TRUE;
   BOOL bUseProv = FALSE;
   LPSTR szX509 = NULL;
   LPSTR szSubjectStore = g_szMyStore;
   LPSTR szIssuerStore = g_szMyStore;
   LPSTR szIssuerName = g_szEmpty;
   LPSTR szCertFile = g_szEmpty;
   LPSTR szKeyFile = g_szEmpty;
   LPSTR szPassword = g_szEmpty;
   WORD wMonths = 0;
   BOOL bCA = FALSE;
   int n;
   int i;
   DWORD dwStart;
   
   // Print Usage
   if (argc < 2)
   {
     PrintUsage();
     return 0;
   }


   // User wants to import a certificate
   if (_stricmp(argv[1], "-i") == 0)
   {
      BOOL bUser;
      DWORD num;

      if (argc != 8)
      {
         PrintUsage();
         return 0;
      }

      if (_stricmp(argv[6], "m") == 0)
         bUser = FALSE;
      else
         bUser = TRUE;

      num = (DWORD)atoi(argv[7]);

      bResult = ImportCertificate(argv[2],
                                argv[3],
                                argv[4],
                                argv[5],
                                bUser,
                                num);
      if (!bResult)
      {
         printf("Unable to Import Certificate\n");
         return 0;
      }
      else
      {
         printf("Certificate Imported successfully\n");
         return 1;
      }
   }

   // Set X509 Name
   szX509 = argv[1];

   // Parse rest of the options
   n = 2;
   while (n < argc)
   {
    // User selected Key Type
    if (_stricmp(argv[n], "-k") == 0)
    {
      if ((n+1) < argc)
      {
         if (_stricmp(argv[++n], "s") == 0)
           dwKeyType = AT_SIGNATURE;
         else
           dwKeyType = AT_KEYEXCHANGE;
      }
      else
      {
         PrintUsage();
         return 0;
      }
    }

    // User set number of months
    if (_stricmp(argv[n], "-m") == 0)
    {
       if ((n+1) < argc)
       {
          wMonths = (WORD)atoi(argv[++n]);
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    // User wants this to be a CA.  Indicated in
    // Basic contraints
    if (_stricmp(argv[n], "-ca") == 0)
    {
       bCA = TRUE;
    }

    // User wants to set Enhanced Key usage extension
    if (_stricmp(argv[n], "-u") == 0)
    {
      if ((n+1) < argc)
      {
         dwUsage = (DWORD)atoi(argv[++n]);
      }
      else
      {
         PrintUsage();
         return 0;
      }
    }

    // User wants to set the Crypto Provider
    if (_stricmp(argv[n], "-p") == 0)
    {
       if ((n+1) < argc)
       {
          bUseProv = TRUE;
          dwProvNum = (DWORD)atoi(argv[++n]);
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    // User selected signature algorithm
    if (_stricmp(argv[n], "-s") == 0)
    {
       if ((n+1) < argc)
       {
          if (_stricmp(argv[++n], "md5") == 0)
             szSigAlg = g_szSigAlg[0];
          else
             szSigAlg = g_szSigAlg[1];
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    // User selected the Subject Location
    if (_stricmp(argv[n], "-sl") == 0)
    {
       if ((n+2) < argc)
       {
          bExport = FALSE;
          szSubjectStore = argv[++n];
          if (_stricmp(argv[++n], "m") == 0)
             bSubjectUser = FALSE;
          else
             bSubjectUser = TRUE;
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    // User wants to export the Certificate
    if (_stricmp(argv[n], "-ex") == 0)
    {
       if ((n+3) < argc)
       {
          bExport = TRUE;
          szCertFile = argv[++n];
          szKeyFile = argv[++n];
          szPassword = argv[++n];
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    // User has selected an issuer
    if (_stricmp(argv[n], "-is") == 0)
    {
       if ((n+3) < argc)
       {
          bSelfSigned = FALSE;
          szIssuerName = argv[++n];
          szIssuerStore = argv[++n];
          if (_stricmp(argv[++n], "m") == 0)
             bIssuerUser = FALSE;
          else
             bIssuerUser = TRUE;
       }
       else
       {
          PrintUsage();
          return 0;
       }
    }

    n++;
   }

   dwStart = GetTickCount();

   for (i=0; i<REPEAT_LOOP; ++i)
   {
       // Create Certificate
       bResult = CreateCertificate(
                         szX509,        // Certificate Name
                         dwKeyType,     // Key Type
                         szSigAlg,      // Signature Algorithm
                         wMonths,       // Number of Months
                         dwUsage,       // Enhanced Key Usage
                         bCA,           // CA or not
                         bUseProv,      // Use dwProvNum
                         dwProvNum,     // Provider Number
                         szSubjectStore,// Certificate Store
                         bSubjectUser,  // User or Machine flag
                         bSelfSigned,   // Self Signed flag
                         szIssuerName,  // Issuer of Certificate
                         szIssuerStore, // Store of Issuer
                         bIssuerUser,   // User or Machine flag
                         bExport,       // Export flag
                         szCertFile,    // Certificate File
                         szKeyFile,     // Key File
                         szPassword);   // Password for Key File
       if (!bResult)
       {
         printf("Unable to create certificate\n");
       }
   }

   printf("Creating %d certificates took %d milliseconds\n", REPEAT_LOOP, GetTickCount() - dwStart);

   return 1;
}

//
// ImportCertificate installs the crpto provider and certificate
// on the machine.
//
BOOL ImportCertificate(LPSTR szCertFile, LPSTR szKeyFile, LPSTR szPassword,
                  LPSTR szStore, BOOL bUser, DWORD dwProviderNum)
{
   LPWSTR szwContainer = NULL;
   HCRYPTPROV hProv = 0;
   HCRYPTHASH hHash = 0;
   HCERTSTORE hStore = NULL;
   HCRYPTKEY hKey = 0;
   HCRYPTKEY hPubKey = 0;
   HANDLE hFile = INVALID_HANDLE_VALUE;
   LPBYTE pbEncodedCert = NULL;
   LPBYTE pbEncodedKey = NULL;
   PCCERT_CONTEXT pCertContext = NULL;
   CRYPT_KEY_PROV_INFO CertKeyInfo;
   CERT_KEY_CONTEXT certKeyContext;
   BOOL fReturn = FALSE;
   RPC_STATUS Status;
   HANDLE hHeap;
   UUID Uuid;
   BOOL bResult;
   DWORD dwSize, dwRead;
   WCHAR szwStore[200];
   WCHAR szwCertFile[200];
   WCHAR szwKeyFile[200];
   DWORD dwAcquireFlags = 0;
   DWORD dwCertOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
   WCHAR szwProvider[260] = { PROVIDER };
   DWORD dwProviderType = PROV_RSA_FULL;
   HRESULT hr;
   int i;

   // Get process heap
   hHeap = GetProcessHeap();

   __try
   {
     if (!bUser)
     {
        dwAcquireFlags = CRYPT_MACHINE_KEYSET;
        dwCertOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
     }

     dwSize = 260;
     bResult = MyCryptEnumProviders(dwProviderNum,
                                    &dwProviderType,
                                    szwProvider,
                                    &dwSize);
     if (!bResult)
     {
        printf("Unable to get provider\n");
        __leave;
     }

     // Convert multibyte store name to wide char string
     i = MultiByteToWideChar(CP_ACP, 0, szKeyFile, -1, szwKeyFile, 200);
     if (i == 0)
     {
       printf("Unable to convert szKeyFile to Unicode string\n");
       __leave;
     }

     // Open Key File
     hFile = CreateFile(szwKeyFile,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
     if (hFile == INVALID_HANDLE_VALUE)
     {
         printf("Unable to open key file\n");
         __leave;
     }

     // Get file length
     dwSize = GetFileSize(hFile, NULL);
     if (dwSize == 0xFFFFFFFF)
     {
       printf("Unable to get size of certificate file\n");
       __leave;
     }

     // Allocate memory for encoded key
     pbEncodedKey = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
     if (!pbEncodedKey)
     {
       printf("Unable to allocate memory for encoded key\n");
       __leave;
     }

     // Read encoded key data
     bResult = ReadFile(hFile,
                    (LPVOID)pbEncodedKey,
                    dwSize,
                    &dwRead,
                    NULL);
     if (!bResult)
     {
       printf("Unable to read encoded key\n");
       __leave;
     }

     // Close file handle
     CloseHandle(hFile);
     hFile = INVALID_HANDLE_VALUE;

     {
        HCRYPTPROV hTemp;

        // Create Temporary Provider
        bResult = CryptAcquireContext(&hTemp,
                                      L"Temp000",
                                      PROVIDER,
                                      PROV_RSA_FULL,
                                      CRYPT_NEWKEYSET);
        if (!bResult)
        {
           // If Temporary Provider exists already,
           // open it
           if (GetLastError() == NTE_EXISTS)
           {
              bResult = CryptAcquireContext(&hTemp,
                                          L"Temp000",
                                          PROVIDER,
                                          PROV_RSA_FULL,
                                          0);
              if (!bResult)
              {
                 printf("Unable to get temporary provider handle\n");
                 __leave;
              }
           }
           else
           {
              printf("Unable to create temporary provider handle\n");
              __leave;
           }
        }

        // Place random data in Uuid
        // Could have used UuidCreate but it is not supported
        // under Win9x.
        bResult = CryptGenRandom(hTemp, sizeof(Uuid), (LPBYTE)&Uuid);
        if (!bResult)
        {
           printf("CryptGenRandom failed with %x\n", GetLastError());
           __leave;
        }

        // Close Provider handle
        CryptReleaseContext(hTemp, 0);

        // Delete Container
        CryptAcquireContext(&hTemp,
                           L"Temp000",
                           PROVIDER,
                           PROV_RSA_FULL,
                           CRYPT_DELETEKEYSET);

        // convert random uuid to a string, we will use it as a container
        Status = UuidToString(&Uuid, &szwContainer);
        if (Status != RPC_S_OK)
        {
          printf("Unable to convert uuid to string\n");
          __leave;
        }
     }

     // Create new crypto context
     bResult = CryptAcquireContext(&hProv,
                            szwContainer,
                            szwProvider,
                            dwProviderType,
                            CRYPT_NEWKEYSET | dwAcquireFlags);
     if (!bResult)
     {
       printf("CryptAcquireContext failed with %x\n", GetLastError());
       __leave;
     }

     if (_stricmp( szPassword, "null" ) != 0)
     {
         // Create Hash to hash password
         bResult = CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash);
         if (!bResult)
         {
           printf("CryptCreateHash failed with %x\n", GetLastError());
           __leave;
         }

         // Hash Password
         bResult = CryptHashData(hHash, (LPBYTE)szPassword, strlen(szPassword), 0);
         if (!bResult)
         {
           printf("CryptHashData failed with %x\n", GetLastError());
           __leave;
         }

         // Derive Session Key from password hash
         bResult = CryptDeriveKey(hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey);
         if (!bResult)
         {
           printf("CryptDeriveKey failed with %x\n", GetLastError());
           __leave;
         }
     }

     // Import Private/Public Key into Provider
     bResult = CryptImportKey(hProv, pbEncodedKey, dwSize, hKey,
                        CRYPT_EXPORTABLE, &hPubKey);
     if (!bResult)
     {
       printf("CryptImportKey failed with %x\n", GetLastError());
       __leave;
     }

     // Convert multibyte store name to wide char string
     i = MultiByteToWideChar(CP_ACP, 0, szCertFile, -1, szwCertFile, 200);
     if (i == 0)
     {
       printf("Unable to convert szCertFile to Unicode string\n");
       __leave;
     }
     
     // Open Certificate file
     hFile = CreateFile(szwCertFile,
                   GENERIC_READ,
                   0,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);
     if (hFile == INVALID_HANDLE_VALUE)
     {
       printf("Unable to open certificate file\n");
       __leave;
     }

     // Get file length
     dwSize = GetFileSize(hFile, NULL);
     if (dwSize == 0xFFFFFFFF)
     {
       printf("Unable to get size of certificate file\n");
       __leave;
     }

     // Allocate memory for encoded certificate
     pbEncodedCert = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
     if (!pbEncodedCert)
     {
       printf("Unable to allocate memory for encoded certificate\n");
       __leave;
     }

     // Read encoded certificate data
     bResult = ReadFile(hFile,
                    (LPVOID)pbEncodedCert,
                    dwSize,
                    &dwRead,
                    NULL);
     if (!bResult)
     {
       printf("Unable to read encoded certificate\n");
       __leave;
     }

     // Close file handle
     CloseHandle(hFile);
     hFile = INVALID_HANDLE_VALUE;

	 //
	 // Verify that the key pair matches
	 //
     hr = VerifyKeyPair( pbEncodedCert, dwSize, hProv );
	 if ( hr == S_OK )
     {
		printf("VerifyKeyPair succeeded\n");
     }
		
     // Convert multibyte store name to wide char string
     i = MultiByteToWideChar(CP_ACP, 0, szStore, -1, szwStore, 200);
     if (i == 0)
     {
       printf("Unable to convert store to Unicode string\n");
       __leave;
     }

     // Open Certificate Store
     hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                      ENCODING,
                      0,
                      dwCertOpenFlags,
                      (LPVOID)szwStore);
     if (!hStore)
     {
       printf("CertOpenStore failed with %x\n", GetLastError());
       __leave;
     }

     // Add Certificate to store
     bResult = CertAddEncodedCertificateToStore(hStore,
                                     X509_ASN_ENCODING,
                                     pbEncodedCert,
                                     dwSize,
                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                     &pCertContext);
     if (!bResult)
     {
       printf("CertAddEncodedCertificateToStore failed with %x\n", GetLastError());
       __leave;
     }

     {
        ZeroMemory(&CertKeyInfo, sizeof(CertKeyInfo));
        CertKeyInfo.pwszContainerName = szwContainer;
        CertKeyInfo.pwszProvName = szwProvider;
        CertKeyInfo.dwProvType = dwProviderType;

        CertKeyInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
        CertKeyInfo.cProvParam = 0;
        CertKeyInfo.rgProvParam = NULL;
        CertKeyInfo.dwFlags |= CERT_SET_KEY_CONTEXT_PROP_ID;

        dwSize = sizeof(CertKeyInfo.dwKeySpec);
        bResult = CryptGetKeyParam(hPubKey, KP_ALGID, (LPBYTE)&CertKeyInfo.dwKeySpec,
                            &dwSize, 0);
        if (!bResult)
        {
          printf("CryptGetKeyParam failed with %x\n", GetLastError());
          __leave;
        }

        // Set Key property for Certificate
        bResult = CertSetCertificateContextProperty(pCertContext,
                                         CERT_KEY_PROV_INFO_PROP_ID,
                                         0,
                                         (LPVOID)&CertKeyInfo);
        if (!bResult)
        {
          printf("CertSetCertificateContextProperty failed with %x\n", GetLastError());
          __leave;
        }
        
        certKeyContext.cbSize = sizeof(CERT_KEY_CONTEXT);
        certKeyContext.hCryptProv = hProv;
        certKeyContext.dwKeySpec = CertKeyInfo.dwKeySpec;

        bResult = CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_KEY_CONTEXT_PROP_ID,
                    0,
                    (void *)&certKeyContext);
        if (!bResult)
        {
          printf("CertSetCertificateContextProperty CERT_KEY_CONTEXT_PROP_ID failed with %x\n", GetLastError());
          __leave;
        }
     }

     fReturn = TRUE;
   }
   _finally
   {
     // Clean up
     if (szwContainer) RpcStringFree(&szwContainer);
     if (hHash) CryptDestroyHash(hHash);
     if (hKey) CryptDestroyKey(hKey);
     if (hPubKey) CryptDestroyKey(hPubKey);
     if (hProv) CryptReleaseContext(hProv, 0);
     if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
     if (pbEncodedCert) HeapFree(hHeap, 0, pbEncodedCert);
     if (pbEncodedKey) HeapFree(hHeap, 0, pbEncodedKey);
     if (pCertContext) CertFreeCertificateContext(pCertContext);
     if (hStore) CertCloseStore(hStore, 0);
   }

   return fReturn;
}

BOOL CreateCertificate(LPSTR szX509, DWORD dwKeyType,
                       LPSTR szSigAlg, WORD wMonths,
                       DWORD dwUsage, BOOL bCA, BOOL bUseProv,
                       DWORD dwProviderNum, LPSTR szSubjectStore,
                       BOOL bSubjectUser, BOOL bSelfSigned,
                       LPSTR szIssuerName, LPSTR szIssuerStore,
                       BOOL bIssuerUser, BOOL bExport,
                       LPSTR szCertFile, LPSTR szKeyFile,
                       LPSTR szPassword)
{
   BOOL bReturn = FALSE;
   BOOL bResult;
   LPBYTE pbNameBlob = NULL;
   LPWSTR szwContainer = NULL;
   RPC_STATUS Status;
   HCRYPTPROV hProv = 0;
   HCRYPTPROV hIssuerProv = 0;
   HCRYPTKEY hPubKey = 0;
   HCRYPTKEY hSessionKey = 0;
   HCRYPTHASH hHash = 0;
   HCERTSTORE hStore = 0;
   HANDLE hCertFile = INVALID_HANDLE_VALUE;
   HANDLE hKeyFile = INVALID_HANDLE_VALUE;
   PCRYPT_DATA_BLOB KeyId = NULL;
   PCERT_PUBLIC_KEY_INFO PublicKeyInfo = NULL;
   PCCERT_CONTEXT pIssuerCert = NULL;
   PCCERT_CONTEXT pCertContext = NULL;
   LPBYTE pbKeyIdentifier = NULL;
   LPBYTE SubjectKeyIdentifier = NULL;
   LPBYTE pbKeyUsage = NULL;
   LPBYTE pbEnhKeyUsage = NULL;
   LPBYTE pbBasicConstraints = NULL;
   LPBYTE pbAuthorityKeyId = NULL;
   LPBYTE bpEncodedCert = NULL;
   LPBYTE pbExportedKey = NULL;
   CERT_ENHKEY_USAGE CertEnhKeyUsage = { 0, NULL };
   BYTE SerialNumber[8];
   CERT_BASIC_CONSTRAINTS2_INFO BasicConstraints;
   CERT_AUTHORITY_KEY_ID_INFO AuthorityKeyId;
   BYTE ByteData;
   CRYPT_BIT_BLOB KeyUsage;
   CERT_EXTENSION CertExtension[5];
   CRYPT_DATA_BLOB CertKeyIdentifier;
   CERT_NAME_BLOB IssuerName;
   HANDLE hHeap = GetProcessHeap();
   CERT_INFO CertInfo;
   DWORD dwSize, m, q;
   DWORD dwAcquireFlags, dwIssuerKeyType = 0;
   DWORD dwIssuerFlags, dwSubjectFlags;
   FILETIME ftTime;
   SYSTEMTIME stTime;
   WCHAR szwCertFile[200];
   WCHAR szwKeyFile[200];
   WCHAR szwX509[2000];
   WCHAR szwProvider[260] = { PROVIDER };
   DWORD dwProviderType = PROV_RSA_FULL;
   BOOL bAddAuthorityExtension = FALSE;
   WCHAR szwStoreContainer[20];
   DWORD dwStart;
   int i;
   
   __try
   {
      // Enumerate Provider
      if (bUseProv)
      {
         dwSize = 260;
         bResult = MyCryptEnumProviders(
                           dwProviderNum,
                           &dwProviderType,
                           szwProvider,
                           &dwSize);
         if (!bResult)
         {
            printf("Unable to get provider\n");
            __leave;
         }

      }

      if (bSubjectUser)
      {
         // Certificate will be in the User store and
         // key container will be a User container
         dwAcquireFlags = 0;
         dwSubjectFlags = CERT_SYSTEM_STORE_CURRENT_USER;
      }
      else
      {
         // Certificate will be in the Machine store and
         // key container will be a Mahince container
         dwAcquireFlags = CRYPT_MACHINE_KEYSET;
         dwSubjectFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
      }

      if (bIssuerUser)
      {
         // Get Issuer Certificate from User store
         dwIssuerFlags = CERT_SYSTEM_STORE_CURRENT_USER;
      }
      else
      {
         // Get Issuer Certificate from Machine store
         dwIssuerFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
      }

      // Convert multibyte store name to wide char string
   	  i = MultiByteToWideChar(CP_ACP, 0, szX509, -1, szwX509, 2000);
      if (i == 0)
   	  {
	       printf("Unable to convert szX509 to Unicode string\n");
	       __leave;
      }
     
      // Get X509 Name and convert it to a Name Blob
      bResult = CertStrToName(X509_ASN_ENCODING,
                          szwX509,
                          CERT_X500_NAME_STR,
                          NULL,
                          NULL,
                          &dwSize,
                          NULL);
      if (!bResult)
      {
         printf("CertStrToName failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate memory for Name Blob
      pbNameBlob = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
      if (!pbNameBlob)
      {
         printf("Unable to allocate memory for name blob\n");
         __leave;
      }

      // Convert X509 Name to Name Blob
      bResult = CertStrToName(X509_ASN_ENCODING,
                          szwX509,
                          CERT_X500_NAME_STR,
                          NULL,
                          (LPBYTE)pbNameBlob,
                          &dwSize,
                          NULL);
      if (!bResult)
      {
         printf("CertStrToName failed with %x\n", GetLastError());
         __leave;
      }

      IssuerName.cbData = dwSize;
      IssuerName.pbData = pbNameBlob;

      // Convert Enhanced Key usage number to
      // Enhanced Key Usage extension

      // Find Enhanced Key Usage extensions count
      for (m = 0; m < g_EnhKeyUsage.dwCount; m++)
      {
        if ((g_EnhKeyUsage.dwValue[m] & dwUsage) == g_EnhKeyUsage.dwValue[m])
        {
          CertEnhKeyUsage.cUsageIdentifier++;
        }
      }

      // If extensions exist continue
      if (CertEnhKeyUsage.cUsageIdentifier != 0)
      {
         // Allocate memory for Enhanced Key Usage array
         CertEnhKeyUsage.rgpszUsageIdentifier =
             (LPSTR *)HeapAlloc(hHeap, 0, CertEnhKeyUsage.cUsageIdentifier * sizeof(LPSTR));
         if (!CertEnhKeyUsage.rgpszUsageIdentifier)
         {
           printf("Unable to allocate memory for Enhanced Usage array\n");
           __leave;
         }

         // Initialize Enhanced Key Usage array to NULL
         for (m = 0; m < CertEnhKeyUsage.cUsageIdentifier; m++)
         {
           CertEnhKeyUsage.rgpszUsageIdentifier[m] = NULL;
         }

         // Add proper extension OID to array
         q = 0;
         for (m = 0; m < g_EnhKeyUsage.dwCount; m++)
         {
           if ((g_EnhKeyUsage.dwValue[m] & dwUsage) == g_EnhKeyUsage.dwValue[m])
           {
             CertEnhKeyUsage.rgpszUsageIdentifier[q++] = g_EnhKeyUsage.szUsage[m];
           }
         }
      }

      // Convert Store string to unicode
      i = MultiByteToWideChar(0, 0, szSubjectStore, -1, szwStoreContainer, 20);
      if (i == 0)
      {
          printf("MultiByteToWideChar failed with %d\n", GetLastError());
          __leave;
      }

      // Create Crypto Context

      {
         UUID Uuid;
         HCRYPTPROV hTemp;

         // Create Temporary Provider
         bResult = CryptAcquireContext(&hTemp,
                                       L"Temp000",
                                       PROVIDER,
                                       PROV_RSA_FULL,
                                       CRYPT_NEWKEYSET);
         if (!bResult)
         {
            // If Temporary Provider exists already,
            // open it
            if (GetLastError() == NTE_EXISTS)
            {
               bResult = CryptAcquireContext(&hTemp,
                                          L"Temp000",
                                          PROVIDER,
                                          PROV_RSA_FULL,
                                          0);
               if (!bResult)
               {
                  printf("Unable to get temporary provider handle\n");
                  __leave;
               }
            }
            else
            {
               printf("Unable to create temporary provider handle\n");
               __leave;
            }
         }

         // Place random data in Uuid
         // Could have used UuidCreate but it is not supported
         // under Win9x.
         bResult = CryptGenRandom(hTemp, sizeof(Uuid), (LPBYTE)&Uuid);
         if (!bResult)
         {
            printf("CryptGenRandom failed with %x\n", GetLastError());
            __leave;
         }

         // Close Provider handle
         CryptReleaseContext(hTemp, 0);

         // Delete Container
         CryptAcquireContext(&hTemp,
                           L"Temp000",
                           PROVIDER,
                           PROV_RSA_FULL,
                           CRYPT_DELETEKEYSET);

         // Create a random uuid
         /*Status = UuidCreate(&Uuid);
         if (Status != RPC_S_OK)
         {
            printf("Unable to create random container\n");
            __leave;
         }*/

         // convert random uuid to a string, we will use it as a container
         Status = UuidToString(&Uuid, &szwContainer);
         if (Status != RPC_S_OK)
         {
            printf("Unable to convert uuid to string\n");
            __leave;
         }

         // Create new crypto context
         bResult = CryptAcquireContext(&hProv,
                            szwStoreContainer, //szwContainer,
                            szwProvider,
                            dwProviderType,
                            CRYPT_NEWKEYSET | dwAcquireFlags);
         if (!bResult)
         {
            printf("CryptAcquireContext failed with %x\n", GetLastError());
            __leave;
         }
      }

      // Generate Private/Public key pair
      dwStart = GetTickCount();
      bResult = CryptGenKey(hProv, dwKeyType, PK_KEY_SIZE, &hPubKey);
      //printf("CryptGenKey took %d milliseconds\n", GetTickCount() - dwStart);
      if (!bResult)
      {
         printf("CryptGenKey failed with %x\n", GetLastError());
         __leave;
      }

      // Zero CERT_INFO structure
      ZeroMemory(&CertInfo, sizeof(CertInfo));

      // Set Version of Certificate
      CertInfo.dwVersion = CERT_V3;

      // Create Random Serial Number
      bResult = CryptGenRandom(hProv, 8, SerialNumber);
      if (!bResult)
      {
         printf("CryptGenRandom failed with %x\n", GetLastError());
         __leave;
      }

      // Set Serial Number of Certificate
      CertInfo.SerialNumber.cbData = 8;
      CertInfo.SerialNumber.pbData = SerialNumber;

      // Set Signature Algorithm of Certificate
      CertInfo.SignatureAlgorithm.pszObjId = szSigAlg;
      CertInfo.SignatureAlgorithm.Parameters.cbData = 0;
      CertInfo.SignatureAlgorithm.Parameters.pbData = NULL;

      // set NotBefore date
      GetSystemTime(&stTime);
      SystemTimeToFileTime(&stTime, &ftTime);
      CertInfo.NotBefore = ftTime;

      if (wMonths == 0)
      {
         if (bSelfSigned)
            wMonths = 24;
         else
            wMonths = 6;
      }

      //
      // Set After Date
      //
      stTime.wMonth = (USHORT)(stTime.wMonth + wMonths);
      if ((stTime.wMonth / 12) > 0)
      {
         stTime.wYear = (USHORT)(stTime.wYear + (stTime.wMonth / 12));
         stTime.wMonth = (USHORT)(stTime.wMonth % 12);
      }

      SystemTimeToFileTime(&stTime, &ftTime);
      CertInfo.NotAfter = ftTime;

      // Get Public Key Info size
      bResult = CryptExportPublicKeyInfo(hProv, dwKeyType,
                                       X509_ASN_ENCODING, NULL, &dwSize);
      if (!bResult)
      {
         printf("CryptExportPublicKeyInfo failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate memory for Public Key Info
      PublicKeyInfo = (PCERT_PUBLIC_KEY_INFO)HeapAlloc(hHeap, 0, dwSize);
      if (!PublicKeyInfo)
      {
         printf("Unable to allocate memory for public key info\n");
         __leave;
      }

      // Get Public Key Info
      bResult = CryptExportPublicKeyInfo(hProv, dwKeyType,
                                       X509_ASN_ENCODING,
                                       PublicKeyInfo, &dwSize);
      if (!bResult)
      {
         printf("CryptExportPublicKeyInfo failed with %x\n", GetLastError());
         __leave;
      }

      // Set Public Key info of Certificate
      CertInfo.SubjectPublicKeyInfo = *PublicKeyInfo;

      // Create Hash
      bResult = CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash);
      if (!bResult)
      {
         printf("CryptCreateHash failed with %x\n", GetLastError());
         __leave;
      }

      // Hash Public Key Info
      bResult = CryptHashData(hHash, (LPBYTE)PublicKeyInfo, dwSize, 0);
      if (!bResult)
      {
         printf("CryptHashData failed with %x\n", GetLastError());
         __leave;
      }

      // Get Size of Hash
      bResult = CryptGetHashParam(hHash, HP_HASHVAL, NULL, &dwSize, 0);
      if (!bResult)
      {
         printf("CryptGetHashParam failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate Memory for Key Identifier (hash of Public Key info)
      pbKeyIdentifier = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
      if (!pbKeyIdentifier)
      {
         printf("Unable to allocate memory for Hashed Public key Info\n");
         __leave;
      }

      // Get Hash of Public Key Info
      bResult = CryptGetHashParam(hHash, HP_HASHVAL, pbKeyIdentifier, &dwSize, 0);
      if (!bResult)
      {
         printf("CryptGetHashParam failed with %x\n", GetLastError());
         __leave;
      }

      // We will use this to set the Key Identifier extension
      CertKeyIdentifier.cbData = dwSize;
      CertKeyIdentifier.pbData = pbKeyIdentifier;

      // Set Subject of Certificate
      CertInfo.Subject = IssuerName;

      // Set Issuer of Certificate
      if (bSelfSigned)
      {
         CertInfo.Issuer = IssuerName;
      }
      else
      {
         pIssuerCert = FindCertificate(szIssuerName, szIssuerStore,
                                       dwIssuerFlags, &KeyId,
                                       &hIssuerProv, &dwIssuerKeyType);
         if (!pIssuerCert)
         {
            printf("Unable to find Issuer Certificate\n");
            __leave;
         }

         CertInfo.Issuer = pIssuerCert->pCertInfo->Subject;
      }

      // Get Subject Key Identifier Extension size
      bResult = CryptEncodeObject(ENCODING,
                                  szOID_SUBJECT_KEY_IDENTIFIER,
                                  (LPVOID)&CertKeyIdentifier,
                                  NULL, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate Memory for Subject Key Identifier Blob
      SubjectKeyIdentifier = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
      if (!SubjectKeyIdentifier)
      {
         printf("Unable to allocate memory for Subject Key Identifier\n");
         __leave;
      }

      // Get Subject Key Identifier Extension
      bResult = CryptEncodeObject(ENCODING,
                                  szOID_SUBJECT_KEY_IDENTIFIER,
                                  (LPVOID)&CertKeyIdentifier,
                                  SubjectKeyIdentifier, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Set Subject Key Identifier
      CertExtension[CertInfo.cExtension].pszObjId = szOID_SUBJECT_KEY_IDENTIFIER;
      CertExtension[CertInfo.cExtension].fCritical = FALSE;
      CertExtension[CertInfo.cExtension].Value.cbData = dwSize;
      CertExtension[CertInfo.cExtension].Value.pbData = SubjectKeyIdentifier;

      // Increase extension count
      CertInfo.cExtension++;

      // Set Key Usage according to Public Key Type
      ZeroMemory(&KeyUsage, sizeof(KeyUsage));
      KeyUsage.cbData = 1;
      KeyUsage.pbData = &ByteData;

      if (dwKeyType == AT_SIGNATURE)
      {
         ByteData = CERT_DIGITAL_SIGNATURE_KEY_USAGE|
                    CERT_NON_REPUDIATION_KEY_USAGE|
                    CERT_KEY_CERT_SIGN_KEY_USAGE |
                    CERT_CRL_SIGN_KEY_USAGE;
      }

      if (dwKeyType == AT_KEYEXCHANGE)
      {
         ByteData = CERT_DIGITAL_SIGNATURE_KEY_USAGE |
                    CERT_DATA_ENCIPHERMENT_KEY_USAGE|
                    CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                    CERT_KEY_AGREEMENT_KEY_USAGE;
      }

      // Get Key Usage blob size
      bResult = CryptEncodeObject(ENCODING,
                                  X509_KEY_USAGE,
                                  (LPVOID)&KeyUsage,
                                  NULL, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate Memory for Key Usage Blob
      pbKeyUsage = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
      if (!pbKeyUsage)
      {
         printf("Unable to allocate memory for Subject Key Identifier\n");
         __leave;
      }

      // Get Key Usage Extension blob
      bResult = CryptEncodeObject(ENCODING,
                                  X509_KEY_USAGE,
                                  (LPVOID)&KeyUsage,
                                  pbKeyUsage, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Set Key Usage extension
      CertExtension[CertInfo.cExtension].pszObjId = szOID_KEY_USAGE;
      CertExtension[CertInfo.cExtension].fCritical = FALSE;
      CertExtension[CertInfo.cExtension].Value.cbData = dwSize;
      CertExtension[CertInfo.cExtension].Value.pbData = pbKeyUsage;

      // Increase extension count
      CertInfo.cExtension++;

      if (CertEnhKeyUsage.cUsageIdentifier != 0)
      {
         // Get Enhanced Key Usage size
         bResult = CryptEncodeObject(ENCODING,
                                     X509_ENHANCED_KEY_USAGE,
                                     (LPVOID)&CertEnhKeyUsage,
                                     NULL, &dwSize);
         if (!bResult)
         {
            printf("CryptEncodeObject failed with %x\n", GetLastError());
            __leave;
         }

         // Allocate Memory for Enhanced Key usage Blob
         pbEnhKeyUsage = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
         if (!pbEnhKeyUsage)
         {
            printf("Unable to allocate memory for Subject Key Identifier\n");
            __leave;
         }

         // Get Enhanced Key Usage Extension blob
         bResult = CryptEncodeObject(ENCODING,
                                     X509_ENHANCED_KEY_USAGE,
                                     (LPVOID)&CertEnhKeyUsage,
                                     pbEnhKeyUsage, &dwSize);
         if (!bResult)
         {
            printf("CryptEncodeObject failed with %x\n", GetLastError());
            __leave;
         }

         // Set Enhanced Key Usage extension
         CertExtension[CertInfo.cExtension].pszObjId = szOID_ENHANCED_KEY_USAGE;
         CertExtension[CertInfo.cExtension].fCritical = FALSE;
         CertExtension[CertInfo.cExtension].Value.cbData = dwSize;
         CertExtension[CertInfo.cExtension].Value.pbData = pbEnhKeyUsage;

         // Increase extension count
         CertInfo.cExtension++;
      }

      // Zero Basic Constraints structure
      ZeroMemory(&BasicConstraints, sizeof(BasicConstraints));

      // Self-signed is always a CA
      if (bSelfSigned)
      {
         BasicConstraints.fCA = TRUE;
         BasicConstraints.fPathLenConstraint = TRUE;
         BasicConstraints.dwPathLenConstraint = 2;
      }
      else
      {
         BasicConstraints.fCA = bCA;
         if ( bCA )
         {
             BasicConstraints.fPathLenConstraint = TRUE;
             BasicConstraints.dwPathLenConstraint = 1;
         }
      }

      // Get Basic Constraints blob size
      bResult = CryptEncodeObject(ENCODING,
                                  X509_BASIC_CONSTRAINTS2,
                                  (LPVOID)&BasicConstraints,
                                  NULL, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Allocate Memory for Basic Constraints Blob
      pbBasicConstraints = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
      if (!pbBasicConstraints)
      {
         printf("Unable to allocate memory for Subject Key Identifier\n");
         __leave;
      }

      // Get Basic Constraints Extension blob
      bResult = CryptEncodeObject(ENCODING,
                                  X509_BASIC_CONSTRAINTS2,
                                  (LPVOID)&BasicConstraints,
                                  pbBasicConstraints, &dwSize);
      if (!bResult)
      {
         printf("CryptEncodeObject failed with %x\n", GetLastError());
         __leave;
      }

      // Set Basic Constraints extension
      CertExtension[CertInfo.cExtension].pszObjId = szOID_BASIC_CONSTRAINTS2;
      CertExtension[CertInfo.cExtension].fCritical = FALSE;
      CertExtension[CertInfo.cExtension].Value.cbData = dwSize;
      CertExtension[CertInfo.cExtension].Value.pbData = pbBasicConstraints;

      // Increase extension count
      CertInfo.cExtension++;

      if (bSelfSigned)
      {
         AuthorityKeyId.KeyId = CertKeyIdentifier;
         AuthorityKeyId.CertIssuer = CertInfo.Issuer;
         AuthorityKeyId.CertSerialNumber = CertInfo.SerialNumber;
         bAddAuthorityExtension = TRUE;
      }
      else
      {
         if (KeyId)
         {
            AuthorityKeyId.KeyId = *KeyId;
            AuthorityKeyId.CertIssuer = pIssuerCert->pCertInfo->Subject;
            AuthorityKeyId.CertSerialNumber = pIssuerCert->pCertInfo->SerialNumber;
            bAddAuthorityExtension = TRUE;
         }
      }

      if (bAddAuthorityExtension)
      {
         // Get Authority Key Id blob size
         bResult = CryptEncodeObject(ENCODING,
                                     X509_AUTHORITY_KEY_ID,
                                     (LPVOID)&AuthorityKeyId,
                                     NULL, &dwSize);
         if (!bResult)
         {
            printf("CryptEncodeObject failed with %x\n", GetLastError());
            __leave;
         }

         // Allocate Authority Key Id Blob
         pbAuthorityKeyId = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
         if (!pbAuthorityKeyId)
         {
            printf("Unable to allocate memory for Subject Key Identifier\n");
            __leave;
         }

         // Get Authority Key Id blob
         bResult = CryptEncodeObject(ENCODING,
                                     X509_AUTHORITY_KEY_ID,
                                     (LPVOID)&AuthorityKeyId,
                                     pbAuthorityKeyId, &dwSize);
         if (!bResult)
         {
            printf("CryptEncodeObject failed with %x\n", GetLastError());
            __leave;
         }

         // Set Authority Key Id extension
         CertExtension[CertInfo.cExtension].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER;
         CertExtension[CertInfo.cExtension].fCritical = FALSE;
         CertExtension[CertInfo.cExtension].Value.cbData = dwSize;
         CertExtension[CertInfo.cExtension].Value.pbData = pbAuthorityKeyId;

         // Increase extension count
         CertInfo.cExtension++;
      }

      CertInfo.rgExtension = CertExtension;

      if (bSelfSigned)
      {
         // Get Encoded Certificate Size
         bResult = CryptSignAndEncodeCertificate(hProv, dwKeyType,
                                                 X509_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                                                 (LPVOID)&CertInfo,
                                                 &(CertInfo.SignatureAlgorithm),
                                                 NULL, NULL, &dwSize);
         if (!bResult)
         {
            printf("CryptSignAndEncodeCertificate failed with %x\n", GetLastError());
            __leave;
         }

         // Allocate memory for encoded certificate
         bpEncodedCert = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
         if (!bpEncodedCert)
         {
            printf("Unable to allocate memory for encoded certficate\n");
            __leave;
         }

         // Sign and Encode certificate
         dwStart = GetTickCount();
         bResult = CryptSignAndEncodeCertificate(hProv, dwKeyType,
                                                 X509_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                                                 (LPVOID)&CertInfo,
                                                 &(CertInfo.SignatureAlgorithm),
                                                 NULL, bpEncodedCert, &dwSize);
         //printf("CryptSignAndEncodeCertificate took %d milliseconds\n", GetTickCount() - dwStart);
         if (!bResult)
         {
            printf("CryptSignAndEncodeCertificate failed with %x\n", GetLastError());
            __leave;
         }
      }
      else
      {
         // Get Encoded Certificate Size
         bResult = CryptSignAndEncodeCertificate(hIssuerProv, dwIssuerKeyType,
                                                 X509_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                                                 (LPVOID)&CertInfo,
                                                 //&(CertInfo.SignatureAlgorithm),
                                                 &(pIssuerCert->pCertInfo->SignatureAlgorithm),
                                                 NULL, NULL, &dwSize);
         if (!bResult)
         {
            printf("CryptSignAndEncodeCertificate failed with %x\n", GetLastError());
            __leave;
         }

         // Allocate memory for encoded certificate
         bpEncodedCert = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
         if (!bpEncodedCert)
         {
            printf("Unable to allocate memory for encoded certficate\n");
            __leave;
         }

         // Sign and Encode certificate
         dwStart = GetTickCount();
         bResult = CryptSignAndEncodeCertificate(hIssuerProv, dwIssuerKeyType,
                                                 X509_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                                                 (LPVOID)&CertInfo,
                                                 //&(CertInfo.SignatureAlgorithm),
                                                 &(pIssuerCert->pCertInfo->SignatureAlgorithm),
                                                 NULL, bpEncodedCert, &dwSize);
         //printf("CryptSignAndEncodeCertificate took %d milliseconds\n", GetTickCount() - dwStart);
         if (!bResult)
         {
            printf("CryptSignAndEncodeCertificate failed with %x\n", GetLastError());
            __leave;
         }
      }
      
#if REPEAT_LOOP == 1
      if (bExport)
      {
          DWORD dwWritten;

	      // Convert multibyte store name to wide char string
     	  i = MultiByteToWideChar(CP_ACP, 0, szCertFile, -1, szwCertFile, 200);
	      if (i == 0)
     	  {
		       printf("Unable to convert szCertFile to Unicode string\n");
		       __leave;
	      }
     
          // Create Certificate file
          hCertFile = CreateFile(szwCertFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, NULL);
          if (hCertFile == INVALID_HANDLE_VALUE)
          {
              printf("CreateFile failed with %d\n", GetLastError());
              __leave;
          }

          // Write encoded Certificate to file
          bResult = WriteFile(hCertFile, (LPVOID)bpEncodedCert, dwSize, &dwWritten, NULL);
          if (!bResult)
          {
              printf("WriteFile failed with %d\n", GetLastError());
              __leave;
          }

          if (_stricmp( szPassword, "null" ) != 0)
          {
              // Destroy previous hash
              if (hHash) CryptDestroyHash(hHash);
              hHash = 0;

              // Create hash
              bResult = CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash);
              if (!bResult)
              {
                  printf("CryptCreateHash failed with %x\n", GetLastError());
                  __leave;
              }

              // Hash password
              bResult = CryptHashData(hHash, (LPBYTE)szPassword, strlen(szPassword), 0);
              if (!bResult)
              {
                  printf("CryptHashData failed with %x\n", GetLastError());
                  __leave;
              }

              // Derive Session Key from hash
              bResult = CryptDeriveKey(hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hSessionKey);
              if (!bResult)
              {
                  printf("CryptDeriveKey failed with %x\n", GetLastError());
                  __leave;
              }
          }

          //
          // Export the private key
          //
          // Get size of exported key blob
          bResult = CryptExportKey(hPubKey, hSessionKey, PRIVATEKEYBLOB, 0, NULL, &dwSize);
          if (!bResult)
          {
              printf("CryptExportKey failed with %x\n", GetLastError());
              __leave;
          }
          
          // Allocate memory for exported key blob
          pbExportedKey = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
          if (!pbExportedKey)
          {
              printf("Unable to allocate memory for exported key\n");
              __leave;
          }

          // Get exported key blob
          bResult = CryptExportKey(hPubKey, hSessionKey, PRIVATEKEYBLOB,
                                   0, pbExportedKey, &dwSize);
          if (!bResult)
          {
              printf("CryptExportKey failed with %x\n", GetLastError());
              __leave;
          }

	      // Convert multibyte store name to wide char string
     	  i = MultiByteToWideChar(CP_ACP, 0, szKeyFile, -1, szwKeyFile, 200);
	      if (i == 0)
     	  {
		       printf("Unable to convert szKeyFile to Unicode string\n");
		       __leave;
	      }
     
          // Create Exported Key File
          hKeyFile = CreateFile(szwKeyFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);
          if (hKeyFile == INVALID_HANDLE_VALUE)
          {
              printf("CreateFile failed with %d\n", GetLastError());
              __leave;
          }

          // Write exported key to file
          bResult = WriteFile(hKeyFile, (LPVOID)pbExportedKey, dwSize, &dwWritten, NULL);
          if (!bResult)
          {
              printf("WriteFile failed with %d\n", GetLastError());
              __leave;
          }

          assert( dwWritten == dwSize );

          //
          // Export the public key
          //
          if (pbExportedKey) HeapFree(hHeap, 0, pbExportedKey);
          if (hKeyFile) CloseHandle(hKeyFile);
          
          // Get size of exported key blob
          bResult = CryptExportKey(hPubKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwSize);
          if (!bResult)
          {
              printf("CryptExportKey failed with %x\n", GetLastError());
              __leave;
          }
          
          // Allocate memory for exported key blob
          pbExportedKey = (LPBYTE)HeapAlloc(hHeap, 0, dwSize);
          if (!pbExportedKey)
          {
              printf("Unable to allocate memory for exported key\n");
              __leave;
          }

          // Get exported key blob
          bResult = CryptExportKey(hPubKey, NULL, PUBLICKEYBLOB,
                                   0, pbExportedKey, &dwSize);
          if (!bResult)
          {
              printf("CryptExportKey failed with %x\n", GetLastError());
              __leave;
          }

          // Create Exported Key File
          hKeyFile = CreateFile(L"publickey.key", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);
          if (hKeyFile == INVALID_HANDLE_VALUE)
          {
              printf("CreateFile failed with %d\n", GetLastError());
              __leave;
          }

          // Write exported key to file
          bResult = WriteFile(hKeyFile, (LPVOID)pbExportedKey, dwSize, &dwWritten, NULL);
          if (!bResult)
          {
              printf("WriteFile failed with %d\n", GetLastError());
              __leave;
          }

          assert( dwWritten == dwSize );
          
          // delete crypto context
          bResult = CryptAcquireContext(&hProv,
                            szwContainer,
                            szwProvider,
                            dwProviderType,
                            CRYPT_DELETEKEYSET | dwAcquireFlags);
          if (!bResult)

          {
              printf("CryptAcquireContext failed with %x\n", GetLastError());
              __leave;
          }

          bReturn = TRUE;

          printf("Certificate and Key information stored to files\n");
      }
      else
      {
          WCHAR szwStore[20];
          CRYPT_KEY_PROV_INFO CryptKeyProvInfo;
          LPWSTR szwFile;
          int i;
          DWORD dwWritten;

          if (bSelfSigned)
          {
              szwFile = L"SelfSigned.cer";
          }
          else
          {
              szwFile = L"Certificate.cer";
          }

          // Create Certificate file
          hCertFile = CreateFile(szwFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, NULL);
          if (hCertFile == INVALID_HANDLE_VALUE)
          {
              printf("CreateFile failed with %d\n", GetLastError());
              __leave;
          }

          // Write encoded Certificate to file
          bResult = WriteFile(hCertFile, (LPVOID)bpEncodedCert, dwSize, &dwWritten, NULL);
          if (!bResult)
          {
              printf("WriteFile failed with %d\n", GetLastError());
              __leave;
          }

          printf("File called %ls has been saved.\n", szwFile);

          // Convert Store string to unicode
          i = MultiByteToWideChar(0, 0, szSubjectStore, -1, szwStore, 20);
          if (i == 0)
          {
              printf("MultiByteToWideChar failed with %d\n", GetLastError());
              __leave;
          }

          // Open Certificate store
          hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                 ENCODING,
                                 0, dwSubjectFlags, (LPVOID)szwStore);
          if (!hStore)
          {
              printf("CertOpenStore failed with %x\n", GetLastError());
              __leave;
          }

          // Place Certificate in store
          bResult = CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
                                    bpEncodedCert, dwSize,
                                    CERT_STORE_ADD_REPLACE_EXISTING,
                                    &pCertContext);
          if (!bResult)
          {
              printf("CertAddEncodedCertificateToStore failed with %x\n", GetLastError());
              __leave;
          }

          // Initialize CRYPT_KEY_PROV_INFO structure
          ZeroMemory(&CryptKeyProvInfo, sizeof(CryptKeyProvInfo));
          CryptKeyProvInfo.pwszContainerName = szwContainer;
          CryptKeyProvInfo.pwszProvName = szwProvider;
          CryptKeyProvInfo.dwProvType = dwProviderType;
          CryptKeyProvInfo.dwKeySpec = dwKeyType;

          // Set Certificate's Key Provider info
          bResult = CertSetCertificateContextProperty(pCertContext,
                                        CERT_KEY_PROV_INFO_PROP_ID,
                                        0, (LPVOID)&CryptKeyProvInfo);
          if (!bResult)
          {
              printf("CertSetCertificateContextProperty failed with %x\n", GetLastError());
              __leave;
          }

          bReturn = TRUE;

          printf("Certificate created successfully and installed\n");
      }
#else
      bReturn = TRUE;
#endif
   }
   _finally
   {
      // Clean up
      if (pbNameBlob) HeapFree(hHeap, 0, pbNameBlob);
      if (CertEnhKeyUsage.rgpszUsageIdentifier)
         HeapFree(hHeap, 0, CertEnhKeyUsage.rgpszUsageIdentifier);
      if (PublicKeyInfo) HeapFree(hHeap, 0, PublicKeyInfo);
      if (pbKeyIdentifier) HeapFree(hHeap, 0, pbKeyIdentifier);
      if (SubjectKeyIdentifier) HeapFree(hHeap, 0, SubjectKeyIdentifier);
      if (pbKeyUsage) HeapFree(hHeap, 0, pbKeyUsage);
      if (pbEnhKeyUsage) HeapFree(hHeap, 0, pbEnhKeyUsage);
      if (pbBasicConstraints) HeapFree(hHeap, 0, pbBasicConstraints);
      if (KeyId) HeapFree(hHeap, 0, KeyId);
      if (pbAuthorityKeyId) HeapFree(hHeap, 0, pbAuthorityKeyId);
      if (bpEncodedCert) HeapFree(hHeap, 0, bpEncodedCert);
      if (pbExportedKey) HeapFree(hHeap, 0, pbExportedKey);
      if (szwContainer) RpcStringFree(&szwContainer);
      if (hCertFile) CloseHandle(hCertFile);
      if (hKeyFile) CloseHandle(hKeyFile);
      if (hPubKey) CryptDestroyKey(hPubKey);
      if (hSessionKey) CryptDestroyKey(hSessionKey);
      if (hHash) CryptDestroyHash(hHash);
      if (hProv) CryptReleaseContext(hProv, 0);
      if (hIssuerProv) CryptReleaseContext(hIssuerProv, 0);
      if (pIssuerCert) CertFreeCertificateContext(pIssuerCert);
      if (pCertContext) CertFreeCertificateContext(pCertContext);
      if (hStore) CertCloseStore(hStore, 0);
   }

   return bReturn;
}

HRESULT VerifyKeyPair( LPBYTE pbEncodedCert, DWORD dwCertSize, HCRYPTPROV hPrvProv )
{
    PCCERT_CONTEXT pCertContextRequest = NULL;
    HRESULT hr = S_OK;
    LPWSTR szwContainer = NULL;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hPubKey = 0;
    RPC_STATUS Status;
    UUID Uuid;
    BOOL bResult;
    WCHAR szwProvider[260] = { PROVIDER };
    DWORD dwProviderType = PROV_RSA_FULL;
    DWORD dwAcquireFlags = 0;
	BYTE *pbBuffer= (BYTE *)"The data that is to be hashed and signed.";
    DWORD dwBufferLen = strlen((char *)pbBuffer)+1;
	LPTSTR szDescription = NULL;
    BYTE pbSignature[200];
    DWORD dwSigLen = 200;
    //DWORD dwKeyType = AT_KEYEXCHANGE;
    DWORD tickct;
    int i;
    
	bResult = CryptCreateHash(
	   hPrvProv, 
	   CALG_SHA1, 
	   0, 
	   0, 
	   &hHash);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptCreateHash failed with %x\n", hr);
       goto error;
    }

	bResult = CryptHashData(
	   hHash, 
	   pbBuffer, 
	   dwBufferLen, 
	   0);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptHashData failed with %x\n", hr);
       goto error;
    }

    tickct = GetTickCount();
    for (i=0; i<SIGN_LOOP; ++i)
    {
        bResult = CryptSignHash(
           hHash, 
           AT_KEYEXCHANGE, 
           szDescription, 
           0, 
           pbSignature, 
           &dwSigLen);
        if (!bResult)
        {
           hr = GetLastError();
           printf("CryptSignHash failed with %x\n", hr);
           goto error;
        }
    }
    printf("CryptSignHash %d times took %d ms for %d byte Signing\n", i, GetTickCount() - tickct, dwSigLen );
		
	if (hHash) CryptDestroyHash(hHash);

	//
	// We now have something signed by the private key.
	// We now verify the it can be verified with the public key in the cert
	//
	
    {
        HCRYPTPROV hTemp;

        // Create Temporary Provider
        bResult = CryptAcquireContext(&hTemp,
                                      L"Temp000",
                                      PROVIDER,
                                      PROV_RSA_FULL,
                                      CRYPT_NEWKEYSET);
        if (!bResult)
        {
           // If Temporary Provider exists already,
           // open it
           hr = GetLastError();
           if (hr == NTE_EXISTS)
           {
              bResult = CryptAcquireContext(&hTemp,
                                          L"Temp000",
                                          PROVIDER,
                                          PROV_RSA_FULL,
                                          0);
              if (!bResult)
              {
                 printf("Unable to get temporary provider handle\n");
		         goto error;
              }
           }
           else
           {
              printf("Unable to create temporary provider handle\n");
              goto error;
           }
        }

        // Place random data in Uuid
        // Could have used UuidCreate but it is not supported
        // under Win9x.
        bResult = CryptGenRandom(hTemp, sizeof(Uuid), (LPBYTE)&Uuid);
        if (!bResult)
        {
           hr = GetLastError();
           printf("CryptGenRandom failed with %x\n", hr);
           goto error;
        }

        // Close Provider handle
        CryptReleaseContext(hTemp, 0);

        // Delete Container
        CryptAcquireContext(&hTemp,
                           L"Temp000",
                           PROVIDER,
                           PROV_RSA_FULL,
                           CRYPT_DELETEKEYSET);

        // convert random uuid to a string, we will use it as a container
        Status = UuidToString(&Uuid, &szwContainer);
        if (Status != RPC_S_OK)
        {
          hr = Status;
          printf("Unable to convert uuid to string\n");
          goto error;
        }
    }

    // Create new crypto context
    bResult = CryptAcquireContext(&hProv,
                            szwContainer,
                            szwProvider,
                            dwProviderType,
                            CRYPT_NEWKEYSET | dwAcquireFlags);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptAcquireContext failed with %x\n", hr);
       goto error;
    }

    pCertContextRequest = CertCreateCertificateContext( X509_ASN_ENCODING, pbEncodedCert, dwCertSize );
    if (!pCertContextRequest)
    {
        hr = GetLastError();
        printf("Failed CertCreateCertificateContext [%x]\n", hr);
        goto error;
    }

	bResult = CryptImportPublicKeyInfoEx(hProv, ENCODING, &(pCertContextRequest->pCertInfo->SubjectPublicKeyInfo), CALG_RSA_KEYX, 0, NULL, &hPubKey );
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptImportPublicKeyInfoEx failed with %x\n", hr);
       goto error;
    }

	bResult = CryptCreateHash(
	   hProv, 
	   CALG_SHA1, 
	   0, 
	   0, 
	   &hHash);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptCreateHash 2 failed with %x\n", hr);
       goto error;
    }

	bResult = CryptHashData(
	   hHash, 
	   pbBuffer, 
	   dwBufferLen, 
	   0);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptHashData 2 failed with %x\n", hr);
       goto error;
    }

    tickct = GetTickCount();
    for (i=0; i<VERIFY_LOOP; ++i)
    {
    	bResult = CryptVerifySignature(
    	   hHash, 
    	   pbSignature, 
    	   dwSigLen, 
    	   hPubKey,
    	   szDescription, 
    	   0);
        if (!bResult)
        {
           hr = GetLastError();
           printf("CryptVerifySignature failed with %x\n", hr);
           goto error;
        }
    }
    printf("CryptVerifySignature %d times took %d ms for %d byte Sig verification\n", i, GetTickCount() - tickct, dwSigLen );

error:
    if (szwContainer) RpcStringFree(&szwContainer);
    if (hHash) CryptDestroyHash(hHash);
    if (hPubKey) CryptDestroyKey(hPubKey);
    if (hProv) CryptReleaseContext(hProv, 0);
    if (pCertContextRequest) CertFreeCertificateContext(pCertContextRequest);
	
	return hr;
}     	

//
// Find Certificate with szCertName in the Subject name
//
PCCERT_CONTEXT FindCertificate(LPSTR szCertName, LPSTR szStore,
                               DWORD dwFlags, PCRYPT_DATA_BLOB *KeyId,
                               HCRYPTPROV *hProv, LPDWORD dwKeyType)
{
   HANDLE hHeap = GetProcessHeap();
   PCRYPT_KEY_PROV_INFO KeyProvInfo = NULL;
   PCCERT_CONTEXT pCertContext = NULL;
   PCERT_EXTENSION pExtension = NULL;
   HCERTSTORE hStore = 0;
   WCHAR szwStore[20];
   BOOL bResult, bSuccess = FALSE;
   DWORD dwSize, dwAcquireFlags = 0;
   int i;

   __try
   {
      *KeyId = NULL;
      *hProv = 0;

      if (dwFlags == CERT_SYSTEM_STORE_LOCAL_MACHINE)
         dwAcquireFlags = CRYPT_MACHINE_KEYSET;

      // Convert Store string to Unicode
      i = MultiByteToWideChar(0, 0, szStore, -1, szwStore, 20);
      if (i == 0)
      {
         __leave;
      }

      // Open Certificate store
      hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                           ENCODING,
                           0, dwFlags, (LPVOID)szwStore);
      if (!hStore)
      {
         __leave;
      }

      // Find Certificate with Subject name
      pCertContext = CertFindCertificateInStore(hStore,
                              ENCODING,
                              0, CERT_FIND_SUBJECT_STR_A,
                              (LPVOID)szCertName, NULL);
      if (pCertContext)
      {
         // Get Key Provider Info size
         bResult = CertGetCertificateContextProperty(pCertContext,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             NULL,
                                             &dwSize);
         if (!bResult)
         {
            __leave;
         }

         // Allocate Key Provider Info
         KeyProvInfo = (PCRYPT_KEY_PROV_INFO)HeapAlloc(hHeap, 0, dwSize);
         if (!KeyProvInfo)
         {
            __leave;
         }

         // Get Key Provider Info
         bResult = CertGetCertificateContextProperty(pCertContext,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             (LPVOID)KeyProvInfo,
                                             &dwSize);
         if (!bResult)
         {
            __leave;
         }

         // Get Crypto Context of Certificate
         bResult = CryptAcquireContext(hProv, KeyProvInfo->pwszContainerName, KeyProvInfo->pwszProvName,
                                       KeyProvInfo->dwProvType, dwAcquireFlags);
         if (!bResult)
         {
            __leave;
         }

         // Return Key Spec
         *dwKeyType = KeyProvInfo->dwKeySpec;

         bSuccess = TRUE;

         // Find Subject Key Identifier Extension
         pExtension = CertFindExtension(szOID_SUBJECT_KEY_IDENTIFIER,
                                        pCertContext->pCertInfo->cExtension,
                                        pCertContext->pCertInfo->rgExtension);

         // If Subject Key Identifier Extension Exists
         if (pExtension)
         {

            // Get Size of Data Blob
            bResult = CryptDecodeObject(ENCODING,
                                        szOID_SUBJECT_KEY_IDENTIFIER,
                                        pExtension->Value.pbData,
                                        pExtension->Value.cbData,
                                        0, NULL, &dwSize);
            if (!bResult)
            {
               __leave;
            }

            // Allocate Data Blob
            *KeyId = (PCRYPT_DATA_BLOB)HeapAlloc(hHeap, 0, dwSize);
            if (!(*KeyId))
            {
               __leave;
            }

            // Get Key Identifier Data Blob
            bResult = CryptDecodeObject(ENCODING,
                                        szOID_SUBJECT_KEY_IDENTIFIER,
                                        pExtension->Value.pbData,
                                        pExtension->Value.cbData,
                                        0, (LPVOID)*KeyId, &dwSize);
            if (!bResult)
            {
               __leave;
            }
         }
      }
      else
      {
         __leave;
      }

      bSuccess = TRUE;
   }
   __finally
   {
      // Clean up
      if (hStore) CertCloseStore(hStore, 0);
      if (KeyProvInfo) HeapFree(hHeap, 0, KeyProvInfo);
      if (!bSuccess)
      {
         if (pCertContext) CertFreeCertificateContext(pCertContext);
         pCertContext = NULL;
         if (*KeyId) HeapFree(hHeap, 0, *KeyId);
         *KeyId = NULL;
      }
   }

   return pCertContext;
}

//
// Implement this is CryptEnumProviders is unavailble
//
BOOL WINAPI MyCryptEnumProviders(DWORD dwIndex, LPDWORD pdwProvType,
                                 LPTSTR szProvName, LPDWORD pcbProvName)
{
    static LPTSTR szKeyPath = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider");
    BOOL bResult = TRUE;
    DWORD dwNumKeys;
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    LONG lResult;
    FILETIME ft;

    __try
    {
       // Open registry provider registry key
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyPath, 0, KEY_READ, &hKey);
        if (lResult != ERROR_SUCCESS)
        {
            bResult = FALSE;
            __leave;
        }


        if (szProvName == NULL)
        {
           // Query for Number of Keys and Size maximum size of
           // provider
           lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, pcbProvName,
                                     NULL, NULL, NULL, NULL, NULL, NULL);
           if (lResult != ERROR_SUCCESS)
           {
              bResult = FALSE;
              __leave;
           }

           // return Size of Provider Name
           *pcbProvName = (*pcbProvName + 1) * sizeof(TCHAR);

           if (dwIndex >= dwNumKeys) return FALSE;
        }
        else
        {
           DWORD dwSize;
           DWORD dwType;

           // Get Provider by Index
           dwSize = *pcbProvName/sizeof(TCHAR);
           lResult = RegEnumKeyEx(hKey, dwIndex, szProvName, &dwSize, NULL, NULL, NULL, &ft);
           if (lResult != ERROR_SUCCESS)
           {
              bResult = FALSE;
              __leave;
           }

           *pcbProvName = (dwSize + 1) * sizeof(TCHAR);

           // Open the Provider Registry Key
           lResult = RegOpenKeyEx(hKey, szProvName, 0, KEY_READ, &hSubKey);
           if (lResult != ERROR_SUCCESS)
           {
              bResult = FALSE;
              __leave;
           }

           // Get Provider Type
           dwSize = sizeof(DWORD);
           lResult = RegQueryValueEx(hSubKey, TEXT("Type"), NULL, &dwType, (LPBYTE)pdwProvType, &dwSize);
           if (lResult != ERROR_SUCCESS)
           {
              bResult = FALSE;
              __leave;
           }
        }
    }
    __finally
    {
       // Clean up
       if (hKey != NULL) RegCloseKey(hKey);
       if (hSubKey != NULL) RegCloseKey(hSubKey);
    }

    return bResult;
}

//
// Print Usage
//
void PrintUsage(void)
{
   DWORD nIndex = 0;
   DWORD dwProvType, dwSize;
   WCHAR szwProvider[160];

   printf("\nUsage: CreateCert [Import option] <X509 Name> [Options]\n");
   printf("\n[Import option] : If this option is present, everything else is ignored\n");
   printf("\t-i <cert file> <public key file> <password> <store> <u>ser|<m>achine <provider num>\n");
   printf("\n<X509 Name> (eg. CN=Certificate)\n");
   printf("\n[Options]\n");
   printf("Type of Certificate:\n");
   printf("\t-p <provider number> - default: PROVIDER\n");
   printf("\t-k <e>xchange key | <s>ignature key - default:exchange\n");
   printf("\t-s <sha>|<md5> - default:sha\n");
   printf("\t-m <number of months of validity>\n");
   printf("\t-ca - indicates that the certificate is to be a CA. True for selfsigned\n");
   printf("\t-u <enhanced key usage number> - add following numbers\n");
   printf("\t\tServer Authentication : 1\n");
   printf("\t\tClient Authentication : 2\n");
   printf("\t\tCode Signing          : 4\n");
   printf("\t\tEmail Protection      : 8\n");
   printf("\t\tTime Stamping         : 16\n");
   printf("\nLocation of Certificate:\n");
   printf("\t-sl <store> <u>ser|<m>achine - default:my u\n");
   printf("\t\tor\n");
   printf("\t-ex <cert file> <public key file> <password>\n");
   printf("\nSigner of the certificate - defaults to self-signed if -is is not present\n");
   printf("\t-is <CommonName or substring> <store> <u>ser|<m>achine\n");

   printf("\nProviders:\n");
   dwSize = 160;
   while (MyCryptEnumProviders(nIndex, &dwProvType, szwProvider, &dwSize))
   {
      printf("\t%d : %ls\n", nIndex, szwProvider);
      dwSize = 160;
      nIndex++;
   }

   printf("\nSelf-Signed Certificates create a file called SelfSigned.cer\n");
   printf("Non Self-Signed Certificates create a file called Certificate.cer\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\CreateCert\CreateCert.h ===
//===================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright 1998-1999. Microsoft Corporation. All Right Reserved.
// File: CreateCert.h
//
//===================================================================
#ifndef __CreateCert__
#define __CreateCert__

void PrintUsage(void);
BOOL ImportCertificate(
         LPSTR szCertFile,
         LPSTR szKeyFile,
         LPSTR szPassword,
         LPSTR szStore,
         BOOL bUser,
         DWORD dwProviderNum);

BOOL CreateCertificate(
         LPSTR szX509,
         DWORD dwKeyType,
         LPSTR szSigAlg,
         WORD wMonths,
         DWORD dwCertEnhKeyUsage,
         BOOL bCA,
         BOOL bUseProv,
         DWORD dwProviderNum,
         LPSTR szSubjectStore,
         BOOL bSubjectUser,
         BOOL bSelfSigned,
         LPSTR szIssuerName,
         LPSTR szIssuerStore,
         BOOL bIssuerUser,
         BOOL bExport,
         LPSTR szCertFile,
         LPSTR szKeyFile,
         LPSTR szPassword);

PCCERT_CONTEXT FindCertificate(
         LPSTR szCertName,
         LPSTR szStore,
         DWORD dwFlags,
         PCRYPT_DATA_BLOB *KeyId,
         HCRYPTPROV *hProv,
         LPDWORD dwKeyType);

BOOL WINAPI MyCryptEnumProviders(
         DWORD dwIndex,
         LPDWORD pdwProvType,
         LPTSTR szProvName,
         LPDWORD pcbProvName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\DecryptTest\DecryptTest.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <wincrypt.h>
#include <rpc.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <malloc.h>
#include "base64.h"
#include "sha.h"
#include "cryptkeys.h"

#define PROVIDER L"nCipher Enhanced Cryptographic Provider"

//
// This is for the nCipher byte reversal bug. When we install with a new
// nCipher CSP that fixes this bug, this define will need to be removed.
//
#define NCIPHER_BYTE_REVERSAL_BUG 1

//#define USE_TEST_KEY 1

#define REPEAT_COUNT 1

#ifdef USE_TEST_KEY
BYTE g_PrivateKey[] = {
    0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xd7, 0xe4, 0x7a, 0x30, 0xe5, 0x8e, 0x1e, 0x87, 0xc8, 0xda, 0x7f, 0xae,
    0x22, 0xb5, 0x20, 0x35, 0x26, 0x78, 0x17, 0x11, 0x8d, 0xb6, 0xd7, 0xb1, 0xaa, 0xdb, 0x1f, 0x54,
    0xc8, 0x0f, 0xca, 0x38, 0x56, 0x21, 0x88, 0x4b, 0x9d, 0x60, 0x4a, 0x8e, 0x36, 0xff, 0x81, 0x72,
    0x62, 0x00, 0xe0, 0xad, 0xaa, 0x9e, 0x22, 0x44, 0xd9, 0xcb, 0x0b, 0xbd, 0x7a, 0xf3, 0x87, 0x5f,
    0x01, 0x76, 0x9e, 0x3f, 0xcf, 0x0c, 0x07, 0x3e, 0xe8, 0xaf, 0xa1, 0xe1, 0xdf, 0x6b, 0x6a, 0x38,
    0x77, 0x60, 0x42, 0x6e, 0xee, 0x10, 0x0a, 0x9e, 0xd8, 0x5c, 0x45, 0x59, 0x29, 0xe0, 0x21, 0x47,
    0x4c, 0x6a, 0xbf, 0xfc, 0x72, 0xfd, 0xdb, 0xa2, 0x64, 0x6e, 0x59, 0x1d, 0x36, 0x54, 0x28, 0xf1,
    0x8f, 0xca, 0xa7, 0x5d, 0x03, 0xaf, 0x31, 0x07, 0xbc, 0x47, 0x89, 0x5e, 0x6e, 0x44, 0x01, 0x3b,
    0xed, 0x0f, 0xd2, 0xd2, 0xdd, 0x54, 0xef, 0x5d, 0xf9, 0xb1, 0x7b, 0xc5, 0x89, 0x69, 0x2a, 0x5f,
    0xbc, 0x42, 0x29, 0xec, 0xd2, 0x59, 0x6e, 0x1d, 0x82, 0x98, 0x87, 0x32, 0x93, 0xff, 0x44, 0xd5,
    0x6f, 0x01, 0x92, 0x81, 0x67, 0x3b, 0x3e, 0xe7, 0x27, 0xf8, 0xdf, 0x69, 0x33, 0xd9, 0x4f, 0xd1,
    0xf5, 0xda, 0xae, 0x77, 0x11, 0xa8, 0x31, 0xdc, 0x7f, 0x40, 0x47, 0x14, 0x04, 0xc6, 0x4e, 0x2e,
    0x3c, 0x41, 0xf0, 0xf9, 0x43, 0xfb, 0x7f, 0x2d, 0x4a, 0xe8, 0xb0, 0x7c, 0x78, 0x18, 0xec, 0x8e,
    0x96, 0xf9, 0xea, 0x9d, 0x83, 0x6f, 0x9f, 0x14, 0xc6, 0x37, 0x52, 0x07, 0x37, 0x57, 0xa7, 0x30,
    0x64, 0xa8, 0x32, 0xe6, 0xb0, 0xea, 0xb6, 0x98, 0x3d, 0x54, 0x73, 0x5e, 0x44, 0xcf, 0x15, 0x61,
    0x21, 0xee, 0x42, 0x6e, 0x50, 0x33, 0xba, 0x74, 0xae, 0x37, 0xb0, 0x3b, 0xde, 0x71, 0xc0, 0xdd,
    0x7e, 0xf1, 0xee, 0xd7, 0x9d, 0x8b, 0xa7, 0x0f, 0x90, 0xd6, 0x23, 0xbc, 0xe0, 0x5a, 0x93, 0x42,
    0x08, 0xf9, 0x0a, 0xa4, 0x03, 0x33, 0xbe, 0x4c, 0xe1, 0xbf, 0xf7, 0x54, 0xf5, 0x57, 0xf6, 0x57,
    0x1c, 0xbb, 0x79, 0xec, 0x0a, 0x71, 0x14, 0x64, 0x9c, 0xb4, 0xab, 0xd3, 0x74, 0x1a, 0x4c, 0xd2,
    0x57, 0x1d, 0xac, 0x4d, 0x10, 0xc3, 0xa2, 0xea, 0x33, 0x1b, 0x33, 0x32, 0xb2, 0x66, 0xab, 0x68,
    0x24, 0xea, 0xf1, 0xf1, 0xef, 0x1a, 0xef, 0xf7, 0x90, 0xb1, 0x2c, 0xf4, 0x1d, 0x7e, 0xd4, 0x1b,
    0x1f, 0x96, 0x14, 0x81, 0xa6, 0x48, 0x0d, 0xa3, 0x88, 0x07, 0x8e, 0x93, 0xfe, 0x63, 0xd0, 0x19,
    0x70, 0xbc, 0x09, 0xbb, 0x19, 0xcb, 0x04, 0xf9, 0x6f, 0xc1, 0x6b, 0x07, 0x09, 0xf0, 0x9c, 0x7b,
    0xb7, 0x77, 0x9d, 0xae, 0x07, 0x82, 0xfc, 0x89, 0x0e, 0x08, 0x68, 0x3f, 0x42, 0x21, 0x36, 0x22,
    0xf7, 0xb1, 0x65, 0xa5, 0xd8, 0xd8, 0x06, 0x50, 0x9e, 0xf3, 0xef, 0xbf, 0xf9, 0x29, 0xf2, 0xa1,
    0x89, 0x7a, 0xc9, 0x90, 0xea, 0x73, 0xfe, 0x71, 0xfb, 0x3a, 0x01, 0xa3, 0xe4, 0xae, 0x1d, 0x8e,
    0x51, 0x07, 0xfb, 0xd2, 0x40, 0xe2, 0x87, 0x49, 0x8d, 0xc1, 0xc0, 0x92, 0x77, 0x9a, 0x2d, 0xbb,
    0xff, 0x06, 0xbd, 0xb1, 0xb8, 0xb2, 0xae, 0x6d, 0x03, 0xcb, 0x0e, 0xbb, 0x47, 0x1d, 0x9c, 0x66,
    0xc2, 0xa6, 0xb7, 0x5d, 0xe9, 0x33, 0x23, 0x3a, 0xe2, 0xca, 0x45, 0xb2, 0x06, 0x82, 0x6b, 0x51,
    0x32, 0xa2, 0x06, 0x77, 0xbd, 0xc4, 0x40, 0x47, 0x83, 0x5c, 0x89, 0xd3, 0x6a, 0x59, 0x0b, 0xc2,
    0x7f, 0x3b, 0xba, 0x3c, 0x46, 0x0d, 0xd9, 0x71, 0x62, 0x24, 0x8d, 0x40, 0xe5, 0x68, 0x4e, 0x68,
    0x7a, 0xa7, 0x3e, 0xbd, 0x09, 0x33, 0x54, 0x7e, 0x1f, 0xe6, 0x50, 0x28, 0x83, 0x29, 0x25, 0x13,
    0x5a, 0x3b, 0xe0, 0xa4, 0x89, 0x98, 0xaa, 0x51, 0xe7, 0x49, 0x20, 0xef, 0x7e, 0xe5, 0xcc, 0x94,
    0x53, 0x84, 0xfd, 0xd0, 0x13, 0xd0, 0x28, 0x9e, 0xfe, 0x37, 0xc8, 0x96, 0x24, 0x1a, 0xa3, 0x91,
    0x6d, 0x28, 0xcb, 0xee, 0xa5, 0xf5, 0xa0, 0x70, 0xc3, 0xb0, 0xf6, 0xca, 0xe3, 0xc4, 0xa8, 0x2e,
    0xaf, 0xde, 0xe4, 0x7e, 0x6b, 0x93, 0x62, 0xa2, 0x02, 0x1e, 0xf4, 0x38, 0x5d, 0x97, 0x3b, 0x87,
    0x28, 0x81, 0x35, 0x61 };
#endif

//
// Print Usage
//
void PrintUsage(void)
{
    printf("Usage: DecryptTest base64String\n");
}

int __cdecl main(int argc, char *argv[])
{
    BOOL bResult;
    char* pszBase64String;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY hPrvKey = 0;
    HRESULT hr;

    BYTE buffer[256];
    char buffer1[64];
    BYTE buffer2[64];
    DWORD dwSize = 0;
    PXBOX_ENCRYPTED_ONLINE_DATA pData;
    char pcRecoveryKey[16];
    DWORD dwStart,dwEnd;
    int i;
    
    // Print Usage
    if (argc < 2)
    {
        PrintUsage();
        return 0;
    }

    dwStart = GetTickCount();
    printf("CryptDecrypt starting...\n");

#ifndef USE_TEST_KEY
    // open crypto context with the private key
    bResult = CryptAcquireContext(&hProv,
                            L"XboxOnlineKeyV1",
                            PROVIDER,
                            PROV_RSA_FULL,
                            CRYPT_MACHINE_KEYSET);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptAcquireContext failed with %x\n", hr);
       goto ErrorExit;
    }

    dwEnd = GetTickCount();
    printf("CryptAcquireContext took %d milliseconds\n", dwEnd - dwStart);
    dwStart = dwEnd;

	bResult = CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hPrvKey );
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptGetUserKey failed with %x\n", hr);
       goto ErrorExit;
    }
    
    dwEnd = GetTickCount();
    printf("CryptGetUserKey took %d milliseconds\n", dwEnd - dwStart);
    dwStart = dwEnd;
#else
    //
    // Create a temporay provider context to import the keys
    //
    bResult = CryptAcquireContext(&hProv,
                               L"XboxTemp002",
                               MS_ENHANCED_PROV,
                               PROV_RSA_FULL,
                               CRYPT_NEWKEYSET);
    if (!bResult)
    {
       // If Temporary Provider exists already,
       // open it
       if (GetLastError() == NTE_EXISTS)
       {
          bResult = CryptAcquireContext(&hProv,
                                      L"XboxTemp002",
                                      MS_ENHANCED_PROV,
                                      PROV_RSA_FULL,
                                      0);
          if (!bResult)
          {
             printf("Unable to get temporary provider handle\n");
             goto ErrorExit;
          }
       }
       else
       {
          printf("Unable to create temporary provider handle\n");
          goto ErrorExit;
       }
    }
    
    //
    // Import the private key
    //
    bResult = CryptImportKey(hProv, g_PrivateKey, sizeof(g_PrivateKey), NULL, 0, &hPrvKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Failed CryptImportKey [%x]\n", hr);
        goto ErrorExit;
    }
#endif

    pszBase64String = argv[1];

    for (i=0; i<REPEAT_COUNT; ++i) {

        bResult = Base64Decode( pszBase64String, strlen(pszBase64String), buffer, &dwSize );
        assert( bResult );
        assert( dwSize == ONLINE_KEY_PKENC_SIZE );

        //
        // Decrypt the online key with the private key.
        //
        bResult = CryptDecrypt( hPrvKey, NULL, TRUE, 0, buffer, &dwSize );
        if(!bResult)
        {
            hr = GetLastError();
            printf("Error %x during CryptDecrypt! Bytes output:%lu\n", hr, dwSize);
            goto ErrorExit;
        }
    
    }

    dwEnd = GetTickCount();
    printf("CryptDecrypt %d times took %d milliseconds\n", REPEAT_COUNT, dwEnd - dwStart);
    dwStart = dwEnd;

    assert( dwSize == sizeof(XBOX_ENCRYPTED_ONLINE_DATA) );

#if !defined(USE_TEST_KEY) && defined(NCIPHER_BYTE_REVERSAL_BUG)
    BYTE t,*p,*q;
    p = &buffer[0];
    q = &buffer[dwSize-1];
    while ( q > p )
    {
        t = *p;
        *p = *q;
        *q = t;
        ++p;
        --q;
    }
#endif

    pData = (PXBOX_ENCRYPTED_ONLINE_DATA)&buffer[0];
    
    //
    // Print out the keys
    //
    printf("OnlineKey: %02x%02x\n",
        pData->OnlineKey[0], pData->OnlineKey[1]
        );

    printf("HardDriveKey: %02x%02x\n",
        pData->HardDriveKey[0], pData->HardDriveKey[1]
        );

    bResult = Base64Encode( pData->HardDriveKey, HARD_DRIVE_KEY_LEN, buffer1 );
    assert( bResult );
    printf("HardDriveKey encoded: %s\n", buffer1);

    bResult = Base64Decode( buffer1, strlen(buffer1), buffer2, &dwSize );
    assert( bResult );
    assert( dwSize == HARD_DRIVE_KEY_LEN );
    assert( memcmp( buffer2, pData->HardDriveKey, dwSize ) == 0 );
    
    //
    // Compute recovery key
    //
    ComputeRecoveryKey( pData->HardDriveKey, pcRecoveryKey );

    printf("RecoveryKey: %.8s\n", pcRecoveryKey);

    printf("MACAddress: %02x%02x%02x%02x%02x%02x\n",
        pData->MACAddress[0], pData->MACAddress[1],
        pData->MACAddress[2], pData->MACAddress[3],
        pData->MACAddress[4], pData->MACAddress[5]
        );

    printf("XboxSerialNumber: %.12s\n", pData->XboxSerialNumber);
    
    printf("GameRegion: %X\n", pData->GameRegion);

    printf("AVRegion: %X\n", pData->AVRegion);

    dwEnd = GetTickCount();
    printf("printing took %d milliseconds\n", dwEnd - dwStart);
    dwStart = dwEnd;

    CryptReleaseContext( hProv, 0 );

    dwEnd = GetTickCount();
    printf("CryptReleaseContext took %d milliseconds\n", dwEnd - dwStart);
    dwStart = dwEnd;

    return 0;
    
ErrorExit:

    CryptReleaseContext( hProv, 0 );

    printf("Failed\n");

    return 1;
}


//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenOnlineKey\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <windows.h>
#include <assert.h>
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\DecryptTest\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <windows.h>
#include <assert.h>
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenOnlineKey\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\DecryptTest\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenPerBoxData\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\dumpEEPROM\dumpEEPROM.cpp ===
#include <ntos.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include "PerBoxData.h"
#include "cryptkeys.h"

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

HRESULT ReadPerBoxData()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    char RecoveryKey[8];
    
    //
    // Get some pointers ready
    //
    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    // 
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    //if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return NTE_BAD_DATA;
        }
    }

    //
    // Double check the hard drive key
    //
    ASSERT( HARD_DRIVE_KEY_LEN == XBOX_KEY_LENGTH );
    if (!RtlEqualMemory( pEncryptedEEPROMData->HardDriveKey, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"HardDriveKey does not match");
        return NTE_BAD_KEY;        
    }

    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );

#if DBG
    XDBGTRC("factory", "OnlineKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        factorySettings->OnlineKey[0], factorySettings->OnlineKey[1],
        factorySettings->OnlineKey[2], factorySettings->OnlineKey[3],
        factorySettings->OnlineKey[4], factorySettings->OnlineKey[5],
        factorySettings->OnlineKey[6], factorySettings->OnlineKey[7],
        factorySettings->OnlineKey[8], factorySettings->OnlineKey[9],
        factorySettings->OnlineKey[10], factorySettings->OnlineKey[11],
        factorySettings->OnlineKey[12], factorySettings->OnlineKey[13],
        factorySettings->OnlineKey[14], factorySettings->OnlineKey[15]
        );

    XDBGTRC("factory", "HardDriveKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
        pEncryptedEEPROMData->HardDriveKey[0], pEncryptedEEPROMData->HardDriveKey[1],
        pEncryptedEEPROMData->HardDriveKey[2], pEncryptedEEPROMData->HardDriveKey[3],
        pEncryptedEEPROMData->HardDriveKey[4], pEncryptedEEPROMData->HardDriveKey[5],
        pEncryptedEEPROMData->HardDriveKey[6], pEncryptedEEPROMData->HardDriveKey[7],
        pEncryptedEEPROMData->HardDriveKey[8], pEncryptedEEPROMData->HardDriveKey[9],
        pEncryptedEEPROMData->HardDriveKey[10], pEncryptedEEPROMData->HardDriveKey[11],
        pEncryptedEEPROMData->HardDriveKey[12], pEncryptedEEPROMData->HardDriveKey[13],
        pEncryptedEEPROMData->HardDriveKey[14], pEncryptedEEPROMData->HardDriveKey[15]
        );

    ComputeRecoveryKey( pEncryptedEEPROMData->HardDriveKey, RecoveryKey );
    XDBGTRC("factory", "RecoveryKey: %.8s", RecoveryKey);

    XDBGTRC("factory", "MACAddress: %02x%02x%02x%02x%02x%02x",
        factorySettings->EthernetAddr[0], factorySettings->EthernetAddr[1],
        factorySettings->EthernetAddr[2], factorySettings->EthernetAddr[3],
        factorySettings->EthernetAddr[4], factorySettings->EthernetAddr[5]
        );

    XDBGTRC("factory", "XboxSerialNumber: %.12s", factorySettings->SerialNumber);
    
    XDBGTRC("factory", "GameRegion: %X", pEncryptedEEPROMData->GameRegion);

    XDBGTRC("factory", "AVRegion: %X", factorySettings->AVRegion);
#endif
    
    return S_OK;
}

//======================== The main function
void __cdecl main()
{
    HRESULT hr;
    
#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    hr = ReadPerBoxData();
    if ( FAILED( hr ) )
    {
        XDBGTRC("factory", "ReadPerBoxData returned %x",hr);
        goto ErrorExit;        
    }

ErrorExit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenPerBoxData\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <windows.h>
#include <assert.h>
#include "Base64.h"
#include "gpbdver.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenOnlineKey\GenOnlineKey.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <assert.h>
#include <wincrypt.h>
#include <cryptkeys.h>
#include <base64.h>

BYTE g_PublicKey[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xff, 0xb8, 0x5b, 0x38, 0x9a, 0x63, 0x9e, 0x72, 0x5c, 0x32, 0x85, 0x17,
    0x04, 0xe2, 0xdf, 0xe4, 0xc7, 0x13, 0xb5, 0xe6, 0x02, 0xd9, 0x2f, 0x3d, 0x24, 0x03, 0x43, 0xda,
    0x03, 0xf6, 0x9c, 0xcf, 0xaa, 0x7d, 0x9e, 0x6e, 0xc2, 0xb9, 0xe4, 0x76, 0x16, 0xf9, 0xe9, 0x4e,
    0x2c, 0x6c, 0xf3, 0x1b, 0x95, 0x3c, 0x94, 0x0f, 0x69, 0x5d, 0xdd, 0x09, 0xfd, 0x27, 0x57, 0xa7,
    0x95, 0x02, 0xc6, 0xfb, 0x4d, 0x96, 0xb4, 0x5e, 0x8b, 0xfa, 0xc1, 0x34, 0x60, 0xac, 0x06, 0xbb,
    0xa9, 0x85, 0x56, 0xbb, 0xeb, 0x40, 0xf3, 0xb2, 0xb7, 0xc3, 0x28, 0x75, 0x3d, 0xb9, 0x53, 0x26,
    0x9b, 0x1e, 0x49, 0x48, 0x80, 0x43, 0xc9, 0x09, 0xb2, 0xa3, 0x20, 0x49, 0x28, 0x21, 0xe4, 0x31,
    0xb1, 0xad, 0x55, 0x9e, 0xce, 0x7c, 0xa5, 0x97, 0xee, 0xe1, 0x26, 0xe9, 0xbc, 0x13, 0x4f, 0x1e,
    0xa0, 0x5d, 0xa2, 0xbe };

HCRYPTPROV g_hProv = 0;
HCRYPTKEY g_hPubKey = 0;

static HRESULT getProviderAndKey()
{
    BOOL bResult;
    HRESULT hr;

    if ( g_hProv )
    {
        return S_OK;
    }
    
    CryptAcquireContext( &g_hProv, "XboxTemp001", MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
    g_hProv = 0;

    //
    // Create a temporay provider context to import the keys
    //
    bResult = CryptAcquireContext(&g_hProv,
                               "XboxTemp001",
                               MS_ENHANCED_PROV,
                               PROV_RSA_FULL,
                               CRYPT_NEWKEYSET);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Unable to create temporary provider handle\n");
        g_hProv = 0;
        return hr;
    }

    //
    // Import the public key
    //
    bResult = CryptImportKey(g_hProv, g_PublicKey, sizeof(g_PublicKey), NULL, 0, &g_hPubKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Failed CryptImportKey [%x]\n", hr);
        CryptReleaseContext( g_hProv, 0 );
        g_hPubKey = 0;
        return hr;
    }

    return S_OK;
}

HRESULT EncryptOnlineKey (
    IN char* pcXboxSerialNumber,
    IN LPBYTE pbOnlineKey,
    IN LPBYTE pbHardDriveKey,
    IN LPBYTE pbMACAddress,
    IN DWORD GameRegion,
    IN DWORD AVRegion,
    OUT DWORD* pdwOnlineKeyVersion,
    OUT LPBYTE pbEncOnlineKey
    )
{
    BOOL bResult;
    HRESULT hr;
    
    XBOX_ENCRYPTED_ONLINE_DATA EncData;
    DWORD dwDataLen;
    
    RtlZeroMemory( &EncData, sizeof(EncData) );
    RtlCopyMemory( EncData.XboxSerialNumber, pcXboxSerialNumber, XBOX_SERIAL_NUMBER_LEN );
    RtlCopyMemory( EncData.OnlineKey, pbOnlineKey, ONLINE_KEY_LEN );
    RtlCopyMemory( EncData.HardDriveKey, pbHardDriveKey, HARD_DRIVE_KEY_LEN );
    RtlCopyMemory( EncData.MACAddress, pbMACAddress, ETHERNET_MAC_ADDR_LEN );
    EncData.GameRegion = GameRegion;
    EncData.AVRegion = AVRegion;

    RtlZeroMemory( pbEncOnlineKey, ONLINE_KEY_PKENC_SIZE );
    RtlCopyMemory( pbEncOnlineKey, &EncData, sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) );
    
    //
    // Encrypt the online key with the public key.
    //
    dwDataLen = sizeof(XBOX_ENCRYPTED_ONLINE_DATA);
    bResult = CryptEncrypt( g_hPubKey, NULL, TRUE, 0, pbEncOnlineKey, &dwDataLen, ONLINE_KEY_PKENC_SIZE );
    if(!bResult)
    {
        hr = GetLastError();
        printf("Error %x during CryptEncrypt! Bytes required:%lu\n", hr, dwDataLen);
        goto error;
    }

    assert( dwDataLen == ONLINE_KEY_PKENC_SIZE );

    *pdwOnlineKeyVersion = 1;
    
    hr = S_OK;
    
error:

    return hr;
}



void PrintUsage()
{
    printf("Usage: GenOnlineKey 16ByteKeyInHex\n");    
}

extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{
    HRESULT hr;

    DWORD GameRegion = 0;
    DWORD AVRegion = 0;
    BYTE pbMACAddress[ETHERNET_MAC_ADDR_LEN] = {0,0,0,0,0,0};
    char pcXboxSerialNumber[XBOX_SERIAL_NUMBER_LEN] = {'9','9','9','9','9','9','9','9','9','9','9','9'};
    DWORD dwOnlineKeyVersion;
    char pcOnlineKey[173];

    BOOL bResult;
    DWORD i;
    int byte;
    
    // Data and buffers
    XBOX_ENCRYPTED_PER_BOX_DATA output;
    BYTE pbOnlineKey[ONLINE_KEY_PKENC_SIZE];

    RtlZeroMemory( &output, sizeof(output) );

    if (argc != 2 || strlen(argv[1]) != 32)
    {
        PrintUsage();
        return 1;
    }

    for( i = 0; i < ONLINE_KEY_LEN; ++i )
    {
         sscanf(&(argv[1][i*2]), "%2x", &byte );
         output.OnlineKey[i] = (BYTE)byte;
    }
    
    for( i = 0; i < XBOX_SERIAL_NUMBER_LEN; ++i )
    {
        if (!isalnum(pcXboxSerialNumber[i]))
        {
            return E_INVALIDARG;
        }
    }
    
    output.GameRegion = GameRegion;
    output.AVRegion = AVRegion;
    RtlCopyMemory( output.MACAddress, pbMACAddress, sizeof(output.MACAddress) );
    RtlCopyMemory( output.XboxSerialNumber, pcXboxSerialNumber, sizeof(output.XboxSerialNumber) );

    //
    // Get Crypto API provider and public key.
    //
    hr = getProviderAndKey();
    if ( FAILED( hr) )
    {
        goto error;
    }

    //
    // Generate the random bytes we need
    //
    bResult = CryptGenRandom(g_hProv, sizeof(output.HardDriveKey), (LPBYTE)&output.HardDriveKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;
    }
    
    //
    // Encrypt the online key
    //
    hr = EncryptOnlineKey( output.XboxSerialNumber,
                           output.OnlineKey, output.HardDriveKey,
                           output.MACAddress, output.GameRegion, output.AVRegion,
                           &dwOnlineKeyVersion, pbOnlineKey );
    if ( FAILED( hr) )
    {
        goto error;
    }

    assert( BASE64_ENCODE_BUFFER_SIZE( ONLINE_KEY_PKENC_SIZE ) == 173 );
    bResult = Base64Encode( pbOnlineKey, ONLINE_KEY_PKENC_SIZE, pcOnlineKey );    

    //
    // Clear the temp output buffer
    //
    RtlZeroMemory( &output, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) );

    printf( pcOnlineKey );
    printf( "\n" );
    
    hr = S_OK;
    
error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\green\greenp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    greenp.cpp

Abstract:

    This is a pre-compile header file.

--*/

#include <ntos.h>
#include <stdio.h>

#include <xtl.h>
#include <xdbg.h>
#include <xboxp.h>
#include <xconfig.h>
#include <xboxverp.h>

#define XFONT_TRUETYPE
#include <xfont.h>

#include "xboxvideo.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\green\green.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    green.cpp

Abstract:

    This module implements routine to display green background on TV

--*/

#include "greenp.h"

CXBoxVideo g_Video;

void __cdecl main()
{
    g_Video.Initialize(640, 480);
    g_Video.ClearScreen(COLOR_MEDIUM_GREEN);
    g_Video.ShowScreen();
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenPerBoxData\gpbdver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_GPBDBuildNumberD")
__declspec(selectany) unsigned short GPBDBuildNumberD[8] = { 'G' | ('P' << 8), 'B' | ('D' << 8), 'A' | ('T' << 8), 'A' | ('D' << 8),
                                        VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_GPBDBuildNumber")
__declspec(selectany) unsigned short GPBDBuildNumber[8] = { 'G' | ('P' << 8), 'B' | ('D' << 8), 'A' | ('T' << 8), 'A',
                                        VER_PRODUCTVERSION };
#endif

#pragma data_seg()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenPerBoxData\GenPerBoxData.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <wincrypt.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include "sha.h"
#include "rc4.h"
#include "PerBoxData.h"
#include "cryptKeys.h"
#include "base64.h"
#include "gpbdver.h"

//#define DETAILED_CHECKS 1

//#define DETAILED_TRACE 1

//#define DETAILED_LOG_FILE 1

//#define USE_TEST_KEY 1

//#define REPEAT_COUNT 1000

//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
static void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


#define RC4_CONFOUNDER_LEN 8

typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}

VOID AppendFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD dwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesWrote;
    DWORD dwPos;

    hFile = CreateFile(lpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("GeneratePerBoxData: unable to open %s, error %X\n", lpFileName, GetLastError());
        return;
    }

    dwPos = SetFilePointer( hFile, 0, NULL, FILE_END );
    if ( dwPos == INVALID_SET_FILE_POINTER )
    {
        printf("GeneratePerBoxData: unable to seek %s, error %X\n", lpFileName, GetLastError());
        return;        
    }

    if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) || (dwBytesWrote != dwFileSize))
    {
        printf("GeneratePerBoxData: cannot write to %s, error %X\n", lpFileName, GetLastError() );
        return;
    }

    CloseHandle(hFile);
}

#ifndef USE_TEST_KEY
//
// The private key matching this public key is in an nCipher box
//
BYTE g_PublicKey[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xff, 0xb8, 0x5b, 0x38, 0x9a, 0x63, 0x9e, 0x72, 0x5c, 0x32, 0x85, 0x17,
    0x04, 0xe2, 0xdf, 0xe4, 0xc7, 0x13, 0xb5, 0xe6, 0x02, 0xd9, 0x2f, 0x3d, 0x24, 0x03, 0x43, 0xda,
    0x03, 0xf6, 0x9c, 0xcf, 0xaa, 0x7d, 0x9e, 0x6e, 0xc2, 0xb9, 0xe4, 0x76, 0x16, 0xf9, 0xe9, 0x4e,
    0x2c, 0x6c, 0xf3, 0x1b, 0x95, 0x3c, 0x94, 0x0f, 0x69, 0x5d, 0xdd, 0x09, 0xfd, 0x27, 0x57, 0xa7,
    0x95, 0x02, 0xc6, 0xfb, 0x4d, 0x96, 0xb4, 0x5e, 0x8b, 0xfa, 0xc1, 0x34, 0x60, 0xac, 0x06, 0xbb,
    0xa9, 0x85, 0x56, 0xbb, 0xeb, 0x40, 0xf3, 0xb2, 0xb7, 0xc3, 0x28, 0x75, 0x3d, 0xb9, 0x53, 0x26,
    0x9b, 0x1e, 0x49, 0x48, 0x80, 0x43, 0xc9, 0x09, 0xb2, 0xa3, 0x20, 0x49, 0x28, 0x21, 0xe4, 0x31,
    0xb1, 0xad, 0x55, 0x9e, 0xce, 0x7c, 0xa5, 0x97, 0xee, 0xe1, 0x26, 0xe9, 0xbc, 0x13, 0x4f, 0x1e,
    0xa0, 0x5d, 0xa2, 0xbe };
#else
BYTE g_PublicKey[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xd7, 0xe4, 0x7a, 0x30, 0xe5, 0x8e, 0x1e, 0x87, 0xc8, 0xda, 0x7f, 0xae,
    0x22, 0xb5, 0x20, 0x35, 0x26, 0x78, 0x17, 0x11, 0x8d, 0xb6, 0xd7, 0xb1, 0xaa, 0xdb, 0x1f, 0x54,
    0xc8, 0x0f, 0xca, 0x38, 0x56, 0x21, 0x88, 0x4b, 0x9d, 0x60, 0x4a, 0x8e, 0x36, 0xff, 0x81, 0x72,
    0x62, 0x00, 0xe0, 0xad, 0xaa, 0x9e, 0x22, 0x44, 0xd9, 0xcb, 0x0b, 0xbd, 0x7a, 0xf3, 0x87, 0x5f,
    0x01, 0x76, 0x9e, 0x3f, 0xcf, 0x0c, 0x07, 0x3e, 0xe8, 0xaf, 0xa1, 0xe1, 0xdf, 0x6b, 0x6a, 0x38,
    0x77, 0x60, 0x42, 0x6e, 0xee, 0x10, 0x0a, 0x9e, 0xd8, 0x5c, 0x45, 0x59, 0x29, 0xe0, 0x21, 0x47,
    0x4c, 0x6a, 0xbf, 0xfc, 0x72, 0xfd, 0xdb, 0xa2, 0x64, 0x6e, 0x59, 0x1d, 0x36, 0x54, 0x28, 0xf1,
    0x8f, 0xca, 0xa7, 0x5d, 0x03, 0xaf, 0x31, 0x07, 0xbc, 0x47, 0x89, 0x5e, 0x6e, 0x44, 0x01, 0x3b,
    0xed, 0x0f, 0xd2, 0xd2 };

BYTE g_PrivateKey[] = {
    0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xd7, 0xe4, 0x7a, 0x30, 0xe5, 0x8e, 0x1e, 0x87, 0xc8, 0xda, 0x7f, 0xae,
    0x22, 0xb5, 0x20, 0x35, 0x26, 0x78, 0x17, 0x11, 0x8d, 0xb6, 0xd7, 0xb1, 0xaa, 0xdb, 0x1f, 0x54,
    0xc8, 0x0f, 0xca, 0x38, 0x56, 0x21, 0x88, 0x4b, 0x9d, 0x60, 0x4a, 0x8e, 0x36, 0xff, 0x81, 0x72,
    0x62, 0x00, 0xe0, 0xad, 0xaa, 0x9e, 0x22, 0x44, 0xd9, 0xcb, 0x0b, 0xbd, 0x7a, 0xf3, 0x87, 0x5f,
    0x01, 0x76, 0x9e, 0x3f, 0xcf, 0x0c, 0x07, 0x3e, 0xe8, 0xaf, 0xa1, 0xe1, 0xdf, 0x6b, 0x6a, 0x38,
    0x77, 0x60, 0x42, 0x6e, 0xee, 0x10, 0x0a, 0x9e, 0xd8, 0x5c, 0x45, 0x59, 0x29, 0xe0, 0x21, 0x47,
    0x4c, 0x6a, 0xbf, 0xfc, 0x72, 0xfd, 0xdb, 0xa2, 0x64, 0x6e, 0x59, 0x1d, 0x36, 0x54, 0x28, 0xf1,
    0x8f, 0xca, 0xa7, 0x5d, 0x03, 0xaf, 0x31, 0x07, 0xbc, 0x47, 0x89, 0x5e, 0x6e, 0x44, 0x01, 0x3b,
    0xed, 0x0f, 0xd2, 0xd2, 0xdd, 0x54, 0xef, 0x5d, 0xf9, 0xb1, 0x7b, 0xc5, 0x89, 0x69, 0x2a, 0x5f,
    0xbc, 0x42, 0x29, 0xec, 0xd2, 0x59, 0x6e, 0x1d, 0x82, 0x98, 0x87, 0x32, 0x93, 0xff, 0x44, 0xd5,
    0x6f, 0x01, 0x92, 0x81, 0x67, 0x3b, 0x3e, 0xe7, 0x27, 0xf8, 0xdf, 0x69, 0x33, 0xd9, 0x4f, 0xd1,
    0xf5, 0xda, 0xae, 0x77, 0x11, 0xa8, 0x31, 0xdc, 0x7f, 0x40, 0x47, 0x14, 0x04, 0xc6, 0x4e, 0x2e,
    0x3c, 0x41, 0xf0, 0xf9, 0x43, 0xfb, 0x7f, 0x2d, 0x4a, 0xe8, 0xb0, 0x7c, 0x78, 0x18, 0xec, 0x8e,
    0x96, 0xf9, 0xea, 0x9d, 0x83, 0x6f, 0x9f, 0x14, 0xc6, 0x37, 0x52, 0x07, 0x37, 0x57, 0xa7, 0x30,
    0x64, 0xa8, 0x32, 0xe6, 0xb0, 0xea, 0xb6, 0x98, 0x3d, 0x54, 0x73, 0x5e, 0x44, 0xcf, 0x15, 0x61,
    0x21, 0xee, 0x42, 0x6e, 0x50, 0x33, 0xba, 0x74, 0xae, 0x37, 0xb0, 0x3b, 0xde, 0x71, 0xc0, 0xdd,
    0x7e, 0xf1, 0xee, 0xd7, 0x9d, 0x8b, 0xa7, 0x0f, 0x90, 0xd6, 0x23, 0xbc, 0xe0, 0x5a, 0x93, 0x42,
    0x08, 0xf9, 0x0a, 0xa4, 0x03, 0x33, 0xbe, 0x4c, 0xe1, 0xbf, 0xf7, 0x54, 0xf5, 0x57, 0xf6, 0x57,
    0x1c, 0xbb, 0x79, 0xec, 0x0a, 0x71, 0x14, 0x64, 0x9c, 0xb4, 0xab, 0xd3, 0x74, 0x1a, 0x4c, 0xd2,
    0x57, 0x1d, 0xac, 0x4d, 0x10, 0xc3, 0xa2, 0xea, 0x33, 0x1b, 0x33, 0x32, 0xb2, 0x66, 0xab, 0x68,
    0x24, 0xea, 0xf1, 0xf1, 0xef, 0x1a, 0xef, 0xf7, 0x90, 0xb1, 0x2c, 0xf4, 0x1d, 0x7e, 0xd4, 0x1b,
    0x1f, 0x96, 0x14, 0x81, 0xa6, 0x48, 0x0d, 0xa3, 0x88, 0x07, 0x8e, 0x93, 0xfe, 0x63, 0xd0, 0x19,
    0x70, 0xbc, 0x09, 0xbb, 0x19, 0xcb, 0x04, 0xf9, 0x6f, 0xc1, 0x6b, 0x07, 0x09, 0xf0, 0x9c, 0x7b,
    0xb7, 0x77, 0x9d, 0xae, 0x07, 0x82, 0xfc, 0x89, 0x0e, 0x08, 0x68, 0x3f, 0x42, 0x21, 0x36, 0x22,
    0xf7, 0xb1, 0x65, 0xa5, 0xd8, 0xd8, 0x06, 0x50, 0x9e, 0xf3, 0xef, 0xbf, 0xf9, 0x29, 0xf2, 0xa1,
    0x89, 0x7a, 0xc9, 0x90, 0xea, 0x73, 0xfe, 0x71, 0xfb, 0x3a, 0x01, 0xa3, 0xe4, 0xae, 0x1d, 0x8e,
    0x51, 0x07, 0xfb, 0xd2, 0x40, 0xe2, 0x87, 0x49, 0x8d, 0xc1, 0xc0, 0x92, 0x77, 0x9a, 0x2d, 0xbb,
    0xff, 0x06, 0xbd, 0xb1, 0xb8, 0xb2, 0xae, 0x6d, 0x03, 0xcb, 0x0e, 0xbb, 0x47, 0x1d, 0x9c, 0x66,
    0xc2, 0xa6, 0xb7, 0x5d, 0xe9, 0x33, 0x23, 0x3a, 0xe2, 0xca, 0x45, 0xb2, 0x06, 0x82, 0x6b, 0x51,
    0x32, 0xa2, 0x06, 0x77, 0xbd, 0xc4, 0x40, 0x47, 0x83, 0x5c, 0x89, 0xd3, 0x6a, 0x59, 0x0b, 0xc2,
    0x7f, 0x3b, 0xba, 0x3c, 0x46, 0x0d, 0xd9, 0x71, 0x62, 0x24, 0x8d, 0x40, 0xe5, 0x68, 0x4e, 0x68,
    0x7a, 0xa7, 0x3e, 0xbd, 0x09, 0x33, 0x54, 0x7e, 0x1f, 0xe6, 0x50, 0x28, 0x83, 0x29, 0x25, 0x13,
    0x5a, 0x3b, 0xe0, 0xa4, 0x89, 0x98, 0xaa, 0x51, 0xe7, 0x49, 0x20, 0xef, 0x7e, 0xe5, 0xcc, 0x94,
    0x53, 0x84, 0xfd, 0xd0, 0x13, 0xd0, 0x28, 0x9e, 0xfe, 0x37, 0xc8, 0x96, 0x24, 0x1a, 0xa3, 0x91,
    0x6d, 0x28, 0xcb, 0xee, 0xa5, 0xf5, 0xa0, 0x70, 0xc3, 0xb0, 0xf6, 0xca, 0xe3, 0xc4, 0xa8, 0x2e,
    0xaf, 0xde, 0xe4, 0x7e, 0x6b, 0x93, 0x62, 0xa2, 0x02, 0x1e, 0xf4, 0x38, 0x5d, 0x97, 0x3b, 0x87,
    0x28, 0x81, 0x35, 0x61 };
#endif

HCRYPTPROV g_hProv = 0;
HCRYPTKEY g_hPubKey = 0;
#ifdef USE_TEST_KEY
HCRYPTKEY g_hPrvKey = 0;
#endif

static HRESULT getProviderAndKey()
{
    BOOL bResult;
    HRESULT hr;

    if ( g_hProv )
    {
        return S_OK;
    }
    
    CryptAcquireContext( &g_hProv, "XboxTemp001", MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
    g_hProv = 0;

    //
    // Create a temporay provider context to import the keys
    //
    bResult = CryptAcquireContext(&g_hProv,
                               "XboxTemp001",
                               MS_ENHANCED_PROV,
                               PROV_RSA_FULL,
                               CRYPT_NEWKEYSET);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Unable to create temporary provider handle\n");
        g_hProv = 0;
        return hr;
    }

    //
    // Import the public key
    //
    bResult = CryptImportKey(g_hProv, g_PublicKey, sizeof(g_PublicKey), NULL, 0, &g_hPubKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Failed CryptImportKey [%x]\n", hr);
        CryptReleaseContext( g_hProv, 0 );
        g_hPubKey = 0;
        return hr;
    }

#ifdef USE_TEST_KEY
    //
    // Import the private key
    //
    bResult = CryptImportKey(g_hProv, g_PrivateKey, sizeof(g_PrivateKey), NULL, 0, &g_hPrvKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("Failed CryptImportKey [%x]\n", hr);
        CryptReleaseContext( g_hProv, 0 );
        g_hPrvKey = 0;
        return hr;
    }
#endif

    return S_OK;
}

HRESULT EncryptOnlineKey (
    IN char* pcXboxSerialNumber,
    IN LPBYTE pbOnlineKey,
    IN LPBYTE pbHardDriveKey,
    IN LPBYTE pbMACAddress,
    IN DWORD GameRegion,
    IN DWORD AVRegion,
    OUT DWORD* pdwOnlineKeyVersion,
    OUT LPBYTE pbEncOnlineKey
    )
{
    BOOL bResult;
    HRESULT hr;
    
    XBOX_ENCRYPTED_ONLINE_DATA EncData;
    DWORD dwDataLen;
    
    RtlZeroMemory( &EncData, sizeof(EncData) );
    RtlCopyMemory( EncData.XboxSerialNumber, pcXboxSerialNumber, XBOX_SERIAL_NUMBER_LEN );
    RtlCopyMemory( EncData.OnlineKey, pbOnlineKey, ONLINE_KEY_LEN );
    RtlCopyMemory( EncData.HardDriveKey, pbHardDriveKey, HARD_DRIVE_KEY_LEN );
    RtlCopyMemory( EncData.MACAddress, pbMACAddress, ETHERNET_MAC_ADDR_LEN );
    EncData.GameRegion = GameRegion;
    EncData.AVRegion = AVRegion;

#ifdef REPEAT_COUNT
    DWORD dwStart = GetTickCount();
    int i;
    for (i=0; i<REPEAT_COUNT; ++i) {
#endif

    RtlZeroMemory( pbEncOnlineKey, ONLINE_KEY_PKENC_SIZE );
    RtlCopyMemory( pbEncOnlineKey, &EncData, sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) );
    
    //
    // Encrypt the online key with the public key.
    //
    dwDataLen = sizeof(XBOX_ENCRYPTED_ONLINE_DATA);
    bResult = CryptEncrypt( g_hPubKey, NULL, TRUE, 0, pbEncOnlineKey, &dwDataLen, ONLINE_KEY_PKENC_SIZE );
    if(!bResult)
    {
        hr = GetLastError();
        printf("Error %x during CryptEncrypt! Bytes required:%lu\n", hr, dwDataLen);
        goto error;
    }

#ifdef REPEAT_COUNT
    }
    printf("CryptEncrypt %d times took %d milliseconds\n", REPEAT_COUNT, GetTickCount() - dwStart);
#endif

    assert( dwDataLen == ONLINE_KEY_PKENC_SIZE );

#if defined(DETAILED_CHECKS) && defined(USE_TEST_KEY)
    //
    // Decrypt the online key with the private key.
    //
    BYTE buffer[ONLINE_KEY_PKENC_SIZE];
    RtlCopyMemory( buffer, pbEncOnlineKey, ONLINE_KEY_PKENC_SIZE );
    
    dwDataLen = ONLINE_KEY_PKENC_SIZE;
    bResult = CryptDecrypt( g_hPrvKey, NULL, TRUE, 0, buffer, &dwDataLen );
    if(!bResult)
    {
        hr = GetLastError();
        printf("Error %x during CryptDecrypt! Bytes output:%lu\n", hr, dwDataLen);
        goto error;
    }
    
    assert( dwDataLen == sizeof(XBOX_ENCRYPTED_ONLINE_DATA) );

    assert( RtlEqualMemory( buffer, &EncData, sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) ) );

#endif

    *pdwOnlineKeyVersion = 1;
    
    hr = S_OK;
    
error:

    return hr;
}


HRESULT GeneratePerBoxData (
    IN DWORD GameRegion,
    IN DWORD AVRegion,
    IN LPBYTE pbMACAddress, // ETHERNET_MAC_ADDR_LEN bytes
    IN char* pcXboxSerialNumber, // XBOX_SERIAL_NUMBER_LEN bytes
    OUT char* pcHardDriveKey,
    OUT char* pcRecoveryKey, // RECOVERY_KEY_LEN bytes
    OUT DWORD* pdwOnlineKeyVersion,
    OUT char* pcOnlineKey,
    OUT LPBYTE pbOutputBuffer,
    IN OUT DWORD* pdwOutputBufferSize
    )
{
    return GeneratePerBoxDataEx(
                NULL, // generate a random one
                GameRegion,
                AVRegion,
                pbMACAddress, // ETHERNET_MAC_ADDR_LEN bytes
                pcXboxSerialNumber, // XBOX_SERIAL_NUMBER_LEN bytes
                pcHardDriveKey,
                pcRecoveryKey, // RECOVERY_KEY_LEN bytes
                pdwOnlineKeyVersion,
                pcOnlineKey,
                pbOutputBuffer,
                pdwOutputBufferSize
                );
}


HRESULT GeneratePerBoxDataEx (
    IN char* pcInputHardDriveKey,
    IN DWORD GameRegion,
    IN DWORD AVRegion,
    IN LPBYTE pbMACAddress, // ETHERNET_MAC_ADDR_LEN bytes
    IN char* pcXboxSerialNumber, // XBOX_SERIAL_NUMBER_LEN bytes
    OUT char* pcHardDriveKey,
    OUT char* pcRecoveryKey, // RECOVERY_KEY_LEN bytes
    OUT DWORD* pdwOnlineKeyVersion,
    OUT char* pcOnlineKey,
    OUT LPBYTE pbOutputBuffer,
    IN OUT DWORD* pdwOutputBufferSize
    )
{
    HRESULT hr;
    BOOL bResult;
    DWORD i;
    
    // Data and buffers
    XBOX_ENCRYPTED_PER_BOX_DATA output;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE pbOnlineKey[ONLINE_KEY_PKENC_SIZE];

    BYTE decodeBuffer[256];
    DWORD dwSize;
    
    if ( pbOutputBuffer == NULL )
    {
        *pdwOutputBufferSize = sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER);      
        return S_OK;
    }
    if ( *pdwOutputBufferSize < sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER) )
    {
        return E_INVALIDARG;
    }
    *pdwOutputBufferSize = sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) + sizeof(RC4_SHA1_HEADER);

    for( i = 0; i < XBOX_SERIAL_NUMBER_LEN; ++i )
    {
        if (!isalnum(pcXboxSerialNumber[i]))
        {
            return E_INVALIDARG;
        }
    }
    
    RtlZeroMemory( &output, sizeof(output) );
    output.GameRegion = GameRegion;
    output.AVRegion = AVRegion;
    RtlCopyMemory( output.MACAddress, pbMACAddress, sizeof(output.MACAddress) );
    RtlCopyMemory( output.XboxSerialNumber, pcXboxSerialNumber, sizeof(output.XboxSerialNumber) );

    //
    // Get Crypto API provider and public key.
    //
    hr = getProviderAndKey();
    if ( FAILED( hr) )
    {
        goto error;
    }

    //
    // Generate the random bytes we need
    //
    if (pcInputHardDriveKey)
    {
        //
        // Use supplied key if one exists
        //
        bResult = Base64Decode( pcInputHardDriveKey, 24, decodeBuffer, &dwSize );
        if( !bResult || dwSize != sizeof(output.HardDriveKey) )
        {
            printf("Input Hard Drive Key failed to decode\n");
            goto error;
        }
        RtlCopyMemory( (LPBYTE)&output.HardDriveKey, decodeBuffer, sizeof(output.HardDriveKey) );
    }
    else
    {
        bResult = CryptGenRandom(g_hProv, sizeof(output.HardDriveKey), (LPBYTE)&output.HardDriveKey);
        if (!bResult)
        {
            hr = GetLastError();
            printf("CryptGenRandom failed with %x\n", hr);
            goto error;
        }
    }
    
    bResult = CryptGenRandom(g_hProv, sizeof(output.OnlineKey), (LPBYTE)&output.OnlineKey);
    if (!bResult)
    {
        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;
    }

    bResult = CryptGenRandom(g_hProv, sizeof(Confounder), (LPBYTE)&Confounder);
    if (!bResult)
    {
        hr = GetLastError();
        printf("CryptGenRandom failed with %x\n", hr);
        goto error;
    }

    //
    // Package bytes to be sent to WritePerBoxData
    //
    RtlCopyMemory( pbOutputBuffer + sizeof(RC4_SHA1_HEADER), &output, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) );
    rc4HmacEncrypt(
        Confounder,
        (LPBYTE)FACTORY_RAND_KEY, FACTORY_RAND_KEY_LEN,
        pbOutputBuffer + sizeof(RC4_SHA1_HEADER), sizeof(XBOX_ENCRYPTED_PER_BOX_DATA),
        pbOutputBuffer );

    //
    // Encrypt the online key
    //
    hr = EncryptOnlineKey( output.XboxSerialNumber,
                           output.OnlineKey, output.HardDriveKey,
                           output.MACAddress, output.GameRegion, output.AVRegion,
                           pdwOnlineKeyVersion, pbOnlineKey );
    if ( FAILED( hr) )
    {
        goto error;
    }

    assert( BASE64_ENCODE_BUFFER_SIZE( ONLINE_KEY_PKENC_SIZE ) == 173 );
    bResult = Base64Encode( pbOnlineKey, ONLINE_KEY_PKENC_SIZE, pcOnlineKey );    

    assert( BASE64_ENCODE_BUFFER_SIZE( sizeof(output.HardDriveKey) ) == 25 );
    bResult = Base64Encode( output.HardDriveKey, sizeof(output.HardDriveKey), pcHardDriveKey );    

#ifdef DETAILED_CHECKS
    //
    // Double check if decode gets back the same thing
    //
    bResult = Base64Decode( pcOnlineKey, 172, decodeBuffer, &dwSize );    
    assert( dwSize == ONLINE_KEY_PKENC_SIZE );
    assert( RtlEqualMemory( decodeBuffer, pbOnlineKey, dwSize ) );

    bResult = Base64Decode( pcHardDriveKey, 24, decodeBuffer, &dwSize );   
    assert( dwSize == sizeof(output.HardDriveKey) );
    assert( RtlEqualMemory( decodeBuffer, output.HardDriveKey, dwSize ) );
#endif

    //
    // Compute recovery key
    //
    ComputeRecoveryKey( output.HardDriveKey, pcRecoveryKey );

#ifdef DETAILED_TRACE
    //
    // Print out the keys
    //
    printf("OnlineKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
        output.OnlineKey[0], output.OnlineKey[1],
        output.OnlineKey[2], output.OnlineKey[3],
        output.OnlineKey[4], output.OnlineKey[5],
        output.OnlineKey[6], output.OnlineKey[7],
        output.OnlineKey[8], output.OnlineKey[9],
        output.OnlineKey[10], output.OnlineKey[11],
        output.OnlineKey[12], output.OnlineKey[13],
        output.OnlineKey[14], output.OnlineKey[15]
        );

    printf("HardDriveKey: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
        output.HardDriveKey[0], output.HardDriveKey[1],
        output.HardDriveKey[2], output.HardDriveKey[3],
        output.HardDriveKey[4], output.HardDriveKey[5],
        output.HardDriveKey[6], output.HardDriveKey[7],
        output.HardDriveKey[8], output.HardDriveKey[9],
        output.HardDriveKey[10], output.HardDriveKey[11],
        output.HardDriveKey[12], output.HardDriveKey[13],
        output.HardDriveKey[14], output.HardDriveKey[15]
        );

    printf("RecoveryKey: %.8s\n", pcRecoveryKey);

    printf("MACAddress: %.6s\n", output.MACAddress);

    printf("XboxSerialNumber: %.12s\n", output.XboxSerialNumber);
    
    printf("GameRegion: %X\n", output.GameRegion);

    printf("AVRegion: %X\n", output.AVRegion);
#endif

    //
    // Clear the temp output buffer
    //
    RtlZeroMemory( &output, sizeof(XBOX_ENCRYPTED_PER_BOX_DATA) );

#ifdef DETAILED_LOG_FILE
    char buffer[1024];

    sprintf( buffer, "%.12s %08X %08X %02X:%02X:%02X:%02X:%02X:%02X %s %.8s %02X %s\r\n",
        pcXboxSerialNumber, GameRegion, AVRegion,
        pbMACAddress[0], pbMACAddress[1], pbMACAddress[2],
        pbMACAddress[3], pbMACAddress[4], pbMACAddress[5],
        pcHardDriveKey,
        pcRecoveryKey,
        *pdwOnlineKeyVersion,
        pcOnlineKey );
        
    AppendFileFromMemory( "C:\\GeneratePerBoxData_log.txt", buffer, strlen(buffer) );
#endif

    hr = S_OK;
    
error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\green\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );

    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader

private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth;
    int m_ScreenHeight;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\green\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\green\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "greenp.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}

// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}
// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\GenTest\GenTest.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <assert.h>
#include <xboxp.h>
#include <av.h>
#include "PerBoxData.h"
#include "cryptkeys.h"

VOID
WriteFileFromMemory(
    LPCSTR lpFileName,
    LPVOID pvFileContents,
    DWORD dwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesWrote;

    hFile = CreateFile(lpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "GenTest: error: unable to open %s\n", lpFileName);
        exit(1);
    }

    if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) ||
        (dwBytesWrote != dwFileSize)) {
        fprintf(stderr, "GenTest: error: cannot write to %s\n", lpFileName);
        exit(1);
    }

    CloseHandle(hFile);
}

void PrintUsage()
{
    printf("Usage: GenTest -l n -p\n");    
}

extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{
    HRESULT hr;
    DWORD GameRegion = XC_GAME_REGION_NA;
    DWORD AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
    BYTE MACAddress[ETHERNET_MAC_ADDR_LEN] = { 0x00,0x50,0xF2,0x00,0x66,0x66 };
    char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN] = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' };
    char HardDriveKey[25];
    char RecoveryKey[RECOVERY_KEY_LEN];
    DWORD dwOnlineKeyVersion = 0;
    char OnlineKey[173];
    BYTE buffer[512];
    DWORD dwBufferSize = 0;
    DWORD tickCt;
    int i,n;
    int loop=1;
    BOOL pause = FALSE;

    n = 1;
    while (n < argc)
    {
       // loop a number of iterations
       if (_stricmp(argv[n], "-l") == 0)
       {
          if ((n+1) < argc)
          {
             loop = atoi(argv[++n]);
          }
          else
          {
             PrintUsage();
             return 1;
          }
       }
       // Pause between loops
       else if (_stricmp(argv[n], "-p") == 0)
       {
          if (n < argc)
          {
              pause = TRUE;
          }
          else
          {
              PrintUsage();
              return 1;
          }
       }
       
       ++n;
    }
    
    printf("Looping %d iterations\n", loop);
    tickCt = GetTickCount();

    MACAddress[4] = (BYTE)(tickCt & 0xff);
    MACAddress[5] = (BYTE)((tickCt>>8) & 0xfe);
    
    for (i=0; i<loop; ++i)
    {
        dwBufferSize = sizeof(buffer);
        hr = GeneratePerBoxData (
                GameRegion,
                AVRegion,
                MACAddress,
                XboxSerialNumber,
                HardDriveKey,
                RecoveryKey,
                &dwOnlineKeyVersion,
                OnlineKey,
                buffer,
                &dwBufferSize );
            
        if ( FAILED( hr ) )
        {
            printf("Failed GeneratePerBoxData - [%x]\n", hr);
            return 1;
        }
        
        if (pause)
        {
            printf("Finished iteration %d, hit enter for next iteration\n", i);
            getchar();
        }
    }
    
    printf("Took %d ms\n", GetTickCount() - tickCt);
    
    WriteFileFromMemory( "perBoxImage.dat", buffer, dwBufferSize );

    printf("HardDriveKey: %s\n", HardDriveKey);

    printf("RecoveryKey: %.8s\n", RecoveryKey);

    printf("dwOnlineKeyVersion: %d\n", dwOnlineKeyVersion);

    printf("OnlineKey: %s\n", OnlineKey);

    for (i=0; i<loop; ++i)
    {
        dwBufferSize = sizeof(buffer);
        hr = GeneratePerBoxDataEx (
                HardDriveKey,
                GameRegion,
                AVRegion,
                MACAddress,
                XboxSerialNumber,
                HardDriveKey,
                RecoveryKey,
                &dwOnlineKeyVersion,
                OnlineKey,
                buffer,
                &dwBufferSize );
            
        if ( FAILED( hr ) )
        {
            printf("Failed GeneratePerBoxData - [%x]\n", hr);
            return 1;
        }
        
        if (pause)
        {
            printf("Finished iteration %d, hit enter for next iteration\n", i);
            getchar();
        }
    }
    
    printf("Took %d ms\n", GetTickCount() - tickCt);
    
    WriteFileFromMemory( "perBoxImage.dat", buffer, dwBufferSize );

    printf("HardDriveKey: %s\n", HardDriveKey);

    printf("RecoveryKey: %.8s\n", RecoveryKey);

    printf("dwOnlineKeyVersion: %d\n", dwOnlineKeyVersion);

    printf("OnlineKey: %s\n", OnlineKey);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\oobaudit\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\CXCrypto.h ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
//===================================================================
#ifndef _CXCRYPTO_H_
#define _CXCRYPTO_H_

#include <xtl.h>
#include <init.h>
#include <xboxp.h>
#include <av.h>

#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>

#include <wincrypt.h>
#include <cryptkeys.h>
#include <sha.h>
#include <rc4.h>
  
#define RC4_CONFOUNDER_LEN 8
//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;


class CXCrypto {
private:
   
public:

    BOOL  rc4HmacDecrypt(
                    IN PUCHAR pbKey,
                    IN ULONG cbKey,
                    IN PUCHAR pbInput,
                    IN ULONG cbInput,
                    IN PUCHAR pbHeader); // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes 
                         
    void rc4HmacEncrypt(
                    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
                    IN PUCHAR pbKey,
                    IN ULONG cbKey,
                    IN PUCHAR pbInput,
                    IN ULONG cbInput,
                    OUT PUCHAR pbHeader); // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes

    ~CXCrypto() {}
    CXCrypto() {}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\OnlineDump.h ===
#include <ntos.h>  //ntos has to come before xtl.h
#include <xtl.h>
#include <xboxp.h>


CONST DWORD APPEND_FILE = 0;
CONST DWORD NEW_FILE    = 1;


#define BREAK_INTO_DEBUGGER     _asm { int 3 }
// Prototypes


CONST WORD TOP   = 1;
CONST WORD BOTTOM= 0;
  

class COnlineDump: public CXCrypto {

public:

      COnlineDump( VOID ){}
      ~COnlineDump( VOID ){}

      DWORD
      DetermineBitMask(IN DWORD dwBitMask);

      VOID DrawMessage(const PCHAR pcszTextLine1, const PCHAR pcszTextLine2, DWORD dwColor);

      BOOL
      ReadEEPROM ( BYTE* pbData );
      
      BOOL 
      FileToDrive( LPCSTR lpFileName,
                   LPVOID pvFileContents,
                   DWORD dwFileSize,
                   DWORD dwWriteFlags );
   
      VOID DebugOut (PCHAR szMessage,...);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\locktest\LockTest.cpp ===
#include <ntos.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xdbg.h>
#include <xcrypt.h>
#include <cryptkeys.h>

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

BOOL HDUnlock( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_UNLOCK;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDUnlock", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDUnlock", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
    	SecurityData.Maximum = TRUE;
	    SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}

void __cdecl main()
{
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    
#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    __asm int 3;

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
    }
    
    //
    // Compute Key to use to lock hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
                         
    //HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );

    //HDUnlock( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );

    //HDDisablePassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <stdio.h>
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\oobaudit\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\CXCrypto.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "CXCrypto.h"

void 
CXCrypto::
rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


BOOL 
CXCrypto::
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\KeyFromCert\KeyFromCert.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <wincrypt.h>
#include <rpc.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <malloc.h>

#define PROVIDER MS_ENHANCED_PROV

#define ENCODING (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

//
// Print Usage
//
void PrintUsage(void)
{
    printf("Usage: KeyFromCert CertFileName PublicKeyFileName\n");
}

int __cdecl main(int argc, char *argv[])
{
    BOOL bResult;
    char* pszCertFile;
    char* pszKeyFile;
    DWORD dwSize;
    DWORD dwWritten,dwRead;

    HCRYPTPROV hProv = 0;
    UUID Uuid;
    
    PCCERT_CONTEXT pCertificateContext;

    HCRYPTKEY hPubKey = 0;
    HANDLE hFile;
    HANDLE hKeyFile;
    HRESULT hr;
    
    BYTE* pbExportedKey;
    BYTE* pbEncodedCert;
    LPWSTR szwContainer = NULL;
    RPC_STATUS Status;

    // Print Usage
    if (argc < 3)
    {
        PrintUsage();
        return 0;
    }

    // Set Certificate file Name
    pszCertFile = argv[1];
    pszKeyFile = argv[2];

    // Open Certificate file
    hFile = CreateFileA(pszCertFile,
                   GENERIC_READ,
                   0,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
       printf("Unable to open certificate file\n");
       goto ErrorExit;
    }

    // Get file length
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF)
    {
       printf("Unable to get size of certificate file\n");
       goto ErrorExit;
    }

    // Allocate memory for encoded certificate
    pbEncodedCert = (LPBYTE)_alloca(dwSize);
    if (!pbEncodedCert)
    {
       printf("Unable to allocate memory for encoded certificate\n");
       goto ErrorExit;
    }

    // Read encoded certificate data
    bResult = ReadFile(hFile,
                    (LPVOID)pbEncodedCert,
                    dwSize,
                    &dwRead,
                    NULL);
    if (!bResult)
    {
       printf("Unable to read encoded certificate\n");
       goto ErrorExit;
    }

    assert( dwRead == dwSize );

    // Close file handle
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    {
        HCRYPTPROV hTemp;

        // Create Temporary Provider
        bResult = CryptAcquireContext(&hTemp,
                                      L"Temp000",
                                      PROVIDER,
                                      PROV_RSA_FULL,
                                      CRYPT_NEWKEYSET);
        if (!bResult)
        {
           // If Temporary Provider exists already,
           // open it
           hr = GetLastError();
           if (hr == NTE_EXISTS)
           {
              bResult = CryptAcquireContext(&hTemp,
                                          L"Temp000",
                                          PROVIDER,
                                          PROV_RSA_FULL,
                                          0);
              if (!bResult)
              {
                 printf("Unable to get temporary provider handle\n");
		         goto ErrorExit;
              }
           }
           else
           {
              printf("Unable to create temporary provider handle\n");
              goto ErrorExit;
           }
        }

        // Place random data in Uuid
        // Could have used UuidCreate but it is not supported
        // under Win9x.
        bResult = CryptGenRandom(hTemp, sizeof(Uuid), (LPBYTE)&Uuid);
        if (!bResult)
        {
           hr = GetLastError();
           printf("CryptGenRandom failed with %x\n", hr);
           goto ErrorExit;
        }

        // Close Provider handle
        CryptReleaseContext(hTemp, 0);

        // Delete Container
        CryptAcquireContext(&hTemp,
                           L"Temp000",
                           PROVIDER,
                           PROV_RSA_FULL,
                           CRYPT_DELETEKEYSET);

        // convert random uuid to a string, we will use it as a container
        Status = UuidToString(&Uuid, &szwContainer);
        if (Status != RPC_S_OK)
        {
            hr = Status;
            printf("Unable to convert uuid to string\n");
            goto ErrorExit;
        }
    }

    // Create new crypto context
    bResult = CryptAcquireContext(&hProv,
                            szwContainer,
                            PROVIDER,
                            PROV_RSA_FULL,
                            CRYPT_NEWKEYSET);
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptAcquireContext failed with %x\n", hr);
       goto ErrorExit;
    }

    pCertificateContext = CertCreateCertificateContext( X509_ASN_ENCODING, pbEncodedCert, dwRead );
    if (!pCertificateContext)
    {
        hr = GetLastError();
        printf("Failed CertCreateCertificateContext [%x]\n", hr);
        goto ErrorExit;
    }

	bResult = CryptImportPublicKeyInfoEx(hProv, ENCODING, &(pCertificateContext->pCertInfo->SubjectPublicKeyInfo), CALG_RSA_KEYX, 0, NULL, &hPubKey );
    if (!bResult)
    {
       hr = GetLastError();
       printf("CryptImportPublicKeyInfoEx failed with %x\n", hr);
       goto ErrorExit;
    }

    // Get size of exported key blob
    bResult = CryptExportKey(hPubKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwSize);
    if (!bResult)
    {
          printf("CryptExportKey failed with %x\n", GetLastError());
          goto ErrorExit;
    }
      
    // Allocate memory for exported key blob
    pbExportedKey = (LPBYTE)_alloca(dwSize);
    if (!pbExportedKey)
    {
          printf("Unable to allocate memory for exported key\n");
          goto ErrorExit;
    }

    // Get exported key blob
    bResult = CryptExportKey(hPubKey, NULL, PUBLICKEYBLOB,
                               0, pbExportedKey, &dwSize);
    if (!bResult)
    {
          printf("CryptExportKey failed with %x\n", GetLastError());
          goto ErrorExit;
    }

    // Create Exported Key File
    hKeyFile = CreateFileA(pszKeyFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, NULL);
    if (hKeyFile == INVALID_HANDLE_VALUE)
    {
          printf("CreateFile failed with %d\n", GetLastError());
          goto ErrorExit;
    }

    // Write exported key to file
    bResult = WriteFile(hKeyFile, (LPVOID)pbExportedKey, dwSize, &dwWritten, NULL);
    if (!bResult)
    {
          printf("WriteFile failed with %d\n", GetLastError());
          goto ErrorExit;
    }

    assert( dwWritten == dwSize );

    // Close file handle
    CloseHandle(hKeyFile);
    hKeyFile = INVALID_HANDLE_VALUE;

    printf("Succeeded\n");

    return 0;
    
ErrorExit:

    printf("Failed\n");

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\OnlineDump\OnlineDump.cpp ===
#include <ntos.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#include "cryptkeys.h"
#include "xboxvideo.h"
#include "smcdef.h"
#include "xboxverp.h"
#include "ctype.h"
#include <xdbg.h>

#define XFONT_TRUETYPE
#include <xfont.h>

#include "CXCrypto.h"

#include "onlinedump.h"

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }


#define DUMP_SIZE (EEPROM_TOTAL_MEMORY_SIZE + sizeof(RC4_SHA1_HEADER) + XBOX_KEY_LENGTH)


CXBoxVideo* g_pVideo;


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, DWORD dwColor)
{
    ASSERT(g_pVideo && pcszTextLine1);

    g_pVideo->ClearScreen(dwColor);

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }


    WCHAR szBuildString[64];
    wsprintfW(szBuildString, L"XTL Version %hs", VER_PRODUCTVERSION_STR);
    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();

}

int __cdecl main()
{
   //
   // Dump Online related Contents.
   //
   COnlineDump* m = new COnlineDump();
   
   CHAR szSerialNumber[13];
   CHAR szFileName[400];
   WCHAR wszSuccessMessage[400];
   BYTE bData[DUMP_SIZE];
   BOOL bResult;
   DWORD dwDeviceBitMask;
   DWORD dwReturn;
   DWORD dwReturnVal;
   CHAR sz;
   DWORD dwInsertions;                  
   DWORD dwRemovals;
   DWORD dwReturnMask;
   XDEVICE_PREALLOC_TYPE xdpt = {XDEVICE_TYPE_MEMORY_UNIT, 8};
   EEPROM_LAYOUT* pel= (EEPROM_LAYOUT*)bData;
   XBOX_FACTORY_SETTINGS* pxfs = (XBOX_FACTORY_SETTINGS*)&pel->FactorySection;   
   
   //
   // Initialize our graphics.
   //
   if ((g_pVideo = new CXBoxVideo) == NULL)
   {
      m->DebugOut("Couldn't allocate video objects");
      goto Cleanup;
   }

   g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
   g_pVideo->ClearScreen(COLOR_BLACK);
   g_pVideo->ShowScreen();

   // Read the EEPROM and dump it.
   bResult = m->ReadEEPROM(bData);
   if (!bResult)
   {
      DrawMessage (L"Online Dump", L"Failed to read EEPROM. Aborting...", COLOR_TV_RED);
      goto Cleanup;
   }
   
   strncpy( szSerialNumber, (const char*)pxfs->SerialNumber,12);
   szSerialNumber[12] = '\0';

   //m->DrawText("Initializing MU's");
   XInitDevices( 1, &xdpt);
   dwDeviceBitMask = XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );

   for (;;) {
      // Some removal or insertion happened
      if (TRUE == XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, 
                                     &dwInsertions, &dwRemovals )) {
         if ( !dwRemovals ) {
            dwReturnMask = m->DetermineBitMask(dwInsertions); 
 
            dwReturnVal = XMountMU(dwReturnMask, HIWORD(dwInsertions)? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT, &sz );
            if ( ERROR_SUCCESS != dwReturnVal ) {
               DrawMessage (L"Online Dump", L"Failed to Mount MU.", COLOR_TV_RED);
               goto Cleanup;
            }

            //m->DrawText("Insert:: MU Plug %lu and %s Driveletter is %c", dwReturnMask, HIWORD(dwInsertions)? "BOTTOM":"TOP", sz );

            sprintf( szFileName,"%c:\\%s-%s.dat",sz,"EEPROM",szSerialNumber);
            wsprintfW( wszSuccessMessage, L"Dump to %hs successful.",szFileName);
            
            //XMUNameFromDriveLetter( sz, wszMUName, sizeof( wszMUName ));
            //m->DrawText("Writing %s to %S",szFileName,wszMUName);
            
            bResult = m->FileToDrive( szFileName, (LPVOID)bData, DUMP_SIZE, NEW_FILE );
            if (!bResult)
            {
               DrawMessage (L"Online Dump", L"Failed to write configuration out.", COLOR_TV_RED);
            }
            else
            {
               DrawMessage (L"Online Dump", wszSuccessMessage, COLOR_DARK_GREEN);
            }
            
            XUnmountMU( dwReturnMask, HIWORD(dwInsertions)? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT );

            goto Cleanup;
         }
         else if ( !dwInsertions )
         {
            dwReturnMask=m->DetermineBitMask(dwRemovals);
            // m->DrawText("Removed:: MU Plug %lu and %s Driveletter is %c", dwReturnMask, HIWORD(dwRemovals)? "BOTTOM":"TOP", sz );
         }
      }
   }

Cleanup:

   delete m;
   Sleep (INFINITE);

   return 0;
}




DWORD
COnlineDump::
DetermineBitMask(IN DWORD dwBitMask)
{


   DWORD dwReturnMask;

   if ( dwBitMask & XDEVICE_PORT0_TOP_MASK ) {
      dwReturnMask = XDEVICE_PORT0;
   } else
      if ( dwBitMask & XDEVICE_PORT0_BOTTOM_MASK  ) {
      // Port 1 Bottom
      dwReturnMask = XDEVICE_PORT0;

   } else
      if ( dwBitMask & XDEVICE_PORT1_TOP_MASK   ) {
      // Port 2 Bottom
      dwReturnMask = XDEVICE_PORT1;//MAKELONG(TOP,1);
   } else
      if ( dwBitMask &  XDEVICE_PORT1_BOTTOM_MASK ) {
      // Port 2 Bottom
      dwReturnMask = XDEVICE_PORT1;//MAKELONG(BOTTOM ,1);
   } else
      if ( dwBitMask & XDEVICE_PORT2_TOP_MASK   ) {
      // Port 3 Bottom
      dwReturnMask = XDEVICE_PORT2;//MAKELONG(TOP ,2);
   } else
      if ( dwBitMask & XDEVICE_PORT2_BOTTOM_MASK  ) {
      // Port 3 Bottom
      dwReturnMask = XDEVICE_PORT2;//MAKELONG(BOTTOM ,2);
   } else
      if ( dwBitMask & XDEVICE_PORT3_TOP_MASK  ) {
      // Port 4 Bottom
      dwReturnMask = XDEVICE_PORT3;//MAKELONG(TOP ,3);
   } else
      if ( dwBitMask & XDEVICE_PORT3_BOTTOM_MASK  ) {
      // Port 4 Bottom
      dwReturnMask = XDEVICE_PORT3;//MAKELONG(BOTTOM , 3 );
   }
   return dwReturnMask;

}



BOOL
COnlineDump::
ReadEEPROM ( BYTE* pbData )
{

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
   BOOL bResult; 
   NTSTATUS status;
   DWORD type, size;
   BYTE bEEPROMMemory[EEPROM_TOTAL_MEMORY_SIZE];
   EEPROM_LAYOUT* eeprom                  = (EEPROM_LAYOUT*)bEEPROMMemory;
   XBOX_FACTORY_SETTINGS* factorySettings = (XBOX_FACTORY_SETTINGS*)&eeprom->FactorySection;
   XBOX_USER_SETTINGS* userSettings       = (XBOX_USER_SETTINGS*)   &eeprom->UserConfigSection;
   PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA)&eeprom->EncryptedSection;

   BYTE shaDigest[XC_SERVICE_DIGEST_SIZE];
   BYTE shaCtxt[XC_SERVICE_SHA_CONTEXT_SIZE];
   BYTE bEncryptedTail[sizeof(RC4_SHA1_HEADER) + XBOX_KEY_LENGTH];
   XBOX_FACTORY_SETTINGS savedSettings;
   DWORD i;
   
   // read EEPROM Data
   status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, bEEPROMMemory, EEPROM_TOTAL_MEMORY_SIZE, &size);
   if (!NT_SUCCESS(status)) {
      DebugOut("ExQueryNonVolatileSetting FAILED");
      return FALSE;
   }

   //
   // Decrypt the Encrypted part of the EEPROM if it is encrypted.
   //
   if (!RtlEqualMemory(pEncryptedEEPROMData->HardDriveKey,ZERO_KEY,XBOX_KEY_LENGTH))
   {
      // Only Encrypt if it is not a dev kit
      //
      bResult = rc4HmacDecrypt(
                              (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
                              pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
                              (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
      if ( !bResult ) {
         DebugOut("EEPROM Decrypt FAILED");
         return FALSE;
      }
   }

   //
   // Check for invalid characters in serial number
   //
   for(i=0; i<sizeof(factorySettings->SerialNumber); ++i)
   {
      if (!isalnum(factorySettings->SerialNumber[i]))
      {
          factorySettings->SerialNumber[i] = '#';
      }
   }
   
   // DeMorph the OnlineKey before using it.
   MorphKeyByHardDriveKey( factorySettings->OnlineKey,sizeof( factorySettings->OnlineKey));

   // Compute one way hash of HD Key
   ASSERT( sizeof(pEncryptedEEPROMData->HardDriveKey) == XBOX_KEY_LENGTH );
   XcSHAInit( shaCtxt );
   XcSHAUpdate( shaCtxt, pEncryptedEEPROMData->HardDriveKey, XBOX_KEY_LENGTH );
   XcSHAFinal( shaCtxt, shaDigest );

   //
   // Create Encrypted Tail Section
   //
   RtlCopyMemory( bEncryptedTail+sizeof(RC4_SHA1_HEADER), shaDigest, XBOX_KEY_LENGTH );
   rc4HmacEncrypt(
       pEncryptedEEPROMData->EncHeader, // use as confounder
       factorySettings->OnlineKey, sizeof( factorySettings->OnlineKey),
       bEncryptedTail+sizeof(RC4_SHA1_HEADER), XBOX_KEY_LENGTH,
       (LPBYTE)bEncryptedTail );

   //
   // Zero out everything but Serial number and EthernetAddr
   //
   RtlCopyMemory(savedSettings.SerialNumber, factorySettings->SerialNumber, sizeof(savedSettings.SerialNumber));
   RtlCopyMemory(savedSettings.EthernetAddr, factorySettings->EthernetAddr, sizeof(savedSettings.EthernetAddr));
   RtlZeroMemory( bEEPROMMemory, sizeof(bEEPROMMemory) );
   RtlCopyMemory(factorySettings->SerialNumber, savedSettings.SerialNumber, sizeof(savedSettings.SerialNumber));
   RtlCopyMemory(factorySettings->EthernetAddr, savedSettings.EthernetAddr, sizeof(savedSettings.EthernetAddr));
   
   // Copy everthing over to the databuffer.
   ASSERT( sizeof(bEEPROMMemory) + sizeof(bEncryptedTail) == DUMP_SIZE );
   RtlCopyMemory(pbData, bEEPROMMemory, sizeof(bEEPROMMemory));
   RtlCopyMemory(pbData+sizeof(bEEPROMMemory), bEncryptedTail, sizeof(bEncryptedTail));
   
   return TRUE;
}


VOID
COnlineDump::
DebugOut (PCHAR szMessage,...)
/*++

Routine Description:
   It behaves much like printf but sends to the debugOut.

Arguments:
   same as printf.

Return Value:
   NONE

Author: Wally Ho (wallyho) April 25th, 2001   

--*/
{
   va_list vaArgs;
   char szBuffer[ MAX_PATH];

   //  Write the formatted string to the log.
   va_start( vaArgs, szMessage );
   
#ifdef DBG
   vsprintf( szBuffer, szMessage, vaArgs );

   OutputDebugStringA( szBuffer );
#endif

   va_end  ( vaArgs );
   return;
}



BOOL
COnlineDump::
FileToDrive( LPCSTR lpFileName,
             LPVOID pvFileContents,
             DWORD dwFileSize,
             DWORD dwWriteFlags )
{

   HANDLE hFile = INVALID_HANDLE_VALUE;
   DWORD dwBytesWrote;
   DWORD dwPos;
   DWORD dwFileStyle;
   CHAR  szOperation[30];
   DWORD dwFilePosition;
   BOOL bResult = FALSE;
   
   switch (dwWriteFlags) {
   case APPEND_FILE:
      dwFileStyle = OPEN_ALWAYS;
      sprintf(szOperation,"%s","Appending File");
      dwFilePosition = FILE_END;
      break;
   case NEW_FILE:
   default:
      dwFileStyle = CREATE_ALWAYS;
      sprintf(szOperation,"%s","New File");
      dwFilePosition = FILE_BEGIN;
      break; 
   }
   
   hFile = CreateFile(lpFileName, 
                      GENERIC_WRITE, 
                      FILE_SHARE_READ | FILE_SHARE_WRITE, 
                      NULL,
                      dwFileStyle, 
                      FILE_ATTRIBUTE_NORMAL, 
                      NULL);

   if ( hFile == INVALID_HANDLE_VALUE ) {
      DebugOut("%s:unable to open %s, error %X\n", szOperation,lpFileName, GetLastError());
      goto Cleanup;
   }

   dwPos = SetFilePointer( hFile, 0, NULL, dwFilePosition );
   if ( dwPos == INVALID_SET_FILE_POINTER ) {
      DebugOut("%s: unable to seek %s, error %X\n", szOperation, lpFileName, GetLastError());
      goto Cleanup;
   }

   if (!WriteFile(hFile, pvFileContents, dwFileSize, &dwBytesWrote, NULL) || (dwBytesWrote != dwFileSize)) {
      DebugOut("%s: cannot write to %s, error %X\n", szOperation, lpFileName, GetLastError() );
      goto Cleanup;
   }

   bResult = TRUE;
   
Cleanup:

   if (hFile != INVALID_HANDLE_VALUE)
   {
      CloseHandle(hFile);
   }

   return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\oobaudit\oobaudit.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    oobauditp.cpp

Abstract:

    This module implements routine to reset EEPROM settings

--*/

#include "oobauditp.h"

#define MAX_RETRIES 3

//
// Global statically allocated video object
//

CXBoxVideo g_Video;

NTSTATUS
ResetEEPROMUserSettings(
    VOID
    )
/*++

Routine Description:

    Reset user settings in EEPROM to their defaults

Arguments:

    None

Return Value:

    Status of the operation

--*/
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS Status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*)buf;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(userSettings, sizeof(*userSettings));

        if (XGetGameRegion() == XC_GAME_REGION_JAPAN) {
            userSettings->Language = XC_LANGUAGE_JAPANESE;
            userSettings->TimeZoneBias = -540;
            strcpy(userSettings->TimeZoneStdName, "TST");
            strcpy(userSettings->TimeZoneDltName, "TST");
        }

        userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
        Status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));
    }

    return Status;
}

VOID
DrawMessage(
    LPCWSTR pcszTextLine1,
    LPCWSTR pcszTextLine2,
    DWORD dwColor
    )
{
    ASSERT(pcszTextLine1);

    g_Video.ClearScreen(dwColor);

    g_Video.DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_Video.DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }


    WCHAR szBuildString[64];
    wsprintfW(szBuildString, L"XTL Version %hs", VER_PRODUCTVERSION_STR);
    g_Video.DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_Video.ShowScreen();

}

void __cdecl main()
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    int tries = 0;

    g_Video.Initialize(SCREEN_WIDTH, SCREEN_HEIGHT);
    g_Video.ClearScreen(COLOR_BLACK);
    g_Video.ShowScreen();

    //
    // Reset the manufacturing bit.
    // Per manufacturing request: We will retry MAX_RETRIES times before
    // giving up as failed.
    //

    while (tries < MAX_RETRIES && !NT_SUCCESS(Status)) {
        tries++;
        Status = ResetEEPROMUserSettings();
    }

    //
    // Give status. We don't assume the user reads english, or understands the terminology
    // Although there is text, the background color is the distinguishing feature.
    // RED == Unable to update EEPROM data.
    // GREEN == EEPROM update succeeded.
    //

    if (!NT_SUCCESS(Status)) {
        DbgPrint("Reset EEPROM failed (returned 0x%x)\r\n", Status);
        DrawMessage(L"Out Of Box Audit", L"Failed to update Xbox configuration.", COLOR_TV_RED);
    } else {
        DrawMessage(L"Out Of Box Audit", L"Xbox successfully updated.", COLOR_DARK_GREEN);
    }

    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\oobaudit\oobauditp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    oobauditp.cpp

Abstract:

    This is a pre-compile header file.

--*/

#include <ntos.h>
#include <stdio.h>

#include <xtl.h>
#include <xdbg.h>
#include <xboxp.h>
#include <xconfig.h>
#include <xboxverp.h>

#define XFONT_TRUETYPE
#include <xfont.h>

#include "xboxvideo.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\MakeRecImg\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MakeRecImg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\oobaudit\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "oobauditp.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( XFONT_CENTER );
        XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\MakeRecImg\MakeRecImg.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      MakeRecImg.cpp
// Contents:  MakeRecImg.exe main entry point.
// Revisions: 20-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_IMAGEBLD_CMD_LINE -- The maximum number of chars in the command line
//                          specified to imagebld.  Large # because it will
//                          hold a lot of "/INSERTFILE:..." strings.
#define MAX_IMAGEBLD_CMD_LINE 2000

// MAX_IMAGE_FILE_SIZE   -- The maximum size of a recovery image file.
#define MAX_IMAGE_FILE_SIZE   0x3000000     // 48 MB

// COPY_BUFFER_SIZE      -- Size of the buffer that holds the copied data
#define COPY_BUFFER_SIZE 32768


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES +++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_nCurImageFile       -- Current image file # that we're writing to.
int g_nCurImageFile;

// g_dwCurImageOffset    -- Byte offset into the current image file
DWORD g_dwCurImageOffset;

// g_hfileCurImage       -- Handle to the current image file
HANDLE g_hfileCurImage;

// g_dwSourcePathLen     -- String length of the directory the app was run
//                          in.  Used to generate relative path names
DWORD g_dwSourcePathLen;

// g_xsum                -- Checksum of data in recovery image files.
CCheckSum g_xsum;

// g_cFiles				 -- Number of files in the image
int g_cFiles;

// g_uliSize             -- Total number of bytes in all files in image
ULARGE_INTEGER g_uliSize;

// g_szVersion           -- Version to embed
char g_szVersion[20];


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// sImageHeader          -- Contains information about the image files.
//                          Written to the start of the first image file.
typedef struct
{
    USHORT usVerMajor, usVerMinor, usVerBuild, usVerQfe;
    DWORD cImageFiles;
    DWORD dwChecksum;
	ULARGE_INTEGER uliSize;
} sImageHeader;

// sFileHeader           -- Contains information about a particular file in
//                          an image file.  'szRelPathName' is the relative
//                          path and file name.
typedef struct
{
    char szRelPathName[MAX_PATH];
    DWORD dwSize;
} sFileHeader;
  
  
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpUsage
// Purpose:   Dumps the application usage information to the console
// Arguments: None
// Return:    Always returns 'FALSE'
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL DumpUsage()
{
    printf("Usage:  MakeRecImg <SourcePath> <Version>\n\n"
           "    <SourcePath>    - Directory containing recovery files\n"
           "    <Version>       - Embedded Dash version (ie 1.0.3944.1)\n"
           "  Note:   'RecoverHD.exe' MUST exist in the current directory\n"
           "  Output: 'RecoverHD.xbe' in the current directory\n\n");

    return FALSE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleCommandLine
// Purpose:   Parses the command line, grabs the appropriate strings from it
//            and verifies that they are valid.
// Arguments: argc          -- The number of arguments on the command line
//            argv          -- The list of arguments on the command line
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL HandleCommandLine(int argc, char *argv[], char szSourcePath[MAX_PATH])
{
    DWORD dwAttr;
    
    // First, verify that the correct number of arguments was specified
    if (argc != 3)
        return DumpUsage();

    // Ensure that the specified path is an absolute (non-local) path
    MakePathAbsolute(argv[1], szSourcePath);

    // Verify that the specified path exists and is indeed a directory
    dwAttr = GetFileAttributes(szSourcePath);
    if (dwAttr == 0xFFFFFFFF)
    {
        printf("Error - path '%s' not found.\n", szSourcePath);
        return FALSE;
    }
    
    if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
    {
        printf("Error - '%s' is not a directory.\n", szSourcePath);
        return FALSE;
    }

    // Store the version
    strcpy(g_szVersion, argv[2]);

    // return success
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleEndOfImage
// Purpose:   Closes out the current image file and creates a new one.
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL HandleEndOfImage()
{
    char szImageFile[MAX_PATH];

    // Close the existing image file
    if (g_hfileCurImage)
        CloseHandle(g_hfileCurImage);

    g_nCurImageFile++;

    // Generate the name of the next image file
    sprintf(szImageFile, "Recovery%d.img", g_nCurImageFile);
    
    // Open the next image file
    g_hfileCurImage = CreateFile(szImageFile, GENERIC_WRITE, 0,
                                 NULL, CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, NULL);
    if (g_hfileCurImage == INVALID_HANDLE_VALUE)
    {
        printf ("Error - Failed to create image file '%s'.\n",
                szImageFile);
        return FALSE;
    }
    
    g_dwCurImageOffset = 0;

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBuffer
// Purpose:   Writes a buffer of data to the specified image file.  If there
//            is not enough room in the image file, then this function makes
//            sure that transition happens correctly
// Arguments: 
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL WriteBuffer(HANDLE hfileDest, BYTE *pbySource, DWORD dwBytesToWrite)
{
    while (dwBytesToWrite)
    {
        DWORD dw, dwWrite = min(dwBytesToWrite, MAX_IMAGE_FILE_SIZE -
                                                g_dwCurImageOffset);
        if (dwWrite)
        {
            if (!WriteFile(hfileDest, pbySource, dwWrite, &dw, NULL) ||
                dw != dwWrite)
            {
                printf("Error - Failed to write to recovery file.\n");
                return FALSE;
            }

            dwBytesToWrite     -= dwWrite;
            g_dwCurImageOffset += dwWrite;
        }

        if (dwBytesToWrite > 0)
        {
            assert (g_dwCurImageOffset == MAX_IMAGE_FILE_SIZE);
            
            // If there are more bytes to write, then it's because the
            // buffer spanned the end of the image file.  Open a new one.
            if (!HandleEndOfImage())
                return FALSE;
            
            pbySource += dwWrite;
        }
    }
    
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AddFileToRecoveryImage
// Purpose:   Adds the specified file to the recovery image(s).  It may be
//            necessary for the file to span multiple image files.
// Arguments: szFilePath    -- Path/Name of file to add
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL AddFileToRecoveryImage(char *szFilePath)
{
    DWORD dw, dwSourceSize, dwSourceHigh;
    BOOL  fRetVal = FALSE;
    sFileHeader filehdr;
    
    // Open the specified file
    HANDLE hfileSource = CreateFile(szFilePath, GENERIC_READ, 0, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfileSource == INVALID_HANDLE_VALUE)
    {
        printf("Error - failed to open source file '%s'.\n", szFilePath);
        return FALSE;
    }

    // Copy the source file to the set of recovery image files.  We need
    // to be sure that the recovery image files don't exceed their maximum
    // size, so we may need to span the source file across multiple image
    // files.
    dwSourceSize = GetFileSize(hfileSource, &dwSourceHigh);

    // We don't support source files > 2gb in size
    if (dwSourceHigh)
    {
        printf("Error - source file '%s' is too big.  Tool requires"
               " updating.\n", szFilePath);
        goto done;
    }

    g_uliSize.QuadPart += (__int64)dwSourceSize;
    
    // Add the file header to the image
    filehdr.dwSize = dwSourceSize;
    strcpy(filehdr.szRelPathName, szFilePath + g_dwSourcePathLen+1);
    if (!WriteBuffer(g_hfileCurImage, (BYTE*)&filehdr, sizeof filehdr))
        goto done;

    while (dwSourceSize != 0)
    {
        BYTE rgbyCopyBuffer[COPY_BUFFER_SIZE];
        
        // There are more bytes to copy.  Copy as many as possible to the
        // current image file.
        
        // Determine how many to copy; maximum is limited by copy buffer
        DWORD dwBytesToCopy = min(COPY_BUFFER_SIZE, dwSourceSize);

        // Read the bytes
        if (!ReadFile(hfileSource, rgbyCopyBuffer, dwBytesToCopy, &dw,
                      NULL) || dw != dwBytesToCopy)
        {
            printf("Error - Failed to read file '%s'.\n", szFilePath);
            goto done;

        }

        // Write out the bytes
        if (!WriteBuffer(g_hfileCurImage, rgbyCopyBuffer, dwBytesToCopy))
            goto done;

        // Checksum the bytes
        g_xsum.SumBytes(rgbyCopyBuffer, dwBytesToCopy);

        dwSourceSize -= dwBytesToCopy;
    }

	g_cFiles++;

    // If here, we were successful!
    fRetVal = TRUE;

done:

    // We're done with the source file now.
    CloseHandle(hfileSource);

    return fRetVal;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  StrToUpper
// Purpose:   Convert an arbitrary-cased string to upper case.
// Arguments: szSource      -- String to convert.
//            szDest        -- Buffer to hold upper case version of szSource
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void StrToUpper(char *szSource, char *szDest)
{
    while (*szSource)
        *szDest++ = (char)toupper(*szSource++);
    *szDest = *szSource;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  RecurseCreateRecoveryImages
// Purpose:   Given a directory, munges the files into a collection of
//            image files which are subsequently embedded in an exe.
// Arguments: szSourceDir   -- Directory which contains the files to munge.
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL RecurseCreateRecoveryImages(char *szSourceDir)
{
    WIN32_FIND_DATA wfd;
    char szSearchString[MAX_PATH];

    // Find all files in the current directory and add them to the image
    // file.  If the image file reaches beyond the size limit, then cap it
    // and start a new image file.
    sprintf(szSearchString, "%s\\*", szSourceDir);
    HANDLE hfile = FindFirstFile(szSearchString, &wfd);
    if (hfile == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        char szFullPath[MAX_PATH], szFullPathUpper[MAX_PATH];

        // Ignore '.' and '..'
        if (!strcmp(wfd.cFileName, ".") || !strcmp(wfd.cFileName, ".."))
            continue;
        
        // Generate the full pathname to the current file.
        sprintf(szFullPath, "%s\\%s", szSourceDir, wfd.cFileName);

        // Force uppercase version of the path.
        StrToUpper(szFullPath, szFullPathUpper);

        // For retail recovery, we only add files that go into 'XDASH'.
        // The 'XDASH\' portion of the path is replaced with 'Y:\' by
        // RecoverHD.xbe;  The reason we leave things like they are is
        // so that we can support arbitrary folders later on if desired.
        if (!strstr(szFullPathUpper, "\\XDASH"))
            continue;

        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Recurse into the directory; we don't explicitly add
            // directories to the image (they are implicit in the files
            // that are added).
            if (!RecurseCreateRecoveryImages(szFullPath))
                return FALSE;
        }
        else
        {
            // Add the file to the recovery image(s)
            if (!AddFileToRecoveryImage(szFullPath))
                return FALSE;
        }

    } while (FindNextFile(hfile, &wfd));
    
    // We've enumerated all files in 'szSourceDir'
    FindClose(hfile);
    
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CreateRecoveryImages
// Purpose:   Sets up state necessary for RecurseCreateRecoveryImages, and
//            handles injecting data at the end.
// Arguments: szSourceDir   -- Directory which contains the files to munge.
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CreateRecoveryImages(char *szSourceDir)
{
    sImageHeader imghdr;
    DWORD        dwWritten;
    int          nMajor, nMinor, nBuild, nQFE;

    g_nCurImageFile    = 0;
    g_dwCurImageOffset = 0;
	g_cFiles		   = 0;
	g_uliSize.QuadPart = 0;
    g_hfileCurImage    = NULL;
    
    // Create the first image file (as Recovery1.img - recovery0.img contains
    // header and is handled afterwards).
    if (!HandleEndOfImage())
        return FALSE;

    if (!RecurseCreateRecoveryImages(szSourceDir))
        return FALSE;

    // Close the final image file
    if (g_hfileCurImage)
        CloseHandle(g_hfileCurImage);

    // We now want to embed the number of image files and checksum data into
    // the first recovery image file.  Open it and write the data in.
    HANDLE hfileImage0 = CreateFile("Recovery0.img", GENERIC_WRITE, 0, NULL,
                                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                    NULL);
    if (hfileImage0 == INVALID_HANDLE_VALUE)
    {
        printf("Error - Failed to open Recover0.img to write header.\n");
        return FALSE;
    }

    // Write the image header
    imghdr.cImageFiles = g_cFiles;
	imghdr.uliSize.QuadPart = g_uliSize.QuadPart;
    imghdr.dwChecksum  = g_xsum.DwFinalSum();
    
    // Add version to image header
    sscanf(g_szVersion, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild, &nQFE);
    *(WORD*)(&imghdr.usVerMajor) = (WORD)nMajor;
    *(WORD*)(&imghdr.usVerMinor) = (WORD)nMinor;
    *(WORD*)(&imghdr.usVerBuild) = (WORD)nBuild;
    *(WORD*)(&imghdr.usVerQfe)   = (WORD)nQFE;

    if (!WriteFile(hfileImage0, &imghdr, sizeof imghdr, &dwWritten, 0) ||
        dwWritten != sizeof imghdr)
    {
        printf("Error - Failed to inject header into Recovery0.img.\n");
        CloseHandle(hfileImage0);
        return FALSE;
    }

    CloseHandle(hfileImage0);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GenerateImgBldCmdLine
// Purpose:   Generates the necessary imagebld command line to embed the
//            list of image files.
// Arguments: szOrigDir         -- Directory that the exe was run from.
//            szImageBldCmdLine -- Destination buffer to hold the string.
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL GenerateImgBldCmdLine(char *szOrigDir, char *szImageBldCmdLine)
{
    sprintf(szImageBldCmdLine, "imagebld.exe /NOSETUPHD /TESTMEDIATYPES:0x00000004 /TESTREGION:0xFFFFFFFF /INITFLAGS:0x00000000");
    for (int i = 0; i <= g_nCurImageFile; i++)
    {
        char szTemp[200];
        sprintf(szTemp, " /INSERTFILE:Recovery%d.img,.RCVR%d,RN", i, i);
        strcat(szImageBldCmdLine, szTemp);
    }

    strcat(szImageBldCmdLine, " /OUT:RecoverHD.xbe ");
    strcat(szImageBldCmdLine, szOrigDir);
    strcat(szImageBldCmdLine, "\\RecoverHD.exe");
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SpawnImageBld
// Purpose:   Spawns imagebld with the specified command line.  If there are
//            any problems then output the error here.
// Arguments: szImageBldCmdLine -- The command line to send to ImageBld.
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL SpawnImageBld(char *szImageBldCmdLine)
{
    if (_spawnlp( _P_WAIT, "imagebld.exe", szImageBldCmdLine, NULL) != 0)
	{
        printf("Error - Failed to spawn ImageBld with the following command"
               "line: '%s'.\n", szImageBldCmdLine);
        return FALSE;
	}
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   This is the default entry point into a console application.  
//            When the application is started, Windows calls into this
//            function - when this function exits, the application ends.
// Arguments: argc          -- The number of arguments on the command line
//            argv          -- The list of arguments on the command line
// Return:    Result value application returns to the operating system
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int __cdecl main(int argc, char *argv[])
{
    char szImageBldCmdLine[MAX_IMAGEBLD_CMD_LINE];
    char szOrigDir[MAX_PATH], szOrig[MAX_PATH];
    char szTempDir[MAX_PATH], szTemp[MAX_PATH];
    char szSourcePath[MAX_PATH];
    int  nRetVal = -1;

    // Parse the command line and grab the appropriate strings.
    if (!HandleCommandLine(argc, argv, szSourcePath))
        return -1;

    g_dwSourcePathLen = strlen(szSourcePath);

    // At this point, szSourcePath contains the absolute path of the source
    // directory (necessary since we may change drives for the temp dir)

    // Store the original directory so that we can restore it when done.
    GetCurrentDirectory(MAX_PATH, szOrigDir);

    // Create a temporary directory and change to it -- this allows us to
    // generate a large collection of files without messing up the user's
    // directory.
    if (!GetTempDirName(szTempDir))
        return -1;

    if (!SetCurrentDirectory(szTempDir))
    {
        printf("Failed to change directory to temp dir '%s'.\n", szTempDir);
        return -1;
    }

    printf("\nWorking...\n");
    
    // Munge all of the files in the specified source directory into the
    // set of recovery images.
    if (!CreateRecoveryImages(szSourcePath))
        goto done;

    // Generate the command line string for imagebld that embeds the
    // appropriate image files into the RecoverHD executable.
    if (!GenerateImgBldCmdLine(szOrigDir, szImageBldCmdLine))
        goto done;

    // Spawn imagebld with the generated command line.  This should generate
    // RecoverHD.xbe, with all of the image files embedded into it.
    if (!SpawnImageBld(szImageBldCmdLine))
        goto done;

    // Finally, copy the resultant RecoverHD.exe file from the temporary
    // directory to the user's current directory.
    sprintf(szOrig, "%s\\RecoverHD.xbe", szOrigDir);
    sprintf(szTemp, "%s\\RecoverHD.xbe", szTempDir);
    if (!CopyFile(szTemp, szOrig, FALSE))
    {
        printf("Error - failed to copy xbe from temp directory.\n");
        goto done;
    }

    // If here, then we were successful!
    printf("\nRecoverHD.xbe successfully created.\n\n");
    nRetVal = 0;

done:

    // Clean up after ourselves (delete the temporary directory)
    RecursiveRemoveDirectory(szTempDir);

    // Restore the original directory
    SetCurrentDirectory(szOrigDir);

    return nRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\MakeRecImg\Util.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      Util.cpp
// Contents:  Some utility functions for the MakeRecImg app
// Revisions: 21-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MakePathAbsolute
// Purpose:   Ensures that the specified path is an absolute path, not a
//            local one.
// Arguments: szSourcePath      -- The path to make absolute
//            szAbsolutePath    -- The buffer to hold the result
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void MakePathAbsolute(char *szSourcePath, char *szAbsolutePath)
{

    // Is the specified source path a local or absolute path?  If it's
    // local, then convert to absolute so that we don't have to worry about
    // it later.  Valid path types:
    //  X:\...      Absolute
    //  \\...       Absolute (UNC)
    //  \...        Local (since temp dir may be on different drive)
    //  ...         Local
    if ((szSourcePath[1] == ':'  && szSourcePath[2] == '\\') ||
        (szSourcePath[0] == '\\' && szSourcePath[1] == '\\'))
        strcpy(szAbsolutePath, szSourcePath);
    else
    {
        // Must be local case; combine with current directory
        char szCurDir[MAX_PATH];
        GetCurrentDirectory(MAX_PATH, szCurDir);
        if (szSourcePath[0] == '\\')
            sprintf(szAbsolutePath, "%c:%s", szCurDir[0], szSourcePath);
        else
            sprintf(szAbsolutePath, "%s\\%s", szCurDir, szSourcePath);
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetTempDirName
// Purpose:   Generates a temporary directory name.  Rooted in doc&settings\
//            <user>\localsettings\temp.
// Arguments: szTempDir     -- Buffer to hold temporary directory name.
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL GetTempDirName(char *szTempDir)
{
	char szTempPath[MAX_PATH];

    GetTempPath(MAX_PATH, szTempPath);
    if (GetTempFileName(szTempPath, "mri", 0, szTempDir) == 0)
    {
        // Couldn't create the temporary directory
        printf("Error - Failed to create temp directory.  Ensure that your "
               "system drive ('%c':\\) has enough free space available and "
               "that you have the appropriate administrative permissions.",
               szTempPath[0]);
        return FALSE;
    }

    // GetTempFileName forces creation of a file with the temporary name; we
    // want a directory, so delete the created file.
    if (!DeleteFile(szTempDir))
    {
        // Couldn't delete the newly created file for some reason.  This
        // shouldn't happen, but just in case, we fail
        printf("Error: Failed to delete temporary file '%s'.\n", szTempDir);
        return FALSE;
    }

    // Finally, create the directory itself
    if (!CreateDirectory(szTempDir, NULL))
    {
        printf("Error: Failed to create temporary directory '%s'.\n",
               szTempDir);
        return FALSE;
    }

    return TRUE;  
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  RecursiveRemoveDirectory
// Purpose:   Recursively deletes the contents of a directory.
// Arguments: szDir         -- Name of the directory to delete.
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void RecursiveRemoveDirectory(char *szFolder)
{
    if (SetCurrentDirectory(szFolder))
    {
        WIN32_FIND_DATA wfd;
        HANDLE hfile = FindFirstFile("*.*", &wfd);
        while (hfile != INVALID_HANDLE_VALUE)
        {
            char *szFile = wfd.cFileName;
            if (strcmp(szFile, ".") && strcmp(szFile, ".."))
            {
                // It's neither '.' nor '..' - remove it!  If it's a file,
                // delete it; if it's a directory, then recurse down into it
                if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    RecursiveRemoveDirectory(szFile);
                else
                    DeleteFile(szFile);
            }

            if (!FindNextFile(hfile, &wfd))
                break;
        }
        FindClose(hfile);

        // Set our current directory back to the original directory so that
        // we can remove 'this' directory
        SetCurrentDirectory("..");

        // Finally, remove the directory itself
        RemoveDirectory(szFolder);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\MakeRecImg\StdAfx.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      StdAfx.h
// Contents:  
// Revisions: 20-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <assert.h>
#include "Util.h"
#include "xsum.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID Address
    );

VOID
NTAPI
AvRelocateSavedDataAddress(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\MakeRecImg\Util.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      Util.h
// Contents:  
// Revisions: 21-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MakePathAbsolute
// Purpose:   Ensures that the specified path is an absolute path, not a
//            local one.
// Arguments: szSourcePath      -- The path to make absolute
//            szAbsolutePath    -- The buffer to hold the result
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void MakePathAbsolute(char *szSourcePath, char *szAbsolutePath);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetTempDirName
// Purpose:   Generates a temporary directory name.  Rooted in doc&settings\
//            <user>\localsettings\temp.
// Arguments: szTempDir     -- Buffer to hold temporary directory name.
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL GetTempDirName(char *szTempDir);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  RecursiveRemoveDirectory
// Purpose:   Recursively deletes the contents of a directory.
// Arguments: szDir         -- Name of the directory to delete.
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void RecursiveRemoveDirectory(char *szFolder);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\recovpch.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      recovpch.h
// Contents:  
// Revisions: 22-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include <nt.h>
#include <ntrtl.h>
#include <xtl.h>
#include <stdio.h>
#include <assert.h>
#include <idex.h>

#include "xboxverp.h"
#include "imagefile.h"
#include "xsum.h"
#include "FormatHD.h"

#define XFONT_TRUETYPE
#include <xfont.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\refresh\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\RecoverHD.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      RecoverHD.cpp
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "recovpch.h"
#include "xboxvideo.h"
#include <init.h>
#include <xconfig.h>
#include <xboxp.h>


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_IMAGE_FILE_SIZE   -- The maximum size of a recovery image file.
//                          This MUST match the value in MakeRecImg.
#define MAX_IMAGE_FILE_SIZE          0x3000000     // 48 MB

// COPY_BUFFER_SIZE      -- Size of the buffer that holds the copied data
#define COPY_BUFFER_SIZE             32768

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// sImageHeader          -- Contains information about the image files.
//                          Written to the start of the first image file.
typedef struct
{
    USHORT usVerMajor, usVerMinor, usVerBuild, usVerQfe;
    DWORD cImageFiles;
    DWORD dwChecksum;
	ULARGE_INTEGER uliSize;
} sImageHeader;

// sFileHeader           -- Contains information about a particular file in
//                          an image file.  'szRelPathName' is the relative
//                          path and file name.
typedef struct
{
    char szRelPathName[MAX_PATH];
    DWORD dwSize;
} sFileHeader;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL OBJECTS +++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pVideo             -- Interface to the xbox video display
CXBoxVideo* g_pVideo;

// g_pBackgroundBitmap  -- The bitmap to display behind the text
BitmapFile* g_pBackgroundBitmap;

// g_szResult           -- Used to store result string displayed to user.
TCHAR g_szResult[1000];
TCHAR g_szResult2[1000];

// g_cbyRead            -- Number of bytes read from the current section
DWORD g_cbyRead;

// g_cbyTotalRead       -- Number of bytes read from all sections
int g_cbyTotalRead;

// g_ih                 -- Image header
sImageHeader g_ih;

// g_pbySection         -- Location in the current section
BYTE *g_pbySection;

// g_iCurSection        -- Current section number
int g_iCurSection;

// g_xsum               -- Ongoing checksum of files in the image.
CCheckSum g_xsum;

// g_tszQuickMBtoWC     -- Used by QuickMBtoWC for quick multibyte-to-wide
//                         char conversions.
TCHAR g_tszQuickMBtoWC[2000];

extern COBJECT_STRING HdPartition1;
extern COBJECT_STRING HdPartition2;
extern COBJECT_STRING HdPartition3;
extern COBJECT_STRING CDrive;
extern COBJECT_STRING YDrive;
extern COBJECT_STRING ZDrive;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a debug string to the console
// Arguments: tszErr        -- The format string
//            ...           -- Optional parameters
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(TCHAR *tszErr, ...)
{
    TCHAR tszErrOut[256];

    va_list valist;

    va_start (valist,tszErr);
    wvsprintf (tszErrOut, tszErr, valist);
    OutputDebugString (tszErrOut);

    va_end (valist);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ResetUserEEPROMSettings
// Purpose:   Resets the user data section of the EEPROM
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL ResetUserEEPROMSettings(void)
{
    EEPROM_LAYOUT Data;
    XBOX_USER_SETTINGS *UserData;
    NTSTATUS st;
    ULONG Type, Size;

    st = ExQueryNonVolatileSetting(XC_MAX_ALL, &Type, &Data, sizeof Data,
        &Size);
    if(!NT_SUCCESS(st))
        return FALSE;

    UserData = (XBOX_USER_SETTINGS *)Data.UserConfigSection;
    memset(UserData, 0, sizeof *UserData);

    if (XGetGameRegion() & XC_GAME_REGION_JAPAN) {
        UserData->Language = XC_LANGUAGE_JAPANESE;
        UserData->TimeZoneBias = -540;
        strcpy(UserData->TimeZoneStdName, "TST");
        strcpy(UserData->TimeZoneDltName, "TST");
    }

    UserData->Checksum = ~XConfigChecksum(UserData, sizeof *UserData);

    st = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, &Data, sizeof Data);
    return NT_SUCCESS(st);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  QuickMBtoWC
// Purpose:   Supplies easy inlined multibyte-to-wide char conversions.
//            Must not call this function twice in the same function call.
// Arguments: sz            -- String to convert
// Return:    Wide-char version of passed-in string.
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TCHAR *QuickMBtoWC(char *sz)
{
    memset(g_tszQuickMBtoWC, 0, sizeof g_tszQuickMBtoWC);
    mbstowcs(g_tszQuickMBtoWC, sz, strlen(sz));
    return g_tszQuickMBtoWC;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DrawMessage
// Purpose:   Outputs a one or two line message to the screen
// Arguments: pcszTextLine1 -- First line to output
//            pcszTextLine2 -- Second line to output
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2,
                 LPCWSTR pcszTextLine3 = NULL)
{
    // If the video display or background bitmap failed to load, then we
    // should never have gotten here.
    assert(g_pVideo && g_pBackgroundBitmap);

    // Set the screen back to it's original state (just the background
    // image)
    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());


    if (NULL != pcszTextLine1)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine1);

    if (NULL != pcszTextLine2)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT +
                           ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);

    if (NULL != pcszTextLine3)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT * 8,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine3);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UpdateProgress
// Purpose:   Updates the onscreen progress display.  This includes the
//            progress bar and 'time remaining' displays.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void UpdateProgress()
{
    // Keep track of the last progress output so that we can avoid
    // unnecessary screen renders.
    static DWORD s_dwProgPercent = -1;

    // Calculate the percentage of the disc that's been handled.
    DWORD dwProgPercent = (DWORD)((__int64)g_cbyTotalRead * 100 /
                                           g_ih.uliSize.QuadPart);

    // We only need to update if the onscreen display may change
    if (dwProgPercent != s_dwProgPercent) {
        DrawMessage(TEXT("Restoring HD"), TEXT("Please wait"));

        // Draw progress bar background
        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        // Draw progress bar bkgnd
        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        // Draw progress bar
        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) *
                                         dwProgPercent),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);

        g_pVideo->ShowScreen();

        s_dwProgPercent = dwProgPercent;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WaitForAnyButton
// Purpose:   Waits for a button to be pressed.
// UNDONE:    This function was cut-and-paste from recovery.cpp, and as such
//            contains a lot of unnecessary code.  This will eventually be
//            pared down to the minimal required functionality.
//            As a result, this function is left as-is and is uncommented.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void WaitForAnyButton()
{
    DWORD dwNewVideoMode;
    BOOL fYButton;
    PDWORD pdwNewVideoMode = &dwNewVideoMode;
    PBOOL pfYButton = &fYButton;
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed) {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++) {
                if ((1 << i) & dwRemovals) {
                    if (NULL != hPads[i])
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                }

                if ((1 << i) & dwInsertions) {
                    if (NULL == hPads[i])
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++) {
            if ((1 << i) & dwPads) {
                if (NULL != hPads[i]) {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State)) {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;

                            if (pfYButton)
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF)) {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  NextSection
// Purpose:   Closes the current section and moves on to the next one.
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL NextSection()
{
    char szSection[20];

    if (g_iCurSection != -1)
    {
        sprintf(szSection, ".RCVR%d", g_iCurSection);
        DebugOutput(TEXT("Freeing section '%s'.\n"), QuickMBtoWC(szSection));
        if (!XFreeSection(szSection))
        {
            wsprintf(g_szResult, TEXT("Failed to Release section '%s'"),
                                 QuickMBtoWC(szSection));
            return FALSE;
        }
    }

    g_iCurSection++;

    sprintf(szSection, ".RCVR%d", g_iCurSection);
    DebugOutput(TEXT("Loading section '%s'.\n"), QuickMBtoWC(szSection));
    g_pbySection = (BYTE*)XLoadSection(szSection);
    if (g_pbySection == NULL)
    {
        wsprintf(g_szResult, TEXT("Section '%s' expected but not found"),
                             QuickMBtoWC(szSection));
        return FALSE;
    }

    // Reset the number of bytes read in the current section
    g_cbyRead = 0;

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBuffer
// Purpose:   Reads the specified number of bytes from the image file.
//            Automatically handles switching to the next section as
//            necessary
// Arguments: pvBuffer          -- Buffer to hold the read data.
//            dwBytes           -- Number of bytes to read.
//            fChecksum         -- Whether to add bytes to checksum
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL ReadBuffer(void *pvBuffer, DWORD dwBytes, bool fChecksum)
{
    DWORD dwBytesToRead;

    assert(dwBytes < MAX_IMAGE_FILE_SIZE);

ReadBytes:

    dwBytesToRead = min(dwBytes, MAX_IMAGE_FILE_SIZE - g_cbyRead);
    if (dwBytesToRead)
    {
//      Contemplate: pvBuffer = g_pbySection + g_cbyRead;
        memcpy(pvBuffer, g_pbySection + g_cbyRead, dwBytesToRead);
        dwBytes -= dwBytesToRead;
        g_cbyRead += dwBytesToRead;
        g_cbyTotalRead += dwBytesToRead;

        if (fChecksum)
            g_xsum.SumBytes((BYTE*)pvBuffer, dwBytesToRead);
    }

    if (dwBytes)
    {
        // Need to move to the next section
        if (!NextSection())
            return FALSE;

        pvBuffer = (BYTE*)pvBuffer + dwBytesToRead;
        goto ReadBytes;
    }

    UpdateProgress();

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SetupDirectoryTree
// Purpose:
// Arguments:
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL SetupDirectoryTree(char *szFile)
{
    char szPath[MAX_PATH];
    char szNew[MAX_PATH];

    // Separate the path alone (ie ignore the filename for now) since that's
    // what we want to create.
    strcpy(szPath, szFile);
    char *pszSlash = strrchr(szPath, '\\');
    if (!pszSlash)
    {
        // Root file; no directory to create
        return TRUE;
    }

    *pszSlash = '\0';

    // szNew will contain the full path to the current depth, while szCur
    // will contain the name of just the current directory; it will get
    // repeatedly appended onto szNew to iteratively create the entire
    // directory chain.
    char *szCur = strtok(szPath, "\\/");

    // Skip the drive designation
    strcpy(szNew, szCur);
    szCur = strtok(NULL, "\\/");

    while (szCur)
    {
        // Append the current directory onto the full-path string.
        strcat(szNew, "\\");
        strcat(szNew, szCur);

        // Try to create the full path to the current depth.
        CreateDirectory(szNew, NULL);

        // Get the name of the next-depth directory.
        szCur = strtok(NULL, "\\/");
    }

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  StrToUpper
// Purpose:   Convert an arbitrary-cased string to upper case.
// Arguments: szSource      -- String to convert.
//            szDest        -- Buffer to hold upper case version of szSource
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void StrToUpper(char *szSource, char *szDest)
{
    while (*szSource)
        *szDest++ = (char)toupper(*szSource++);
    *szDest = *szSource;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ExtractNextFile
// Purpose:   Extracts the contents of the next file in the image, and
//            writes it to disk.  Generates the necessary directories.
// Arguments: None
// Return:    'TRUE' if successful, 'FALSE' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL ExtractNextFile()
{
    sFileHeader filehdr;
    char        szFilePathName[MAX_PATH];
    char        szFullPathUpper[MAX_PATH];

    // Read the file header
    if (!ReadBuffer(&filehdr, sizeof filehdr, false))
    {
        wsprintf(g_szResult, TEXT("Failed to read file header"));
        return FALSE;
    }

    DebugOutput(TEXT("Extracting file '%s' (%d bytes)\n"),
                QuickMBtoWC(filehdr.szRelPathName), filehdr.dwSize);

    // Files MUST start with 'XDASH'.
    StrToUpper(filehdr.szRelPathName, szFullPathUpper);
    if (memcmp(szFullPathUpper, "XDASH", 5))
    {
        wsprintf(g_szResult, TEXT("Invalid File '%s'"),
                 QuickMBtoWC(szFilePathName));
        return FALSE;
    }

    // Extract files to temporary partition.
    sprintf(szFilePathName, "Z:\\%s", filehdr.szRelPathName + 6);

    // Generate necessary directory tree
    if (!SetupDirectoryTree(szFilePathName))
        return FALSE;

    // Create the new file on the xbox
    HANDLE hfile = CreateFile(szFilePathName, GENERIC_WRITE, 0, NULL,
                              CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        wsprintf(g_szResult, TEXT("Failed to create '%s' (%08X)"),
                 QuickMBtoWC(szFilePathName), GetLastError());
        return FALSE;
    }

    // Extract the contents of the file from the image
    char rgbyCopyBuffer[32768];
    DWORD dwBytesToCopy = filehdr.dwSize;

    while (dwBytesToCopy)
    {
        DWORD dw, dwBytes = min(32768, dwBytesToCopy);
        if (!ReadBuffer(&rgbyCopyBuffer, dwBytes, true))
        {
            wsprintf(g_szResult, TEXT("Failed to read from image"));
            CloseHandle(hfile);
            return FALSE;
        }

        // Write the bytes
        if (!WriteFile(hfile, rgbyCopyBuffer, dwBytes, &dw, NULL) ||
            dw != dwBytes)
        {
            wsprintf(g_szResult, TEXT("Failed to write to '%s'"),
                     QuickMBtoWC(filehdr.szRelPathName));
            CloseHandle(hfile);
            return FALSE;
        }

        dwBytesToCopy -= dwBytes;
    }

    // Close the file
    CloseHandle(hfile);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XCopyFiles
// Purpose:   Recursively copies a directory.
// Arguments: szSourceDir       -- Source directory to copy
//            szDestDir         -- Destination to copy files to.
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL XCopyFiles(char *szSourceDir, char *szDestDir)
{
    WIN32_FIND_DATA wfd;
    char szSearchString[MAX_PATH];

    // Find all files in 'szSourceDir' and copy them to 'szDestDir'.  Recurse
    // into directories.
    sprintf(szSearchString, "%s\\*", szSourceDir);
    HANDLE hfile = FindFirstFile(szSearchString, &wfd);
    if (hfile == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        char szFullSourcePath[MAX_PATH];
        char szFullDestPath[MAX_PATH];

        // Ignore '.' and '..'
        if (!strcmp(wfd.cFileName, ".") || !strcmp(wfd.cFileName, ".."))
            continue;

        // Generate the full pathname to the current file.
        sprintf(szFullSourcePath, "%s\\%s", szSourceDir, wfd.cFileName);
        sprintf(szFullDestPath,   "%s\\%s", szDestDir,   wfd.cFileName);

        DebugOutput(TEXT("Copying %s "), QuickMBtoWC(szFullSourcePath));

        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Recurse into the directory
            if (!CreateDirectory(szFullDestPath, NULL))
                return FALSE;

            DebugOutput(TEXT("to %s (recurse)\n"), QuickMBtoWC(szFullDestPath));
            if (!XCopyFiles(szFullSourcePath, szFullDestPath))
                return FALSE;
        }
        else
        {
            // Copy the file
            DebugOutput(TEXT("to %s\n"), QuickMBtoWC(szFullDestPath));
            if (!CopyFile(szFullSourcePath, szFullDestPath, TRUE))
                return FALSE;
        }

    } while (FindNextFile(hfile, &wfd));

    // We've enumerated all files in 'szSourceDir'
    FindClose(hfile);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  VerifyVersion
// Purpose:   Verifies that the xbox and this app's versions match.
// Arguments:
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL VerifyVersion(XBOX_KRNL_VERSION *pverXbox,
                   XBOX_KRNL_VERSION *pverRecoverHD)
{
    int nMajor, nMinor, nBuild, nQFE;

    // Store the Xbox version
    memcpy(pverXbox, XboxKrnlVersion, sizeof XBOX_KRNL_VERSION);

    // Mask out the debug bit
    pverXbox->Qfe &= 0x7FFF;

    // Store the RecoverHD version
    sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild,
                                                  &nQFE);
    *(WORD*)(&pverRecoverHD->Major) = (WORD)nMajor;
    *(WORD*)(&pverRecoverHD->Minor) = (WORD)nMinor;
    *(WORD*)(&pverRecoverHD->Build) = (WORD)nBuild;
    *(WORD*)(&pverRecoverHD->Qfe)   = (WORD)nQFE;

    return (pverXbox->Major == pverRecoverHD->Major &&
            pverXbox->Minor == pverRecoverHD->Minor &&
            pverXbox->Build == pverRecoverHD->Build &&
            pverXbox->Qfe   == pverRecoverHD->Qfe);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   Main entry point to application
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void __cdecl main()
{
    XBOX_KRNL_VERSION verXbox, verRecoverHD;
    TCHAR szVersion[20];

    wsprintf(g_szResult, TEXT("Generic Failure"));

    g_pbySection  = NULL;
    g_iCurSection = -1;

    // Initialize core peripheral port support
    XInitDevices(0, NULL);

    // Create the video subsytem and background bitmap objects
    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;
    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        OutputDebugString(TEXT("Couldn't allocate video objects"));
        Sleep(INFINITE);
    }

    // Initialize the screen and read in the background bitmap
    g_pBackgroundBitmap->read(0, 0,
                              FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");
    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    // Load the first section (so that we can get the image header).
    if (!NextSection())
        goto done;

    // Store the image header (since g_pbySection will go away as soon as
    // we unload the section).
    memcpy(&g_ih, g_pbySection, sizeof g_ih);
    wsprintf(szVersion, TEXT("%d.%d.%d.%d"), g_ih.usVerMajor, g_ih.usVerMinor,
                                             g_ih.usVerBuild, g_ih.usVerQfe);
    DrawMessage(TEXT("Press any button on the controller to restore"),
                TEXT("the Xbox HD to its original state."), szVersion);

    g_pVideo->ShowScreen();

    // Wait for them to press a button.
    WaitForAnyButton();

    g_cbyTotalRead = 0;

    if (g_ih.uliSize.QuadPart == 0)
    {
        g_ih.uliSize.QuadPart = 1;
    }

    UpdateProgress();

    // Load the first section containing data
    if (!NextSection())
        goto done;

    // Verify that the kernel version matches

    // 0x7FFF to mask out the debug bit
    if (XboxKrnlVersion->Major != 1 ||
        XboxKrnlVersion->Minor != 0 ||
        (XboxKrnlVersion->Build != 3944 && XboxKrnlVersion->Build != 4034) ||
        (XboxKrnlVersion->Qfe & 0x7FFF) != 1)
    {
        wsprintf(g_szResult, TEXT("Incorrect RecoverHD version"));
        wsprintf(g_szResult2, TEXT("Xbox: %d.%d.%d.%d, RecoverHD: %d.%d.%d.%d"),
                 XboxKrnlVersion->Major, XboxKrnlVersion->Minor,
                 XboxKrnlVersion->Build, XboxKrnlVersion->Qfe & 0x7FFF,
                 g_ih.usVerMajor, g_ih.usVerMinor, g_ih.usVerBuild,
                 g_ih.usVerQfe);

        goto done;
    }

    // Format the HD to remove anything that was previously there.
    // NOTE: Does NOT touch the Y partition (partition 2) -- we don't want
    // to format that until we're sure the data was successfully extracted
    // from the xbe.
    if (!FormatHD())
        goto done;

    DebugOutput(TEXT("%d files to extract, %d bytes, Checksum=0x%08X.\n"),
                g_ih.cImageFiles, g_ih.uliSize.LowPart, g_ih.dwChecksum);

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &CDrive,
                                         (POBJECT_STRING) &HdPartition1)))
    {
        wsprintf(g_szResult, TEXT("Failed to link C to Partition1"));
        goto done;
    }

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &YDrive,
                                         (POBJECT_STRING) &HdPartition2)))
    {
        wsprintf(g_szResult, TEXT("Failed to link Y to Partition2"));
        goto done;
    }

    // Mount the utility drive so that we can use it for temporary space
    if (!XMountUtilityDrive(TRUE))
    {
        wsprintf(g_szResult, TEXT("Failed to mount Z:"));
        goto done;
    }

    // Add the empty TDATA and UDATA directories.  Note that this is not
    // necessary if we are doing more than a retail recovery.
    if (!CreateDirectory("C:\\TDATA", NULL))
    {
        wsprintf(g_szResult, TEXT("Failed to create C:\\TDATA"));
        goto done;
    }

    if (!CreateDirectory("C:\\UDATA", NULL))
    {
        wsprintf(g_szResult, TEXT("Failed to create C:\\UDATA"));
        goto done;
    }

    // We write everything to a temp partition first in case there's invalid
    // data in one of the sections.  After all data is successfully written,
    // we copy it to Parititon2 (Y:).  By writing to the temp partition
    // first, if we fail out part-way due to invalid data, then we know we
    // haven't FUBAR'ed the dash partition.

    // Step over all of the image file sections; create files as we go
    for (DWORD i = 0; i < g_ih.cImageFiles; i++)
    {
        if (!ExtractNextFile())
            goto done;
    }

    // Do the checksums match?
    if (g_ih.dwChecksum != g_xsum.DwFinalSum())
    {
        wsprintf(g_szResult, TEXT("Checksums do not match: 0x%08X, 0x%08X"),
                 g_ih.dwChecksum, g_xsum.DwFinalSum());
        goto done;
    }

    // At this point, we're confident that the data on the disc is valid, so
    // we can start mucking about with the Y partition and EEPROM
    if (!ResetUserEEPROMSettings())
    {
        wsprintf(g_szResult, TEXT("Failed to reset EEPROM"));
        goto done;
    }

    if (!FormatYPartition())
    {
        wsprintf(g_szResult, TEXT("Failed to format the Y partition"));
        goto done;
    }

    DrawMessage(TEXT("Moving Files..."), TEXT(""));

    g_pVideo->ShowScreen();

    // Copy the data from the utility drive to the Y Drive
    if (!XCopyFiles("Z:", "Y:"))
    {
        wsprintf(g_szResult, TEXT("Failed to copy files from Z to Y"));
        goto done;
    }

    // Wipe partition 3 (by clearing out the cache database)
    if (!WipeCacheDB())
    {
        wsprintf(g_szResult, TEXT("Failed to clear the Cache DB"));
        goto done;
    }

    // If here, then we were successful
    wsprintf(g_szResult, TEXT("Xbox HD successfully restored.  Remove the"));
	wsprintf(g_szResult2, TEXT("DVD and power off or reboot the Xbox now."));

done:

    DebugOutput(TEXT("\ng_szResult: '%s'.\n\n\n"), g_szResult);

    // We're done; report the results to the user
	DrawMessage(g_szResult, g_szResult2);
    g_pVideo->ShowScreen();

    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    //XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    //XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	m_Device->BeginScene();
	m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		//XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            //XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\refresh\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\FormatHD.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      FormatHD.h
// Contents:  
// Revisions: 22-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatHD
// Purpose:   Formats the Xbox HD.
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL FormatHD();

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WipeCacheDB
// Purpose:   Wipes the cache db sector.  Called after data has been copied
//            off of the utility drive.
// Arguments: None.
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL WipeCacheDB();

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatYPartition
// Purpose:   Formats the Y partition (Partition 2; the dash partition)
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL FormatYPartition();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rework\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\FormatHD.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      FormatHD.cpp
// Contents:  UNDONE-COMMENT
// Revisions: 22-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "RecovPCH.h"
#include <nt.h>

extern "C" BOOL WINAPI XapiFormatFATVolume(POBJECT_STRING pcVolume);
extern "C" UCHAR FASTCALL RtlFindFirstSetRightMember(IN ULONG Set);

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#define MAX_SECS_PER_VERIFY 256

COBJECT_STRING PrimaryHarddisk = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition0"));
COBJECT_STRING HdPartition1 =    CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1"));
COBJECT_STRING HdPartition2 =    CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition2"));
COBJECT_STRING HdPartition3 =    CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition3"));
COBJECT_STRING CDrive =          CONSTANT_OBJECT_STRING(OTEXT("\\??\\C:"));
COBJECT_STRING YDrive =          CONSTANT_OBJECT_STRING(OTEXT("\\??\\Y:"));
COBJECT_STRING ZDrive =          CONSTANT_OBJECT_STRING(OTEXT("\\??\\Z:"));

#define DASHBOARD_PARTITION_NUMBER 2

static const CHAR HdPartitionX[] = "\\Device\\Harddisk0\\partition%d";

extern TCHAR g_szResult[1000];

void DebugOutput(TCHAR *tszErr, ...);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteFirstSectors
// Purpose:   Taken verbatim from ntos\recovery\recovery.cpp
// Arguments: 
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NTSTATUS WriteFirstSectors(IN HANDLE hDisk)
{
    LARGE_INTEGER WriteOffset;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    BYTE rgbSector[XBOX_HD_SECTOR_SIZE];
	BYTE RefurbSectorBytes[XBOX_HD_SECTOR_SIZE];
	XBOX_REFURB_INFO RefurbInfo;
    PXBOX_CONFIG_SECTOR ConfigSector = (PXBOX_CONFIG_SECTOR) rgbSector;
    int i;

    RtlZeroMemory(rgbSector, sizeof(rgbSector));

    // Zero out sectors 0-2 and 4-15 (including cache db sector):
    // Sector 3 (XBOX_REFURB_INFO_SECTOR_INDEX) contains the refurb
    // information - leave it alone
    for (i = XBOX_BOOT_SECTOR_INDEX; i < XBOX_CONFIG_SECTOR_INDEX +
         XBOX_NUM_CONFIG_SECTORS; i++)
    {
        if (i == XBOX_REFURB_INFO_SECTOR_INDEX)
            continue;

        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        status = NtWriteFile(hDisk, NULL, NULL, NULL, &ioStatus,
                             rgbSector, XBOX_HD_SECTOR_SIZE, &WriteOffset);
        if (FAILED(status))
            return status;
    }

    return STATUS_SUCCESS;
}
typedef
VOID
(CALLBACK *PFORMAT_PROGRESS_ROUTINE)(
    UINT uPercent
    );


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  RecFormatFATVolume
// Purpose:   Taken from ntos\recovery\recovery.cpp
// Arguments: 
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL
WINAPI
RecFormatFATVolume(
    POBJECT_STRING VolumePath,
    BOOL fQuickFormat,
    PFORMAT_PROGRESS_ROUTINE pFPR = 0
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    ULONG StructureAlignment;
    PARTITION_INFORMATION PartitionInformation;
    LARGE_INTEGER ByteOffset;

    if (pFPR)
    {
        pFPR(0);
    }

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!XapiFormatFATVolume(VolumePath))
    {
        return FALSE;
    }

    //
    // Open the volume for read/write access.
    //

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    //
    // Now do the verify...
    //

    {
        DWORD dwAllSectors = (DWORD) PartitionInformation.PartitionLength.QuadPart >> SectorShift;
        DWORD dwSecsPerVerify = min((dwAllSectors / 20) + 1, MAX_SECS_PER_VERIFY);
        DWORD dwPercent = 0;

        // Do a full verify of the disk

        for (DWORD i = 0; i < dwAllSectors; i += dwSecsPerVerify)
        {
            VERIFY_INFORMATION vi;

            if ((i * 100) / dwAllSectors > dwPercent)
            {
                dwPercent = ((i * 100) / dwAllSectors);
                //XDBGTRC("RECOVERY", "Format is %ld%% complete", dwPercent);
                if (pFPR)
                {
                    pFPR(dwPercent);
                }
            }

            vi.StartingOffset.QuadPart = i << SectorShift;
            vi.Length = min(dwSecsPerVerify, dwAllSectors - i) << SectorShift;

            ASSERT(dwSecsPerVerify < (0xFFFFFFFF >> SectorShift));

            status = NtDeviceIoControlFile(
                        VolumeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_VERIFY,
                        &vi,
                        sizeof(vi),
                        NULL,
                        0
                        );

            if (!NT_SUCCESS(status))
            {
                break;
            }

            if ((0 == i) && fQuickFormat)
            {
                //
                // NOTE: modifying loop counter, ugly, I know.  But this is a
                // convenient way to make sure that quickformat verifies the
                // beginning and the end of the disk..
                //
                i = max(i + dwSecsPerVerify, dwAllSectors - dwSecsPerVerify);
            }
        }

        NtClose(VolumeHandle);

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }
    }

    if (pFPR)
    {
        pFPR(100);
    }

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatHD
// Purpose:   Formats the Xbox HD. Adapted from ntos\recovery\recovery.cpp.
//            NOTE: Doesn't touch Partition2 (Y -- the Dash partition).
//                  That must be done elsewhere.
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL FormatHD()
{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OBJECT_ATTRIBUTES oa;
    HANDLE hDisk;
    NTSTATUS Status;
    int i;

    // Open a handle to the entire hard disk (aka Partition0)
    InitializeObjectAttributes(&oa, (POBJECT_STRING) &PrimaryHarddisk,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenFile(&hDisk, SYNCHRONIZE | GENERIC_ALL, &oa,
                        &statusBlock, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(Status))
    {
        wsprintf(g_szResult, TEXT("Failed to open HD for format"));
        return FALSE;
    }

    Status = WriteFirstSectors(hDisk);

    if (!NT_SUCCESS(Status))
    {
        wsprintf(g_szResult, TEXT("WriteFirstSectors() failed (0x%08x)"),
                 Status);
        return FALSE;
    }

    NtClose(hDisk);

    for (DWORD nCurPartition = 1; nCurPartition <
         XDISK_FIRST_CACHE_PARTITION + *HalDiskCachePartitionCount;
         nCurPartition++)
    {
        if (nCurPartition != 2)
        {
            OCHAR szPartition[MAX_PATH];
            OBJECT_STRING PartitionString;

            DebugOutput(TEXT("Formatting partition %d\n"), nCurPartition);

            _snoprintf(szPartition, ARRAYSIZE(szPartition), HdPartitionX,
                       nCurPartition);

            RtlInitObjectString(&PartitionString, szPartition);

            if (!RecFormatFATVolume(&PartitionString, TRUE))
            {
                wsprintf(g_szResult, TEXT("Failed to format partition %d"),
                         nCurPartition);
                return FALSE;
            }
        }
    }

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WipeCacheDB
// Purpose:   Wipes the cache db sector.  Called after data has been copied
//            off of the utility drive.
// Arguments: None.
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL WipeCacheDB()
{
    IO_STATUS_BLOCK statusBlock;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;
    LARGE_INTEGER WriteOffset;
    HANDLE hDisk;
    BYTE rgbZeroes[XBOX_HD_SECTOR_SIZE];

    // Open a handle to the entire hard disk (aka Partition0)
    InitializeObjectAttributes(&oa, (POBJECT_STRING) &PrimaryHarddisk,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenFile(&hDisk, SYNCHRONIZE | GENERIC_ALL, &oa,
                        &statusBlock, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(Status))
    {
        wsprintf(g_szResult, TEXT("Failed to open HD for format"));
        return FALSE;
    }

    WriteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

    memset(rgbZeroes, 0, XBOX_HD_SECTOR_SIZE);

    Status = NtWriteFile(hDisk, NULL, NULL, NULL, &statusBlock, rgbZeroes,
                         XBOX_HD_SECTOR_SIZE, &WriteOffset);
    if (FAILED(Status))
        return Status;

    if (!NT_SUCCESS(Status))
    {
        wsprintf(g_szResult, TEXT("WipeCacheDB() failed (0x%08x)"),
                 Status);
        return FALSE;
    }

    NtClose(hDisk);

    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatYPartition
// Purpose:   Formats the Y partition (Partition 2; the dash partition)
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL FormatYPartition()
{
    OCHAR szPartition[MAX_PATH];
    OBJECT_STRING PartitionString;

    _snoprintf(szPartition, ARRAYSIZE(szPartition), HdPartitionX, 2);

    RtlInitObjectString(&PartitionString, szPartition);

    if (!RecFormatFATVolume(&PartitionString, TRUE))
    {
        wsprintf(g_szResult, TEXT("Failed to format partition 2"));
        return FALSE;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\RecoverHD\RecoverHD\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rework\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\bootmbr.h ===
#define X86BOOTCODE_SIZE 512


unsigned char x86BootCode[] = {
51,192,142,208,188,0,124,251,80,7,80,31,252,190,27,124,
191,27,6,80,87,185,229,1,243,164,203,189,190,7,177,4,
56,110,0,124,9,117,19,131,197,16,226,244,205,24,139,245,
131,198,16,73,116,25,56,44,116,246,160,181,7,180,7,139,
240,172,60,0,116,252,187,7,0,180,14,205,16,235,242,136,
78,16,232,70,0,115,42,254,70,16,128,126,4,11,116,11,
128,126,4,12,116,5,160,182,7,117,210,128,70,2,6,131,
70,8,6,131,86,10,0,232,33,0,115,5,160,182,7,235,
188,129,62,254,125,85,170,116,11,128,126,16,0,116,200,160,
183,7,235,169,139,252,30,87,139,245,203,191,5,0,138,86,
0,180,8,205,19,114,35,138,193,36,63,152,138,222,138,252,
67,247,227,139,209,134,214,177,6,210,238,66,247,226,57,86,
10,119,35,114,5,57,70,8,115,28,184,1,2,187,0,124,
139,78,2,139,86,0,205,19,115,81,79,116,78,50,228,138,
86,0,205,19,235,228,138,86,0,96,187,170,85,180,65,205,
19,114,54,129,251,85,170,117,48,246,193,1,116,43,97,96,
106,0,106,0,255,118,10,255,118,8,106,0,104,0,124,106,
1,106,16,180,66,139,244,205,19,97,97,115,14,79,116,11,
50,228,138,86,0,205,19,235,214,97,249,195,73,110,118,97,
108,105,100,32,112,97,114,116,105,116,105,111,110,32,116,97,
98,108,101,0,69,114,114,111,114,32,108,111,97,100,105,110,
103,32,111,112,101,114,97,116,105,110,103,32,115,121,115,116,
101,109,0,77,105,115,115,105,110,103,32,111,112,101,114,97,
116,105,110,103,32,115,121,115,116,101,109,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,44,68,99,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\refresh\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <stdio.h>
#include <xapip.h>
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
//#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rework\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <stdio.h>
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rework\Rework.cpp ===
#include <ntos.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#define XFONT_TRUETYPE
#include <xfont.h>
#include "PerBoxData.h"
#include "cryptkeys.h"
#include "xboxvideo.h"
#include "smcdef.h"
#include "xboxverp.h"

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

#define RC4_CONFOUNDER_LEN 8


//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;


static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}


//
// Copied from recovery.cpp.
//
VOID
EjectDvd (VOID)
{
    //
    // This requires matching SMC firmware and DVD firmware (DVT3 and onward)..
    //

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        SMC_DVD_TRAY_OPERATION_OPEN);
}



HRESULT SetManufacturingRegion (VOID)
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    bResult = rc4HmacDecrypt(
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    if ( !bResult )
    {
        return E_FAIL;
    }

    //
    // Set the manufacturing region flag
    //
    pEncryptedEEPROMData->GameRegion |= XC_GAME_REGION_MANUFACTURING;

    //
    // Compute Key to use to lock hard drive
    // This must be done before we encrypt the buffer back to the encrypted state
    //
    XcHMAC( pEncryptedEEPROMData->HardDriveKey, HARD_DRIVE_KEY_LEN,
            (BYTE*)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (BYTE*)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    //
    // Encrypt the encrypted part back again
    //
    rc4HmacEncrypt(
        (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
        (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
        pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
        (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }


    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}

CXBoxVideo* g_pVideo;


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, DWORD dwColor)
{
    ASSERT(g_pVideo && pcszTextLine1);

    g_pVideo->ClearScreen(dwColor);

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }


    WCHAR szBuildString[64];
    wsprintfW(szBuildString, L"XTL Version %hs", VER_PRODUCTVERSION_STR);
    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();

}



#define MAX_RETRIES 3

//======================== The main function
void __cdecl main()
{
    HRESULT hr = E_FAIL;
    int tries = 0;

#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    //
    // Initialize our graphics.
    //
    if ((g_pVideo = new CXBoxVideo) == NULL) {

        XDBGWRN("factory", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pVideo->ShowScreen();

    //
    // Reset the manufacturing bit.
    // Per manufacturing request: We will retry MAX_RETRIES times before
    // giving up as failed.
    //
    while (tries < MAX_RETRIES && FAILED (hr)) {

        tries++;
        hr = SetManufacturingRegion ();
    }

    //
    // Give status. We don't assume the user reads english, or understands the terminology
    // Although there is text, the background color is the distinguishing feature.
    // RED == Unable to update EEPROM data.
    // GREEN == EEPROM update succeeded.
    //
    if ( FAILED( hr ) )
    {
        XDBGTRC("factory", "SetManufacturingRegion failed (returned %x)",hr);
        DrawMessage (L"Factory Reset", L"Failed to update Xbox configuration.", COLOR_TV_RED);
    }
    else
    {
        DrawMessage (L"Factory Reset", L"Xbox successfully updated.", COLOR_DARK_GREEN);
    }

    //
    // We are done, eject the DVD and wait forever.
    //
    //EjectDvd ();
    Sleep (INFINITE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rework\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "pch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'\n", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer\n" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer\n" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\refresh\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "pch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\refresh\refresh.cpp ===
#include "pch.h"
#include <xboxp.h>
#include <xconfig.h>
#include "xboxvideo.h"
#include "smcdef.h"
#include "xboxverp.h"

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

COBJECT_STRING PrimaryHarddisk = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\Partition0") );
COBJECT_STRING HdPartition1 = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\Partition1") );
COBJECT_STRING CDrive = CONSTANT_OBJECT_STRING( OTEXT("\\??\\C:") );

//
// Copied from recovery.cpp.
//
VOID
EjectDvd (VOID)
{
    //
    // This requires matching SMC firmware and DVD firmware (DVT3 and onward)..
    //

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        SMC_DVD_TRAY_OPERATION_OPEN);
}


CXBoxVideo* g_pVideo;


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, DWORD dwColor)
{
    ASSERT(g_pVideo && pcszTextLine1);

    g_pVideo->ClearScreen(dwColor);

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }


    WCHAR szBuildString[64];
    wsprintfW(szBuildString, L"XTL Version %hs", VER_PRODUCTVERSION_STR);
    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();

}


BOOL FResetHD(void)
{
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    LARGE_INTEGER WriteOffset;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status = STATUS_SUCCESS;
    BYTE rgbSectorBytes[XBOX_HD_SECTOR_SIZE];
    int i;
    BOOL f;
    NTSTATUS st;

    // Nuke the cache DB sector and the config sectors
    memset(rgbSectorBytes, 0, sizeof rgbSectorBytes);
    InitializeObjectAttributes(&oa, (POBJECT_STRING)&PrimaryHarddisk,
        OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenFile(&h, SYNCHRONIZE | GENERIC_ALL, &oa, &ioStatus, 0,
        FILE_SYNCHRONOUS_IO_NONALERT);
    f = NT_SUCCESS(st);
    for(i = XBOX_BOOT_SECTOR_INDEX;
        i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS); ++i)
    {
        /* We'll preserve the refurb data and we'll preserve the online
         * machine credentials.  We don't check the online credentials for
         * validity, since obliterating them would make them invalid anyway */
        if(i != XBOX_REFURB_INFO_SECTOR_INDEX && i !=
            (XBOX_CONFIG_SECTOR_INDEX + 1))
        {
            WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;
            st = NtWriteFile(h, NULL, NULL, NULL, &ioStatus, rgbSectorBytes,
                XBOX_HD_SECTOR_SIZE, &WriteOffset);
            f = NT_SUCCESS(st) && f;
        }
    }
    NtClose(h);

    // Nuke the data partition
    if(XapiFormatFATVolume((POBJECT_STRING)&HdPartition1)) {
        st = IoCreateSymbolicLink((POBJECT_STRING)&CDrive,
            (POBJECT_STRING)&HdPartition1);
        if(NT_SUCCESS(st)) {
            // Recreate the TDATA and UDATA directories
            // Do this with a bitwise OR rather than a binary OR to avoid the
            // short-circuit
            if(((!CreateDirectory("C:\\TDATA", NULL)) |
                    (!CreateDirectory("C:\\UDATA", NULL))) == 0)
                return f;
        }
    }
            
    return FALSE;
}

BOOL FResetUserEEPROMSettings(void)
{
    ULONG DvdRegion;
    EEPROM_LAYOUT Data;
    XBOX_USER_SETTINGS *UserData;
    NTSTATUS st;
    ULONG Type, Size;

    // Reset the user data, but preserve the DVD region, if set
    st = ExQueryNonVolatileSetting(XC_MAX_ALL, &Type, &Data, sizeof Data,
        &Size);
    if(!NT_SUCCESS(st))
        return FALSE;
    UserData = (XBOX_USER_SETTINGS *)Data.UserConfigSection;

    DvdRegion = UserData->DvdRegion;
    if(DvdRegion < 1 || DvdRegion > 6)
        // guard against bogus setting
        DvdRegion = 0;

    memset(UserData, 0, sizeof *UserData);
    UserData->DvdRegion = DvdRegion;
    if (XGetGameRegion() & XC_GAME_REGION_JAPAN) {
        UserData->Language = XC_LANGUAGE_JAPANESE;
        UserData->TimeZoneBias = -540;
        strcpy(UserData->TimeZoneStdName, "TST");
        strcpy(UserData->TimeZoneDltName, "TST");
    }

    UserData->Checksum = ~XConfigChecksum(UserData, sizeof *UserData);
    st = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, &Data, sizeof Data);
    return NT_SUCCESS(st);
}


//======================== The main function
void __cdecl main()
{
    BOOL f;

#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    //
    // Initialize our graphics.
    //
    if ((g_pVideo = new CXBoxVideo) == NULL) {

        XDBGWRN("factory", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pVideo->ShowScreen();

    f = FResetHD();
    f = FResetUserEEPROMSettings() && f;

    //
    // Give status. We don't assume the user reads english, or understands the terminology
    // Although there is text, the background color is the distinguishing feature.
    // RED == Unable to update EEPROM data.
    // GREEN == EEPROM update succeeded.
    //
    if (!f)
    {
        DrawMessage (L"System refresh", L"Failed to refresh system", COLOR_TV_RED);
    }
    else
    {
        DrawMessage (L"System refresh", L"Xbox successfully updated.", COLOR_DARK_GREEN);
    }

    //
    // We are done, eject the DVD and wait forever.
    //
    EjectDvd ();
    Sleep (INFINITE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\recovpch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <scsi.h>
#include <stdio.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#ifdef RECOVERYAPP

#define XFONT_TRUETYPE
#include <xfont.h>

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    );

#endif // RECOVERYAPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\recovstr.h ===
#pragma once

static const PWSTR RStrings[] =
{
    L"[Internal] Xbox version %hs (0x%02x)",
    L"Xbox version %hs",
    L"Xbox recovery has failed", L"because of an unexpected error (0x%08x).",
    L"because this Xbox is no longer supported.",
    L"Press any gamepad button to begin recovery.", L"(Warning: Hard disk will be erased.)",
    L"Recover as a retail Xbox or a dev kit Xbox?", L"(Y button: retail, Any other button: dev kit)",
    L"Please wait.  Updating the ROM...", L"(Do not reboot or power off!)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please eject and remove the recovery CD.",
    L"Please remove the recovery CD and",
    L"press any gamepad button to reboot.",
};

enum RECOVSTR_INDEX
{
    RS_BUILD_NUMBER_FORMAT_INTERNAL = 0,
    RS_BUILD_NUMBER_FORMAT,
    RS_FAILURE_LINE1,
    RS_FAILURE_LINE2_FORMAT,
    RS_FAILURE_LINE2_OLD_BOX,
    RS_GAMEPAD_BEGIN_LINE1,
    RS_GAMEPAD_BEGIN_LINE2,
    RS_RETAIL_LINE1,
    RS_RETAIL_LINE2,
    RS_FLASH_LINE1,
    RS_FLASH_LINE2,
    RS_PREPARING,
    RS_COPYING,
    RS_GAMEPAD_END_RETAIL,
    RS_GAMEPAD_END_LINE1,
    RS_GAMEPAD_END_LINE2,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\recovery.cpp ===
#include "recovpch.h"
#include "recovstr.h"
#include "xboxverp.h"
#include "xconfig.h"
#include "xboxp.h"
#include "xdisk.h"
#include "smcdef.h"
#include "xboxvideo.h"
#include "imagefile.h"
#include "xcrypt.h"

#define RECOVERYNOFLASH 1

#ifndef RECOVERYNOFLASH

#define ROM_SIZE                    (1024 * 1024)
#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_BYTE_OFFSET     0x78
#define ROM_FLASH_RETRIES           25

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)RomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

#endif // ! RECOVERYNOFLASH

#define ZERO_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"


#define QUICK_FORMAT TRUE


extern "C"
{
UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

BOOL
WINAPI
XapiFormatFATVolume(
    POBJECT_STRING pcVolume
    );


BYTE g_InitTableVer = 0;
BOOL g_fInternalCD;

extern DWORD D3D__AvInfo;



}


ULONG g_FilesCopied = 0;

#define APPROX_FILE_COUNT   350

const POSTR g_RootDirExceptions[] =
{
    OTEXT("default.xbe"),
    OTEXT("RETAIL"),
    OTEXT("RECMEDIA"),
    OTEXT("XDASH")
};

const POSTR g_RetailDashExceptions[] =
{
    OTEXT("3dinfo"),
    OTEXT("data"),
    OTEXT("media"),
    OTEXT("menus"),
    OTEXT("sounds"),
    OTEXT("xboxdash.xbe"),
    OTEXT("xshell.xbe"),
    OTEXT("dvdkeyd.bin")
};

CXBoxVideo* g_pVideo;
BitmapFile* g_pBackgroundBitmap;


COBJECT_STRING DVDDevice =         CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Cdrom0") );
COBJECT_STRING PrimaryHarddisk =   CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition0") );
COBJECT_STRING HdPartition1 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1") );
COBJECT_STRING HdPartition2 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition2") );
COBJECT_STRING CDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\C:") );
COBJECT_STRING YDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\Y:") );

#define DASHBOARD_PARTITION_NUMBER 2

static const CHAR HdPartitionX[] = "\\Device\\Harddisk0\\partition%d";


//
// Functions for dealing with the encrypted section of the EEPROM
//

//
// The EEPROM encrypted section is unencrypted if the hard drive key field is all 0's
//
inline BOOL IsEEPROMEncryptedSectionUnencrypted(const XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    const UCHAR* hdkey = encryptedSection->HDKey;
    for (INT i=0; i < XBOX_KEY_LENGTH; i++)
        if (hdkey[i] != 0) return FALSE;
    return TRUE;
}

//
// Decrypted the encrypted section of the EEPROM
//
static DWORD DecryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    EncryptedSettings = *encryptedSection;
    Data = EncryptedSettings.HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
    memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        EncryptedSettings.Checksum,
        XC_SERVICE_DIGEST_SIZE,
        NULL,
        0,
        LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    //
    // Now verify the checksum.
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        Confounder,
        RC4_CONFOUNDER_LEN,
        Data,
        DataSize,
        Checksum);

    //
    // Decrypt is successful only if checksum matches
    //
    if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0)
        return ERROR_INVALID_PASSWORD;

    memset(encryptedSection, 0, sizeof(*encryptedSection));
    memcpy(encryptedSection->HDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    encryptedSection->GameRegion = EncryptedSettings.GameRegion;
    return ERROR_SUCCESS;
}

//
// Encrypt the encrypted section of the EEPROM
//
static DWORD EncryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    UCHAR Confounder[RC4_CONFOUNDER_LEN] = { 0x4c,0x70,0x33,0xcb,0x5b,0xb5,0x97,0xd2 };
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    Data = encryptedSection->HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);

    //
    // Create the header - the confounder & checksum
    //
    memset(encryptedSection->Checksum, 0, sizeof(encryptedSection->Checksum));
    memcpy(encryptedSection->Confounder, Confounder, sizeof(encryptedSection->Confounder));

    //
    // Checksum everything but the checksum
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Confounder,
           RC4_CONFOUNDER_LEN,
           Data,
           DataSize,
           encryptedSection->Checksum);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Checksum,
           XC_SERVICE_DIGEST_SIZE,
           NULL,
           0,
           LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, encryptedSection->Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    return ERROR_SUCCESS;
}

//
// Make sure the encrypted section of the EEPROM is encrypted and that there is
// a region set
//
static DWORD PrepareEEPROM(BOOL fRetail)
{
    EEPROM_LAYOUT eepromData;
    ULONG type, length;
    DWORD err;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection =
        (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
    {
        if (ERROR_SUCCESS != DecryptEEPROMEncryptedSection(encryptedSection))
        {
            memset(encryptedSection, 0, sizeof(*encryptedSection));
        }
    }

    if (0 == (encryptedSection->GameRegion & ~XC_GAME_REGION_MANUFACTURING))
    {
        encryptedSection->GameRegion = XC_GAME_REGION_NA;
    }
    else
    {
        encryptedSection->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;
    }

    //
    // Only encrypt the EEPROM header if this is going to be a retail box
    //
    if (fRetail)
    {
        err = EncryptEEPROMEncryptedSection(encryptedSection);

        if (ERROR_SUCCESS != err)
        {
            return err;
        }
    }

    return XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));
}


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, int iProgPercent)
{
    ASSERT(g_pVideo && g_pBackgroundBitmap && pcszTextLine1);

    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        //
        // Draw progress bar bkgnd
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        //
        // Draw progress bar
        //

        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) * min(iProgPercent, 100)),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);
    }

    WCHAR szBuildString[64];

    if (g_fInternalCD)
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT_INTERNAL],
                  VER_PRODUCTVERSION_STR,
                  g_InitTableVer);
    }
    else
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT],
                  VER_PRODUCTVERSION_STR);
    }

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();
}


VOID
EjectDVD()
{
    //
    // This requires matching SMC firmware and DVD firmware (DVT3 and onward)..
    //

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        SMC_DVD_TRAY_OPERATION_OPEN);
}


DWORD ReadSMC(unsigned char addr)
{
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
}


VOID GetSMCVersion(PSTR pszSMCVersion, UINT cchSMCVersion)
{
    ASSERT(cchSMCVersion > 3);

    HalWriteSMBusValue(0x21, 0x01, FALSE, 0);

    pszSMCVersion[0] = (char)ReadSMC(0x01);
    pszSMCVersion[1] = (char)ReadSMC(0x01);
    pszSMCVersion[2] = (char)ReadSMC(0x01);
    pszSMCVersion[3] = '\0';
}

//
// Copies files from a source path to a destination path.  The source path
// is a filter that can be passed to FindFirstFile() and is currently required
// to end in "\\*".  The destination path should end with a trailing backslash ('\')
//

BOOL
CopyFiles(
    IN PCOSTR pcszSrcPath,
    IN PCOSTR pcszDestPath,
    IN BOOL fRootDir,
    IN const POSTR * ppszExceptionList,
    IN UINT cExceptionListItems
    )
{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
    int nSrcLen = ocslen(pcszSrcPath);
    int nDestLen = ocslen(pcszDestPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);

    if (NULL == ppszExceptionList)
    {
        ppszExceptionList = g_RootDirExceptions;
        cExceptionListItems = ARRAYSIZE(g_RootDirExceptions);
    }

    if (INVALID_HANDLE_VALUE != hFind)
    {
        OCHAR szSrcFile[MAX_PATH], szDestFile[MAX_PATH];
        ocscpy(szSrcFile, pcszSrcPath);
        ocscpy(szDestFile, pcszDestPath);
        ASSERT((szSrcFile[nSrcLen - 1] == OTEXT('*')) &&
               (szSrcFile[nSrcLen - 2] == OTEXT('\\')));
        do
        {
            BOOL fCopyThis = TRUE;

            if (fRootDir)
            {
                int i;
                for (i = 0; i < (int) cExceptionListItems; i++)
                {
                    if (0 == _ocsicmp(wfd.cFileName, ppszExceptionList[i]))
                    {
                        fCopyThis = FALSE;
                        break;
                    }
                }
            }

            if (!fCopyThis)
            {
                continue;
            }

            lstrcpynO(&(szSrcFile[nSrcLen - 1]),
                      wfd.cFileName,
                      ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
            lstrcpynO(&(szDestFile[nDestLen]),
                      wfd.cFileName,
                      ARRAYSIZE(szDestFile) - nDestLen);

            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                int nFileLen = ocslen(wfd.cFileName);

                bRet = CreateDirectory(szDestFile, NULL);

                if (!bRet)
                {
                    break;
                }

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]),
                          OTEXT("\\*"),
                          ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));

                lstrcpynO(&(szDestFile[nDestLen + nFileLen]),
                          OTEXT("\\"),
                          ARRAYSIZE(szDestFile) - (nDestLen + nFileLen));

                bRet = CopyFiles(szSrcFile, szDestFile, FALSE, NULL, 0);

                if (!bRet)
                {
                    break;
                }
            }
            else
            {
                bRet = CopyFile(szSrcFile, szDestFile, FALSE);

                //
                // Files coming off of CD/DVD end up read-only, so clear
                // all of the attributes.. (otherwise dosnet won't work)
                //

                SetFileAttributes(szDestFile, FILE_ATTRIBUTE_NORMAL);

                if (!bRet)
                {
                    break;
                }

                DrawMessage(RStrings[RS_COPYING],
                            NULL,
                            5 + min((++g_FilesCopied * 90) / APPROX_FILE_COUNT, 90));
            }

        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
    {
        bRet = TRUE;
    }

    return bRet;
}


NTSTATUS
WriteFirstSectors(
    IN HANDLE hDisk
    )
{
    LARGE_INTEGER WriteOffset;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    BYTE rgbSectorBytes[XBOX_HD_SECTOR_SIZE];
	BYTE RefurbSectorBytes[XBOX_HD_SECTOR_SIZE];
	XBOX_REFURB_INFO RefurbInfo;
    PXBOX_CONFIG_SECTOR ConfigSector = (PXBOX_CONFIG_SECTOR) rgbSectorBytes;
    int i;

    //
    // Zero out sectors 0-2 and 4-7 (including cache db sector):
    //

    //
    // Sector 3 (XBOX_REFURB_INFO_SECTOR_INDEX) contains the refurb
    // information - leave it alone
    //

    RtlZeroMemory(rgbSectorBytes, sizeof(rgbSectorBytes));

    for (i = XBOX_BOOT_SECTOR_INDEX;
         i < XBOX_REFURB_INFO_SECTOR_INDEX;
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

	// reset refurb info

	RefurbInfo.Signature = XBOX_REFURB_INFO_SIGNATURE;
	RefurbInfo.PowerCycleCount = 0;
	RefurbInfo.FirstSetTime.QuadPart = 0;
	// setup sector data with xbox refurb info
	memcpy(rgbSectorBytes,&RefurbInfo,sizeof(XBOX_REFURB_INFO));
	// using the dropout value of i for the calculation
	WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;
	NtWriteFile(hDisk,
            NULL,
            NULL,
            NULL,
            &ioStatus,
            rgbSectorBytes,
            XBOX_HD_SECTOR_SIZE,
            &WriteOffset);

	// clear rgbsectorbytes again
    RtlZeroMemory(rgbSectorBytes, sizeof(rgbSectorBytes));

    for (i = XBOX_CACHE_DB_SECTOR_INDEX;
         i < XBOX_CONFIG_SECTOR_INDEX;
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

    //
    // Preserve config sectors sectors 8-15 (if valid), otherwise zero them:
    //

    for (i = XBOX_CONFIG_SECTOR_INDEX;
         i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS);
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        status = NtReadFile(hDisk,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatus,
                            ConfigSector,
                            XBOX_HD_SECTOR_SIZE,
                            &WriteOffset);

        if (NT_SUCCESS(status) &&
            (ConfigSector->SectorBeginSignature == XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE) &&
            (ConfigSector->SectorEndSignature == XBOX_CONFIG_SECTOR_END_SIGNATURE) &&
            (XConfigChecksum(ConfigSector, sizeof(*ConfigSector)) == 0xffffffff))
        {
            XDBGWRN("RECOVERY", "Preserving config sector %d.", i);
        }
        else
        {
            XDBGWRN("RECOVERY", "Invalid config sector %d - not preserving.", i);
            RtlZeroMemory(ConfigSector, XBOX_HD_SECTOR_SIZE);

            NtWriteFile(hDisk,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatus,
                        ConfigSector,
                        XBOX_HD_SECTOR_SIZE,
                        &WriteOffset);
        }
    }

    return status;
}


//
// Reset user settings in EEPROM to their defaults (all zeros)
//

NTSTATUS ResetEEPROMUserSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory(userSettings, sizeof(*userSettings));
        userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));
    }

    return status;
}




//
// Generate the default EEPROM image
//  We assume the output buffer has already been
//  zero-initialized by the caller.
//
VOID DefaultNonVolatileSettings(EEPROM_LAYOUT* eeprom)
{
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    LARGE_INTEGER systime;
    UCHAR* enetaddr;
    ULONG tick0;

    // Pick a random Ethernet address in the 1M range
    // of the 00-50-f2 address block. Only even addresses
    // are used here.
    __asm {
        rdtsc
        mov tick0, eax
    }
    KeQuerySystemTime(&systime);
    tick0 = (tick0 ^ systime.LowPart) & 0xffffe;

    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;

    enetaddr = factorySettings->EthernetAddr;
    enetaddr[0] = 0x00;
    enetaddr[1] = 0x50;
    enetaddr[2] = 0xf2;
    enetaddr[3] = (UCHAR) (tick0 >> 16);
    enetaddr[4] = (UCHAR) (tick0 >>  8);
    enetaddr[5] = (UCHAR) (tick0      );

    // The first 32 addresses are reserved.
    enetaddr[5] |= 0x20;

    factorySettings->AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
    factorySettings->Checksum = ~XConfigChecksum(factorySettings, sizeof(*factorySettings));

    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
}

//
// Verify the non-volatile settings are valid
// and initialize them to default values if necessary.
//
NTSTATUS CheckNonVolatileSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status) &&
        XConfigChecksum(factorySettings, sizeof(*factorySettings)) == 0xffffffff &&
        XConfigChecksum(userSettings, sizeof(*userSettings)) == 0xffffffff) {
        XDBGWRN("RECOVERY", "Preserving EEPROM settings.");
    } else if (XboxHardwareInfo->GpuRevision == 0xa1) {
        XDBGWRN("RECOVERY", "Initializing EEPROM settings (DVT2) ...");
        memset(buf, 0, sizeof(buf));

        DefaultNonVolatileSettings(eeprom);
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));

        if (!NT_SUCCESS(status)) {
            XDBGWRN("RECOVERY", "Failed to initialized EEPROM settings: %x.", status);
        }
    } else {
        XDBGWRN("RECOVERY", "!!!!!!!!!! Corrupted EEPROM on DVT3 box !!!!!!!!!!");
    }

    return status;
}


// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

//
// This function returns with *pdwNewVideoMode set to 0xFFFFFFFF if a regular
// controller button is pressed.
//
// It returns with *pdwNewVideoMode set to a valid video mode if a video mode
// change button sequence has been pressed:
// (both triggers + right thumbstick + some other button)
//

VOID
WaitForAnyButton(PDWORD pdwNewVideoMode, PBOOL pfYButton)
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed)
    {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++)
            {
                if ((1 << i) & dwRemovals)
                {
                    if (NULL != hPads[i])
                    {
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                    }
                }

                if ((1 << i) & dwInsertions)
                {
                    if (NULL == hPads[i])
                    {
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                    }
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                if (NULL != hPads[i])
                {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State))
                    {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                            {
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                            }
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;
                            
                            if (pfYButton)
                            {
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                            }
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF))
            {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}



#define FAIL_RECOVERY(code)                                    \
{                                                              \
    WCHAR szMsg[128];                                          \
    wsprintfW(szMsg, RStrings[RS_FAILURE_LINE2_FORMAT], code); \
    DrawMessage(RStrings[RS_FAILURE_LINE1], szMsg, -1);        \
    XDBGWRN("RECOVERY", "Recovery failed (err 0x%08x)", code); \
    IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();   \
    ASSERT(pDevice);                                           \
    pDevice->BlockUntilIdle();                                 \
    Sleep(INFINITE);                                           \
    return;                                                    \
}




#define MAX_SECS_PER_VERIFY 256

typedef
VOID
(CALLBACK *PFORMAT_PROGRESS_ROUTINE)(
    UINT uPercent
    );

BOOL
WINAPI
RecFormatFATVolume(
    POBJECT_STRING VolumePath,
    BOOL fQuickFormat,
    PFORMAT_PROGRESS_ROUTINE pFPR
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    ULONG StructureAlignment;
    PARTITION_INFORMATION PartitionInformation;
    LARGE_INTEGER ByteOffset;

    if (pFPR)
    {
        pFPR(0);
    }

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!XapiFormatFATVolume(VolumePath))
    {
        return FALSE;
    }

    //
    // Open the volume for read/write access.
    //

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    //
    // Now do the verify...
    //

    {
        DWORD dwAllSectors = (DWORD) PartitionInformation.PartitionLength.QuadPart >> SectorShift;
        DWORD dwSecsPerVerify = min((dwAllSectors / 20) + 1, MAX_SECS_PER_VERIFY);
        DWORD dwPercent = 0;

        // Do a full verify of the disk

        for (DWORD i = 0; i < dwAllSectors; i += dwSecsPerVerify)
        {
            VERIFY_INFORMATION vi;

            if ((i * 100) / dwAllSectors > dwPercent)
            {
                dwPercent = ((i * 100) / dwAllSectors);
                XDBGTRC("RECOVERY", "Format is %ld%% complete", dwPercent);
                if (pFPR)
                {
                    pFPR(dwPercent);
                }
            }

            vi.StartingOffset.QuadPart = i << SectorShift;
            vi.Length = min(dwSecsPerVerify, dwAllSectors - i) << SectorShift;

            ASSERT(dwSecsPerVerify < (0xFFFFFFFF >> SectorShift));

            status = NtDeviceIoControlFile(
                        VolumeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_VERIFY,
                        &vi,
                        sizeof(vi),
                        NULL,
                        0
                        );

            if (!NT_SUCCESS(status))
            {
                XDBGERR("RECOVERY",
                        "NtDeviceIoControlFile() IOCTL_DISK_VERIFY failed - st=0x%08X",
                        status);
                break;
            }

            if ((0 == i) && fQuickFormat)
            {
                //
                // NOTE: modifying loop counter, ugly, I know.  But this is a
                // convenient way to make sure that quickformat verifies the
                // beginning and the end of the disk..
                //
                i = max(i + dwSecsPerVerify, dwAllSectors - dwSecsPerVerify);
            }
        }

        NtClose(VolumeHandle);

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }
    }

    if (pFPR)
    {
        pFPR(100);
    }

    return TRUE;
}

//
// Index of the partition that is currently being formatted (1-based)
//

UINT g_CurrentFormatPartition;


VOID
CALLBACK
RecFormatProgress(
    UINT uPercent
    )
{
    UINT uPartitions = (XDISK_FIRST_CACHE_PARTITION - 1) + *HalDiskCachePartitionCount;
    DrawMessage(RStrings[RS_PREPARING],
                NULL,
                ((100 / uPartitions) * (g_CurrentFormatPartition - 1)) +
                    (uPercent / uPartitions));
}

BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}



void __cdecl main()
{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OBJECT_ATTRIBUTES oa;
    HANDLE hDisk;
    NTSTATUS Status;
    int i;
    

    WCHAR szText[128];
    DWORD dwVideoFlags;
    BOOL fRetail = FALSE;
    UINT WaitStep = 0;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    BOOL fDiskHasRetail = (0xFFFFFFFF != GetFileAttributes("D:\\RETAIL"));
    DWORD dwNV2ARevision = *((DWORD*)0xFD000000);
    CHAR szSMCVersion[4];

    GetSMCVersion(szSMCVersion, ARRAYSIZE(szSMCVersion));
    
    g_fInternalCD = (0xFFFFFFFF != GetFileAttributes("D:\\DEVKIT\\DXT\\CYDRIVE.DXT"));

    //
    // Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

    CheckNonVolatileSettings();


    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;

    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        XDBGERR("RECOVERY", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\rrbkgrnd.bmp");

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version >= 0x46: DVT4
    //

    //
    // SMC Versions starting with 'B' are no longer supported (DVT3=B2A, DVT4=B3B, etc.)
    //
    // DVT5/XDK2 and greater start with 'D' or 'P' (i.e. DVT5=DXB)
    //
/* allow DVT 4 boxes for now
    if ((g_InitTableVer < 0x46) ||
        ((dwNV2ARevision & 0xFF) == 0xA1) ||
        ((dwNV2ARevision & 0xFF) == 0xA2) ||
        (szSMCVersion[0] == 'B'))

     if ((g_InitTableVer < 0x46) ||
        ((dwNV2ARevision & 0xFF) == 0xA1) ||
        ((dwNV2ARevision & 0xFF) == 0xA2))
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_OLD_BOX], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox is no longer supported");

        XDBGWRN("RECOVERY", "Versions: 0x%02x, 0x%02x, %s",
                g_InitTableVer, (dwNV2ARevision & 0xFF), szSMCVersion);

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }
*/
    DrawMessage(RStrings[RS_GAMEPAD_BEGIN_LINE1], RStrings[RS_GAMEPAD_BEGIN_LINE2], -1);

    while (WaitStep < 2)
    {
        WaitForAnyButton(&dwVideoFlags, &fRetail);

        if (0xFFFFFFFF != dwVideoFlags)
        {
            //
            // Reset video flags and re-init
            //

            ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));

            D3D__AvInfo = 0;

            g_pVideo->DeInitialize();

            g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

            g_pVideo->ClearScreen(COLOR_BLACK);
            g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
            g_pVideo->ShowScreen();
        }
        else
        {
            WaitStep++;
            if (!fDiskHasRetail)
            {
                fRetail = FALSE;
                break;
            }
        }

        //
        // Wait for the button to go back up before asking for another button press
        //
        
        if ((WaitStep > 0) && (WaitStep < 2))
        {
            Sleep(200);
        }
        
        DrawMessage(RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE1 : RS_RETAIL_LINE1],
                    RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE2 : RS_RETAIL_LINE2],
                    -1);

    }

    if (ERROR_SUCCESS != PrepareEEPROM(fRetail))
    {
        XDBGWRN("RECOVERY", "Recovery failed because it could not prepare the EEPROM");
        FAIL_RECOVERY(25);
    }



    DrawMessage(RStrings[RS_PREPARING], NULL, 0);



    Status = ResetEEPROMUserSettings();

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Dash recovery failed because ResetEEPROMUserSettings() failed");
        HalReturnToFirmware(HalFatalErrorRebootRoutine);
    }


    //
    // Open a handle to the entire hard disk (aka Partition0)
    //

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &PrimaryHarddisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hDisk,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Could not open hard disk %Z (0x%08x).", &PrimaryHarddisk, Status);
        FAIL_RECOVERY(13);
    }

    Status = WriteFirstSectors(hDisk);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY",
                "WriteFirstSectors() failed (0x%08x) for hard disk %Z.",
                Status,
                &PrimaryHarddisk);
        FAIL_RECOVERY(14);
    }

    NtClose(hDisk);

    XDBGTRC("RECOVERY", "Formatting hard disk partitions...");

    for (g_CurrentFormatPartition = 1;
         g_CurrentFormatPartition < XDISK_FIRST_CACHE_PARTITION + *HalDiskCachePartitionCount;
         g_CurrentFormatPartition++)
    {
        OCHAR szPartition[MAX_PATH];
        OBJECT_STRING PartitionString;


        _snoprintf(szPartition,
                   ARRAYSIZE(szPartition),
                   HdPartitionX,
                   g_CurrentFormatPartition);

        RtlInitObjectString(&PartitionString, szPartition);

        if (!RecFormatFATVolume(
                &PartitionString,
                QUICK_FORMAT,
                RecFormatProgress))
        {
            XDBGERR("RECOVERY", "Could not format hard disk partition %d.", g_CurrentFormatPartition);
            FAIL_RECOVERY(100 + g_CurrentFormatPartition);
        }
    }



    DrawMessage(RStrings[RS_COPYING], NULL, 5);

    //
    // Give the main partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &CDrive, (POBJECT_STRING) &HdPartition1)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &CDrive, &HdPartition1);
        FAIL_RECOVERY(15);
    }

    if (fRetail)
    {
        if (!CreateDirectory("C:\\TDATA", NULL))
        {
            FAIL_RECOVERY(22);
        }
        
        if (!CreateDirectory("C:\\UDATA", NULL))
        {
            FAIL_RECOVERY(23);
        }
    }
    else
    {
        if (!CopyFiles(OTEXT("D:\\*"), OTEXT("C:\\"), TRUE, NULL, 0))
        {
            XDBGERR("RECOVERY", "Could not copy files to the hard disk (main partition)");
            FAIL_RECOVERY(16);
        }
    }

    //
    // Give the dash partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &YDrive, (POBJECT_STRING) &HdPartition2)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &YDrive, &HdPartition2);
        FAIL_RECOVERY(17);
    }

    if (!CopyFiles(OTEXT("D:\\XDASH\\*"),
                   OTEXT("Y:\\"),
                   fRetail,
                   fRetail ? g_RetailDashExceptions : NULL,
                   fRetail ? ARRAYSIZE(g_RetailDashExceptions) : 0))
    {
        XDBGERR("RECOVERY", "Could not copy files to the hard disk (dash partition)");
        FAIL_RECOVERY(18);
    }

    if (fRetail)
    {
        //
        // Copy over the retail dash
        //

        if (!CopyFile("D:\\RETAIL\\xboxdash.xbe", "Y:\\xboxdash.xbe", FALSE))
        {
            FAIL_RECOVERY(24);
        }
    }

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        ASSERT( RtlEqualMemory( ZERO_KEY, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ) );
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
    }

    //
    // Compute Key to use to lock hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );

    DrawMessage(RStrings[RS_COPYING], NULL, 100);

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        XDBGTRC("RECOVERY", "\n\nPlease remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_LINE1], RStrings[RS_GAMEPAD_END_LINE2], -1);

        EjectDVD();
    }
    else
    {
        //
        // We can't eject the CD if we're running on the retail kernel, so we have to ask the
        // user to eject instead...
        //
        
        XDBGTRC("RECOVERY", "\n\nPlease eject and remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_RETAIL], NULL, -1);
    }

    WaitForAnyButton(&dwVideoFlags, NULL);

    if (0xFFFFFFFF != dwVideoFlags)
    {
        //
        // Reset video flags before rebooting
        //

        ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));
    }

    XDBGWRN("RECOVERY", "Recovery completed successfully.");

    HalReturnToFirmware( HalRebootRoutine );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\unlock\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_TV_GREEN                          0xFF2CDF2C
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\unlock\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <stdio.h>
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

    // Always do interlaced output on an HDTV.
    if (XGetAVPack() == XC_AV_PACK_HDTV)
    {
        d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    }

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( XFONT_CENTER );
        XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\rr_recovery\flash.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    flash.c

Abstract:

    This module implements function used to program kernel image to flash
    ROM on EVT and DVT machine.

--*/

#include "recovpch.h"
#include <pci.h>


//
// Manufacturer and chip identifiers
//

#define SST_ID                  0xBF
#define SST_49LF040             0x53

#define AMD_ID                  0x01
#define FUJITSU_ID              0x04
#define HYUNDAI_ID              0xAD
#define GENERIC_29F080          0xD5

#define ST_ID                   0x20
#define M29F080A                0xF1

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080
} FlashDeviceID;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize( ID )         FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024     // Generic 29F080
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress( ID )  ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if ( !ARGUMENT_PRESENT(Address) ) {
        Address = FlashBaseAddress( ID );
    }

    if ( ID == FlashSST49LF040 ) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;        // data matches
        } else if ( d & 0x20 ) {            // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if ( t == d ) {
                return FlashStatusReady;    // data matches
            }
            if ( retry-- ) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if ( retry-- ) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0xF0 );
    KeStallExecutionProcessor( 150000 );
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;

detect:

    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0x90 );

    KeStallExecutionProcessor( 1 );

    id1 = FlashReadByte( 0xFFFF0000 );
    id2 = FlashReadByte( 0xFFFF0001 );

    FlashResetDevice();

    if ( id1 == SST_ID && id2 == SST_49LF040 ) {
        return FlashSST49LF040;
    }

    if ( (id1 == AMD_ID || id1 == HYUNDAI_ID || id1 == FUJITSU_ID) && \
         id2 == GENERIC_29F080 ) {
        return FlashGeneric29F080;
    }

    if ( id1 == ST_ID && id2 == M29F080A ) {
        return FlashGeneric29F080;
    }

    if ( FirstTime == TRUE ) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for ( byte=0x00; byte<=0xff; byte++ ) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace( 0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration) );
            if ( Configuration.BaseClass == 6 && Configuration.SubClass == 1 ) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if ( Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2 ) {
            byte = 0x01;
            HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while ( Retries-- ) {

        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x80 );
        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x10 );

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while ( FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count ) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while ( FlashReadByte(FlashPtr) != 0xFF && Count ) {
            KeStallExecutionProcessor( 150000 );
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize( ID );
        FlashResetDevice();
        FlashPtr = FlashBaseAddress( ID );

        ASSERTMSG( "Size of flash ROM must be power of two", (Count & (Count-1)) == 0 );

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != 0xFFFF ) {
                DbgPrint( "FLASH: blank check failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while ( Retries-- ) {

        Count = FlashSize( ID );
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );

        while ( Count-- ) {

            b = *pb++;

            if ( b != 0xFF ) {
                FlashWriteByte( 0xFFFF5555, 0xAA );
                FlashWriteByte( 0xFFFF2AAA, 0x55 );
                FlashWriteByte( 0xFFFF5555, 0xA0 );
                FlashWriteByte( FlashPtr, b );

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while ( FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again ) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while ( FlashReadByte(FlashPtr) != b && Again ) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize( ID );
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );
        FlashResetDevice();

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != *pw++ ) {
                DbgPrint( "FLASH: verification failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR( 0x2FF );
    FlashWriteMSR( 0x2FF, 0 );

    for ( MTRR=0x200; MTRR<0x20F; MTRR+=2 ) {
        v = FlashReadMSR( MTRR );
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if ( Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0 ) {
            v = FlashReadMSR( MTRR+1 );
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR( MTRR+1, v );
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR( 0x2FF, MTRRdeftype );

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = S_OK;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if ( IsBadReadPtr(ImageBuffer, ImageSize) || \
         IsBadWritePtr(szResp, cchResp) ) {
        return HRESULT_FROM_WIN32( ERROR_NOACCESS );
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( !KernelRomBase ) {
        _snprintf( szResp, cchResp, "unable to map i/o space" );
        return E_FAIL;
    }

    __asm cli

    XDBGWRN("RECOVERY", "FLASH: interrupts are now disabled" );

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching( FALSE );

    ID = FlashDetectDevice();

    if ( ID == FlashUnknownDevice ) {
        _snprintf( szResp, cchResp, "Unknown flash device id" );
        hr = E_FAIL;
        goto cleanup;
    }

    if ( FlashSize(ID) != ImageSize ) {
        _snprintf( szResp, cchResp, "Invalid image size" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: erasing and blank checking..." );

    if ( !FlashEraseChip(ID) ) {
        _snprintf( szResp, cchResp, "Failed to erase flash chip" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: programming..." );

    if ( !FlashProgramImage(ID, ImageBuffer) ) {
        _snprintf( szResp, cchResp, "Failed to program kernel image (verify failed)" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: done" );

    if ( SUCCEEDED(hr) ) {
        _snprintf( szResp, cchResp, "Done, new image flashed" );
    }

    hr = S_OK;

cleanup:

    __asm sti

    XDBGWRN("RECOVERY", "FLASH: interrupts are now enabled" );

    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching( TRUE );

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint( "FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\unlock\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\ScreenTest\screentest.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ScreenTest.h

Abstract:

    Definitions for ScreenTest application

Author:

    Dennis Krueger (a-denkru) July 2001

Revision History:

--*/
#ifndef __SCREENTEST_H_
#define __SCREENTEST_H_



#include <ntos.h>

// disk
#include <ntdddisk.h>
#include <ntddscsi.h>

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include <XBApp.h>
#include <XBInput.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBSound.h>
#include <XBStopWatch.h>
#include <xboxp.h>
#include <xconfig.h>

#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define MAX_LINES 100

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

class CTextScreenLine
{
public:
	
	 FLOAT m_sx;
	 FLOAT m_sy;
	 DWORD m_dwColor;
	 WCHAR* m_strText;
	 DWORD m_dwFlags;


	 CTextScreenLine();
	 CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * TextStr, DWORD dwFlags=0);

	 ~CTextScreenLine() {;};  // do nothing destructor
};


class CTextScreenArray
{
public:
	CTextScreenArray();
	~CTextScreenArray();
	int Add(CTextScreenLine *);
	int Replace(CTextScreenLine *,int Index);
	CTextScreenLine * GetLine(int Index);	
	int GetLineCount();
		

private:
	
	CTextScreenLine * m_TextLines[MAX_LINES]; // rather than make this array dynamic
								      // I'm just making it a static "reasonable" size
	int m_LineCount;

};

#define AUDIO_TRACK_COUNT 1

class CXBoxUtility : public CXBApplication
{
public:
    
    HRESULT				Initialize();
    HRESULT				Render();
    HRESULT				FrameMove();
	CXBFont				m_Font16;
	XBOX_REFURB_INFO	m_RefurbInfo;
	CTextScreenArray	m_ThisScreen;

	UINT				m_GamePadLineIndex;

	bool				m_fAudioOK;
	bool				m_fPlaying;
	CTextScreenLine *	m_pAudioLine;
	UINT				m_AudioLineIndex;
	UINT				m_iPlayIndex;
	DWORD				m_AudioStartTicks;
	CXBSound			m_LeftSound;
	CXBSound			m_RightSound;
	CXBSound			m_StereoSound;


	CXBoxUtility();
	~CXBoxUtility() {;};

};

#endif //!defined (__SCREENTEST_H_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\unlock\main.cpp ===
#include <ntos.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#define XFONT_TRUETYPE
#include <xfont.h>
#include "cryptkeys.h"
#include "xboxvideo.h"
#include "xboxverp.h"

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif



#define RC4_CONFOUNDER_LEN 8

BOOL HDDisablePassword( BYTE* password, DWORD dwLen );

HRESULT UnlockHardDrive(void)
{
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    HRESULT hr;

    //
    // Compute Key to use and unlock hard drive
    //
    XcHMAC( (PUCHAR)*XboxHDKey, XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    hr = HDDisablePassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE ) ?
        S_OK : E_FAIL;

    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );

    return hr;
}

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;


static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

HRESULT SetManufacturingRegion (VOID)
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BOOL fWasEncrypted;

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
        fWasEncrypted = TRUE;
    else
        fWasEncrypted = !RtlEqualMemory(pEncryptedEEPROMData->HardDriveKey - 8,
            ZERO_KEY, 8);

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    if(fWasEncrypted) {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            return E_FAIL;
        }
    }

    //
    // Set the manufacturing region flag
    //
    pEncryptedEEPROMData->GameRegion |= XC_GAME_REGION_MANUFACTURING;


    //
    // Encrypt the encrypted part back again
    //
    if(fWasEncrypted) {
        rc4HmacEncrypt(
            (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    }

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }


    //
    // Zero out the memory
    //
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}




CXBoxVideo* g_pVideo;


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, DWORD dwColor)
{
    ASSERT(g_pVideo && pcszTextLine1);

    g_pVideo->ClearScreen(dwColor);

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }


    WCHAR szBuildString[64];
    wsprintfW(szBuildString, L"XTL Version %hs", VER_PRODUCTVERSION_STR);
    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();

}



#define MAX_RETRIES 3

//======================== The main function
void __cdecl main()
{
    HRESULT hr = E_FAIL;
    int tries = 0;

#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    //
    // Initialize our graphics.
    //
    if ((g_pVideo = new CXBoxVideo) == NULL) {

        XDBGWRN("factory", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );
    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pVideo->ShowScreen();



    //
    // Unlock the hard drive.
    //
    if (SUCCEEDED(hr)) {

        tries = 0;
        hr = E_FAIL;

        while (tries < MAX_RETRIES && FAILED (hr)) {
            tries++;
            hr = UnlockHardDrive ();
        }
    }



    if (SUCCEEDED(hr))
    {
        //
        // Reset the manufacturing bit.
        // Per manufacturing request: We will retry MAX_RETRIES times before
        // giving up as failed.
        //
        tries = 0;
        hr = E_FAIL;
        while (tries < MAX_RETRIES && FAILED (hr)) {
            tries++;
            hr = SetManufacturingRegion ();
        }
    }

    //
    // Give status. We don't assume the user reads english, or understands the terminology
    // Although there is text, the background color is the distinguishing feature.
    // RED == Unable to update EEPROM data.
    // GREEN == EEPROM update succeeded.
    //
    if ( FAILED( hr ) )
    {
        XDBGTRC("factory", "UnlockXboxHardDrive or DecryptDevKitEEPROM failed (returned %x)",hr);
        DrawMessage (L"Drive Reset", L"Failed to reset hard disk security.", COLOR_TV_RED);
    }
    else
    {
        DrawMessage (L"Drive Reset", L"Xbox hard disk successfully reset.", COLOR_DARK_GREEN);
    }

    Sleep (INFINITE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\WritePerBoxData\wpbdver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_WPBDBuildNumberD")
__declspec(selectany) unsigned short WPBDBuildNumberD[8] = { 'W' | ('P' << 8), 'B' | ('D' << 8), 'A' | ('T' << 8), 'A' | ('D' << 8),
                                        VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_WPBDBuildNumber")
__declspec(selectany) unsigned short WPBDBuildNumber[8] = { 'W' | ('P' << 8), 'B' | ('D' << 8), 'A' | ('T' << 8), 'A',
                   