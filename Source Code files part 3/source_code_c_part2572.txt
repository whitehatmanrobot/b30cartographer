rackParams->dwGroupBits;
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pMuteMgr->m_dwTrackExtrasFlags )
		{
			m_pMuteMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pMuteMgr->OnDataChanged();
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pMuteMgr->m_dwProducerOnlyFlags )
		{
			m_pMuteMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pMuteMgr->OnDataChanged();
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnShowProperties

HRESULT CMuteStrip::OnShowProperties()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	IDMUSProdFramework* pIFramework = NULL;
	IDMUSProdPropSheet* pIPropSheet = NULL;
	HRESULT hr = S_OK;
	VARIANT var;

	// Get a pointer to the Timeline
	if (m_pMuteMgr->m_pTimeline == NULL)
	{
		hr = E_FAIL;
		goto EXIT;
	}

	// Get a pointer to the Framework from the timeline
	m_pMuteMgr->m_pTimeline->GetTimelineProperty(TP_DMUSPRODFRAMEWORK, &var);
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		hr = E_FAIL;
		goto EXIT;
	}

	// Get a pointer to the property sheet
	pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE(pIFramework);
	if (pIPropSheet == NULL)
	{
		hr = E_FAIL;
		goto EXIT;
	}

	//  If the property sheet is hidden, exit
	if (pIPropSheet->IsShowing() != S_OK)
	{
		hr = S_OK;
		goto EXIT;
	}

	// If our property page is already displayed, exit
	if (m_fPropPageActive)
	{
		ASSERT(m_pPropPageMgr != NULL);
		hr = S_OK;
		goto EXIT;
	}

	// Get a reference to our property page manager
	if(m_pPropPageMgr == NULL)
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if (NULL == pPPM) {
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
			
		hr = pPPM->QueryInterface(IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr);
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if (FAILED(hr)) {
			goto EXIT;
		}
	}

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pMuteMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	RELEASE(pIPropSheet);
	RELEASE(pIFramework);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnRemoveFromPageManager

HRESULT CMuteStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_pPropPageMgr)
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnShowProperties

HRESULT CMuteStrip::OnShowProperties(IDMUSProdTimeline* pTimeline)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
	m_pMuteMgr->OnShowProperties();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::UpdateVScroll
//
// Updates the vertical scrollbar's position, range and page size.  This
// is called when the mute strip is resized, or pchannels are added
// or removed.
//
void CMuteStrip::UpdateVScroll()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CRect rect;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rect;

	VERIFY(SUCCEEDED(m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_RECT, &var)));

	CRect oldRect = m_rectVScroll;
	
	// move the vertical scroll bar to where it needs to go
	m_VScrollBar.GetClientRect(&m_rectVScroll);
	m_rectVScroll.left = rect.right - m_rectVScroll.right - /*BORDER_HORIZ_WIDTH - */c_nChannelWidth;
	m_rectVScroll.right = m_rectVScroll.left + m_rectVScroll.right;
	m_rectVScroll.top = rect.top;
	m_rectVScroll.bottom = rect.bottom;
	
	// move the scroll bar
	m_VScrollBar.MoveWindow(&m_rectVScroll, TRUE);

	// compute the scrollbar range and pagesize
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.nMin = 0;
	si.nMax = m_arrChannels.GetSize() - (rect.Height() / c_nChannelHeight);
	if (si.nMax < 1) {
		// disable the scrollbar
		m_VScrollBar.EnableScrollBar(ESB_DISABLE_BOTH);
		m_VScrollBar.ShowWindow(TRUE);
	}
	else {
		// enable the scrollbar
		m_VScrollBar.EnableScrollBar(ESB_ENABLE_BOTH);
		m_VScrollBar.ShowWindow(TRUE);
		// set the range
		si.fMask = SIF_RANGE;
		m_VScrollBar.SetScrollInfo(&si, TRUE);
		
		if (m_rectVScroll != oldRect)
		{
			// set the new page size
			si.fMask = SIF_PAGE;
			si.nPage = 1;
			m_VScrollBar.SetScrollInfo(&si, TRUE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SetVScroll
//
// Set a new vertical scroll value for the mute strip.  The scrollbar and
// strip are updated accordingly.
//
void CMuteStrip::SetVScroll(long lNewValue)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	long lOldScroll = m_lVScroll;
	m_lVScroll = lNewValue;
	LimitVScroll();
	if (lOldScroll == m_lVScroll) {
		return;
	}
	VARIANT var;
	var.vt = VT_I4;
	V_I4(&var) = m_lVScroll * c_nChannelHeight;
	m_pMuteMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var);

	m_VScrollBar.SetScrollPos(m_lVScroll);
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::LimitVScroll
//
// Limits the Y scroll value to be within acceptable range.
//
void CMuteStrip::LimitVScroll() 
{
	CRect rect;
	m_VScrollBar.GetClientRect(&rect);
	long lMax = max( 0, m_arrChannels.GetSize() - rect.Height() / c_nChannelHeight );

	if (m_lVScroll < 0) {
		m_lVScroll = 0;
	}
	else if (m_lVScroll > lMax) {
		m_lVScroll = lMax;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnVScroll
//
// Called by the vertical scrollbar when the user scrolls.
//
void CMuteStrip::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CRect rect;
	m_VScrollBar.GetClientRect(&rect);
	long lNewPos;
	switch(nSBCode)
	{
	case SB_TOP:
		lNewPos = 0;
		break;
	case SB_LINEDOWN:
		lNewPos = m_lVScroll + 1;
		break;
	case SB_LINEUP:
		lNewPos = m_lVScroll - 1;
		break;
	case SB_PAGEDOWN:
		lNewPos = m_lVScroll + (rect.Height() / c_nChannelHeight);
		break;
	case SB_PAGEUP:
		lNewPos = m_lVScroll - (rect.Height() / c_nChannelHeight);
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		lNewPos = nPos;
		break;
	case SB_BOTTOM:
		lNewPos = m_arrChannels.GetSize() - (rect.Height() / c_nChannelHeight);
		break;
	case SB_ENDSCROLL:
	default:
		return;
	}

	SetVScroll(lNewPos);
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnVScroll
//
// Windows message handler for vertical scrolling.
//
HRESULT CMuteStrip::OnVScroll(WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// update position of scrollbar
	UpdateVScroll();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnSize
//
// Message handler for strip resizing.
//
HRESULT CMuteStrip::OnSize(WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// update position of scrollbar
	UpdateVScroll();
	// make sure current scroll position is within range (since size was changed)
	SetVScroll(m_lVScroll);
	//m_pMuteMgr->OnDataChanged();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetMyWindow
//
// Retrieves the handle of the window which this strip is in.
//
HWND CMuteStrip::GetMyWindow()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	IOleWindow* pIOleWindow;
	m_pMuteMgr->m_pTimeline->QueryInterface(IID_IOleWindow, (void**)&pIOleWindow);
	ASSERT(pIOleWindow);
	
	HWND hWnd;

	VERIFY(pIOleWindow->GetWindow(&hWnd) == S_OK);
	pIOleWindow->Release();
	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::UpdateStateData
//
// Update design state data structure (m_StateData).
//
void CMuteStrip::UpdateStateData()
{
	// fill the structure with data
	if( m_pMuteMgr->m_pTimeline )
	{
		VARIANT var;
		m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var);
		m_StateData.m_lVScroll = m_lVScroll;
		m_StateData.m_lHeight = V_I4(&var);
		m_StateData.m_svView = m_svView;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::ApplyStateData
//
// Applies design state data previously loaded from a design time stream
// (by SaveStateData)
//
void CMuteStrip::ApplyStateData()
{
	// get data from the structure.
	if (!m_fLoadedStateData) return;
	VARIANT var;
	var.vt = VT_I4;
	V_I4(&var) = m_StateData.m_lHeight;
	m_pMuteMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, var);
	m_svView = m_StateData.m_svView;
	V_I4(&var) = m_svView;
	m_pMuteMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_STRIPVIEW, var);
	SetVScroll(m_StateData.m_lVScroll);


}



/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::IsBeyondMaxTime
//
// Returns true iff the given measurebeat is beyond the maximum time in the
// timeline.
//
bool CMuteStrip::IsBeyondMaxTime(long lMeasure, long lBeat) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	MUSIC_TIME mtTime = m_pMuteMgr->GetMusicTime(lMeasure, lBeat);
	VARIANT var;
	VERIFY(SUCCEEDED(m_pMuteMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var)));
	MUSIC_TIME mtMax = V_I4(&var);
	return (mtTime >= mtMax);	
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SnapTimes
//
// Returns the result of the given start and end times, fully
// including beats that they touch.
// The resulting mtBeginResult == mtEndResult if mtStart == mtEnd
//
void CMuteStrip::SnapTimes(MUSIC_TIME mtBegin, MUSIC_TIME mtEnd, 
						   MUSIC_TIME &mtBeginResult, MUSIC_TIME &mtEndResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pMuteMgr);

	mtBeginResult = mtBegin;
	mtEndResult = mtEnd;
	
	// swap if necessary
	if (mtBeginResult > mtEndResult) {
		MUSIC_TIME mtTemp = mtEndResult;
		mtEndResult = mtBeginResult;
		mtBeginResult = mtTemp;
	}

	// calc real begin and end times (fully include beats)
	long lMeasure, lBeat;
	m_pMuteMgr->GetMeasureBeat(mtBeginResult, lMeasure, lBeat);
	mtBeginResult = m_pMuteMgr->GetMusicTime(lMeasure, lBeat);
	if (mtBegin == mtEnd) {
		mtEndResult = mtBeginResult;
	}
	else {
		m_pMuteMgr->GetMeasureBeat(mtEndResult-1, lMeasure, lBeat);
		lBeat++;
		m_pMuteMgr->NormalizeMeasureBeat(lMeasure, lBeat);
		mtEndResult = m_pMuteMgr->GetMusicTime(lMeasure, lBeat);
		ASSERT(mtBeginResult != mtEndResult);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetSelectTimes
//
// Returns the begin and end selection times, fully
// including beats that are touched by the timeline selection area.
// The resulting mtBeginTime == mtEndTime if there is no selection.
//
void CMuteStrip::GetSelectTimes(MUSIC_TIME &mtBeginTime, MUSIC_TIME &mtEndTime) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pMuteMgr);

	if (!m_bGutterSelected) {
		mtBeginTime = -1;
		mtEndTime = -1;
	}
	else {
		SnapTimes(m_mtBeginSelect, m_mtEndSelect, mtBeginTime, mtEndTime);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnLButtonDown
//
HRESULT CMuteStrip::OnLButtonDown(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_svView != SV_NORMAL) {
		// we're minimized.
		return S_OK;
	}
	int nIdx = YPosToChannelIdx(lYPos);
	if (nIdx >= m_arrChannels.GetSize()) {
		// we are outside a pchannel
		return S_OK;
	}

	// set mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pMuteMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
	
	DWORD dwChannel = m_arrChannels[nIdx];

	long lMeasure, lBeat;
	m_pMuteMgr->m_pTimeline->PositionToMeasureBeat(m_pMuteMgr->m_dwGroupBits, 0, 
		lXPos, &lMeasure, &lBeat);
	
	if (IsBeyondMaxTime(lMeasure, lBeat)) {
		return S_OK;
	}

	if (m_pMuteMgr->IsPositionMuted(lMeasure, lBeat, dwChannel)) {
		m_EditMode = emToggleOff;
		m_pMuteMgr->TurnOffMute(lMeasure, lBeat, dwChannel);
	}
	else {
		m_EditMode = emToggleOn;
		m_pMuteMgr->TurnOnMute(lMeasure, lBeat, dwChannel);
	}
	
	// redraw the position
	InvalidatePosition(nIdx, lMeasure, lBeat);
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnMouseMove
//
HRESULT CMuteStrip::OnMouseMove(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_EditMode == emNone) {
		return S_OK;
	}

	// see if we need to start the timer for horizontal scrolling
	if( m_fLButtonDown )
	{
		// Deal with timer used for scrolling
		VARIANT var;

		// Get rectangle defining strip position
		var.vt = VT_BYREF;
		RECT rectStrip;
		V_BYREF(&var) = &rectStrip;
		if( SUCCEEDED ( m_pMuteMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
		{
			// Get cursor position
			POINT pt;
			::GetCursorPos( &pt );

			// Convert cursor position to strip coordinates
			if( SUCCEEDED ( m_pMuteMgr->m_pTimeline->ScreenToStripPosition( (IDMUSProdStrip *)this, &pt ) ) 
			&&  SUCCEEDED ( m_pMuteMgr->m_pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &pt ) ) )
			{
				if( pt.x < rectStrip.left 
				||  pt.x > rectStrip.right 
				||  pt.y < rectStrip.top 
				||  pt.y > rectStrip.bottom )
				{
					// May need to scroll, cursor is NOT in the visible portion of the strip
					if( m_nScrollTimerID == 0 )
					{
						StartScrollTimer( FIRST_SCROLL_ID );
					}
				}
				else
				{
					// No need to scroll, cursor IS in the visible portion of the strip
					if( m_nScrollTimerID )
					{
						StopScrollTimer();
					}
				}
			}
		}
	}

	// figure out maximum Y (used in mouse move).
	VARIANT var;
	m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var);
	long lMinY = m_lVScroll * c_nChannelHeight;
	long lMaxY = V_I4(&var) + lMinY - 2;

	// don't do anything if the mouse moves to a beat that isnt visible.
	if (lYPos < lMinY || lYPos > lMaxY) {
		return S_OK;
	}

	int nIdx = YPosToChannelIdx(lYPos);
	if (nIdx >= m_arrChannels.GetSize() || nIdx < 0) {
		// we are outside a pchannel
		return S_OK;
	}
	DWORD dwChannel = m_arrChannels[nIdx];

	long lMeasure, lBeat;
	m_pMuteMgr->m_pTimeline->PositionToMeasureBeat(m_pMuteMgr->m_dwGroupBits, 0, 
		lXPos, &lMeasure, &lBeat);
	
	if( lXPos < 0
	||  IsBeyondMaxTime(lMeasure, lBeat) )
	{
		return S_OK;
	}

	ASSERT( lMeasure >= 0 );
	ASSERT( lBeat >= 0 );

	if (m_EditMode == emToggleOff) {
		m_pMuteMgr->TurnOffMute(lMeasure, lBeat, dwChannel);
	}
	else if (m_EditMode == emToggleOn) {
		m_pMuteMgr->TurnOnMute(lMeasure, lBeat, dwChannel);
	}

	if (m_EditMode != emNone) {

		// redraw the position
		InvalidatePosition(nIdx, lMeasure, lBeat);
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnLButtonUp
//
HRESULT CMuteStrip::OnLButtonUp(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_EditMode != emNone) {
		// release mouse capture
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pMuteMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);

		m_EditMode = emNone;
		m_nLastEdit = IDS_UNDO_MUTE;
		m_pMuteMgr->OnDataChanged();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnRButtonUp
//
HRESULT CMuteStrip::OnRButtonUp(WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// remember where the user clicked
	m_pMuteMgr->m_pTimeline->PositionToMeasureBeat(m_pMuteMgr->m_dwGroupBits, 0,
		lXPos, &m_lClickedMeasure, &m_lClickedBeat);
	m_nClickedIdx = YPosToChannelIdx(lYPos);

	CMenu menu;
	menu.LoadMenu(IDM_MUTESTRIP_POPUP);
	CMenu* pPopupMenu = menu.GetSubMenu(0);
	ASSERT(pPopupMenu != NULL);

	if (m_nClickedIdx >= 0 && m_nClickedIdx < m_arrChannels.GetSize() && m_svView == SV_NORMAL) {
		// prepare the menu items
		CString strFormat;
		CString str;
		
		DWORD dwChan = m_arrChannels[m_nClickedIdx]+1;

		// cut, copy, paste, select all, delete
		pPopupMenu->EnableMenuItem( ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
		pPopupMenu->EnableMenuItem( ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
		pPopupMenu->EnableMenuItem( 4, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
					MF_GRAYED | MF_BYPOSITION );
		pPopupMenu->EnableMenuItem( ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
		pPopupMenu->EnableMenuItem( ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );

		// mute pchan item
		pPopupMenu->GetMenuString(CM_MUTEALL, strFormat, MF_BYCOMMAND);
		str.Format(strFormat, dwChan);
		pPopupMenu->ModifyMenu(CM_MUTEALL, MF_BYCOMMAND | MF_STRING, CM_MUTEALL, str);

		// unmute pchan item
		pPopupMenu->GetMenuString(CM_UNMUTEALL, strFormat, MF_BYCOMMAND);
		str.Format(strFormat, dwChan);
		pPopupMenu->ModifyMenu(CM_UNMUTEALL, MF_BYCOMMAND | MF_STRING, CM_UNMUTEALL, str);

		// clear pchan item
		pPopupMenu->GetMenuString(CM_CLEARALL, strFormat, MF_BYCOMMAND);
		str.Format(strFormat, dwChan);
		pPopupMenu->ModifyMenu(CM_CLEARALL, MF_BYCOMMAND | MF_STRING, CM_CLEARALL, str);

		CMuteItem* pItem = m_pMuteMgr->GetItemAtPosition(m_lClickedMeasure, m_lClickedBeat, m_arrChannels[m_nClickedIdx]);
		
		// if no remap item at clicked measurebeat, disable clear remap menu item
		if (pItem == NULL || !pItem->IsRemap()) {
			pPopupMenu->EnableMenuItem(CM_UNREMAP, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		}
		
		// if a mute exists, disable remap menu item.
		if (pItem != NULL && pItem->IsMute()) {
			pPopupMenu->EnableMenuItem(CM_REMAP, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		}

	}
	else {
		// load menu strings that don't have channel number (%d's)
		CString str;
		
		// mute pchan item
		str.LoadString(IDS_MUTEPCHANNEL);
		pPopupMenu->ModifyMenu(CM_MUTEALL, MF_BYCOMMAND | MF_STRING, CM_MUTEALL, str);

		// unmute pchan item
		str.LoadString(IDS_UNMUTEPCHANNEL);
		pPopupMenu->ModifyMenu(CM_UNMUTEALL, MF_BYCOMMAND | MF_STRING, CM_UNMUTEALL, str);

		// clear pchan item
		str.LoadString(IDS_CLEARPCHANNEL);
		pPopupMenu->ModifyMenu(CM_CLEARALL, MF_BYCOMMAND | MF_STRING, CM_CLEARALL, str);

		// disable some items since no pchannel is clicked.
		pPopupMenu->EnableMenuItem(CM_REMAP, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		pPopupMenu->EnableMenuItem(CM_UNREMAP, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		pPopupMenu->EnableMenuItem(CM_MUTEALL, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		pPopupMenu->EnableMenuItem(CM_UNMUTEALL, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
		pPopupMenu->EnableMenuItem(CM_CLEARALL, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
	}

	// bring up the menu
	POINT pt;
	if (GetCursorPos(&pt )) {
		m_pMuteMgr->m_pTimeline->TrackPopupMenu(pPopupMenu->GetSafeHmenu(),
			pt.x, pt.y, (IDMUSProdStrip*)this, NULL);
	}
	
	menu.DestroyMenu();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::DoAddRemoveDlg
//
//  Bring up the add/remove channels dialog and add/remove the channels if the
//  user clicks OK.
//
void CMuteStrip::DoAddRemoveDlg()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Initialize the add PChannel dialog
	CDlgAddPChannel dlgAddPChannel;

	// Set the PChannelName pointer
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( m_pMuteMgr->m_pDMProdFramework->FindProject( m_pMuteMgr->m_pDMProdSegmentNode, &pIProject ) ) )
	{
		pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&dlgAddPChannel.m_pIPChannelName );
		RELEASE( pIProject );
	}

	// Set up the array of PChannels we're editing
	dlgAddPChannel.m_adwPChannels.RemoveAll();
	for( int idx = 0 ;  idx < m_arrChannels.GetSize() ;  idx++ )
	{
		dlgAddPChannel.m_adwPChannels.Add( m_arrChannels[idx] );
	}

	if( dlgAddPChannel.DoModal() == IDOK )
	{
		// figure out which channels were removed, if any
		CArray<DWORD, DWORD> arrRemoved;
		int idx1 = 0;
		int idx2 = 0;
		while( idx1 < m_arrChannels.GetSize() )
		{
			DWORD ch1, ch2;
			ch1 = m_arrChannels[idx1];
			if( idx2 == dlgAddPChannel.m_adwPChannels.GetSize()
			||  ch1 < (ch2 = dlgAddPChannel.m_adwPChannels[idx2]) )
			{
				// ch1 was removed
				arrRemoved.Add(ch1);
				idx1++;
			}
			else if (ch1 > ch2)
			{
				// ch2 was added
				idx2++;
			}
			else if (ch1 == ch2)
			{
				// ch1 is still there
				idx1++;
				idx2++;
			}
		}

		// remove data on removed channels
		for (int i = 0; i < arrRemoved.GetSize(); i++) 
			m_pMuteMgr->RemoveChannelData(arrRemoved[i]);
		
		// set the array of channels to what the user selected
		// and repaint the strip.
		m_arrChannels.RemoveAll();
		for( int idx = 0 ;  idx < dlgAddPChannel.m_adwPChannels.GetSize() ;  idx++ )
		{
			m_arrChannels.Add( dlgAddPChannel.m_adwPChannels[idx] );
		}
		m_arrChannels.FreeExtra();
		m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
		
		if( arrRemoved.GetSize() > 0 )
		{
			// reduce the strip height if it is too large
			VARIANT var;
			m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var);
			long lHeight = V_I4(&var);
			if( m_arrChannels.GetSize() * c_nChannelHeight < lHeight )
			{
				var.vt = VT_I4;
				V_I4(&var) = max(c_nMinHeight, m_arrChannels.GetSize() * c_nChannelHeight);
				m_pMuteMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, var);
				UpdateVScroll();
				SetVScroll(m_lVScroll);
			}
		}

		// update dmusic data if channels were removed
		m_nLastEdit = IDS_UNDO_ADD_REMOVE_PCHANNEL;
		m_pMuteMgr->OnDataChanged();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::DoRemapDlg
//
// Bring up the remap pchannel dialog and do the remapping if the user
// clicks OK.
//
void CMuteStrip::DoRemapDlg()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_nClickedIdx < 0 || m_nClickedIdx >= m_arrChannels.GetSize()) {
		// we are outside a pchannel
		return;
	}

	// Get the IDMUSProdPChannelName interface pointer
	IDMUSProdPChannelName* pIPChannelName = NULL;
	if( m_pMuteMgr
	&&  m_pMuteMgr->m_pDMProdFramework 
	&&  m_pMuteMgr->m_pDMProdSegmentNode )
	{
		IDMUSProdProject* pIProject;
		if( SUCCEEDED ( m_pMuteMgr->m_pDMProdFramework->FindProject(m_pMuteMgr->m_pDMProdSegmentNode, &pIProject) ) )
		{
			if( FAILED ( pIProject->QueryInterface(IID_IDMUSProdPChannelName, (void**)&pIPChannelName) ) )
			{
				pIPChannelName = NULL;
			}
			pIProject->Release();
		}
	}

	// init the dialog
	CRemapDlg dlg;
	dlg.m_pIPChannelName = pIPChannelName;
	dlg.m_dwPChannel = m_arrChannels[m_nClickedIdx];
	dlg.m_lMeasure = m_lClickedMeasure;
	dlg.m_lBeat = m_lClickedBeat;
	if (dlg.DoModal() == IDOK) {
		// do the remap
		if( dlg.m_dwPChannel == dlg.m_dwPChannelMap )
		{
			m_pMuteMgr->ClearRemap(m_lClickedMeasure, m_lClickedBeat, dlg.m_dwPChannel);
		}
		else
		{
			m_pMuteMgr->RemapPChannel(m_lClickedMeasure, m_lClickedBeat, dlg.m_dwPChannel, dlg.m_dwPChannelMap);
		}

		// repaint the strip
		m_pMuteMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip*)this, NULL, true);
	
		// sync with dmusic
		if( dlg.m_dwPChannel == dlg.m_dwPChannelMap )
		{
			m_nLastEdit = IDS_UNDO_CLEAR_REMAP;
		}
		else
		{
			m_nLastEdit = IDS_UNDO_REMAP_PCHANNEL;
		}
		m_pMuteMgr->OnDataChanged();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SaveStateData
//
// Save design time state data for this mute strip.
//
HRESULT CMuteStrip::SaveStateData(IDMUSProdRIFFStream* pIRiffStream)
{
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	int i;
	DWORD dwNumChannels, dwChan;

	UpdateStateData();

    // prepare stream
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}
	
	// create the UI chunk.
	ck.ckid = DMUS_FOURCC_MUTE_UI_CHUNK;
	if (pIRiffStream->CreateChunk(&ck, 0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// write the data
	hr = pIStream->Write(&m_StateData, sizeof(m_StateData), &dwBytesWritten);
	if (FAILED(hr)
	||  dwBytesWritten != sizeof(m_StateData)) 
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// write the channel data
	dwNumChannels = m_arrChannels.GetSize();
	hr = pIStream->Write(&dwNumChannels, sizeof(dwNumChannels), &dwBytesWritten);
	if (FAILED(hr)
	||  dwBytesWritten != sizeof(dwNumChannels)) 
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	for (i = 0; i < (int)dwNumChannels; i++) {
		dwChan = m_arrChannels[i];
		hr = pIStream->Write(&dwChan, sizeof(dwChan), &dwBytesWritten);
		if (FAILED(hr)
		||  dwBytesWritten != sizeof(dwChan)) 
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// finish the chunk
	if (pIRiffStream->Ascend(&ck, 0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::MergeStateData
//
// Reads design time data from the given stream and adds the channels that
// aren't already being shown by the strip.
//
HRESULT CMuteStrip::MergeStateData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pck)
{
	HRESULT hr = S_OK;
	MMCKINFO ck = *pck;
	DWORD dwSize;
	DWORD dwByteCount;
	int i;
	DWORD dwNumChannels, dwChan;
	ioMuteStripDesign stateData; // for reading purposes; the data is actually ignored

    // prepare stream
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}
	
	dwSize = min(ck.cksize, sizeof(stateData));
	hr = pIStream->Read(&stateData, dwSize, &dwByteCount);
	if (FAILED(hr)
	||  dwByteCount != dwSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	// read the channel data
	hr = pIStream->Read(&dwNumChannels, sizeof(dwNumChannels), &dwByteCount);
	if (FAILED(hr)
	||  dwByteCount != sizeof(DWORD))
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	// add the channels that aren't already being displayed.
	{
		int idx = 0;
		for (i = 0; i < (int)dwNumChannels; i++) {
			hr = pIStream->Read(&dwChan, sizeof(dwChan), &dwByteCount);
			if (FAILED(hr)
			||  dwByteCount != sizeof(dwChan)) 
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
			while (idx < m_arrChannels.GetSize() && m_arrChannels[idx] < dwChan) 
				idx++;
			if (idx == m_arrChannels.GetSize() || m_arrChannels[idx] != dwChan) {
				m_arrChannels.InsertAt(idx, dwChan);
			}
		}
	}
	
	if (pIRiffStream->Ascend(&ck, 0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
ON_ERROR:
	pIStream->Release();
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::SyncStateData
//
// Called from CMuteMgr::Load when design time state data for this mute strip
// was not loaded (runtime file was loaded).
// Must make sure m_arrChannels matches actual mute data.
//
void CMuteStrip::SyncStateData(void)
{
	// Set PChannel array
	if( m_pMuteMgr->m_lstMutes.IsEmpty() == FALSE )
	{
		DWORD dwLastPChannel = -1;
		DWORD dwPChannel;
		int idx;

		// Initialize PChannel array
		m_arrChannels.RemoveAll();

		// Fill PChannel array
		POSITION pos = m_pMuteMgr->m_lstMutes.GetHeadPosition();
		while( pos )
		{
			CMuteItem* pItem = m_pMuteMgr->m_lstMutes.GetNext( pos );

			dwPChannel = pItem->GetPChannel();
			if( dwPChannel != dwLastPChannel )
			{
				idx = 0;
				while( idx < m_arrChannels.GetSize()  &&  m_arrChannels[idx] < dwPChannel )
				{
					idx++;
				}
				if( idx == m_arrChannels.GetSize()  ||  m_arrChannels[idx] != dwPChannel )
				{
					m_arrChannels.InsertAt( idx, dwPChannel );
				}

				dwLastPChannel = dwPChannel;
			}
		}
	}

	// Set StateData strip height
	m_StateData.m_lHeight = c_nDefaultHeight;
	if( (m_arrChannels.GetSize() * c_nChannelHeight) < c_nDefaultHeight )
	{
		m_StateData.m_lHeight = max( c_nMinHeight, (m_arrChannels.GetSize() * c_nChannelHeight) );
	}

	// Set StateData scroll position
	m_lVScroll = 0;
	m_StateData.m_lVScroll = m_lVScroll;

	// Set StateData strip view
	m_StateData.m_svView = m_svView;
}


/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::LoadStateData
//
// Load design time state data for this mute strip.  It isn't actually
// applied (except for channels showing), until ApplyStateData is called.
//
HRESULT CMuteStrip::LoadStateData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pck)
{
	HRESULT hr = S_OK;
	MMCKINFO ck = *pck;
	DWORD dwSize;
	DWORD dwByteCount;
	int i;
	DWORD dwNumChannels, dwChan;

    // prepare stream
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if (pIStream == NULL)
	{
		return E_INVALIDARG;
	}
	
	dwSize = min(ck.cksize, sizeof(m_StateData));
	hr = pIStream->Read(&m_StateData, dwSize, &dwByteCount);
	if (FAILED(hr)
	||  dwByteCount != dwSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	// read the channel data
	hr = pIStream->Read(&dwNumChannels, sizeof(dwNumChannels), &dwByteCount);
	if (FAILED(hr)
	||  dwByteCount != sizeof(DWORD))
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	m_arrChannels.RemoveAll();
	for (i = 0; i < (int)dwNumChannels; i++) {
		hr = pIStream->Read(&dwChan, sizeof(dwChan), &dwByteCount);
		if (FAILED(hr)
		||  dwByteCount != sizeof(dwChan)) 
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		m_arrChannels.Add(dwChan);
	}
	
	if (pIRiffStream->Ascend(&ck, 0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
ON_ERROR:
	pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::UpdateName

void CMuteStrip::UpdateName()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_pMuteMgr->m_dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	strTmp.LoadString( IDS_STRIP_NAME );

	m_strName = strText + CString(": ") + strTmp;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::StartScrollTimer

void CMuteStrip::StartScrollTimer( UINT nScrollTimerID )
{
	if( m_nScrollTimerID )
	{
		StopScrollTimer();
	}

	CWnd *pWnd = GetTimelineCWnd();
	if( pWnd )
	{
		UINT nInterval;

		switch( nScrollTimerID )
		{
			case FIRST_SCROLL_ID:
				nInterval = 350;
				break;
			case SECOND_SCROLL_ID:
				nInterval = 80;
				break;
			default:
				nInterval = 80;
				break;
		}

		m_dwTimerCount = 0;

		if( ::SetTimer( pWnd->GetSafeHwnd(), nScrollTimerID, nInterval, NULL ) )
		{
			m_nScrollTimerID = nScrollTimerID;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::StopScrollTimer

void CMuteStrip::StopScrollTimer( void )
{
	if( m_nScrollTimerID )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			::KillTimer( pWnd->GetSafeHwnd(), m_nScrollTimerID );
		}

		m_nScrollTimerID = 0;
		m_dwTimerCount = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::GetTimelineCWnd

CWnd* CMuteStrip::GetTimelineCWnd( void )
{
	CWnd* pWnd = NULL;

	// Get the DC of our Strip
	if( m_pMuteMgr->m_pTimeline )
	{
		VARIANT vt;
		vt.vt = VT_I4;

		if( SUCCEEDED ( m_pMuteMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt ) ) )
		{
			CDC cDC;
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}

	return pWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CMuteStrip::OnTimer

void CMuteStrip::OnTimer( void )
{
	if( m_nScrollTimerID == FIRST_SCROLL_ID )
	{
		StartScrollTimer( SECOND_SCROLL_ID );
	}

	// Get cursor position
	POINT pt;
	::GetCursorPos( &pt );

	// Convert to strip coordinates
	if( FAILED ( m_pMuteMgr->m_pTimeline->ScreenToStripPosition( (IDMUSProdStrip *)this, &pt ) ) )
	{
		return;
	}

	// Get current horizontal scroll position
	VARIANT var;
	long lHScroll = 0;
	if( SUCCEEDED( m_pMuteMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
	{
		lHScroll = V_I4(&var);
	}

	// Scroll left?
	if( pt.x < lHScroll 
	&&  lHScroll > 0 )
	{
		// Scroll left
		var.vt = VT_I4;
		V_I4(&var) = max( lHScroll - SCROLL_HORIZ_AMOUNT, 0 );
		m_pMuteMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

		OnMouseMove( NULL, NULL, max(lHScroll - SCROLL_HORIZ_AMOUNT, 0), pt.y );
		return;
	}

	// Scroll right?
	var.vt = VT_BYREF;
	RECT rectStrip;
	V_BYREF(&var) = &rectStrip;
	if( SUCCEEDED ( m_pMuteMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
	{
		// Compute the right side of the display
		long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

		// Compute the maximum scroll position
		m_pMuteMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lTimelineClockLength = V_I4(&var);
		long lMaxXPos;
		if( SUCCEEDED ( m_pMuteMgr->m_pTimeline->ClocksToPosition( lTimelineClockLength, &lMaxXPos ) ) )
		{
			long lMaxHScroll = lMaxXPos - (rectStrip.right - rectStrip.left);

			if( pt.x > lMaxScreenPos 
			&&  lHScroll < lMaxHScroll )
			{
				// Scroll right
				var.vt = VT_I4;
				V_I4(&var) = min( lHScroll + SCROLL_HORIZ_AMOUNT, lMaxHScroll);
				m_pMuteMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

				OnMouseMove( NULL, NULL, min(lMaxScreenPos + SCROLL_HORIZ_AMOUNT, lMaxXPos), pt.y );
				return;
			}
		}
	}

	// Vertical scrolls must go slower
	if( ++m_dwTimerCount < 3 )
	{
		return;
	}
	m_dwTimerCount = 0;

	// Get current vertical scroll position
	long lVScroll = 0;
	if( SUCCEEDED( m_pMuteMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, &var ) ) )
	{
		lVScroll = V_I4(&var);
	}

	// Scroll up?
	if( pt.y < lVScroll 
	&&  lVScroll > 0 )
	{
		// Scroll up
		long lOrigVScroll = m_lVScroll;
		SetVScroll( m_lVScroll - 1 );

		if( m_lVScroll != lOrigVScroll )
		{
			OnMouseMove( NULL, NULL, pt.x, (m_lVScroll * c_nChannelHeight) );
		}
		return;
	}
	
	// Scroll down?
	m_pMuteMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var);
	long lMinY = m_lVScroll * c_nChannelHeight;
	long lMaxY = V_I4(&var) + lMinY - 2;
	if( pt.y > lMaxY ) 
	{
		// Scroll up
		long lOrigVScroll = m_lVScroll;
		SetVScroll( m_lVScroll + 1 );

		if( m_lVScroll != lOrigVScroll )
		{
			lMinY = m_lVScroll * c_nChannelHeight;
			lMaxY = V_I4(&var) + lMinY - 2;
			OnMouseMove( NULL, NULL, pt.x, lMaxY );
		}
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\RemapDlg.cpp ===
// RemapDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MuteStripMgr.h"
#include "RemapDlg.h"
#include "MuteMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemapDlg dialog


CRemapDlg::CRemapDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRemapDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRemapDlg)
	//}}AFX_DATA_INIT
	m_pIPChannelName = NULL;
}

CRemapDlg::~CRemapDlg()
{
	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}
}


void CRemapDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemapDlg)
	DDX_Control(pDX, IDC_PCHANNEL_NAME, m_ChannelNameEdit);
	DDX_Control(pDX, IDC_PCHANNEL_EDIT, m_ChannelEdit);
	DDX_Control(pDX, IDC_PCHANNEL_SPIN, m_ChannelSpin);
	//}}AFX_DATA_MAP
}


void CRemapDlg::UpdatePChannelName( void )
{
	if( ::IsWindow(m_ChannelSpin.m_hWnd) == FALSE )
	{
		return;
	}

	long lPChannel = m_ChannelSpin.GetPos() - 1;

	// Fill the PChannel name edit box with the PChannel's name
	if( m_pIPChannelName )
	{
		WCHAR wstrName[MAX_PATH];
		if( SUCCEEDED( m_pIPChannelName->GetPChannelName( lPChannel, wstrName) ) )
		{
			m_ChannelNameEdit.SetWindowText( CString( wstrName ) );
		}
	}
}


BEGIN_MESSAGE_MAP(CRemapDlg, CDialog)
	//{{AFX_MSG_MAP(CRemapDlg)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PCHANNEL_SPIN, OnDeltaposPchannelSpin)
	ON_EN_CHANGE(IDC_PCHANNEL_EDIT, OnChangePchannelEdit)
	ON_EN_KILLFOCUS(IDC_PCHANNEL_EDIT, OnKillfocusPchannelEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemapDlg message handlers

BOOL CRemapDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// initialize the dlg strings
	CString str, strFormat;
	if( m_pIPChannelName )
	{
		WCHAR wstrName[MAX_PATH];
		if( SUCCEEDED( m_pIPChannelName->GetPChannelName(m_dwPChannel, wstrName) ) )
		{
			str = wstrName;
		}
		AfxFormatString1(strFormat, IDS_REMAP_PROMPT, str);
	}
	else
	{
		GetDlgItemText(IDC_REMAPTXT, strFormat);
	}
	str.Format(strFormat, m_dwPChannel+1);
	SetDlgItemText(IDC_REMAPTXT, str);

	GetDlgItemText(IDC_MEASUREBEATTXT, strFormat);
	str.Format(strFormat, m_lMeasure+1, m_lBeat+1);
	SetDlgItemText(IDC_MEASUREBEATTXT, str);

	int nMin = (m_dwPChannel == 0) ? 2: 1;
	m_ChannelSpin.SetRange(nMin, MAX_PCHANNEL);
	m_ChannelSpin.SetPos(nMin);

	m_ChannelEdit.SetLimitText( 3 );

	UpdatePChannelName();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRemapDlg::OnOK() 
{
	m_dwPChannelMap = m_ChannelSpin.GetPos() - 1;

	CDialog::OnOK();
}

void CRemapDlg::OnDeltaposPchannelSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	//Wrap
	DWORD dwNewPos = pNMUpDown->iPos + pNMUpDown->iDelta;
	if( dwNewPos > MAX_PCHANNEL )
	{
		dwNewPos = 1;
	}
	if( dwNewPos < 1 )
	{
		dwNewPos = MAX_PCHANNEL;
	}

	m_ChannelSpin.SetPos( dwNewPos );
	UpdatePChannelName();

	*pResult = 1;
}

void CRemapDlg::OnChangePchannelEdit() 
{
	// disable OK button if pchannel is same.
	if (m_ChannelSpin.GetSafeHwnd())
	{
		CString str;
		m_ChannelEdit.GetWindowText(str);
		if (str.IsEmpty()) {
			int lower, higher;
			m_ChannelSpin.GetRange(lower, higher);
			str.Format("%d", lower);
			m_ChannelEdit.SetWindowText(str);
			m_ChannelEdit.SetSel(0, 1);
		}
	}

	UpdatePChannelName();
}		

void CRemapDlg::OnKillfocusPchannelEdit() 
{
	if( m_ChannelSpin.GetSafeHwnd() != NULL )
	{
		long l = m_ChannelSpin.GetPos();

		if( (LOWORD(l) < 1) || (HIWORD(l) != 0) )
		{
			m_ChannelSpin.SetPos(1);
		}
	}

	UpdatePChannelName();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteStripMgr.cpp ===
// MuteStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MuteStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include <PChannelname.h>
#include "MuteStripMgr.h"
#include "MuteMgr.h"
#include <AFXCTL.H>
#include <dmusici.h>
#include <SegmentGuids.h>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MuteMgr, CMuteMgr)
END_OBJECT_MAP()

class CMuteStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMuteStripMgrApp theApp;

BOOL CMuteStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CMuteStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_MuteMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMuteTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicMuteTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_MUTESTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\MuteScrollBar.h ===
#if !defined(AFX_MUTESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_)
#define AFX_MUTESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// MuteScrollBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMuteScrollBar window

class CMuteScrollBar : public CScrollBar
{
public:
	CMuteScrollBar();
	virtual ~CMuteScrollBar();

	void SetMuteStrip(class CMuteStrip* pMuteStrip);

private:
	class CMuteStrip* m_pMuteStrip;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMuteScrollBar)
	//}}AFX_VIRTUAL


	// Generated message map functions
protected:
	//{{AFX_MSG(CMuteScrollBar)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MUTESCROLLBAR_H__BAA6C243_24E4_11D2_850F_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\RemapDlg.h ===
#if !defined(AFX_REMAPDLG_H__03599C07_22F2_11D2_850F_00A0C99F7E74__INCLUDED_)
#define AFX_REMAPDLG_H__03599C07_22F2_11D2_850F_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RemapDlg.h : header file
//

#include "resource.h"
#include <PChannelName.h>

/////////////////////////////////////////////////////////////////////////////
// CRemapDlg dialog

class CRemapDlg : public CDialog
{
// Construction
public:
	CRemapDlg(CWnd* pParent = NULL);   // standard constructor
	~CRemapDlg();		

	// these are to init the dialog
	IDMUSProdPChannelName*	m_pIPChannelName;
	DWORD	m_dwPChannel;
	long	m_lMeasure;
	long	m_lBeat;

	// the channel that the user chooses.
	DWORD	m_dwPChannelMap;

// Dialog Data
	//{{AFX_DATA(CRemapDlg)
	enum { IDD = IDD_REMAP };
	CEdit	m_ChannelNameEdit;
	CEdit	m_ChannelEdit;
	CSpinButtonCtrl	m_ChannelSpin;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdatePChannelName();

	// Generated message map functions
	//{{AFX_MSG(CRemapDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDeltaposPchannelSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangePchannelEdit();
	afx_msg void OnKillfocusPchannelEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMAPDLG_H__03599C07_22F2_11D2_850F_00A0C99F7E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MuteStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_TRACK_NAME                  101
#define IDS_EDITOR_NAME                 102
#define IDS_PROPPAGE_GROUP_BITS         103
#define IDR_MUTEMGR                     104
#define IDS_STRIP_NAME                  105
#define IDS_CHANNEL                     106
#define IDS_REMOVEWARNING               107
#define IDS_MUTEPCHANNEL                108
#define IDS_UNMUTEPCHANNEL              109
#define IDS_CLEARPCHANNEL               110
#define IDS_PCHANNELS                   111
#define IDS_ZERO_CHANNELS               112
#define IDS_UNDO_MUTE                   113
#define IDS_UNDO_PCHANNEL               114
#define IDS_UNDO_CLEAR                  115
#define IDS_UNDO_REMAP_PCHANNEL         117
#define IDS_UNDO_CLEAR_REMAP            118
#define IDS_UNDO_MUTE_PCHANNEL          119
#define IDS_UNDO_UNMUTE_PCHANNEL        120
#define IDS_UNDO_CLEAR_PCHANNEL         121
#define IDS_UNDO_ADD_REMOVE_PCHANNEL    122
#define IDS_UNDO_DELETE_MUTE_REMAP      123
#define IDS_UNDO_PASTE_MUTE_REMAP       124
#define IDS_UNDO_TRACK_GROUP            125
#define IDS_REMAP_PROMPT                126
#define IDR_EDIT_RMENU                  201
#define IDC_LIST_CHANNEL                202
#define IDC_PCHANNEL_EDIT               203
#define IDM_MUTESTRIP_POPUP             204
#define IDC_PCHANNEL_SPIN               205
#define IDC_EDIT_PCHANNEL               206
#define IDC_BUTTON_ADD                  207
#define IDC_BTN_REMOVE                  208
#define IDB_MUTE                        209
#define IDC_REMAPTXT                    210
#define IDC_SPIN_PCHANNEL               211
#define IDI_MUTE                        212
#define IDC_MEASUREBEATTXT              213
#define IDC_EDIT_PCHANNEL_NAME          214
#define IDD_REMAP                       215
#define IDC_PCHANNEL_NAME               216
#define IDD_DLG_ADD_PCHANNEL            217
#define IDC_BUTTON_ADD16                218
#define ID_VIEW_PROPERTIES              32768
#define CM_REMAP                        32769
#define CM_UNMUTEALL                    32770
#define ID_EDIT_DELETE                  32771
#define CM_MUTEALL                      32772
#define ID_EDIT_INSERT                  32772
#define CM_CLEARALL                     32773
#define CM_UNREMAP                      32774
#define CM_TRACKPROPS                   32775
#define CM_ADDREMOVE                    32776
#define CM_TEST                         32777
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         500
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\MuteStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A18560A7_1724_11D2_850D_00A0C99F7E74__INCLUDED_)
#define AFX_STDAFX_H__A18560A7_1724_11D2_850D_00A0C99F7E74__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A18560A7_1724_11D2_850D_00A0C99F7E74__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\Channel.h ===
// Channel.h: interface for the CChannel class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHANNEL_H__0D0FEB41_960E_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_CHANNEL_H__0D0FEB41_960E_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "BandEditor.h"

class CGridCtrl;

class CChannel
{
public:
	CChannel(CGridCtrl* pParent);

	// Returns falls on failure to get GDI resources
	void CChannel::Create(IDMUSProdBandPChannel* pInstrument);

	virtual ~CChannel();

	CChannel    *m_pNext;

private:
	int			m_nId;
	int			m_nPan;
	int			m_nVol;

	bool		m_bSelected;
	bool		m_bEnabled;		

	bool		m_bDrums;
	CRect       m_rcBtnArea;
	CGridCtrl*	m_pParent;

public:
	
	IDMUSProdBandPChannel*	m_pInstrument;

	const short  m_cxSize;
	const short  m_cySize;
	BOOL         m_fDepressed;
	BOOL         m_fTop;
	CPoint		 m_ptTouch;
	bool		 m_bDragButton;
	int			 m_nDraggedPan;
	int			 m_nDraggedVol;


	void Draw( CDC *pdc, const CRect& rcInvalid );
	void DrawButton(CDC* pDC, const CRect& rcInvalid, CBitmap* pBitmap, bool bDown, bool bSelected);
	void DrawDrums(CDC* pDC, bool bDown, bool bSelected);
	void DrawNumber(CDC* pDC, bool bDown);

	CPoint	GetMiddle();
	void	SetSelected(bool bSelection);
	void	SetEnabled(bool bEnable);
	bool	IsSelected();
	bool	IsEnabled();
	void	Move( CRect *prcExtent, CPoint *pptNewLoc = NULL );

	void	SetPanVol(short nPan, short nVol);
	void	Refresh();

	// Inline methods
	BOOL	HitTest( CPoint &point );
	void	GetButtonArea( CRect *prc );
	long	GetId();  
	short	GetPan();  
	short	GetVol();  
};

#endif // !defined(AFX_CHANNEL_H__0D0FEB41_960E_11D0_8C10_00A0C92E1CAC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\Channel.cpp ===
// Channel.cpp: implementation of the CChannel class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Grid.h"
#include "GridCtl.h"
#include "Channel.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#pragma optimize("", off)
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CChannel::CChannel(CGridCtrl* pParent) : m_cxSize( 25 ), m_cySize( 22 ), m_bDrums(false), 
										 m_bSelected(false), m_bDragButton(false), 
										 m_nDraggedPan(0), m_nDraggedVol(0), m_bEnabled(false)
{
	ASSERT(pParent);
	m_pParent = pParent;
}

void CChannel::Create(IDMUSProdBandPChannel* pInstrument)
{
	ASSERT(pInstrument);

	m_pInstrument = pInstrument;

	// set button identification and initial values
	pInstrument->GetPChannelNumber(&m_nId);
	pInstrument->GetPan(&m_nPan);
	pInstrument->GetVolume(&m_nVol);

	// terminate list and set initial state to up
	m_pNext = NULL;
	m_fDepressed = FALSE;
	m_fTop = FALSE;
}

CChannel::~CChannel()
{
	if(m_pInstrument)
		m_pInstrument->Release();
}

//////////////////////////////////////////////////////////////////////
// Member function implementation
//////////////////////////////////////////////////////////////////////
void CChannel::Move( CRect *prcExtent, CPoint *pptNewLoc )
{
	if( pptNewLoc )
	{
		// calculate the new pan and volume values
		m_nPan = (short) ((pptNewLoc->x * 127) / prcExtent->right);
		m_nVol = 127 - (short) ((pptNewLoc->y * 127) / prcExtent->bottom);

		m_nPan = max( 0, min( 127, m_nPan ) );
		m_nVol = max( 0, min( 127, m_nVol ) );

	}

	// set the new screen area variable
	m_rcBtnArea.left = (m_nPan * prcExtent->right) / 127 + prcExtent->left;
	m_rcBtnArea.top = ((127 - m_nVol) * prcExtent->bottom) / 127 + prcExtent->top;
	m_rcBtnArea.right = m_rcBtnArea.left + m_cxSize;
	m_rcBtnArea.bottom = m_rcBtnArea.top + m_cySize;
}


void CChannel::Draw( CDC* pDC, const CRect& rcInvalid )
{
	ASSERT(m_pInstrument);
	m_pInstrument->GetPan(&m_nPan);
	m_pInstrument->GetVolume(&m_nVol);


	// select the down look bitmap if we are being dragged
	if( m_fDepressed )  
	{
		DrawButton(pDC, rcInvalid, &(m_pParent->m_bmBtnDn), true, m_bSelected);
	}
	else  
	{
		BOOL bSelected = FALSE;
		m_pInstrument->IsSelected(&bSelected);
		if(m_bSelected)
			DrawButton(pDC, rcInvalid, &(m_pParent->m_bmMask), false, m_bSelected);
		else
			DrawButton(pDC, rcInvalid, &(m_pParent->m_bmBtnUp), false, m_bSelected);
	}

	// call draw routine for the next button
	if( m_pNext )
		m_pNext->Draw(pDC, rcInvalid);
}

void CChannel::DrawButton(CDC* pDC, const CRect& rcInvalid, CBitmap* pBitmap, bool bDown, bool bSelected)
{
	ASSERT(pDC);

	CRect rcTemp;

	if(rcTemp.IntersectRect(&rcInvalid, &m_rcBtnArea) == 0)
		return;


	if(m_pNext != NULL)
	{
		rcTemp.IntersectRect(&m_rcBtnArea, &(m_pNext->m_rcBtnArea));
		if(rcTemp == m_pNext->m_rcBtnArea)
			return;
	}

	// Create a copy of the original bitmap...we don't want to touch the original
	CBitmap bmpCopy;
	CSize size = pBitmap->GetBitmapDimension();
	bmpCopy.CreateCompatibleBitmap(pDC, (m_rcBtnArea.right - m_rcBtnArea.left), (m_rcBtnArea.bottom - m_rcBtnArea.top));

	// Create a new compatible device context
	CDC* pMemDC = new CDC;
	if(pMemDC->CreateCompatibleDC( NULL ) == 0 || pMemDC->m_hDC == NULL)
	{
		delete pMemDC;
		return;
	}
	
	CBitmap* pbmOldFromMemDC = pMemDC->SelectObject(&bmpCopy);
	CBitmap* pbmOldFromScreenDC = pDC->SelectObject(pBitmap);

	pMemDC->BitBlt( 0, 0, m_cxSize, m_cySize, pDC, 0, 0, SRCCOPY);
	pDC->SelectObject(pbmOldFromScreenDC);

	/*if(m_bDrums)
	{
		DrawDrums(pMemDC, bDown, bSelected);
		DrawNumber(pMemDC, bDown);
	}
	else*/
		DrawNumber(pMemDC, bDown);

	pDC->BitBlt( m_rcBtnArea.left, m_rcBtnArea.top, m_rcBtnArea.right,
				 m_rcBtnArea.bottom, pMemDC, 0, 0, SRCCOPY );

	//Select he old bitmap into the DC and delete the DC
	pMemDC->SelectObject(pbmOldFromMemDC);
	delete pMemDC;
}


void CChannel::DrawDrums(CDC* pDC, bool bDown, bool bSelected)
{
	ASSERT(pDC);
	DWORD dwRop = SRCCOPY;
		
	// NOTE : The Rect shifts for the down state
	CRect* pRect = new CRect( 2 + bDown, 2+ bDown, m_cxSize - 4 + bDown, m_cySize - 4 + bDown);

	// Need a new device context for the source bitmap
	CDC* pSrcDC= new CDC;
	if(pSrcDC->CreateCompatibleDC( NULL ) == 0 || pSrcDC->m_hDC == NULL)
	{
		delete pSrcDC;
		return;
	}

	// Select the drums bitmap into the DC

	CBitmap* pbmoSrc = pSrcDC->SelectObject(&(m_pParent->m_bmDrums));
	
	// Use a different raster operation if the channel is selected
	if(bSelected)
		dwRop = DSTINVERT;

	pDC->BitBlt( pRect->left, pRect->top, pRect->right, pRect->bottom, pSrcDC,	0, 0, dwRop);

	// Select the old bitmap into the DC and delete the DC
	pSrcDC->SelectObject(pbmoSrc);
	delete pSrcDC;
	delete pRect;
}


void CChannel::DrawNumber(CDC* pDC, bool bDown)
{
	ASSERT(pDC);
	TCHAR buf[8];
	
	LOGFONT lfThin;
	ZeroMemory( &lfThin, sizeof(LOGFONT));

	lfThin.lfHeight = 16; 
	lfThin.lfWidth = 5; 
	lfThin.lfWeight = 700; 
	CString sFont;
	sFont.LoadString(IDS_FONT);
	strcpy(lfThin.lfFaceName, (LPCSTR)sFont);

	CFont thinFont;
	thinFont.CreateFontIndirect(&lfThin);

	// NOTE : The Rect shifts for the down state
	CRect* pRect = new CRect( 2 + bDown, 2 + bDown, m_cxSize - 1 + bDown, m_cySize - 1 + bDown);

	// draw the channel number on the button up bitmap
	COLORREF oldColor = NULL;
	if(!m_bEnabled && !m_bSelected)
		oldColor = pDC->SetTextColor(::GetSysColor(COLOR_GRAYTEXT)/*RGB(6, 103, 102)*/);
	else if(m_bEnabled && m_bSelected)
		oldColor = pDC->SetTextColor(RGB(245, 239, 141));
	else if(!m_bEnabled && m_bSelected)
		oldColor = pDC->SetTextColor(RGB(255, 128, 128));

	_itot( m_nId + 1, buf, 10 );
	pDC->SetBkMode( TRANSPARENT );
	CFont* pOldFont = pDC->SelectObject(&thinFont);
	pDC->DrawText( buf, lstrlen( buf ), pRect, DT_CENTER | DT_VCENTER |	DT_SINGLELINE );
	
	if(pOldFont)
		pDC->SelectObject(pOldFont);

	if(oldColor)
		pDC->SetTextColor(oldColor);

	delete pRect;
}

void CChannel::SetSelected(bool bSelection)
{
	m_pInstrument->SetSelected(bSelection);
	m_bSelected = bSelection;
}

bool CChannel::IsSelected()
{
	BOOL bSelected = false;
	m_pInstrument->IsSelected(&bSelected);
    return bSelected ? true : false;
}

CPoint CChannel::GetMiddle()
{
	CPoint point(m_rcBtnArea.right - (m_rcBtnArea.right - m_rcBtnArea.left)/2, m_rcBtnArea.bottom - (m_rcBtnArea.bottom - m_rcBtnArea.top)/2);
	return point;
}
	

void CChannel::SetEnabled(bool bEnable)
{
	m_bEnabled = bEnable;
}

bool CChannel::IsEnabled()
{
	return m_bEnabled;
}

void CChannel::SetPanVol( short nPan, short nVol )  
{
	ASSERT(m_pInstrument);

	m_pInstrument->SetPan(nPan);
	m_pInstrument->SetVolume(nVol);
	m_bEnabled = true;

	m_nPan = max( 0, min( 127, nPan ) );
	m_nVol = max( 0, min( 127, nVol ) );
}

void CChannel::Refresh()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return; 

	m_pInstrument->IsEnabled((BOOL*)&m_bEnabled);
	m_pInstrument->GetPan(&m_nPan);
	m_pInstrument->GetVolume(&m_nVol);
	m_pInstrument->IsSelected((BOOL*)&m_bSelected);
}

BOOL CChannel::HitTest( CPoint &point )
{
	return m_rcBtnArea.PtInRect(point);
}

void CChannel::GetButtonArea( CRect *prc )	
{ 
	*prc = m_rcBtnArea; 
}

long CChannel::GetId()  
{ 
	return m_nId; 
}

short CChannel::GetPan()  
{ 
	return m_nPan; 
}

short CChannel::GetVol()  
{ 
	return m_nVol;
}
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\Grid.cpp ===
// Grid.cpp : Implementation of CGridApp and DLL registration.

#include "stdafx.h"
#include "Grid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CGridApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xeab0cd43, 0x9459, 0x11d0, { 0x8c, 0x10, 0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CGridApp::InitInstance - DLL initialization

BOOL CGridApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CGridApp::ExitInstance - DLL termination

int CGridApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\GridCtl.cpp ===
// GridCtl.cpp : Implementation of the CGridCtrl ActiveX Control class.

#include "stdafx.h"
#include "Grid.h"
#include "GridCtl.h"
#include "GridPpg.h"
#include "Channel.h"
#include <afxext.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma optimize("", off)

IMPLEMENT_DYNCREATE(CGridCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CGridCtrl, COleControl)
	//{{AFX_MSG_MAP(CGridCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CGridCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CGridCtrl)
	DISP_FUNCTION(CGridCtrl, "BringToFront", BringToFront, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CGridCtrl, "MoveButton", MoveButton, VT_EMPTY, VTS_I4 VTS_I2 VTS_I2)
	DISP_FUNCTION(CGridCtrl, "RemoveButton", RemoveButton, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CGridCtrl, "RemoveAllButtons", RemoveAllButtons, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CGridCtrl, "SelectButton", SelectButton, VT_EMPTY, VTS_I4 VTS_BOOL)
	DISP_FUNCTION(CGridCtrl, "SetEnabled", SetEnabled, VT_EMPTY, VTS_I4 VTS_BOOL)
	DISP_FUNCTION(CGridCtrl, "AddButton", AddButton, VT_BOOL, VTS_UNKNOWN)
	DISP_FUNCTION(CGridCtrl, "UpdateButton", UpdateButton, VT_EMPTY, VTS_I4)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CGridCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CGridCtrl, COleControl)
	//{{AFX_EVENT_MAP(CGridCtrl)
	EVENT_CUSTOM("CursorOver", FireCursorOver, VTS_I4)
	EVENT_CUSTOM("Move", FireMove, VTS_I4  VTS_I2  VTS_I2)
	EVENT_CUSTOM("Update", FireUpdate, VTS_UNKNOWN  VTS_BOOL  VTS_BOOL)
	EVENT_CUSTOM("SelectPChannel", FireSelectPChannel, VTS_I4  VTS_BOOL  VTS_BOOL)
	EVENT_CUSTOM("SaveUndoState", FireSaveUndoState, VTS_NONE)
	EVENT_CUSTOM("DisplayStatus", FireDisplayStatus, VTS_I2)
	EVENT_CUSTOM("RightClick", FireRightClick, VTS_I2  VTS_I2)
	EVENT_CUSTOM("DeleteChannel", FireDeleteChannel, VTS_NONE)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CGridCtrl, 1)
	PROPPAGEID(CGridPropPage::guid)
END_PROPPAGEIDS(CGridCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CGridCtrl, "GRID.GridCtrl.1",
	0xeab0cd46, 0x9459, 0x11d0, 0x8c, 0x10, 0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CGridCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DGrid =
		{ 0xeab0cd44, 0x9459, 0x11d0, { 0x8c, 0x10, 0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac } };
const IID BASED_CODE IID_DGridEvents =
		{ 0xeab0cd45, 0x9459, 0x11d0, { 0x8c, 0x10, 0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwGridOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;/* |
	OLEMISC_RECOMPOSEONRESIZE;*/

IMPLEMENT_OLECTLTYPE(CGridCtrl, IDS_GRID, _dwGridOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::CGridCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CGridCtrl

BOOL CGridCtrl::CGridCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_GRID,
			IDB_GRID,
			afxRegApartmentThreading,
			_dwGridOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::CGridCtrl - Constructor

CGridCtrl::CGridCtrl() : m_EBW( 2 ), m_bSized(FALSE), m_bSendUpdate(true) 
{
	InitializeIIDs(&IID_DGrid, &IID_DGridEvents);

	// initialize member variables
	m_pBtnLst = NULL;
	m_pDrag = NULL;
	m_pOver = NULL;
	m_bmGridTile.LoadBitmap( IDB_GRIDTILE );

	// load the up/down button bitmaps
	m_bmBtnUp.LoadBitmap(IDB_BTNUP);
	m_bmBtnDn.LoadBitmap(IDB_BTNDN);
	m_bmDrums.LoadBitmap(IDB_DRUMS);
	m_bmMask.LoadBitmap(IDB_MASK);

	m_fMoved = FALSE;

	CRect rect(0, 0, 8, 8);
	m_pTracker = new CRectTracker(&rect, CRectTracker::dottedLine);
}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::~CGridCtrl - Destructor

CGridCtrl::~CGridCtrl()
{
	CChannel  *pScan = m_pBtnLst;
	CChannel  *pDelete;

	while( pScan )
	{
		pDelete = pScan;
		pScan = pScan->m_pNext;
		delete pDelete;
	}
	m_bmGridTile.DeleteObject();
		
	// Destroy the button bitmaps
	m_bmBtnUp.DeleteObject();
	m_bmBtnDn.DeleteObject();
	m_bmDrums.DeleteObject();	
	m_bmMask.DeleteObject();

	if(m_pTracker)
	{
		delete m_pTracker;
		m_pTracker = NULL;
	}
}


//
//  EmbossRect()       raised = 0: sunken, width = 2
//                              1: raised, width = 2
//                              2: sunken, width = 1
//                              3: raised, width = 1
//
void CGridCtrl::EmbossRect( HDC hdc, const CRect *pRect, char raised )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int     nModeOld  = 0 ;
	HPEN    hPenOld   = 0 ;
	HPEN    hPenWhite = 0, hPenGray = 0 ;
	int     pen_width, offset ;
	CRect   Rect = *pRect;

    if( raised > 1 ) {
        pen_width = 1 ;
        offset    = 0 ;
        raised   -= 2 ;
    } else {
        pen_width = 2 ;
        offset    = 1 ;
    }

    if( (hPenWhite = CreatePen(PS_SOLID, pen_width, RGB(255,255,255)))
    &&  (hPenGray  = CreatePen(PS_SOLID, pen_width, RGB(128,128,128))) ) {
        nModeOld = SetROP2( hdc, R2_COPYPEN ) ;

        if( pen_width == 2 ) {
            Rect.InflateRect( -1, -1 ) ;
        } else {
            Rect.right-- ;
            Rect.bottom-- ;
        }

        if( raised )
            hPenOld = (HPEN) SelectObject( hdc, hPenWhite ) ;
        else
            hPenOld = (HPEN) SelectObject( hdc, hPenGray ) ;
        MoveToEx( hdc, Rect.left, Rect.bottom, NULL ) ;
        LineTo( hdc, Rect.left, Rect.top ) ;
        LineTo( hdc, Rect.right, Rect.top ) ;

        if( raised )
            SelectObject( hdc, hPenGray ) ;
        else
            SelectObject( hdc, hPenWhite ) ;
        MoveToEx( hdc, Rect.right, Rect.top+offset, NULL ) ;
        LineTo( hdc, Rect.right, Rect.bottom ) ;
        LineTo( hdc, Rect.left+offset, Rect.bottom ) ;

        if( pen_width == 2 ) 
            Rect.InflateRect( 1, 1 ) ;

        if( raised ) {
            SetPixel( hdc, Rect.right-offset, Rect.top, RGB(128,128,128) ) ;
            SetPixel( hdc, Rect.left, Rect.bottom-offset, RGB(128,128,128) ) ;
        } else {
            SetPixel( hdc, Rect.right-offset, Rect.top, RGB(255,255,255) ) ;
            SetPixel( hdc, Rect.left, Rect.bottom-offset, RGB(255,255,255) ) ;
        }

        if( pen_width == 1 ) { 
            Rect.right++ ;
            Rect.bottom++ ;
        }
    }

    if( nModeOld )
        SetROP2( hdc, nModeOld ) ;
    if( hPenOld )
        SelectObject( hdc, hPenOld ) ;
    if( hPenWhite )
        DeleteObject( hPenWhite ) ;
    if( hPenGray )
        DeleteObject( hPenGray ) ;
}


CRect *CGridCtrl::GetAdjustedArea( CChannel *pc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_rcAdjusted = m_rcExtent;
	m_rcAdjusted.left = 1;//m_EBW;
	m_rcAdjusted.top = m_EBW + 1;
	m_rcAdjusted.right -= 2 * m_EBW + pc->m_cxSize;
	m_rcAdjusted.bottom -= 2 * m_EBW + pc->m_cySize;
	return &m_rcAdjusted;
}


void CGridCtrl::_BringToFront( CChannel *pc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pc == NULL )  
		return;

	if( pc->m_pNext == NULL )  
		return;

	if( pc->m_pNext != m_pDrag )  
	{
		_BringToFront( pc->m_pNext );
		return;
	}

	if( pc->m_pNext->m_pNext == NULL )  
		return;

	pc->m_pNext = SwapAdjacentNodes( pc->m_pNext, pc->m_pNext->m_pNext );
	_BringToFront( pc->m_pNext );
}


void CGridCtrl::SendToBack()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel* pScan = m_pBtnLst;
	m_pDrag->m_pNext = pScan;
	m_pBtnLst = m_pDrag;

	// then splice it before the drag button
	while( pScan )
	{
		if( pScan->m_pNext == m_pDrag )  {
			pScan->m_pNext = NULL;
		}
		pScan = pScan->m_pNext;
}	}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::OnDraw - Drawing function

void CGridCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPen     *pPenOld, *pPen;
	CBitmap  *pbmOld;
	CBitmap  *pbmFb;  // ptr to frame buffer bitmap
	CDC      *pfbdc;
	CBrush   *pbrush, *pbrushOld;
	short     nHSCntr, nVSCntr;  // horizontal/vertical snap to grid center

	// create frame buffer bitmap
	pbmFb = new CBitmap;
	m_rcExtent.left = 0;
	m_rcExtent.top = 0;

	if(m_bSized == FALSE)
	{
		m_rcExtent.right = rcBounds.Width();
		m_rcExtent.bottom = rcBounds.Height();
	}
	pbmFb->CreateCompatibleBitmap( pdc, m_rcExtent.right, m_rcExtent.bottom );

	// create memory device context for the frame buffer
	pfbdc = new CDC;
	if(pfbdc->CreateCompatibleDC( pdc ) == 0 ||pfbdc->m_hDC == NULL)
	{
		delete pfbdc;
		delete pbmFb;
		return;
	}

	pbmOld = pfbdc->SelectObject( pbmFb );

	// paint the background with a grid pattern
	pbrush = new CBrush;
	pbrush->CreatePatternBrush( &m_bmGridTile );
	pbrushOld = pfbdc->SelectObject( pbrush );
	pfbdc->PatBlt( rcInvalid.left, rcInvalid.top,
		rcInvalid.right - rcInvalid.left, rcInvalid.bottom - rcInvalid.top, PATCOPY );
	pfbdc->SelectObject( pbrushOld );
	pbrush->DeleteObject();
	delete pbrush;

	// draw an embossed border
	EmbossRect( pfbdc->m_hDC, &m_rcExtent, (char) 0 );

	// draw the cross hairs
	pPen = new CPen;
	pPen->CreatePen( PS_SOLID, 0, RGB(128, 128, 0) ) ;
    pPenOld = pfbdc->SelectObject( pPen ) ;
	nHSCntr = (m_rcExtent.Width() / 2) - ((m_rcExtent.Width() / 2) % 8);
	nVSCntr = (m_rcExtent.Height() / 2) - ((m_rcExtent.Height() / 2) % 8);
    MoveToEx( pfbdc->m_hDC, nHSCntr, 2, NULL );
    LineTo( pfbdc->m_hDC, nHSCntr, m_rcExtent.Height() - 2 );
    MoveToEx( pfbdc->m_hDC, 2, nVSCntr, NULL );
    LineTo( pfbdc->m_hDC, m_rcExtent.Width() - 2, nVSCntr );
    pfbdc->SelectObject( pPenOld );
	pPen->DeleteObject();
    delete pPen;

	// draw the buttons
	if( m_pBtnLst )  
	{
		m_pBtnLst->Draw( pfbdc, rcInvalid );
	}

	// blt the frame buffer onto the screen
	pdc->BitBlt( rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom,
		pfbdc, 0, 0, SRCCOPY );

	// cleanup and destroy the frame buffer
	pfbdc->SelectObject( pbmOld );
	pbmFb->DeleteObject();
	delete pbmFb;
	delete pfbdc;
}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::DoPropExchange - Persistence support

void CGridCtrl::DoPropExchange(CPropExchange* pPX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::OnResetState - Reset control to default state

void CGridCtrl::OnResetState()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel* pScan = m_pBtnLst;
	CChannel* pDelete;

	while( pScan )
	{
		pDelete = pScan;
		pScan = pScan->m_pNext;
		delete pDelete;
	}
	m_pBtnLst = NULL;
	m_pDrag = NULL;
	m_pOver = NULL;
	InvalidateControl( &m_rcExtent );

	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl::AboutBox - Display an "About" box to the user

void CGridCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog dlgAbout(IDD_ABOUTBOX_GRID);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CGridCtrl message handlers
BOOL CGridCtrl::AddButton(LPUNKNOWN pInstrumentItem) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pInstrumentItem);

	CChannel  *pScan, *pAppend;
	CRect      rect;

	IDMUSProdBandPChannel* pInstrument = NULL;
	if(FAILED(pInstrumentItem->QueryInterface(IID_IDMUSProdBandPChannel, (void**)&pInstrument)))
		return FALSE;

	int nID = -1;
	pInstrument->GetPChannelNumber(&nID);
	
	if(nID  < 0)  
		return FALSE;

	int nPan = 0;
	pInstrument->GetPan(&nPan);
	nPan = max( 0, min( 127, nPan ) );

	int nVolume = 0;
	pInstrument->GetVolume(&nVolume);
	nVolume = max( 0, min( 127, nVolume ) );

	if( m_pBtnLst == NULL )
	{
		// first button on the control
		m_pBtnLst = new CChannel(this);
		// We're out of memory??
		if(m_pBtnLst == NULL)
			return FALSE;
		m_pBtnLst->Create(pInstrument);
		pAppend = m_pBtnLst;
	}
	else  
	{
		// append a new button to the end of the list
		pScan = m_pBtnLst;
		while( pScan )
		{
			pAppend = pScan;
			pScan = pScan->m_pNext;
		}
		pAppend->m_pNext = new CChannel(this);
		// We're out of memory??
		if(pAppend->m_pNext == NULL)
			return FALSE;

		pAppend->m_pNext->Create(pInstrument);
		pAppend = pAppend->m_pNext;
		pAppend->Move(GetAdjustedArea(pAppend));
	}

	// position it and draw it
	if( pAppend )  
	{
		pAppend->Move( GetAdjustedArea( pAppend ) );
		pAppend->GetButtonArea( &rect );
		InvalidateControl( &rect );
		return TRUE;
	}

	return FALSE;
}

void CGridCtrl::RemoveAllButtons()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel* pScan = m_pBtnLst;

	while(pScan)
	{
		m_pBtnLst = pScan->m_pNext;
		delete pScan;
		pScan = m_pBtnLst;
	}

	InvalidateControl(NULL);
}



void  CGridCtrl::RemoveButton(long nId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel* pScan = m_pBtnLst;
	CChannel* pPrev = NULL;

	while(pScan)
	{
		if(pScan->GetId() == nId)
		{
			if(pPrev != NULL)
				pPrev->m_pNext = pScan->m_pNext; // Removed the button from the list
			else
				m_pBtnLst = pScan->m_pNext;		 // The first node matches

			delete pScan;
			pScan = NULL;
			break;
		}
		pPrev = pScan;
		pScan = pScan->m_pNext;
	}

	m_pDrag = NULL;

	InvalidateControl(NULL);
	
}

void CGridCtrl::SelectAllButtons()
{
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel*	pScan = m_pBtnLst;

	while(pScan)
	{
		SelectButton(pScan->GetId(), true);
		FireUpdate( pScan->m_pInstrument, true, true);
		pScan = pScan->m_pNext;
	}
}

void CGridCtrl::UnselectAllButtons()
{
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel*	pScan = m_pBtnLst;

	while(pScan)
	{
		pScan->SetSelected(false);
		pScan->m_fTop = FALSE;
		pScan = pScan->m_pNext;
	}
	
	FireUpdate(NULL, false, false);
}


void CGridCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel*	pScan = m_pBtnLst;
	CRect		rect;

	m_bSendUpdate = true;
	bool bTrack = true;
	bool bAnySelected = false;

	while(pScan)
	{
		if(pScan->HitTest(point) && pScan->IsSelected())
		{
			bAnySelected = true;
			bTrack = false;
			MarkButtonForMove(pScan, point);
			m_bMultiSelected = true;
			break;
		}

		pScan = pScan->m_pNext;
	}


	pScan = m_pBtnLst;
	while(pScan && !bAnySelected)
	{
		if(pScan->HitTest(point))
		{
			bTrack = false;
			bAnySelected = true;
			
			if(!(nFlags & MK_CONTROL) && pScan->IsSelected() == false)
			{
				UnselectAllButtons();
				MarkButtonForMove(pScan, point);
				m_bMultiSelected = false;
				break;
			}
			else if(pScan->IsSelected() == true)// User must have started dragging the button
			{
				MarkButtonForMove(pScan, point);
				m_bMultiSelected = true;
				break;
			}
			else if((nFlags & MK_CONTROL))
			{
				MarkButtonForMove(pScan, point);
				pScan->m_bDragButton = false;
				pScan->SetSelected(true);
				m_bMultiSelected = true;
				break;
			}
		}

		pScan = pScan->m_pNext;
	}

	// No click on any button
	if(bAnySelected == false)
	{
		ReleaseCapture();
		UnselectAllButtons();
		m_bMultiSelected = false;
	}

	if(bTrack)
	{
		m_pTracker->TrackRubberBand(this, point);
		// Test every channel button for a mouse hit
		pScan = m_pBtnLst;
		m_pDrag = NULL;
		CChannel* pFirstButton = NULL;
		while(pScan)
		{
			pScan->m_bDragButton = false;
			
			if(m_pTracker->HitTest(pScan->GetMiddle()) != CRectTracker::hitNothing)
			{
				if(pFirstButton == NULL)
					pFirstButton = pScan;

				m_bMultiSelected = true;
				pScan->SetSelected(true);
				FireUpdate( pScan->m_pInstrument, true, false);
			}
			else
				pScan->SetSelected(false);

			pScan = pScan->m_pNext;
		}
		if(pFirstButton)
			FireUpdate( pFirstButton->m_pInstrument, true, true);
	} 

	// Set the drag Distances for all selected buttons
	pScan = m_pBtnLst;
	while(m_pDrag && pScan)
	{
		bool bBroughtToFront = false;
		if(pScan->IsSelected())
		{
			pScan->GetButtonArea(&rect);
			CRect draggedButtonRect;
			m_pDrag->GetButtonArea(&draggedButtonRect);
			pScan->m_nDraggedPan = m_pDrag->GetPan() - pScan->GetPan();
			pScan->m_nDraggedVol = m_pDrag->GetVol() - pScan->GetVol();

			if(!pScan->m_fTop)
			{
				BringToFront(pScan->GetId());
				bBroughtToFront = true;
				pScan = m_pBtnLst;
			}
		}

		if(!bBroughtToFront)
			pScan= pScan->m_pNext;
	}

	// repaint the button
	InvalidateControl();

	COleControl::OnLButtonDown(nFlags, point);
}

void CGridCtrl::MarkButtonForMove(CChannel* pButton, CPoint point)
{
	pButton->SetSelected(true);
	BringToFront(pButton->GetId());
		
	CRect rect;
	pButton->GetButtonArea( &rect );

	// remember where on the button the mouse landed
	m_ptTouch = point;
	m_ptTouch.x -= rect.left;
	m_ptTouch.y -= rect.top;
	pButton->m_bDragButton = true;
	m_pDrag = pButton;
	m_fMoved = FALSE;
}

void CGridCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// No PChannels?
	if(m_pBtnLst == NULL)
	{
		return;
	}
	
	CRect  rect;
	ReleaseCapture();

	// Do a hit test for proper selection
	CChannel* pScan = m_pBtnLst;
	CChannel* pOver = NULL;

	if(!(nFlags & MK_CONTROL) && m_bMultiSelected == false)
	{
		if(pScan->HitTest(point) && pScan->IsSelected() == false)
		{
			m_pDrag = NULL;
			UnselectAllButtons();
		}
	}

	pScan = m_pBtnLst;
	while( pScan )  
	{
		if(pScan->IsSelected())
		{
			if(m_pDrag && ((nFlags & MK_CONTROL) || m_bMultiSelected == true))
			{
				FireUpdate( pScan->m_pInstrument, true, false);
			}
			else
			{
				FireUpdate( pScan->m_pInstrument, (nFlags & MK_CONTROL), true);
			}
		}
		
		pScan = pScan->m_pNext;
	}

	if(m_pDrag)
	{
		FireUpdate( m_pDrag->m_pInstrument, true, true);
		m_pDrag->m_pInstrument->SyncChanges(true);
	}

	COleControl::OnLButtonUp(nFlags, point);
}

void CGridCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	static CPoint oldPoint = CPoint(0, 0);
	if(point == oldPoint)
		return;

	oldPoint = point;

	CPoint     pt;
	CRect      rect;
	CChannel*  pScan = m_pBtnLst;
	
	static bool bSyncChannels = true;

	if(nFlags & MK_LBUTTON)
	{
		SetCapture();
		pScan = m_pBtnLst;

		// Saving the undo state should happen only once during the mouse move
		if(m_pDrag && m_bSendUpdate)
		{
			if(FAILED(m_pDrag->m_pInstrument->SyncChanges(true)))
				bSyncChannels = false;
			else
				bSyncChannels = true;

			FireSaveUndoState();
		}

		while(pScan)
		{
			if(pScan->IsSelected() == true && pScan == m_pDrag)
			{
				int nOldDragPan = pScan->GetPan();
				int nOldDragVol = pScan->GetVol();

				pt = point - m_ptTouch;
				pt.x = min( max( 0, pt.x ), m_rcExtent.right - 2 * m_EBW - pScan->m_cxSize );
				pt.y = min( max( 0, pt.y ), m_rcExtent.bottom - 2 * m_EBW - pScan->m_cySize );
				
				pScan->Move( GetAdjustedArea( pScan ), &pt );
				pScan->SetPanVol(pScan->GetPan(), pScan->GetVol());

				if(nOldDragPan != m_pDrag->GetPan() || nOldDragVol != m_pDrag->GetVol())
				{
					m_bSendUpdate = true;
					FireDisplayStatus(pScan->GetId());
				}
				else
					m_bSendUpdate = false;

				if(bSyncChannels)
					m_pDrag->m_pInstrument->SyncChanges(false);
						
				// Move all the other pchannels
				CChannel* pChannel = m_pBtnLst;
				while(pChannel)
				{
					if(pChannel->IsSelected())
					{
						int nNewPan = m_pDrag->GetPan() - pChannel->m_nDraggedPan;
						int nNewVol = m_pDrag->GetVol() - pChannel->m_nDraggedVol;

						nNewPan = max( 0, min( 127, nNewPan ) );
						nNewVol = max( 0, min( 127, nNewVol ) );

						CRect rect;

						// Move the pchannel only if it has really moved
						// This will save us some unnecessary updates
						if(nNewPan != pChannel->GetPan() || nNewVol != pChannel->GetVol())
						{
							pChannel->SetPanVol(nNewPan, nNewVol);
							pChannel->Move(GetAdjustedArea(pChannel));
						
							if(bSyncChannels)
								pChannel->m_pInstrument->SyncChanges(false);
						}
					}

					pChannel = pChannel->m_pNext;
				}
				 
				// remember that the button has been moved
				m_fMoved = TRUE;
				break;

			}
			pScan = pScan->m_pNext;
		}

		if(m_pDrag)
		{
			m_bSendUpdate = false;
		}

		InvalidateControl();
	}
}

void CGridCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_bSized == TRUE)
	{
		return;
	}
	
	m_bSized = TRUE;

	// the ClassWizard says call your parent first
	COleControl::OnSize(nType, cx, cy);

	// now save the new window size
	m_rcExtent.left = 0;
	m_rcExtent.top = 0;
	m_rcExtent.right = cx;
	m_rcExtent.bottom = cy;

	// recalculate all button positions
	CChannel* pEnum = m_pBtnLst;
	while( pEnum )
	{
		pEnum->Move( GetAdjustedArea( pEnum ) );
		pEnum = pEnum->m_pNext;
	}
	InvalidateControl( &m_rcExtent );
}


void CGridCtrl::BringToFront(long nID) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel* pScan = GetChannelByID(nID);

	if( pScan )  
	{
		pScan->m_fTop = TRUE;

		// special case for head of list
		if( m_pBtnLst == pScan  &&  m_pBtnLst->m_pNext )
		{
			m_pBtnLst = SwapAdjacentNodes( m_pBtnLst, m_pBtnLst->m_pNext );
		}

		// temporarily assign the button to be the drag button and then call
		// the private method to bring it to the front
		m_pOver = pScan;
		CChannel* pTemp = m_pDrag;
		m_pDrag = pScan;
		_BringToFront( m_pBtnLst );
		m_pDrag = pTemp;

		// repaint
		InvalidateControl( NULL );
	}	

}


void CGridCtrl::MoveButton(long nID, short nPan, short nVolume) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CChannel* pScan = GetChannelByID(nID);
	
	if(pScan)
	{
		CRect rect;
		// invalidate current area under the button
		pScan->GetButtonArea( &rect );
		InvalidateControl( &rect );

		// position it and redraw it
		//pScan->SetPanVol( nPan, nVolume );
		pScan->Move( GetAdjustedArea( pScan ) );
		pScan->GetButtonArea( &rect );
		InvalidateControl( &rect );
	}
}



BOOL CGridCtrl::OnEraseBkgnd(CDC* pDC) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return FALSE;
}




void CGridCtrl::SelectButton(long nID, BOOL bSelection) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CChannel* pScan = GetChannelByID(nID);
	
	if(pScan)
	{
		CRect  rect;
		pScan->SetSelected(bSelection ? true : false);
		pScan->GetButtonArea( &rect );
		InvalidateControl( &rect );
	}
}


CChannel* CGridCtrl::GetChannelByID(long nID)
{
	CChannel  *pScan = m_pBtnLst;
	while( pScan )
	{
		if( nID == pScan->GetId() )  
			return pScan;
		
		pScan = pScan->m_pNext;
	}

	return NULL;
}

void CGridCtrl::SetEnabled(long nID, BOOL bEnable) 
{
	CChannel* pChannel = GetChannelByID(nID);
	
	if(pChannel)
	{
		CRect  rect;
		pChannel->SetEnabled(bEnable ? true : false);
		pChannel->GetButtonArea( &rect );
		InvalidateControl( &rect );
	}
}

void CGridCtrl::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pBtnLst == NULL)
	{
		return;
	}

	CChannel*	pScan = m_pBtnLst;
	CRect		rect;

	bool bAnySelected = false;

	while(pScan)
	{
		if(pScan->HitTest(point) && pScan->IsSelected())
		{
			bAnySelected = true;
			MarkButtonForMove(pScan, point);
			m_bMultiSelected = true;
			break;
		}

		pScan = pScan->m_pNext;
	}


	pScan = m_pBtnLst;
	while(pScan)
	{
		if(pScan->HitTest(point))
		{
			bAnySelected = true;
			
			if(!(nFlags & MK_CONTROL) && pScan->IsSelected() == false)
			{
				UnselectAllButtons();
				MarkButtonForMove(pScan, point);
				m_bMultiSelected = false;
				break;
			}
			else if(pScan->IsSelected() == true)// User must have started dragging the button
			{
				MarkButtonForMove(pScan, point);
				m_bMultiSelected = true;
				break;
			}
			else if((nFlags & MK_CONTROL) && pScan->m_fTop == TRUE)
			{
				MarkButtonForMove(pScan, point);
				pScan->m_bDragButton = false;
				pScan->SetSelected(true);
				m_bMultiSelected = true;
				break;
			}
		}

		pScan = pScan->m_pNext;
	}

	// No click on any button
	if(bAnySelected == false)
	{
		UnselectAllButtons();
		m_bMultiSelected = false;
	}

	// special case for head of list
	if(m_pBtnLst->IsSelected() == true && m_pBtnLst == m_pDrag &&  m_pBtnLst->m_pNext )  
	{
		m_pBtnLst = SwapAdjacentNodes( m_pBtnLst, m_pBtnLst->m_pNext );
	}

	_BringToFront( m_pBtnLst );	

	InvalidateControl();
	
	COleControl::OnRButtonDown(nFlags, point);
}

void CGridCtrl::OnRButtonUp(UINT nFlags, CPoint point) 
{
	OnLButtonUp(nFlags, point);
}

void CGridCtrl::UpdateButton(long nPChannel) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CChannel* pScan = GetChannelByID(nPChannel);
	if(pScan)
	{
		pScan->Refresh();
		MoveButton(nPChannel, pScan->GetPan(),pScan->GetVol());
	}
}

CChannel* CGridCtrl::SwapAdjacentNodes( CChannel *pParent, CChannel *pChild )
{
	pParent->m_pNext = pChild->m_pNext;
	pChild->m_pNext = pParent;
	return pChild;
}

#pragma optimize("", on)

void CGridCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// Adjust the volume and pan values
	switch(nChar)
	{
		case VK_UP: 
		{
			if(nRepCnt > 1)
			{
				break;
			}

			StepVolume(true);
			InvalidateControl();
			break;
		}

		case VK_DOWN:
		{
			if(nRepCnt > 1)
			{
				break;
			}

			StepVolume(false);
			InvalidateControl();
			break;
		}
		case VK_LEFT:
		{
			if(nRepCnt > 1)
			{
				break;
			}

			StepPan(false);
			InvalidateControl();
			break;
		}
		case VK_RIGHT:
		{
			if(nRepCnt > 1)
			{
				break;
			}

			StepPan(true);
			InvalidateControl();
			break;
		}

		case 'a':
		case 'A':
		{
			if(nFlags & VK_CONTROL) 
			{
				SelectAllButtons();
			}
			break;
		}

		case VK_DELETE:
		{
			FireDeleteChannel();
			break;
		}

		default:
		{
			break;
		}
	}
	
	COleControl::OnKeyDown(nChar, nRepCnt, nFlags);
}


void CGridCtrl::StepVolume(bool bStepUp)
{
	// Check if any buttons are selectd
	if(AreAnyChannelsSelected() == false)
	{
		return;
	}

	// Save the undo state
	FireSaveUndoState();

	int nIncrement = bStepUp ? 1 : -1;

	CChannel* pScan = m_pBtnLst;
	while(pScan)  
	{
		if(pScan->IsSelected())
		{
			int nOldVol = pScan->GetVol();
			int nPan = pScan->GetPan();
			int nNewVol = nOldVol + nIncrement;

			if(nNewVol >=0 && nNewVol <= 127)
			{
				pScan->SetEnabled(true);
				pScan->SetPanVol(nPan, nNewVol);
				long lId = pScan->GetId();
				MoveButton(lId, pScan->GetPan(),pScan->GetVol());
				
				CRect rect;				
				pScan->GetButtonArea( &rect );
				InvalidateControl( &rect );

				FireMove(lId, nPan, nNewVol);
				FireUpdate( pScan->m_pInstrument, true, false);
			}
		}
		
		pScan = pScan->m_pNext;
	}
}

void CGridCtrl::StepPan(bool bStepRight)
{
	// Check if any buttons are selectd
	if(AreAnyChannelsSelected() == false)
	{
		return;
	}

	// Save the undo state
	FireSaveUndoState();

	int nIncrement = bStepRight ? 1 : -1;

	CChannel* pScan = m_pBtnLst;
	while(pScan)  
	{
		if(pScan->IsSelected())
		{
			int nVol = pScan->GetVol();
			int nOldPan = pScan->GetPan();
			int nNewPan = nOldPan + nIncrement;

			if(nNewPan >=0 && nNewPan <= 127)
			{
				pScan->SetEnabled(true);
				pScan->SetPanVol(nNewPan, nVol);
				long lId = pScan->GetId();
				MoveButton(lId, pScan->GetPan(),pScan->GetVol());
				CRect rect;				
				pScan->GetButtonArea( &rect );
				InvalidateControl( &rect );
				FireMove(lId, nNewPan, nVol);
				FireUpdate( pScan->m_pInstrument, true, false);
			}
		}
		
		pScan = pScan->m_pNext;
	}
}


bool CGridCtrl::AreAnyChannelsSelected()
{
	CChannel* pScan = m_pBtnLst;
	while(pScan)  
	{
		if(pScan->IsSelected())
		{
			return true;
		}

		pScan = pScan->m_pNext;
	}

	return false;
}


void CGridCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// Adjust the volume and pan values
	switch(nChar)
	{
		case VK_UP: 
		case VK_DOWN:
		case VK_LEFT:
		case VK_RIGHT:
		{
			if(nRepCnt > 1)
			{
				break;
			}
			CChannel* pScan = m_pBtnLst;
			while(pScan)  
			{
				if(pScan->IsSelected())
				{
					FireUpdate(pScan->m_pInstrument, true, true);
					pScan->m_pInstrument->SyncChanges(true);
				}

				pScan = pScan->m_pNext;
			}

			break;
		}

	}
	
	
	COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
}

void CGridCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	FireRightClick(point.x, point.y);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\Grid.h ===
#if !defined(AFX_GRID_H__EAB0CD4B_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_GRID_H__EAB0CD4B_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Grid.h : main header file for GRID.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CGridApp : See Grid.cpp for implementation.

class CGridApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRID_H__EAB0CD4B_9459_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\GridPpg.cpp ===
// GridPpg.cpp : Implementation of the CGridPropPage property page class.

#include "stdafx.h"
#include "Grid.h"
#include "GridPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CGridPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CGridPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CGridPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CGridPropPage, "GRID.GridPropPage.1",
	0xeab0cd47, 0x9459, 0x11d0, 0x8c, 0x10, 0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac)


/////////////////////////////////////////////////////////////////////////////
// CGridPropPage::CGridPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CGridPropPage

BOOL CGridPropPage::CGridPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_GRID_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CGridPropPage::CGridPropPage - Constructor

CGridPropPage::CGridPropPage() :
	COlePropertyPage(IDD, IDS_GRID_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CGridPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CGridPropPage::DoDataExchange - Moves data between page and properties

void CGridPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CGridPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CGridPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\GridCtl.h ===
#if !defined(AFX_GRIDCTL_H__EAB0CD53_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_GRIDCTL_H__EAB0CD53_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GridCtl.h : Declaration of the CGridCtrl ActiveX Control class.

#include "BandEditor.h"
#include "Channel.h"

/////////////////////////////////////////////////////////////////////////////
// CGridCtrl : See GridCtl.cpp for implementation.

class CGridCtrl : public COleControl
{
	DECLARE_DYNCREATE(CGridCtrl)

// Constructor
public:
	CGridCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CGridCtrl();

	DECLARE_OLECREATE_EX(CGridCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CGridCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CGridCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CGridCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CGridCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CGridCtrl)
	afx_msg void BringToFront(long nId);
	afx_msg void MoveButton(long nId, short nPan, short nVolume);
	afx_msg void RemoveButton(long nId);
	afx_msg void RemoveAllButtons();
	afx_msg void SelectButton(long nId, BOOL bSelection);
	afx_msg void SetEnabled(long nID, BOOL bEnable);
	afx_msg BOOL AddButton(LPUNKNOWN pInstrumentItem);
	afx_msg void UpdateButton(long nPChannel);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CGridCtrl)
	void FireCursorOver(long nId)
		{FireEvent(eventidCursorOver,EVENT_PARAM(VTS_I4), nId);}
	void FireMove(long nId, short nPan, short nVolume)
		{FireEvent(eventidMove,EVENT_PARAM(VTS_I4  VTS_I2  VTS_I2), nId, nPan, nVolume);}
	void FireUpdate(LPUNKNOWN pInstrument, BOOL bCTRLDown, BOOL bRefreshUI)
		{FireEvent(eventidUpdate,EVENT_PARAM(VTS_UNKNOWN  VTS_BOOL  VTS_BOOL), pInstrument, bCTRLDown, bRefreshUI);}
	void FireSelectPChannel(long nId, BOOL bSelection, BOOL bCtrlDown)
		{FireEvent(eventidSelectPChannel,EVENT_PARAM(VTS_I4  VTS_BOOL  VTS_BOOL), nId, bSelection, bCtrlDown);}
	void FireSaveUndoState()
		{FireEvent(eventidSaveUndoState,EVENT_PARAM(VTS_NONE));}
	void FireDisplayStatus(short nID)
		{FireEvent(eventidDisplayStatus,EVENT_PARAM(VTS_I2), nID);}
	void FireRightClick(short nX, short nY)
		{FireEvent(eventidRightClick,EVENT_PARAM(VTS_I2  VTS_I2), nX, nY);}
	void FireDeleteChannel()
		{FireEvent(eventidDeleteChannel,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CGridCtrl)
	dispidBringToFront = 1L,
	dispidMoveButton = 2L,
	dispidRemoveButton = 3L,
	dispidSelectButton = 5L,
	dispidSetEnabled = 6L,
	dispidAddButton = 7L,
	dispidUpdateButton = 8L,
	eventidCursorOver = 1L,
	eventidMove = 2L,
	eventidUpdate = 3L,
	eventidSelectPChannel = 4L,
	eventidSaveUndoState = 5L,
	eventidDisplayStatus = 6L,
	eventidRightClick = 7L,
	eventidDeleteChannel = 8L,
	//}}AFX_DISP_ID
	};

	// UI function to draw a 3D border around the control
	void EmbossRect( HDC hdc, const CRect *pRect, char raised );

	// embossed border width
	const short m_EBW;

	CBitmap	m_bmBtnUp;
	CBitmap	m_bmBtnDn;
	CBitmap	m_bmDrums;
	CBitmap	m_bmMask;

private:
	CRectTracker* m_pTracker;

	CRect		m_rcExtent;
	CRect		m_rcAdjusted;
	CChannel*	m_pBtnLst;
	CChannel*	m_pDrag;
	CChannel*	m_pOver;
	CBitmap		m_bmGridTile;
	CPoint		m_ptTouch;
	BOOL		m_fMoved;
	BOOL		m_bSized; // Set TRUE on create time OnSize...
	bool		m_bMultiSelected;
	bool		m_bSendUpdate;


	bool		AreAnyChannelsSelected();
	void		UnselectAllButtons();
	void		SelectAllButtons();
	void		MarkButtonForMove(CChannel* pButton, CPoint point);
	CRect*		GetAdjustedArea( CChannel *pc );
	void		_BringToFront( CChannel *pc );
	void		SendToBack();
	CChannel*	GetChannelByID(long nID);

	void		StepVolume(bool bStepUp);
	void		StepPan(bool bStepRight);

	CChannel*	SwapAdjacentNodes( CChannel *pParent, CChannel *pChild );
	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRIDCTL_H__EAB0CD53_9459_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\GridPpg.h ===
#if !defined(AFX_GRIDPPG_H__EAB0CD55_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_GRIDPPG_H__EAB0CD55_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GridPpg.h : Declaration of the CGridPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CGridPropPage : See GridPpg.cpp.cpp for implementation.

class CGridPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CGridPropPage)
	DECLARE_OLECREATE_EX(CGridPropPage)

// Constructor
public:
	CGridPropPage();

// Dialog Data
	//{{AFX_DATA(CGridPropPage)
	enum { IDD = IDD_PROPPAGE_GRID };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CGridPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRIDPPG_H__EAB0CD55_9459_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\StdAfx.h ===
#if !defined(AFX_STDAFX_H__EAB0CD49_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_STDAFX_H__EAB0CD49_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__EAB0CD49_9459_11D0_8C10_00A0C92E1CAC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PanVol\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Grid.rc
//
#define IDS_GRID                        1
#define IDD_ABOUTBOX_GRID               1
#define IDB_GRID                        1
#define IDI_ABOUTDLL                    1
#define IDS_GRID_PPG                    2
#define IDS_GRID_PPG_CAPTION            200
#define IDD_PROPPAGE_GRID               200
#define IDB_BTNUP                       201
#define IDS_LOW_RESOURCES               201
#define IDB_GRIDTILE                    202
#define IDS_FONT                        202
#define IDB_BTNDN                       203
#define IDB_MASK                        204
#define IDB_DRUMS                       205

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\CurvePropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __CURVEPROPPAGEMGR_H_
#define __CURVEPROPPAGEMGR_H_


#include <staticproppagemanager.h>
#include "PropCurve.h"


//////////////////////////////////////////////////////////////////////
//  CCurvePropPageMgr

class CCurvePropPageMgr : public CStaticPropPageManager 
{
friend class CPropPageCurve;

public:
	CCurvePropPageMgr(IDMUSProdFramework* pIFramework, CParamStrip* pParamStrip);
	virtual ~CCurvePropPageMgr();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:

	CPropPageCurve*		m_pTabCurve;
	CParamStrip*		m_pParamStrip;
	CTrackMgr*			m_pTrackMgr;	// Track manager
	GUID				m_GUIDManager;
	IDMUSProdFramework* m_pIFramework;

public:
	static short		sm_nActiveTab;
};

#endif // __CURVEPROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\GridsPerSecondDlg.cpp ===
// GridsPerSecondDlg.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "GridsPerSecondDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg dialog


CGridsPerSecondDlg::CGridsPerSecondDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGridsPerSecondDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGridsPerSecondDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_nSnapToRefTime_GridsPerSecond = 0;
	m_fAllParts = FALSE;
}


void CGridsPerSecondDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGridsPerSecondDlg)
	DDX_Control(pDX, IDC_NBR_MS, m_staticNbrMS);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_SPIN_NBR_GRIDS, m_spinNbrGrids);
	DDX_Control(pDX, IDC_EDIT_NBR_GRIDS, m_editNbrGrids);
	DDX_Control(pDX, IDC_RADIO_ACTIVE_PART, m_radioActivePart);
	DDX_Control(pDX, IDC_RADIO_ALL_PARTS, m_radioAllParts);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::SetNbrMsPerGridText

void CGridsPerSecondDlg::SetNbrMsPerGridText( void ) 
{
	int nGridsPerSecond = m_spinNbrGrids.GetPos();
	ASSERT( nGridsPerSecond >= MIN_NBR_GRIDS_PER_SECOND );
	ASSERT( nGridsPerSecond <= MAX_NBR_GRIDS_PER_SECOND );

	CString strNbr;
	if( 1000 % nGridsPerSecond )
	{
		strNbr.Format( "%.2f", ((float)1000 / nGridsPerSecond) );
	}
	else
	{
		strNbr.Format( "%d", (1000 / nGridsPerSecond) );
	}

	CString strNbrMS;
	AfxFormatString1( strNbrMS, IDS_NBR_MS_PER_GRID_TEXT, strNbr );

	m_staticNbrMS.SetWindowText( strNbrMS );
}


BEGIN_MESSAGE_MAP(CGridsPerSecondDlg, CDialog)
	//{{AFX_MSG_MAP(CGridsPerSecondDlg)
	ON_EN_KILLFOCUS(IDC_EDIT_NBR_GRIDS, OnKillFocusEditNbrGrids)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_NBR_GRIDS, OnDeltaPosSpinNbrGrids)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnInitDialog

BOOL CGridsPerSecondDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();
	
	// Limit the number of grids
	m_spinNbrGrids.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editNbrGrids.LimitText( 3 );

	// Set number of grids
	ASSERT( m_nSnapToRefTime_GridsPerSecond != 0 );
	m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
	SetNbrMsPerGridText();

	// Set radio buttons
	m_radioActivePart.SetCheck( 1 );
	m_radioAllParts.SetCheck( 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnKillFocusEditNbrGrids

void CGridsPerSecondDlg::OnKillFocusEditNbrGrids( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewNbrGrids;

	m_editNbrGrids.GetWindowText( strNewNbrGrids );

	// Strip leading and trailing spaces
	strNewNbrGrids.TrimRight();
	strNewNbrGrids.TrimLeft();

	if( strNewNbrGrids.IsEmpty() )
	{
		m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
	}
	else
	{
		short nNewNbrGrids = (short)_ttoi( strNewNbrGrids );

		// Check bounds
		if( nNewNbrGrids > MAX_NBR_GRIDS_PER_SECOND 
		||  nNewNbrGrids < MIN_NBR_GRIDS_PER_SECOND )
		{
			AfxMessageBox( IDS_ERR_NBR_GRIDS_PER_SECOND );
			m_spinNbrGrids.SetPos( m_nSnapToRefTime_GridsPerSecond );
			m_editNbrGrids.SetFocus();
			m_editNbrGrids.SetSel( 0, -1 );
		}
		else
		{
			m_spinNbrGrids.SetPos( nNewNbrGrids );
		}
	}

	SetNbrMsPerGridText();
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnDeltaPosSpinNbrGrids

void CGridsPerSecondDlg::OnDeltaPosSpinNbrGrids( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEditNbrGrids();

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Get the valid range
		int iLower, iUpper;
		m_spinNbrGrids.GetRange( iLower, iUpper );

		// Get current posiion
		int iPos = m_spinNbrGrids.GetPos();

		// Check ranges
		iPos += ((NM_UPDOWN* )pNMHDR)->iDelta;
		if( iPos > iUpper )
		{
			iPos = iUpper;
		}
		if( iPos < iLower )
		{
			iPos = iLower;
		}

		m_spinNbrGrids.SetPos( iPos );
	}

	SetNbrMsPerGridText();

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg::OnOK

void CGridsPerSecondDlg::OnOK( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(	m_radioAllParts.GetCheck() )
	{
		m_fAllParts = TRUE;
	}

	m_nSnapToRefTime_GridsPerSecond = (short)m_spinNbrGrids.GetPos();
	ASSERT( m_nSnapToRefTime_GridsPerSecond >= MIN_NBR_GRIDS_PER_SECOND );
	ASSERT( m_nSnapToRefTime_GridsPerSecond <= MAX_NBR_GRIDS_PER_SECOND );

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\GridsPerSecondDlg.h ===
#if !defined(AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_)
#define AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// GridsPerSecondDlg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CGridsPerSecondDlg dialog

class CGridsPerSecondDlg : public CDialog
{
// Construction
public:
	CGridsPerSecondDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGridsPerSecondDlg)
	enum { IDD = IDD_GRIDS_PER_SECOND };
	CStatic	m_staticNbrMS;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinNbrGrids;
	CEdit	m_editNbrGrids;
	CButton	m_radioActivePart;
	CButton	m_radioAllParts;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridsPerSecondDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetNbrMsPerGridText() ;

	// Generated message map functions
	//{{AFX_MSG(CGridsPerSecondDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillFocusEditNbrGrids();
	afx_msg void OnDeltaPosSpinNbrGrids(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	short   m_nSnapToRefTime_GridsPerSecond;
	BOOL	m_fAllParts;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRIDSPERSECONDDLG_H__9EA8FD59_CA8B_44D5_A5A7_49D483F35093__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "TabObject.h"
#include "SegmentIO.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {14CA5E1D-718A-4202-B1A3-89EF0E9FE7EE}
static const GUID GUID_ParamStripPPGMgr = 
{ 0x14ca5e1d, 0x718a, 0x4202, { 0xb1, 0xa3, 0x89, 0xef, 0xe, 0x9f, 0xe7, 0xee } };

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	// Must use other constructor!!!
	ASSERT( 0 );
}

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_ParamStripPPGMgr;

	// Initialize our pointers to NULL
	m_pTabGroupBits = NULL;
	m_pTrackFlagsPPG = NULL;
	m_pTabObject = NULL;

	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		delete m_pTabGroupBits;
		m_pTabGroupBits = NULL;
	}

	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}

	if( m_pTabObject )
	{
		delete m_pTabObject;
		m_pTabObject = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	CStaticPropPageManager::~CStaticPropPageManager();
}


HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::GetPropertySheetTitle

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::GetPropertySheetPages

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add group bits tab
	if( m_pTabGroupBits == NULL )
	{
		m_pTabGroupBits = new CGroupBitsPPG();
	}
	if( m_pTabGroupBits )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabGroupBits->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabGroupBits->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add object tab
	if( m_pTabObject == NULL )
	{
		m_pTabObject = new CTabObject();
	}
	if( m_pTabObject )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabObject->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabObject->m_pIPropSheet = m_pIPropSheet;

		// Point the property page back to this property page manager
		m_pTabObject->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::RefreshData

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		m_pTabGroupBits->RefreshData();
	}

	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}

	if( m_pTabObject )
	{
		m_pTabObject->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr::SetObject

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabGroupBits )
	{
		m_pTabGroupBits->SetObject( pINewPropPageObject );
	}

	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}

	if( m_pTabObject )
	{
		m_pTabObject->SetObject( pINewPropPageObject );
	}

	return CStaticPropPageManager::SetObject( pINewPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT

	m_pPPO = NULL;
	m_pIPropSheet = NULL;

	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable )
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPG* pioGroupBitsPPG = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	int iIndex;
	for (iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	m_pIPropSheet->GetActivePage( &CGroupBitsPropPageMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

interface IDMUSProdPChannelName;

class CGroupBitsPPG;
class CTrackFlagsPPG;
class CTabObject;
class CTrackMgr;

struct ioGroupBitsPPG
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
};

// Definitions copied from the "shared" groupbitsPPG
// These definitions are not actually used in the implementation,
// they're just here to make basestrip.cpp compile
#define GROUPBITSPPG_INDEX 0

#define GROUPBITSPPG_GROUPBITS_RO 0x1

typedef struct _PPGTrackParams
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
	DWORD	dwPropPageFlags;
} PPGTrackParams;
// End included definitions

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
friend class CGroupBitsPPG;
friend class CTabObject;

public:
	CGroupBitsPropPageMgr();
	CGroupBitsPropPageMgr( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CGroupBitsPropPageMgr();

	// IUnknown functions
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CGroupBitsPPG*		m_pTabGroupBits;
	CTrackFlagsPPG*		m_pTrackFlagsPPG;
	CTabObject*			m_pTabObject;

public:
	static short		sm_nActiveTab;
};


/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG 

class CGroupBitsPPG : public CPropertyPage
{
// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_WAVE_GROUP_BITS };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPG				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\newparameterdialog.cpp ===
// newparameterdialog.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "SegmentDesigner.h"
#include "SegmentIO.h"
#include "audiopathdesigner.h"
#include "ToolGraphDesigner.h"
#include "TrackMgr.h"
#include "TrackObject.h"
#include "newparameterdialog.h"
#include "conductor.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


StageInfo CNewParameterDialog::m_arrToolsStages[MAX_STAGES_TOOLS] = {StageInfo(DMUS_PATH_SEGMENT_TOOL, IDS_TOOLS_SEGMENT), StageInfo(DMUS_PATH_AUDIOPATH_TOOL, IDS_TOOLS_SEGMENT_AUDIOPATH), StageInfo(DMUS_PATH_PERFORMANCE_TOOL, IDS_TOOLS_PERFORMANCE_AUDIOPATH_TOOLGRAPH)};
StageInfo CNewParameterDialog::m_arrDMOStages[MAX_STAGES_DMOS] = {StageInfo(DMUS_PATH_BUFFER_DMO, IDS_DMOS_SEGMENT_AUDIOPATH), StageInfo(DMUS_PATH_PERFORMANCE, IDS_DMOS_PERFORMANCE_AUDIOPATH)};

CDMToolInfo::CDMToolInfo(DMUSProdToolInfo toolInfo, IUnknown* pIUnkTool)
{
	CopyMemory(&m_ToolInfo, &toolInfo, sizeof(DMUSProdToolInfo));
	m_pIUnkTool = pIUnkTool;
}	

CDMToolInfo::~CDMToolInfo()
{
	if(m_pIUnkTool)
	{
		m_pIUnkTool->Release();
		m_pIUnkTool = NULL;
	}
}


CDMOInfo::CDMOInfo(DMUSProdDMOInfo dmoInfo)
{
	CopyMemory(&m_DMOInfo, &dmoInfo, sizeof(DMUSProdDMOInfo));
}


bool CNewParameterDialog::m_bParamsForTools = false;
UINT CNewParameterDialog::m_nLastSelectedStageIndex = 0; 
UINT CNewParameterDialog::m_nLastSelectedObjectIndex = 0; 
UINT CNewParameterDialog::m_nLastSelectedParamIndex = 0;


/////////////////////////////////////////////////////////////////////////////
// CNewParameterDialog dialog

CNewParameterDialog::CNewParameterDialog(CTrackMgr* pTrackMgr) : CDialog(CNewParameterDialog::IDD, NULL), 
m_pTrackMgr(pTrackMgr), 
m_pISegment(NULL) 
{
	//{{AFX_DATA_INIT(CNewParameterDialog)
	//}}AFX_DATA_INIT

	ASSERT(pTrackMgr);
}


void CNewParameterDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewParameterDialog)
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_NEWOBJECT_SPIN_PCHANNEL, m_PChannelSpin);
	DDX_Control(pDX, IDC_NEWOBJECT_EDIT_PCHANNEL, m_PChannelEdit);
	DDX_Control(pDX, IDC_EDIT_PCHNAME, m_PChannelNameEdit);
	DDX_Control(pDX, IDC_COMBO_OBJECT, m_ObjectCombo);
	DDX_Control(pDX, IDC_COMBO_PARAM, m_ParamCombo);
	DDX_Control(pDX, IDC_COMBO_STAGE, m_StageCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewParameterDialog, CDialog)
	//{{AFX_MSG_MAP(CNewParameterDialog)
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_OBJECT, OnSelchangeComboObject)
	ON_CBN_SELCHANGE(IDC_COMBO_STAGE, OnSelchangeComboStage)
	ON_BN_CLICKED(IDC_RADIO_TOOLS, OnRadioTools)
	ON_BN_CLICKED(IDC_RADIO_DMOS, OnRadioDMOs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewParameterDialog message handlers

BOOL CNewParameterDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_pISegment = m_pTrackMgr->GetSegment();
	ASSERT(m_pISegment);

	// Show the parameters for tools by default
	if(m_bParamsForTools)
	{
		InitializeToolsControls();
	}
	else
	{
		InitializeDMOControls();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewParameterDialog::InitializeToolsControls()
{
	CButton* pToolRadio = (CButton*) GetDlgItem(IDC_RADIO_TOOLS);
	if(pToolRadio)
	{
		pToolRadio->SetCheck(1);
	}

	CButton* pDMORadio = (CButton*)GetDlgItem(IDC_RADIO_DMOS);
	if(pDMORadio)
	{
		pDMORadio->SetCheck(0);
	}

	InitializeToolsStageCombo();

	if(SUCCEEDED(InitializeToolsObjectCombo()))
	{
		InitializeToolsParameterCombo();
	}

	RefreshPChannelText();
}

void CNewParameterDialog::OnDestroy() 
{
	CDialog::OnDestroy();

	CleanObjectList();
	CleanParamsList();
	
	if(m_pISegment)
	{
		m_pISegment->Release();
	}
	
}


void CNewParameterDialog::InitializeToolsStageCombo()
{
	m_StageCombo.ResetContent();

	for(int nIndex = 0; nIndex < MAX_STAGES_TOOLS; nIndex++)
	{
		CString sStageName;
		sStageName.LoadString(m_arrToolsStages[nIndex].m_uStageName);
		m_StageCombo.AddString(sStageName);				
	}

	m_StageCombo.SetCurSel(m_nLastSelectedStageIndex);

	RefreshPChannelText();
}


HRESULT CNewParameterDialog::InitializeToolsObjectCombo()
{
	int nSelectedStage = m_StageCombo.GetCurSel();
	if(nSelectedStage == CB_ERR)
	{
		return E_FAIL;
	}
	
	CleanObjectList();	
	CleanParamsList();

	DWORD dwStage = m_arrToolsStages[nSelectedStage].m_dwStage;
	
	m_OKButton.EnableWindow(TRUE);
	m_ObjectCombo.EnableWindow(TRUE);
	m_ParamCombo.EnableWindow(TRUE);

	IDMUSProdConductor* pIConductor = m_pTrackMgr->GetConductor();
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return E_FAIL;
	}

	CPtrList lstObjects;
	if(FAILED(GetToolList(m_pISegment, pIConductor, dwStage, &lstObjects)))
	{
		m_ObjectCombo.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);
		pIConductor->Release();
		return E_FAIL;
	}

	pIConductor->Release();

	if(lstObjects.IsEmpty())
	{
		m_ObjectCombo.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);
		return E_FAIL;
	}

	POSITION position = lstObjects.GetHeadPosition();
	while(position)
	{
		CDMToolInfo* pToolInfo = (CDMToolInfo*)lstObjects.GetNext(position);
		ASSERT(pToolInfo);
		if(pToolInfo)
		{
			CString sToolName = pToolInfo->m_ToolInfo.awchToolName;
			int nInsertionIndex = m_ObjectCombo.AddString(sToolName);
			if(nInsertionIndex != CB_ERR)
			{
				if(m_ObjectCombo.SetItemDataPtr(nInsertionIndex, pToolInfo) == CB_ERR)
				{
					m_ObjectCombo.DeleteString(nInsertionIndex);
					return E_FAIL;
				}
			}
		}
	}

	m_ObjectCombo.SetCurSel(m_nLastSelectedObjectIndex);

	RefreshPChannelText();

	return S_OK;
}


void CNewParameterDialog::InitializeToolsParameterCombo()
{
	CleanParamsList();

	int nSelectedToolIndex = m_ObjectCombo.GetCurSel();
	if(nSelectedToolIndex == CB_ERR)
	{
		return;
	}

	CDMToolInfo* pToolInfo = (CDMToolInfo*)m_ObjectCombo.GetItemDataPtr(nSelectedToolIndex);
	ASSERT(pToolInfo);
	if(pToolInfo == NULL)
	{
		return;
	}
	
	m_OKButton.EnableWindow(TRUE);
	m_ParamCombo.EnableWindow(TRUE);
	
	CPtrList lstToolParams;
	if(FAILED(GetToolParamList(pToolInfo, &lstToolParams)))
	{
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);

		return;
	}

	
	if(lstToolParams.IsEmpty())
	{
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);
		return;
	}

	POSITION position = lstToolParams.GetHeadPosition();
	while(position)
	{
		MP_PARAMINFO* pParamInfo = (MP_PARAMINFO*) lstToolParams.GetNext(position);
		ASSERT(pParamInfo);
		if(pParamInfo)
		{
			CString sParamLabel = pParamInfo->szLabel;
			int nInsertionIndex = m_ParamCombo.AddString(sParamLabel);
			if(nInsertionIndex != CB_ERR)
			{
				if(m_ParamCombo.SetItemDataPtr(nInsertionIndex, pParamInfo) == CB_ERR)
				{
					m_ParamCombo.DeleteString(nInsertionIndex);
					return;
				}
			}
		}
	}

	m_ParamCombo.SetCurSel(m_nLastSelectedParamIndex);

}


HRESULT CNewParameterDialog::GetToolList(IDMUSProdSegmentEdit8*	pISegment, IDMUSProdConductor* pIConductor, DWORD dwStage, CPtrList* plstObjects)
{
	ASSERT(plstObjects);
	if(plstObjects == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdToolGraphInfo* pIToolGraphInfo = NULL;
	if(dwStage == DMUS_PATH_SEGMENT_TOOL)
	{
		if(FAILED(GetSegmentToolGraph(pISegment, &pIToolGraphInfo)))
		{
			return E_FAIL;
		}
	}
	else if(dwStage == DMUS_PATH_AUDIOPATH_TOOL)
	{
		if(FAILED(GetSegmentAudioPathToolGraph(pISegment, &pIToolGraphInfo)))
		{
			return E_FAIL;
		}
	}
	else if(DMUS_PATH_PERFORMANCE_TOOL)
	{
		if(FAILED(GetPerformanceAudioPathToolGraph(pIConductor, &pIToolGraphInfo)))
		{
			return E_FAIL;
		}
	}

	// Should never really assert right?
	ASSERT(pIToolGraphInfo);

	DWORD dwToolCount = 0;
	if(FAILED(pIToolGraphInfo->GetToolCount(&dwToolCount)))
	{
		pIToolGraphInfo->Release();
		return E_FAIL;
	}

	for(DWORD dwIndex = 0; dwIndex < dwToolCount; dwIndex++)
	{
		IUnknown* pUnkTool = NULL;
		if(FAILED(pIToolGraphInfo->EnumTools(dwIndex, &pUnkTool)))
		{
			return E_FAIL;
		}

		DMUSProdToolInfo toolInfo;
		ZeroMemory(&toolInfo, sizeof(DMUSProdToolInfo));
		toolInfo.wSize = sizeof(DMUSProdToolInfo);
		if(FAILED(pIToolGraphInfo->GetToolInfo(pUnkTool, &toolInfo)))
		{
			pUnkTool->Release();
			return E_FAIL;
		}

		CDMToolInfo* pToolInfo = new CDMToolInfo(toolInfo, pUnkTool);
		if(pToolInfo == NULL)
		{
			pUnkTool->Release();
			return E_OUTOFMEMORY;
		}
		
		plstObjects->AddTail(pToolInfo);
	}

	pIToolGraphInfo->Release();
	return S_OK;

}

HRESULT CNewParameterDialog::GetToolParamList(CDMToolInfo* pToolInfo, CPtrList* plstToolParams)
{
	ASSERT(pToolInfo);
	if(pToolInfo == NULL)
	{
		return E_POINTER;
	}

	ASSERT(plstToolParams);
	if(plstToolParams == NULL)
	{
		return E_POINTER;
	}

	IUnknown* pIUnkTool = pToolInfo->m_pIUnkTool;
	ASSERT(pIUnkTool);
	if(pIUnkTool == NULL)
	{
		return E_UNEXPECTED;
	}

	IMediaParamInfo* pIParamInfo = NULL;
	if(FAILED(pIUnkTool->QueryInterface(IID_IMediaParamInfo, (void**)&pIParamInfo)))
	{
		return E_FAIL;
	}

	if(FAILED(GetSupportedTimeFormat(pIParamInfo, &(pToolInfo->m_guidTimeFormat))))
	{
		pIParamInfo->Release();
		return E_FAIL;
	}

	DWORD dwParamCount = 0;
	if(FAILED(pIParamInfo->GetParamCount(&dwParamCount)))
	{
		pIParamInfo->Release();
		return E_FAIL;
	}

	for(DWORD dwIndex = 0; dwIndex < dwParamCount; dwIndex++)
	{
		MP_PARAMINFO* pInfo = new MP_PARAMINFO;
		if(FAILED(pIParamInfo->GetParamInfo(dwIndex, pInfo)))
		{
			delete pInfo;
			return E_FAIL;
		}

		plstToolParams->AddTail(pInfo);
	}

	pIParamInfo->Release();
	return S_OK;
}


HRESULT CNewParameterDialog::GetSegmentToolGraph(IDMUSProdSegmentEdit8* pISegment, IDMUSProdToolGraphInfo** ppIToolGraphInfo)
{
	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdNode* pISegmentNode = NULL;
	if(FAILED(pISegment->QueryInterface(IID_IDMUSProdNode, (void**)&pISegmentNode)))
	{
		return E_FAIL;
	}

	if(FAILED(pISegmentNode->GetObject(GUID_ToolGraphNode, IID_IDMUSProdToolGraphInfo, (void**)ppIToolGraphInfo)))
	{
		pISegmentNode->Release();
		return E_FAIL;
	}

	pISegmentNode->Release();
	return S_OK;
}


HRESULT CNewParameterDialog::GetSegmentAudioPathToolGraph(IDMUSProdSegmentEdit8* pISegment, IDMUSProdToolGraphInfo** ppIToolGraphInfo)
{
	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdNode* pISegmentNode = NULL;
	if(FAILED(pISegment->QueryInterface(IID_IDMUSProdNode, (void**)&pISegmentNode)))
	{
		return E_FAIL;
	}

	IDMUSProdNode* pIAudioPathNode = NULL;
	if(FAILED(pISegmentNode->GetObject(GUID_AudioPathNode, IID_IDMUSProdNode, (void**)&pIAudioPathNode)))
	{
		pISegmentNode->Release();
		return E_FAIL;
	}

	if(FAILED(pIAudioPathNode->GetObject(GUID_ToolGraphNode, IID_IDMUSProdToolGraphInfo, (void**)ppIToolGraphInfo)))
	{
		pIAudioPathNode->Release();
		pISegmentNode->Release();
		return E_FAIL;
	}

	pIAudioPathNode->Release();
	pISegmentNode->Release();
	return S_OK;
}

HRESULT CNewParameterDialog::GetPerformanceAudioPathToolGraph(IDMUSProdConductor* pIConductor, IDMUSProdToolGraphInfo** ppIToolGraphInfo)
{
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdConductorPrivate* pIConductorPrivate = NULL;
	if(FAILED(pIConductor->QueryInterface(IID_IDMUSProdConductorPrivate, (void**)&pIConductorPrivate)))
	{
		return E_FAIL;
	}

	IDMUSProdNode* pIAudioPathNode = NULL;
	if(FAILED(pIConductorPrivate->GetDefaultAudiopathNode(&pIAudioPathNode)))
	{
		pIConductorPrivate->Release(); 
		return E_FAIL;
	}

	// Release the private interface
	pIConductorPrivate->Release(); 

	if(FAILED(pIAudioPathNode->GetObject(GUID_ToolGraphNode, IID_IDMUSProdToolGraphInfo, (void**)ppIToolGraphInfo)))
	{
		pIAudioPathNode->Release();
		return E_FAIL;
	}

	pIAudioPathNode->Release();
	return S_OK;
}

void CNewParameterDialog::OnSelchangeComboObject() 
{
	if(m_bParamsForTools)
	{
		InitializeToolsParameterCombo();
	}
	else
	{
		InitializeDMOParameterCombo();
	}
	
	RefreshPChannelText();
}

void CNewParameterDialog::OnSelchangeComboStage() 
{
	if(m_bParamsForTools)
	{
		if(SUCCEEDED(InitializeToolsObjectCombo()))
		{
			InitializeToolsParameterCombo();
		}
	}
	else
	{
		if(SUCCEEDED(InitializeDMOObjectCombo()))
		{
			InitializeDMOParameterCombo();
		}
	}
}

void CNewParameterDialog::CleanObjectList()
{
	int nObjectCount = m_ObjectCombo.GetCount();
	while(m_ObjectCombo.GetCount() > 0)
	{
		void* pObject = m_ObjectCombo.GetItemDataPtr(0);
		ASSERT(pObject);
		m_ObjectCombo.DeleteString(0);
		if(pObject)
		{
			delete pObject;
		}
	}

	m_ObjectCombo.ResetContent();
}


void CNewParameterDialog::CleanParamsList()
{
	int nParamCount = m_ParamCombo.GetCount();
	while(m_ParamCombo.GetCount() > 0)
	{
		MP_PARAMINFO* pParamInfo = (MP_PARAMINFO*)m_ParamCombo.GetItemDataPtr(0);
		ASSERT(pParamInfo);
		m_ParamCombo.DeleteString(0);
		if(pParamInfo)
		{
			delete pParamInfo;
		}
	}

	m_ParamCombo.ResetContent();
}

void CNewParameterDialog::OnOK() 
{
	int nStageIndex = m_StageCombo.GetCurSel();
	if(nStageIndex == CB_ERR)
	{
		return;
	}
	StageInfo selectedStageInfo = m_arrToolsStages[nStageIndex];
	m_StripInfo.m_dwStage = selectedStageInfo.m_dwStage;

	CString sStageName;
	m_StageCombo.GetWindowText(sStageName);
	m_StripInfo.m_sStageName = sStageName;

	CString sObjectName;
	m_ObjectCombo.GetWindowText(sObjectName);
	m_StripInfo.m_sObjectName = sObjectName;

	int nParamIndex = m_ParamCombo.GetCurSel();
	if(nParamIndex == CB_ERR)
	{
		return;
	}
	MP_PARAMINFO* pParamInfo = (MP_PARAMINFO*)m_ParamCombo.GetItemDataPtr(nParamIndex);
	if(pParamInfo == NULL)
	{
		return;
	}

	CopyMemory(&m_StripInfo.m_ParamInfo, pParamInfo, sizeof(MP_PARAMINFO));
	
	m_StripInfo.m_dwParamIndex = nParamIndex;
	
	CString sParamName;
	m_ParamCombo.GetWindowText(sParamName);
	m_StripInfo.m_sParamName = sParamName;

	// We know the CLSID for the DMOs...so get it only if we're dealing with tools
	if(m_bParamsForTools)
	{
		int nObjectIndex = m_ObjectCombo.GetCurSel();
		if(nObjectIndex == CB_ERR)
		{
			return;
		}
		CDMToolInfo* pToolInfo = (CDMToolInfo*)m_ObjectCombo.GetItemDataPtr(nObjectIndex);
		if(pToolInfo == NULL)
		{
			return;
		}
		if(FAILED(GetObjectCLSID(pToolInfo->m_pIUnkTool, &m_StripInfo.m_guidObject)))
		{
			return;
		}

		m_StripInfo.m_sPChannelText = pToolInfo->m_ToolInfo.awchPChannels;
		m_StripInfo.m_dwPChannel = pToolInfo->m_ToolInfo.dwFirstPChannel;
		m_StripInfo.m_dwBuffer = 0;
		m_StripInfo.m_guidTimeFormat = pToolInfo->m_guidTimeFormat;

		m_nLastSelectedStageIndex = nStageIndex;
		m_nLastSelectedObjectIndex = nObjectIndex;
		m_nLastSelectedParamIndex = nParamIndex;
	}
	else
	{
		int nObjectIndex = m_ObjectCombo.GetCurSel();
		if(nObjectIndex == CB_ERR)
		{
			return;
		}
		CDMOInfo* pDMOInfo = (CDMOInfo*)m_ObjectCombo.GetItemDataPtr(nObjectIndex);
		if(pDMOInfo == NULL)
		{
			return;
		}
		m_StripInfo.m_dwStage = pDMOInfo->m_DMOInfo.dwStage;
		m_StripInfo.m_guidObject = pDMOInfo->m_DMOInfo.clsidDMO;
        m_StripInfo.m_guidInstance = pDMOInfo->m_DMOInfo.guidDesignGUID;
		m_StripInfo.m_sPChannelText = pDMOInfo->m_DMOInfo.awchPChannelText;
		m_StripInfo.m_dwPChannel = pDMOInfo->m_DMOInfo.dwPChannel;
		m_StripInfo.m_dwBuffer = pDMOInfo->m_DMOInfo.dwBufferIndex;
		m_StripInfo.m_guidTimeFormat = pDMOInfo->m_guidTimeFormat;
		m_StripInfo.m_dwObjectIndex = pDMOInfo->m_DMOInfo.dwEffectIndex;

		m_nLastSelectedStageIndex = nStageIndex;
		m_nLastSelectedObjectIndex = nObjectIndex;
		m_nLastSelectedParamIndex = nParamIndex;
	}

	CDialog::OnOK();
}

void CNewParameterDialog::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();
}

HRESULT	CNewParameterDialog::GetObjectCLSID(IUnknown* pIUnkObject, GUID* pguidObject)
{
	ASSERT(pIUnkObject);
	if(pIUnkObject == NULL)
	{
		return E_POINTER;
	}

	// Get IPersistStream and ask for CLSID
	IPersistStream* pIStream = NULL;
	if(FAILED(pIUnkObject->QueryInterface(IID_IPersistStream, (void**)&pIStream)))
	{
		return E_FAIL;
	}

	if(FAILED(pIStream->GetClassID(pguidObject)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}

void CNewParameterDialog::OnRadioTools() 
{
	m_bParamsForTools = true;
	CleanObjectList();
	CleanParamsList();

	InitializeToolsControls();
}

void CNewParameterDialog::OnRadioDMOs() 
{
	m_bParamsForTools = false;
	CleanObjectList();
	CleanParamsList();

	InitializeDMOControls();
}


void CNewParameterDialog::InitializeDMOControls()
{
	CButton* pToolRadio = (CButton*) GetDlgItem(IDC_RADIO_TOOLS);
	if(pToolRadio)
	{
		pToolRadio->SetCheck(0);
	}

	CButton* pDMORadio = (CButton*)GetDlgItem(IDC_RADIO_DMOS);
	if(pDMORadio)
	{
		pDMORadio->SetCheck(1);
	}

	InitializeDMOStageCombo();
	if(SUCCEEDED(InitializeDMOObjectCombo()))
	{
		InitializeDMOParameterCombo();
	}
}

void CNewParameterDialog::InitializeDMOStageCombo()
{
	m_StageCombo.ResetContent();

	for(int nIndex = 0; nIndex < MAX_STAGES_DMOS; nIndex++)
	{
		CString sStageName;
		sStageName.LoadString(m_arrDMOStages[nIndex].m_uStageName);
		m_StageCombo.AddString(sStageName);				
	}

	m_StageCombo.SetCurSel(m_nLastSelectedStageIndex);
	RefreshPChannelText();
}

HRESULT CNewParameterDialog::InitializeDMOObjectCombo()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_FAIL;
	}

	CleanObjectList();
	CleanParamsList();

	int nSelectedStage = m_StageCombo.GetCurSel();
	if(nSelectedStage == CB_ERR)
	{
		return E_FAIL;
	}

	DWORD dwStage = m_arrDMOStages[nSelectedStage].m_dwStage;
	
	m_ObjectCombo.EnableWindow(TRUE);
	m_ParamCombo.EnableWindow(TRUE);
	m_OKButton.EnableWindow(TRUE);

	IDMUSProdConductor* pIConductor = m_pTrackMgr->GetConductor();
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return E_FAIL;
	}

	CPtrList lstObjects;
	if(FAILED(GetDMOList(m_pISegment, pIConductor, dwStage, &lstObjects)))
	{
		m_ObjectCombo.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);
		pIConductor->Release();
		return E_FAIL;
	}
	pIConductor->Release();

	if(lstObjects.IsEmpty())
	{
		m_ObjectCombo.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		m_OKButton.EnableWindow(FALSE);
		return E_FAIL;
	}

	POSITION position = lstObjects.GetHeadPosition();
	while(position)
	{
		CDMOInfo* pDMOInfo = (CDMOInfo*)lstObjects.GetNext(position);
		ASSERT(pDMOInfo);
		if(pDMOInfo)
		{
			CString sDMOName = pDMOInfo->m_DMOInfo.awchDMOName;
			int nInsertionIndex = m_ObjectCombo.AddString(sDMOName);
			if(nInsertionIndex != CB_ERR)
			{
				if(m_ObjectCombo.SetItemDataPtr(nInsertionIndex, pDMOInfo) == CB_ERR)
				{
					m_ObjectCombo.DeleteString(nInsertionIndex);
					return E_FAIL;
				}
			}
		}
	}

	if(m_nLastSelectedObjectIndex < (UINT)m_ObjectCombo.GetCount())
	{
		m_ObjectCombo.SetCurSel(m_nLastSelectedObjectIndex);
	}
	else
	{
		m_ObjectCombo.SetCurSel(0);
	}
	RefreshPChannelText();

	return S_OK;
}

void CNewParameterDialog::InitializeDMOParameterCombo()
{
	CleanParamsList();

	int nSelectedDMOIndex = m_ObjectCombo.GetCurSel();
	if(nSelectedDMOIndex == CB_ERR)
	{
		return;
	}

	CDMOInfo* pDMOInfo = (CDMOInfo*)m_ObjectCombo.GetItemDataPtr(nSelectedDMOIndex);
	ASSERT(pDMOInfo);
	if(pDMOInfo == NULL)
	{
		return;
	}

	m_OKButton.EnableWindow(TRUE);
	m_ParamCombo.EnableWindow(TRUE);
	
	CPtrList lstDMOParams;
	if(FAILED(GetDMOParamList(pDMOInfo, &lstDMOParams)))
	{
		m_OKButton.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		return;
	}

	if(lstDMOParams.IsEmpty())
	{
		m_OKButton.EnableWindow(FALSE);
		m_ParamCombo.EnableWindow(FALSE);
		return;
	}

	POSITION position = lstDMOParams.GetHeadPosition();
	while(position)
	{
		MP_PARAMINFO* pParamInfo = (MP_PARAMINFO*) lstDMOParams.GetNext(position);
		ASSERT(pParamInfo);
		if(pParamInfo)
		{
			CString sParamLabel = pParamInfo->szLabel;
			int nInsertionIndex = m_ParamCombo.AddString(sParamLabel);
			if(nInsertionIndex != CB_ERR)
			{
				if(m_ParamCombo.SetItemDataPtr(nInsertionIndex, pParamInfo) == CB_ERR)
				{
					m_ParamCombo.DeleteString(nInsertionIndex);
					return;
				}
			}
		}
	}

	m_ParamCombo.SetCurSel(m_nLastSelectedParamIndex);
}


HRESULT CNewParameterDialog::GetDMOList(IDMUSProdSegmentEdit8*	pISegment, IDMUSProdConductor* pIConductor, DWORD dwStage, CPtrList* plstObjects)
{
	ASSERT(plstObjects);
	if(plstObjects == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdDMOInfo* pIDMOInfo = NULL;
	if(dwStage == DMUS_PATH_BUFFER_DMO)
	{
		if(FAILED(GetSegmentDMOInfo(pISegment, &pIDMOInfo)))
		{
			// We might be calling this on load...the stage ID in the content for both stages is the same as DMUS_PATH_BUFFER_DMO
			/*if(FAILED(GetPerformanceDMOInfo(pIConductor, &pIDMOInfo)))
			{*/
				return E_FAIL;
			/*}*/
		}
	}
	else if(dwStage == DMUS_PATH_PERFORMANCE)
	{
		if(FAILED(GetPerformanceDMOInfo(pIConductor, &pIDMOInfo)))
		{
			return E_FAIL;
		}
	
	}
	else
	{
		return E_UNEXPECTED;
	}

	// Should never really assert right?
	ASSERT(pIDMOInfo);

	DWORD dwDMOCount = 0;
	for(DWORD dwIndex = 0; ; dwIndex++)
	{
		DMUSProdDMOInfo dmoInfo;
		ZeroMemory(&dmoInfo, sizeof(DMUSProdDMOInfo));
		dmoInfo.dwSize = sizeof(DMUSProdDMOInfo);
		if(FAILED(pIDMOInfo->EnumDMOInfo(dwIndex, &dmoInfo)))
		{
			dwIndex--;
			break;
		}

		CDMOInfo* pDMOInfo = new CDMOInfo(dmoInfo);

		if(pDMOInfo == NULL)
		{
			pIDMOInfo->Release();
			return E_OUTOFMEMORY;
		}
		
		plstObjects->AddTail(pDMOInfo);
	}

	pIDMOInfo->Release();

	return S_OK;

}

HRESULT CNewParameterDialog::GetDMOParamList(CDMOInfo* pDMOInfo, CPtrList* plstDMOParams)
{
	ASSERT(pDMOInfo);
	if(pDMOInfo == NULL)
	{
		return E_POINTER;
	}

	ASSERT(plstDMOParams);
	if(plstDMOParams == NULL)
	{
		return E_POINTER;
	}

	CLSID clsidDMO = pDMOInfo->m_DMOInfo.clsidDMO;
	IUnknown* pIUnkDMO = NULL;
	if(FAILED(::CoCreateInstance(clsidDMO, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &pIUnkDMO)))
	{
		return E_FAIL;
	}

	ASSERT(pIUnkDMO);

	IMediaParamInfo* pIParamInfo = NULL;
	if(FAILED(pIUnkDMO->QueryInterface(IID_IMediaParamInfo, (void**)&pIParamInfo)))
	{
		return E_FAIL;
	}

	DWORD dwParamCount = 0;
	if(FAILED(pIParamInfo->GetParamCount(&dwParamCount)))
	{
		pIParamInfo->Release();
		pIUnkDMO->Release();
		return E_FAIL;
	}

	for(DWORD dwIndex = 0; dwIndex < dwParamCount; dwIndex++)
	{
		MP_PARAMINFO* pInfo = new MP_PARAMINFO;
		if(FAILED(pIParamInfo->GetParamInfo(dwIndex, pInfo)))
		{
			delete pInfo;
			pIParamInfo->Release();
			pIUnkDMO->Release();
			return E_FAIL;
		}

		if(pInfo->mpType == MPT_ENUM)
		{

			WCHAR* pwchText = NULL;
			/*if(FAILED(pIParamInfo->GetParamText(dwIndex, &pwchText)))
			{
				delete pInfo;
				pIParamInfo->Release();
				pIUnkDMO->Release();
				return E_FAIL;
			}*/

			if(FAILED(CTrackObject::GetParamEnumTypeText(clsidDMO, dwIndex, &pwchText)))
			{
				delete pInfo;
				pIParamInfo->Release();
				pIUnkDMO->Release();
				return E_FAIL;
			}

			CString sParamText = pwchText;
			if(pwchText)
			{
				::CoTaskMemFree(pwchText);
			}
		}

		// Get the supprted time format for the DMO
		if(FAILED(GetSupportedTimeFormat(pIParamInfo, &(pDMOInfo->m_guidTimeFormat))))
		{
			pIParamInfo->Release();
			pIUnkDMO->Release();
			return E_FAIL;
		}

		plstDMOParams->AddTail(pInfo);
	}

	pIParamInfo->Release();
	pIUnkDMO->Release();
	return S_OK;
}


HRESULT CNewParameterDialog::GetSegmentDMOInfo(IDMUSProdSegmentEdit8* pISegment, IDMUSProdDMOInfo** ppIDMOInfo)
{
	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdNode* pISegmentNode = NULL;
	if(FAILED(pISegment->QueryInterface(IID_IDMUSProdNode, (void**)&pISegmentNode)))
	{
		return E_FAIL;
	}

	if(FAILED(pISegmentNode->GetObject(GUID_AudioPathNode, IID_IDMUSProdDMOInfo, (void**)ppIDMOInfo)))
	{
		pISegmentNode->Release();
		return E_FAIL;
	}

	pISegmentNode->Release();
	return S_OK;
}


HRESULT CNewParameterDialog::GetPerformanceDMOInfo(IDMUSProdConductor* pIConductor, IDMUSProdDMOInfo** ppIDMOInfo)
{
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdConductorPrivate* pIConductorPrivate = NULL;
	if(FAILED(pIConductor->QueryInterface(IID_IDMUSProdConductorPrivate, (void**)&pIConductorPrivate)))
	{
		return E_FAIL;
	}

	IDMUSProdNode* pIAudioPathNode = NULL;
	if(FAILED(pIConductorPrivate->GetDefaultAudiopathNode(&pIAudioPathNode)))
	{
		pIConductorPrivate->Release(); 
		return E_FAIL;
	}
	
	// Release the private interface
	pIConductorPrivate->Release(); 
	
	if(FAILED(pIAudioPathNode->QueryInterface(IID_IDMUSProdDMOInfo, (void**)ppIDMOInfo)))
	{
		pIAudioPathNode->Release();
		return E_FAIL;
	}

	pIAudioPathNode->Release();
	return S_OK;
}


void CNewParameterDialog::RefreshPChannelText()
{
	if(m_ObjectCombo.GetCount() == 0)
	{
		return;
	}

	m_PChannelNameEdit.SetWindowText(NULL);

	if(m_bParamsForTools)
	{
		int nIndex = m_ObjectCombo.GetCurSel();
		if(nIndex != CB_ERR)
		{
			CDMToolInfo* pToolInfo = (CDMToolInfo*) m_ObjectCombo.GetItemDataPtr(nIndex);
			CString sPChannelText = "";
			if(pToolInfo)
			{
				sPChannelText = pToolInfo->m_ToolInfo.awchPChannels;
				m_PChannelNameEdit.SetWindowText(sPChannelText);
			}
		}
	}
	else
	{
		int nIndex = m_ObjectCombo.GetCurSel();
		if(nIndex != CB_ERR)
		{
			CDMOInfo* pDMOInfo = (CDMOInfo*) m_ObjectCombo.GetItemDataPtr(nIndex);
			CString sPChannelText = "";
			if(pDMOInfo)
			{
				sPChannelText = pDMOInfo->m_DMOInfo.awchPChannelText;
				m_PChannelNameEdit.SetWindowText(sPChannelText);
			}
		}
	}
}

HRESULT CNewParameterDialog::GetSupportedTimeFormat(IMediaParamInfo* pIParamInfo, GUID* pguidTimeFormat)
{
	ASSERT(pIParamInfo);
	if(pIParamInfo == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pguidTimeFormat);
	if(pguidTimeFormat == NULL)
	{
		return E_POINTER;
	}

	DWORD dwNumFormats = 0;
	if(FAILED(pIParamInfo->GetNumTimeFormats(&dwNumFormats)))
	{
		return E_FAIL;
	}

	if(dwNumFormats == 0)
	{
		return E_FAIL;
	}

	GUID guidMusicTime = GUID_TIME_MUSIC;
	GUID guidRefTime = GUID_TIME_REFERENCE;

	for(DWORD dwIndex = 0; dwIndex < dwNumFormats; dwIndex++)
	{
		if(FAILED(pIParamInfo->GetSupportedTimeFormat(dwIndex, pguidTimeFormat)))
		{
			return E_FAIL;
		}

		if(::IsEqualGUID(guidMusicTime, *pguidTimeFormat))
		{
			return S_OK;
		}

		if(::IsEqualGUID(guidRefTime, *pguidTimeFormat))
		{
			return S_OK;
		}
	}

	// Send back the last guid...no choice!
	if(dwIndex == dwNumFormats)
	{
		return S_OK;
	}
	
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\NewPartDlg.cpp ===
// NewPartDlg.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "NewPartDlg.h"
#include <PChannelName.h>
#include <SegmentDesigner.h>
#include "Timeline.h"
#include <dmusici.h>
#include "TrackMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog


CNewPartDlg::CNewPartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewPartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewPartDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_lPChannel = 0;
	m_pTrackMgr = NULL;
}

// Set the track number
void CNewPartDlg::SetTrack( int nTrack )
{
	m_lPChannel = nTrack;
}

// Set m_pTrackMgr
void CNewPartDlg::SetTrackMgr( CTrackMgr *pTrackMgr )
{
	ASSERT( pTrackMgr != NULL );
	if ( pTrackMgr == NULL )
	{
		return;
	}
	m_pTrackMgr = pTrackMgr;
}

void CNewPartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPartDlg)
	DDX_Control(pDX, IDC_PCHANNEL_STATUS, m_staticStatus);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_NEWPART_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_NEWPART_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHNAME, m_editPChannelName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPartDlg, CDialog)
	//{{AFX_MSG_MAP(CNewPartDlg)
	ON_EN_CHANGE(IDC_NEWPART_EDIT_PCHANNEL, OnChangeNewpartEditPChannel)
	ON_EN_KILLFOCUS(IDC_NEWPART_EDIT_PCHANNEL, OnKillfocusNewpartEditPChannel)
	ON_NOTIFY(UDN_DELTAPOS, IDC_NEWPART_SPIN_PCHANNEL, OnDeltaposNewpartSpinPchannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg message handlers

BOOL CNewPartDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDialog::OnInitDialog();

	// Make sure the TrackMgr pointer is valid
	ASSERT( m_pTrackMgr );
	if( m_pTrackMgr == NULL )
	{
		return TRUE;
	}

	m_lPChannel = m_pTrackMgr->GetGreatestUsedPChannel() + 1;

	m_spinPChannel.SetRange(1, MAX_PCHANNEL);
	m_spinPChannel.SetPos( m_lPChannel + 1 );

	m_editPChannel.LimitText(4);	// Length of 'Perf'

	m_strEmptyPChannel.LoadString( IDS_EMPTY_PCHANNEL );
	m_strUsedPChannel.LoadString( IDS_USED_PCHANNEL );
	m_strInvalidPChannel.LoadString( IDS_INVALID_PCHANNEL );

	m_strBroadcastSeg.LoadString( IDS_BROADCAST_SEG );
	m_strBroadcastPerf.LoadString( IDS_BROADCAST_PERF );

	UpdatePChannelName();

	m_btnOK.EnableWindow( TRUE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewPartDlg::OnChangeNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		// Exit if empty
		if ( cstrTmp.IsEmpty() )
		{
			m_staticStatus.SetWindowText(m_strInvalidPChannel);
			m_editPChannelName.SetWindowText("--------");
			m_btnOK.EnableWindow( FALSE );
			return;
		}

		// Check if this is broadcast PChannel
		if( cstrTmp.CompareNoCase( m_strBroadcastPerf ) == 0 )
		{
			m_lPChannel = -1;
			UpdatePChannelName();
		}
		else if( cstrTmp.CompareNoCase( m_strBroadcastSeg ) == 0 )
		{
			m_lPChannel = -2;
			UpdatePChannelName();
		}
		else
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) || (nPChannel > MAX_PCHANNEL) )
			{
				m_staticStatus.SetWindowText(m_strInvalidPChannel);
				m_editPChannelName.SetWindowText("--------");
				m_btnOK.EnableWindow( FALSE );
			}
			else
			{
				m_lPChannel = nPChannel - 1;

				UpdatePChannelName();
				m_btnOK.EnableWindow( TRUE );
			}
		}
	}
}

void CNewPartDlg::OnKillfocusNewpartEditPChannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString cstrTmp;
		m_editPChannel.GetWindowText( cstrTmp );

		// Strip leading and trailing spaces
		cstrTmp.TrimRight();
		cstrTmp.TrimLeft();

		if ( cstrTmp.IsEmpty() )
		{
			if( m_lPChannel >= 0 )
			{
				m_spinPChannel.SetPos( m_lPChannel + 1 );
			}
			else if( m_lPChannel == -1 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
			}
			else if( m_lPChannel == -2 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
			}

			UpdatePChannelName();
			m_btnOK.EnableWindow( TRUE );
			return;
		}

		if( (cstrTmp.CompareNoCase( m_strBroadcastPerf ) != 0)
		&&	(cstrTmp.CompareNoCase( m_strBroadcastSeg ) != 0) )
		{
			BOOL fTransSucceeded;
			int nPChannel = GetDlgItemInt( IDC_NEWPART_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
			if ( !fTransSucceeded || (nPChannel < 1) )
			{
				m_lPChannel = 0;
				m_spinPChannel.SetPos( 1 );
			}
			else if ( nPChannel > MAX_PCHANNEL )
			{
				m_lPChannel = MAX_PCHANNEL - 1;
				m_spinPChannel.SetPos( MAX_PCHANNEL );
			}
			else
			{
				// m_lPChannel should have been set by OnChangeNewpartEditPchannel()
				ASSERT(m_lPChannel == nPChannel - 1 );
			}
		}

		UpdatePChannelName();

		m_btnOK.EnableWindow( TRUE );
	}
}

void CNewPartDlg::UpdatePChannelName( void )
{
	ASSERT( m_pTrackMgr != NULL );

	if( m_pTrackMgr->PChannelExists( m_lPChannel ) )
	{
		m_staticStatus.SetWindowText( m_strUsedPChannel );
	}
	else
	{
		m_staticStatus.SetWindowText( m_strEmptyPChannel );
	}

	// Fill the PChannel name edit box with the PChannel's name
	if( m_pTrackMgr )
	{
		CString strPChannelName;

		if( SUCCEEDED( m_pTrackMgr->GetPChannelName( m_lPChannel, strPChannelName ) ) )
		{
			m_editPChannelName.SetWindowText( strPChannelName );
		}
	}
}

void CNewPartDlg::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Convert the m_lPChannel to a DWORD
	DWORD dwPChannel;
	if( m_lPChannel >= 0 )
	{
		dwPChannel = m_lPChannel;
	}
	else if( m_lPChannel == -1 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	}
	else if( m_lPChannel == -2 )
	{
		dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
	}

	// Create the Part
	if( SUCCEEDED ( m_pTrackMgr->AddPart( dwPChannel ) ) )
	{
		// Update the UI to the next PChannel
		if( m_lPChannel >= 0 )
		{
			m_lPChannel = min( (m_lPChannel + 1), (MAX_PCHANNEL - 1) );
		}
		else
		{
			m_lPChannel = 0;
		}

		m_spinPChannel.SetPos( m_lPChannel + 1 );
		UpdatePChannelName();
	}
}

void CNewPartDlg::OnDeltaposNewpartSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	*pResult = 0;

	if( pNMUpDown && (m_lPChannel <= 0) )
	{
		if( pNMUpDown->iDelta > 0 )
		{
			if( m_lPChannel == -2 )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				m_lPChannel = -1;
				*pResult = 1;
			}
			else if( m_lPChannel == -1 )
			{
				m_spinPChannel.SetPos( 1 );
				m_lPChannel = 0;
				*pResult = 1;
			}
		}
		else // ( pNMUpDown->iDelta <= 0 )
		{
			if( m_lPChannel == -1 )
			{
				m_lPChannel = -2;
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
			}
			else if( m_lPChannel == 0 )
			{
				m_lPChannel = -1;
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
			}
			*pResult = 1;
		}
	}
}


// Custom edit control that only accepts numbers, editing keys, 's' and 'p'
IMPLEMENT_DYNCREATE( CNewPartEdit, CEdit )

CNewPartEdit::CNewPartEdit() : CEdit()
{
}

LRESULT CNewPartEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8: // Backspace
		case 's':
		case 'S':
		case 'e':
		case 'E':
		case 'g':
		case 'G':
		case 'p':
		case 'P':
		case 'r':
		case 'R':
		case 'f':
		case 'F':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\newparameterdialog.h ===
#if !defined(AFX_NEWPARAMETERDIALOG_H__6733EE74_A089_4FB2_BD58_155F0C0868A8__INCLUDED_)
#define AFX_NEWPARAMETERDIALOG_H__6733EE74_A089_4FB2_BD58_155F0C0868A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// newparameterdialog.h : header file
//

#include <afxtempl.h>
#include "resource.h"
#include "DMusProd.h"
#include "MedParam.h"
#include "TrackMgr.h"
#include "TrackObject.h"
#include "SegmentDesigner.h"
#include "ToolGraphDesigner.h"
#include "AudioPathDesigner.h"


#define MAX_STAGES_TOOLS	3
#define MAX_STAGES_DMOS		2

class CTrackMgr;

struct StageInfo
{
	StageInfo(DWORD dwStage = 0, UINT uStageName = 0)
	{
		m_dwStage = dwStage;
		m_uStageName = uStageName;
	};

	DWORD	m_dwStage;
	UINT	m_uStageName;
};

class CDMToolInfo
{
public:
	CDMToolInfo(DMUSProdToolInfo toolInfo, IUnknown* pIUnkTool);
	virtual ~CDMToolInfo();

public:
	DMUSProdToolInfo	m_ToolInfo;
	GUID				m_guidTimeFormat;
	IUnknown*			m_pIUnkTool;
};

class CDMOInfo
{
public:
	CDMOInfo(DMUSProdDMOInfo dmoInfo);

public:
	DMUSProdDMOInfo	m_DMOInfo;
	GUID			m_guidTimeFormat;
};


struct StripInfo
{
	StripInfo& operator = (const StripInfo& source)
	{
		m_sStageName = source.m_sStageName;
		m_sObjectName = source.m_sObjectName;
		m_dwPChannel = source.m_dwPChannel;
		m_sPChannelText = source.m_sPChannelText;
		m_dwStage = source.m_dwStage;
		m_guidObject = source.m_guidObject;
        m_guidInstance = source.m_guidInstance;
		m_guidTimeFormat = source.m_guidTimeFormat;
		CopyMemory(&m_ParamInfo, &source.m_ParamInfo, sizeof(MP_PARAMINFO));
		m_sParamName = source.m_sParamName;
		m_dwParamIndex = source.m_dwParamIndex;
		m_dwBuffer = source.m_dwBuffer;
		m_dwObjectIndex = source.m_dwObjectIndex;
		return *this;
	}

	DWORD			m_dwPChannel;
	CString			m_sPChannelText;
	DWORD			m_dwStage;
	DWORD			m_dwObjectIndex;
	CString			m_sObjectName;
	CString			m_sStageName;
	GUID			m_guidObject;
    GUID            m_guidInstance;
	MP_PARAMINFO	m_ParamInfo;
	CString			m_sParamName;
	DWORD			m_dwParamIndex;
	GUID			m_guidTimeFormat;
	DWORD			m_dwBuffer;

};


/////////////////////////////////////////////////////////////////////////////
// CNewParameterDialog dialog

class CNewParameterDialog : public CDialog
{
// Construction
public:
	CNewParameterDialog(CTrackMgr* pTrackMgr);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewParameterDialog)
	enum { IDD = IDD_NEW_PARAM };
	CButton	m_OKButton;
	CSpinButtonCtrl	m_PChannelSpin;
	CEdit	m_PChannelEdit;
	CEdit	m_PChannelNameEdit;
	CComboBox	m_ObjectCombo;
	CComboBox	m_ParamCombo;
	CComboBox	m_StageCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewParameterDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewParameterDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboObject();
	afx_msg void OnSelchangeComboStage();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnRadioTools();
	afx_msg void OnRadioDMOs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:

	void InitializeToolsControls();
	void InitializeToolsStageCombo();
	HRESULT InitializeToolsObjectCombo();
	void InitializeToolsParameterCombo();

	void InitializeDMOControls();
	void InitializeDMOStageCombo();
	HRESULT InitializeDMOObjectCombo();
	void InitializeDMOParameterCombo();

	static HRESULT GetToolList(IDMUSProdSegmentEdit8* pISegment, IDMUSProdConductor* pIConductor, DWORD dwStage, CPtrList* plstObjects);
	static HRESULT GetDMOList(IDMUSProdSegmentEdit8* pISegment, IDMUSProdConductor* pIConductor, DWORD dwStage, CPtrList* plstObjects);
	static HRESULT GetSupportedTimeFormat(IMediaParamInfo* pIParamInfo, GUID* pguidTimeFormat);

private:
	static HRESULT GetSegmentToolGraph(IDMUSProdSegmentEdit8* pISegment, IDMUSProdToolGraphInfo** ppIToolGraphNode);
	static HRESULT GetSegmentAudioPathToolGraph(IDMUSProdSegmentEdit8* pISegment, IDMUSProdToolGraphInfo** ppIToolGraphNode);
	static HRESULT GetPerformanceAudioPathToolGraph(IDMUSProdConductor* pIConductor, IDMUSProdToolGraphInfo** ppIToolGraphNode);
	HRESULT GetToolParamList(CDMToolInfo* pToolInfo, CPtrList* plstToolParams);

	static HRESULT GetSegmentDMOInfo(IDMUSProdSegmentEdit8* pISegment, IDMUSProdDMOInfo** ppIDMOInfo);
	static HRESULT GetPerformanceDMOInfo(IDMUSProdConductor* pIConductor, IDMUSProdDMOInfo** ppIDMOInfo);
	HRESULT GetDMOParamList(CDMOInfo* pDMOInfo, CPtrList* plstDMOParams);

	HRESULT	GetObjectCLSID(IUnknown* pIUnkObject, GUID* pguidObject);

	void	CleanObjectList();
	void	CleanParamsList();

	void	RefreshPChannelText();	

public:
	static StageInfo m_arrToolsStages[MAX_STAGES_TOOLS];
	static StageInfo m_arrDMOStages[MAX_STAGES_DMOS];
	
	StripInfo	m_StripInfo;

private:
	CTrackMgr*				m_pTrackMgr;
	IDMUSProdSegmentEdit8*	m_pISegment;

	static bool				m_bParamsForTools;

	static UINT				m_nLastSelectedStageIndex;
	static UINT				m_nLastSelectedObjectIndex;
	static UINT				m_nLastSelectedParamIndex;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPARAMETERDIALOG_H__6733EE74_A089_4FB2_BD58_155F0C0868A8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\NewPartDlg.h ===
#if !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
#define AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPartDlg.h : header file
//

#include "resource.h"

#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

class CTrackMgr;

class CNewPartEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CNewPartEdit)
public:
	CNewPartEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CNewPartDlg dialog

class CNewPartDlg : public CDialog
{
// Construction
public:
	CNewPartDlg(CWnd* pParent = NULL);   // standard constructor

	void	SetTrack( int nTrack ); // Set the initial track number
	void	SetTrackMgr( CTrackMgr *pTrackMgr );

// Dialog Data
	//{{AFX_DATA(CNewPartDlg)
	enum { IDD = IDD_NEW_PART };
	CStatic	m_staticStatus;
	CButton	m_btnOK;
	CNewPartEdit	m_editPChannel;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannelName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPartDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewpartEditPChannel();
	afx_msg void OnKillfocusNewpartEditPChannel();
	virtual void OnOK();
	afx_msg void OnDeltaposNewpartSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	long			m_lPChannel;
	CTrackMgr*		m_pTrackMgr;
	CString			m_strEmptyPChannel;
	CString			m_strUsedPChannel;
	CString			m_strInvalidPChannel;

	CString			m_strBroadcastSeg;
	CString			m_strBroadcastPerf;

	void UpdatePChannelName( void );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPARTDLG_H__8E79CB36_EB82_11D2_A6E5_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\ParamStripMgrApp.h ===
// ParamStripMgrApp.h : Declaration of the CParamStripMgrApp

#ifndef __PARAMSTRIPMGRAPP_H_
#define __PARAMSTRIPMGRAPP_H_

#include <dmusprod.h>

class CParamStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

	IDMUSProdPropPageManager*	m_pIPageManager;
	CFont*	m_pParamStripFont;				// Param strip font
};

extern class CParamStripMgrApp theApp;

#endif // __PARAMSTRIPMGRAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\ParamStrip.h ===
#ifndef __PARAMSTRIP__H_
#define __PARAMSTRIP__H_

#include "TrackMgr.h"

void EmptyList(CTypedPtrList<CPtrList, CTrackItem*>& list);
void NormalizeList(IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset);

struct ioObjectUI
{
    DWORD cbSize;           // size of the structure
    GUID m_guidInstance;    // GUID that uniquely identifies the DMO instance
};

struct ioStripUI
{
	ioStripUI()
	{
		m_dblVerticalZoom = 0.1;
		m_lStripHeight = CRV_DEFAULT_HEIGHT;
		m_lVerticalScrollYPos = 0;
		m_nSnapToRefTime = (short) IDM_SNAP_GRID;
		m_nSnapToMusicTime = (short)IDM_SNAP_GRID;
		m_nStripView = SV_MINIMIZED;
		m_dwFlagsUI = 0;
		m_nSnapToRefTime_GridsPerSecond = DEFAULT_NBR_GRIDS_PER_SECOND;
	}

	double		m_dblVerticalZoom;		// Vertical zoom factor
	long		m_lStripHeight;			// Height of strip
	long		m_lVerticalScrollYPos;	// Vertical scroll Y position
	short		m_nSnapToRefTime;		// 'Snap To' increment when moving items with mouse (DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
	short		m_nSnapToMusicTime;		// 'Snap To' increment when moving items with mouse (!DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
	int			m_nStripView;			// Minimized or maximized
	DWORD		m_dwFlagsUI;			// various state flags (see STRIPUI_ prefix)
	short	    m_nSnapToRefTime_GridsPerSecond;
};

struct ioCopyPasteUI
{
	ioCopyPasteUI()
	{
		m_rtPasteOverwriteRange = 0;	
		m_rtOffset = 0;
		m_rtStartTime = 0;
		m_lRefTimeSec = 0;
		m_lRefTimeGrid = 0;
		m_lRefTimeMs = 0;
		m_mtPasteOverwriteRange = 0;	
		m_rtOffset = 0;
		m_mtStartTime = 0;
		m_lMusicTimeBeat = 0;
		m_lMusicTimeGrid = 0;	
		m_lMusicTimeTick = 0;	
		m_fRefTimeTrack = false;
	}

	REFERENCE_TIME	m_rtPasteOverwriteRange;// Total clock time of list (REFERENCE_TIME)
	REFERENCE_TIME	m_rtOffset;				// Offset from start of wave (REFERENCE_TIME)
	REFERENCE_TIME  m_rtStartTime;			// Start time of first item in list (REFERENCE_TIME)
	long			m_lRefTimeSec;			// Beat offset of first item in list
	long			m_lRefTimeGrid;			// Grid offset of first item in list
	long			m_lRefTimeMs;			// Tick offset of first item in list
	MUSIC_TIME		m_mtPasteOverwriteRange;// Total clock time of list (MUSIC_TIME)
	MUSIC_TIME		m_mtOffset;				// Offset from start of wave (REFERENCE_TIME)
	MUSIC_TIME		m_mtStartTime;			// Start time of first item in list (MUSIC_TIME)
	long			m_lMusicTimeBeat;		// Beat offset of first item in list
	long			m_lMusicTimeGrid;		// Grid offset of first item in list
	long			m_lMusicTimeTick;		// Tick offset of first item in list
	bool			m_fRefTimeTrack;		// Time is REFERENCE_TIME
};


class CParamStrip :	public CBaseStrip
{
public:
	CParamStrip( CTrackMgr* pTrackMgr, CTrackObject* pTrackObject );
	~CParamStrip();

public:
// IDMUSProdStrip overrides
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar overrides
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit overrides
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	

// IDropSource overrides

// IDropTarget overrides
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// General helper overrides
	HRESULT	PostRightClickMenu( POINT pt );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

	// Helpers
	HRESULT LoadStrip( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT SaveStrip( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	bool	RecomputeTimes();														// Returns true if anything changed
	void	RecomputeMeasureBeats();
	void	TimelineToStripUI();
	void	StripUIToTimeline();
	void	InvalidateFBar( void );
	void	CleanUp();
	void	RefreshUI(WORD& wRefreshUI);
	void	RefreshCurvePropertyPage( void );
	void	RefreshCurveStrips( void );


	// Methods to set properties of the strip
	void	OnCurvePropPageMgrDeleted();
	HRESULT SetProperties(StripInfo* pStripInfo);

	void	OnUpdateInsertCurveValue(POINT ptLeft, POINT ptRight);
	WORD	SelectCurvesInRect( CRect* pRect );
	CRect	GetUpdatedCurveRect(CCurveTracker& curveTracker, CTrackItem* pCurve, int nAction);
	void	OnUpdateDragCurveValue(CCurveTracker& tracker, int nAction);	

	// Accessors / Mutators
	IDMUSProdPropPageManager* GetPropPageMgr();

	CString			GetName();
	void			SetName(CString sName);

	CTrackMgr*		GetTrackManager();
	CTrackObject*	GetTrackObject();

	DWORD			GetDMParamFlags();
	void			SetDMParamFlags(DWORD dwParamFlagsDM);

	HRESULT			GetTimeSignature(DirectMusicTimeSig* pTimeSig, MUSIC_TIME mtTime);
	HRESULT			GetParamInfoFromCLSID(MP_PARAMINFO* pParamInfo);

	BOOL			GetStripRect(LPRECT pRectStrip);

	DWORD			GetParamIndex();
	BOOL			UseCenterLine( void );
	HRESULT			CanDeleteParameter();
	
	void			SwitchTimeBase( void );
	BOOL			IsOneGrid();


protected:
	HRESULT	DrawMinimizedStrip( HDC hDC, RECT* pRectStrip );
	HRESULT	DrawMaximizedStrip( HDC hDC, STRIPVIEW sv, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset );
	void	InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset );
	void	UnselectGutterRange();
	void	DrawClockVerticalLines( HDC hDC, long lXOffset );
	void	HighlightTimelineRange(HDC hDC, long lXOffset);
	void	DrawHorizontalLines(HDC hDC, const RECT &rectClip);
	void	DrawCurve(CTrackItem* pTrackItem, HDC hDC, RECT* pRectStrip, LONG lXOffset);
	void	DragModify(CTrackItem* pTrackItem, int nStripXPos, int nStripYPos, int nAction, bool bMakeCopy = false);
	WORD	SelectCurve( CTrackItem* pTrackItem, BOOL fState );
	WORD	SelectAllCurves( BOOL fState );
	BOOL	CanCycle();
	HRESULT OnCreate();
	HRESULT OnDestroy();
	void	ShowCurveValueOnStausBar(CTrackItem* pItem);
	HRESULT SnapUnknownToNextIncrement(REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime);
	bool	CListSelectedRegion_Contains( REFERENCE_TIME rtTime );

// IDropTarget helpers 
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lXPos, bool bDropNotPaste, BOOL &fChanged );

// IDropSource helpers
	HRESULT CreateDataObject(IDataObject**, long position);
	HRESULT	DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos);

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos);
	HRESULT OnLButtonUp( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnSetCursor( long lXPos, long lYPos);

	CTrackItem* GetItemFromPoint( long lPos );
	bool SelectItemsInSelectedRegions();
	void SelectRegionsFromSelectedItems();	
	void AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	BOOL RegisterClipboardFormats();

	CTrackItem* GetTopItemFromMeasureBeat( long lMeasure, long lBeat );
	CTrackItem* GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CTrackItem* GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat );
	CTrackItem* GetNextItem( POSITION pos );
	CTrackItem* GetNextSelectedItem( POSITION pos );
	CTrackItem* GetFirstSelectedItem();
	CTrackItem*	GetCurveFromPoint( int nStripXPos, int nStripYPos, BOOL bFrameOnly );
	UINT		HitTest( CCurveTracker& tracker, long lStripXPos, long lStripYPos );

	// Methods for Parameter curves
	void	InsertCurve(long lXPos, long lYPos);
	void	StartInsertingCurve();
	void	StopInsertingCurve();
	float	YPosToValue(long lYPos);
	short	ValueToYPos(float fltValue);
	int		AdjustXPos( int nStripXPos );	
	void	CreateCurveCopy(CTrackItem* pCurve);
	
	// Overrides of CBaseStrip
	bool	IsSelected();	// Returns true if any items are selected
	bool	IsEmpty();		// Returns false if there are any items
	bool	SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime );

		// From CTrackMgr
	void	UnselectAll();
	void	InsertByAscendingTime( CTrackItem *pItem, BOOL fPaste );
	bool	DeleteBetweenMeasureBeats( long lmStart, long lbStart, long lmEnd, long lbEnd );
	HRESULT SaveSelectedItems( LPSTREAM pIStream, REFERENCE_TIME rtOffset, CTrackItem* pItemAtDragPoint );
	HRESULT CycleItems( long lXPos );
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
	void	MarkSelectedItems( DWORD flags );
	void	UnMarkItems( DWORD flags );
	void	DeleteMarked( DWORD flags );
	void	DeleteSelectedItems();

	// New methods
	void	GetFBName( CString& strFBName );
	void	OnShowStripProperties();
	void	OnShowItemProperties();
	HWND	GetMyWindow();

	HRESULT LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream );
	HRESULT SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream );
	HRESULT SaveStripDesignData( IDMUSProdRIFFStream* pIRiffStream );
	
	void	DoGridsPerSecond( void );
	void	SetSnapTo( WORD wID );
	HRESULT SnapXPosToUnknownTime(long lXPos, REFERENCE_TIME* prtSnapTime);
	HRESULT SnapUnknownTime(REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime);
	REFERENCE_TIME CalculateDropTime(MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI);
	REFERENCE_TIME CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI );

	// Fields used for UI 
	CTrackMgr*		m_pTrackMgr;
	CTrackObject*	m_pTrackObject;
	CTrackItem		m_SelectedTrackItem;
	CTrackItem*		m_pItemToToggle;
	UINT			m_cfParamTrack;				// CF_PARAMTRACK Clipboard format
	bool			m_fLeftMouseDown;
	HANDLE			m_hKeyStatusBar;

	// For inserting parameter curves
	BOOL			m_fInsertingCurve;
	float			m_fltInsertingStartValue;		// new curve's start value
	float			m_fltInsertingEndValue;		// new curve's end value
	long			m_lInsertingStartClock;		// new curve's start music time
	long			m_lInsertingEndClock;		// new curve's music time
					

	// Reference counter for bitmaps
	static long		sm_lBitmapRefCount;

	// Zoom status variables
	static CBitmap	sm_bmpZoomInBtnUp;
	static CBitmap	sm_bmpZoomInBtnDown;
	static CBitmap	sm_bmpZoomOutBtnUp;
	static CBitmap	sm_bmpZoomOutBtnDown;
	bool			m_fZoomInDown;
	bool			m_fZoomOutDown;

	// Vertical scroll variables
	long			m_lVerticalScroll; 

	// Fields that are persisted (DirectMusic parameter control track data)
	DWORD			m_dwParamIndex;			// Index number of the parameter on the object
	DWORD			m_dwParamFlagsDM;		// Various flags pertaining to parameter (strip)

	CTypedPtrList<CPtrList, CTrackItem*> m_lstTrackItems;

	// Fields that are only persisted in design files
	CString			m_strStripName;			// Used by FBDraw()
	HCURSOR 		m_hCursor;

public:
	MP_PARAMINFO	m_ParamInfo;			// Keeps the parameter info 
	ioStripUI		m_StripUI;				// UI info for the strip
};

inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, CTrackItem& item)
{
	CMusicTimeConverter cmtBeg(item.m_lMeasure, item.m_lBeat, csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}

#endif // __PARAMSTRIP__H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\ParamStrip.cpp ===
// ParamStrip.cpp : Implementation of CParamStrip
#include "stdafx.h"
#include <math.h>
#include <RiffStrm.h>
#include "ParamStripMgrApp.h"
#include "GridsPerSecondDlg.h"
#include "TrackItem.h"
#include "ParamStripMgr.h"
#include "TrackMgr.h"
#include "ParamStrip.h"
#include "Tracker.h"
#include "CurvePropPageMgr.h"
#include "GroupBitsPPG.h"
#include <BaseMgr.h>
#include <SegmentDesigner.h>
#include <SegmentIO.h>
#include <DLLJazzDataObject.h>
#include <PChannelName.h>
#include <dmusicf.h>
#include "GrayOutRect.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// This sets the strip's height
#define DEFAULT_STRIP_HEIGHT		20	// TODO: get rid of this later		

// Bitmaps
long CParamStrip::sm_lBitmapRefCount = 0;
CBitmap	CParamStrip::sm_bmpZoomInBtnUp;
CBitmap	CParamStrip::sm_bmpZoomInBtnDown;
CBitmap	CParamStrip::sm_bmpZoomOutBtnUp;
CBitmap	CParamStrip::sm_bmpZoomOutBtnDown;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// EmptyList

void EmptyList( CTypedPtrList<CPtrList, CTrackItem*>& list )
{
	// Remove and delete all the CTrackItems from the given list
	while( !list.IsEmpty() )
	{
		delete list.RemoveHead();
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// NormalizeList

void NormalizeList( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, CTypedPtrList<CPtrList, CTrackItem*>& list, REFERENCE_TIME rtOffset )
{
	UNREFERENCED_PARAMETER(pITimeline);
	UNREFERENCED_PARAMETER(dwGroupBits);

	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		CTrackItem* pItem = list.GetNext(pos);
		ASSERT(pItem);
		if(pItem)
		{
			// This method only called for drag/drop and cut/copy/paste
			// so it is safe to mess with the values that are stored in time fields
			// Keep the duration in the end time
			// Keep the physical tiome in start time
			pItem->m_mtEndTime = (MUSIC_TIME) pItem->m_rtDuration;
			pItem->m_mtStartTime = (MUSIC_TIME) (pItem->m_rtTimePhysical - rtOffset);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip constructor/destructor

CParamStrip::CParamStrip( CTrackMgr* pTrackMgr, CTrackObject* pTrackObject ) : CBaseStrip( pTrackMgr )
{
	if( pTrackMgr == NULL 
	||  pTrackObject == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Handle to the status bar
	m_hKeyStatusBar = NULL;

	// Set our pointer to our strip manager
	m_pTrackMgr = pTrackMgr;

	// Set our pointer to our strip object
	m_pTrackObject = pTrackObject;

	// Initialize our clipboard formats to 0
	m_cfParamTrack = 0;

	m_fInsertingCurve = FALSE;

	// Initialize our state variables
	m_lVerticalScroll = 0;
	m_fLeftMouseDown = false;
	m_fZoomInDown = false;
	m_fZoomOutDown = false;

	// Initialize the item to toggle (when CTRL-clicking) to NULL
	m_pItemToToggle = NULL;

	// Initialize fields that are persisted (DirectMusic parameter control track data)
	m_dwParamIndex = 0xFFFFFFFF;
	m_dwParamFlagsDM = 0;
}

CParamStrip::~CParamStrip()
{
	CleanUp();
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CleanUp

void CParamStrip::CleanUp( void )
{
	// Clear our pointer to our strip manager
	if( m_pTrackMgr )
	{
		m_pTrackMgr->SetParamStripForPropSheet(this, TRUE);
		m_pTrackMgr = NULL;
	}

	// Delete all the items in m_lstTrackItems
	EmptyList( m_lstTrackItems );
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetTopItemFromMeasureBeat

CTrackItem* CParamStrip::GetTopItemFromMeasureBeat( long lMeasure, long lBeat )
{
	CTrackItem* pTheItem = NULL;
	CTrackItem* pFirstItem = NULL;
	CTrackItem* pItem;

	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			if( pFirstItem == NULL )
			{
				pFirstItem = pItem;
			}

			if( pItem->m_wFlagsUI & RF_TOP_ITEM )
			{
				pTheItem = pItem;
				break;
			}
		}

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}
	}

	if( pTheItem == NULL )
	{
		pTheItem = pFirstItem;
	}

	return pTheItem;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// GetNextSelectedItem - helper method for Draw()

void GetNextSelectedItem( CTypedPtrList<CPtrList, CTrackItem*>& list, POSITION &posItem )
{
	// Note that if the item at posItem is selected, this method doesn't do anything useful.
	if( posItem )
	{
		// Save the current position
		POSITION posToSave = posItem;

		// Check if we have not run off the end of the list, and if the currently item is unselected
		while( posItem && !list.GetNext( posItem )->m_fSelected )
		{
			// Current item is unselected, save the position of the next item
			posToSave = posItem;
		}

		// Check if we found a selected item
		if( posToSave )
		{
			// Save the position of the selected item
			posItem = posToSave;

		}
		// Otherwise both posToSave and posItem are NULL
	}
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::AdjustTopItem - helper method for Draw()

void CParamStrip::AdjustTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pFirstSelectedItem = NULL;
	CTrackItem* pTopItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			break;
		}

		if( pItem->m_fSelected )
		{
			if( pFirstSelectedItem == NULL )
			{
				pFirstSelectedItem = pItem;
			}
		}

		if( pItem->m_wFlagsUI & RF_TOP_ITEM )
		{
			if( pTopItem == NULL )
			{
				pTopItem = pItem;
			}
			else
			{
				// Can only have one top item
				pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
			}
		}
	}

	if( pTopItem )
	{
		if( pTopItem->m_fSelected == FALSE )
		{
			if( pFirstSelectedItem )
			{
				// pTopItem is NOT selected so it shouldn't be the top item
				pTopItem->m_wFlagsUI &= ~RF_TOP_ITEM;
						
				// pFirstSelectedItem IS selected so make it the top item
				pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
			}
		}
	}
	else if( pFirstSelectedItem )
	{
		// Make the selected item the top item
		pFirstSelectedItem->m_wFlagsUI |= RF_TOP_ITEM;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetNextSelectedTopItem - helper method for Draw()

CTrackItem* CParamStrip::GetNextSelectedTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( pItem->m_lMeasure != lCurrentMeasure
			||  pItem->m_lBeat != lCurrentBeat )
			{
				pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
				ASSERT( pNextItem != NULL );	// Should not happen!
				break;
			}
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetNextTopItem - helper method for Draw()

CTrackItem* CParamStrip::GetNextTopItem( POSITION pos, long lCurrentMeasure, long lCurrentBeat )
{
	CTrackItem* pNextItem = NULL;
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure != lCurrentMeasure
		||  pItem->m_lBeat != lCurrentBeat )
		{
			pNextItem = GetTopItemFromMeasureBeat( pItem->m_lMeasure, pItem->m_lBeat );
			ASSERT( pNextItem != NULL );	// Should not happen!
			break;
		}
	}

	return pNextItem;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetNextSelectedItem - helper method for Draw()

CTrackItem* CParamStrip::GetNextSelectedItem( POSITION pos )
{
		// Get a pointer to the selected item
//	CTrackItem* pItem = m_lstTrackItems.GetAt( posItem );

	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_fSelected )
		{
			return pItem;
		}
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetNextItem - helper method for Draw()

CTrackItem* CParamStrip::GetNextItem( POSITION pos )
{
	CTrackItem* pItem;

	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		return pItem;
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DrawMinimizedStrip

HRESULT	CParamStrip::DrawMinimizedStrip( HDC hDC, RECT* pRectStrip )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL || m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return E_UNEXPECTED;
	}

	CString strText;
	// Format text depicting type of curves in this Part
	if(m_pTrackObject->IsEmptyTrackObject() == TRUE)
	{
		strText.LoadString(IDS_NO_PARAM_TRACKS_TEXT);
	}
	else
	{
		strText = m_pTrackObject->GetMinimizedStripText();
	}

	// Set font
	HFONT pFontOld = NULL;

	if( theApp.m_pParamStripFont == NULL )
	{
		theApp.m_pParamStripFont = new CFont;

		if( theApp.m_pParamStripFont )
		{
			CString strFontName;
			if( !strFontName.LoadString( IDS_PARAM_STRIP_FONTNAME ) )
			{
				strFontName = _T("Arial");
			}
			if( theApp.m_pParamStripFont->CreatePointFont( 80, strFontName, CDC::FromHandle(hDC) ) == FALSE )
			{
				delete theApp.m_pParamStripFont;
				theApp.m_pParamStripFont = NULL;
			}
		}
	}
	if( theApp.m_pParamStripFont )
	{
		pFontOld = (HFONT)::SelectObject( hDC, theApp.m_pParamStripFont->GetSafeHandle() );
	}

	// Draw text depicting type of curves in this Part
	pRectStrip->left = 4;
	::DrawText( hDC, strText, -1, pRectStrip, DT_LEFT | DT_VCENTER | DT_SINGLELINE );

	if( pFontOld )
	{
		::SelectObject( hDC, pFontOld );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DrawCurve

void CParamStrip::DrawCurve( CTrackItem* pTrackItem, HDC hDC, RECT* pRectStrip, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	COLORREF crNoteColor = RGB(0, 0, 255);
	COLORREF crSelectedNoteColor = RGB(255, 0, 0);

	if(m_pTrackObject->IsDisabled())
	{
		crNoteColor = RGB(166, 166, 166);
	}

	float fltLastValue = (float)0xFFFFFFFF;
	short nPosValue = 0;
	long lCurveStartClock = 0;
	
	VARIANT var;
	CRect rect;

	lCurveStartClock  = pTrackItem->m_mtStartTime;

	// Get Strip height and center
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}
	int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

	float fValueRange = m_ParamInfo.mpdMaxValue - m_ParamInfo.mpdMinValue;
	float fltYScale = (float)nStripHeight / fValueRange;
	float fltZeroValue = m_ParamInfo.mpdNeutralValue;
	
	// Get MUSIC_TIME increment
	MUSIC_TIME mtIncrement;
	pTimeline->PositionToClocks( 1, &mtIncrement );

	// Initialize rectFrame and rectSelect
	pTrackItem->m_rectFrame.SetRectEmpty();
	pTrackItem->m_rectSelect.SetRectEmpty();

	pTrackItem->m_mtCurrent = 0;
	pTrackItem->m_mtDuration = pTrackItem->m_mtEndTime - pTrackItem->m_mtStartTime;
	pTimeline->ClocksToPosition( lCurveStartClock + pTrackItem->m_mtCurrent, &rect.right );

	BOOL fFirstTime = TRUE;

	// Draw the curve
	while( pTrackItem->m_mtCurrent <= pTrackItem->m_mtDuration )
	{
		// Compute value of curve at m_mtCurrent
		float fltValue = pTrackItem->ComputeCurve( NULL );
		
		nPosValue = ValueToYPos(fltValue);

		// Increment time offset into Curve
		pTrackItem->m_mtCurrent += mtIncrement;

		if( fltValue != fltLastValue)
		{
			fltLastValue = fltValue;

			// Set rect left
			rect.left = rect.right;

			// Set rect right
			pTimeline->ClocksToPosition( lCurveStartClock + pTrackItem->m_mtCurrent, &rect.right );


			if( UseCenterLine() )
			{
				// Set rect top and bottom
				nPosValue = nStripCenter - nPosValue;

				// Draw Curves around central axis
				if( fltValue < 0 )
				{
					rect.top = nStripCenter;
					rect.bottom = nStripHeight - nPosValue;
				}
				else
				{
					rect.top = nPosValue;
					rect.bottom = nStripCenter;
				}
			}
			else
			{
				// Set rect top and bottom
				nPosValue = nStripHeight - nPosValue;

				rect.top = nPosValue;
				rect.bottom = nStripHeight;
			}

			if( rect.bottom <= rect.top )
			{
				rect.top = rect.bottom - 1;
			}

			rect.left -= lXOffset;
			rect.right -= lXOffset;

			int nOrigRectRight = rect.right;
			rect.right = max( rect.right, rect.left + 2 );

			// Draw this part of the Curve
			if( pTrackItem->m_fSelected )
			{
				::SetBkColor( hDC, crSelectedNoteColor );
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
			}
			else
			{
				::SetBkColor( hDC, crNoteColor );
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
			}
			
			rect.right = nOrigRectRight;

			rect.left += lXOffset;
			rect.right += lXOffset;

			// Adjust rectSelect right, top, and bottom
			if( fFirstTime )
			{
				fFirstTime = FALSE;
				pTrackItem->m_rectSelect.SetRect( rect.left, rect.top, rect.right, rect.bottom );
			}
			else
			{
				pTrackItem->m_rectSelect.right = rect.right;
				pTrackItem->m_rectSelect.top = min( pTrackItem->m_rectSelect.top, rect.top );
				pTrackItem->m_rectSelect.bottom = max( pTrackItem->m_rectSelect.bottom, rect.bottom );
			}
		}
	}

	// Set rectFrame
	pTrackItem->m_rectFrame.left = pTrackItem->m_rectSelect.left;
	pTrackItem->m_rectFrame.right = pTrackItem->m_rectSelect.right;
	if( pTrackItem->m_fltStartValue < pTrackItem->m_fltEndValue )
	{
		pTrackItem->m_rectFrame.top = nStripHeight - ValueToYPos( pTrackItem->m_fltEndValue );
		pTrackItem->m_rectFrame.bottom = nStripHeight - ValueToYPos( pTrackItem->m_fltStartValue );
	}
	else
	{
		pTrackItem->m_rectFrame.top = nStripHeight - ValueToYPos( pTrackItem->m_fltStartValue );
		pTrackItem->m_rectFrame.bottom = nStripHeight - ValueToYPos( pTrackItem->m_fltEndValue );
	}

	pTrackItem->m_rectFrame.left -= lXOffset;
	pTrackItem->m_rectFrame.right -= lXOffset;

	::FrameRect( hDC, &pTrackItem->m_rectFrame, (HBRUSH)GetStockObject(DKGRAY_BRUSH) );

	pTrackItem->m_rectFrame.left += lXOffset;
	pTrackItem->m_rectFrame.right += lXOffset;
	
	// draw selection handles if curve is selected
	if( pTrackItem->m_fSelected )
	{
		CRect selRect = pTrackItem->m_rectFrame;
		VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
		VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
		
		CCurveTracker curveTracker(&selRect);
		curveTracker.Draw( CDC::FromHandle(hDC) );
	}
}



/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DrawMaximizedStrip

HRESULT	CParamStrip::DrawMaximizedStrip(HDC hDC, STRIPVIEW sv, RECT* pRectStrip, RECT* pRectClip, LONG lXOffset)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}
	
	// Save the DC
	int iSavedDC = ::SaveDC( hDC );

	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Draw Bar, Beat, Grid lines
	if(m_pTrackMgr->IsRefTimeTrack() )
	{
		DrawClockVerticalLines(hDC, lXOffset);
	}
	else
	{
		DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
		pTimeline->DrawMusicLines(hDC, ML_DRAW_MEASURE_BEAT_GRID, dwGroupBits, 0, lXOffset);
	}

	// Draw horizontal lines
	DrawHorizontalLines( hDC, rectClip );

	// Highlight range selected in timeline
	HighlightTimelineRange( hDC, lXOffset );

	VARIANT var;

	// Store strip height
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	// DRAW CENTER LINE
	if( UseCenterLine() )
	{
		HPEN penShadow = ::CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) );
		if( penShadow )
		{
			int nStripCenter = pRectStrip->top + (nStripHeight >> 1);

			HPEN penOld = (HPEN)::SelectObject( hDC, penShadow );
			::SetROP2( hDC, R2_COPYPEN );

			::MoveToEx( hDC, pRectClip->left, nStripCenter, NULL );
			::LineTo( hDC, pRectClip->right, nStripCenter );

			if( penOld )
			{
				::SelectObject( hDC, penOld );
				::DeleteObject( penShadow );
			}
		}
	}

	// Create overlapping Curve pen
	HPEN penOld = NULL;
	HPEN penOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetSysColor(COLOR_WINDOW) );
	if( penOverlappingLine )
	{
		penOld = (HPEN)::SelectObject( hDC, penOverlappingLine );
	}

	// Set up work fields
	long lStripStartClock =0;
	long lStripEndClock = 0;
	long lTimelineClockLength = 0;

	pTimeline->PositionToClocks( pRectClip->left + lXOffset, &lStripStartClock );
	pTimeline->PositionToClocks( pRectClip->right + lXOffset, &lStripEndClock );
	
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	lTimelineClockLength = V_I4(&var);

	lStripEndClock = min( lStripEndClock, lTimelineClockLength );
	lStripStartClock = min( lStripStartClock, lStripEndClock - 1 );

	CRect rect;
	CRect* pCurveRect;
	CPtrList lstRects;

	long lCurveStartClock = 0;
	long lCurveEndClock = 0;

	RECT rectFrame;
	CRect rectSelect;

	BOOL fHaveSelected = FALSE;

	// DRAW UNSELECTED CURVES
	CTrackItem* pTrackItem = NULL;
	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		pTrackItem = (CTrackItem*) m_lstTrackItems.GetNext(position);
		ASSERT(pTrackItem);

		if(pTrackItem->m_fSelected)
		{
			fHaveSelected = TRUE;
		}
		else
		{


			lCurveStartClock = pTrackItem->m_mtStartTime;
			lCurveEndClock = pTrackItem->m_mtEndTime;

			rectFrame = pTrackItem->m_rectFrame;
			rectSelect = pTrackItem->m_rectSelect;

			if( lCurveStartClock <= lStripEndClock )
			{
				// Draw this Curve
				DrawCurve( pTrackItem, hDC, pRectStrip, lXOffset );
				rectFrame = pTrackItem->m_rectFrame;
				rectSelect = pTrackItem->m_rectSelect;

				// Frame intersecting rectangles
				POSITION posRect = lstRects.GetHeadPosition();
				while(posRect)
				{
					CRect* pRect = (CRect*) lstRects.GetNext(posRect);

					// Compute intersection with other Curves
					rect.IntersectRect( pCurveRect, &pTrackItem->m_rectSelect );
									
					// Draw it
					if( rect.left != rect.right || rect.top != rect.bottom )
					{
						rect.left -= lXOffset;
						rect.right -= lXOffset;
						::MoveToEx( hDC, rect.left, rect.bottom, NULL );
						::LineTo( hDC, rect.left, rect.top );
						::LineTo( hDC, rect.right, rect.top );
						::LineTo( hDC, rect.right, rect.bottom );
						::LineTo( hDC, rect.left, rect.bottom );
					}
				}

				// Store this Curve's rectangle
				pCurveRect = new CRect( &pTrackItem->m_rectSelect );
				if( pCurveRect )
				{
					lstRects.AddHead( pCurveRect );
				}
			}

			// Set Curve rectFrame and rectSelect
			pTrackItem->m_rectFrame = rectFrame;
			pTrackItem->m_rectSelect = rectSelect;
		}
	}

	// DRAW SELECTED CURVES
	if( fHaveSelected )
	{
		position = m_lstTrackItems.GetHeadPosition();
		while(position)
		{
			CTrackItem* pTrackItem = (CTrackItem*)m_lstTrackItems.GetNext(position);
			ASSERT(pTrackItem);
			if( pTrackItem->m_fSelected )
			{
				// Make sure Curve is showing
				lCurveStartClock = pTrackItem->m_mtStartTime;
				lCurveEndClock = pTrackItem->m_mtEndTime;

				rectFrame = pTrackItem->m_rectFrame;
				rectSelect = pTrackItem->m_rectSelect;

				if( lCurveEndClock >= lStripStartClock )
				{
					// Draw this Curve
					DrawCurve( pTrackItem, hDC, pRectStrip, lXOffset );
					rectFrame = pTrackItem->m_rectFrame;
					rectSelect = pTrackItem->m_rectSelect;
					
					// Frame intersecting rectangles
					POSITION posRect = lstRects.GetHeadPosition();
					while(posRect)
					{
						pCurveRect = (CRect*)lstRects.GetNext(posRect);

						// Compute intersection with other Curves
						rect.IntersectRect( pCurveRect, &pTrackItem->m_rectSelect );
										
						// Draw it
						if( rect.left != rect.right	|| rect.top != rect.bottom )
						{
							rect.left -= lXOffset;
							rect.right -= lXOffset;
							::MoveToEx( hDC, rect.left, rect.bottom, NULL );
							::LineTo( hDC, rect.left, rect.top );
							::LineTo( hDC, rect.right, rect.top );
							::LineTo( hDC, rect.right, rect.bottom );
							::LineTo( hDC, rect.left, rect.bottom );
						}
					}

					// Store this Curve's rectangle
					pCurveRect = new CRect( &pTrackItem->m_rectSelect );
					if( pCurveRect )
					{
						lstRects.AddTail( pCurveRect );
					}
				}

				// Set Curve rectFrame and rectSelect
				pTrackItem->m_rectFrame = rectFrame;
				pTrackItem->m_rectSelect = rectSelect;
			}
		}
	}

	if( penOld )
	{
		::SelectObject( hDC, penOld );
		::DeleteObject( penOverlappingLine );
	
	}

	while( !lstRects.IsEmpty() )
	{
		pCurveRect = (CRect*)lstRects.RemoveHead();
		delete pCurveRect;
	}


	return S_OK;
}


#define SECOND_LINE_PENSTYLE	PS_SOLID
#define SECOND_LINE_WIDTH		2
#define SECOND_LINE_COLOR		RGB(0,0,0)
#define GRID_LINE_PENSTYLE		PS_SOLID
#define GRID_LINE_WIDTH			1
#define GRID_LINE_COLOR			RGB(204,204,255)

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DrawClockVerticalLines

void CParamStrip::DrawClockVerticalLines( HDC hDC, long lXOffset ) 
{
	// Create the "second" pen
	HPEN hpenSecond = ::CreatePen( SECOND_LINE_PENSTYLE, SECOND_LINE_WIDTH, SECOND_LINE_COLOR );
	if( hpenSecond == NULL )
	{
		return;
	}

	// Create the "grid" pen
	HPEN hpenGrid = ::CreatePen( GRID_LINE_PENSTYLE, GRID_LINE_WIDTH, GRID_LINE_COLOR );
	if( hpenGrid == NULL )
	{
		::DeleteObject( hpenSecond );
		return;
	}

	// Save the current pen and switch to the "second" pen
	HPEN hpenOld = static_cast<HPEN>( ::SelectObject( hDC, hpenSecond ) );

	// Set BkMode
	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Determine end position
	VARIANT var;
	long lEndPosition;
	m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( V_I4(&var), &lEndPosition );

	// Determine start time
	REFERENCE_TIME refTime, refSecond;
	REFERENCE_TIME refGrid = REFCLOCKS_PER_SECOND / m_StripUI.m_nSnapToRefTime_GridsPerSecond;
	m_pTrackMgr->m_pTimeline->PositionToRefTime( rectClip.left + lXOffset, &refTime );
	refSecond = refTime / REFCLOCKS_PER_SECOND;

	char achText[20];
	long lCurPosition;
	long lSecondPosition;

	do
	{
		refTime = refSecond * REFCLOCKS_PER_SECOND;
		m_pTrackMgr->m_pTimeline->RefTimeToPosition( refTime, &lCurPosition );

		if( lCurPosition < lEndPosition )
		{
			// Save position for "second" text
			lSecondPosition = lCurPosition - lXOffset;

			// Draw "second" line
			::SelectObject( hDC, hpenSecond );
			::MoveToEx( hDC, lSecondPosition, 0, NULL );
			::LineTo( hDC, lSecondPosition, m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight );
		
			// Draw "grid" lines
			for( int i = 0 ;  i < m_StripUI.m_nSnapToRefTime_GridsPerSecond ;  i++ )
			{
				refTime += refGrid;
				m_pTrackMgr->m_pTimeline->RefTimeToPosition( refTime, &lCurPosition );

				if( lCurPosition >= lEndPosition )
				{
					break;
				}

				::SelectObject( hDC, hpenGrid );
				::MoveToEx( hDC, lCurPosition - lXOffset, 0, NULL );
				::LineTo( hDC, lCurPosition - lXOffset, m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight );
			}

			// Draw "second" text
			if( refSecond < 60 )
			{
				_snprintf( achText, 10, "%02d", (int)refSecond );
			}
			else
			{
				_snprintf( achText, 10, "%d:%02d", (int)refSecond/60, (int)refSecond%60 );
			}
			::TextOut( hDC, lSecondPosition, m_StripUI.m_lVerticalScrollYPos, achText, strlen(achText) );
		}

		refSecond++;

	} while( lCurPosition < rectClip.right + lXOffset );

	::SetBkMode( hDC, nOldBkMode);
	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpenSecond );
	::DeleteObject( hpenGrid );
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DrawHorizontalLines

void CParamStrip::DrawHorizontalLines(HDC hDC, const RECT &rectClip)
{
	HPEN hpen = ::CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
	if(hpen == NULL )
	{
		return;
	}

	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpen));

	// Initialize rectangle
	RECT rectLayer;
	rectLayer.left = rectClip.left;
	rectLayer.right = rectClip.right;
	rectLayer.bottom = m_StripUI.m_lVerticalScrollYPos;

	// Now, draw all the lines
	rectLayer.top = rectLayer.bottom;
	rectLayer.bottom = rectLayer.top + m_StripUI.m_lStripHeight;

	::MoveToEx( hDC, rectLayer.left, rectLayer.top, NULL );
	::LineTo( hDC, rectLayer.right, rectLayer.top );

	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpen );
}



/////////////////////////////////////////////////////////////////////////////
// CParamStrip::InvertGutterRange

void CParamStrip::InvertGutterRange( HDC hDC, RECT* pRectClip, LONG lXOffset )
{
	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Highlight the selected range (if there is one)
	if(fUseGutterSelectRange)
	{
		if( m_pTrackMgr->m_pTimeline )
		{
			RECT rectHighlight;

			rectHighlight.top = pRectClip->top;
			rectHighlight.bottom = pRectClip->bottom;

			m_pTrackMgr->m_pTimeline->ClocksToPosition( m_lGutterBeginSelect > m_lGutterEndSelect ?
													   m_lGutterEndSelect : m_lGutterBeginSelect,
													   &rectHighlight.left );

			m_pTrackMgr->m_pTimeline->ClocksToPosition( m_lGutterBeginSelect > m_lGutterEndSelect ?
													   m_lGutterBeginSelect : m_lGutterEndSelect,
													   &rectHighlight.right );

			rectHighlight.left -= lXOffset;
			rectHighlight.right -= lXOffset;

			GrayOutRect( hDC, &rectHighlight );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::Draw

HRESULT	STDMETHODCALLTYPE CParamStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that our timeline pointer is valid
	if( m_pTrackMgr == NULL
	||	m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

		// Get Function Bar rectangle
	VARIANT var;
	RECT rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return E_FAIL;
	}

	// Get Curve Strip rectangle
	RECT rectStrip;
	if (!GetStripRect(&rectStrip))
	{
		return E_FAIL;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	::OffsetRect( &rectStrip, -rectFBar.right, -rectStrip.top );
	::OffsetRect( &rectStrip, lLeftPosition, 0 );


	// Set a flag if we should use the gutter range for our selection
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);

	// Get clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		InvertGutterRange( hDC, &rectClip, lXOffset);
		DrawMinimizedStrip( hDC, &rectStrip );
	}
	else
	{
		DrawMaximizedStrip( hDC, sv, &rectStrip, &rectClip, lXOffset );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::HighlightTimelineRange

void CParamStrip::HighlightTimelineRange(HDC hDC, long lXOffset)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	// Highlight the selected range, if there is one.
	bool fUseGutterSelectRange = m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect);
	if( fUseGutterSelectRange )
	{
		RECT rectClip;
		::GetClipBox( hDC, &rectClip );

		RECT rectHighlight;
		rectHighlight.top = m_StripUI.m_lVerticalScrollYPos + 0;
		rectHighlight.bottom = m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight;

		REFERENCE_TIME rtTime;
		MUSIC_TIME mtTime;

		// Convert the selection start point to a pixel position
		m_pTrackMgr->ClocksToUnknownTime( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect, &rtTime );
		SnapUnknownTime( rtTime, &rtTime );
		m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );
		m_pTrackMgr->m_pTimeline->ClocksToPosition( mtTime, &(rectHighlight.left) );

		// Offset the rectangle by the horizontal ofset
		rectHighlight.left -= lXOffset;

		// Check that the highlight rectange is visible
		if( rectHighlight.left < rectClip.right )
		{
			// Convert the selection end point to a pixel position
			m_pTrackMgr->ClocksToUnknownTime( m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect, &rtTime );
			SnapUnknownTime( rtTime, &rtTime );
			SnapUnknownToNextIncrement( rtTime, &rtTime );
			m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );
			m_pTrackMgr->m_pTimeline->ClocksToPosition( mtTime, &(rectHighlight.right) );

			// Offset the rectangle by the horizontal ofset
			rectHighlight.right -= lXOffset;

			// Check that the highlight rectange is visible
			if( rectHighlight.right > rectClip.left )
			{
				// Invert the selected rectangle
				GrayOutRect( hDC, &rectHighlight );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetItemFromPoint

CTrackItem* CParamStrip::GetItemFromPoint( long lPos )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return NULL;
	}

	CTrackItem* pItemReturn = NULL;

	long lMeasure = 0;
	long lBeat = 0;
	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
	if( SUCCEEDED( pTimeline->PositionToMeasureBeat( dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
	{
		pItemReturn = GetTopItemFromMeasureBeat( lMeasure, lBeat );
	}

	return pItemReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetFBName

void CParamStrip::GetFBName( CString& strFBName )
{
	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return;
	}

	CString strTrackGroup, strPChannelName, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	strFBName.Empty();
	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

	// Determine track group text
	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strTrackGroup += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strTrackGroup += strTmp;
	}

	// Determine PChannel text
	strPChannelName = m_pTrackObject->GetPChannelText();

	// Put it all together
	CString sObjectName = m_pTrackObject->GetObjectName();
	CString sStripName = sObjectName + ":" + m_strStripName;
	if(m_StripUI.m_nStripView == SV_MINIMIZED)
	{
		if(sObjectName.IsEmpty())
		{
			sStripName = m_strStripName;
		}
		else
		{
			sStripName = sObjectName;
		}
	}

	if( m_pTrackObject->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_SEGMENT )
	{
		if( strPChannelName.IsEmpty() )
		{
			strFBName.Format( "%s: %s", strTrackGroup,  sStripName );
		}
		else
		{
			strFBName.Format( "%s: %s: %s", strTrackGroup, strPChannelName, sStripName );
		}
	}
	else
	{
		strTmp.Empty();
		if( m_pTrackObject->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			strTmp.LoadString( IDS_BROADCAST_SEG );
		}
		else if( m_pTrackObject->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			strTmp.LoadString( IDS_BROADCAST_PERF );
		}
		if( strPChannelName.IsEmpty() )
		{
			strFBName.Format( "%s: %s: %s", strTrackGroup, strTmp, sStripName );
		}
		else
		{
			strFBName.Format( "%s: %s (%s): %s", strTrackGroup, strTmp, strPChannelName, sStripName );
		}
	}
	
	ASSERT( strFBName.IsEmpty() == FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CParamStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
		case SP_NAME:
		{
			if( m_strStripName.IsEmpty() )
			{
				m_strStripName.LoadString( IDS_STRIP_NAME );
			}

			pvar->vt = VT_BSTR; 

			CString strFBName;
			GetFBName( strFBName );
			V_BSTR(pvar) = strFBName.AllocSysString();
			break;
		}

		case SP_RESIZEABLE:
			// We are resizable
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			//V_BOOL(pvar) = FALSE;
			break;

		case SP_MINMAXABLE:
			// We support Minimize/Maximize
			pvar->vt = VT_BOOL;
			V_BOOL(pvar) = TRUE;
			break;

		case SP_MINIMIZE_HEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = STRIP_MINIMIZE_HEIGHT;
			break;

		case SP_MINHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = STRIP_MIN_HEIGHT;
			break;

		case SP_MAXHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = STRIP_MAX_HEIGHT;
			break;

		case SP_DEFAULTHEIGHT:
			pvar->vt = VT_INT;
			V_INT(pvar) = CRV_DEFAULT_HEIGHT;
			break;

		case SP_CURSOR_HANDLE:
			pvar->vt = VT_I4;
			V_I4(pvar) = (int) m_hCursor;
			break;

		default:
			return CBaseStrip::GetStripProperty( sp, pvar );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CParamStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate our timeline pointer
	if( m_pTrackMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Initialize the return code to SUCCESS
	HRESULT hr = S_OK;

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		switch( nMsg )
		{
			case WM_LBUTTONDOWN:
			case WM_LBUTTONUP:
			case WM_RBUTTONDOWN:
			case WM_MOUSEMOVE:
			case WM_KEYDOWN:
				// Do nothing if strip is minimized
				return S_OK;

			case WM_RBUTTONUP:
				// Only displai right-click context menu if strip is minimized
				POINT pt;
				if( !GetCursorPos( &pt ) )
				{
					hr = E_UNEXPECTED;
					break;
				}
				m_fInFunctionBarMenu = true;
				hr = PostRightClickMenu( pt );
				m_fInFunctionBarMenu = false;
				return S_OK;
		}
	}

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fLeftMouseDown = true;
		hr = OnLButtonDown( wParam, lXPos, lYPos );
		m_lXPos = lXPos;	// need to start drag drop from where selection started
		break;

	/*case WM_LBUTTONDBLCLK:
		m_fLeftMouseDown = true;
		// Use default message handler for WM_LBUTTONDBLCLK
		hr = CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;*/

	case WM_RBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		hr = OnMouseMove( wParam, lParam, lXPos, lYPos );
		break;


	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONUP:
		m_fLeftMouseDown = false;
		hr = OnLButtonUp( wParam, lParam, lXPos, lYPos );
		//m_lXPos = lXPos;
		break;

	case WM_RBUTTONUP:
		// Use default message handler for WM_RBUTTONUP
		hr = CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;

	case WM_SETCURSOR:
		hr = OnSetCursor( lXPos, lYPos );
		break;

	case WM_SIZE:
		if( wParam == SIZE_MAXIMIZED )
		{
			m_pTrackObject->OnChangeParamStripView(SV_NORMAL);
		}
		else if( wParam == SIZE_MINIMIZED )
		{
			m_pTrackObject->OnChangeParamStripView(SV_MINIMIZED);
		}
		else
		{
			if( m_pTrackMgr->m_pTimeline )
			{
				VARIANT var;
				if( SUCCEEDED( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var) ) )
				{
					if( m_StripUI.m_lStripHeight != V_I4(&var) )
					{
						m_StripUI.m_lStripHeight = V_I4(&var);
						m_pTrackMgr->NotifyDataChange(IDS_UNDO_STRIP_RESIZE);
					}
				}
			}
		}
		break;

	case WM_COMMAND:
	{
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode = HIWORD( wParam );	// notification code 
		WORD wID		 = LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{

			case IDM_SNAP_NONE:
			case IDM_SNAP_GRID:
			case IDM_SNAP_BEAT:
			case IDM_SNAP_BAR:
			case IDM_SNAP_SECOND:
			{
				SetSnapTo( wID );
				break;
			}

			case IDM_SNAP_SET_GRID:
			{
				DoGridsPerSecond();
				break;
			}

			case ID_NEW_PARAM:
			{
				m_pTrackMgr->AddNewObject();
				break;
			}

			case ID_DELETE_PARAM:
			{
				m_pTrackMgr->DeleteSelectedStripsFromObjects();
				break;
			}

			case ID_EDIT_INSERT_CURVE:
			{
				hr = Insert();
				break;
			}
			
			case ID_VIEW_PROPERTIES:
				hr = ShowPropertySheet();
				if( SUCCEEDED ( hr ) )
				{
					if( m_fShowItemProps )
					{
						// Change to the item property page
						OnShowItemProperties();

						// Update the property page, if it exists
						if( m_pPropPageMgr )
						{
							m_pPropPageMgr->RefreshData();
						}
					}
					else
					{
						// Change to the track group property page
						OnShowStripProperties();

						// Update the property page, if it exists
						IDMUSProdPropPageManager* pTrackPropPageMgr = m_pTrackMgr->GetPropPageMgr();
						if( pTrackPropPageMgr )
						{
							pTrackPropPageMgr->RefreshData();
						}
					}
				}
				break;

			default:
				// Try the default message handler
				CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;
		}
		break;
	}

	case WM_DESTROY:
		hr = OnDestroy();
		break;

	case WM_CREATE:
		hr = OnCreate();

		// Fall through to CBaseStrip's message handler, since we want it to also
		// handle the WM_CREATE message

	default:
		// Try the default message handler
		// This handles WM_COMMAND and WM_CREATE
		CBaseStrip::OnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::FBOnWMMessage

HRESULT CParamStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Change the property page to the strip (group bits) property page
		OnShowStripProperties();
		StopInsertingCurve();
		break;

	case WM_LBUTTONUP:
		hr = OnLButtonUp(wParam, lParam, lXPos, lYPos);
		break;

	/*case WM_RBUTTONUP:
		hr = OnRButtonUp();
		break;*/

	case WM_MOUSEMOVE:
		hr = OnMouseMove(wParam, lParam, lXPos, lYPos );
		break;

	case WM_RBUTTONUP:
		// Change the property page to the strip (group bits) property page
		OnShowStripProperties();

		// Set the cursor position for the insert operation to -1
		m_lXPos = -1;

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Display a right-click context menu.
		m_fInFunctionBarMenu = true;
		hr = PostRightClickMenu( pt );
		m_fInFunctionBarMenu = false;
		break;

	default:
		return CBaseStrip::FBOnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::Copy

HRESULT CParamStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if there is anything to copy
	HRESULT hr;
	hr = CanCopy();
	if( hr != S_OK )
	{
		// Nothing to copy - return error code
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}


	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get the span of the selected items
	long lStartTime = 0;
	long lEndTime = 0;
	m_pSelectedRegions->GetSpan(lStartTime, lEndTime);

	// Compute the start offset
	REFERENCE_TIME rtStartOffset = 0;
	long lMeasure = 0;
	long lBeat = 0;
	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
	
	pTimeline->ClocksToMeasureBeat(dwGroupBits, 0, lStartTime, &lMeasure, &lBeat);
	m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, 0, 0, &rtStartOffset);
	CTrackItem* pFirstSelectedItem = GetFirstSelectedItem();

	if(pFirstSelectedItem)
	{
		rtStartOffset = pFirstSelectedItem->m_rtTimePhysical - rtStartOffset;
	}

	// Create an IStream to save the selected items in.
	IStream* pStreamCopy = NULL;

	// Verify that we were able to create a stream
	if(FAILED(CreateStreamOnHGlobal(NULL, TRUE, &pStreamCopy)))
	{
		return E_OUTOFMEMORY;
	}


	// Save the selected items into the stream
	if(FAILED(SaveSelectedItems(pStreamCopy, rtStartOffset, NULL)))
	{
		// Save failed
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	// The save succeeded - copy the stream to the clipboard
	hr = CopyDataToClipboard(pITimelineDataObject, pStreamCopy, m_cfParamTrack, m_pTrackMgr, this);

	// Release our pointer to the stream
	pStreamCopy->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CalculateDropTime

REFERENCE_TIME CParamStrip::CalculateDropTime(MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}
	

	REFERENCE_TIME rtDropTime = 0;
	if(m_pTrackMgr->IsRefTimeTrack())
	{
		REFERENCE_TIME rtTime = 0;
		pTimeline->ClocksToRefTime( mtTime, &rtTime );
		rtTime += pCopyPasteUI->m_rtOffset;

		long lMinute, lSec, lGrid, lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );

		switch(m_StripUI.m_nSnapToRefTime)
		{
			case IDM_SNAP_NONE:
			{
				// Nothing to do
				break;
			}

			case IDM_SNAP_GRID:
			{
				m_pTrackMgr->MinSecGridMsToRefTime(this, lMinute, lSec, lGrid, pCopyPasteUI->m_lRefTimeMs, &rtTime);
				break;
			}
			
			case IDM_SNAP_SECOND:
			{
				m_pTrackMgr->MinSecGridMsToRefTime(this, lMinute, lSec, pCopyPasteUI->m_lRefTimeGrid, pCopyPasteUI->m_lRefTimeMs, &rtTime);
				break;
			}
		}

		m_pTrackMgr->RefTimeToUnknownTime(rtTime, &rtDropTime);
	}
	else
	{
		mtTime += pCopyPasteUI->m_mtOffset;

		long lMeasure = 0;
		long lBeat = 0;
		long lGrid = 0;
		long lTick = 0;

		m_pTrackMgr->ClocksToMeasureBeatGridTick(mtTime, &lMeasure, &lBeat, &lGrid, &lTick);

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
			{
				// Nothing to do
				break;
			}

			case IDM_SNAP_GRID:
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks(lMeasure, lBeat, lGrid, pCopyPasteUI->m_lMusicTimeTick, &mtTime);
				break;
			}
			
			case IDM_SNAP_BEAT:
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks(lMeasure, lBeat, pCopyPasteUI->m_lMusicTimeGrid, pCopyPasteUI->m_lMusicTimeTick, &mtTime);
				break;
			}
			
			case IDM_SNAP_BAR:
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks(lMeasure, pCopyPasteUI->m_lMusicTimeBeat, 
															pCopyPasteUI->m_lMusicTimeGrid, pCopyPasteUI->m_lMusicTimeTick,&mtTime);
				break;
			}
		}

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CalculatePasteTime

REFERENCE_TIME CParamStrip::CalculatePasteTime( MUSIC_TIME mtTime, ioCopyPasteUI* pCopyPasteUI )
{
	REFERENCE_TIME rtDropTime;

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( mtTime, &rtTime );

		long lMinute, lSec, lGrid, lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );

		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
												    lSec,
													lGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
			
			case IDM_SNAP_SECOND:
				m_pTrackMgr->MinSecGridMsToRefTime( this,
													lMinute,
													lSec,
													pCopyPasteUI->m_lRefTimeGrid,
													pCopyPasteUI->m_lRefTimeMs,
													&rtTime );
				break;
		}

		m_pTrackMgr->RefTimeToUnknownTime( rtTime, &rtDropTime );
	}
	else
	{
		long lMeasure, lBeat, lGrid, lTick;
		m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  lGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BEAT:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  lBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
			
			case IDM_SNAP_BAR:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure,
														  pCopyPasteUI->m_lMusicTimeBeat,
														  pCopyPasteUI->m_lMusicTimeGrid,
														  pCopyPasteUI->m_lMusicTimeTick,
														  &mtTime );
				break;
		}

		m_pTrackMgr->ClocksToUnknownTime( mtTime, &rtDropTime );
	}

	return rtDropTime;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::PasteAt

HRESULT CParamStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lPasteTime, bool bDropNotPaste, BOOL &fChanged )
{
	// Validate the data object pointer
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}
		
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}


	// Calc rtSnapPasteTime 
	REFERENCE_TIME rtSnapPasteTime = 0;
	if(FAILED(m_pTrackMgr->ClocksToUnknownTime(lPasteTime, &rtSnapPasteTime)))
	{
		return E_FAIL;
	}

	if(FAILED(SnapUnknownTime( rtSnapPasteTime, &rtSnapPasteTime)))
	{
		return E_FAIL;
	}

	// Handle CF_PARAMTRACK
	if(pITimelineDataObject->IsClipFormatAvailable(m_cfParamTrack) == S_OK)
	{
		// Try and read the stream that contains the items
		IStream* pIStream = NULL;
		if(SUCCEEDED(pITimelineDataObject->AttemptRead(m_cfParamTrack, &pIStream)))
		{
			// Read DMUS_FOURCC_COPYPASTE_UI_CHUNK
			ioCopyPasteUI iCopyPasteUI;
			ZeroMemory( &iCopyPasteUI, sizeof(ioCopyPasteUI) );

			IDMUSProdRIFFStream* pIRiffStream = NULL;
			if(FAILED(AllocRIFFStream( pIStream, &pIRiffStream)) || pIRiffStream == NULL)
			{
				return E_OUTOFMEMORY;
			}

			// Remember the stream position
			DWORD dwPos = StreamTell( pIStream );
			
			MMCKINFO ck;
			ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
			if(pIRiffStream->Descend(&ck, NULL, MMIO_FINDCHUNK) == 0)
			{
				DWORD dwByteCount = 0;
				DWORD dwSize = min(ck.cksize, sizeof(ioCopyPasteUI));

				if(FAILED(pIStream->Read( &iCopyPasteUI, dwSize, &dwByteCount)) || dwByteCount != dwSize)
				{
					pIStream->Release();
					return E_FAIL;
				}
			}

			// Release the RIFF stream and reset the stream pointer
			pIRiffStream->Release();
			StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

			// If we're in a drag-drop operation, check if we're dragging from and dropping to this strip
			if(bDropNotPaste && (m_pITargetDataObject == m_pISourceDataObject))
			{
				// Make sure we are /dropping to a different location
				REFERENCE_TIME rtSnapTime;
				if(SUCCEEDED(SnapXPosToUnknownTime(m_lStartDragPosition, &rtSnapTime)))
				{
					if( rtSnapPasteTime == rtSnapTime )
					{
						// Didn't move - exit early
						pIStream->Release();
						return E_FAIL;
					}
				}
			}

			// Load the stream into a list of items
			CTypedPtrList<CPtrList, CTrackItem*> list;
			if(FAILED(LoadList(list, pIStream)))
			{
				pIStream->Release();
				return E_FAIL;
			}

			// Do we need to convert times?
			if(iCopyPasteUI.m_fRefTimeTrack != m_pTrackMgr->IsRefTimeTrack())
			{
				POSITION position = list.GetHeadPosition();
				while(position)
				{
					CTrackItem* pItem = list.GetNext(position);
					ASSERT(pItem);
					if(pItem)
					{
						pItem->SwitchTimeBase();
                        pItem->SetPhysicalTime(pItem->m_rtTimePhysical, pItem->m_rtDuration);
					}
				}
			}

			// Remember the group bits
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

			// Calc rtPasteTime 
			REFERENCE_TIME rtPasteTime;
			if( bDropNotPaste )
			{
				rtPasteTime = CalculateDropTime(lPasteTime, &iCopyPasteUI);
			}
			else
			{
				rtPasteTime = CalculatePasteTime(lPasteTime, &iCopyPasteUI);
			}


			// The length of the segment
			MUSIC_TIME mtSegmentLength = LONG_MAX;
			REFERENCE_TIME rtSegmentLength = 0;
			pTimeline->ClocksToRefTime(mtSegmentLength, &rtSegmentLength); 

			// Check if there are any items to paste
			if(!list.IsEmpty())
			{
				long lMeasure = 0;
				long lBeat = 0;
				long lGrid = 0;
				long lTick= 0;

				// Unselect all items so the only selected items are the dropped or pasted ones
				UnselectAll();

				// Make sure the last item lands in the last beat or sooner
				VARIANT varLength;
				if(SUCCEEDED(pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength)))
				{
					mtSegmentLength = V_I4(&varLength);
					m_pTrackMgr->ClocksToUnknownTime(mtSegmentLength, &rtSegmentLength);

					// Make sure the last item lands in the last beat or sooner
					REFERENCE_TIME rtTimeLastItem = list.GetTail()->m_rtTimePhysical + rtPasteTime;
					if(rtTimeLastItem >= rtSegmentLength)
					{
						m_pTrackMgr->UnknownTimeToMeasureBeatGridTick(rtPasteTime - (rtTimeLastItem - rtSegmentLength),
																	  &lMeasure, &lBeat, &lGrid, &lTick);

						m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, lGrid, lTick, 
																	  &rtPasteTime );

						SnapUnknownTime( rtPasteTime, &rtPasteTime );
					}
				}

				// Make sure the first item lands in the first beat or later
				REFERENCE_TIME rtTimeFirstItem = list.GetHead()->m_rtTimePhysical + rtPasteTime;
				if( rtTimeFirstItem < 0 )
				{
					m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtPasteTime + -rtTimeFirstItem,
																  &lMeasure, &lBeat, &lGrid, &lTick );

					m_pTrackMgr->MeasureBeatGridTickToUnknownTime( lMeasure, lBeat, lGrid, lTick, 
																  &rtPasteTime );

					SnapUnknownTime( rtPasteTime, &rtPasteTime );
				}
			}

			// Check if we're doing a paste
			if(!bDropNotPaste)
			{
				// We're doing a paste, so get the paste type
				TIMELINE_PASTE_TYPE tlPasteType;
				if( FAILED( pTimeline->GetPasteType( &tlPasteType ) ) )
				{
					// Failed to get the paste type, so return with error code
					pIStream->Release();
					return E_FAIL;
				}

				// Check if we're doing a paste->overwrite
				if( tlPasteType == TL_PASTE_OVERWRITE )
				{
					REFERENCE_TIME rtTimeFirstItem = list.GetHead()->m_rtTimePhysical + rtPasteTime;

					long lMeasureStart = 0;
					long lMeasureEnd = 0;
					long lBeatStart = 0;
					long lBeatEnd = 0;
					long lGrid = 0;
					long lTick = 0;
					
					m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtTimeFirstItem,
																  &lMeasureStart, &lBeatStart, &lGrid, &lTick );

					m_pTrackMgr->UnknownTimeToMeasureBeatGridTick( rtTimeFirstItem + iCopyPasteUI.m_rtPasteOverwriteRange,
																  &lMeasureEnd, &lBeatEnd, &lGrid, &lTick );

					// Now, delete any items that fall between the first and last beats we're pasting in
					fChanged = DeleteBetweenMeasureBeats( lMeasureStart, lBeatStart, lMeasureEnd, lBeatEnd );				
				}
			}

			// Iterate throught the list of items we loaded
			while( !list.IsEmpty() )
			{
				// Remove the head of the list
				CTrackItem* pItem = list.RemoveHead();
				ASSERT(pItem);

				// Check if the item will land before the end of the segment
				pItem->m_rtTimePhysical += rtPasteTime;
				if(pItem->m_rtTimePhysical < rtSegmentLength)
				{
					// Recalc m_mtTime fields
					/*MUSIC_TIME mtDuration = pItem->m_mtEndTime - pItem->m_mtStartTime;*/
					
					REFERENCE_TIME rtDuration = pItem->m_rtDuration;
					/*m_pTrackMgr->ClocksToUnknownTime(mtDuration, &rtDuration);*/

					pItem->SetPhysicalTime(pItem->m_rtTimePhysical, rtDuration);
	
					// When pasted or dropped, each item is selected
					pItem->m_fSelected = TRUE;

					InsertByAscendingTime( pItem, TRUE );

					// We changed
					fChanged = TRUE;

				}
				else
				{
					// Item would be pasted beyond the end of the segment - delete it
					delete pItem;
				}
			}
			pIStream->Release();
		}
	}

	if(m_nStripIsDragDropSource)
	{
		// Drag/drop Target and Source are the same strip
		m_nStripIsDragDropSource = 2;
	}

	if( CParamStrip::m_pIDocRootOfDragDropSource &&  CParamStrip::m_pIDocRootOfDragDropSource == m_pTrackMgr->GetDocRootNode())
	{
		// Drag/drop Target and Source are the same file (i.e. Segment)
		CParamStrip::m_fDragDropIntoSameDocRoot = TRUE;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::Paste

HRESULT CParamStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that there is something to paste
	HRESULT hr;
	hr = CanPaste( pITimelineDataObject );
	if( hr != S_OK )
	{
		// Nothing to paste - return an error
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Validate our TrackMgr and Timeline pointers
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}	

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Get a TimelineDataObject, if we don't already have one
	hr = GetTimelineDataObject( pITimelineDataObject, pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if(FAILED(hr) || (pITimelineDataObject == NULL))
	{
		return hr;
	}

	// Convert the paste position to clocks
	long lClocks = 0;
	if(FAILED(pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lClocks)))
	{
		return E_UNEXPECTED;
	}

	// Do the paste
	BOOL fChanged = FALSE;
	hr = PasteAt(pITimelineDataObject, lClocks, false, fChanged);

	// Check if the paste succeeded AND if something was actually pasted
	if(SUCCEEDED(hr) && fChanged)
	{
		// Update the selection regions to only include the selected items
		SelectRegionsFromSelectedItems();

		// Notify the containing segment that we did a paste operation
		m_pTrackMgr->SetLastEdit(IDS_PASTE);
		m_pTrackMgr->TrackDataChanged();

		// Redraw our strip
		pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

		// Ensure the track item property page is visible
		OnShowItemProperties();

		// Refresh the track item property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}

		// Sync with DirectMusic
		m_pTrackMgr->SyncWithDirectMusic();
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::InsertCurve

void CParamStrip::InsertCurve( long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}


	// Get CurveStrip rect
	CRect rectStrip;
	if (!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWnd( lXPos, lYPos );
	pTimeline->StripToWindowPos( (IDMUSProdStrip *)this, &ptWnd );

	// Make sure YPos is in this CurveStrip
	if( ptWnd.y < rectStrip.top || ptWnd.y > rectStrip.bottom )
	{
		// YPos is NOT in this CurveStrip
		return;
	}

	// Make sure XPos is in this CurveStrip
	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lClockLength = V_I4(&var);
	long lXPosClock = 0;

	pTimeline->PositionToClocks( lXPos, &lXPosClock );
	if( lXPosClock < 0
	||  lXPosClock > lClockLength
	||  ptWnd.x < rectStrip.left 
	||  ptWnd.x > rectStrip.right )
	{
		// XPos is NOT in this CurveStrip
		return ;
	}

	IOleWindow* pIOleWindow;

	pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	if( pIOleWindow )
	{
		CWnd wnd;
		HWND hWnd;

		if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
		{
			CPoint point( lXPos, lYPos );

			if( SUCCEEDED ( pTimeline->StripToWindowPos( this, &point ) ) )
			{
				// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
				// We have to call ReleaseCapture(), or the CurveTracker won't work.
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				::ReleaseCapture();

				m_fInsertingCurve = INSERT_CURVE_END_VALUE;

				wnd.Attach( hWnd );
				CCurveTracker curveTracker( &wnd, pTimeline, this, CTRK_INSERTING );
				if( curveTracker.TrackRubberBand( &wnd, point, TRUE ) )
				{
					// Create Direct Music Curve
					CTrackItem* pCurve = new CTrackItem(m_pTrackMgr, this);
					if( pCurve )
					{
						// Fill in Curve values
						pCurve->SetStartEndTime(m_lInsertingStartClock, m_lInsertingEndClock);
						pCurve->SetStartEndValue(m_fltInsertingStartValue, m_fltInsertingEndValue);

						SelectAllCurves( FALSE );
						pCurve->m_fSelected = TRUE;

						m_lstTrackItems.AddTail(pCurve);

						// Redraw CurveStrips
						RefreshCurveStrips();
						RefreshCurvePropertyPage();

						// Let the object know about the changes
						m_pTrackMgr->NotifyDataChange( IDS_UNDO_INSERT_CURVE ); 
					}
				}

				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

				wnd.Detach();
			}
		}

		pIOleWindow->Release();
	}
}



/////////////////////////////////////////////////////////////////////////////
// CParamStrip::Delete

HRESULT CParamStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}
	
	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Delete all selected items
	DeleteSelectedItems();

	// Clear all selection ranges
	m_pSelectedRegions->Clear();

	// Redraw our strip
	pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

	// Refresh the track item property page, if it exists
	if(m_pPropPageMgr)
	{
		m_pPropPageMgr->RefreshData();
	}

	// Notify the containing segment that a delete operation occurred
	m_pTrackMgr->SetLastEdit(IDS_DELETE);
	m_pTrackMgr->TrackDataChanged();

	// Sync with DirectMusic
	m_pTrackMgr->SyncWithDirectMusic();

	// Return that the delete succeeded
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CanPaste

HRESULT CParamStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid timeline pointer
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Make sure the clipboard formats have been registered
	if( RegisterClipboardFormats() == FALSE )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a TimelineDataObject, if we don't already have one
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, pTimeline );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if(FAILED(hr) || pITimelineDataObject == NULL)
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;
	if(pITimelineDataObject->IsClipFormatAvailable(m_cfParamTrack) == S_OK)
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


HRESULT CParamStrip::CanDeleteParameter( void )
{
	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return S_FALSE;
	}

	// If it's the empty dummy track object then we can't delete it...
	if(m_pTrackObject->IsEmptyTrackObject())
	{
		return S_FALSE;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CanInsert

HRESULT CParamStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we have a valid Timeline pointer
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// Do nothing if strip is minimized
	if( m_StripUI.m_nStripView == SV_MINIMIZED)
	{
		return S_FALSE;
	}


	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the position to paste at
	long lInsertTime = 0;
	if(FAILED(pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lInsertTime)))
	{
		return E_UNEXPECTED;
	}

	// Check if the insert position is invalid, or if the user clicked in the function bar
	if(lInsertTime < 0)
	{
		// It's invalid - we can't insert
		return S_FALSE;
	}

	// Convert from a time to a pixel position
	long lPosition = 0;
	if(FAILED(pTimeline->ClocksToPosition( lInsertTime, &lPosition)))
	{
		return E_UNEXPECTED;
	}

	// Get the length of the segment, in clocks
	VARIANT var;
	if( FAILED(pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var)))
	{
		return E_UNEXPECTED;
	}

	// If the position to insert is beyond the end of the segment, return S_FALSE since we can't insert there
	if(lInsertTime >= V_I4(&var))
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DragOver

HRESULT CParamStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( m_pITargetDataObject == NULL )
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::Drop

HRESULT CParamStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	// Verify that we're passed the data object we're expecting
	if( (m_pITargetDataObject == NULL)
	||	(m_pITargetDataObject != pIDataObject) )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		// Try and load the arrow cursor
		HCURSOR hCursor = ::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
		if( hCursor )
		{
			// The the mouse cursor to an arrow cursor
			HCURSOR hCursorOld = ::SetCursor( hCursor );
	
			// Prepare context menu
			HMENU hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
			if( hMenu )
			{
				// Initialize the drop effect to DROPEFFECT_NONE
				m_dwDragRMenuEffect = DROPEFFECT_NONE;

				// Track right context menu for drag-drop via TrackPopupMenu
				HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );

				// Init state of menu items
				if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
				{
					::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
				}

				// Get a window to attach menu to
				HWND hwnd = GetTimelineHWND();
				if( hwnd )
				{
					// Display and track menu
	 				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
								  pt.x, pt.y, 0, hwnd, NULL );

					// Destroy the popup menu
					::DestroyMenu( hMenu );

					// Need to process WM_COMMAND from TrackPopupMenu
					MSG msg;
					while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
					{
						if( msg.message == WM_COMMAND )
						{
							OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
						}
						else
						{
							TranslateMessage( &msg );
							DispatchMessage( &msg );
						}
					}

					// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
					m_dwOverDragEffect = m_dwDragRMenuEffect;

					// Reset the RMenu's effect to DROPEFFECT_NONE
					m_dwDragRMenuEffect = DROPEFFECT_NONE;
				}
			}

			// Reset the cursor to its previous image
			::SetCursor( hCursorOld );

			// Don't destory the hCursor, since it is a shared cursor
		}
	}

	// Check that the user didn't cancel the drag-drop operation
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Allocate a Timleine DataObject
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			// Import the DataObject that was dragged
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				// Compute the time to drop at
				long lPasteTime;
				m_pTrackMgr->m_pTimeline->PositionToClocks( pt.x, &lPasteTime );

				// Actually paste the data
				BOOL fChanged = FALSE;
				hr = PasteAt( pITimelineDataObject, lPasteTime, true, fChanged );

				// Check that the paste succeeded, and that something was actually pasted
				if( SUCCEEDED ( hr ) && fChanged )
				{
					*pdwEffect = m_dwOverDragEffect;

					// Check if the target strip is different from the source strip
					if( m_nStripIsDragDropSource != 2 )
					{
						// Update the list of selected regions to include only the selected items
						SelectRegionsFromSelectedItems();

						if( CParamStrip::m_fDragDropIntoSameDocRoot == FALSE
						||  m_dwOverDragEffect != DROPEFFECT_MOVE )
						{
							// Either we are dropping into a different file,
							// or we are doing a "copy" and there will be no change to the source strip, so....
							// Notify the containing segment that a paste operation occurred
							m_pTrackMgr->SetLastEdit(IDS_PASTE);
							m_pTrackMgr->TrackDataChanged();
						}

						// Redraw our strip
						m_pTrackMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
						
						// If the property sheet is visible, make it display the track item's property page
						OnShowItemProperties();

						// Update the track item's property page, if it exists
						if( m_pPropPageMgr )
						{
							m_pPropPageMgr->RefreshData();
						}

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
				}
			}

			// Release our reference to the Timeline DataObject we allocated
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	// Return the success/failure code
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetData

HRESULT CParamStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	CPropCurve* pPropCurve = (CPropCurve *)*ppData;

	int nNbrSelectedCurves = 0;

	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		CTrackItem* pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);
		ASSERT(pCurve);
		if( pCurve->m_fSelected )
		{

			if( nNbrSelectedCurves == 0 )
			{
				pPropCurve->GetValuesFromCurve( this, pCurve );
			}
			else
			{
				CPropCurve propcurve;
				propcurve.GetValuesFromCurve( this, pCurve );
				*pPropCurve += propcurve;
			}

			nNbrSelectedCurves++;
		}
	}

	if( nNbrSelectedCurves == 0 )
	{
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SetData

HRESULT CParamStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_POINTER;
	}

	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	CPropCurve* pPropCurve = (CPropCurve *)pData;

	CTrackItem* pCurve = NULL;
	DWORD dwChanged = 0;


	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		CTrackItem* pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);
		ASSERT(pCurve);
		if( pCurve->m_fSelected )
		{
			dwChanged |= pPropCurve->ApplyValuesToCurve( this, pCurve );
		}
	}

	// Always refresh property page. (If user tries to change duration to value less than 1,
	// we need to reset the property page to valid values)
	RefreshCurvePropertyPage();

	if( dwChanged )
	{
		// Redraw CurveStrips
		RefreshCurveStrips();

		// Let the object know about the changes
		m_pTrackMgr->NotifyDataChange( IDS_UNDO_CHANGE_CURVE ); 
	}

	return S_OK;

}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnShowProperties

HRESULT STDMETHODCALLTYPE CParamStrip::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pDMProdFramework = m_pTrackMgr->GetFramework();
	ASSERT(pDMProdFramework);
	if(pDMProdFramework == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	if( m_fShowItemProps == FALSE )
	{
		OnShowStripProperties();
		return S_OK;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If item property page manager already in propsheet, refresh and exit
	if( pIPropSheet->IsEqualPageManagerObject( (IDMUSProdPropPageObject*)this ) == S_OK )
	{
		ASSERT( m_pPropPageMgr != NULL );
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
		pIPropSheet->Release();
		return S_OK;
	}

	// release our reference to the property sheet
	pIPropSheet->Release();

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		// Create a new "item" property page manager
		CCurvePropPageMgr* pPPM = new CCurvePropPageMgr( pDMProdFramework, this );

		// Verify that we're not out of memory
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Get the IDMUSProdPropPageManager interface from the property page
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Release the reference created by the contructor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		// If we failed, return a failure code
		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Store the last active tab
	short nActiveTab = CCurvePropPageMgr::sm_nActiveTab;

	// Set the displayed property page to our property page
	pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Set the active tab
	if( SUCCEEDED ( pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		CWnd* pWndHadFocus = CWnd::GetFocus();

		pIPropSheet->SetActivePage( nActiveTab ); 
		RELEASE( pIPropSheet );

		if( pWndHadFocus )
		{
			pWndHadFocus->SetFocus();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CParamStrip::OnRemoveFromPageManager( void )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CanPasteFromData

HRESULT CParamStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	// Check that we're passed a valid IDataObject pointer
	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Get a Timeline DataObject that encapsulates the pIDataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject = NULL;
	HRESULT hr = GetTimelineDataObject( pITimelineDataObject, m_pTrackMgr->m_pTimeline, pIDataObject );

	// Verify that GetTimelineDataObject succeeded, and actually returned a TimelineDataObject pointer
	if( FAILED(hr)
	||	(pITimelineDataObject == NULL) )
	{
		return hr;
	}

	// Check the timeline data object for our clipboard formats
	hr = S_FALSE;
	if( pITimelineDataObject->IsClipFormatAvailable( m_cfParamTrack ) == S_OK )
	{
		// If we found our clipboard format, return S_OK
		hr = S_OK;
	}

	// Release our reference on the Timeline DataObject
	pITimelineDataObject->Release();

	// Return either S_OK or S_FALSE
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnLButtonDown

HRESULT CParamStrip::OnLButtonDown( WPARAM wParam, long lXPos, long lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		return FALSE;
	}

	UnselectGutterRange();

	// Handle inserting a new Curve
	if( m_fInsertingCurve )
	{
		InsertCurve( lXPos, lYPos );
		StopInsertingCurve();
		return S_OK;
	}

	// Get a pointer to the Timeline
	if( pTimeline == NULL )
	{
		return E_FAIL;
	}
	
	CTrackItem* pTrackItem = GetCurveFromPoint( lXPos, lYPos, TRUE );
	WORD wRefreshUI = FALSE;
	
	if (pTrackItem) 
	{		
		// Have we clicked on a curve?
		if (pTrackItem->m_fSelected) 
		{	
			// Convert the frame rect of the curve to window coordinates
			CRect selRect = pTrackItem->m_rectFrame;
			VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
			VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
			
			// create a tracker and find out if we are on a handle or somewhere within the curve
			CCurveTracker curveTracker(&selRect);
			UINT hit = HitTest( curveTracker, lXPos, lYPos );

			switch(hit) 
			{
				case CRectTracker::hitMiddle:
				{
					if (wParam & MK_CONTROL) 
					{
						wRefreshUI |= SelectCurve(pTrackItem, FALSE);
						DragModify(pTrackItem, lXPos, lYPos, CTRK_DRAGGING, true);
					}
					else 
					{
						DragModify(pTrackItem, lXPos, lYPos, CTRK_DRAGGING);
					}
					m_fShowItemProps = true;
					break;
				}

				default:
				{
					wRefreshUI |= SelectAllCurves(FALSE);
					wRefreshUI |= SelectCurve(pTrackItem, TRUE);
					RefreshUI(wRefreshUI);
					DragModify(pTrackItem, lXPos, lYPos, CTRK_DRAGGING_EDGE);
				}
			}
		}
		else {
			
			if (!(wParam & MK_CONTROL)) 
			{
				wRefreshUI |= SelectAllCurves(FALSE);
			}

			wRefreshUI |= SelectCurve(pTrackItem, TRUE);
			RefreshUI(wRefreshUI);
			DragModify(pTrackItem, lXPos, lYPos, CTRK_DRAGGING);
		}

		RefreshUI(wRefreshUI);
		RefreshCurvePropertyPage();
	}
	else 
	{
		
		// user might have clicked on the curve outside of the frame
		// in which case we select the curve only
		CTrackItem* pTrackItem = GetCurveFromPoint( lXPos, lYPos, FALSE );
		if (pTrackItem) 
		{
			if (!(wParam & MK_CONTROL)) 
			{
				wRefreshUI |= SelectAllCurves(FALSE);
			}

			wRefreshUI |= SelectCurve(pTrackItem, !((wParam & MK_CONTROL) && pTrackItem->m_fSelected));
			RefreshUI(wRefreshUI);
		}
		else if( wParam & MK_SHIFT )
		{
			// Shift key is down
			// AMC TODO: Implement shift select
		}
		else
		{
			// Handle curve bounding box selection
			wRefreshUI = SelectAllCurves( FALSE );

			if( pTrackItem )
			{
				wRefreshUI |= SelectCurve( pTrackItem, TRUE );
			}
			else
			{
				// Refresh UI
				RefreshUI(wRefreshUI);

				// Switch to curve strip property page
				RefreshCurvePropertyPage();

				// Create bounding box
				IOleWindow* pIOleWindow = NULL;
				pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
				if( pIOleWindow )
				{
					CWnd wnd;
					HWND hWnd;

					if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
					{
						CPoint point( lXPos, lYPos );

						if( SUCCEEDED ( pTimeline->StripToWindowPos( this, &point ) ) )
						{
							wnd.Attach( hWnd );
							CCurveTracker curveTracker( &wnd, pTimeline, this, CTRK_SELECTING );
							curveTracker.TrackRubberBand( &wnd, point, TRUE );
							wnd.Detach();
						}
					}

					pIOleWindow->Release();
				}
			}
		}

		RefreshUI(wRefreshUI);
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnLButtonUp

HRESULT CParamStrip::OnLButtonUp( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Finish inserting new Curve
	if( m_fInsertingCurve )
	{
		StopInsertingCurve();
		return S_OK;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnRButtonDown

HRESULT CParamStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Unselect all items in the other strips
	UnselectGutterRange();

	// Get the item at the mouse click.
	CTrackItem* pItem = GetCurveFromPoint( lXPos, lYPos, TRUE );

	if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		// Neither control or shift were pressed

		// Check if an item was clicked on
		if( pItem )
		{
			// Check if the item is selected
			if( pItem->m_fSelected == FALSE )
			{
				// Item is not selected, unselect all items
				UnselectAll();

				// Select just this item
				pItem->m_fSelected = TRUE;

				// Add just this beat to the list of selected regions
				m_pSelectedRegions->AddRegion(lXPos);
			}
			// If the item was already selected, do nothing
		}
		else
		{
			// if region not selected, select it, otherwise do nothing

			// Convert the pixel position to a measure and beat
			long lMeasure = 0;
			long lBeat = 0;
			DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
			if( SUCCEEDED( pTimeline->PositionToMeasureBeat(dwGroupBits, 0,lXPos, &lMeasure, &lBeat) ) )
			{
				// Check if this beat is not already selected
				if( !m_pSelectedRegions->Contains(lMeasure, lBeat))
				{
					// This beat is not selected - unselect all beats
					UnselectAll();

					// Now, select just this beat
					m_pSelectedRegions->AddRegion(lXPos);
				}
			}
		}
	}

	// Redraw our strip
	pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	// Switch the property page to the track item's property page
	OnShowItemProperties();

	// Refresh the  property page, if it exists
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnMouseMove

HRESULT CParamStrip::OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	// Handle inserting a new Curve
	if( m_fInsertingCurve == INSERT_CURVE_START_VALUE )
	{
		CPoint ptLeft( lXPos, lYPos );
		CPoint ptRight( -1, -1 );

		OnUpdateInsertCurveValue( ptLeft, ptRight );
		return S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CanCycle

BOOL CParamStrip::CanCycle( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Can't cycle if strip is minimized
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		return FALSE;
	}

	long lMeasure = 0;
	long lBeat = 0;

	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
	if( SUCCEEDED ( pTimeline->PositionToMeasureBeat( dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat ) ) )
	{
		int nCount = 0;
		CTrackItem* pItem;

		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pItem->m_lMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::PostRightClickMenu

HRESULT CParamStrip::PostRightClickMenu( POINT pt )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	m_fInRightClickMenu = TRUE;

	HMENU hMenu = ::LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU));
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

	::EnableMenuItem(hMenuPopup, ID_EDIT_CUT, (CanCut() == S_OK) ? MF_ENABLED : MF_GRAYED);
	::EnableMenuItem(hMenuPopup, ID_EDIT_COPY, (CanCopy() == S_OK) ? MF_ENABLED : MF_GRAYED);

	::EnableMenuItem(hMenuPopup, 2, (CanPaste(NULL) == S_OK) ? MF_ENABLED | MF_BYPOSITION : MF_GRAYED | MF_BYPOSITION);

	::EnableMenuItem(hMenuPopup, ID_EDIT_INSERT_CURVE, (CanInsert() == S_OK) ? MF_ENABLED : MF_GRAYED);
	::EnableMenuItem(hMenuPopup, ID_DELETE_PARAM, (CanDeleteParameter() == S_OK) ? MF_ENABLED : MF_GRAYED);
	::EnableMenuItem(hMenuPopup, ID_EDIT_DELETE, (CanDelete() == S_OK) ? MF_ENABLED : MF_GRAYED);
	::EnableMenuItem(hMenuPopup, ID_EDIT_SELECT_ALL, (IsEmpty()) ? MF_GRAYED : MF_ENABLED);

	::EnableMenuItem(hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED);
	::EnableMenuItem(hMenuPopup, IDM_CYCLE_ITEMS, (CanCycle() == TRUE) ? MF_ENABLED : MF_GRAYED);

	
	// Initialize 'Snap To' popup menu
	HMENU hMenuPopupSnapTo = ::GetSubMenu(hMenuPopup, 11);	// 11 is index of 'Snap To' popup menu
	ASSERT(hMenuPopupSnapTo != NULL);
	if(hMenuPopupSnapTo)
	{
		CString strMenuText;
		if(m_pTrackMgr->IsRefTimeTrack())
		{
			strMenuText.LoadString(IDS_SECOND_TEXT);
			::InsertMenu( hMenuPopupSnapTo, 2, MF_BYPOSITION | MF_STRING, IDM_SNAP_SECOND, strMenuText ); 
			::InsertMenu( hMenuPopupSnapTo, 3, MF_BYPOSITION | MF_SEPARATOR, 0, NULL ); 

			strMenuText.LoadString(IDS_SET_GRID_TEXT);
			::InsertMenu(hMenuPopupSnapTo, 4, MF_BYPOSITION | MF_STRING, IDM_SNAP_SET_GRID, strMenuText); 

			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_NONE, (m_StripUI.m_nSnapToRefTime == IDM_SNAP_NONE) ? MF_CHECKED : MF_UNCHECKED);
			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_GRID, (m_StripUI.m_nSnapToRefTime == IDM_SNAP_GRID) ? MF_CHECKED : MF_UNCHECKED);
			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_SECOND, (m_StripUI.m_nSnapToRefTime == IDM_SNAP_SECOND) ? MF_CHECKED : MF_UNCHECKED);
		}
		else
		{
			strMenuText.LoadString(IDS_BEAT_MENU_TEXT);
			::InsertMenu(hMenuPopupSnapTo, 2, MF_BYPOSITION | MF_STRING, IDM_SNAP_BEAT, strMenuText); 

			strMenuText.LoadString(IDS_BAR_MENU_TEXT);
			::InsertMenu(hMenuPopupSnapTo, 3, MF_BYPOSITION | MF_STRING, IDM_SNAP_BAR, strMenuText); 

			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_NONE, (m_StripUI.m_nSnapToMusicTime == IDM_SNAP_NONE) ? MF_CHECKED : MF_UNCHECKED);
			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_GRID, (m_StripUI.m_nSnapToMusicTime == IDM_SNAP_GRID) ? MF_CHECKED : MF_UNCHECKED);
			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_BEAT, (m_StripUI.m_nSnapToMusicTime == IDM_SNAP_BEAT) ? MF_CHECKED : MF_UNCHECKED);
			::CheckMenuItem(hMenuPopupSnapTo, IDM_SNAP_BAR, (m_StripUI.m_nSnapToMusicTime == IDM_SNAP_BAR) ? MF_CHECKED : MF_UNCHECKED);
		}
	}

	pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
	::DestroyMenu( hMenu );

	m_fInRightClickMenu = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::UnselectGutterRange

void CParamStrip::UnselectGutterRange( void )
{
	// Make sure everything on the timeline is deselected.

	// Flag that we're unselecting all other strips
	m_fSelecting = TRUE;

	// Set the begin and end selection time to 0
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTrackMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );

	// Flags that we're no longer unselecting all other strips
	m_fSelecting = FALSE;
}


// IDropSource helpers

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CreateDataObject

HRESULT	CParamStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that we're passed a valid location to store the IDataObject pointer in
	ASSERT(ppIDataObject);
	if(ppIDataObject == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Initialize the IDataObject pointer to NULL
	*ppIDataObject = NULL;

	// Allocate a Timleine DataObject
	IDMUSProdTimelineDataObject *pITimelineDataObject;
	if( FAILED( m_pTrackMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
	{
		return E_OUTOFMEMORY;
	}

	// Save Selected items into stream
	HRESULT hr = E_FAIL;

	// Allocate a memory stream
	IStream* pIStream = NULL;
	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_FAIL;
	}

	if(SUCCEEDED(pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream)))
	{
		// Get the item at the drag point
		CTrackItem* pItemAtDragPoint = GetItemFromPoint( lPosition );

		// Compute offset
		REFERENCE_TIME rtOffset = 0;
		MUSIC_TIME mtTimeXPos = 0;
		pTimeline->PositionToClocks( lPosition, &mtTimeXPos );
		m_pTrackMgr->ClocksToUnknownTime( mtTimeXPos, &rtOffset );
		rtOffset = pItemAtDragPoint->m_rtTimePhysical - rtOffset;

		// mark the items as being dragged: this used later for deleting items in drag move
		MarkSelectedItems( UD_DRAGSELECT );

		// Save the selected items into a stream
		if(SUCCEEDED(SaveSelectedItems( pIStream, rtOffset, pItemAtDragPoint)))
		{
			// Add the stream to the Timeline DataObject
			if(SUCCEEDED(pITimelineDataObject->AddExternalClipFormat( m_cfParamTrack, pIStream)))
			{
				hr = S_OK;
			}
		}

		// Releas the stream
		pIStream->Release();
	}

	// If we were successful, export the Timeline DataObject into an IDataObject
	if( SUCCEEDED ( hr ) )
	{
		pITimelineDataObject->Export( ppIDataObject );
	}

	// Release the Timeline DataObject
	pITimelineDataObject->Release();

	// Return the success/failure code
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// CParamStrip::DoDragDrop

HRESULT CParamStrip::DoDragDrop(IDMUSProdTimeline* pTimeline, WPARAM wParam, long lXPos)
{
	// Do a drag'n'drop operation

	// Get the item at the point we're dragging from
	CTrackItem* pItem = GetItemFromPoint( lXPos );

	// Check that we found a item, and that it is selected
	if(!pItem || !pItem->m_fSelected)
	{
		// Didn't find a selected item - return that nothing happened
		return S_FALSE;
	}

	// Initialize flag that determines when a successful drop occurs
	bool fDrop = false;

	// Initialize our result code
	HRESULT hr = S_FALSE;

	// Drag-drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Initialize the drop effect to 'none'
	m_dwDropEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	IDropSource*	pIDropSource;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Ensure m_pISourceDataObject is empty
		if( m_pISourceDataObject )
		{
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}

		// Create a data object from the selected items
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );

		// Check if we successfully created a data object
		if(SUCCEEDED(hr))
		{
			// We can always copy items.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;

			// Check if we can cut items
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the items as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.

			// Initialize our DragDropSource flag to 1 (means we are the source of a drag-drop)
			m_nStripIsDragDropSource = 1;

			// Initialize our DragDropSource DocRoot fields
			CParamStrip::m_pIDocRootOfDragDropSource = m_pTrackMgr->GetDocRootNode();
			CParamStrip::m_fDragDropIntoSameDocRoot = FALSE;

			// Save the state of the mouse buttons
			m_dwStartDragButton = (unsigned long)wParam;

			// Save the position the drag started at
			// (used in PasteAt to determine if we dropped in the same beat we dragged from)
			m_lStartDragPosition = lXPos;

			// Initialize the drop effect to 'none'
			DWORD dwEffect = DROPEFFECT_NONE;

			// Actually do the drag-drop operation
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			// Check what happened during the drag-drop operation
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// A drop occurred - save the effect
				m_dwDropEffect = dwEffect;

				// Check if we did a move
				if(dwEffect & DROPEFFECT_MOVE)
				{
					// We moved some items - delete the items we marked earlier
					DeleteMarked(UD_DRAGSELECT);
				}

				// If the effect wasn't 'None', set the drop flag to true
				if(dwEffect != DROPEFFECT_NONE)
				{
					fDrop = true;
				}
				break;
			default:
				// User cancelled the operation, or dropped the items somewhere they didn't belong
				m_dwDropEffect = DROPEFFECT_NONE;
				break;
			}

			// Check if we really did a drop
			if( fDrop )
			{
				// Check if we dropped in the same strip
				if( m_nStripIsDragDropSource == 2 )
				{
					// Source and target are the same strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// We did a move - use the 'Move' undo text
						m_pTrackMgr->SetLastEdit(IDS_UNDO_MOVE);
					}
					else
					{
						// We did a copy - use the 'Insert' undo text
						m_pTrackMgr->SetLastEdit(IDS_INSERT);
					}

					// Notify the containing segment that we changed
					m_pTrackMgr->TrackDataChanged();

					// Update the selection regions to include the selected items
					SelectRegionsFromSelectedItems();

					// If visible, switch the property sheet to the track item property page
					OnShowItemProperties();

					// If it exists, refresh the track item property page
					if( m_pPropPageMgr )
					{
						m_pPropPageMgr->RefreshData();
					}

					// Sync with DirectMusic
					m_pTrackMgr->SyncWithDirectMusic();
				}
				else
				{
					// Target strip is different from source strip
					if( dwEffect & DROPEFFECT_MOVE )
					{
						// Check if we dropped in the same segment
						if( CParamStrip::m_fDragDropIntoSameDocRoot == TRUE )
						{
							// We did a move operation to another strip in the same segment - use the 'Move' undo text
							m_pTrackMgr->SetLastEdit(IDS_UNDO_MOVE);
						}
						else
						{
							// We did a move operation to another strip in a different - use the 'Delete' undo text
							m_pTrackMgr->SetLastEdit(IDS_DELETE);
						}

						// Let our hosting editor know about the changes
						m_pTrackMgr->TrackDataChanged();

						// Sync with DirectMusic
						m_pTrackMgr->SyncWithDirectMusic();
					}
					else
					{
						// Unselect all items, since the user did a copy operation
						UnselectAll();
					}
				}

				// Refresh our strip display
				m_pTrackMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

				// Return that we actually did a drop
				hr = S_OK;
			}
		}

		// Release the IDropSource interface
		pIDropSource->Release();

		// Clear the DragSelect flag from all items
		UnMarkItems(UD_DRAGSELECT); 
	}
	else
	{
		// Couldn't query for IDropSource interface - return failure code
		hr = E_FAIL;
	}

	// Clear the DragDropSource fields
	m_nStripIsDragDropSource = 0;
	CParamStrip::m_pIDocRootOfDragDropSource = NULL;
	CParamStrip::m_fDragDropIntoSameDocRoot = FALSE;
	
	// Return a success or failure code
	return hr;
}



//////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectCurvesInRect

WORD CParamStrip::SelectCurvesInRect( CRect* pRect )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return 0;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return 0;
	}

	WORD wRefreshUI = 0;

	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		CTrackItem* pItem = (CTrackItem*)m_lstTrackItems.GetNext(position);
		ASSERT(pItem);
		if(pItem)
		{
			BOOL bSelect = FALSE;
			CRect rectFrame = pItem->m_rectFrame;
			if(rectFrame.IntersectRect(&rectFrame, pRect))
			{
				bSelect = TRUE;
			}
			else
			{
				bSelect = FALSE;
			}

			wRefreshUI |= SelectCurve(pItem, bSelect);
		}
	}

	return wRefreshUI;
}


////////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectItemsInSelectedRegions

bool CParamStrip::SelectItemsInSelectedRegions()
{
	// Flag set to true if anything changes
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if this item is within a selection region
		if(CListSelectedRegion_Contains(pItem->m_rtTimePhysical))
		{
			// Check if the item is not selected
			if( !pItem->m_fSelected )
			{
				// Item isn't yet selected - select it and set fChanged to true
				pItem->m_fSelected = TRUE;
				fChanged = true;
			}
		}
		else
		{
			// Check if the item is selected
			if( pItem->m_fSelected )
			{
				// Item is selected - deselect it and set fChagned to true
				pItem->m_fSelected = FALSE;
				fChanged = true;
			}
		}
	}

	// return whether or not we changed the selection state of any items
	return fChanged;
}


////////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectRegionsFromSelectedItems

void CParamStrip::SelectRegionsFromSelectedItems( void )
{
	// Clear the list of selected regions
	m_pSelectedRegions->Clear();

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Add the beat the item is in to the list of selected regions.
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *pItem);
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
// CParamStrip::RegisterClipboardFormats

BOOL CParamStrip::RegisterClipboardFormats( void )
{
	// CF_PARAMTRACK
	if( m_cfParamTrack == 0 )
	{
		m_cfParamTrack = RegisterClipboardFormat( CF_PARAMTRACK );
	}

	if( m_cfParamTrack == 0 )
	{ 
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::LoadList

HRESULT CParamStrip::LoadList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO		ck;
	MMCKINFO		ckListTrack;
	MMCKINFO		ckListItem;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	// LoadList does not expect to be called twice on the same object!

	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Load the items
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK:
					{
						DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER iObjectHeader;

						// Read in the item's header structure
						dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER ), ck.cksize );
						hr = pIStream->Read( &iObjectHeader, dwSize, &dwByteCount );

						// Handle any I/O error by returning a failure code
						if( FAILED( hr ) ||  dwByteCount != dwSize )
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
						
						GUID guidObject = m_pTrackObject->GetCLSID();
						if(::IsEqualGUID(guidObject, iObjectHeader.guidObject) == FALSE)
						{
							// This is not our curve data
							hr = E_FAIL;
							goto ON_ERROR;
						}

						break;
					}


					case DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST:
						while( pIRiffStream->Descend( &ckListTrack, &ck, 0 ) == 0 )
						{
							switch( ckListTrack.ckid )
							{
								case DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK:
								{
									DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER iParamHeader;

									// Read in the item's header structure
									dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER ), ckListTrack.cksize );
									hr = pIStream->Read( &iParamHeader, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									// This method called when pasting or dropping items
									// Do not overwrite strip parameters

									if(m_dwParamIndex != iParamHeader.dwIndex)
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									break;
								}

								case DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK:
								{
									// Store size of this chunk
									dwSize = ckListTrack.cksize - 4;

									// Read size of struct
									DWORD dwStructSize;
									hr = pIStream->Read( &dwStructSize, sizeof(DWORD), &dwByteCount );
									//dwSize -= sizeof(DWORD);

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != sizeof(DWORD) )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									// Read all items
									while( dwSize )
									{
										CTrackItem* pNewItem = new CTrackItem( m_pTrackMgr, this );
										if( pNewItem == NULL )
										{
											hr = E_OUTOFMEMORY;
											goto ON_ERROR;
										}
										hr = pNewItem->LoadListItem( pIStream, dwStructSize );
										if( FAILED ( hr ) )
										{
											delete pNewItem;
											goto ON_ERROR;
										}
										list.AddTail( pNewItem );
										dwSize -= dwStructSize;
									}
									break;
								}

								case FOURCC_LIST:
									switch( ckListTrack.fccType )
									{
										case DMUS_FOURCC_STRIP_UI_LIST:
											while( pIRiffStream->Descend( &ckListItem, &ckListTrack, 0 ) == 0 )
											{
												switch( ckListItem.ckid )
												{
													case DMUS_FOURCC_STRIP_UI_CHUNK:
													{
														ioStripUI iStripUI;

														// Read in the item's header structure
														dwSize = min( sizeof( ioStripUI ), ck.cksize );
														hr = pIStream->Read( &iStripUI, dwSize, &dwByteCount );

														// Handle any I/O error by returning a failure code
														if( FAILED( hr )
														||  dwByteCount != dwSize )
														{
															hr = E_FAIL;
															goto ON_ERROR;
														}
														break;
													}
												}

												pIRiffStream->Ascend( &ckListItem, 0 );
											}
											break;
									}
									break;
							}

							pIRiffStream->Ascend( &ckListTrack, 0 );
						}
						break;
				}
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	RELEASE( pIRiffStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SaveList

HRESULT CParamStrip::SaveList( CTypedPtrList<CPtrList, CTrackItem*>& list, IStream* pIStream )
{
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	MMCKINFO ckStrip;
	MMCKINFO ck;
	HRESULT hr = E_FAIL;
	DWORD dwBytesWritten = 0;

	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Try and allocate a RIFF stream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Save the Object header
	MMCKINFO ckObject;
	ckObject.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK;
	if( pIRiffStream->CreateChunk( &ckObject, 0 ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Clear out the structure (clears out the padding bytes as well).
	DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER oObjectHeader;
	m_pTrackObject->GetObjectHeader(oObjectHeader);

	// Write the structure out to the stream
	hr = pIStream->Write( &oObjectHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER) )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK chunk
	if( pIRiffStream->Ascend(&ckObject, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}


	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST list chunk
	ckStrip.fccType = DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST;
	if( pIRiffStream->CreateChunk( &ckStrip, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER oParamHeader;
		ZeroMemory( &oParamHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER) );

		// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER structure
		oParamHeader.dwIndex = m_dwParamIndex;
		oParamHeader.dwFlags = m_dwParamFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oParamHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's design data
	hr = SaveStripDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save the track items in this PChannel
	if( !list.IsEmpty() )
	{
		// Create a chunk to store the list of items 
		MMCKINFO ckItems;
		ckItems.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK;
		if( pIRiffStream->CreateChunk( &ckItems, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write size of the DMUS_IO_PARAMCONTROLTRACK_CURVEINFO struct
		DWORD dwStructSize = sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO);
		DWORD dwBytesWritten;
		hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the item list
		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = list.GetNext( pos );

			// Save each item
			hr = pItem->SaveListItem( pIStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		pIRiffStream->Ascend( &ckItems, 0 );
	}

	// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST list chunk
	if( pIRiffStream->Ascend(&ckStrip, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIRiffStream );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::LoadStrip

HRESULT CParamStrip::LoadStrip( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
	MMCKINFO		ck;
	MMCKINFO		ckList;
	DWORD			dwByteCount;
	DWORD			dwSize;
	HRESULT			hr = E_FAIL;

	if( pIRiffStream == NULL 
	||  pckParent == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	m_fInsertingCurve = FALSE;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Load the items
	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK:
			{
				DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER iParamHeader;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER ), ck.cksize );
				hr = pIStream->Read( &iParamHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwParamIndex = iParamHeader.dwIndex;
				m_dwParamFlagsDM = iParamHeader.dwFlags;
				break;
			}

			case DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK:
			{
				// Store size of this chunk
				dwSize = ck.cksize - 4;

				// Read size of struct
				DWORD dwStructSize = 0;
				hr = pIStream->Read( &dwStructSize, sizeof(DWORD), &dwByteCount );
				//dwSize -= sizeof(DWORD);

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != sizeof(DWORD) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Read all items
				while( dwSize )
				{
					CTrackItem* pNewItem = new CTrackItem( m_pTrackMgr, this );
					if( pNewItem == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}
					hr = pNewItem->LoadTrackItem( pIStream, dwStructSize );
					if( FAILED ( hr ) )
					{
						delete pNewItem;
						goto ON_ERROR;
					}
					InsertByAscendingTime( pNewItem, FALSE );
					dwSize -= dwStructSize;
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_STRIP_UI_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_STRIP_UI_CHUNK:
								{
									ioStripUI iStripUI;

									// Read in the item's header structure
									dwSize = min( sizeof( ioStripUI ), ck.cksize );
									hr = pIStream->Read( &iStripUI, dwSize, &dwByteCount );

									// Handle any I/O error by returning a failure code
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										hr = E_FAIL;
										goto ON_ERROR;
									}

									m_StripUI.m_dblVerticalZoom = iStripUI.m_dblVerticalZoom;
									m_StripUI.m_lStripHeight = iStripUI.m_lStripHeight;
									m_StripUI.m_nStripView = iStripUI.m_nStripView;
									m_StripUI.m_nSnapToRefTime = iStripUI.m_nSnapToRefTime;
									m_StripUI.m_nSnapToMusicTime = iStripUI.m_nSnapToMusicTime;
									m_StripUI.m_dwFlagsUI = iStripUI.m_dwFlagsUI;
									m_StripUI.m_nSnapToRefTime_GridsPerSecond = iStripUI.m_nSnapToRefTime_GridsPerSecond;

									if( m_StripUI.m_nSnapToRefTime == 0 )
									{
										m_StripUI.m_nSnapToRefTime = IDM_SNAP_GRID;
									}

									if( m_StripUI.m_nSnapToMusicTime == 0 )
									{
										m_StripUI.m_nSnapToMusicTime = IDM_SNAP_GRID;
									}

									if( m_StripUI.m_nSnapToRefTime_GridsPerSecond == 0 )
									{
										m_StripUI.m_nSnapToRefTime_GridsPerSecond = DEFAULT_NBR_GRIDS_PER_SECOND;
									}

									break;
								}
								
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strStripName );
									break;
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
	RELEASE( pIStream );

	hr = GetParamInfoFromCLSID(&m_ParamInfo);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SaveStrip

HRESULT CParamStrip::SaveStrip( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ckStrip;
	MMCKINFO ck;
	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST list chunk
	ckStrip.fccType = DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST;
	if( pIRiffStream->CreateChunk( &ckStrip, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER oParamHeader;
		ZeroMemory( &oParamHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER) );

		// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER structure
		oParamHeader.dwIndex = m_dwParamIndex;
		oParamHeader.dwFlags = m_dwParamFlagsDM;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oParamHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's design data
	if( ftFileType == FT_DESIGN )
	{
		hr = SaveStripDesignData( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save the track items in this PChannel
	if( !m_lstTrackItems.IsEmpty() )
	{
		// Create a chunk to store the list of items 
		MMCKINFO ckItems;
		ckItems.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK;
		if( pIRiffStream->CreateChunk( &ckItems, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write size of the DMUS_IO_PARAMCONTROLTRACK_CURVEINFO struct
		DWORD dwStructSize = sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO);
		DWORD dwBytesWritten;
		hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Iterate through the item list
		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

			// Save each item
			hr = pItem->SaveTrackItem( pIStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
		
		pIRiffStream->Ascend( &ckItems, 0 );
	}

	// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST list chunk
	if( pIRiffStream->Ascend(&ckStrip, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SaveStripDesignData

HRESULT CParamStrip::SaveStripDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ckMain;
	MMCKINFO ck;
	HRESULT hr;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Create the DMUS_FOURCC_STRIP_UI_LIST list chunk
	ckMain.fccType = DMUS_FOURCC_STRIP_UI_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the DMUS_FOURCC_STRIP_UI_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_STRIP_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Make sure we are saving the latest information
		if( m_pTrackMgr
		&&  m_pTrackMgr->m_pTimeline )
		{
			TimelineToStripUI();
		}

		// Clear out the structure (clears out the padding bytes as well).
		ioStripUI oStripUI;
		ZeroMemory( &oStripUI, sizeof(ioStripUI) );

		// Fill in the members of the ioStripUI structure
		oStripUI.m_dblVerticalZoom = m_StripUI.m_dblVerticalZoom;
		oStripUI.m_lStripHeight = m_StripUI.m_lStripHeight;
		oStripUI.m_nStripView = m_StripUI.m_nStripView;
		oStripUI.m_dwFlagsUI = m_StripUI.m_dwFlagsUI;
		oStripUI.m_nSnapToRefTime = m_StripUI.m_nSnapToRefTime;
		oStripUI.m_nSnapToMusicTime = m_StripUI.m_nSnapToMusicTime;
		oStripUI.m_nSnapToRefTime_GridsPerSecond = m_StripUI.m_nSnapToRefTime_GridsPerSecond;


		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oStripUI, sizeof(ioStripUI), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioStripUI) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_STRIP_UI_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the strip's name
	if( !m_strStripName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strStripName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Ascend out of the DMUS_FOURCC_STRIP_UI_LIST list chunk
	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnShowStripProperties

void CParamStrip::OnShowStripProperties()
{
	m_fShowItemProps = false;

	if( m_pTrackMgr )
	{
		m_pTrackMgr->SetParamStripForPropSheet(this);
		m_pTrackMgr->OnShowProperties();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnShowItemProperties

void CParamStrip::OnShowItemProperties()
{
	if( IsSelected() == FALSE )
	{
		// Switch the property page to the strip's property page
		OnShowStripProperties();
		return;
	}

	m_fShowItemProps = true;

	OnShowProperties();
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::IsSelected

bool CParamStrip::IsSelected()
{
	// If anything is selected, return true
	
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Item is selected - return true
			return true;
		}
	}

	// No items selected - return false
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::IsEmpty

bool CParamStrip::IsEmpty()
{
	return m_lstTrackItems.IsEmpty() ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectSegment

// Return true if anything changed
bool CParamStrip::SelectSegment( MUSIC_TIME mtBeginTime, MUSIC_TIME mtEndTime )
{
	ASSERT(m_pTrackMgr);
	if( m_pTrackMgr == NULL)
	{
		return false;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL )
	{
		return false;
	}

	REFERENCE_TIME rtTime = 0;

	// Snap the start point
	m_pTrackMgr->ClocksToUnknownTime( mtBeginTime, &rtTime );
	SnapUnknownTime( rtTime, &rtTime );
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtBeginTime );

	// Snap the end point
	m_pTrackMgr->ClocksToUnknownTime( mtEndTime, &rtTime );
	SnapUnknownTime( rtTime, &rtTime );
	SnapUnknownToNextIncrement( rtTime, &rtTime );
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtEndTime );
	mtEndTime--;

	// Convert the passed in times to a generic time class
	CMusicTimeConverter cmtBeg(mtBeginTime);
	CMusicTimeConverter cmtEnd(mtEndTime);

	// Create a region that contains the selected time
	CSelectedRegion region(cmtBeg, cmtEnd);

	// Add the region to the list of selected regions
	m_pSelectedRegions->AddRegion(region);

	// Select all items in the list of selected regions
	// This will return true if the selection state of any item changed
	return SelectItemsInSelectedRegions();
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::UnselectAll

void CParamStrip::UnselectAll()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selection flag for each item 
		m_lstTrackItems.GetNext( pos )->m_fSelected = FALSE;
	}

	// Clear the list of selected regions
	m_pSelectedRegions->Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DeleteBetweenMeasureBeats

bool CParamStrip::DeleteBetweenMeasureBeats( long lmStart, long lbStart, long lmEnd, long lbEnd )
{
	// Initially, nothing changed
	bool fChanged = false;

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while(pos)
	{
		// Save current position
		POSITION posTemp = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item's measure value is before the start measure
		if( pItem->m_lMeasure < lmStart )
		{
			// Too early - keep looking
			continue;
		}

		// Check if the item's measure value is after the end measure
		if( pItem->m_lMeasure > lmEnd )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// If the item is in the start measure, check if it is before the start beat
		if( ( pItem->m_lMeasure == lmStart )
		&&	( pItem->m_lBeat < lbStart ) )
		{
			// Too early - keep looking
			continue;
		}

		// If the item is in the end measure, check if it is after the end beat
		if( ( pItem->m_lMeasure == lmEnd)
		&&	( pItem->m_lBeat > lbEnd ) )
		{
			// Too late - done looking (since the list is sorted)
			break;
		}

		// Within the given range, delete the item
		m_lstTrackItems.RemoveAt(posTemp);
		delete pItem;
		fChanged = true;
	}

	// Return whether or not anything changed
	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::InsertByAscendingTime

void CParamStrip::InsertByAscendingTime( CTrackItem* pItemToInsert, BOOL fPaste )
{
	// Ensure the pItemToInsert pointer is valid
	if ( pItemToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CTrackItem* pItem;
	POSITION posCurrent, posNext = m_lstTrackItems.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pItem = m_lstTrackItems.GetNext( posNext );

		if( fPaste )
		{
			if( pItem->m_mtStartTime == pItemToInsert->m_mtStartTime )
			{
				// Replace item
				m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
				m_lstTrackItems.RemoveAt( posCurrent );
				delete pItem;
				return;
			}
		}

		if( pItem->m_mtStartTime > pItemToInsert->m_mtStartTime )
		{
			// Insert before posCurrent (which is the position of pItem)
			m_lstTrackItems.InsertBefore( posCurrent, pItemToInsert );
			return;
		}
	}

	// pItemToInsert is later than all items in the list, add it at the end of the list
	m_lstTrackItems.AddTail( pItemToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnUpdate

HRESULT CParamStrip::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	HRESULT hr = E_INVALIDARG;
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If the update isn't for our strip, exit
	DWORD dwTrackGroupBits = m_pTrackMgr->GetGroupBits();
	if( !(dwGroupBits & dwTrackGroupBits) )
	{
		return E_INVALIDARG;
	}

// TODO - Do we need Framework messages?????
/*
	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was removed from the Project Tree
						pItem->SetFileReference( NULL );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted) )
						{
							m_pTrackMgr->m_nLastEdit = IDS_UNDO_DELETE_WAVE;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// This file was replaced in the Project Tree, re-establish the link
						pItem->SetFileReference( (IDMUSProdNode *)pFrameworkMsg->pData );

						m_pTrackMgr->m_nLastEdit = IDS_UNDO_REPLACE_WAVE;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find the items that changed and update them
				POSITION pos = m_lstTrackItems.GetHeadPosition();
				while( pos )
				{
					CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

					if( pItem
					&&  pItem->m_FileRef.pIDocRootNode == pINode )
					{
						// Set undo text resource id
						m_pTrackMgr->m_nLastEdit = IDS_UNDO_CHANGE_WAVE_LINK;
						hr = S_OK;
					}
				}
			}
		}

		RELEASE( pINode );

		if( SUCCEEDED ( hr ) )
		{
			// Let our hosting editor know about the changes
			if( hr == S_OK )
			{
				m_pTrackMgr->OnDataChanged();
			}

			if( m_pTrackMgr->m_pTimeline )
			{
				m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
			}

			// Update the property page
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}

			m_pTrackMgr->SyncWithDirectMusic();
		}
	}
*/

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SaveSelectedItems

HRESULT CParamStrip::SaveSelectedItems( LPSTREAM pIStream, REFERENCE_TIME rtOffset, CTrackItem* pItemAtDragPoint )
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Create a list to store the items to save in
	CTypedPtrList<CPtrList, CTrackItem*> lstItemsToSave;

	// Iterate throught the list of items
	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		// Get a pointer to each item
		CTrackItem* pItem = m_lstTrackItems.GetNext(position);

		// Check if the item is selected
		if(pItem->m_fSelected )
		{
			// Add the item to the list of items to save
			CTrackItem* pNewItem = new CTrackItem(m_pTrackMgr, this, *pItem);
			if(pNewItem)
			{
				// TODO!!!   Put back
				//mtPasteOverwriteRange = max( mtPasteOverwriteRange, );
				lstItemsToSave.AddTail( pNewItem );
			}
		}
	}

	// Get item for DMUS_FOURCC_COPYPASTE_UI_CHUNK
	CTrackItem* pCopyPasteItem = pItemAtDragPoint;
	if(pCopyPasteItem == NULL)
	{
		if( lstItemsToSave.IsEmpty() == FALSE )
		{
			pCopyPasteItem = lstItemsToSave.GetHead();
		}
	}

	// Try and allocate a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(FAILED(AllocRIFFStream( pIStream, &pIRiffStream)) || pIRiffStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();

	// Create DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_COPYPASTE_UI_CHUNK;
	if(pIRiffStream->CreateChunk(&ck, 0) != 0)
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	MUSIC_TIME mtPasteOverwriteRange = -1;

	// If range selected via timeline, use it
	// TODO!!!   Put back
	//if( m_bGutterSelected && (m_lGutterBeginSelect != m_lGutterEndSelect) )
	{
		long lStartTime = 0;
		long lEndTime = 0;
		m_pSelectedRegions->GetSpan( lStartTime, lEndTime );

		// Compute the start offset
		MUSIC_TIME mtStartOffset = 0;
		long lMeasure = 0;
		long lBeat = 0;
		pTimeline->ClocksToMeasureBeat(dwGroupBits, 0, lStartTime, &lMeasure, &lBeat);
		m_pTrackMgr->MeasureBeatGridTickToClocks(lMeasure, lBeat, 0, 0, &mtStartOffset);

		// Compute the end offset
		MUSIC_TIME mtEndOffset = 0;
		pTimeline->ClocksToMeasureBeat(dwGroupBits, 0, lEndTime, &lMeasure, &lBeat);
		m_pTrackMgr->MeasureBeatGridTickToClocks(lMeasure, (lBeat + 1), 0, 0, &mtEndOffset);

		mtPasteOverwriteRange = mtEndOffset - mtStartOffset;
	}

	// Clear out the structure (clears out the padding bytes as well).
	ioCopyPasteUI oCopyPasteUI;
	ZeroMemory( &oCopyPasteUI, sizeof(ioCopyPasteUI) );

	// Fill in the members of the ioCopyPasteUI structure
	if(pCopyPasteItem)
	{
		long lMinute = 0;
		long lMeasure = 0;

		m_pTrackMgr->UnknownTimeToRefTime( rtOffset, &oCopyPasteUI.m_rtOffset );
		m_pTrackMgr->UnknownTimeToRefTime( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_rtStartTime );
		m_pTrackMgr->RefTimeToMinSecGridMs( this, oCopyPasteUI.m_rtStartTime, &lMinute, &oCopyPasteUI.m_lRefTimeSec,
										   &oCopyPasteUI.m_lRefTimeGrid, &oCopyPasteUI.m_lRefTimeMs );

		m_pTrackMgr->UnknownTimeToClocks( rtOffset, &oCopyPasteUI.m_mtOffset );
		m_pTrackMgr->UnknownTimeToClocks( pCopyPasteItem->m_rtTimePhysical, &oCopyPasteUI.m_mtStartTime );
		m_pTrackMgr->ClocksToMeasureBeatGridTick( oCopyPasteUI.m_mtStartTime, &lMeasure, &oCopyPasteUI.m_lMusicTimeBeat,
												 &oCopyPasteUI.m_lMusicTimeGrid, &oCopyPasteUI.m_lMusicTimeTick );

	}
	
	pTimeline->ClocksToRefTime(mtPasteOverwriteRange, &oCopyPasteUI.m_rtPasteOverwriteRange);
	oCopyPasteUI.m_mtPasteOverwriteRange = mtPasteOverwriteRange;
	oCopyPasteUI.m_fRefTimeTrack = m_pTrackMgr->IsRefTimeTrack();

	// Write the structure out to the stream
	DWORD dwBytesWritten = 0;
	HRESULT hr = pIStream->Write( &oCopyPasteUI, sizeof(ioCopyPasteUI), &dwBytesWritten);
	if(FAILED(hr) ||  dwBytesWritten != sizeof(ioCopyPasteUI))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Ascend out of the DMUS_FOURCC_COPYPASTE_UI_CHUNK chunk
	if(pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Check that anything is selected
	if(lstItemsToSave.IsEmpty())
	{
		pIRiffStream->Release();
		return S_FALSE;
	}

	// For each item in lstItemsToSave, subtract rtOffset from m_rtTimePhysical
	REFERENCE_TIME rtNormalizeOffset = 0;
	if(pCopyPasteItem == NULL)
	{
		ASSERT( 0 );
		rtNormalizeOffset = 0;
	}
	else
	{
		rtNormalizeOffset = pCopyPasteItem->m_rtTimePhysical;
	}

	NormalizeList(pTimeline, dwGroupBits, lstItemsToSave, rtNormalizeOffset );

	// Save the list of items into pIStream
	hr = SaveList(lstItemsToSave, pIStream);

	// Empty the temporary list of items
	EmptyList(lstItemsToSave);

	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CycleItems

HRESULT CParamStrip::CycleItems( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if( m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure = 0;
	long lBeat = 0;
	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
	HRESULT hr = pTimeline->PositionToMeasureBeat( dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CTrackItem* pFirstItem = NULL;
		CTrackItem* pSecondItem = NULL;
		CTrackItem* pItem;

		hr = E_FAIL;

		POSITION pos = m_lstTrackItems.GetHeadPosition();
		while( pos )
		{
			pItem = m_lstTrackItems.GetNext( pos );

			if( pItem->m_lMeasure == lMeasure
			&&  pItem->m_lBeat == lBeat )
			{
				if( pFirstItem == NULL )
				{
					pFirstItem = pItem;
				}
				else if( pSecondItem == NULL )
				{
					pSecondItem = pItem;
				}

				if( pItem->m_wFlagsUI & RF_TOP_ITEM )
				{
					if( pos )
					{
						// Cycle to next item if on same measure/beat
						CTrackItem* pNextItem = GetNextItem( pos );
						if( pNextItem )
						{
							if( pNextItem->m_lMeasure == lMeasure
							&&  pNextItem->m_lBeat == lBeat )
							{
								UnselectAll();
								pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
								pNextItem->m_fSelected = TRUE;
								pNextItem->m_wFlagsUI |= RF_TOP_ITEM;
								hr = S_OK;
								break;
							}
						}
					}

					// Cycle to first item on same measure/beat
					UnselectAll();
					pItem->m_wFlagsUI &= ~RF_TOP_ITEM;
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
					break;
				}
			}

			if( pItem->m_lMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondItem )
				{
					pSecondItem->m_fSelected = TRUE;
					pSecondItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				else if( pFirstItem )
				{
					pFirstItem->m_fSelected = TRUE;
					pFirstItem->m_wFlagsUI |= RF_TOP_ITEM;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Update the selection regions to include just this selected item
		SelectRegionsFromSelectedItems();

		// Redraw the strip
		m_pTrackMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::RecomputeMeasureBeats

void CParamStrip::RecomputeMeasureBeats()
{
	CTrackItem* pItem;
	long lMeasure;
	long lBeat;
	long lTick;

	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return;
	}

	// Recompute measure/beat of all items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		pItem = m_lstTrackItems.GetNext( pos );

		m_pTrackMgr->ClocksToMeasureBeatTick( pItem->m_mtStartTime, &lMeasure, &lBeat, &lTick ); 
		pItem->m_lMeasure = lMeasure;
		pItem->m_lBeat = lBeat;
		pItem->m_lTick = lTick;
		
		pItem->UpdateTimeFieldsFromMeasureBeatTick();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetNextGreatestUniqueTime

MUSIC_TIME CParamStrip::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime = 0;

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return 0;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return 0;
	}

	// Get next greatest unique time
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		if( pItem->m_lMeasure > lMeasure )
		{
			break;
		}

		m_pTrackMgr->MeasureBeatTickToClocks( pItem->m_lMeasure, 0, 0, &mtTime );

		DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
		pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pItem->m_lMeasure == lMeasure
		&&  pItem->m_lBeat == lBeat )
		{
			lTick = pItem->m_lTick + 1;

			// Take care of measure/beat rollover
			m_pTrackMgr->MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	m_pTrackMgr->MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::RecomputeTimes

bool CParamStrip::RecomputeTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;

	bool fChanged = false;

	if( m_pTrackMgr == NULL )
	{
		ASSERT( 0 );
		return FALSE;
	}

	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Save our current position
		POSITION pos2 = pos;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Make sure measure and beat are valid
		if( pItem->m_lMeasure >= 0
		&&  pItem->m_lBeat >= 0 )
		{
			// Using the item's current measure, beat, tick settings, determine which measure, bet and tick
			// the item will end up on
			m_pTrackMgr->MeasureBeatTickToClocks( pItem->m_lMeasure, pItem->m_lBeat, pItem->m_lTick, &mtTime );  
			m_pTrackMgr->ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			// Check if either the measure or beat were changed
			if( pItem->m_mtStartTime != mtTime
			||	pItem->m_lMeasure != lMeasure
			||	pItem->m_lBeat != lBeat
			||	pItem->m_lTick != lTick )
			{
				// Remove the itme from the list
				m_lstTrackItems.RemoveAt( pos2 );

				// The measure of the item changed
				if( pItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// items on beat 7 would end up on next measure's beat 3
					while( pItem->m_lMeasure != lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						m_pTrackMgr->MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						m_pTrackMgr->ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				m_pTrackMgr->ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

				pItem->m_mtStartTime = mtTime;
				pItem->m_lMeasure = lMeasure;
				pItem->m_lBeat = lBeat;
				pItem->m_lTick = lTick;
				fChanged = TRUE;

				InsertByAscendingTime( pItem, FALSE );
			}
		}
	}

	// Return whether or not anything changed
	return fChanged;
}




/////////////////////////////////////////////////////////////////////////////
// CParamStrip::MarkSelectedItems

// ORs dwFlags with the m_dwBits of each selected item
void CParamStrip::MarkSelectedItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// It's selected - update m_dwBits
			pItem->m_dwBitsUI |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DeleteMarked

// deletes items marked by given flag
void CParamStrip::DeleteMarked( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if any of the specified dwFlags are set in this item
		if( pItem->m_dwBitsUI & dwFlags )
		{
			// At least one of the flags in dwFlags is set, remove the item
			m_lstTrackItems.RemoveAt(pos2);
			delete pItem;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DeleteSelectedItems

void CParamStrip::DeleteSelectedItems()
{
	// Start iterating through the list of items
	POSITION pos1 = m_lstTrackItems.GetHeadPosition();
	while( pos1 )
	{
		// Save the current position
		POSITION pos2 = pos1;

		// Get a pointer to the current item
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos1 );

		// Check if the current item is selected
		if( pItem->m_fSelected )
		{
			// This item is selected, remove it from the list
			m_lstTrackItems.RemoveAt( pos2 );
			delete pItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetFirstSelectedItem

CTrackItem* CParamStrip::GetFirstSelectedItem()
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Get a pointer to this lyic
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );

		// Check if the item is selected
		if( pItem->m_fSelected )
		{
			// Item is selected, return a pointer to it
			return pItem;
		}
	}

	// No items are selected, return NULL
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::UnMarkItems

// unmarks flag m_dwUndermined field CTrackItems in list
void CParamStrip::UnMarkItems( DWORD dwFlags )
{
	// Iterate through the list of items
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		// Clear the selected flags in each item
		m_lstTrackItems.GetNext( pos )->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::TimelineToStripUI

void CParamStrip::TimelineToStripUI( void )
{
	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return;
	}

	VARIANT var;

	// m_StripUI.m_nStripView handled by WM_SIZE 
	// m_StripUI.m_lStripHeight handled by WM_SIZE 

	// Initialize state flags
	m_StripUI.m_dwFlagsUI = 0;
		
	// Active strip?
	if( SUCCEEDED ( m_pTrackMgr->m_pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		IUnknown* pIUnknown = V_UNKNOWN(&var);
		if( pIUnknown )
		{
			IDMUSProdStrip* pIActiveStrip;
			if( SUCCEEDED ( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIActiveStrip ) ) )
			{
				if( pIActiveStrip == (IDMUSProdStrip *)this )
				{
					m_StripUI.m_dwFlagsUI |= STRIPUI_ACTIVESTRIP;
				}

				RELEASE( pIActiveStrip );
			}
			
			RELEASE( pIUnknown );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::StripUIToTimeline

void CParamStrip::StripUIToTimeline( void )
{
	if( m_pTrackMgr == NULL
	||  m_pTrackMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return;
	}

	VARIANT var;

	// Set strip view
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		var.vt = VT_I4;
		V_I4(&var) = m_StripUI.m_nStripView;
		m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIPVIEW, var );
	}

	// Set strip height
	if( m_StripUI.m_nStripView != SV_MINIMIZED )
	{
		var.vt = VT_I4;
		V_I4(&var) = m_StripUI.m_lStripHeight;
		m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, var );
	}

	// Set active strip
	// Other strips do not reset the active strip
//	if( m_StripUI.m_dwFlagsUI & STRIPUI_ACTIVESTRIP )
//	{
//		var.vt = VT_UNKNOWN;
//		if( SUCCEEDED( QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
//		{
//			m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
//		}
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnCreate

HRESULT CParamStrip::OnCreate( void )
{
	// Register our clipboard formats
	RegisterClipboardFormats();

	// Load button bitmaps
	if( InterlockedIncrement( &sm_lBitmapRefCount ) == 1 )
	{
		BITMAP bmParam;
		if( sm_bmpZoomInBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpZoomInBtnUp.LoadBitmap( IDB_ZOOMIN_UP );
			sm_bmpZoomInBtnUp.GetBitmap( &bmParam );
			sm_bmpZoomInBtnUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( sm_bmpZoomInBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpZoomInBtnDown.LoadBitmap( IDB_ZOOMIN_DOWN );
			sm_bmpZoomInBtnDown.GetBitmap( &bmParam );
			sm_bmpZoomInBtnDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( sm_bmpZoomOutBtnUp.GetSafeHandle() == NULL )
		{
			sm_bmpZoomOutBtnUp.LoadBitmap( IDB_ZOOMOUT_UP );
			sm_bmpZoomOutBtnUp.GetBitmap( &bmParam );
			sm_bmpZoomOutBtnUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( sm_bmpZoomOutBtnDown.GetSafeHandle() == NULL )
		{
			sm_bmpZoomOutBtnDown.LoadBitmap( IDB_ZOOMOUT_DOWN );
			sm_bmpZoomOutBtnDown.GetBitmap( &bmParam );
			sm_bmpZoomOutBtnDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnDestroy

HRESULT CParamStrip::OnDestroy( void )
{
	// Delete the Bitmap buttons
	if( InterlockedDecrement( &sm_lBitmapRefCount ) == 0 )
	{
		if( sm_bmpZoomInBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpZoomInBtnUp.DeleteObject();
		}
		if( sm_bmpZoomInBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpZoomInBtnDown.DeleteObject();
		}
		if( sm_bmpZoomOutBtnUp.GetSafeHandle() != NULL )
		{
			sm_bmpZoomOutBtnUp.DeleteObject();
		}
		if( sm_bmpZoomOutBtnDown.GetSafeHandle() != NULL )
		{
			sm_bmpZoomOutBtnDown.DeleteObject();
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetStripRect
//
BOOL CParamStrip::GetStripRect(LPRECT pRectStrip)
{

	ASSERT(pRectStrip);
	if(pRectStrip == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_FAIL;
	}

	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = pRectStrip;
	if( FAILED ( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// Adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	long lHeight;
	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		lHeight = STRIP_MINIMIZE_HEIGHT;
	}
	else
	{

		if( FAILED ( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
		{
			return FALSE;
		}
		lHeight = V_I4(&var);
	}

	POINT ptTop;
	POINT ptBottom;
	
	ptTop.x = 0;
	ptTop.y = 0;
	ptBottom.x = 0;
	ptBottom.y = lHeight;
	
	m_pTrackMgr->m_pTimeline->StripToWindowPos( this, &ptTop );
	m_pTrackMgr->m_pTimeline->StripToWindowPos( this, &ptBottom );

	pRectStrip->top = ptTop.y;
	pRectStrip->bottom = ptBottom.y;
	
	return TRUE;
}


HRESULT CParamStrip::SetProperties(StripInfo* pStripInfo)
{
	ASSERT(pStripInfo);
	if(pStripInfo == NULL)
	{
		return E_POINTER;
	}

	m_dwParamIndex = pStripInfo->m_dwParamIndex;
	m_strStripName = pStripInfo->m_sParamName;

	// Copy the param info
	CopyMemory(&m_ParamInfo, &pStripInfo->m_ParamInfo, sizeof(MP_PARAMINFO));

	return S_OK;
}


CString CParamStrip::GetName()
{
	return m_strStripName;
}

void CParamStrip::SetName(CString sName)
{
	m_strStripName = sName;
}

HRESULT CParamStrip::Insert()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	StartInsertingCurve();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::StartInsertingCurve

void CParamStrip::StartInsertingCurve()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pITimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pITimeline);
	if(pITimeline == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	m_fltInsertingStartValue = 0;
	m_fltInsertingEndValue = 0;
	m_lInsertingStartClock = 0;
	m_lInsertingEndClock = 0;

	m_fInsertingCurve = INSERT_CURVE_START_VALUE;

	// Ensure the arrow cursor is displayed
	m_hCursor = LoadCursor(NULL, IDC_ARROW);
	::SetCursor( m_hCursor );

	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	pITimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);

	if(pIFramework)
	{
		// Remove the old statuc bar first
		if(m_hKeyStatusBar)
		{
			pIFramework->RestoreStatusBar(m_hKeyStatusBar);	
			m_hKeyStatusBar = NULL;
		}
		pIFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar  );
		pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 25 );
	}

	CPoint pt( -1, -1 );
	OnUpdateInsertCurveValue( pt, pt );
}


/////////////////////////////////////////////////////////////////////////////
// CCurveStrip::StopInsertingCurve

void CParamStrip::StopInsertingCurve()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pITimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pITimeline);
	if(pITimeline == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	if(m_fInsertingCurve)
	{
		if(m_fInsertingCurve == INSERT_CURVE_START_VALUE)
		{
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			pITimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
		}

		m_fInsertingCurve = INSERT_CURVE_FALSE;

		if(pIFramework)
		{
			pIFramework->RestoreStatusBar(m_hKeyStatusBar);	
			m_hKeyStatusBar = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::YPosToValue

float CParamStrip::YPosToValue( long lYPos )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return 0;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return 0;
	}

	long lMaxValue = 0;
	float fltValue = 0;

	// Store maximum value
	lMaxValue = (long) m_ParamInfo.mpdMaxValue;

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	int nStripCenter = (nStripHeight >> 1);

	float fValueRange = m_ParamInfo.mpdMaxValue - m_ParamInfo.mpdMinValue;
	float fltYScale = (float)nStripHeight / fValueRange;
	float fltZeroValue = m_ParamInfo.mpdNeutralValue;

	float fltYPos  = (float)nStripHeight - lYPos;
	if(UseCenterLine())
	{
		fltYPos = (float) nStripCenter - lYPos;
	}

	fltValue = m_ParamInfo.mpdMinValue + (fltYPos / fltYScale);

	return fltValue ;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::ValueToYPos

short CParamStrip::ValueToYPos( float fltValue )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return 0;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return 0;
	}

	DWORD dwYPos = 0;

	// Get Strip height
	VARIANT var;
	int nStripHeight = CRV_DEFAULT_HEIGHT; 
	if( SUCCEEDED( pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		nStripHeight = V_I4(&var);
	}

	int nStripCenter = (nStripHeight >> 1);

	float fValueRange = (m_ParamInfo.mpdMaxValue - m_ParamInfo.mpdMinValue);
	float fltYScale = (float)nStripHeight / fValueRange;
	float fltZeroValue = m_ParamInfo.mpdNeutralValue;

	fltValue = (m_ParamInfo.mpdMaxValue - fltValue);

	if(UseCenterLine())
	{
		float fScaledYPos = fltValue * fltYScale;
		fScaledYPos = fScaledYPos < 0 ? (-fScaledYPos) : fScaledYPos;
		dwYPos = (DWORD) (nStripCenter - fScaledYPos);
	}
	else
	{
		float fScaledYPos = fltValue * fltYScale;
		fScaledYPos = fScaledYPos < 0 ? (-fScaledYPos) : fScaledYPos;
		dwYPos = (DWORD) (nStripHeight - floor(fScaledYPos + 0.5));
	}

	return (short)dwYPos;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnUpdateInsertCurveValue
//
// Called when tracker is resized during curve insertion.
// Updates the status bar and computes curve start and end values and
// start and end times.
void CParamStrip::OnUpdateInsertCurveValue( POINT ptLeft, POINT ptRight )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}
	
	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}
	
	CString strStart;
	CString strEnd;
	CString strStatus;

	strStart.LoadString(IDS_START_TEXT);
	strEnd.LoadString(IDS_END_TEXT);

	// Get CurveStrip rect
	CRect rectStrip;
	if(!GetStripRect(rectStrip))
	{
		return;
	}

	// Convert points into Window coordinates
	CPoint ptWndLeft(ptLeft);
	CPoint ptWndRight(ptRight);
	pTimeline->StripToWindowPos((IDMUSProdStrip *)this, &ptWndLeft);
	pTimeline->StripToWindowPos((IDMUSProdStrip *)this, &ptWndRight);

	// Make sure ptLeft.y is in this ParamStrip
	if( ptWndLeft.y < rectStrip.top
	||  ptWndLeft.y > rectStrip.bottom )
	{
		// ptLeft.y is NOT in this ParamStrip
		strStatus.Format( "%s, %s", strStart, strEnd );
	}
	else
	{
		// Get clock length of this ParamStrip
		VARIANT var;
		pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lClockLength = V_I4(&var);

		// Make sure ptLeft.x is in this CurveStrip
		long lStartClock = 0;

		pTimeline->PositionToClocks( ptLeft.x, &lStartClock );
		if( lStartClock < 0
		||  lStartClock > lClockLength )
		{
			// ptLeft.x is NOT in this CurveStrip
			strStatus.Format( "%s, %s", strStart, strEnd );
		}
		else
		{
	
			// start and end values that will be *displayed*
			float fltDispStartValue = 0;
			float fltDispEndValue = 0;

			// Set StartValue
			m_lInsertingStartClock = lStartClock % lClockLength;
			m_fltInsertingStartValue = YPosToValue( ptLeft.y );
			
			fltDispStartValue = m_fltInsertingStartValue;
			
			if(m_ParamInfo.mpType != MPT_FLOAT)
			{
				if(fltDispStartValue < 0)
				{
					fltDispStartValue = (int)(fltDispStartValue - 0.5);
				}
				else
				{
					fltDispStartValue = (int)(fltDispStartValue + 0.5);
				}
			}

			// See if ptRight.y is in this CurveStrip
			if( ptWndRight.y >= rectStrip.top
			&&  ptWndRight.y <= rectStrip.bottom )
			{
				long lEndClock;

				// ptRight.y is in this CurveStrip so set EndValue
				pTimeline->PositionToClocks( ptRight.x, &lEndClock );
				m_lInsertingEndClock = m_lInsertingStartClock + (lEndClock - lStartClock);
				m_fltInsertingEndValue = YPosToValue( ptRight.y );
				fltDispEndValue = m_fltInsertingEndValue;

				if(m_ParamInfo.mpType != MPT_FLOAT)
				{
					if(fltDispEndValue < 0)
					{
						fltDispEndValue = (int)(fltDispEndValue - 0.5);
					}
					else
					{
						fltDispEndValue = (int)(fltDispEndValue + 0.5);
					}
				}

				strStatus.Format( "%s %.03f, %s %.03f", strStart, fltDispStartValue, strEnd, fltDispEndValue );

			}
			else
			{
				strStatus.Format( "%s %.03f, %s", strStart, fltDispStartValue, strEnd );
			}
		}
	}

	// Refresh status bar
	if(pIFramework )
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnUpdateDragCurveValue
//
// Called when the tracker is resized during curve dragging/resizing.
// Updates the status bar with start, end values.
//
void CParamStrip::OnUpdateDragCurveValue(CCurveTracker& tracker, int nAction)
{

	CRect newRect = GetUpdatedCurveRect(tracker, tracker.m_pTrackItem, nAction);

	// Figure out start and end values and positions
	long lStartClock = 0;
	long lEndClock = 0;

	m_pTrackMgr->m_pTimeline->PositionToClocks(newRect.left, &lStartClock);
	m_pTrackMgr->m_pTimeline->PositionToClocks(newRect.right, &lEndClock);

	float fltStartValue = YPosToValue(newRect.top);
	float fltEndValue = YPosToValue(newRect.bottom);

	// Check for the type for the values
	if(m_ParamInfo.mpType != MPT_FLOAT)
	{
		if(fltStartValue < 0)
		{
			fltStartValue = (int)(fltStartValue - 0.5);
		}
		else
		{
			fltStartValue = (int)(fltStartValue + 0.5);
		}

		if(fltEndValue < 0)
		{
			fltEndValue = (int)(fltEndValue - 0.5);
		}
		else
		{
			fltEndValue = (int)(fltEndValue + 0.5);
		}
	}


	// create the status bar string
	CString strStart;
	CString strEnd;
	CString strStatus;

	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	strStatus.Format("%s %.03f, %s %.03f", strStart, fltStartValue, strEnd, fltEndValue);
	
	// Refresh status bar
	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	if(pIFramework)
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetUpdatedCurveRect
//
// Returns an updated rect for the given curve based on the tracker's rect
// and offset.  The rect returned is relative to the curve strip.
// This method is used in the process dragging existing curves.
CRect CParamStrip::GetUpdatedCurveRect(CCurveTracker& curveTracker, 
									   CTrackItem* pCurve,
									   int nAction)
{
	ASSERT(pCurve != NULL);

	CRect newRect;

	if (nAction == CTRK_DRAGGING) 

	{
		newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(curveTracker.m_offset);
	}
	else
	{
		// Get Curve Strip rectangle
		CRect rectStrip;
		if (!GetStripRect(rectStrip))
		{
			return newRect;
		}

		// Get Curve Strip left position
		long lLeftPosition;
		m_pTrackMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
		m_pTrackMgr->m_pTimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

		// get the new curve bounds relative to the curve strip
		newRect = curveTracker.m_rect;
		newRect.OffsetRect(-rectStrip.TopLeft());
		newRect.OffsetRect(lLeftPosition, 0);
		newRect.OffsetRect(-curveTracker.m_nXOffset, 0);
	}

	// swap values of the rect if necessary
	if (pCurve->m_fltEndValue > pCurve->m_fltStartValue) 
	{
		int temp = newRect.top;
		newRect.top = newRect.bottom;
		newRect.bottom = temp;
	}

	return newRect;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DragModify
//
// Handles move operation on the selected curves.
void CParamStrip::DragModify(CTrackItem* pTrackItem, int nStripXPos, int nStripYPos, int nAction, bool bMakeCopy)
{
	ASSERT(pTrackItem);
	if(pTrackItem == NULL)
	{
		return;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	// setup the status bar
	if( pIFramework )
	{
		// Remove the old statuc bar first
		if(m_hKeyStatusBar)
		{
			pIFramework->RestoreStatusBar(m_hKeyStatusBar);	
			m_hKeyStatusBar = NULL;
		}
		
		pIFramework->SetNbrStatusBarPanes( 1, SBLS_MOUSEDOWNUP, &m_hKeyStatusBar );
		pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 25 );

	}

	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	long lXOffset = 0;
	CRect selRect = pTrackItem->m_rectFrame;
	CPoint point( nStripXPos, nStripYPos );

	// convert point to window coordinates
	VERIFY( SUCCEEDED( pTimeline->StripToWindowPos(this, &point) ) );
	
	// convert the frame rect of the curve to window coordinates
	VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
	VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.BottomRight())));
	
	// create a list of selected curves (not including the one clicked on)
	CCurveList curveList;

	if (nAction == CTRK_DRAGGING)
	{
		POSITION position = m_lstTrackItems.GetHeadPosition();
		while(position)
		{
			CTrackItem* pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);

			if(pCurve != pTrackItem)
			{
				if (pCurve->m_fSelected)
				{
					curveList.AddTail(pCurve);
				}
			}
		}
	}

	CWnd wnd;
	wnd.Attach(GetMyWindow());

	// create a tracker to handle the move
	CCurveTracker curveTracker(&wnd, pTimeline, this, (short)nAction, &selRect);
	curveTracker.SetCurve(pTrackItem);
	curveTracker.SetCurveList(&curveList);
	curveTracker.SetXOffset( lXOffset );
	curveTracker.m_offset = 0;

	if(pTrackItem == NULL || curveList.GetCount() > 1)
	{
		OnUpdateDragCurveValue(curveTracker, nAction);
	}
	else
	{
		ShowCurveValueOnStausBar(pTrackItem);
	}


	// This sets a flag in the Timeline so that it doesn't autoscroll during playback.
	// We have to call ReleaseCapture(), or the CurveTracker won't work.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
	::ReleaseCapture();

	if (curveTracker.Track(&wnd, point, FALSE))
	{
		curveList.AddTail(pTrackItem);

		POSITION listPos = curveList.GetHeadPosition();
		while (listPos != NULL) 
		{
			CTrackItem* pCurve = curveList.GetNext(listPos);
			
			CRect newRect = GetUpdatedCurveRect(curveTracker, pCurve, nAction);

			// Make copies of the curves if required
			if(bMakeCopy)
			{
				CreateCurveCopy(pCurve);
			}

			// Figure out start and end values and positions
			long lStartClock = 0;
			long lEndClock = 0;

			pTimeline->PositionToClocks(newRect.left, &lStartClock);
			pTimeline->PositionToClocks(newRect.right, &lEndClock);

			float fltStartValue = YPosToValue(newRect.top);
			float fltEndValue = YPosToValue(newRect.bottom);

			if (nAction != CTRK_DRAGGING) 
			{
				pCurve->m_mtDuration = lEndClock - lStartClock;
			}

			pCurve->SetStartEndTime(lStartClock, lEndClock);
			pCurve->SetStartEndValue(fltStartValue, fltEndValue);			
		}

		// Redraw CurveStrips
		RefreshCurveStrips();
		RefreshCurvePropertyPage();

		// Let the object know about the changes
		UINT uStrRes = IDS_UNDO_CHANGE_CURVE;
		if(bMakeCopy)
		{
			uStrRes = IDS_UNDO_COPY_CURVE;
		}

		m_pTrackMgr->NotifyDataChange(uStrRes); 
	}

	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	if( pIFramework )
	{
		pIFramework->RestoreStatusBar( m_hKeyStatusBar );	
		m_hKeyStatusBar = NULL;
	}
	
	wnd.Detach();
}


void CParamStrip::CreateCurveCopy(CTrackItem* pCurve)
{
	ASSERT(pCurve);
	if(pCurve == NULL)
	{
		return;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	// Make a copy
	CTrackItem* pNewCurve = new CTrackItem(m_pTrackMgr, this);
	pNewCurve->Copy(pCurve);

	// Unselect it and add it to the strip
	pNewCurve->m_fSelected = FALSE;
	m_lstTrackItems.AddTail(pNewCurve);
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetMyWindow
//
// Retrieves the handle of the window which this strip is in.
HWND CParamStrip::GetMyWindow()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return NULL;
	}

	// Create bounding box
	IOleWindow* pIOleWindow = NULL;
	pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
	ASSERT(pIOleWindow);
	
	HWND hWnd;

	VERIFY(pIOleWindow->GetWindow(&hWnd) == S_OK);
	pIOleWindow->Release();
	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::GetCurveFromPoint

CTrackItem*	CParamStrip::GetCurveFromPoint( int nStripXPos, int nStripYPos, BOOL bFrameOnly )
{
	CTrackItem* pTheCurve = NULL;
	BOOL fOnTheCurveHandles = FALSE;

	CTrackItem* pCurve = NULL;
	BOOL fOnCurveHandles = FALSE;
	CRect rect;

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return NULL;
	}


	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	int nAdjustedXPos = AdjustXPos( nStripXPos );

	CPoint point1( nAdjustedXPos, nStripYPos );
	CPoint point2( nAdjustedXPos, nStripYPos );
	CPoint point3( nAdjustedXPos, nStripYPos );

	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);
		CRect rectCurve = bFrameOnly ? pCurve->m_rectFrame : pCurve->m_rectSelect;

		if( rectCurve.PtInRect( point1 )   
		||  rectCurve.PtInRect( point2 ) 
		||  rectCurve.PtInRect( point3 ) )  
		{
			// Need to set fOnCurveHandles
			fOnCurveHandles = FALSE;
			if( pCurve->m_fSelected )
			{
				// Convert the frame rect of the curve to window coordinates
				CRect selRect = pCurve->m_rectFrame;
				VERIFY( SUCCEEDED ( pTimeline->StripToWindowPos( this, &selRect.TopLeft() ) ) );
				VERIFY( SUCCEEDED ( pTimeline->StripToWindowPos( this, &selRect.BottomRight() ) ) );

				// Create a tracker
				CCurveTracker curveTracker( &selRect );
				UINT nHit = HitTest( curveTracker, nStripXPos, nStripYPos );
			
				switch( nHit )
				{
					case CRectTracker::hitTopLeft:
					case CRectTracker::hitBottomRight:
					case CRectTracker::hitTopRight:
					case CRectTracker::hitBottomLeft:
					case CRectTracker::hitTop:
					case CRectTracker::hitBottom:
					case CRectTracker::hitRight:
					case CRectTracker::hitLeft:
						// Cursor is over a RectTracker handle
						fOnCurveHandles = TRUE;
						break;
				}
			}

			if( pTheCurve == NULL )
			{
				pTheCurve = pCurve;
				fOnTheCurveHandles = fOnCurveHandles;
			}
			else
			{
				if( fOnTheCurveHandles == FALSE )
				{
					if( fOnCurveHandles == TRUE )
					{
						// Use the Curve whose handle is being hit
						pTheCurve = pCurve;
						fOnTheCurveHandles = TRUE;
					}
					else
					{
						// Use the Curve with the narrowest width
						if( pCurve->m_rectSelect.Width() < pTheCurve->m_rectSelect.Width() ) 
						{
							pTheCurve = pCurve;
						}
					}
				}
				else
				{
					if( fOnCurveHandles == TRUE )
					{
						// Use the Curve with the narrowest width
						if( pCurve->m_rectSelect.Width() < pTheCurve->m_rectSelect.Width() ) 
						{
							pTheCurve = pCurve;
						}
					}
				}
			}
		}
	}

	return pTheCurve;
}



/////////////////////////////////////////////////////////////////////////////
// CParamStrip::AdjustXPos

int CParamStrip::AdjustXPos( int nStripXPos )
{
	long lNewXPos = 0;

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return NULL;
	}

	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);


	MUSIC_TIME mtTime;

	pTimeline->PositionToClocks( nStripXPos, &mtTime );
	pTimeline->ClocksToPosition( mtTime, &lNewXPos );

	return lNewXPos;
}

//////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectCurve

WORD CParamStrip::SelectCurve( CTrackItem* pTrackItem, BOOL fState )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return 0;
	}
	
	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return NULL;
	}


	WORD wRefreshUI = FALSE;

	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		CTrackItem* pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);
		if( pCurve == pTrackItem)
		{
			if( pTrackItem->m_fSelected != fState )
			{
				pTrackItem->m_fSelected = fState;
				if(fState)
				{
					long lDurMeasure = 0;
					long lDurBeat = 0;
					long lDurTick = 0;

					MUSIC_TIME mtDuration = pCurve->m_mtEndTime - pCurve->m_mtStartTime;
					m_pTrackMgr->ClocksToMeasureBeatTick(mtDuration, &lDurMeasure, &lDurBeat, &lDurTick);

					long lPosition = 0;
					pTimeline->ClocksToPosition(pCurve->m_mtStartTime, &lPosition);
					m_pSelectedRegions->AddRegion(lPosition, lDurMeasure, lDurBeat);
				}
				else
				{
					long lPosition = 0;
					pTimeline->ClocksToPosition(pCurve->m_mtStartTime, &lPosition);
					m_pSelectedRegions->ToggleRegion(lPosition);
				}

				wRefreshUI = TRUE;
			}
		}
	}

	return wRefreshUI;
}


//////////////////////////////////////////////////////////////////////////////
// CParamStrip::SelectAllCurves

WORD CParamStrip::SelectAllCurves( BOOL fState )
{
	WORD wRefreshUI = FALSE;

	POSITION position = m_lstTrackItems.GetHeadPosition();
	while(position)
	{
		CTrackItem* pCurve = (CTrackItem*)m_lstTrackItems.GetNext(position);
		if( pCurve->m_fSelected != fState )
		{
			pCurve->m_fSelected = fState;
			wRefreshUI = TRUE;
		}
	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::HitTest

UINT CParamStrip::HitTest( CCurveTracker& tracker, long lStripXPos, long lStripYPos )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return NULL;
	}

	// Adjust X pos (for repeating Parts)
	int nAdjustedXPos = AdjustXPos( lStripXPos );

	CPoint point( nAdjustedXPos, lStripYPos );
	VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &point)));

	// Try adjusted point
	UINT hit = tracker.HitTest( point );

	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	return hit;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::RefreshUI
//
// Refreshes the curve strip if wRefreshUI is true.  Sets wRefreshUI to
// false.
void CParamStrip::RefreshUI(WORD& wRefreshUI)
{
	if( wRefreshUI )
	{
		RefreshCurveStrips();
		RefreshCurvePropertyPage();
		wRefreshUI = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::RefreshCurvePropertyPage	

void CParamStrip::RefreshCurvePropertyPage( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return; 
	}

	IDMUSProdStrip* pIActiveStrip = NULL;
	VARIANT var;

	// Get the active Strip
	if( SUCCEEDED ( pTimeline->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		pIActiveStrip = (IDMUSProdStrip *)V_UNKNOWN( &var );
	}
	else
	{
		pIActiveStrip = NULL;
	}

	if( pIFramework )
	{
		IDMUSProdPropSheet* pIPropSheet = NULL;

		// Get IDMUSProdPropSheet interface
		if( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				if( (pIActiveStrip == this)
				||  (pIPropSheet->IsEqualPageManagerObject(this) == S_OK) )
				{
					m_fShowItemProps = true;
					OnShowProperties();
				}
			}
			
			pIPropSheet->Release();
		}
	}

	if( pIActiveStrip )
	{
		pIActiveStrip->Release();
	}

}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::RefreshCurveStrips
	
void CParamStrip::RefreshCurveStrips( void )
{
	ASSERT(m_pTrackObject);
	if(m_pTrackObject)
	{
		m_pTrackObject->RefreshAllStrips();
	}
}



CTrackMgr* CParamStrip::GetTrackManager()
{
	return m_pTrackMgr;
}

CTrackObject*	CParamStrip::GetTrackObject()
{
	return m_pTrackObject;
}

HRESULT	CParamStrip::GetTimeSignature(DirectMusicTimeSig* pTimeSig, MUSIC_TIME mtTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(pTimeSig);
	if(pTimeSig == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	long lMeasure = 0;
	long lBeat = 0;
	long lGrid = 0;
	long lTick = 0;
	if(FAILED(m_pTrackMgr->ClocksToMeasureBeatGridTick(mtTime, &lMeasure, &lBeat, &lGrid, &lTick)))
	{
		return E_FAIL;
	}

	DMUS_TIMESIGNATURE TimeSig;
	DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
	if(FAILED(pTimeline->GetParam(GUID_TimeSignature, dwGroupBits, 0, lMeasure, NULL, &TimeSig)))
	{
		return E_FAIL;
	}

	pTimeSig->m_wGridsPerBeat = TimeSig.wGridsPerBeat;
	pTimeSig->m_bBeat = TimeSig.bBeat;
	pTimeSig->m_bBeatsPerMeasure = TimeSig.bBeatsPerMeasure;

	return S_OK;
}

void CParamStrip::OnCurvePropPageMgrDeleted()
{
	if(m_pPropPageMgr)
	{
		m_pPropPageMgr = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::OnSetCursor
//
// Sets the mouse cursor based on where the mouse is relative to the curves.
HRESULT CParamStrip::OnSetCursor( long lXPos, long lYPos)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	if( m_StripUI.m_nStripView == SV_MINIMIZED )
	{
		m_hCursor = LoadCursor(NULL, IDC_ARROW);
		return S_OK;
	}

	CTrackItem* pCurve = GetCurveFromPoint( lXPos, lYPos, TRUE );

	if (pCurve)
	{
		if (pCurve->m_fSelected)
		{
			// convert the frame rect of the curve to window coordinates
			CRect selRect = pCurve->m_rectFrame;
			VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.TopLeft())));
			VERIFY(SUCCEEDED(pTimeline->StripToWindowPos(this, &selRect.BottomRight())));

			// create a tracker
			CCurveTracker curveTracker(&selRect);
			UINT hit = HitTest( curveTracker, lXPos, lYPos );
		
			// I had to do this because CRectTracker.LoadCursor doesn't return an HCURSOR
			switch(hit)
			{
				case CRectTracker::hitTopLeft:
				case CRectTracker::hitBottomRight:
				{
					m_hCursor = LoadCursor(NULL, IDC_SIZENWSE);
					break;
				}

				case CRectTracker::hitTopRight:
				case CRectTracker::hitBottomLeft:
				{
					m_hCursor = LoadCursor(NULL, IDC_SIZENESW);
					break;
				}

				case CRectTracker::hitTop:
				case CRectTracker::hitBottom:
				{
					m_hCursor = LoadCursor(NULL, IDC_SIZENS);
					break;
				}

				case CRectTracker::hitRight:
				case CRectTracker::hitLeft:
				{
					m_hCursor = LoadCursor(NULL, IDC_SIZEWE);
					break;
				}

				case CRectTracker::hitMiddle:
				{

					m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
					break;
				}

				default:
				{
					m_hCursor = LoadCursor(NULL, IDC_ARROW);
					break;
				}
			}
		}
		else
		{
			m_hCursor = LoadCursor(NULL, IDC_SIZEALL);
		}
	}
	else
	{
		m_hCursor = LoadCursor(NULL, IDC_ARROW);
	}

	return S_OK;
}

HRESULT	CParamStrip::GetParamInfoFromCLSID(MP_PARAMINFO* pParamInfo)
{
	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(pParamInfo);
	if(pParamInfo == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;
	IUnknown* pIUnkObject = NULL;
	CLSID clsidObject = m_pTrackObject->m_guidObject;
	if(SUCCEEDED(hr = ::CoCreateInstance(clsidObject, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &pIUnkObject)))
	{
		IMediaParamInfo* pIParamInfo = NULL;
		if(SUCCEEDED(hr = pIUnkObject->QueryInterface(IID_IMediaParamInfo, (void**)&pIParamInfo)))
		{
			hr = pIParamInfo->GetParamInfo(m_dwParamIndex, pParamInfo);
			pIParamInfo->Release();
		}

		pIUnkObject->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::UseCenterLine

BOOL CParamStrip::UseCenterLine( void )
{
	/*if(m_ParamInfo.mpdMaxValue > 0 && m_ParamInfo.mpdMinValue < 0)
	{
		return TRUE;
	}*/

    return FALSE;
}


DWORD CParamStrip::GetParamIndex()
{
	return m_dwParamIndex;
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SwitchTimeBase

void CParamStrip::SwitchTimeBase( void )
{
	POSITION pos = m_lstTrackItems.GetHeadPosition();
	while( pos )
	{
		CTrackItem* pItem = m_lstTrackItems.GetNext( pos );
		pItem->SwitchTimeBase();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::InvalidateFBar

void CParamStrip::InvalidateFBar( void )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	// Invalidate the function bar
	RECT rect;
	rect.right = 0;
	rect.top = m_StripUI.m_lVerticalScrollYPos;
	rect.bottom = m_StripUI.m_lVerticalScrollYPos + m_StripUI.m_lStripHeight;
	VARIANT var;
	var.vt = VT_I4;
	if( FAILED ( pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
	{
		return;
	}
	rect.left = -V_I4(&var);

	// Need to offset it if we're horizontally scrolled
	long lLeftDisplay;
	pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

	rect.left += lLeftDisplay;
	rect.right += lLeftDisplay;

	// Really invalidate the function bar
	pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

DWORD CParamStrip::GetDMParamFlags()
{
	return m_dwParamFlagsDM;
}

void CParamStrip::SetDMParamFlags(DWORD dwFlagsDM)
{
	m_dwParamFlagsDM = dwFlagsDM;
}

IDMUSProdPropPageManager* CParamStrip::GetPropPageMgr()
{
	return m_pPropPageMgr;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::DoGridsPerSecond

void CParamStrip::DoGridsPerSecond( void )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	ASSERT(m_pTrackObject);
	if(m_pTrackObject == NULL)
	{
		return;
	}

	CGridsPerSecondDlg dlgGridsPerSecond;

	dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond = m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	if( dlgGridsPerSecond.DoModal() == IDOK )
	{
		if( dlgGridsPerSecond.m_fAllParts )
		{
			if( m_pTrackObject->AllStrips_SetNbrGridsPerSecond(dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond) )
			{
				m_pTrackMgr->SetLastEdit(IDS_UNDO_NBR_GRIDS_PER_SECOND);
				m_pTrackMgr->TrackDataChanged();
				m_pTrackObject->AllStrips_Invalidate();
			}
		}
		else
		{
			if( m_StripUI.m_nSnapToRefTime_GridsPerSecond != dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond )
			{
				m_StripUI.m_nSnapToRefTime_GridsPerSecond = dlgGridsPerSecond.m_nSnapToRefTime_GridsPerSecond;
				m_pTrackMgr->SetLastEdit(IDS_UNDO_NBR_GRIDS_PER_SECOND);
				m_pTrackMgr->TrackDataChanged();
				pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
			}
		}

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}
}



/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SetSnapTo

void CParamStrip::SetSnapTo( WORD wID )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		m_StripUI.m_nSnapToRefTime = wID;

		// Update the Timeline with the snap-to setting (if possible)
		if( (wID == IDM_SNAP_NONE)
		||	(wID == IDM_SNAP_GRID) )
		{
			// Create a variant to store the timeline snap-to setting in
			VARIANT var;
			var.vt = VT_I4;

			switch( wID )
			{
			case IDM_SNAP_NONE:
				V_I4(&var) = DMUSPROD_TIMELINE_SNAP_NONE;
				break;
			case IDM_SNAP_GRID:
				V_I4(&var) = DMUSPROD_TIMELINE_SNAP_GRID;
				break;
			}

			// Now, set the TP_SNAP_TO property
			m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
		}
	}
	else
	{
		m_StripUI.m_nSnapToMusicTime = wID;

		// Update the Timeline with the snap-to setting

		// Convert from the our own SNAP_TO setting to the timeline's SNAP_TO setting
		DMUSPROD_TIMELINE_SNAP_TO tlSnapTo;

		switch( wID )
		{
		case IDM_SNAP_NONE:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_NONE;
			break;
		case IDM_SNAP_GRID:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
			break;
		case IDM_SNAP_BEAT:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_BEAT;
			break;
		case IDM_SNAP_BAR:
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_BAR;
			break;
		default:
			ASSERT(FALSE);
			tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
			break;
		}

		// Now, set the TP_SNAP_TO property
		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = tlSnapTo;
		m_pTrackMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
	}

	// Save undo state and redraw our strip
	m_pTrackMgr->SetLastEdit(IDS_UNDO_SNAP_TO);
	m_pTrackMgr->TrackDataChanged();
	pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SnapXPosToUnknownTime

HRESULT CParamStrip::SnapXPosToUnknownTime(long lXPos, REFERENCE_TIME* prtSnapTime)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	if(prtSnapTime == NULL)
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	*prtSnapTime = 0;

	if(lXPos < 0)
	{
		ASSERT(0);
		return E_INVALIDARG;
	}

	MUSIC_TIME mtTime = 0;
	if(FAILED(m_pTrackMgr->m_pTimeline->PositionToClocks(lXPos, &mtTime)))
	{
		ASSERT(0);
		return E_FAIL;
	}

	REFERENCE_TIME rtTime = 0;
	if(FAILED(m_pTrackMgr->ClocksToUnknownTime(mtTime, &rtTime)))
	{
		ASSERT(0);
		return E_FAIL;
	}

	return SnapUnknownTime(rtTime, prtSnapTime);
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SnapUnknownTime

HRESULT CParamStrip::SnapUnknownTime(REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime)
{
	if(prtSnapTime == NULL)
	{
		ASSERT(0);
		return E_INVALIDARG;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	*prtSnapTime = 0;

	if(rtTime < 0)
	{
		ASSERT(0);
		return E_INVALIDARG;
	}

	if(m_pTrackMgr->IsRefTimeTrack())
	{
		long lMinute;
		long lSec;
		long lGrid;
		long lMs;
		m_pTrackMgr->RefTimeToMinSecGridMs(this, rtTime, &lMinute, &lSec, &lGrid, &lMs);

		if(m_StripUI.m_nSnapToRefTime != IDM_SNAP_NONE)
		{
			if(lMs < 0)
			{
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, (lGrid - 1), 0, &rtTime );
				m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSec, &lGrid, &lMs );
			}
		}

		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				// Nothing to do
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, lGrid, 0, &rtTime );
				break;
			
			case IDM_SNAP_SECOND:
				m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSec, 0, 0, &rtTime );
				break;
		}
	}
	else
	{
		long lMeasure;
		long lBeat;
		long lGrid;
		long lTick;
		m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lGrid, &lTick );

		MUSIC_TIME mtTime;
		if( m_StripUI.m_nSnapToMusicTime != IDM_SNAP_NONE )
		{
			if( lTick < 0 )
			{
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, (lGrid - 1), 0, &mtTime );
				m_pTrackMgr->ClocksToMeasureBeatGridTick( mtTime, &lMeasure, &lBeat, &lGrid, &lTick );
			}
		}

		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );
				break;

			case IDM_SNAP_GRID:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, 0, &mtTime );
				break;
			
			case IDM_SNAP_BEAT:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, 0, 0, &mtTime );
				break;
			
			case IDM_SNAP_BAR:
				m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, 0, 0, 0, &mtTime );
				break;

			default:
				ASSERT( 0 );	// Should not happen!
				mtTime = 0;
		}

		rtTime = mtTime;
	}

	*prtSnapTime = rtTime;
	return S_OK;
}

BOOL CParamStrip::IsOneGrid()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return FALSE;
	}

	if(m_pTrackMgr->IsRefTimeTrack() )
	{
		if(m_StripUI.m_nSnapToRefTime_GridsPerSecond == 1 )
		{
			return TRUE;
		}
	}

	return FALSE;

}

void CParamStrip::ShowCurveValueOnStausBar(CTrackItem* pItem)
{
	ASSERT(pItem);
	if(pItem == NULL)
	{
		return;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}
	
	// create the status bar string
	CString strStart;
	CString strEnd;
	CString strStatus;

	strStart.LoadString( IDS_START_TEXT );
	strEnd.LoadString( IDS_END_TEXT );

	float fltStart = 0;
	float fltEnd = 0;
	pItem->GetStartEndValue(fltStart, fltEnd);

	strStatus.Format("%s %.03f, %s %.03f", strStart, fltStart, strEnd, fltEnd);
	
	// Refresh status bar
	IDMUSProdFramework* pIFramework = m_pTrackMgr->GetFramework();
	if(pIFramework)
	{
		BSTR bstrStatus = strStatus.AllocSysString();
		pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstrStatus, TRUE );
	}

}

/////////////////////////////////////////////////////////////////////////////
// CParamStrip::SnapUnknownToNextIncrement

HRESULT CParamStrip::SnapUnknownToNextIncrement( REFERENCE_TIME rtTime, REFERENCE_TIME* prtSnapTime )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	SnapUnknownTime(rtTime, &rtTime);

	if(m_pTrackMgr->IsRefTimeTrack())
	{
		long lMinute = 0;
		long lSecond = 0;
		long lGrid = 0;
		long lMs = 0;
	
		m_pTrackMgr->RefTimeToMinSecGridMs( this, rtTime, &lMinute, &lSecond, &lGrid, &lMs );
		switch( m_StripUI.m_nSnapToRefTime )
		{
			case IDM_SNAP_NONE:
				lMs++;
				break;

			case IDM_SNAP_GRID:
				lGrid++;
				break;
			
			case IDM_SNAP_SECOND:
				lSecond++;
				break;
		}
		m_pTrackMgr->MinSecGridMsToRefTime( this, lMinute, lSecond, lGrid, lMs, &rtTime );
	}
	else
	{
		long lMeasure, lBeat, lGrid, lTick;
		MUSIC_TIME mtTime;

		m_pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)rtTime, &lMeasure, &lBeat, &lGrid, &lTick );
		switch( m_StripUI.m_nSnapToMusicTime )
		{
			case IDM_SNAP_NONE:
				lTick++;
				break;

			case IDM_SNAP_GRID:
				lGrid++;
				break;
			
			case IDM_SNAP_BEAT:
				lBeat++;
				break;
			
			case IDM_SNAP_BAR:
				lMeasure++;
				break;
		}
		m_pTrackMgr->MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );
		rtTime = mtTime;
	}

	*prtSnapTime = rtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CParamStrip::CListSelectedRegion_Contains

bool CParamStrip::CListSelectedRegion_Contains( REFERENCE_TIME rtTime )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return false;
	}

	ASSERT(m_pSelectedRegions);
	if(m_pSelectedRegions == NULL)
	{
		return false;
	}

	MUSIC_TIME mtTime;
	m_pTrackMgr->UnknownTimeToClocks( rtTime, &mtTime );

	if( m_pSelectedRegions->Contains( mtTime ) )
	{
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\ParamStripMgrDLL.cpp ===
// ParamStripMgrDLL.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "RiffStrm.h"
#include "resource.h"
#include "ParamStripMgr.h"
#include <AFXCTL.H>
#include "ParamStripMgrApp.h"

#include <initguid.h>
#include "TrackMgr.h"
#include "SegmentGUIDs.h"
#include "audiopathdesigner.h"
#include "ToolGraphDesigner.h"
#include "PChannelName.h"
#include <dmusici.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// ATL Stuff follows
CComModule _Module; 

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ParamMgr, CTrackMgr)
END_OBJECT_MAP()


CParamStripMgrApp theApp;

BOOL CParamStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	m_pParamStripFont = NULL;
	return CWinApp::InitInstance();
}

int CParamStripMgrApp::ExitInstance()
{
	if( m_pParamStripFont )
	{
		m_pParamStripFont->DeleteObject();
		delete m_pParamStripFont;
		m_pParamStripFont = NULL;
	}

	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusicProducer strip managers

static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Convert the Parameter Control Strip Manager's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_ParamMgr, &psz) ) )
	{
		// Convert from an OLE string to a multi-byte string
		char szEditorCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorCLSID, sizeof(szEditorCLSID), NULL, NULL );

		// Free the memory used by the OLE string
		CoTaskMemFree( psz );

		// Convert the Parameter Control Track's CLSID into an OLE string
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicParamControlTrack, &psz) ) )
		{
			// Convert from an OLE string to a multi-byte string
			char szTrackCLSID[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );

			// Free the memory used by the OLE string
			CoTaskMemFree( psz );

			// Load the name of the track from the resource file
			CString strTrackName;
			strTrackName.LoadString( IDS_TRACK_NAME );

			// Build the path to the item in the registry to set
			TCHAR szRegPath[256];
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
			_tcscat( szRegPath, szTrackCLSID );

			// Set the default value to the track's name
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}

			// Set the CLSID of the Strip Manager editor to use to edit this track
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("StripManager"), szEditorCLSID)) )
			{
				return FALSE;
			}
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes entries from the system registry for DirectMusicProducer strip managers

static BOOL UnregisterComponents( void )
{
	// Convert the Parameter Control Track's CLSID into an OLE string
	LPOLESTR psz;
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicParamControlTrack, &psz) ) )
	{
		// Convert the OLE string into a character string
		char szTrackCLSID[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackCLSID, sizeof(szTrackCLSID), NULL, NULL );
		CoTaskMemFree( psz );

		// Build the registry key to delete
		char szRegPath[255];
		strcpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		strcat( szRegPath, szTrackCLSID );

		// Delete the registry key
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Creates the DirectMusic Producer-specific registry entries
	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_PARAMSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	// unregisters object
	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	// Removes the DirectMusic Producer-specific registry entries
	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\PropCurve.h ===
#ifndef __PROPCURVE_H_
#define __PROPCURVE_H_

#include "TrackMgr.h"

#define INVALID_VALUE	0xFFFFFFFF

class CPropCurve
{
public:
	CPropCurve();

	DWORD	ApplyValuesToCurve( CParamStrip* pParamStrip, CTrackItem* pCurve );
	void	GetValuesFromCurve( CParamStrip* pParamStrip, CTrackItem* pCurve );
	MUSIC_TIME AbsTime();
	void	Copy( CPropCurve *pPropCurve );
	void	Clear();
	
	CPropCurve operator +=(const CPropCurve PropCurve);
	
	void UpdateStartBarBeatGridTick(long m_lStartBar, long m_lStartBeat, long m_lStartGrid, long m_lStartTick);
	void UpdateEndBarBeatGridTick(long m_lEndBar, long m_lEndBeat, long m_lEndGrid, long m_lEndTick);
	void UpdateDurationBarBeatGridTick(long m_lDurationBar, long m_lDurationBeat, long m_lDurationGrid, long m_lDurationTick);


	// Curve fields	
	float		m_fltStartValue;	// Curve's start value
	float		m_fltEndValue;		// Curve's end value
	DWORD		m_dwCurveShape;		// Shape of curve
	BOOL		m_fStartFromCurrent;// Start from current flag	
	
	// Used to track which fields are shared by multiple 
	// notes and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined;
	DWORD		m_dwUndetermined2;

	// Used to relay which fields have changed
	DWORD		m_dwChanged;
	DWORD		m_dwChanged2;

	REFERENCE_TIME	m_rtStartTime;
	REFERENCE_TIME	m_rtDuration;

	CParamStrip*	m_pParamStrip;

	// Fields used for setting the bar, beat, grid, tick data
	long		m_lStartBar;
	long		m_lStartBeat;
	long		m_lStartGrid;
	long		m_lStartTick;

	long		m_lEndBar;
	long		m_lEndBeat;
	long		m_lEndGrid;
	long		m_lEndTick;

	long		m_lDurBar;
	long		m_lDurBeat;
	long		m_lDurGrid;
	long		m_lDurTick;
};


// Flags for m_dwUndetermined:

#define UD_DURATION		(DWORD)(1 << 3)
#define UD_STARTBAR		(DWORD)(1 << 4)
#define UD_STARTBEAT	(DWORD)(1 << 5)
#define UD_STARTGRID	(DWORD)(1 << 6)
#define UD_STARTTICK	(DWORD)(1 << 7)
#define UD_ENDBAR		(DWORD)(1 << 8)
#define UD_ENDBEAT		(DWORD)(1 << 9)
#define UD_ENDGRID		(DWORD)(1 << 10)
#define UD_ENDTICK		(DWORD)(1 << 11)
#define UD_DURBAR		(DWORD)(1 << 12)
#define UD_DURBEAT		(DWORD)(1 << 13)
#define UD_DURGRID		(DWORD)(1 << 14)
#define UD_DURTICK		(DWORD)(1 << 15)
#define UD_STARTCURRENT	(DWORD)(1 << 16)


#define UNDT_OFFSET			UD_OFFSET
#define UNDT_GRIDSTART		UD_GRIDSTART
#define UNDT_VARIATIONS		UD_VARIATIONS
#define UNDT_DURATION		UD_DURATION
#define UNDT_STARTBAR		UD_STARTBAR
#define UNDT_STARTBEAT		UD_STARTBEAT
#define UNDT_STARTGRID		UD_STARTGRID
#define UNDT_STARTTICK		UD_STARTTICK
#define UNDT_ENDBAR			UD_ENDBAR
#define UNDT_ENDBEAT		UD_ENDBEAT
#define UNDT_ENDGRID		UD_ENDGRID
#define UNDT_ENDTICK		UD_ENDTICK
#define UNDT_DURBAR			UD_DURBAR
#define UNDT_DURBEAT		UD_DURBEAT
#define UNDT_DURGRID		UD_DURGRID
#define UNDT_DURTICK		UD_DURTICK

#define UNDT_FLIPVERT		(1 << 19)
#define UNDT_FLIPHORZ		(1 << 20)
#define UNDT_STARTVAL		(1 << 21)
#define UNDT_ENDVAL			(1 << 22)
#define UNDT_SHAPE			(1 << 23)

#define UNDT_RESETENABLE	(1 << 24)
#define UNDT_RESETVAL		(1 << 25)
#define UNDT_RESETBAR		(1 << 26)
#define UNDT_RESETBEAT		(1 << 27)
#define UNDT_RESETGRID		(1 << 28)
#define UNDT_RESETTICK		(1 << 29)
#define UNDT_RESETDURATION	(1 << 30)

#define UNDT2_MERGEINDEX	(DWORD(1 << 0))
#define UNDT2_STARTCURRENT	(DWORD(1 << 1))

#define UNDT_CURVENONE		0x80000000

#define UNDT_START_BARBEATGRIDTICK (UNDT_STARTBAR | UNDT_STARTBEAT | UNDT_STARTGRID | UNDT_STARTTICK)
#define UNDT_END_BARBEATGRIDTICK (UNDT_ENDBAR | UNDT_ENDBEAT | UNDT_ENDGRID | UNDT_ENDTICK)
#define UNDT_DUR_BARBEATGRIDTICK (UNDT_DURBAR | UNDT_DURBEAT | UNDT_DURGRID | UNDT_DURTICK)
#define UNDT_RESET_BARBEATGRIDTICK (UNDT_RESETBAR | UNDT_RESETBEAT | UNDT_RESETGRID | UNDT_RESETTICK)


#define CHGD_DURATION		UD_DURATION
#define CHGD_STARTBAR		UD_STARTBAR
#define CHGD_STARTBEAT		UD_STARTBEAT
#define CHGD_STARTGRID		UD_STARTGRID
#define CHGD_STARTTICK		UD_STARTTICK
#define CHGD_ENDBAR			UD_ENDBAR
#define CHGD_ENDBEAT		UD_ENDBEAT
#define CHGD_ENDGRID		UD_ENDGRID
#define CHGD_ENDTICK		UD_ENDTICK
#define CHGD_DURBAR			UD_DURBAR
#define CHGD_DURBEAT		UD_DURBEAT
#define CHGD_DURGRID		UD_DURGRID
#define CHGD_DURTICK		UD_DURTICK
#define CHGD_STARTCURRENT	UD_STARTCURRENT

#define CHGD_STARTVAL		UNDT_STARTVAL	
#define CHGD_ENDVAL			UNDT_ENDVAL		
#define CHGD_SHAPE			UNDT_SHAPE		
#define CHGD_FLIPVERT		UNDT_FLIPVERT	
#define CHGD_FLIPHORZ		UNDT_FLIPHORZ	


#define CHGD_START_BARBEATGRIDTICK (UNDT_STARTBAR | UNDT_STARTBEAT | UNDT_STARTGRID | UNDT_STARTTICK)
#define CHGD_END_BARBEATGRIDTICK (UNDT_ENDBAR | UNDT_ENDBEAT | UNDT_ENDGRID | UNDT_ENDTICK)
#define CHGD_DUR_BARBEATGRIDTICK (UNDT_DURBAR | UNDT_DURBEAT | UNDT_DURGRID | UNDT_DURTICK)

#endif // __PROPCURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\PropCurve.cpp ===
#include "stdafx.h"
#include "TrackMgr.h"
#include "TrackItem.h"
#include "ParamStrip.h"
#include "PropCurve.h"


CPropCurve::CPropCurve()
{
	Clear();
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::ApplyValuesToCurve

DWORD CPropCurve::ApplyValuesToCurve( CParamStrip* pParamStrip, CTrackItem* pCurve )
{
	ASSERT( pParamStrip != NULL );
	ASSERT( pCurve != NULL );

	if( pParamStrip == NULL
	||  pCurve == NULL )
	{
		return 0;
	}

	CTrackMgr* pTrackMgr = pParamStrip->GetTrackManager();
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	IDMUSProdTimeline* pTimeline = pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return 0;
	}

	// Get the length of the segment
	VARIANT var;
	pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	DWORD dwChanged = 0;

	// Start Value
	if( m_dwChanged & CHGD_STARTVAL )
	{
		if( pCurve->m_fltStartValue != m_fltStartValue )
		{
			dwChanged |= CHGD_STARTVAL;
			pCurve->SetStartEndValue(m_fltStartValue, m_fltEndValue);
		}
	}

	// End Value
	if( m_dwChanged & CHGD_ENDVAL )
	{
		if( pCurve->m_fltEndValue != m_fltEndValue )
		{
			dwChanged |= CHGD_ENDVAL;
			pCurve->SetStartEndValue(m_fltStartValue, m_fltEndValue);
		}
	}

	// Flip Vert button clicked
	if( m_dwChanged & CHGD_FLIPVERT )
	{
		switch( pCurve->m_dwCurveType)
		{
			case MP_CURVE_SINE:
			case MP_CURVE_LINEAR:
			{
				dwChanged |= CHGD_FLIPVERT;

				float fltMaxValue = 0;
				fltMaxValue = pParamStrip->m_ParamInfo.mpdMaxValue;
				if(pParamStrip->m_ParamInfo.mpdMinValue < 0 && pParamStrip->m_ParamInfo.mpdMaxValue < 0)
				{
					pCurve->m_fltStartValue	= 0 - pCurve->m_fltStartValue;
					pCurve->m_fltEndValue = 0 - pCurve->m_fltEndValue;
				}
				else
				{
					pCurve->m_fltStartValue	= fltMaxValue - pCurve->m_fltStartValue;
					pCurve->m_fltEndValue = fltMaxValue - pCurve->m_fltEndValue;
				}

				pCurve->m_fltStartValue = pCurve->m_fltStartValue > pParamStrip->m_ParamInfo.mpdMaxValue ? pParamStrip->m_ParamInfo.mpdMaxValue : pCurve->m_fltStartValue;
				pCurve->m_fltStartValue = pCurve->m_fltStartValue < pParamStrip->m_ParamInfo.mpdMinValue ? pParamStrip->m_ParamInfo.mpdMinValue : pCurve->m_fltStartValue;
				pCurve->m_fltEndValue = pCurve->m_fltEndValue > pParamStrip->m_ParamInfo.mpdMaxValue ? pParamStrip->m_ParamInfo.mpdMaxValue : pCurve->m_fltEndValue;
				pCurve->m_fltEndValue = pCurve->m_fltEndValue < pParamStrip->m_ParamInfo.mpdMinValue ? pParamStrip->m_ParamInfo.mpdMinValue : pCurve->m_fltEndValue;

				
				break;
			}

			case MP_CURVE_SQUARE:
			{
				dwChanged |= CHGD_FLIPVERT;
				pCurve->m_dwCurveType = MP_CURVE_SQUARE;
				break;
			}

			case MP_CURVE_INVSQUARE:
			{
				dwChanged |= CHGD_FLIPVERT;
				pCurve->m_dwCurveType = MP_CURVE_INVSQUARE;
				break;
			}

			case MP_CURVE_JUMP:
			{
				dwChanged |= CHGD_FLIPVERT;
				pCurve->m_dwCurveType = MP_CURVE_JUMP;
				break;
			}
		}
	}

	// Flip horz button clicked
	if( m_dwChanged & CHGD_FLIPHORZ )
	{
		dwChanged |= CHGD_FLIPHORZ;

		float fltStartValue = pCurve->m_fltStartValue;
		pCurve->m_fltStartValue	= pCurve->m_fltEndValue;
		pCurve->m_fltEndValue = fltStartValue;
	}

	// Shape
	if( m_dwChanged & CHGD_SHAPE )
	{
		if( pCurve->m_dwCurveType != m_dwCurveShape )
		{
			dwChanged |= CHGD_SHAPE;
			pCurve->m_dwCurveType	= m_dwCurveShape;
		}
	}

	if( (m_dwChanged & CHGD_START_BARBEATGRIDTICK) || (m_dwChanged & CHGD_END_BARBEATGRIDTICK)
	||  (m_dwChanged & CHGD_DUR_BARBEATGRIDTICK) )
	{
		dwChanged |= CHGD_START_BARBEATGRIDTICK | CHGD_END_BARBEATGRIDTICK | CHGD_DUR_BARBEATGRIDTICK;

		MUSIC_TIME mtStartTime = 0;
		pTrackMgr->UnknownTimeToClocks(m_rtStartTime, &mtStartTime);

		REFERENCE_TIME rtEndTime = m_rtStartTime + m_rtDuration;
		MUSIC_TIME mtEndTime = 0;
		pTrackMgr->UnknownTimeToClocks(rtEndTime, &mtEndTime);

		if(pTrackMgr->IsRefTimeTrack())
		{
			pCurve->SetPhysicalTime(m_rtStartTime, m_rtDuration);
		}
		else
		{
			pCurve->SetStartEndTime(mtStartTime, mtEndTime);
		}
	}

	// Start from current checkbox selected
	if(m_dwChanged & CHGD_STARTCURRENT)
	{
		dwChanged |= CHGD_STARTCURRENT;
		pCurve->m_dwFlags = m_fStartFromCurrent == TRUE ? MPF_ENVLP_BEGIN_CURRENTVAL : MPF_ENVLP_STANDARD;
	}
	

	return dwChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::GetValuesFromCurve

void CPropCurve::GetValuesFromCurve( CParamStrip* pParamStrip, CTrackItem* pCurve )
{
	ASSERT( pParamStrip != NULL );
	if(pParamStrip == NULL)
	{
		return;
	}

	ASSERT( pCurve != NULL );
	if(pCurve == NULL)
	{
		return;
	}

	CTrackMgr* pTrackMgr = pParamStrip->GetTrackManager();
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	m_pParamStrip = pParamStrip;

	m_fltStartValue		= pCurve->m_fltStartValue;
	m_fltEndValue		= pCurve->m_fltEndValue;
	m_dwCurveShape		= pCurve->m_dwCurveType;

	MUSIC_TIME mtDuration = pCurve->m_mtDuration;
	MUSIC_TIME mtStartTime = pCurve->m_mtStartTime;
	if(pTrackMgr->IsRefTimeTrack())
	{
		m_rtStartTime = pCurve->m_rtTimePhysical;
		m_rtDuration = pCurve->m_rtDuration;
	}
	else
	{
		pTrackMgr->ClocksToUnknownTime(mtDuration, &m_rtDuration);
		pTrackMgr->ClocksToUnknownTime(mtStartTime, &m_rtStartTime);
	}

	MUSIC_TIME mtEndTime = mtStartTime + mtDuration;

	// Get the start, end and duration bar, beat, grid tick
	if(FAILED(pTrackMgr->ClocksToMeasureBeatGridTick(mtStartTime, &m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick)))
	{
		return;
	}

	if(FAILED(pTrackMgr->ClocksToMeasureBeatGridTick(mtEndTime, &m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick)))
	{
		return;
	}

	if(FAILED(pTrackMgr->ClocksToMeasureBeatGridTick(mtDuration, &m_lDurBar, &m_lDurBeat, &m_lDurGrid, &m_lDurTick)))
	{
		return;
	}


	m_dwUndetermined	= UNDT_CURVENONE;
	m_dwUndetermined2	= 0; // &= ~(UNDT2_MERGEINDEX | UNDT2_STARTCURRENT);
	m_dwChanged			= 0;
	m_dwChanged2		= 0;

	m_fStartFromCurrent = pCurve->m_dwFlags & MPF_ENVLP_BEGIN_CURRENTVAL;
}

/////////////////////////////////////////////////////////////////////////////
// CPropCurve::Copy

void CPropCurve::Copy( CPropCurve *pPropCurve )
{
	if( pPropCurve )
	{
		*this = *pPropCurve;
	}
	else
	{
		Clear();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::Clear

void CPropCurve::Clear()
{
	memset( this, 0, sizeof(CPropCurve) );

	m_dwUndetermined	= 0xFFFFFFFF;
	m_dwUndetermined2	= 0xFFFFFFFF;

	m_pParamStrip = NULL;
	m_fStartFromCurrent = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropCurve::operator +=

CPropCurve CPropCurve::operator +=(const CPropCurve PropCurve)
{
	// Duration
	if( m_rtDuration != PropCurve.m_rtDuration )
	{
		m_dwUndetermined |= UNDT_DURATION;
	}


	// Start Value
	if( m_fltStartValue != PropCurve.m_fltStartValue )
	{
		m_dwUndetermined |= UNDT_STARTVAL;
	}

	// End Value
	if( m_fltEndValue != PropCurve.m_fltEndValue )
	{
		m_dwUndetermined |= UNDT_ENDVAL;
	}

	CTrackMgr* pTrackMgr = m_pParamStrip->GetTrackManager();
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return *this;
	}

	// Start Bar, Beat, Grid, Tick
	if( m_lStartBar != PropCurve.m_lStartBar )
	{
 		m_dwUndetermined |= UNDT_STARTBAR;
	}
	if( m_lStartBeat != PropCurve.m_lStartBeat )
	{
		m_dwUndetermined |= UNDT_STARTBEAT;
	}
	if( m_lStartGrid != PropCurve.m_lStartGrid )
	{
		m_dwUndetermined |= UNDT_STARTGRID;
	}
	if( m_lStartTick != PropCurve.m_lStartTick )
	{
		m_dwUndetermined |= UNDT_STARTTICK;
	}

	// End Bar, Beat, Grid, Tick
	if( m_lEndBar != PropCurve.m_lEndBar )
	{
		m_dwUndetermined |= UNDT_ENDBAR;
	}
	if( m_lEndBeat != PropCurve.m_lEndBeat )
	{
		m_dwUndetermined |= UNDT_ENDBEAT;
	}
	if( m_lEndGrid != PropCurve.m_lEndGrid )
	{
		m_dwUndetermined |= UNDT_ENDGRID;
	}
	if( m_lEndTick != PropCurve.m_lEndTick )
	{
		m_dwUndetermined |= UNDT_ENDTICK;
	}

	// Dur Bar, Beat, Grid, Tick
	if( m_lDurBar != PropCurve.m_lDurBar )
	{
		m_dwUndetermined |= UNDT_DURBAR;
	}
	if( m_lDurBeat != PropCurve.m_lDurBeat )
	{
		m_dwUndetermined |= UNDT_DURBEAT;
	}
	if( m_lDurGrid != PropCurve.m_lDurGrid )
	{
		m_dwUndetermined |= UNDT_DURGRID;
	}
	if( m_lDurTick != PropCurve.m_lDurTick )
	{
		m_dwUndetermined |= UNDT_DURTICK;
	}

	if(m_dwCurveShape != PropCurve.m_dwCurveShape)
	{
		m_dwUndetermined |= UNDT_SHAPE;
	}

	if(m_fStartFromCurrent != PropCurve.m_fStartFromCurrent)
	{
		m_dwUndetermined |= UNDT2_STARTCURRENT;
	}

	return *this;
}

void CPropCurve::UpdateStartBarBeatGridTick(long lStartBar, long lStartBeat, long lStartGrid, long lStartTick)
{
	m_lStartBar = lStartBar;
	m_lStartBeat = lStartBeat;
	m_lStartGrid = lStartGrid;
	m_lStartTick = lStartTick;
}

void CPropCurve::UpdateEndBarBeatGridTick(long lEndBar, long lEndBeat, long lEndGrid, long lEndTick)
{
	m_lEndBar = lEndBar;
	m_lEndBeat =lEndBeat;
	m_lEndGrid =lEndGrid;
	m_lEndTick = lEndTick;
}

void CPropCurve::UpdateDurationBarBeatGridTick(long lDurationBar, long lDurationBeat, long lDurationGrid, long lDurationTick)
{
	m_lDurBar = lDurationBar;
	m_lDurBeat = lDurationBeat;
	m_lDurGrid = lDurationGrid;
	m_lDurTick = lDurationTick;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "timeline.h"
#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\PropPageCurve.cpp ===
// PropPageCurve.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "ParamStripMgr.h"
#include "CurvePropPageMgr.h"
#include "PropCurve.h"
#include "PropPageCurve.h"
#include "TrackMgr.h"
#include "ParamStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const TCHAR achUnknown[11] = "----------";

// {F6220A90-31FD-4f64-A477-41589A9764EE}
static const GUID GUID_ParamCurveItemPPGMgr = 
{ 0xf6220a90, 0x31fd, 0x4f64, { 0xa4, 0x77, 0x41, 0x58, 0x9a, 0x97, 0x64, 0xee } };


short CCurvePropPageMgr::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCurvePropPageMgr::CCurvePropPageMgr(IDMUSProdFramework* pIFramework, CParamStrip* pParamStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT(pParamStrip);
	m_pParamStrip = pParamStrip;

	m_pTrackMgr = pParamStrip->GetTrackManager();
	ASSERT( m_pTrackMgr != NULL ); 

	// Store GUID
	m_GUIDManager = GUID_ParamCurveItemPPGMgr;

	// Initialize our pointers to NULL
	m_pTabCurve = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CCurvePropPageMgr::~CCurvePropPageMgr()
{
	// Tell the Param strip that the property page manager is going away
	if(m_pParamStrip)
	{
		m_pParamStrip->OnCurvePropPageMgrDeleted();
	}

	if( m_pTabCurve )
	{
		delete m_pTabCurve;
	}

	if(m_pIFramework)
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	m_pTrackMgr = NULL;

}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr::RemoveCurrentObject

void CCurvePropPageMgr::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CCurvePropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL) || (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	// Get "Curve" text
	CString strCurve;
	strCurve.LoadString( IDS_CURVE_TEXT );

	// Format title
	CString strTitle = strCurve;
	
	if( m_pIPropPageObject )
	{
		CParamStrip* pParamStrip = (CParamStrip *)m_pIPropPageObject;
		ASSERT(pParamStrip);
		CTrackMgr* pTrackMgr = pParamStrip->GetTrackManager();
		ASSERT(pTrackMgr);
		CTrackObject* pTrackObject = pParamStrip->GetTrackObject();
		ASSERT(pTrackObject);
		if(pTrackObject != NULL)
		{
			CString strObjectName = pTrackObject->GetName();
			CString strParam = pParamStrip->GetName();
			
			strTitle = 	strObjectName + "-" + strParam;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();
	*pfAddPropertiesText = TRUE;
		
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CCurvePropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Curve tab
	m_pTabCurve = new CPropPageCurve( this );
	if( m_pTabCurve )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabCurve->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CCurvePropPageMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	}

	CStaticPropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CCurvePropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropCurve propcurve;
	CPropCurve* pPropCurve = &propcurve;

	if( ( m_pIPropPageObject == NULL )
	||  ( m_pIPropPageObject->GetData( (void **)&pPropCurve ) != S_OK ) )
	{
		pPropCurve = NULL;
	}

	// Make sure changes to current Curve are processed in OnKillFocus
	// messages before setting the new Curve(s)
	CWnd* pWndHadFocus = CWnd::GetFocus();

	// Set Property tabs to display the new Curve(s)
	m_pTabCurve->UpdateControls( pPropCurve );
	//m_PropCurve.Copy( pPropCurve );

	// Restore focus
	if( pWndHadFocus && pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCurvePropPageMgr IDMUSProdPropPageManager::SetObject

HRESULT CCurvePropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualObject( pINewPropPageObject ) != S_OK )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing

		if( m_pIPropSheet )
		{
			m_pIPropSheet->RefreshTitle();
		}
	}

	RefreshData();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

void CPropPageCurve::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageCurve)
	DDX_Control(pDX, IDC_COMBO_ENUMSTARTVALUE, m_comboEnumStartValue);
	DDX_Control(pDX, IDC_COMBO_ENUMENDVALUE, m_comboEnumEndValue);
	DDX_Control(pDX, IDC_CHECK_START_FROM_CURRENT, m_btnStartFromCurrent);
	DDX_Control(pDX, IDC_PROMPT_TICK, m_staticPromptTick);
	DDX_Control(pDX, IDC_PROMPT_GRID, m_staticPromptGrid);
	DDX_Control(pDX, IDC_PROMPT_BEAT, m_staticPromptBeat);
	DDX_Control(pDX, IDC_PROMPT_BAR, m_staticPromptBar);
	DDX_Control(pDX, IDC_SPIN_STARTVALUE, m_spinStartValue);
	DDX_Control(pDX, IDC_SPIN_STARTTICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_STARTGRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_STARTBEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_STARTBAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_ENDVALUE, m_spinEndValue);
	DDX_Control(pDX, IDC_SPIN_ENDTICK, m_spinEndTick);
	DDX_Control(pDX, IDC_SPIN_ENDGRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_ENDBEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_ENDBAR, m_spinEndBar);
	DDX_Control(pDX, IDC_SPIN_DURTICK, m_spinDurTick);
	DDX_Control(pDX, IDC_SPIN_DURGRID, m_spinDurGrid);
	DDX_Control(pDX, IDC_SPIN_DURBEAT, m_spinDurBeat);
	DDX_Control(pDX, IDC_SPIN_DURBAR, m_spinDurBar);
	DDX_Control(pDX, IDC_EDIT_STARTVALUE, m_editStartValue);
	DDX_Control(pDX, IDC_EDIT_STARTTICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_STARTGRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_STARTBEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_STARTBAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_ENDVALUE, m_editEndValue);
	DDX_Control(pDX, IDC_EDIT_ENDTICK, m_editEndTick);
	DDX_Control(pDX, IDC_EDIT_ENDGRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_ENDBEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_ENDBAR, m_editEndBar);
	DDX_Control(pDX, IDC_EDIT_DURTICK, m_editDurTick);
	DDX_Control(pDX, IDC_EDIT_DURGRID, m_editDurGrid);
	DDX_Control(pDX, IDC_EDIT_DURBEAT, m_editDurBeat);
	DDX_Control(pDX, IDC_EDIT_DURBAR, m_editDurBar);
	DDX_Control(pDX, IDC_COMBO_SHAPE, m_comboShape);
	DDX_Control(pDX, IDC_BTN_FLIPVERT, m_btnFlipVert);
	DDX_Control(pDX, IDC_BTN_FLIPHORZ, m_btnFlipHorz);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageCurve, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageCurve)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_SHAPE, OnSelChangeComboShape)
	ON_BN_CLICKED(IDC_BTN_FLIPVERT, OnBtnFlipVert)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPVERT, OnDoubleClickedBtnFlipVert)
	ON_BN_CLICKED(IDC_BTN_FLIPHORZ, OnBtnFlipHorz)
	ON_BN_DOUBLECLICKED(IDC_BTN_FLIPHORZ, OnDoubleClickedBtnFlipHorz)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDVALUE, OnDeltaPosSpinEndValue)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTVALUE, OnDeltaPosSpinStartValue)
	ON_EN_CHANGE(IDC_EDIT_ENDVALUE, OnChangeEditEndValue)
	ON_EN_CHANGE(IDC_EDIT_STARTVALUE, OnChangeEditStartValue)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTVALUE, OnKillFocusStartValue)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDVALUE, OnKillFocusEndValue)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBAR, OnKillfocusEditStartbar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTBAR, OnDeltaposSpinStartbar)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTBEAT, OnKillfocusEditStartbeat)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTGRID, OnKillfocusEditStartgrid)
	ON_EN_KILLFOCUS(IDC_EDIT_STARTTICK, OnKillfocusEditStarttick)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBAR, OnKillfocusEditEndbar)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDBEAT, OnKillfocusEditEndbeat)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDGRID, OnKillfocusEditEndgrid)
	ON_EN_KILLFOCUS(IDC_EDIT_ENDTICK, OnKillfocusEditEndtick)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBAR, OnKillfocusEditDurbar)
	ON_EN_KILLFOCUS(IDC_EDIT_DURBEAT, OnKillfocusEditDurbeat)
	ON_EN_KILLFOCUS(IDC_EDIT_DURGRID, OnKillfocusEditDurgrid)
	ON_EN_KILLFOCUS(IDC_EDIT_DURTICK, OnKillfocusEditDurtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTBEAT, OnDeltaposSpinStartbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTGRID, OnDeltaposSpinStartgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_STARTTICK, OnDeltaposSpinStarttick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDBAR, OnDeltaposSpinEndbar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDBEAT, OnDeltaposSpinEndbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDGRID, OnDeltaposSpinEndgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ENDTICK, OnDeltaposSpinEndtick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_DURBAR, OnDeltaposSpinDurbar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_DURBEAT, OnDeltaposSpinDurbeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_DURGRID, OnDeltaposSpinDurgrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_DURTICK, OnDeltaposSpinDurtick)
	ON_BN_CLICKED(IDC_CHECK_START_FROM_CURRENT, OnCheckStartFromCurrent)
	ON_CBN_SELCHANGE(IDC_COMBO_ENUMENDVALUE, OnSelchangeComboEnumEndValue)
	ON_CBN_SELCHANGE(IDC_COMBO_ENUMSTARTVALUE, OnSelchangeComboEnumStartValue)
	ON_CBN_KILLFOCUS(IDC_COMBO_ENUMSTARTVALUE, OnKillfocusComboEnumStartValue)
	ON_CBN_KILLFOCUS(IDC_COMBO_ENUMENDVALUE, OnKillfocusComboEnumEndValue)
	ON_CBN_KILLFOCUS(IDC_COMBO_SHAPE, OnKillfocusComboShape)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////
// CPropPageCurve Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve property page

CPropPageCurve::CPropPageCurve( CCurvePropPageMgr* pCurvePropPageMgr ) : CPropertyPage(CPropPageCurve::IDD)
{
	//{{AFX_DATA_INIT(CPropPageCurve)
	//}}AFX_DATA_INIT
	
	ASSERT( pCurvePropPageMgr != NULL );

	m_pPageManager = pCurvePropPageMgr;
	m_fInUpdateControls = FALSE;
	m_fNeedToDetach = FALSE;
	m_fInOnKillFocusStartValue = FALSE;
	m_fInOnKillFocusEndValue = FALSE;

	m_bFloatType = false;
	m_bIntType = false;
	m_bEnumType = false;
	m_bBoolType = false;
}

CPropPageCurve::~CPropPageCurve()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::EnableItem

void CPropPageCurve::EnableItem( int nID, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nID );

	if( pWnd )
	{
		if( fEnable == FALSE )
		{
			pWnd->SetWindowText( achUnknown );
		}
		pWnd->EnableWindow( fEnable );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StartToUnknownTime

REFERENCE_TIME CPropPageCurve::StartToUnknownTime( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	REFERENCE_TIME rtNewStart = 0;
	if( pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime;
		pTrackMgr->MinSecGridMsToRefTime( m_PropCurve.m_pParamStrip, m_lStartBar, m_lStartBeat, m_lStartGrid, m_lStartTick, &rtTime );
		pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewStart );
	}
	else
	{
		MUSIC_TIME mtTime;
		pTrackMgr->MeasureBeatGridTickToClocks( m_lStartBar, m_lStartBeat, m_lStartGrid, m_lStartTick, &mtTime );
		pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewStart );
	}

	return rtNewStart;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::DurationToUnknownTime

REFERENCE_TIME CPropPageCurve::DurationToUnknownTime( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	REFERENCE_TIME rtNewLength = 0;

	if( pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime = 0;
		pTrackMgr->MinSecGridMsToRefTime( m_PropCurve.m_pParamStrip, m_lDurBar, m_lDurBeat, m_lDurGrid, m_lDurTick, &rtTime );
		pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewLength );
	}
	else
	{
		MUSIC_TIME mtTime = 0;
		pTrackMgr->MeasureBeatGridTickToClocks( m_lDurBar, m_lDurBeat, m_lDurGrid, m_lDurTick, &mtTime );
		pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewLength );
	}

	return rtNewLength;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::MinTimeToUnknownTime

REFERENCE_TIME CPropPageCurve::MinTimeToUnknownTime( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	REFERENCE_TIME rtMinTime;

	if( pTrackMgr->IsRefTimeTrack() )
	{
		pTrackMgr->MinSecGridMsToRefTime( m_PropCurve.m_pParamStrip, 0, 0, 0, 1, &rtMinTime );
	}
	else
	{
		MUSIC_TIME mtMinTime;
		pTrackMgr->MeasureBeatGridTickToClocks( 0, 0, 0, 1, &mtMinTime );
		rtMinTime = mtMinTime;
	}

	return rtMinTime;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::MinTimeToRefTime

REFERENCE_TIME CPropPageCurve::MinTimeToRefTime( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	REFERENCE_TIME rtMinTime = 0;

	if( pTrackMgr->IsRefTimeTrack() )
	{
		pTrackMgr->MinSecGridMsToRefTime( m_PropCurve.m_pParamStrip, 0, 0, 0, 1, &rtMinTime );
	}
	else
	{
		MUSIC_TIME mtMinTime;
		pTrackMgr->MeasureBeatGridTickToClocks( 0, 0, 0, 1, &mtMinTime );
		pTrackMgr->m_pTimeline->ClocksToRefTime( mtMinTime, &rtMinTime );
	}

	return rtMinTime;
}



/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::RecomputeTimes

void CPropPageCurve::RecomputeTimes()
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	if( pTrackMgr->IsRefTimeTrack() )
	{
		ComputeMinSecGridMs();
	}
	else
	{
		ComputeBarBeatGridTick();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::ComputeMinSecGridMs

void CPropPageCurve::ComputeMinSecGridMs( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	// START
	pTrackMgr->RefTimeToMinSecGridMs( m_PropCurve.m_pParamStrip, m_PropCurve.m_rtStartTime,
										&m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );
	

	// END
	pTrackMgr->RefTimeToMinSecGridMs( m_PropCurve.m_pParamStrip, m_PropCurve.m_rtStartTime + m_PropCurve.m_rtDuration,
										&m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );
	

	// LENGTH
	pTrackMgr->RefTimeToMinSecGridMs( m_PropCurve.m_pParamStrip, m_PropCurve.m_rtDuration,
										&m_lDurBar, &m_lDurBeat, &m_lDurGrid, &m_lDurTick );

}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::ComputeBarBeatGridTick

void CPropPageCurve::ComputeBarBeatGridTick( void )
{
	MUSIC_TIME mtTime = 0;

	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}


	// START
	pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropCurve.m_rtStartTime, &m_lStartBar, &m_lStartBeat, &m_lStartGrid, &m_lStartTick );

	// END
	pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropCurve.m_rtStartTime + (MUSIC_TIME)m_PropCurve.m_rtDuration, &m_lEndBar, &m_lEndBeat, &m_lEndGrid, &m_lEndTick );

	// LENGTH
	pTrackMgr->ClocksToMeasureBeatGridTick( (MUSIC_TIME)m_PropCurve.m_rtDuration, &m_lDurBar, &m_lDurBeat, &m_lDurGrid, &m_lDurTick );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetControlRanges

void CPropPageCurve::SetControlRanges( CPropCurve* pPropCurve )
{

	// Get track group bits
	DWORD dwGroupBits = 0xFFFFFFFF;
	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPageManager->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			VARIANT variant;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Set ranges for "time" controls
	if( m_pPageManager->m_pTrackMgr->IsRefTimeTrack() )
	{
		SetRefTimeRanges();
	}
	else
	{
		SetMusicTimeRanges( dwGroupBits, pPropCurve );
	}


	// 'Start' and 'End' value controls
	
	m_editStartValue.LimitText( 3 );
	m_editEndValue.LimitText( 3 );
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		//char szMaxValue[32];
		//itoa((int)pParamStrip->m_ParamInfo.mpdMaxValue, szMaxValue, 10);
		//char szMinValue[32];
		//itoa((int)pParamStrip->m_ParamInfo.mpdMinValue, szMinValue, 10);
		CString sMaxValue;
		sMaxValue.Format("%.03f", pParamStrip->m_ParamInfo.mpdMaxValue);
		CString sMinValue;
		sMinValue.Format("%.03f", pParamStrip->m_ParamInfo.mpdMinValue);

		int nMaxLength = sMaxValue.GetLength();
		int nMinLength = sMinValue.GetLength();
		int nLength = nMaxLength > nMinLength ? nMaxLength : nMinLength;

		m_editStartValue.LimitText( nLength );
		m_editEndValue.LimitText( nLength );

		float fMinValueRange = pParamStrip->m_ParamInfo.mpdMinValue;
		float fMaxValueRange = pParamStrip->m_ParamInfo.mpdMaxValue - pParamStrip->m_ParamInfo.mpdMinValue;

		// Figure out the range if the actual range is less than 1
		if(fMaxValueRange <= 1)
		{
			fMinValueRange = 1;
			fMaxValueRange = 1 + (fMaxValueRange / 0.001);	
		}

		m_spinStartValue.SetRange(fMinValueRange, fMaxValueRange);
		m_spinEndValue.SetRange(fMinValueRange, fMaxValueRange);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetRefTimeRanges

void CPropPageCurve::SetRefTimeRanges( void )
{
	// Limit the minute number to positive numbers
	m_spinStartBar.SetRange( 1, 32767 );
	m_editStartBar.LimitText( 5 );
	m_spinEndBar.SetRange( 1, 32767 );
	m_editEndBar.LimitText( 5 );
	m_spinDurBar.SetRange( 0, 32767 );
	m_editDurBar.LimitText( 5 );

	// Limit the second number to 1-60
	m_spinStartBeat.SetRange( 1, 60 );
	m_editStartBeat.LimitText( 2 );
	m_spinEndBeat.SetRange( 1, 60 );
	m_editEndBeat.LimitText( 2 );
	m_spinDurBeat.SetRange( 0, 60 );
	m_editDurBeat.LimitText( 2 );

	// Limit the grid number to MIN_NBR_GRIDS_PER_SECOND - MAX_NBR_GRIDS_PER_SECOND
	m_spinStartGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( MIN_NBR_GRIDS_PER_SECOND, MAX_NBR_GRIDS_PER_SECOND );
	m_editEndGrid.LimitText( 3 );
	m_spinDurGrid.SetRange( (MIN_NBR_GRIDS_PER_SECOND - 1), MAX_NBR_GRIDS_PER_SECOND );
	m_editDurGrid.LimitText( 3 );

	// Limit the millisecond number to 1-1000
	m_spinStartTick.SetRange( 1, 1000 );
	m_editStartTick.LimitText( 4 );
	m_spinEndTick.SetRange( 1, 1000 );
	m_editEndTick.LimitText( 4 );
	m_spinDurTick.SetRange( 1, 1000 );
	m_editDurTick.LimitText( 4 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetMusicTimeRanges

void CPropPageCurve::SetMusicTimeRanges( DWORD dwGroupBits, CPropCurve* pPropCurve )
{

	ASSERT(pPropCurve);
	if(pPropCurve == NULL)
	{
		return;
	}

	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = NULL;
	pTimeline = pTrackMgr->GetTimeline();

	long lMaxMeasure = 0;
	long lMaxBeat = 0;
	long lMaxGrid = 0;

	// Get the maximum measure value
	if( pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
		lMaxGrid = 256;
	}
	else
	{
		lMaxGrid = 256;	// Fix this!!!

		// Get the length of the timeline, in clocks
		VARIANT var;
		pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		pTimeline->ClocksToMeasureBeat( dwGroupBits, 0, V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				pTimeline->ClocksToMeasureBeat( dwGroupBits, 0, V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		long lItemMeasure = 0;
		long lItemBeat = 0;
		long lItemGrid = 0;
		long lItemTick = 0;

		pTrackMgr->UnknownTimeToMeasureBeatGridTick( pPropCurve->m_rtStartTime, &lItemMeasure, &lItemBeat, &lItemGrid, &lItemTick );

		// If the item is not in the last measure
		if( lItemMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pPageManager->m_pTrackMgr->m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lItemMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pPageManager->m_pTrackMgr->m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Update the range for the measure spin control
	m_spinStartBar.SetRange( 1, lMaxMeasure );
	m_editStartBar.LimitText( 5 );
	m_spinEndBar.SetRange( 1, lMaxMeasure );
	m_editEndBar.LimitText( 5 );
	m_spinDurBar.SetRange( 0, lMaxMeasure );
	m_editDurBar.LimitText( 5 );

	// Update the range for the beat spin control
	m_spinStartBeat.SetRange( 1, lMaxBeat );
	m_editStartBeat.LimitText( 3 );
	m_spinEndBeat.SetRange( 1, lMaxBeat );
	m_editEndBeat.LimitText( 3 );
	m_spinDurBeat.SetRange( 0, lMaxBeat );
	m_editDurBeat.LimitText( 3 );

	// Update the range for the grid spin control
	m_spinStartGrid.SetRange( 1, lMaxGrid );
	m_editStartGrid.LimitText( 3 );
	m_spinEndGrid.SetRange( 1, lMaxGrid );
	m_editEndGrid.LimitText( 3 );
	m_spinDurGrid.SetRange( 0, lMaxGrid );
	m_editDurGrid.LimitText( 3 );

	// Update the range for the tick spin control
	m_spinStartTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editStartTick.LimitText( 5 );
	m_spinEndTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editEndTick.LimitText( 5 );
	m_spinDurTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editDurTick.LimitText( 5 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::EnableControls

void CPropPageCurve::EnableControls( BOOL fEnable ) 
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	// Reference time or music time?
	CString strPrompt;
	if(  pTrackMgr->IsRefTimeTrack() )
	{
		strPrompt.LoadString( IDS_MIN_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_SEC_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_MS_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}
	else
	{
		strPrompt.LoadString( IDS_BAR_TEXT );
		m_staticPromptBar.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_BEAT_TEXT );
		m_staticPromptBeat.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_GRID_TEXT );
		m_staticPromptGrid.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_TICK_TEXT );
		m_staticPromptTick.SetWindowText( strPrompt );
	}

	EnableItem( IDC_EDIT_STARTBAR, fEnable );
	m_spinStartBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTBEAT, fEnable );
	m_spinStartBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTGRID, fEnable );
	m_spinStartGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTTICK, fEnable );
	m_spinStartTick.EnableWindow( fEnable );

	EnableItem( IDC_EDIT_ENDBAR, fEnable );
	m_spinEndBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDBEAT, fEnable );
	m_spinEndBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDGRID, fEnable );
	m_spinEndGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDTICK, fEnable );
	m_spinEndTick.EnableWindow( fEnable );

	EnableItem( IDC_EDIT_DURBAR, fEnable );
	m_spinDurBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURBEAT, fEnable );
	m_spinDurBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURGRID, fEnable );
	m_spinDurGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURTICK, fEnable );
	m_spinDurTick.EnableWindow( fEnable );

	bool bShowCombos = m_bEnumType || m_bBoolType;
	m_comboEnumStartValue.ShowWindow(bShowCombos);
	m_comboEnumEndValue.ShowWindow(bShowCombos);

	CWnd* pWnd = GetDlgItem(IDC_EDIT_STARTVALUE);
	if(pWnd)
	{
		pWnd->ShowWindow(!bShowCombos);
	}
	
	pWnd = GetDlgItem(IDC_EDIT_ENDVALUE);
	if(pWnd)
	{
		pWnd->ShowWindow(!bShowCombos);
	}
	
	m_spinStartValue.ShowWindow(!bShowCombos);
	m_spinEndValue.ShowWindow(!bShowCombos);

	if(fEnable)
	{
		if(bShowCombos)
		{
			m_comboEnumStartValue.EnableWindow(fEnable);
			m_comboEnumEndValue.EnableWindow(fEnable);
		}
		else
		{
			// Disable and hide the controls
			EnableItem( IDC_EDIT_STARTVALUE, fEnable );
			m_spinStartValue.EnableWindow( fEnable );
			EnableItem( IDC_EDIT_ENDVALUE, fEnable );
			m_spinEndValue.EnableWindow( fEnable );
		}
	}
	else
	{
		if(bShowCombos)
		{
			EnableItem(IDC_COMBO_ENUMSTARTVALUE, fEnable);
			EnableItem(IDC_COMBO_ENUMENDVALUE, fEnable);
		}
		else
		{
			EnableItem( IDC_EDIT_STARTVALUE, fEnable );
			m_spinStartValue.EnableWindow( fEnable );
			EnableItem( IDC_EDIT_ENDVALUE, fEnable );
			m_spinEndValue.EnableWindow( fEnable );
		}
	}
	
	EnableItem(IDC_COMBO_SHAPE, fEnable);
	/*m_comboShape.EnableWindow( fEnable );*/
	m_btnFlipHorz.EnableWindow( fEnable );
	m_btnFlipVert.EnableWindow( fEnable );

	m_btnStartFromCurrent.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinStartValuePos

void CPropPageCurve::SetSpinStartValuePos( int nStartValue )
{
	m_spinStartValue.SetPos( nStartValue );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::GetSpinStartValuePos

int CPropPageCurve::GetSpinStartValuePos( void )
{
	int nStartValue = LOWORD(m_spinStartValue.GetPos());

	return nStartValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinEndValuePos

void CPropPageCurve::SetSpinEndValuePos( int nEndValue )
{
	m_spinEndValue.SetPos( nEndValue );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::GetSpinEndValuePos

int CPropPageCurve::GetSpinEndValuePos( void )
{
	int nEndValue = LOWORD(m_spinEndValue.GetPos());
	return nEndValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::UpdateControls

void CPropPageCurve::UpdateControls( CPropCurve* pPropCurve )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPageManager != NULL );
	
	// Make sure controls have been created
	if( ::IsWindow(m_btnFlipVert.m_hWnd) == FALSE )
	{
		return;
	}

	m_fInUpdateControls = TRUE;

	// Update controls
	if( pPropCurve == NULL )
	{
		EnableControls( FALSE );
		m_fInUpdateControls = FALSE;
		return;
	}

	m_bBoolType = false;
	m_bEnumType = false;
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	if(pParamStrip != NULL)
	{
		m_bEnumType = pParamStrip->m_ParamInfo.mpType == MPT_ENUM;
		m_bBoolType = pParamStrip->m_ParamInfo.mpType == MPT_BOOL;
		m_bFloatType = pParamStrip->m_ParamInfo.mpType == MPT_FLOAT;
		m_bIntType = pParamStrip->m_ParamInfo.mpType == MPT_INT;
	}

	EnableControls( TRUE );

	if(m_bEnumType)
	{
		WCHAR* pwszEnumText = NULL;
		CTrackObject* pTrackObject = pParamStrip->GetTrackObject();
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			GUID clsidObject = pTrackObject->GetCLSID();
			DWORD dwParamIndex = pParamStrip->GetParamIndex();
			if(FAILED(CTrackObject::GetParamEnumTypeText(clsidObject, dwParamIndex, &pwszEnumText)))
			{
				return;
			}
		}

		CList<CString, CString&> lstEnumStrings;
		CString sParamName;
		CString sParamUnitLabel;
		DWORD dwCount = 0;
		if(FAILED(CTrackObject::ParseEnumText(pwszEnumText, sParamName, sParamUnitLabel, &lstEnumStrings, &dwCount)))
		{
			return; 
		}

		// Free the allocated text
		::CoTaskMemFree(pwszEnumText);

		// Fill up the combo boxes with enum types
		m_comboEnumStartValue.ResetContent();
		m_comboEnumEndValue.ResetContent();

		DWORD dwValue = 0;
		POSITION position = lstEnumStrings.GetHeadPosition();
		while(position)
		{
			CString sText = lstEnumStrings.GetNext(position);
			int nIndex = m_comboEnumStartValue.AddString(sText);
			if(nIndex == CB_ERR)
			{
				return;
			}
			m_comboEnumStartValue.SetItemData(nIndex, dwValue);

			nIndex = m_comboEnumEndValue.AddString(sText);
			if(nIndex == CB_ERR)
			{
				return;
			}
			m_comboEnumEndValue.SetItemData(nIndex, dwValue);
			dwValue++;
		}
	}

	if(m_bBoolType)
	{
		// Fill up the combo boxes with BOOL types
		m_comboEnumStartValue.ResetContent();
		m_comboEnumEndValue.ResetContent();

		CString sFalse;
		sFalse.LoadString(IDS_BOOL_FALSE);

		CString sTrue;
		sTrue.LoadString(IDS_BOOL_TRUE);

		int nIndex = m_comboEnumStartValue.AddString(sFalse);
		m_comboEnumStartValue.SetItemData(nIndex, 0);
		nIndex = m_comboEnumStartValue.AddString(sTrue);
		m_comboEnumStartValue.SetItemData(nIndex, 1);

		nIndex = m_comboEnumEndValue.AddString(sFalse);
		m_comboEnumEndValue.SetItemData(nIndex, 0);
		nIndex = m_comboEnumEndValue.AddString(sTrue);
		m_comboEnumEndValue.SetItemData(nIndex, 1);
	}

	// Copy the common properties object and set the control ranges
	m_PropCurve.Copy(pPropCurve);
	SetControlRanges( &m_PropCurve);

	// Get the bar, beat, grid and tick for the properties object
	// So we can update the values in the curve to figure out what's indeterminate
	ComputeBarBeatGridTick();
	m_PropCurve.UpdateStartBarBeatGridTick(m_lStartBar, m_lStartBeat, m_lStartGrid, m_lStartTick);
	m_PropCurve.UpdateEndBarBeatGridTick(m_lEndBar, m_lEndBeat, m_lEndGrid, m_lEndTick);
	m_PropCurve.UpdateDurationBarBeatGridTick(m_lDurBar, m_lDurBeat, m_lDurGrid, m_lDurTick);
	
	RecomputeTimes();

	// Set nMeasureBeatOffset
	int nMeasureBeatOffset;
	if( m_pPageManager->m_pTrackMgr->IsRefTimeTrack() )
	{
		nMeasureBeatOffset = 0;
	}
	else
	{
		nMeasureBeatOffset = 1;
	}


	if( pParamStrip && pParamStrip->IsOneGrid())
	{
		m_editStartGrid.SetWindowText( NULL );
		m_editStartGrid.EnableWindow( FALSE );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndGrid.EnableWindow( FALSE );
		m_editDurGrid.SetWindowText( NULL );
		m_editDurGrid.EnableWindow( FALSE );
	}

	int nPos = 0;

	if( pPropCurve->m_dwUndetermined & UNDT_STARTBAR )
	{
		m_editStartBar.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editStartBar, m_lStartBar, nMeasureBeatOffset);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTBEAT )
	{
		m_editStartBeat.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editStartBeat, m_lStartBeat, nMeasureBeatOffset);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTGRID )
	{
		m_editStartGrid.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editStartGrid, m_lStartGrid, 1);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTTICK )
	{
		m_editStartTick.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editStartTick, m_lStartTick, 0);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDBAR )
	{
		m_editEndBar.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editEndBar, m_lEndBar, nMeasureBeatOffset);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDBEAT )
	{
		m_editEndBeat.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editEndBeat, m_lEndBeat, nMeasureBeatOffset);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDGRID )
	{
		m_editEndGrid.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editEndGrid, m_lEndGrid, 1);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDTICK )
	{
		m_editEndTick.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editEndTick, m_lEndTick, 0);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURBAR )
	{
		m_editDurBar.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editDurBar, m_lDurBar, 0);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURBEAT )
	{
		m_editDurBeat.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editDurBeat, m_lDurBeat, 0);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURGRID )
	{
		m_editDurGrid.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editDurGrid, m_lDurGrid, 0);
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURTICK )
	{
		m_editDurTick.SetWindowText( achUnknown );
	}
	else
	{
		SetEditControl(m_editDurTick, m_lDurTick, 0);
	}

	if(m_bFloatType || m_bIntType)
	{
		if( pPropCurve->m_dwUndetermined & UNDT_STARTVAL )
		{
			m_editStartValue.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			float fStartValue = pPropCurve->m_fltStartValue;
			StartEndValueToString( fStartValue, strValue );

			CString strCurrentText;
			m_editStartValue.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editStartValue.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editStartValue.SetSel( 0, -1 );
				m_editStartValue.SetSel( -1, -1 );

				float fRangeGranularity = 1;
				float fValueRange = (pParamStrip->m_ParamInfo.mpdMaxValue - pParamStrip->m_ParamInfo.mpdMinValue);
				
				if(fValueRange <= 1)
				{
					fRangeGranularity = 0.001f; 
				}

				if(fValueRange > 1)
				{
					SetSpinStartValuePos(fStartValue);
				}
				else
				{
					SetSpinStartValuePos(fStartValue / fRangeGranularity);
				}

			}
		}
	}
	else if(m_bEnumType || m_bBoolType)
	{
		if( pPropCurve->m_dwUndetermined & UNDT_STARTVAL )
		{
			m_comboEnumStartValue.SetWindowText( achUnknown );
		}
		else
		{		
			m_comboEnumStartValue.SetCurSel((int)pPropCurve->m_fltStartValue);
		}

	}

	if(m_bFloatType || m_bIntType)
	{
		if( pPropCurve->m_dwUndetermined & UNDT_ENDVAL )
		{
			m_editEndValue.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			float fEndValue = pPropCurve->m_fltEndValue;
			StartEndValueToString( fEndValue, strValue );

			CString strCurrentText;
			m_editEndValue.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editEndValue.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editEndValue.SetSel( 0, -1 );
				m_editEndValue.SetSel( -1, -1 );

				float fRangeGranularity = 1;
				float fValueRange = (pParamStrip->m_ParamInfo.mpdMaxValue - pParamStrip->m_ParamInfo.mpdMinValue);
				
				if(fValueRange <= 1)
				{
					fRangeGranularity = 0.001f; 
				}

				if(fValueRange > 1)
				{
					SetSpinEndValuePos(fEndValue);
				}
				else
				{
					SetSpinEndValuePos(fEndValue / fRangeGranularity);
				}
			}
		}
	}
	else if(m_bEnumType || m_bBoolType)
	{
		if( pPropCurve->m_dwUndetermined & UNDT_ENDVAL )
		{
			m_comboEnumEndValue.SetWindowText( achUnknown );
		}
		else
		{
			m_comboEnumEndValue.SetCurSel((int)pPropCurve->m_fltEndValue);
		}	
	}

	InitShapeCombo(pPropCurve);

	if(pPropCurve->m_dwUndetermined & UNDT2_STARTCURRENT)
	{
		m_btnStartFromCurrent.SetCheck(2);
	}
	else
	{

		if(pPropCurve->m_fStartFromCurrent == TRUE)
		{
			m_btnStartFromCurrent.SetCheck(1);
		}
		else
		{
			m_btnStartFromCurrent.SetCheck(0);
		}
	}


	m_fInUpdateControls = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve message handlers


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnCreate

int CPropPageCurve::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDestroy

void CPropPageCurve::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnSetActive

BOOL CPropPageCurve::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnInitDialog

BOOL CPropPageCurve::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Fill shape combo box
	TCHAR achShape[32];

	for ( int i = IDS_CURVE_SHAPE1 ;  i <= IDS_CURVE_SHAPE5 ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i, achShape, 32 );
		m_comboShape.AddString( achShape );
	}
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnSelChangeComboShape

void CPropPageCurve::OnSelChangeComboShape() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_PropCurve.m_dwCurveShape = 0xFF; 

	switch( m_comboShape.GetCurSel() )
	{
		case 0:
			m_PropCurve.m_dwCurveShape = MP_CURVE_SINE; 
			break;

		case 1:
			m_PropCurve.m_dwCurveShape = MP_CURVE_INVSQUARE; 
			break;

		case 2:
			m_PropCurve.m_dwCurveShape = MP_CURVE_SQUARE; 
			break;

		case 3:
			m_PropCurve.m_dwCurveShape = MP_CURVE_JUMP; 
			break;

		case 4:
			m_PropCurve.m_dwCurveShape = MP_CURVE_LINEAR; 
			break;
	}

	if( m_PropCurve.m_dwCurveShape != 0xFF )
	{
		m_PropCurve.m_dwChanged = CHGD_SHAPE;
		m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnBtnFlipVert

void CPropPageCurve::OnBtnFlipVert() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_PropCurve.m_dwChanged = CHGD_FLIPVERT;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDoubleClickedBtnFlipVert

void CPropPageCurve::OnDoubleClickedBtnFlipVert() 
{
	OnBtnFlipVert();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnBtnFlipHorz

void CPropPageCurve::OnBtnFlipHorz() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_PropCurve.m_dwChanged = CHGD_FLIPHORZ;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDoubleClickedBtnFlipHorz

void CPropPageCurve::OnDoubleClickedBtnFlipHorz() 
{
	OnBtnFlipHorz();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartValue

void CPropPageCurve::OnKillFocusStartValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusStartValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusStartValue = TRUE;



	float fltMin = 0;
	float fltMax = 127;
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
		fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;
	}

	float fRangeGranularity = 1;
	float fValueRange = (fltMax - fltMin);
	
	if(fValueRange <= 1)
	{
		fRangeGranularity = 0.001f; 
	}

	// Get current end value
	float fltCurStartValue = (float)GetSpinStartValuePos();
	if(fValueRange > 1)
	{
		fltCurStartValue = (float)GetSpinStartValuePos() + fRangeGranularity;
	}
	else
	{
		fltCurStartValue = (float)GetSpinStartValuePos() * fRangeGranularity;
	}

	if(fltCurStartValue > fltMax)
	{
		fltCurStartValue = fltCurStartValue - 65536;
	}

	// Get text from edit control
	CString strNewStartValue;
	m_editStartValue.GetWindowText( strNewStartValue );
	strNewStartValue.TrimRight();
	strNewStartValue.TrimLeft();

	float fltNewStartValue = 0;

	// Handle unknown text
	if( _tcsncmp( strNewStartValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewStartValue.IsEmpty() )
	{
		fltNewStartValue = 0; // Set to 0
	}
	else
	{
		fltNewStartValue = StringToStartEndValue( strNewStartValue );
		if( fltNewStartValue == 0xFFFFFFFF)
		{
			fltNewStartValue = fltCurStartValue;	// No change
		}
		else
		{
			// Make sure value is within range
			if( fltNewStartValue < fltMin )
			{
				fltNewStartValue = fltMin;
			}
			if( fltNewStartValue > fltMax )
			{
				fltNewStartValue = fltMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( fltCurStartValue != fltNewStartValue )
	{
		if(fValueRange > 1)
		{
			SetSpinStartValuePos( (int)fltNewStartValue );
		}
		else
		{
			SetSpinStartValuePos( (int)(0.5 + (fltNewStartValue / fRangeGranularity)) );
		}

		m_PropCurve.m_dwChanged = UNDT_STARTVAL;
		m_PropCurve.m_fltStartValue = fltNewStartValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( fltNewStartValue, strValue );
		m_editStartValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editStartValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editStartValue.SetSel( 0, -1 );
			m_editStartValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusStartValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDeltaPosSpinStartValue

void CPropPageCurve::OnDeltaPosSpinStartValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}
	
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip == NULL)
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillFocusStartValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	float fRangeGranularity = 1;
	float fValueRange = (pParamStrip->m_ParamInfo.mpdMaxValue - pParamStrip->m_ParamInfo.mpdMinValue);
	
	if(fValueRange <= 1)
	{
		fRangeGranularity = 0.001f; 
	}

	float fltOldValue  = (float)GetSpinStartValuePos();
	if(fValueRange < 1)
	{
		fltOldValue  = fltOldValue  * fRangeGranularity;
	}

	if(fltOldValue == pParamStrip->m_ParamInfo.mpdMaxValue && pNMUpDown->iDelta > 0)
	{
		return;
	}

	if(fltOldValue == pParamStrip->m_ParamInfo.mpdMinValue && pNMUpDown->iDelta < 0)
	{
		return;
	}

	float fltNewStartValue = 0;
	if(fValueRange > 1)
	{
		if(pNMUpDown->iDelta > 0)
		{
			fltNewStartValue = (float)GetSpinStartValuePos() + fRangeGranularity;
		}
		else if(pNMUpDown->iDelta < 0)
		{
			fltNewStartValue = (float)GetSpinStartValuePos() - fRangeGranularity;
		}
	}
	else
	{
		if(pNMUpDown->iDelta > 0)
		{
			fltNewStartValue = ((float)GetSpinStartValuePos() * fRangeGranularity) + fRangeGranularity;
		}
		else if(pNMUpDown->iDelta < 0)
		{
			fltNewStartValue = ((float)GetSpinStartValuePos() * fRangeGranularity) - fRangeGranularity;
		}
	}

	// Get StartValue range
	float fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
	float fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;

	if(fltNewStartValue > fltMax + 0.5)
	{
		fltNewStartValue = fltNewStartValue - 65536;
	}

	// Make sure value is within range
	if( fltNewStartValue < fltMin )
	{
		fltNewStartValue = fltMin;
	}
	if( fltNewStartValue > fltMax )
	{
		fltNewStartValue = fltMax;
	}

	CString strValue;

	StartEndValueToString( fltNewStartValue, strValue );
	m_editStartValue.SetWindowText( strValue );
	if(fValueRange > 1)
	{
		SetSpinStartValuePos( (int)fltNewStartValue );
	}
	else
	{
		SetSpinStartValuePos( (int)(0.5 + (fltNewStartValue / fRangeGranularity)) );
	}

	m_PropCurve.m_dwChanged = CHGD_STARTVAL;
	m_PropCurve.m_fltStartValue = fltNewStartValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndValue

void CPropPageCurve::OnKillFocusEndValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusEndValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusEndValue = TRUE;

	float fltMin = 0;
	float fltMax = 127;
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
		fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;
	}

	float fRangeGranularity = 1;
	float fValueRange = (fltMax - fltMin);
	
	if(fValueRange <= 1)
	{
		fRangeGranularity = 0.001f; 
	}

	// Get current end value
	float fltCurEndValue = (float)GetSpinEndValuePos();
	if(fValueRange > 1)
	{
		fltCurEndValue = (float)GetSpinEndValuePos() + fRangeGranularity;
	}
	else
	{
		fltCurEndValue = (float)GetSpinEndValuePos() * fRangeGranularity;
	}

	if(fltCurEndValue > fltMax)
	{
		fltCurEndValue = fltCurEndValue - 65536;
	}

	// Get text from edit control
	CString strNewEndValue;
	m_editEndValue.GetWindowText( strNewEndValue );
	strNewEndValue.TrimRight();
	strNewEndValue.TrimLeft();

	float fltNewEndValue;

	// Handle unknown text
	if( _tcsncmp( strNewEndValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewEndValue.IsEmpty() )
	{
		fltNewEndValue = 0; // Set to 0
	}
	else
	{
		fltNewEndValue = StringToStartEndValue( strNewEndValue );
		if( fltNewEndValue == 0xFFFFFFFF)
		{
			fltNewEndValue = fltCurEndValue;	// No change
		}
		else
		{
			// Make sure value is within range
			if( fltNewEndValue < fltMin )
			{
				fltNewEndValue = fltMin;
			}
			if( fltNewEndValue > fltMax )
			{
				fltNewEndValue = fltMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( fltCurEndValue != fltNewEndValue )
	{
		if(fValueRange > 1)
		{
			SetSpinEndValuePos( (int)fltNewEndValue );
		}
		else
		{
			SetSpinEndValuePos( (int)(0.5 + (fltNewEndValue / fRangeGranularity)));
		}

		m_PropCurve.m_dwChanged = CHGD_ENDVAL;
		m_PropCurve.m_fltEndValue = fltNewEndValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( fltNewEndValue, strValue );
		m_editEndValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editEndValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editEndValue.SetSel( 0, -1 );
			m_editEndValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusEndValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDeltaPosSpinEndValue

void CPropPageCurve::OnDeltaPosSpinEndValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get EndValue range
	float fltMin = 0;
	float fltMax = 127;

	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
		fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;
	}


	// Just in case user clicked on spin control immediately after typing text
	OnKillFocusEndValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	float fRangeGranularity = 1;
	float fValueRange = fltMax - fltMin;
	
	if(fValueRange <= 1)
	{
		fRangeGranularity = 0.001f; 
	}

	float fltOldValue  = (float)GetSpinEndValuePos();
	
	if(fltOldValue == fltMax && pNMUpDown->iDelta > 0)
	{
		return;
	}
		
	if(fltOldValue == fltMin && pNMUpDown->iDelta < 0)
	{
		return;
	}

	float fltNewEndValue = 0;  
	if(fValueRange > 1)
	{
		if(pNMUpDown->iDelta > 0)
		{
			fltNewEndValue = (float)GetSpinEndValuePos() + fRangeGranularity;
		}
		else if(pNMUpDown->iDelta < 0)
		{
			fltNewEndValue = (float)GetSpinEndValuePos() - fRangeGranularity;
		}
	}
	else
	{
		if(pNMUpDown->iDelta > 0)
		{
			fltNewEndValue = ((float)GetSpinEndValuePos() * fRangeGranularity) + fRangeGranularity;
		}
		else if(pNMUpDown->iDelta < 0)
		{
			fltNewEndValue = ((float)GetSpinEndValuePos() * fRangeGranularity) - fRangeGranularity;
		}
	}

	
	if(fltNewEndValue > fltMax + 0.5)
	{
		fltNewEndValue = fltNewEndValue - 65536;
	}

	// Make sure value is within range
	if( fltNewEndValue < fltMin )
	{
		fltNewEndValue = fltMin;
	}
	if( fltNewEndValue > fltMax )
	{
		fltNewEndValue = fltMax;
	}

	CString strValue;

	StartEndValueToString( fltNewEndValue, strValue );
	m_editEndValue.SetWindowText( strValue );

	if(fValueRange > 1)
	{
		SetSpinEndValuePos( (int)fltNewEndValue );
	}
	else
	{
		SetSpinEndValuePos( (int)(0.5 + (fltNewEndValue / fRangeGranularity)) );
	}


	m_PropCurve.m_dwChanged = CHGD_ENDVAL;
	m_PropCurve.m_fltEndValue = fltNewEndValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StartEndValueToString

void CPropPageCurve::StartEndValueToString( float fltValue, CString& strValue ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	strValue.Format( "%.03f", fltValue );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StringToStartEndValue

float CPropPageCurve::StringToStartEndValue( LPCTSTR pszNewValue )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewValue = pszNewValue;
	int nLength = strNewValue.GetLength();

	float fltNewValue = (float)atof( strNewValue );

	return fltNewValue;
}

void CPropPageCurve::OnChangeEditEndValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
/*	CString strNewEndValue;
	m_editEndValue.GetWindowText( strNewEndValue );
	strNewEndValue.TrimRight();
	strNewEndValue.TrimLeft();

	// Return if string is empty
	if( strNewEndValue.IsEmpty() )
	{
		return;
	}

	float fltMin = 0;
	float fltMax = 127;
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
		fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;
	}

	if(fltMin >= 0)
	{
		// Return if string equals minus sign
		CString strMinus;
		strMinus.LoadString( IDS_MINUS_TEXT );
		if( strMinus.CompareNoCase(strNewEndValue) == 0 )
		{
			return;
		}
	}

	OnKillFocusEndValue();*/
}

void CPropPageCurve::OnChangeEditStartValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/*if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewStartValue;
	m_editStartValue.GetWindowText( strNewStartValue );
	strNewStartValue.TrimRight();
	strNewStartValue.TrimLeft();

	// Return if string is empty
	if( strNewStartValue.IsEmpty() )
	{
		return;
	}

	// Return if string equals minus sign

	float fltMin = 0;
	float fltMax = 127;
	CParamStrip* pParamStrip = (CParamStrip *)m_pPageManager->m_pIPropPageObject;
	ASSERT(pParamStrip);
	if(pParamStrip != NULL)
	{
		fltMin = pParamStrip->m_ParamInfo.mpdMinValue;
		fltMax = pParamStrip->m_ParamInfo.mpdMaxValue;
	}

	if(fltMin >= 0)
	{
		CString strMinus;
		strMinus.LoadString( IDS_MINUS_TEXT );
		if( strMinus.CompareNoCase(strNewStartValue) == 0 )
		{
			return;
		}
	}

	OnKillFocusStartValue();*/
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetStart

void CPropPageCurve::SetStart( REFERENCE_TIME rtNewStart ) 
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	REFERENCE_TIME rtSegmentLength = pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurEnd = EndToUnknownTime();

	REFERENCE_TIME rtMinStart;
	pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );

	rtNewStart = max( rtNewStart, rtMinStart );
	rtNewStart = min( rtNewStart, rtSegmentLength - rtMinTime );
	
	REFERENCE_TIME rtDuration = m_PropCurve.m_rtDuration;

	rtDuration = max( rtDuration, rtMinTime );

	if( m_PropCurve.m_rtStartTime != rtNewStart || m_PropCurve.m_rtDuration != rtDuration )
	{
		m_PropCurve.m_rtStartTime = rtNewStart;
		m_PropCurve.m_rtDuration = rtDuration;

		// Now, update the object with the new value(s)
		UpdateObject();
	}
	else
	{
		// Display original values
		UpdateControls( &m_PropCurve );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetEnd

void CPropPageCurve::SetEnd( REFERENCE_TIME rtNewEnd ) 
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	REFERENCE_TIME rtSegmentLength = pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurStart = StartToUnknownTime();
	REFERENCE_TIME rtCurLength = DurationToUnknownTime();

	REFERENCE_TIME rtMinStart;
	pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );
	
	REFERENCE_TIME rtNewStart;
	REFERENCE_TIME rtNewLength;
	rtNewLength = rtNewEnd - rtCurStart;
	rtNewStart = rtCurStart;

	rtNewLength = max( rtNewLength, rtMinTime );

	if( m_PropCurve.m_rtStartTime != rtNewStart
	||  m_PropCurve.m_rtDuration != rtNewLength )
	{
		m_PropCurve.m_rtStartTime = rtNewStart;
		m_PropCurve.m_rtDuration = rtNewLength;

		// Now, update the object with the new value(s)
		UpdateObject();
	}
	else
	{
		// Display original values
		UpdateControls( &m_PropCurve );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetDuration

void CPropPageCurve::SetDuration( REFERENCE_TIME rtNewLength ) 
{
	ASSERT(m_pPageManager);
	if(m_pPageManager == NULL)
	{
		return;
	}

	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	REFERENCE_TIME rtSegmentLength = pTrackMgr->GetSegmentLength();
	REFERENCE_TIME rtMinTime = MinTimeToUnknownTime();
	REFERENCE_TIME rtCurStart = StartToUnknownTime();
	REFERENCE_TIME rtCurEnd = EndToUnknownTime();

	REFERENCE_TIME rtMinStart;
	pTrackMgr->ClocksToUnknownTime( -MAX_TICK, &rtMinStart );
	
	REFERENCE_TIME rtNewStart = rtCurStart;

	rtNewLength = max( rtNewLength, rtMinTime );
	rtNewLength = min( (rtSegmentLength - rtNewStart), rtNewLength );

	if( m_PropCurve.m_rtStartTime != rtNewStart
	||  m_PropCurve.m_rtDuration != rtNewLength )
	{
		m_PropCurve.m_rtStartTime = rtNewStart;
		m_PropCurve.m_rtDuration = rtNewLength;

		// Now, update the object with the new value(s)
		UpdateObject();
	}
	else
	{
		// Display original values
		UpdateControls( &m_PropCurve );
	}
}


void CPropPageCurve::OnKillfocusEditStartbar() 
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return;
	}

	int nOffset = 0;
	if( pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartBar, m_lStartBar, nOffset ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTBAR;
		SetStart( StartToUnknownTime() );
	}
}


void CPropPageCurve::OnDeltaposSpinStartbar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditStartbar();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartBar ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTBAR;
		SetStart( StartToUnknownTime() );
	}
}




/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::EndToUnknownTime

REFERENCE_TIME CPropPageCurve::EndToUnknownTime( void )
{
	CTrackMgr* pTrackMgr = m_pPageManager->m_pTrackMgr;
	ASSERT(pTrackMgr);
	if(pTrackMgr == NULL)
	{
		return 0;
	}

	REFERENCE_TIME rtNewEnd = 0;

	if( pTrackMgr->IsRefTimeTrack() )
	{
		REFERENCE_TIME rtTime = 0;
		pTrackMgr->MinSecGridMsToRefTime( m_PropCurve.m_pParamStrip, m_lEndBar, m_lEndBeat, m_lEndGrid, m_lEndTick, &rtTime );
		pTrackMgr->RefTimeToUnknownTime( rtTime, &rtNewEnd );
	}
	else
	{
		MUSIC_TIME mtTime;
		pTrackMgr->MeasureBeatGridTickToClocks( m_lEndBar, m_lEndBeat, m_lEndGrid, m_lEndTick, &mtTime );
		pTrackMgr->ClocksToUnknownTime( mtTime, &rtNewEnd );
	}

	return rtNewEnd;
}




/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CPropPageCurve::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPageManager->m_pIPropPageObject == NULL )
	{
		return false;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else if(strcmp(achUnknown, tcstrTmp) == 0)
	{
		return false;
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CPropPageCurve::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL )
	{
		return false;
	}

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::UpdateObject

void CPropPageCurve::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPageManager && m_pPageManager->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPageManager->m_pIPropPageObject->SetData( (void *) &m_PropCurve);
	}
}

void CPropPageCurve::OnKillfocusEditStartbeat() 
{
	int nOffset = 0;
	if( m_pPageManager->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinStartBeat, m_lStartBeat, nOffset ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTBEAT;
		SetStart( StartToUnknownTime() );
	}

	
}

void CPropPageCurve::OnKillfocusEditStartgrid() 
{
	if( HandleKillFocus( m_spinStartGrid, m_lStartGrid, 1 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTGRID;
		SetStart( StartToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditStarttick() 
{
	if( HandleKillFocus( m_spinStartTick, m_lStartTick, 0 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTTICK;
		SetStart( StartToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditEndbar() 
{
	int nOffset = 0;
	if( m_pPageManager->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndBar, m_lEndBar, nOffset ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDBAR;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditEndbeat() 
{
	int nOffset = 0;
	if( m_pPageManager->m_pTrackMgr->IsRefTimeTrack() )
	{
		nOffset = 0;
	}
	else
	{
		nOffset = 1;
	}

	if( HandleKillFocus( m_spinEndBeat, m_lEndBeat, nOffset ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDBEAT;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditEndgrid() 
{
	if( HandleKillFocus( m_spinEndGrid, m_lEndGrid, 1 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDGRID;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditEndtick() 
{
	if( HandleKillFocus( m_spinEndTick, m_lEndTick, 0 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDTICK;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditDurbar() 
{
	if( HandleKillFocus( m_spinDurBar, m_lDurBar, 0) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURBAR;
		SetDuration( DurationToUnknownTime() );
	}
	
}

void CPropPageCurve::OnKillfocusEditDurbeat() 
{
	if( HandleKillFocus( m_spinDurBeat, m_lDurBeat, 0 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURBEAT;
		SetDuration( DurationToUnknownTime() );
	}
	
}

void CPropPageCurve::OnKillfocusEditDurgrid() 
{
	if( HandleKillFocus( m_spinDurGrid, m_lDurGrid, 0 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURGRID;
		SetDuration( DurationToUnknownTime() );
	}
}

void CPropPageCurve::OnKillfocusEditDurtick() 
{
	if( HandleKillFocus( m_spinDurTick, m_lDurTick, 0 ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURTICK;
		SetDuration( DurationToUnknownTime() );
	}
	
}

void CPropPageCurve::OnDeltaposSpinStartbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditStarttick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartBeat ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTBEAT;
		SetStart( StartToUnknownTime() );
	}

}

void CPropPageCurve::OnDeltaposSpinStartgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditStarttick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartGrid ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTGRID;
		SetStart( StartToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinStarttick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditStarttick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lStartTick ) )
	{
		m_PropCurve.m_dwChanged = CHGD_STARTTICK;
		SetStart( StartToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinEndbar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditEndbar();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndBar) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDBAR;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinEndbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditEndbeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndBeat ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDBEAT;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinEndgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditEndgrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndGrid ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDGRID;
		SetEnd( EndToUnknownTime() );
	}

}

void CPropPageCurve::OnDeltaposSpinEndtick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditEndtick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lEndTick ) )
	{
		m_PropCurve.m_dwChanged = CHGD_ENDTICK;
		SetEnd( EndToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinDurbar(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditDurbar();

	if( HandleDeltaChange( pNMHDR, pResult, m_lDurBar ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURBAR;
		SetDuration( DurationToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinDurbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditDurbeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_lDurBeat ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURBEAT;
		SetDuration( DurationToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinDurgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditDurgrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_lDurGrid ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURGRID;
		SetDuration( DurationToUnknownTime() );
	}
}

void CPropPageCurve::OnDeltaposSpinDurtick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditDurtick();

	if( HandleDeltaChange( pNMHDR, pResult, m_lDurTick ) )
	{
		m_PropCurve.m_dwChanged = CHGD_DURTICK;
		SetDuration( DurationToUnknownTime() );
	}
}



/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetEditControl

void CPropPageCurve::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}

void CPropPageCurve::OnCheckStartFromCurrent() 
{
	m_PropCurve.m_dwChanged = CHGD_STARTCURRENT;

	int nCheck = m_btnStartFromCurrent.GetCheck();
	m_PropCurve.m_fStartFromCurrent = nCheck;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
}

void CPropPageCurve::OnSelchangeComboEnumEndValue() 
{
	int nIndex = m_comboEnumEndValue.GetCurSel();
	DWORD dwValue = m_comboEnumEndValue.GetItemData(nIndex);
	m_PropCurve.m_dwChanged = CHGD_ENDVAL;
	m_PropCurve.m_fltEndValue = dwValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
}

void CPropPageCurve::OnSelchangeComboEnumStartValue() 
{
	int nIndex = m_comboEnumStartValue.GetCurSel();
	DWORD dwValue = m_comboEnumStartValue.GetItemData(nIndex);
	m_PropCurve.m_dwChanged = CHGD_STARTVAL;
	m_PropCurve.m_fltStartValue = dwValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_PropCurve );
}

void CPropPageCurve::OnKillfocusComboEnumStartValue() 
{
	CString sComboSel;
	m_comboEnumStartValue.GetWindowText(sComboSel);

	if(sComboSel.CompareNoCase(achUnknown) == 0)
	{
		return;
	}

	if(m_comboEnumStartValue.SelectString(0, sComboSel) == CB_ERR)
	{
		m_comboEnumStartValue.SetCurSel(m_PropCurve.m_fltStartValue);
		return;
	}

	OnSelchangeComboEnumStartValue();
}

void CPropPageCurve::OnKillfocusComboEnumEndValue() 
{
	CString sComboSel;
	m_comboEnumEndValue.GetWindowText(sComboSel);

	if(sComboSel.CompareNoCase(achUnknown) == 0)
	{
		return;
	}

	if(m_comboEnumEndValue.SelectString(0, sComboSel) == CB_ERR)
	{
		m_comboEnumEndValue.SetCurSel(m_PropCurve.m_fltEndValue);
		return;
	}

	OnSelchangeComboEnumEndValue();
}

void CPropPageCurve::OnKillfocusComboShape() 
{
	CString sComboSel;
	m_comboShape.GetWindowText(sComboSel);

	if(sComboSel.CompareNoCase(achUnknown) == 0)
	{
		return;
	}

	if(m_comboShape.SelectString(0, sComboSel) == CB_ERR)
	{
		InitShapeCombo(&m_PropCurve);
		return;
	}

	OnSelChangeComboShape();
}


void CPropPageCurve::InitShapeCombo(CPropCurve* pPropCurve)
{
	ASSERT(pPropCurve);
	if(pPropCurve == NULL)
	{
		return;
	}

	if(pPropCurve->m_dwUndetermined & UNDT_SHAPE)
	{
		m_comboShape.SetCurSel(-1);
		m_comboShape.SetWindowText(achUnknown);
	}
	else
	{
		if(pPropCurve->m_dwCurveShape == MP_CURVE_SINE)
		{
			m_comboShape.SetCurSel(0);
		}
		else if(pPropCurve->m_dwCurveShape ==  MP_CURVE_INVSQUARE)
		{
			m_comboShape.SetCurSel(1);
		}
		else if(pPropCurve->m_dwCurveShape == MP_CURVE_SQUARE)
		{
			m_comboShape.SetCurSel(2);
		}
		else if(pPropCurve->m_dwCurveShape == MP_CURVE_JUMP)
		{
			m_comboShape.SetCurSel(3);
		}
		else if(pPropCurve->m_dwCurveShape == MP_CURVE_LINEAR)
		{
			m_comboShape.SetCurSel(4);
		}
		else
		{
			m_comboShape.SetCurSel(-1);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\PropPageMgr_Item.h ===
// PropPageMgr_Item.h : Handles the property pages for a track item

#ifndef __PROPPAGEMGR_ITEM_H_
#define __PROPPAGEMGR_ITEM_H_

#include <staticproppagemanager.h>


class CTabFileRef;
class CTabBoundary;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem

class CPropPageMgrItem : public CStaticPropPageManager
{
	friend CTabFileRef;
	friend CTabBoundary;

public:
	CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr );
	~CPropPageMgrItem();

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	IDMUSProdFramework*	m_pIFramework;
	CTrackMgr*			m_pTrackMgr;

	CTabFileRef*		m_pTabFileRef;
	CTabBoundary*		m_pTabBoundary;

public:
	static short		sm_nActiveTab;
};

#endif // __PROPPAGEMGR_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\PropPageCurve.h ===
#if !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
#define AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropPageCurve.h : header file
//

#include "CurvePropPageMgr.h"
#include "ParamStripMgrApp.h"

extern class CParamStripMgrApp theApp;

#define DIALOG_EDIT_LEN 15

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve dialog

class CPropPageCurve : public CPropertyPage
{
// Construction
public:
	CPropPageCurve( CCurvePropPageMgr* pCurvePropPageMgr );
	~CPropPageCurve();

// Dialog Data
	//{{AFX_DATA(CPropPageCurve)
	enum { IDD = IDD_PROPPAGE_CURVE };
	CComboBox	m_comboEnumStartValue;
	CComboBox	m_comboEnumEndValue;
	CButton	m_btnStartFromCurrent;
	CStatic	m_staticPromptTick;
	CStatic	m_staticPromptGrid;
	CStatic	m_staticPromptBeat;
	CStatic	m_staticPromptBar;
	CSpinButtonCtrl	m_spinStartValue;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinEndValue;
	CSpinButtonCtrl	m_spinEndTick;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinDurTick;
	CSpinButtonCtrl	m_spinDurGrid;
	CSpinButtonCtrl	m_spinDurBeat;
	CSpinButtonCtrl	m_spinDurBar;
	CEdit	m_editStartValue;
	CEdit	m_editStartTick;
	CEdit	m_editStartGrid;
	CEdit	m_editStartBeat;
	CEdit	m_editStartBar;
	CEdit	m_editEndValue;
	CEdit	m_editEndTick;
	CEdit	m_editEndGrid;
	CEdit	m_editEndBeat;
	CEdit	m_editEndBar;
	CEdit	m_editDurTick;
	CEdit	m_editDurGrid;
	CEdit	m_editDurBeat;
	CEdit	m_editDurBar;
	CComboBox	m_comboShape;
	CButton	m_btnFlipVert;
	CButton	m_btnFlipHorz;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageCurve)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member Variables
protected:
	CCurvePropPageMgr*		m_pPageManager;
	BOOL					m_fInUpdateControls;
	BOOL					m_fNeedToDetach;
	BOOL					m_fInOnKillFocusStartValue;
	BOOL					m_fInOnKillFocusEndValue;
	bool					m_bEnumType;
	bool					m_bBoolType; 
	bool					m_bFloatType;
	bool					m_bIntType;


	CPropCurve				m_PropCurve;

	long		m_lStartBar;
	long		m_lStartBeat;
	long		m_lStartGrid;
	long		m_lStartTick;

	long		m_lEndBar;
	long		m_lEndBeat;
	long		m_lEndGrid;
	long		m_lEndTick;

	long		m_lDurBar;
	long		m_lDurBeat;
	long		m_lDurGrid;
	long		m_lDurTick;


// Implementation
protected:
	void EnableItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void SetControlRanges( CPropCurve* pPropCurve );
	void SetRefTimeRanges( void );
	void SetMusicTimeRanges( DWORD dwGroupBits, CPropCurve* pPropCurve );
	void StartEndValueToString( float nValue, CString& strValue ); 
	float StringToStartEndValue( LPCTSTR pszNewStartValue );
	void SetSpinStartValuePos( int nStartValue );
	void SetSpinEndValuePos( int nEndValue );
	int GetSpinStartValuePos();
	int GetSpinEndValuePos();
	
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	void SetEditControl( CEdit& edit, long lValue, int nOffset );

	void RecomputeTimes();
	void ComputeMinSecGridMs( void );
	void ComputeBarBeatGridTick( void );

	REFERENCE_TIME StartToUnknownTime( void );
	REFERENCE_TIME EndToUnknownTime( void );
	REFERENCE_TIME DurationToUnknownTime( void );
	REFERENCE_TIME MinTimeToUnknownTime( void );
	REFERENCE_TIME MinTimeToRefTime( void );

	void SetStart( REFERENCE_TIME rtNewStart );
	void SetEnd( REFERENCE_TIME rtNewEnd );
	void SetDuration( REFERENCE_TIME rtNewLength );

	void UpdateObject( void );

	void InitShapeCombo(CPropCurve* pPropCurve);


public:
	void UpdateControls( CPropCurve* pPropCurve );

	// Generated message map functions
	//{{AFX_MSG(CPropPageCurve)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeComboShape();
	afx_msg void OnBtnFlipVert();
	afx_msg void OnDoubleClickedBtnFlipVert();
	afx_msg void OnBtnFlipHorz();
	afx_msg void OnDoubleClickedBtnFlipHorz();
	afx_msg void OnDeltaPosSpinEndValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinStartValue(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditEndValue();
	afx_msg void OnChangeEditStartValue();
	afx_msg void OnKillFocusStartValue();
	afx_msg void OnKillFocusEndValue();
	afx_msg void OnKillfocusEditStartbar();
	afx_msg void OnDeltaposSpinStartbar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditStartbeat();
	afx_msg void OnKillfocusEditStartgrid();
	afx_msg void OnKillfocusEditStarttick();
	afx_msg void OnKillfocusEditEndbar();
	afx_msg void OnKillfocusEditEndbeat();
	afx_msg void OnKillfocusEditEndgrid();
	afx_msg void OnKillfocusEditEndtick();
	afx_msg void OnKillfocusEditDurbar();
	afx_msg void OnKillfocusEditDurbeat();
	afx_msg void OnKillfocusEditDurgrid();
	afx_msg void OnKillfocusEditDurtick();
	afx_msg void OnDeltaposSpinStartbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinStartgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinStarttick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinEndbar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinEndbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinEndgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinEndtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinDurbar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinDurbeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinDurgrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinDurtick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCheckStartFromCurrent();
	afx_msg void OnSelchangeComboEnumEndValue();
	afx_msg void OnSelchangeComboEnumStartValue();
	afx_msg void OnKillfocusComboEnumStartValue();
	afx_msg void OnKillfocusComboEnumEndValue();
	afx_msg void OnKillfocusComboShape();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECURVE_H__3251F4C3_DA91_11D1_89B1_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ParamStripMgrDLL.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_FILEREF            101
#define IDR_WAVEMGR                     102
#define IDR_TRACKMGR                    102
#define IDS_DELETE                      103
#define IDS_PASTE                       104
#define IDS_INSERT                      105
#define IDD_PROPPAGE_WAVE_FILEREF       106
#define IDS_TRACK_NAME                  107
#define IDS_PROPPAGE_GROUP_BITS         108
#define IDS_MULTIPLE_SELECT             109
#define IDS_UNDO_CHANGE                 110
#define IDS_UNDO_MOVE                   111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_STRIP_NAME                  113
#define IDS_DEFAULT_WAVE_TEXT           114
#define IDS_EMPTY_TEXT                  114
#define IDS_UNDO_TRACKEXTRAS            115
#define IDM_SNAP_SECOND                 115
#define IDS_UNDO_PRODUCERONLY           116
#define IDM_SNAP_SET_GRID               116
#define IDM_SNAP_BEAT                   117
#define IDM_SNAP_BAR                    118
#define IDS_UNDO_DELETE_WAVE            119
#define IDM_SNAP_GRID                   119
#define IDS_UNDO_REPLACE_WAVE           120
#define IDM_SNAP_NONE                   120
#define IDS_UNDO_CHANGE_WAVE_LINK       121
#define IDS_UNDO_CHANGE_WAVE_NAME       122
#define IDS_UNDO_FLAGS                  128
#define IDS_NONE_TEXT                   129
#define IDS_BROADCAST_SEG               130
#define IDS_BROADCAST_PERF              131
#define IDS_EMPTY_PCHANNEL              132
#define IDS_USED_PCHANNEL               133
#define IDS_INVALID_PCHANNEL            134
#define IDS_UNDO_ADD_PART               135
#define IDS_UNDO_OBJECT_PCHANNEL        136
#define IDS_UNDO_OBJECT_FLAGS           140
#define IDS_UNDO_OBJECT_NAME            141
#define IDS_UNDO_DELETE_PART            142
#define IDS_UNDO_TRACK_FLAGS            143
#define IDS_UNDO_TRACK_VOLUME           144
#define IDS_UNDO_STRIP_MINIMIZED        146
#define IDS_UNDO_STRIP_MAXIMIZED        147
#define IDS_UNDO_STRIP_RESIZE           148
#define IDS_FONT_NAME                   149
#define IDS_CREATE_TEXT                 160
#define IDS_NO_PARAM_TRACKS_TEXT        161
#define IDS_PARAM_STRIP_FONTNAME        162
#define IDS_TOOLS_SEGMENT               163
#define IDS_TOOLS_SEGMENT_AUDIOPATH     164
#define IDS_START_TEXT                  165
#define IDS_END_TEXT                    166
#define IDS_CURVE_TEXT                  167
#define IDS_MINUS_TEXT                  168
#define IDS_BEAT_TEXT                   171
#define IDS_BEAT_MENU_TEXT              172
#define IDS_BAR_TEXT                    173
#define IDS_BAR_MENU_TEXT               174
#define IDS_GRID_TEXT                   181
#define IDS_TICK_TEXT                   182
#define IDS_MIN_TEXT                    183
#define IDS_SEC_TEXT                    184
#define IDS_MS_TEXT                     185
#define IDS_DMOS_SEGMENT_AUDIOPATH      186
#define IDS_BOOL_FALSE                  187
#define IDS_BOOL_TRUE                   188
#define IDS_DMOS_PERFORMANCE_AUDIOPATH  189
#define IDS_TOOLS_PERFORMANCE_AUDIOPATH_TOOLGRAPH 190
#define IDD_PROPPAGE_WAVE_GROUP_BITS    200
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_BEAT                   202
#define IDC_SPIN_BEAT                   203
#define IDD_PROPPAGE_WAVE_BOUNDARY      203
#define IDC_EDIT_MEASURE                204
#define IDC_SPIN_MEASURE                205
#define IDR_EDITMENU                    206
#define IDC_EDIT_TICK                   206
#define IDM_DRAG_RMENU                  207
#define IDC_SPIN_TICK                   207
#define IDC_COMBO_FILE                  209
#define IDD_NEW_PART                    209
#define IDD_NEW_PARAM                   209
#define IDC_CHECK_GROUP1                223
#define IDC_CHECK_VAR1                  223
#define IDC_CHECK_GROUP2                224
#define IDC_EDIT_NAME                   224
#define IDC_CHECK_VAR2                  224
#define IDC_CHECK_GROUP3                225
#define IDC_EDIT_PCHANNELNAME           225
#define IDC_CHECK_VAR3                  225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_VAR4                  226
#define IDC_CHECK_GROUP5                227
#define IDC_CHECK_VAR5                  227
#define IDC_CHECK_GROUP6                228
#define IDC_CHECK_VAR6                  228
#define IDC_CHECK_GROUP7                229
#define IDC_CHECK_VAR7                  229
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_VAR8                  230
#define IDC_CHECK_GROUP9                231
#define IDC_COMBO_GROUP_LIST            231
#define IDC_CHECK_VAR9                  231
#define IDC_CHECK_GROUP10               232
#define IDC_CHECK_VAR10                 232
#define IDC_CHECK_GROUP11               233
#define IDC_EDIT_PCHANNEL               233
#define IDC_CHECK_VAR11                 233
#define IDC_CHECK_GROUP12               234
#define IDC_SPIN_PCHANNEL               234
#define IDC_CHECK_VAR12                 234
#define IDC_CHECK_GROUP13               235
#define IDC_CHECK_VAR13                 235
#define IDD_PROPPAGE_CURVE              235
#define IDC_CHECK_GROUP14               236
#define IDC_CHECK_VAR14                 236
#define IDC_CHECK_GROUP15               237
#define IDC_CHECK_VAR15                 237
#define IDC_CHECK_GROUP16               238
#define IDC_CHECK_VAR16                 238
#define IDC_CHECK_GROUP17               239
#define IDC_CHECK_VAR17                 239
#define IDC_CHECK_GROUP18               240
#define IDC_CHECK_VAR18                 240
#define IDC_CHECK_GROUP19               241
#define IDC_CHECK_VAR19                 241
#define IDC_CHECK_GROUP20               242
#define IDC_CHECK_VAR20                 242
#define IDC_CHECK_GROUP21               243
#define IDC_CHECK_VAR21                 243
#define IDC_CHECK_GROUP22               244
#define IDC_CHECK_VAR22                 244
#define IDC_CHECK_GROUP23               245
#define IDC_CHECK_VAR23                 245
#define IDC_CHECK_GROUP24               246
#define IDC_CHECK_VAR24                 246
#define IDC_CHECK_GROUP25               247
#define IDC_PCHANNEL_STATUS             247
#define IDC_CHECK_VAR25                 247
#define IDC_CHECK_GROUP26               248
#define IDC_CHECK_VAR26                 248
#define IDC_CHECK_GROUP27               249
#define IDC_CHECK_VAR27                 249
#define IDC_CHECK_GROUP28               250
#define IDC_CHECK_VAR28                 250
#define IDC_CHECK_GROUP29               251
#define IDC_CHECK_VAR29                 251
#define IDC_CHECK_GROUP30               252
#define IDC_CHECK_VAR30                 252
#define IDC_CHECK_GROUP31               253
#define IDC_CHECK_VAR31                 253
#define IDC_CHECK_GROUP32               254
#define IDC_CHECK_VAR32                 254
#define IDC_PROMPT                      255
#define IDC_EDIT_ENDVALUE               255
#define IDB_ZOOMOUT_UP                  257
#define IDC_SYNC                        258
#define IDC_EDIT_STARTVALUE             260
#define IDC_COMBO_OBJECT                261
#define IDC_STAGE_STATIC                261
#define IDC_COMBO_PARAM                 262
#define IDC_OBJECT_STATIC               262
#define IDC_PROMPT_BAR                  262
#define IDB_ZOOMIN_DOWN                 263
#define IDC_PROMPT_BEAT                 263
#define IDB_ZOOMIN_UP                   264
#define IDC_PROMPT_GRID                 264
#define IDB_ZOOMOUT_DOWN                265
#define IDC_PROMPT_TICK                 265
#define IDC_RADIO_TOOLS                 266
#define IDC_RADIO_DMOS                  267
#define IDC_CHECK_START_FROM_CURRENT    268
#define IDC_COMBO_ENUMSTARTVALUE        269
#define IDC_COMBO_ENUMENDVALUE          270
#define IDC_SPIN_STARTVALUE             271
#define IDC_SPIN_ENDVALUE               275
#define IDC_WAVE_NAME                   304
#define IDC_STATIC_SEMI_TONES           320
#define IDC_COMBO_VAR_LOCK              320
#define IDC_STATIC_FINE_TUNE            321
#define IDC_COMBO_SHAPE                 325
#define IDC_EDIT_STARTBAR               326
#define IDC_EDIT_STARTBEAT              327
#define IDC_EDIT_STARTGRID              328
#define IDC_EDIT_STARTTICK              329
#define IDC_EDIT_ENDBAR                 330
#define IDC_EDIT_ENDBEAT                331
#define IDC_EDIT_ENDGRID                332
#define IDC_EDIT_ENDTICK                333
#define IDC_SPIN_STARTBAR               334
#define IDC_SPIN_STARTBEAT              335
#define IDC_SPIN_STARTGRID              336
#define IDC_SPIN_STARTTICK              337
#define IDC_SPIN_ENDBAR                 338
#define IDC_SPIN_ENDBEAT                339
#define IDC_SPIN_ENDGRID                340
#define IDC_SPIN_ENDTICK                341
#define IDC_EDIT_DURBAR                 342
#define IDC_SPIN_DURBAR                 343
#define IDC_EDIT_DURBEAT                344
#define IDC_SPIN_DURBEAT                345
#define IDC_EDIT_DURGRID                346
#define IDC_SPIN_DURGRID                347
#define IDC_EDIT_DURTICK                348
#define IDC_SPIN_DURTICK                349
#define IDC_BTN_FLIPVERT                350
#define IDC_BTN_FLIPHORZ                351
#define IDC_NEWPART_EDIT_PCHANNEL       373
#define IDC_NEWOBJECT_EDIT_PCHANNEL     373
#define IDC_NEWPART_SPIN_PCHANNEL       374
#define IDC_NEWOBJECT_SPIN_PCHANNEL     374
#define IDS_CURVE_SHAPE1                380
#define IDS_CURVE_SHAPE2                381
#define IDS_CURVE_SHAPE3                382
#define IDS_CURVE_SHAPE4                383
#define IDC_EDIT_PCHNAME                384
#define IDS_CURVE_SHAPE5                384
#define IDC_COMBO_VAR_MODE              385
#define IDC_COMBO_STAGE                 385
#define IDS_UNDO_CHANGE_CURVE           385
#define IDC_COMBO_TOOLS                 386
#define IDS_UNDO_INSERT_CURVE           386
#define IDS_NO_PARAM_TEXT               387
#define IDS_SECOND_TEXT                 388
#define IDS_SET_GRID_TEXT               389
#define IDS_NBR_MS_PER_GRID_TEXT        390
#define IDS_ERR_NBR_GRIDS_PER_SECOND    391
#define IDS_UNDO_NBR_GRIDS_PER_SECOND   392
#define IDS_UNDO_ADD_PARAM              393
#define IDS_UNDO_DELETE_PARAM           394
#define IDS_UNDO_SNAP_TO                395
#define IDS_UNDO_COPY_CURVE             396
#define IDD_PROPPAGE_PART               437
#define IDD_PROPPAGE_OBJECT             437
#define IDD_PROPPAGE_TRACK              438
#define IDD_GRIDS_PER_SECOND            456
#define IDC_EDIT_NBR_GRIDS              550
#define IDC_SPIN_NBR_GRIDS              551
#define IDC_RADIO_ACTIVE_PART           553
#define IDC_RADIO_ALL_PARTS             554
#define IDC_NBR_MS                      562
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_ITEMS                 32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_NEW_PARAM                    32772
#define ID_EDIT_INSERT2                 32773
#define ID_EDIT_PASTE_MERGE             32776
#define ID_EDIT_PASTE_OVERWRITE         32778
#define IDM_ADD_PART                    32779
#define ID_EDIT_INSERT_CURVE            32779
#define IDM_DELETE_PART                 32780
#define ID_DELETE_PARAM                 32784
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        269
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         270
#define _APS_NEXT_SYMED_VALUE           121
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabBoundary.h ===
#if !defined(AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabBoundary.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary dialog

class CTabBoundary : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabBoundary)

// Construction
public:
	CTabBoundary();
	~CTabBoundary();

// Dialog Data
	//{{AFX_DATA(CTabBoundary)
	enum { IDD = IDD_PROPPAGE_WAVE_BOUNDARY };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabBoundary)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabBoundary)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetTrackItem( const CTrackItem * pItem );

protected:
	void UpdateObject();
	void EnableControls( BOOL fEnable );

	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CTrackItem				m_TrackItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABBOUNDARY_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabBoundary.cpp ===
// TabBoundary.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabBoundary.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary property page

IMPLEMENT_DYNCREATE(CTabBoundary, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary constructor/destructor

CTabBoundary::CTabBoundary(): CPropertyPage(CTabBoundary::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_FILEREF);
	//{{AFX_DATA_INIT(CTabBoundary)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
}

CTabBoundary::~CTabBoundary()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::DoDataExchange

void CTabBoundary::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabBoundary)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabBoundary, CPropertyPage)
	//{{AFX_MSG_MAP(CTabBoundary)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::SetTrackItem

void CTabBoundary::SetTrackItem( const CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_TrackItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_TrackItem.Copy( pItem );

	// Check to see if the controls have been created
//	if( m_editAttenuation.GetSafeHwnd() == NULL )
//	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
//	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Set xxxx control
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnCreate

int CTabBoundary::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnDestroy

void CTabBoundary::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnInitDialog

BOOL CTabBoundary::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::UpdateObject

void CTabBoundary::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *) &m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::EnableControls

void CTabBoundary::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure controls have been created
//	if( ::IsWindow(m_editAttenuation.m_hWnd) == FALSE )
//	{
//		return;
//	}

//	m_sliderAttenuation.EnableWindow(fEnable);
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabBoundary::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundary::OnSetActive

BOOL CTabBoundary::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetTrackItem( &m_TrackItem );
	}
	else
	{
		SetTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabFileRef.cpp ===
// TabFileRef.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TrackItem.h"
#include "PropPageMgr_Item.h"
#include "TabFileRef.h"
#include "TabBoundary.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "LockoutNotification.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Length (in characters) of the string to allocate to store text entered in
// the measure and beat edit boxes
#define DIALOG_EDIT_LEN 15

// {D9D1D754-B61A-4216-991C-7571D5BEEC22}
static const GUID GUID_WaveItemPPGMgr = 
{ 0xd9d1d754, 0xb61a, 0x4216, { 0x99, 0x1c, 0x75, 0x71, 0xd5, 0xbe, 0xec, 0x22 } };

short CPropPageMgrItem::sm_nActiveTab = 0;

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem constructor/destructor

CPropPageMgrItem::CPropPageMgrItem( IDMUSProdFramework* pIFramework, CTrackMgr* pTrackMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store Framework pointer
	ASSERT( pIFramework != NULL ); 
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	ASSERT( pTrackMgr != NULL ); 
	m_pTrackMgr = pTrackMgr;

	// Store GUID
	m_GUIDManager = GUID_WaveItemPPGMgr;

	// Initialize our pointers to NULL
	m_pTabFileRef = NULL;
	m_pTabBoundary = NULL;

	// call the base class contstructor
	CStaticPropPageManager::CStaticPropPageManager();
}

CPropPageMgrItem::~CPropPageMgrItem()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTabFileRef )
	{
		delete m_pTabFileRef;
		m_pTabFileRef = NULL;
	}

	if( m_pTabBoundary )
	{
		delete m_pTabBoundary;
		m_pTabBoundary = NULL;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	// Call the base class destructor
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	// Try and load the title
	CComBSTR comBSTR;
	if( comBSTR.LoadString( IDS_PROPPAGE_FILEREF ) )
	{
		// Succeeded - return the BSTR
		*pbstrTitle = comBSTR.Detach();
		return S_OK;
	}

	// Failed - return NULL
	*pbstrTitle = NULL;

	return E_FAIL;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_POINTER;
	}

	// Save a copy of the IDMUSProdPropSheet pointer
	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	// Initialize the array and number of property sheets
	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Initialize the number of pages we've added
	short nNbrPages = 0;

	// Create FileRef tab
	if( m_pTabFileRef == NULL )
	{
		m_pTabFileRef = new CTabFileRef();
	}
	if( m_pTabFileRef )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabFileRef->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabFileRef->m_pPropPageMgr = this;
	}

	// Create ?? tab
	if( m_pTabBoundary == NULL )
	{
		m_pTabBoundary = new CTabBoundary();
	}

	// If the property page now exists, add the property page
	if( m_pTabBoundary )
	{
		// Copy the PROPSHEETPAGE structure
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabBoundary->m_psp, sizeof(PROPSHEETPAGE) );

		// Crate a property sheet page from the PROPSHEETPAGE structure
		HPROPSHEETPAGE hPage;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			// If the page creation succeeded, add it to the array
			hPropSheetPage[nNbrPages] = (LONG *)hPage;

			// And increment the number of pages in the array
			nNbrPages++;
		}

		// Point the property page back to this property page manager
		m_pTabBoundary->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPropPageMgrItem::RefreshData

HRESULT STDMETHODCALLTYPE CPropPageMgrItem::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to a CTrackItem
	CTrackItem* pItem;

	if( m_pIPropPageObject == NULL )
	{
		// No property page object - set pointer to NULL
		pItem = NULL;
	}
	// Have a property page object - try and get a pointer from it
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pItem ) ) )
	{
		return E_FAIL;
	}

	// Update the property pages, if they exists
	if( m_pTabFileRef )
	{
		m_pTabFileRef->SetTrackItem( pItem );
	}
	if( m_pTabBoundary )
	{
		m_pTabBoundary->SetTrackItem( pItem );
	}

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef property page

IMPLEMENT_DYNCREATE(CTabFileRef, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef constructor/destructor

CTabFileRef::CTabFileRef(): CPropertyPage(CTabFileRef::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PROPPAGE_FILEREF);
	//{{AFX_DATA_INIT(CTabFileRef)
	//}}AFX_DATA_INIT

	// Initialize our pointers to NULL
	m_pPropPageMgr = NULL;
	m_pTimeline = NULL;

	// Initialize our class members to FALSE
	m_fValidTrackItem = FALSE;
	m_fNeedToDetach = FALSE;
	m_fIgnoreSelChange = FALSE;
}

CTabFileRef::~CTabFileRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	FileListInfo* pFileListInfo;
//	while( !m_lstFileListInfo.IsEmpty() )
//	{
//		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
//		delete pFileListInfo;
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::DoDataExchange

void CTabFileRef::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CTabFileRef)
	DDX_Control(pDX, IDC_COMBO_FILE, m_comboFile);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabFileRef, CPropertyPage)
	//{{AFX_MSG_MAP(CTabFileRef)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_CBN_DROPDOWN(IDC_COMBO_FILE, OnDropDownComboFile)
	ON_CBN_SELCHANGE(IDC_COMBO_FILE, OnSelChangeComboFile)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef custom functions

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetTrackItem

void CTabFileRef::SetTrackItem( const CTrackItem* pItem )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If the pointer is null, there are no items selected, so disable the property page
	if( pItem == NULL )
	{
		m_fValidTrackItem = FALSE;
		m_TrackItem.Clear();
		EnableControls( FALSE );
		return;
	}

	// Initialize the timeline pointer to NULL
	m_pTimeline = NULL;

	// Initialize our groupbits to all 32 groups
	DWORD dwGroupBits = 0xFFFFFFFF;

	// Verify we have a valid pinter to our Property Page Object
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject )
	{
		// Query the Property Page Object for an IDMUSProdStripMgr interface
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			// Ask the strip manager for an IDMUSProdTimeline pointer
			VARIANT variant;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_ITIMELINECTL, &variant ) ) )
			{
				// Query the returned IUnknown pointer for an IDMUSProdTimeline Poiter
				if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline ) ) )
				{
					// Successfully got an IDMUSProdTimeline pointer.
					// Now, release it since we only want a weak reference
					m_pTimeline->Release();
				}

				// Release the returned IUnknown pointer
				V_UNKNOWN( &variant )->Release();
			}

			// Ask the strip mangaer for its track header, so we can read the group bits from it
			DMUS_IO_TRACK_HEADER ioTrackHeader;
			variant.vt = VT_BYREF;
			V_BYREF( &variant ) = &ioTrackHeader;
			if( SUCCEEDED( pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &variant ) ) )
			{
				dwGroupBits = ioTrackHeader.dwGroup;
			}

			// Release the returned IDMUSProdStripMgr pointer
			pStripMgr->Release();
		}
	}

	// Flag that we have a valid item
	m_fValidTrackItem = TRUE;

	// Copy the information from the new item
	m_TrackItem.Copy( pItem );

	long lMaxMeasure, lMaxBeat; // Maximum measure and beat values
	// Get the maximum measure value
	if( m_pTimeline == NULL )
	{
		// No timeline pointer - use default values
		lMaxMeasure = 32767;
		lMaxBeat = 256;
	}
	else
	{
		// Get the length of the timeline, in clocks
		VARIANT var;
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );

		// Convert from clocks to a measure and beat value
		m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
										  V_I4( &var ), &lMaxMeasure, &lMaxBeat );

		// If the beat value is zero, check if the segment is exactly lMaxMeasure in length
		if( lMaxBeat == 0 )
		{
			// Convert from lMaxMeasure to a clock value
			long lClockLength;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, lMaxMeasure, 0, &lClockLength );

			// Check if this clock value is equal to the length
			if( lClockLength == V_I4( &var ) )
			{
				// Exactly lMaxMeasures long.  Get the measure and beat value for the previous tick
				m_pTimeline->ClocksToMeasureBeat( dwGroupBits, 0,
												  V_I4( &var ) - 1, &lMaxMeasure, &lMaxBeat );
			}
		}

		// If the item is not in the last measure
		if( m_TrackItem.m_lMeasure < lMaxMeasure )
		{
			// Convert from a Measure value to a clock value
			long lClockForMeasure;
			m_pTimeline->MeasureBeatToClocks( dwGroupBits, 0, m_TrackItem.m_lMeasure, 0, &lClockForMeasure );

			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE TimeSig;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, 0, lClockForMeasure, NULL, &TimeSig ) ) )
			{
				lMaxBeat = TimeSig.bBeatsPerMeasure - 1;
			}
		}
		// Else the item is in the last measure and lMaxBeat is already set

		// Now convert the measure and beat from 0-based to 1-based
		lMaxMeasure++;
		lMaxBeat++;
	}

	// Check if the edit control has a valid window handle.
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		// It doesn't have a valid window handle - the property page may have been destroyed (or not yet created).
		// Just exit early
		return;
	}

	// Don't send OnKill/OnUpdate notifications when updating the display
	CLockoutNotification LockoutNotifications( m_hWnd );

	// Check if multiple items are selected
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		// Yes - disable the property page and return
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.

	// Enable all the controls
	EnableControls( TRUE );

	// Set File combo box selection
//	m_fIgnoreSelChange = TRUE;
//	SetFileComboBoxSelection();
//	m_fIgnoreSelChange = FALSE;

	// If the item was previously invalid, update the measure and beat display
	if( !m_fValidTrackItem )
	{
		SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_TrackItem.m_lMeasure + 1 );
		SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_TrackItem.m_lBeat + 1 );
		SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_TrackItem.m_lTick );
	}
	// Otherwise, check if the values displayed don't match the new ones
	else
	{
		// Get text from measure edit control
		TCHAR tcstrTmp[DIALOG_EDIT_LEN];
		m_editMeasure.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		BOOL fTransSuccess;
		long lCurValue = GetDlgItemInt( m_editMeasure.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lMeasure + 1) )
		{
			// Update the displayed measure number
			SetDlgItemInt( m_editMeasure.GetDlgCtrlID(), m_TrackItem.m_lMeasure + 1 );
		}

		// Get text from beat edit control
		m_editBeat.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editBeat.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lBeat + 1) )
		{
			// Update the displayed beat number
			SetDlgItemInt( m_editBeat.GetDlgCtrlID(), m_TrackItem.m_lBeat + 1 );
		}

		// Get text from tick edit control
		m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

		// Convert from text to an integer
		lCurValue = GetDlgItemInt( m_editTick.GetDlgCtrlID(), &fTransSuccess, TRUE );

		// Check if the conversion failed, the text is empty, or if the values are different
		if( !fTransSuccess
		|| (tcstrTmp[0] == NULL)
		|| (lCurValue != m_TrackItem.m_lTick) )
		{
			// Update the displayed tick number
			SetDlgItemInt( m_editTick.GetDlgCtrlID(), m_TrackItem.m_lTick );
		}
	}

	// Update the range for the measure spin control
	m_spinMeasure.SetRange( 1, lMaxMeasure );

	// Update the range for the beat spin control
	m_spinBeat.SetRange( 1, lMaxBeat );

	// Update the range for the tick spin control
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::SetFileComboBoxSelection
/*
void CTabFileRef::SetFileComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	// Make sure multiple items were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		goto LEAVE;
	}

	// Nothing to select
	if( m_TrackItem.m_FileRef.pIDocRootNode == NULL )
	{
		goto LEAVE;
	}

	// Create a FileListInfo struct for the current file
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pFileListInfo = new FileListInfo;
	if( pFileListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( m_TrackItem.m_FileRef.pIDocRootNode, &pFileListInfo->guidFile );

	if( SUCCEEDED ( m_TrackItem.m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pFileListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pPropPageMgr->m_pIFramework->FindProject( m_TrackItem.m_FileRef.pIDocRootNode, &pIProject ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->pIProject = pIProject;
//		pFileListInfo->pIProject->AddRef();	intentionally missing

		BSTR bstrProjectName;
		if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
		{
			delete pFileListInfo;
			goto LEAVE;
		}

		pFileListInfo->strProjectName = bstrProjectName;
		::SysFreeString( bstrProjectName );
	}
	else
	{
		delete pFileListInfo;
		goto LEAVE;
	}

	// Select the file in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboFile.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		FileListInfo* pCurFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nCurPos );
		if( pCurFileListInfo )
		{
			if( pCurFileListInfo != (FileListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurFileListInfo->guidFile, pFileListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}

	if( nMatch == CB_ERR )
	{
		FileListInfo* pSLI;

		// Delete old FileInfo list
		while( !m_lstFileListInfo.IsEmpty() )
		{
			pSLI = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboFile.ResetContent();

		// Add this file to the combo box list
		nPos = 0;
		m_lstFileListInfo.AddTail( pFileListInfo );
		InsertFileInfoListInComboBox();
	}
	else
	{
		nPos = nMatch;
		delete pFileListInfo;
		pFileListInfo = NULL;
	}

LEAVE:
	m_comboFile.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::GetFileComboBoxText

void CTabFileRef::GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pFileListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pFileListInfo->strProjectName, pFileListInfo->strName, pFileListInfo->strDescriptor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfoListInComboBox

void CTabFileRef::InsertFileInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	FileListInfo* pFileListInfo;
	int nPos;

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pFileListInfo )
		{
			GetFileComboBoxText( pFileListInfo, strText );
			nPos = m_comboFile.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboFile.SetItemDataPtr( nPos, pFileListInfo );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::InsertFileInfo

void CTabFileRef::InsertFileInfo( FileListInfo* pFileListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	FileListInfo* pListInfo;
	CString strListText;
	CString strFileText;
	POSITION posList;

	GetFileComboBoxText( pFileListInfo, strFileText );

	POSITION pos = m_lstFileListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pFileListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pFileListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstFileListInfo.InsertBefore( pos, pFileListInfo );
				}
				else
				{
					m_lstFileListInfo.AddTail( pFileListInfo );
				}
				return;
			}

			GetFileComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strFileText ) > 0 )
			{
				m_lstFileListInfo.InsertBefore( posList, pFileListInfo );
				return;
			}
		}
	}

	m_lstFileListInfo.AddTail( pFileListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::BuildFileInfoList

void CTabFileRef::BuildFileInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	FileListInfo* pFileListInfo;

	HRESULT hr;

	hr = m_pPropPageMgr->m_pIFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		return;
	}

	// Get GUID for the DocRoot containing this Wave track (i.e. Segment's DocRoot node)
	IDMUSProdNode* pIMyDocRootNode;
	GUID guidMyDocRoot;
	hr = m_pPropPageMgr->m_pTrackMgr->GetParam( GUID_DocRootNode, 0, 0, &pIMyDocRootNode );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return;
	}
	hr = m_pPropPageMgr->m_pIFramework->GetNodeFileGUID( pIMyDocRootNode, &guidMyDocRoot );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return;
	}
	RELEASE( pIMyDocRootNode );

	// Build the list of files
	hr = m_pPropPageMgr->m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pFileListInfo = new FileListInfo;

				pFileListInfo->pIProject = pIProject;
//				pFileListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
					if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
					{
						pFileListInfo->strProjectName = bstrProjectName;
						::SysFreeString( bstrProjectName );
					}

				}

				if( ListInfo.bstrName )
				{
					pFileListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pFileListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				// Update DocRoot file GUID
				m_pPropPageMgr->m_pIFramework->GetNodeFileGUID ( pIFileNode, &pFileListInfo->guidFile );

				if( ::IsEqualGUID(pFileListInfo->guidFile, guidMyDocRoot) )
				{
					// Prevent circular references!
					// Do not include DocRoot containing this Wave Track in the file list
					delete pFileListInfo;
				}
				else
				{
					InsertFileInfo( pFileListInfo );
				}

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pPropPageMgr->m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}
*/

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnCreate

int CTabFileRef::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	// Call the CPropertyPage's OnCreate method to actually create all our controls from our dialog resource.
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDestroy

void CTabFileRef::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	// Call the CPropertyPage's OnDestroy method to actually destroy all our child controls.
	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnInitDialog

BOOL CTabFileRef::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Call the base class's OnInitDialog method
	CPropertyPage::OnInitDialog();

	// Limit the measure number to positive numbers
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Limit the beat number to 1-256
	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );

	// Limit the tick number to MAX_TICK
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinTick

void CTabFileRef::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditTick();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinBeat

void CTabFileRef::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lBeat );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDeltaposSpinMeasure

void CTabFileRef::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	HandleDeltaChange( pNMHDR, pResult, m_TrackItem.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleDeltaChange
//
// Generic handler for deltapos changes
void CTabFileRef::HandleDeltaChange( NMHDR* pNMHDR,
									   LRESULT* pResult,
									   long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;

		// Now, update the object with the new value
		UpdateObject();
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditTick

void CTabFileRef::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(m_spinTick.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	m_editTick.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinTick.SetPos( 0 );

		// Check if the value changed
		if( m_TrackItem.m_lTick != 0 )
		{
			// Update the item with the new value
			m_TrackItem.m_lTick = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( IDC_EDIT_TICK, &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( IDC_EDIT_TICK, m_TrackItem.m_lTick );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			m_spinTick.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( IDC_EDIT_TICK, iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( m_TrackItem.m_lTick != lNewValue )
			{
				// Update the item with the new value
				m_TrackItem.m_lTick = lNewValue;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditBeat

void CTabFileRef::OnKillfocusEditBeat() 
{
	HandleKillFocus( m_spinBeat, m_TrackItem.m_lBeat );
}

/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnKillfocusEditMeasure

void CTabFileRef::OnKillfocusEditMeasure() 
{
	HandleKillFocus( m_spinMeasure, m_TrackItem.m_lMeasure );
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::HandleKillFocus
//
// Generic handler for KillFocus changes
void CTabFileRef::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if we have a valid DataObject pointer
	if( m_pPropPageMgr->m_pIPropPageObject == NULL )
	{
		return;
	}

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( 1 );

		// Check if the value changed
		if( 0 != lUpdateVal )
		{
			// Update the item with the new value
			lUpdateVal = 0;

			// Now, update the object with the new value
			UpdateObject();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + 1 );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lNewValue - 1 != lUpdateVal )
			{
				// Update the item with the new value
				lUpdateVal = lNewValue - 1;

				// Now, update the object with the new value
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::UpdateObject

void CTabFileRef::UpdateObject( void )
{
	// Check for a valid Property Page Object pointer
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject )
	{
		// Update the Property Page Object with the new item
		m_pPropPageMgr->m_pIPropPageObject->SetData( (void *) &m_TrackItem );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::EnableControls

void CTabFileRef::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if the Beat edit control exists
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	// Update the controls with the new window state
	m_comboFile.EnableWindow( fEnable );
	m_spinTick.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );

	// Check if we're disabling
	if( !fEnable )
	{
		// Check if multiple items are selected
		if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
		{
			// Load the 'multiple select' text
			CString strText;
			if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
			{
				// Display the 'multiple select' text
				m_comboFile.SetWindowText( strText );
//				return;
			}
		}
		else
		{
			m_comboFile.SetCurSel( -1 );
		}

		// No items are selected, so clear the controls
		m_editTick.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editMeasure.SetWindowText( NULL );
	}
}



/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnOK

// Windows translated presses of the 'Enter' key into presses of the button 'OK'.
// Here we create a hidden 'OK' button and translate presses of it into tabs to the next
// control in the property page.
void CTabFileRef::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CWnd* pWnd = GetFocus();
	if( pWnd )
	{
		CWnd* pWndNext = GetNextDlgTabItem( pWnd );
		if( pWndNext )
		{
			pWndNext->SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnDropDownComboFile

void CTabFileRef::OnDropDownComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	// Delete old FileInfo list
	FileListInfo* pFileListInfo;
	while( !m_lstFileListInfo.IsEmpty() )
	{
		pFileListInfo = static_cast<FileListInfo*>( m_lstFileListInfo.RemoveHead() );
		delete pFileListInfo;
	}

	// Remove old list from combo box
	m_comboFile.ResetContent();

	// Rebuild the FileInfo list
	BuildFileInfoList();
	InsertFileInfoListInComboBox();

	// Select the current file
	SetFileComboBoxSelection();
*/
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSelChangeComboFile

void CTabFileRef::OnSelChangeComboFile() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	ASSERT( m_pPropPageMgr->m_pIFramework != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	// Make sure multiple Scripts were not selected
	ASSERT( !(m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT) );
	if( m_TrackItem.m_dwBitsUI & UD_MULTIPLESELECT )
	{
		return;
	}

	int nItem = m_comboFile.GetCurSel();
	if( nItem != CB_ERR )
	{
		FileListInfo* pFileListInfo = (FileListInfo *)m_comboFile.GetItemDataPtr( nItem );
		if( pFileListInfo != (FileListInfo *)-1 )
		{
			// fill in appropriate fields
			m_TrackItem.m_FileRef.li = *pFileListInfo;

			IDMUSProdNode* pIDocRootNode = NULL;
			
			// NOTE: Items must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindDocRootNodeByFileGUID( pFileListInfo->guidFile, &pIDocRootNode ) ) )
			{
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->Release();
					m_TrackItem.m_FileRef.pIDocRootNode = NULL;
				}
				
				m_TrackItem.m_FileRef.pIDocRootNode = pIDocRootNode;
				if( m_TrackItem.m_FileRef.pIDocRootNode )
				{
					m_TrackItem.m_FileRef.pIDocRootNode->AddRef();
				}

				UpdateObject();

				pIDocRootNode->Release();
			}
		}
	}
*/
}


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef::OnSetActive

BOOL CTabFileRef::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Refresh the page
	if(	m_fValidTrackItem )
	{
		SetTrackItem( &m_TrackItem );
	}
	else
	{
		SetTrackItem( NULL );
	}

	if( m_pPropPageMgr 
	&&  m_pPropPageMgr->m_pTrackMgr 
	&&  m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CPropPageMgrItem::sm_nActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabObject.cpp ===
// TabObject.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "TabObject.h"
#include "GroupBitsPPG.h"
#include <PChannelName.h>
#include "Timeline.h"
#include "DMusProd.h"
#include <dmusicf.h>
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTabObject property page

CTabObject::CTabObject() : CPropertyPage(CTabObject::IDD)
{
	//{{AFX_DATA_INIT(CTabObject)
	//}}AFX_DATA_INIT

	m_pPPO = NULL;
	m_pPropPageMgr = NULL;
	m_pIPropSheet = NULL;

	m_PPGObjectParams.dwPageIndex = 2;
	m_PPGObjectParams.dwPChannel = 0;
	m_PPGObjectParams.dwParamFlagsDM = 0;

	m_fNeedToDetach = FALSE;
}

CTabObject::~CTabObject()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
}

void CTabObject::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabObject)
	DDX_Control(pDX, IDC_STAGE_STATIC, m_StageStatic);
	DDX_Control(pDX, IDC_OBJECT_STATIC, m_ObjectStatic);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNELNAME, m_editPChannelName);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabObject, CPropertyPage)
	//{{AFX_MSG_MAP(CTabObject)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_PCHANNEL, OnChangeEditPchannel)
	ON_EN_KILLFOCUS(IDC_EDIT_PCHANNEL, OnKillfocusEditPchannel)
	ON_EN_CHANGE(IDC_EDIT_PCHANNELNAME, OnChangeEditPChannelName)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PCHANNEL, OnDeltaposSpinPchannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CTabObject::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CTabObject::EnableControls( BOOL fEnable )
{
	// Make sure controls have been created
	if( ::IsWindow(m_editPChannel.m_hWnd) == FALSE )
	{
		return;
	}

	m_editPChannel.EnableWindow(fEnable);
	m_spinPChannel.EnableWindow( fEnable );
	//m_editName.EnableWindow(fEnable);
	m_editPChannelName.EnableWindow(fEnable);
}

/////////////////////////////////////////////////////////////////////////////
// CTabObject message handlers

int CTabObject::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CTabObject::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabObject::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	m_editPChannel.SetLimitText( 4 ); // 'perf'
	m_spinPChannel.SetRange( MIN_PCHANNEL, MAX_PCHANNEL );

	// Limit PChannel names to DMUS_MAX_NAME - 1 characters
	m_editPChannelName.LimitText( DMUS_MAX_NAME - 1 );

	// Limit track names to DMUS_MAX_NAME - 1 characters
	//m_editName.LimitText( DMUS_MAX_NAME - 1 );

	m_strBroadcastSeg.LoadString(IDS_BROADCAST_SEG);
	m_strBroadcastPerf.LoadString(IDS_BROADCAST_PERF);

	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CTabObject::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioObjectPPG* pioObjectPPG = &m_PPGObjectParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioObjectPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// If a broadcast PChannel, disable setting the PChannel name, and display text
	// instead of a number
	/*if( m_PPGObjectParams.dwPChannel >= DMUS_PCHANNEL_BROADCAST_SEGMENT )
	{
		m_editPChannelName.EnableWindow( FALSE );
		if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
		}
		else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
		}
	}
	else
	{
		m_spinPChannel.SetPos( m_PPGObjectParams.dwPChannel + 1 );
	}*/

	// Set strip name
	//m_editName.SetWindowText( m_PPGObjectParams.strStripName );

	m_ObjectStatic.SetWindowText(m_PPGObjectParams.strObjectName);
	//m_StageStatic.SetWindowText(m_PPGObjectParams.strStageName);

	// Set PChannel name
	//m_editPChannelName.SetWindowText( m_PPGObjectParams.strPChannelName );
	m_editPChannelName.SetWindowText(m_PPGObjectParams.strPChannelText);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CTabObject::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	m_pIPropSheet->GetActivePage( &CGroupBitsPropPageMgr::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}

void CTabObject::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGObjectParams) ) );
	}
}

void CTabObject::OnChangeEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( !strNewPChannel.IsEmpty() )
		{
			// Check if this is broadcast PChannel
			if( _tcsnicmp( strNewPChannel, m_strBroadcastPerf, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_PPGObjectParams.dwPChannel != DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					m_PPGObjectParams.dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
					GetPChannelName( m_PPGObjectParams.dwPChannel, m_PPGObjectParams.strPChannelName );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_PPGObjectParams.strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else if( _tcsnicmp( strNewPChannel, m_strBroadcastSeg, strNewPChannel.GetLength() ) == 0 )
			{
				if( m_PPGObjectParams.dwPChannel != DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					m_PPGObjectParams.dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
					GetPChannelName( m_PPGObjectParams.dwPChannel, m_PPGObjectParams.strPChannelName );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_PPGObjectParams.strPChannelName );
						m_editPChannelName.EnableWindow( FALSE );
					}
				}
			}
			else
			{
				BOOL fTransSucceeded;
				int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
				if ( !fTransSucceeded || (nPChannel < MIN_PCHANNEL) )
				{
					nPChannel = MIN_PCHANNEL;
					m_spinPChannel.SetPos( nPChannel );
				}
				else if( nPChannel > MAX_PCHANNEL )
				{
					nPChannel = MAX_PCHANNEL;
					m_spinPChannel.SetPos( nPChannel );
				}

				m_editPChannelName.EnableWindow( TRUE );

				if( (unsigned)nPChannel != (m_PPGObjectParams.dwPChannel + 1) )
				{
					m_PPGObjectParams.dwPChannel = nPChannel - 1;
					GetPChannelName( m_PPGObjectParams.dwPChannel, m_PPGObjectParams.strPChannelName );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_PPGObjectParams.strPChannelName );
					}
				}
			}
		}
	}
}

void CTabObject::OnKillfocusEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		CString strNewPChannel;
		m_editPChannel.GetWindowText( strNewPChannel );

		// Strip leading and trailing spaces
		strNewPChannel.TrimRight();
		strNewPChannel.TrimLeft();

		if ( strNewPChannel.IsEmpty() )
		{
			if( m_PPGObjectParams.dwPChannel < DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_spinPChannel.SetPos( m_PPGObjectParams.dwPChannel + 1 );
				m_editPChannelName.EnableWindow( TRUE );
			}
			else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_editPChannel.SetWindowText( m_strBroadcastSeg );
				m_editPChannelName.EnableWindow( FALSE );
			}
			else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				m_editPChannelName.EnableWindow( FALSE );
			}
		}
		else
		{
			if( (_tcsnicmp( strNewPChannel, m_strBroadcastPerf, strNewPChannel.GetLength() ) != 0)
			&&	(_tcsnicmp( strNewPChannel, m_strBroadcastSeg, strNewPChannel.GetLength() ) != 0) )
			{
				// Convert from text to dword;
				BOOL fTransSucceeded;
				int nPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTransSucceeded, FALSE );
				ASSERT( fTransSucceeded );
				/*
				if ( !fTransSucceeded || (nPChannel < 1) )
				{
					m_dwPChannel = 0;
					m_strPChannelName = GetPChannelName( m_dwPChannel );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_strPChannelName );
					}
				}
				else */ if( unsigned(nPChannel - 1) != m_PPGObjectParams.dwPChannel )
				{
					m_PPGObjectParams.dwPChannel = nPChannel - 1;
					GetPChannelName( m_PPGObjectParams.dwPChannel, m_PPGObjectParams.strPChannelName );
					UpdatePPO();

					// Changing a PChannel may cause this property sheet to be removed
					// so don't assume controls are still hanging around
					if( ::IsWindow(m_editPChannelName.m_hWnd) )
					{
						m_editPChannelName.SetWindowText( m_PPGObjectParams.strPChannelName );
					}
				}
				m_editPChannelName.EnableWindow( TRUE );
			}
		}
	}
}

void CTabObject::OnChangeEditPChannelName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewName;

	m_editPChannelName.GetWindowText( cstrNewName );

	// Strip leading and trailing spaces
	cstrNewName.TrimRight();
	cstrNewName.TrimLeft();

	if( cstrNewName.Compare( m_PPGObjectParams.strPChannelName ) != 0 )
	{
		m_PPGObjectParams.strPChannelName = cstrNewName;
		UpdatePPO();
	}
}

/*void CTabObject::OnChangeEditName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		return;
	}

	CString cstrNewStripName;

	m_editName.GetWindowText( cstrNewStripName );

	// Strip leading and trailing spaces
	cstrNewStripName.TrimRight();
	cstrNewStripName.TrimLeft();

	if( cstrNewStripName.Compare( m_PPGObjectParams.strStripName ) != 0 )
	{
		m_PPGObjectParams.strStripName = cstrNewStripName;
		UpdatePPO();
	}
}*/

BOOL CTabObject::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_PCHANNEL:
								// If a broadcast PChannel, disable setting the PChannel name, and display text
								// instead of a number
								if( m_PPGObjectParams.dwPChannel >= DMUS_PCHANNEL_BROADCAST_SEGMENT )
								{
									m_editPChannelName.EnableWindow( FALSE );
									if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
									{
										m_editPChannel.SetWindowText( m_strBroadcastSeg );
									}
									else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
									{
										m_editPChannel.SetWindowText( m_strBroadcastPerf );
									}
								}
								else
								{
									m_editPChannelName.EnableWindow( TRUE );
									m_spinPChannel.SetPos( m_PPGObjectParams.dwPChannel + 1 );
								}
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

HRESULT CTabObject::GetPChannelName( DWORD dwPChannel, CString& strPChannelName )
{
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pTrackMgr )
	{
		return m_pPropPageMgr->m_pTrackMgr->GetPChannelName( dwPChannel, strPChannelName ); 
	}

	// Should not happen!
	ASSERT( 0 );
	strPChannelName.Empty();
	return E_FAIL;
}

void CTabObject::OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	*pResult = 0;

	if( pNMUpDown )
	{
		if( pNMUpDown->iDelta > 0 )
		{
			if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				m_editPChannel.SetWindowText( m_strBroadcastPerf );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
				*pResult = 1;
			}
			else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				m_spinPChannel.SetPos( 1 );
				// Taken care of by OnChangeEditPchannel
				//m_dwPChannel = 0;
				*pResult = 1;
			}
		}
		else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
		{
			*pResult = 1;
		}
		else if( m_PPGObjectParams.dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
		{
			m_editPChannel.SetWindowText( m_strBroadcastSeg );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
			*pResult = 1;
		}
		else if( m_PPGObjectParams.dwPChannel == 0 )
		{
			m_editPChannel.SetWindowText( m_strBroadcastPerf );
			// Taken care of by OnChangeEditPchannel
			//m_dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
			*pResult = 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabObject.h ===
#if !defined(AFX_TABOBJECT_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
#define AFX_TABOBJECT_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TabObject.h : header file
//
// Also defined in NewPartDlg.h
#define MIN_PCHANNEL	1
#define MAX_PCHANNEL	999

#include "resource.h"
#include "NewPartDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CTabObject dialog

interface IDMUSProdPropPageObject;
interface IDMUSProdPChannelName;
interface IDMUSProdPropSheet;

class CGroupBitsPropPageMgr;

struct ioObjectPPG
{
	DWORD	dwPageIndex;
	DWORD	dwPChannel;
	CString strPChannelText;
	DWORD	dwParamFlagsDM;
	CString strStripName;
	CString strPChannelName;
	CString strObjectName;
	CString strStageName;
};

class CTabObject : public CPropertyPage
{
friend class CGroupBitsPropPageMgr;

// Construction
public:
	CTabObject();
	~CTabObject();

// Dialog Data
	//{{AFX_DATA(CTabObject)
	enum { IDD = IDD_PROPPAGE_OBJECT };
	CStatic	m_StageStatic;
	CStatic	m_ObjectStatic;
	CEdit	m_editPChannel;
	CEdit	m_editPChannelName;
	CSpinButtonCtrl	m_spinPChannel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabObject)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabObject)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditPchannel();
	afx_msg void OnKillfocusEditPchannel();
	afx_msg void OnChangeEditPChannelName();
	afx_msg void OnDeltaposSpinPchannel(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	HRESULT GetPChannelName( DWORD dwPChannel, CString& strPChannelName );

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	CGroupBitsPropPageMgr*		m_pPropPageMgr;
	IDMUSProdPropPageObject*	m_pPPO;
	ioObjectPPG					m_PPGObjectParams;
	BOOL						m_fNeedToDetach;

	CString						m_strBroadcastSeg;
	CString						m_strBroadcastPerf;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABOBJECT_H__D02E70E9_E7C6_4033_AD9F_A8BDA1620F03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TabFileRef.h ===
#if !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

// TabFileRef.h : header file
//

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>

class CPropPageMgrItem;
class CTabOnReturnEdit;


/////////////////////////////////////////////////////////////////////////////
// CTabFileRef dialog

class CTabFileRef : public CPropertyPage
{
	friend CPropPageMgrItem;
	DECLARE_DYNCREATE(CTabFileRef)

// Construction
public:
	CTabFileRef();
	~CTabFileRef();

// Dialog Data
	//{{AFX_DATA(CTabFileRef)
	enum { IDD = IDD_PROPPAGE_WAVE_FILEREF };
	CComboBox	m_comboFile;
	CEdit	m_editTick;
	CEdit	m_editBeat;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinTick;
	CSpinButtonCtrl	m_spinBeat;
	CSpinButtonCtrl	m_spinMeasure;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabFileRef)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTabFileRef)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditMeasure();
	virtual void OnOK();
	afx_msg void OnDropDownComboFile();
	afx_msg void OnSelChangeComboFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetTrackItem( const CTrackItem * pItem );

protected:
	// File combo box methods
//	void GetFileComboBoxText( const FileListInfo* pFileListInfo, CString& strText );
//	void InsertFileInfoListInComboBox();
//	void InsertFileInfo( FileListInfo* pFileListInfo );
//	void BuildFileInfoList();
//	void SetFileComboBoxSelection();

	void UpdateObject();
	void EnableControls( BOOL fEnable );
	void HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal );
	void HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

	IDMUSProdTimeline*		m_pTimeline;		// Weak timeline reference
	CPropPageMgrItem*		m_pPropPageMgr;

	CTrackItem				m_TrackItem;

	BOOL					m_fNeedToDetach;
	BOOL					m_fValidTrackItem;
	BOOL					m_fIgnoreSelChange;

//    CTypedPtrList<CPtrList, FileListInfo*> m_lstFileListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABFILEREF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\Tracker.cpp ===
// Tracker.cpp : implementation file
//

#include "stdafx.h"
#include "ParamStripMgr.h"
#include "Riffstrm.h"
#include "TrackMgr.h"
#include "TrackItem.h"
#include "Tracker.h"
#include "ParamStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker constructor/ destructor

CCurveTracker::CCurveTracker(CWnd* pWnd, IDMUSProdTimeline* pITimeline, CParamStrip* pParamStrip, short nAction,
							 CRect* initialRect)
{
	ASSERT( pITimeline != NULL );
	ASSERT( pParamStrip != NULL );

	m_pITimeline = pITimeline;
	m_pITimeline->AddRef();

	m_pParamStrip = pParamStrip;
	m_pParamStrip->AddRef();

	m_pWnd = pWnd;
	m_nAction = nAction;


	if (m_nAction == CTRK_DRAGGING) 
	{
		// a little trick to avoid resizing when not intended...
		m_nHandleSize = 0;
	}

	m_pTrackItem = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;

	m_dwScrollTick = 0;
	m_fSetStartPoint = TRUE;

	if (initialRect != NULL) 
	{
		m_rect = *initialRect;
	}
	
	m_sizeMin.cx = 0;
	m_sizeMin.cy = 0;

	m_nStyle = resizeInside;
}

// construct a curve tracker for the SOLE purpose of
// doing hit testing or drawing
CCurveTracker::CCurveTracker(CRect* initialRect)
{
	ASSERT(initialRect != NULL);
	
	m_pITimeline = NULL;
	m_pParamStrip = NULL;
	m_pWnd = NULL;
	m_nAction = CTRK_NOTHING;
	m_pTrackItem = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;
	m_rect = *initialRect;
	m_nStyle = resizeInside;
}

CCurveTracker::~CCurveTracker()
{
	if( m_pITimeline )
	{
		m_pITimeline->Release();
	}

	if( m_pParamStrip )
	{
		m_pParamStrip->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurve

void CCurveTracker::SetCurve( CTrackItem* pTrackItem )
{
	ASSERT( pTrackItem!= NULL );
	m_pTrackItem = pTrackItem;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurveList
//
void CCurveTracker::SetCurveList(CCurveList* pCurveList)
{
	ASSERT(pCurveList != NULL);
	m_pCurveList = pCurveList;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetXOffset
//
void CCurveTracker::SetXOffset(int nXOffset)
{
	ASSERT(nXOffset >= 0);
	m_nXOffset = nXOffset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DoAction

WORD CCurveTracker::DoAction( void )
{
	CRect rectTracker(m_ptStart, m_ptEnd);
	rectTracker.NormalizeRect();

	WORD wRefreshUI = FALSE;

	switch( m_nAction )
	{
		case CTRK_SELECTING:
			wRefreshUI = m_pParamStrip->SelectCurvesInRect( &rectTracker );
			break;

		case CTRK_INSERTING:
		{
			CPoint ptLeft;
			CPoint ptRight;

			if( m_ptStart.x < m_ptEnd.x )
			{
				ptLeft.x = m_ptStart.x;
				ptLeft.y = m_ptStart.y;
				ptRight.x = m_ptEnd.x;
				ptRight.y = m_ptEnd.y;
			}
			else
			{
				ptLeft.x = m_ptEnd.x;
				ptLeft.y = m_ptEnd.y;
				ptRight.x = m_ptStart.x;
				ptRight.y = m_ptStart.y;
			}

			m_pParamStrip->OnUpdateInsertCurveValue( ptLeft, ptRight );
			break;
		}

		case CTRK_DRAGGING:
		case CTRK_DRAGGING_EDGE:
			m_pParamStrip->OnUpdateDragCurveValue( *this, m_nAction );
			break;

	}

	return wRefreshUI;
}



/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetStartEndPoints
//
// Sets the start and end points after restricting them within the strip.
void CCurveTracker::SetStartEndPoints( int nHandle )
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if( !m_pParamStrip->GetStripRect(rectStrip) )
	{
		return;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	// Make sure m_rect.top is within this CurveStrip
	if( m_rect.top < rectStrip.top )
	{
		m_rect.top = rectStrip.top;
	}
	if( m_rect.top >= rectStrip.bottom )
	{
		m_rect.top = rectStrip.bottom;
	}

	// Make sure m_rect.bottom is within this CurveStrip
	if( m_rect.bottom > rectStrip.bottom )
	{
		m_rect.bottom = rectStrip.bottom;
	}
	if( m_rect.bottom <= rectStrip.top )
	{
		m_rect.bottom = rectStrip.top;
	}
	
	// Make tracker rect relative to beginning of the strip
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectTracker.OffsetRect( lLeftPosition, 0 );

	// Get the strip rect relative to its beginning
	CRect rectStripAdjusted = rectStrip;
	rectStripAdjusted.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectStripAdjusted.OffsetRect( lLeftPosition, 0 );

	// Adjust leftmost point
	if( m_nAction == CTRK_DRAGGING_EDGE )
	{
		if( nHandle == hitTopLeft
		||  nHandle == hitBottomLeft
		||  nHandle == hitLeft )
		{
			if( rectTracker.left <= rectTracker.right )
			{
				if( rectTracker.left < rectStripAdjusted.left )
				{
					rectTracker.left = rectStripAdjusted.left;
				}
			}
			else
			{
				if( rectTracker.right < rectStripAdjusted.left )
				{
					rectTracker.right = rectStripAdjusted.left;
				}
			}
		}
	}
	
	bool bKeepLeft = false;
	bool bKeepRight = false;
	
	if (!m_fSetStartPoint && (m_nAction == CTRK_DRAGGING_EDGE)) 
	{
		switch (nHandle) 
		{
			case hitTopLeft:
			case hitBottomLeft:
			case hitLeft:
				bKeepRight = true;
				break;
			case hitTopRight:
			case hitBottomRight:
			case hitRight:
				bKeepLeft = true;
				break;

		}
	}

	// Store starting point if we haven't set it yet
	if (m_fSetStartPoint || m_nAction == CTRK_DRAGGING_EDGE)
	{
		m_fSetStartPoint = FALSE;

		if (bKeepLeft) 
		{
			m_ptStart.y = rectTracker.top;
		}
		else
		{
			m_ptStart = rectTracker.TopLeft();
		}
	}

	// Store ending point
	if (bKeepRight) 
	{
		m_ptEnd.y = rectTracker.bottom;
	}
	else 
	{
		m_ptEnd = rectTracker.BottomRight();
	}

	// Enforce minimum width
	int nNewWidth = m_ptEnd.x - m_ptStart.x;
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if( nAbsWidth < m_sizeMin.cx )
	{
		if( m_ptStart.x <= m_ptEnd.x )
		{
			if( m_ptEnd.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptStart.x = m_ptEnd.x - m_sizeMin.cx;
			}
			else
			{
				m_ptEnd.x = m_ptStart.x + m_sizeMin.cx;
			}
		}
		else
		{
			if( m_ptStart.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptEnd.x = m_ptStart.x - m_sizeMin.cx;
			}
			else
			{
				m_ptStart.x = m_ptEnd.x + m_sizeMin.cx;
			}
		}
	}

	// Enforce minimum height
	int nNewHeight = m_ptEnd.y - m_ptStart.y;
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if( nAbsHeight < m_sizeMin.cy )
	{
		if( m_ptStart.y <= m_ptEnd.y )
		{
			if( m_ptEnd.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptStart.y = m_ptEnd.y - m_sizeMin.cy;
			}
			else
			{
				m_ptEnd.y = m_ptStart.y + m_sizeMin.cy;
			}
		}
		else
		{
			if( m_ptStart.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptEnd.y = m_ptStart.y - m_sizeMin.cy;
			}
			else
			{
				m_ptStart.y = m_ptEnd.y + m_sizeMin.cy;
			}
		}
	}

	// put the values back into m_rect
	m_rect = CRect(m_ptStart, m_ptEnd);
	m_rect.OffsetRect( rectStrip.left, rectStrip.top );
	m_rect.OffsetRect( -lLeftPosition, 0 );
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::LimitRects
//
// Used when m_nAction = CTRK_DRAGGING
// Limits m_rect so that all selected curves will be within the boundaries
// of the strip.
void CCurveTracker::LimitRects() 
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if (!m_pParamStrip->GetStripRect(rectStrip)) 
	{
		return;
	}
	
	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );
	rectStrip.left -= lLeftPosition;

	// Get Curve Strip max right
	VARIANT var;
	m_pITimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineClockLength = V_I4(&var);

	long lMaxPosition = 0;
	m_pITimeline->ClocksToPosition( lTimelineClockLength, &lMaxPosition );
	
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pParamStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectStrip.right = lMaxPosition + rectFBar.right - 1;
	rectStrip.right -= lLeftPosition;

	// adjust tracker rect
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -m_nXOffset, 0 );

	// make a rect that includes all the curve rects
	CRect rectAllCurves = m_pTrackItem->m_rectFrame;
	rectAllCurves.OffsetRect(rectStrip.TopLeft());
	CSize curveOffset =  rectTracker.CenterPoint() - rectAllCurves.CenterPoint();
	rectAllCurves.right = rectAllCurves.left;
	
	// iterate through the list of selected curves and update curveRect
	POSITION listPos;
	listPos = m_pCurveList->GetHeadPosition();
	while (listPos != NULL) 
	{
		CTrackItem* pCurve = m_pCurveList->GetNext(listPos);
		
		CRect newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(rectStrip.TopLeft());
		
		rectAllCurves.left = min(rectAllCurves.left, newRect.left);
		rectAllCurves.right = max(rectAllCurves.right, newRect.left);
		rectAllCurves.top = min(rectAllCurves.top, newRect.top);
		rectAllCurves.bottom = max(rectAllCurves.bottom, newRect.bottom);
	}
	
	rectAllCurves.OffsetRect(curveOffset);
	
	// figure out how much we are going to have to offset m_rect to make it
	// within the strip.
	CSize offset(0, 0);

	// make sure curveRect is within the bounds of the strip
	if (rectAllCurves.top < rectStrip.top) {
		offset.cy = rectStrip.top - rectAllCurves.top;
	}
	else if (rectAllCurves.bottom > rectStrip.bottom) {
		offset.cy = rectStrip.bottom - rectAllCurves.bottom;
	}
	if (rectAllCurves.left < rectStrip.left) {
		offset.cx = rectStrip.left - rectAllCurves.left;
	}
	else if (rectAllCurves.right > rectStrip.right) {
		offset.cx = rectStrip.right - rectAllCurves.right;
	}
	m_rect.OffsetRect(offset);
	m_offset = curveOffset + offset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::AdjustRect

void CCurveTracker::AdjustRect( int nHandle, RECT* pRect )
{
	CRectTracker::AdjustRect( nHandle, pRect );

	if (m_nAction == CTRK_DRAGGING) 
	{
		LimitRects();
	}
	else 
	{
		// Set the Start and End points
		SetStartEndPoints(nHandle);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DrawTrackerRect

void CCurveTracker::DrawTrackerRect( LPCRECT lpRect, CWnd* /*pWndClipTo*/, CDC* pDC, CWnd* /*pWnd*/ )
{
	// clip to the strip
	CRect rectStrip;
	if( !m_pParamStrip->GetStripRect(rectStrip) )
	{
		return;
	}
	
	VARIANT var;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pParamStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);
	rectStrip.left = rectFBar.right;
	CRgn rgn;
	rgn.CreateRectRgn(rectStrip.left, rectStrip.top, rectStrip.right, rectStrip.bottom);
	pDC->SelectClipRgn(&rgn);
		
	// prepare DC for dragging
	pDC->SelectObject(CBrush::FromHandle((HBRUSH)::GetStockObject(NULL_BRUSH)));
	pDC->SetROP2(R2_XORPEN);
	CPen* pOldPen = NULL;
	CPen dragPen;
	if (dragPen.CreatePen(PS_DOT, 0, RGB(0, 0, 0))) 
	{
		pOldPen = pDC->SelectObject(&dragPen);
	}

	if ( m_bErase == FALSE )
	{
		WORD wRefreshUI = DoAction();

		if( wRefreshUI )
		{
			m_pParamStrip->RefreshCurveStrips();
			m_pParamStrip->RefreshCurvePropertyPage(); 
			m_pWnd->UpdateWindow();
		}
	}
	
	if (m_nAction == CTRK_DRAGGING)
	{
		CRect rectFrame;

		// draw the other rects being dragged
		rectFrame = m_pTrackItem->m_rectFrame;
		rectFrame.OffsetRect( m_nXOffset, 0 );
		CSize offset = rectFrame.CenterPoint() - CRect(lpRect).CenterPoint();
		
		// iterate through the list of selected curves
		POSITION listPos;
		listPos = m_pCurveList->GetHeadPosition();
		while (listPos != NULL)
		{
			CTrackItem* pCurve = m_pCurveList->GetNext(listPos);
			rectFrame = pCurve->m_rectFrame;
			rectFrame.OffsetRect( m_nXOffset, 0 );
			pDC->Rectangle(rectFrame - offset);
		}
	}

	// draw the rect 
	pDC->Rectangle( lpRect );

	// cleanup
	if (pOldPen) 
	{
		pDC->SelectObject(pOldPen);
		dragPen.DeleteObject();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\Tracker.h ===
#ifndef __CURVETRACKER_H__
#define __CURVETRACKER_H__

// Tracker.h : header file
//


#include <afxext.h>

#define CTRK_NOTHING		0
#define CTRK_SELECTING		1
#define CTRK_INSERTING		2
#define CTRK_EDITING		3
#define CTRK_DRAGGING		4
#define CTRK_DRAGGING_EDGE	5


class CTrackItem;

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker class

typedef CList<CTrackItem*, CTrackItem*> CCurveList;
class CCurveTracker : public CRectTracker
{
public:
   CCurveTracker( CWnd* pWnd, IDMUSProdTimeline* pITimeline, CParamStrip* pParamStrip, short nAction,
	   CRect* initialRect = NULL);
   CCurveTracker( CRect* initialRect );
   virtual ~CCurveTracker();
   
protected:
	WORD DoAction();
	void ScrollPianoRoll();
	void SetStartEndPoints(int nHandle);
	void LimitRects();

public:
	void SetCurve( CTrackItem* pTrackItem);
	void SetCurveList(CCurveList* pCurveList);
	void SetXOffset(int nXOffset);

// Overrides
public:
	virtual void AdjustRect( int nHandle, RECT* pRect );
	virtual void DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd );

// public members
public:
	// used for dragging
	CSize			m_offset;
	CTrackItem*		m_pTrackItem;	
	CCurveList*		m_pCurveList;
	int				m_nXOffset;			

// private members
protected:
	CWnd*				m_pWnd;
	IDMUSProdTimeline*	m_pITimeline;
	CParamStrip*		m_pParamStrip;
	short				m_nAction;

	CPoint			m_ptStart;	
	CPoint			m_ptEnd;
	BOOL			m_fSetStartPoint;
	
	DWORD			m_dwScrollTick;
};

#endif // __CURVETRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackItem.h ===
#ifndef __PARAM_TRACKITEM_H_
#define __PARAM_TRACKITEM_H_

#include <DMUSProd.h>
#include <dmusici.h>

class CTrackMgr;

// m_dwBits
#define UD_DRAGSELECT		0x00000001
#define UD_MULTIPLESELECT	0x00000002


// m_wFlags
#define RF_TOP_ITEM			0x0001

// Curve defines
#define CT_MAX		192		// Curve table maximum
#define CT_FACTOR	100		// Curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // Curve division factor

// Curve Table: LINEAR
static short ganCT_Linear[CT_MAX + 1] =
{
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200
};


// Curve Table: SINE
static short ganCT_Sine[CT_MAX + 1] =
{
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200
};


// Curve Table: LOG
static short ganCT_Log[CT_MAX + 1] =
{
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200
};


// Curve Table: EXPONENTIAL
static short ganCT_Exp[CT_MAX + 1] =
{
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200
};

class CParamStrip;

class CTrackSelectionItem
{
	CTrackSelectionItem();

};

class CTrackItem
{
public:
	CTrackItem();
	CTrackItem( CTrackMgr* pTrackMgr, CParamStrip* pParamStrip );
	CTrackItem( CTrackMgr* pTrackMgr, CParamStrip* pParamStrip, const CTrackItem& );
	virtual ~CTrackItem();

	void Clear();
	void Copy( const CTrackItem* pItem );
	BOOL IsEqual( const CTrackItem* pItem );

	BOOL After( const CTrackItem& item );
	BOOL Before( const CTrackItem& item );

	HRESULT LoadListItem( IStream* pIStream, DWORD dwStructSize );
	HRESULT SaveListItem( IStream* pIStream );
	HRESULT LoadTrackItem( IStream* pIStream, DWORD dwStructSize );
	HRESULT SaveTrackItem( IStream* pIStream );

	float	ComputeCurve( MUSIC_TIME* pmtIncrement );			// Computes value of Curve at time m_mtCurrent
	void	SwitchTimeBase( void );

	void	SetStartEndTime(MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	void	SetPhysicalTime(REFERENCE_TIME rtTimePhysical, REFERENCE_TIME rtDuration);
	void	SetStartEndValue(float fltStart, float fltEnd);
	void	GetStartEndValue(float& fltStart, float& fltEnd);
	void	UpdateTimeFieldsFromMeasureBeatTick();


public:
	// Fields that are persisted
	MUSIC_TIME		m_mtStartTime;		
	MUSIC_TIME		m_mtEndTime;			
	float			m_fltStartValue;
	float			m_fltEndValue;
	DWORD			m_dwCurveType;			// MP_CURVETYPE enum in IMediaParams.h
	DWORD			m_dwFlags;				// A combination of the MPF_ENVLP_* constants in medparam.h

	REFERENCE_TIME	m_rtTimePhysical;		// Time of measure/beat/tick (REFERENCE_TIME or MUSIC_TIME)

	MUSIC_TIME		m_mtDuration;			// How long this curve lasts
	REFERENCE_TIME  m_rtDuration;			// Duration in REFERENCE_TIME

	// Drawing data
	CRect			m_rectFrame;			// Coords of drawn wave
	CRect			m_rectSelect;			// Coords used for selection (includes text)
	MUSIC_TIME		m_mtCurrent;


	// Work fields
    long			m_lMeasure;				// What measure this item falls on
    long			m_lBeat;				// What beat this item falls on
    long			m_lTick;				// What tick this item falls on
	DWORD			m_dwBitsUI;				// Various bits
	WORD			m_wFlagsUI;				// Various flags
	BOOL			m_fSelected;			// This item is currently selected

private:
	CTrackMgr*		m_pTrackMgr;			// Will be NULL when CTrackItem used for properties
	CParamStrip*	m_pParamStrip;			// The param strip on which this item is placed
};

#endif // __PARAM_TRACKITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackItem.cpp ===
#include "stdafx.h"
#include <math.h>
#include <RiffStrm.h>
#include "TrackItem.h"
#include "TrackMgr.h"
#include "ParamStrip.h"
#include <dmusicf.h>

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTrackItem Constructors/Destructor

CTrackItem::CTrackItem( void ) : m_fSelected(FALSE)
{
	m_pTrackMgr = NULL;
	m_pParamStrip = NULL;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, CParamStrip* pParamStrip )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;
	m_pParamStrip = pParamStrip;

	Clear();
}

CTrackItem::CTrackItem( CTrackMgr* pTrackMgr, CParamStrip* pParamStrip, const CTrackItem& item )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;
	m_pParamStrip = pParamStrip;

	// Copy the passed-in item
	Copy( &item );
}

CTrackItem::~CTrackItem( void )
{
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Clear

void CTrackItem::Clear()
{
	m_mtStartTime = 0;
	m_mtEndTime = 0;
	m_fltStartValue = 0;
	m_fltEndValue = 0;
	m_dwCurveType = MP_CURVE_SINE;

	m_rtTimePhysical = 0;
	m_rtDuration = 0;

	m_lMeasure = 0;
	m_lBeat = 0;
	m_lTick = 0;
	m_dwBitsUI = 0;
	m_wFlagsUI = 0;
	m_fSelected = FALSE;

	m_dwFlags = MPF_ENVLP_STANDARD;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::IsEqual

BOOL CTrackItem::IsEqual( const CTrackItem* pItem )
{
	ASSERT( pItem != NULL );
	
	if( pItem )
	{
		if( m_mtStartTime == pItem->m_mtStartTime
		&&  m_mtEndTime == pItem->m_mtEndTime
		&&  m_fltStartValue == pItem->m_fltStartValue
		&&  m_fltEndValue == pItem->m_fltEndValue
		&&  m_dwCurveType == pItem->m_dwCurveType )
		{
			return TRUE;
		}
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Copy

void CTrackItem::Copy( const CTrackItem* pItem )
{
	ASSERT( pItem != NULL );
	if ( pItem == NULL )
	{
		return;
	}

	if( pItem == this )
	{
		return;
	}

	m_mtStartTime = pItem->m_mtStartTime;
	m_mtEndTime = pItem->m_mtEndTime;
	m_fltStartValue = pItem->m_fltStartValue;
	m_fltEndValue = pItem->m_fltEndValue;
	m_dwCurveType = pItem->m_dwCurveType;

	m_rtTimePhysical = pItem->m_rtTimePhysical;
	m_rtDuration = pItem->m_rtDuration;

	m_lMeasure = pItem->m_lMeasure;
	m_lBeat = pItem->m_lBeat;
	m_lTick = pItem->m_lTick;
	m_dwBitsUI = pItem->m_dwBitsUI;
	m_wFlagsUI = pItem->m_wFlagsUI;
	m_fSelected = pItem->m_fSelected;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::After

BOOL CTrackItem::After( const CTrackItem& item )
{
	// Check if this item is after the one passed in.

	// Check if our measure number is greater.
	if( m_lMeasure > item.m_lMeasure )
	{
		// Our measure number is greater - we're after the item
		return TRUE;
	}
	// Check if our measure number is equal
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our beat number is greater
		if( m_lBeat > item.m_lBeat )
		{
			// Our beat number is greater - we're after the item
			return TRUE;
		}
		// Check if our beat number is equal
		else if( m_lBeat == item.m_lBeat )
		{
			// Check if our tick number is greater
			if( m_lTick > item.m_lTick )
			{
				// Our tick number is greater - we're after the item
				return TRUE;
			}
		}
	}

	// We're either before the item, or on the same measure, beat, tick.
	return FALSE;
}


//////////////////////////////////////////////////////////////////////
//	CTrackItem::Before

BOOL CTrackItem::Before( const CTrackItem& item )
{
	// Check if this item is before the one passed in.

	// Check if our measure number is lesser.
	if( m_lMeasure < item.m_lMeasure )
	{
		// Our measure number is lesser - we're before the item
		return TRUE;
	}
	// Check if our measure number is equal.
	else if( m_lMeasure == item.m_lMeasure )
	{
		// Check if our beat number is lesser.
		if( m_lBeat < item.m_lBeat )
		{
			// Our beat number is lesser - we're before the item
			return TRUE;
		}
		// Check if our beat number is equal.
		else if( m_lBeat == item.m_lBeat )
		{
			// Check if our tick number is lesser.
			if( m_lTick < item.m_lTick )
			{
				// Our tick number is lesser - we're before the item
				return TRUE;
			}
		}
	}

	// We're either after the item, or on the same measure, beat, tick.
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::LoadListItem

HRESULT CTrackItem::LoadListItem( IStream* pIStream, DWORD dwStructSize )
{
    ASSERT(m_pTrackMgr);
    if(m_pTrackMgr == NULL)
    {
        return E_UNEXPECTED;
    }

	// LoadListItem does not expect to be called twice on the same object
	// Code assumes item consists of initial values
	ASSERT( m_mtStartTime == 0 ); 
	ASSERT( m_mtEndTime == 0 );

	if( pIStream == NULL 
	||  dwStructSize == 0 )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Load the item
	DMUS_IO_PARAMCONTROLTRACK_CURVEINFO iCurveInfo;
	DWORD dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_CURVEINFO ), dwStructSize );
	DWORD dwByteCount;
	HRESULT hr = pIStream->Read( &iCurveInfo, dwSize, &dwByteCount );

	// Handle any I/O error by returning a failure code
	if( FAILED( hr )
	||  dwByteCount != dwSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// We have the physical time in the start time
	m_rtTimePhysical = iCurveInfo.mtStartTime;
	m_rtDuration = iCurveInfo.mtEndTime;

	m_fltStartValue = iCurveInfo.fltStartValue;
	m_fltEndValue = iCurveInfo.fltEndValue;
	m_dwCurveType = iCurveInfo.dwCurveType;
	m_dwFlags = iCurveInfo.dwFlags;

	m_pTrackMgr->ClocksToMeasureBeatTick( m_mtStartTime, &m_lMeasure, &m_lBeat, &m_lTick );

ON_ERROR:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveListItem

HRESULT CTrackItem::SaveListItem( IStream* pIStream )
{
	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Clear out the structure (clears out the padding bytes as well).
	DMUS_IO_PARAMCONTROLTRACK_CURVEINFO oCurveInfo;
	ZeroMemory( &oCurveInfo, sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO) );

	// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_CURVEINFO structure
	oCurveInfo.mtStartTime = m_mtStartTime;
	oCurveInfo.mtEndTime = m_mtEndTime;
	oCurveInfo.fltStartValue = m_fltStartValue;
	oCurveInfo.fltEndValue = m_fltEndValue;
	oCurveInfo.dwCurveType = m_dwCurveType;
	oCurveInfo.dwFlags = m_dwFlags;

	// Write the structure out to the stream
	DWORD dwBytesWritten;
	HRESULT hr = pIStream->Write( &oCurveInfo, sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO) )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::LoadTrackItem

HRESULT CTrackItem::LoadTrackItem( IStream* pIStream, DWORD dwStructSize )
{
	// LoadTrackItem does not expect to be called twice on the same object
	// Code assumes item consists of initial values
	ASSERT( m_mtStartTime == 0 ); 
	ASSERT( m_mtEndTime == 0 );

	if( pIStream == NULL 
	||  dwStructSize == 0 )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Load the item
	DMUS_IO_PARAMCONTROLTRACK_CURVEINFO iCurveInfo;
	DWORD dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_CURVEINFO ), dwStructSize );
	DWORD dwByteCount;
	HRESULT hr = pIStream->Read( &iCurveInfo, dwSize, &dwByteCount );

	// Handle any I/O error by returning a failure code
	if( FAILED( hr )
	||  dwByteCount != dwSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	SetStartEndTime(iCurveInfo.mtStartTime, iCurveInfo.mtEndTime);
	SetStartEndValue(iCurveInfo.fltStartValue, iCurveInfo.fltEndValue);
	
	m_dwCurveType = iCurveInfo.dwCurveType;
	m_dwFlags = iCurveInfo.dwFlags;

	m_pTrackMgr->ClocksToMeasureBeatTick( m_mtStartTime, &m_lMeasure, &m_lBeat, &m_lTick );

ON_ERROR:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SaveTrackItem

HRESULT CTrackItem::SaveTrackItem( IStream* pIStream )
{
	if( pIStream == NULL )
	{
		ASSERT( 0 );
		return E_FAIL;
	}

	// Clear out the structure (clears out the padding bytes as well).
	DMUS_IO_PARAMCONTROLTRACK_CURVEINFO oCurveInfo;
	ZeroMemory( &oCurveInfo, sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO) );

	// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_CURVEINFO structure
	oCurveInfo.mtStartTime = m_mtStartTime;
	oCurveInfo.mtEndTime = m_mtEndTime;
	oCurveInfo.fltStartValue = m_fltStartValue;
	oCurveInfo.fltEndValue = m_fltEndValue;
	oCurveInfo.dwCurveType = m_dwCurveType;
	oCurveInfo.dwFlags = m_dwFlags;

	// Write the structure out to the stream
	DWORD dwBytesWritten;
	HRESULT hr = pIStream->Write( &oCurveInfo, sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO) )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackItem::ComputeCurve

float CTrackItem::ComputeCurve( MUSIC_TIME* pmtIncrement )
{
	float fltRet = 0;
	
	IDMUSProdTimeline* pITimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pITimeline);
	if(pITimeline == NULL)
	{
		return 0;
	}

	MUSIC_TIME mtTimeChange = m_mtEndTime - m_mtStartTime;
	MUSIC_TIME mtTimeIntermediate = m_mtCurrent;

	// Horizontal distance along curve between 0 and 1
	float fltScalingX = static_cast<float>(mtTimeIntermediate) / mtTimeChange; 
	// Height of curve at that point between 0 and 1 based on curve f
	float fltScalingY = 0; 

	switch( m_dwCurveType )
	{
		case MP_CURVE_LINEAR:
		{
			fltScalingY = fltScalingX;
			break;
		}

		case MP_CURVE_SQUARE:
		{
			fltScalingY = fltScalingX * fltScalingX;
			break;
		}

		case MP_CURVE_INVSQUARE:
		{
			fltScalingY = (float) sqrt(fltScalingX);
			break;
		}

		case MP_CURVE_SINE:
		{
			fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
			break;
		}

		case MP_CURVE_JUMP:
		default:
		{
			fltRet = m_fltEndValue;
			return fltRet;
		}
	}

	fltRet = (m_fltEndValue - m_fltStartValue) * fltScalingY + m_fltStartValue;

	return fltRet;
}

/////////////////////////////////////////////////////////////////////////////
// CTrackItem::SwitchTimeBase

void CTrackItem::SwitchTimeBase( void )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	if( m_pTrackMgr->IsRefTimeTrack() )
	{
		// Switching from MUSIC_TIME to REFERENCE_TIME
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( (MUSIC_TIME)m_rtTimePhysical, &m_rtTimePhysical );
		m_pTrackMgr->m_pTimeline->ClocksToRefTime( m_rtDuration, &m_rtDuration );
	}
	else
	{
		// Switching from REFERENCE_TIME to MUSIC_TIME
		MUSIC_TIME mtTime;
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( m_rtTimePhysical, &mtTime );
		m_rtTimePhysical = mtTime;
		m_pTrackMgr->m_pTimeline->RefTimeToClocks( m_rtDuration, &mtTime );
		m_mtDuration = mtTime;
        m_rtDuration = mtTime;
	}
}

void CTrackItem::SetStartEndValue(float fltStart, float fltEnd)
{
	ASSERT(m_pParamStrip);

	// Check for the type for the values
	if(m_pParamStrip->m_ParamInfo.mpType != MPT_FLOAT)
	{
		if(fltStart < 0)
		{
			fltStart = (int)(fltStart - 0.5);
		}
		else
		{
			fltStart = (int)(fltStart + 0.5);
		}

		if(fltEnd < 0)
		{
			fltEnd = (int)(fltEnd - 0.5);
		}
		else
		{
			fltEnd = (int)(fltEnd + 0.5);
		}
	}

	m_fltStartValue = fltStart;
	m_fltEndValue = fltEnd;
}


void CTrackItem::GetStartEndValue(float& fltStart, float& fltEnd)
{
	fltStart = m_fltStartValue;
	fltEnd = m_fltEndValue;
}


void CTrackItem::SetPhysicalTime(REFERENCE_TIME rtTimePhysical, REFERENCE_TIME rtDuration)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	REFERENCE_TIME rtTemp = rtTimePhysical;

	MUSIC_TIME mtStartTime = 0;
	m_pTrackMgr->UnknownTimeToClocks(rtTemp, &mtStartTime);

	rtTemp = rtDuration;
	MUSIC_TIME mtDuration = 0;
	m_pTrackMgr->UnknownTimeToClocks(rtTemp, &mtDuration);

	MUSIC_TIME mtEndTime = mtStartTime + mtDuration;

	m_mtStartTime = mtStartTime;
	m_mtEndTime = mtEndTime;
	m_mtDuration = mtDuration;
	m_rtTimePhysical = rtTimePhysical;
	m_rtDuration = rtDuration;

	m_pTrackMgr->ClocksToMeasureBeatTick(m_mtStartTime, &m_lMeasure, &m_lBeat, &m_lTick);
}

void CTrackItem::SetStartEndTime(MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	m_mtStartTime = mtStart;
	m_mtEndTime = mtEnd;

	UpdateTimeFieldsFromMeasureBeatTick();
}


void CTrackItem::UpdateTimeFieldsFromMeasureBeatTick()
{
	m_pTrackMgr->ClocksToMeasureBeatTick(m_mtStartTime, &m_lMeasure, &m_lBeat, &m_lTick);
	m_pTrackMgr->ClocksToUnknownTime(m_mtStartTime, &m_rtTimePhysical);

	m_mtDuration = m_mtEndTime - m_mtStartTime;
	m_pTrackMgr->ClocksToUnknownTime(m_mtDuration, &m_rtDuration);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackMgr.cpp ===
// TrackMgr.cpp : implementation file
//

#include "stdafx.h"
#include <RiffStrm.h>
#include "TrackMgr.h"
#include "newparameterdialog.h"
#include "GroupBitsPPG.h"
#include "TabObject.h"
#include "SegmentDesigner.h"
#include "SegmentIO.h"
#include "PChannelName.h"
#include "ParamStrip.h"
#include <dmusicf.h>
#include <dmusici.h>
#include "TrackFlagsPPG.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Set information about this strip manager
const CLSID CTrackMgr::m_clsid = CLSID_DirectMusicParamControlTrack;
const DWORD CTrackMgr::m_ckid = NULL;
const DWORD CTrackMgr::m_fccType = DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST;

const DWORD g_dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
const DWORD g_dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr constructor/destructor 

CTrackMgr::CTrackMgr() : CBaseMgr()
{
	m_pParamStripForPropSheet = NULL;
	m_pIDMPerformance = NULL;

	CTrackObject* pTrackObject = new CTrackObject(this);
	ASSERT(pTrackObject);
	if(pTrackObject)
	{
		m_lstTrackObjects.AddTail(pTrackObject);
	}

	m_dwTrackExtrasFlags = PARAMTRACK_DEFAULT & TRACKCONFIG_VALID_MASK;
}

CTrackMgr::~CTrackMgr()
{
	// Release all the items in m_lstTrackObjects
	while( !m_lstTrackObjects.IsEmpty() )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.RemoveHead();
		delete pTrackObject;
	}

	if( m_pIDMPerformance )
	{
		RELEASE( m_pIDMPerformance );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr ITrackMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsMeasureBeatOpen
// Returns S_OK if the specified measure and beat is empty.
// Returns S_FALSE if the specified measure and beat already has an item

HRESULT STDMETHODCALLTYPE CTrackMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( 0 );
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTrackMgr::OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Update the m_mtTime value of all items
		if( AllObjects_RecomputeTimes() )
		{
			OnDataChanged();
		}

		// Redraw all strips
		AllObjects_Invalidate();
		return S_OK;
	}

	// Tempo change
	if( ::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		// Redraw all strips
		AllObjects_Invalidate();
		return S_OK;
	}

	if(::IsEqualGUID(rguidType, GUID_Conductor_OutputPortsChanged))
	{
		// Redraw all strips
		AllObjects_RemoveAllStripsFromTimeline();
		AllObjects_RefreshInfo();
		AllObjects_Invalidate();

		// This notification also comes in when we're shutting down
		if(m_pTimeline)
		{
			AllObjects_AddAllStripsToTimeline();
		}
		return S_OK;

	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all track items
		AllObjects_RecomputeMeasureBeats();

		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose Wave from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}

		// Ask all the objects to update their info
		AllObjects_RefreshInfo();	

		// Redraw all strips
		AllObjects_Invalidate();
		return S_OK;
	}

	// Deleted Track
	if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		DeleteAllObjects();
		return S_OK;
	}

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		AllObjects_OnUpdate( rguidType, dwGroupBits, pData );
		return S_OK;
	}

	if( ::IsEqualGUID( rguidType, GUID_TimelineSetSnapTo )
	&&	(pData != NULL) )
	{
		// Convert from the Timeline SNAP_TO setting to our own SNAP_TO settings
		WORD wSnapVal;
		DMUSPROD_TIMELINE_SNAP_TO *ptlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO *)pData;

		switch( *ptlSnapTo )
		{
		case DMUSPROD_TIMELINE_SNAP_NONE:
			wSnapVal = IDM_SNAP_NONE;
			break;
		case DMUSPROD_TIMELINE_SNAP_GRID:
			wSnapVal = IDM_SNAP_GRID;
			break;
		case DMUSPROD_TIMELINE_SNAP_BEAT:
			wSnapVal = IDM_SNAP_BEAT;
			break;
		case DMUSPROD_TIMELINE_SNAP_BAR:
			wSnapVal = IDM_SNAP_BAR;
			break;
		default:
			ASSERT(FALSE);
			wSnapVal = IDM_SNAP_GRID;
			break;
		}

		// Update all the strips with the new snap-to setting
		POSITION pos = m_lstTrackObjects.GetHeadPosition();
		while( pos )
		{
			CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

			POSITION posTrack = pTrackObject->m_lstParamStrips.GetHeadPosition();
			while( posTrack )
			{
				CParamStrip* pParamStrip = pTrackObject->m_lstParamStrips.GetNext( posTrack );

				pParamStrip->m_StripUI.m_nSnapToMusicTime = wSnapVal;

				// If switching to none or grid, update the reftime snap-to setting also
				if( (wSnapVal == IDM_SNAP_NONE)
				||	(wSnapVal == IDM_SNAP_GRID) )
				{
					pParamStrip->m_StripUI.m_nSnapToRefTime = wSnapVal;
				}
			}
		}
	}

	// We don't handle whichever notification was passed to us
	return CBaseMgr::OnUpdate( rguidType, dwGroupBits, pData );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTrackMgr::SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
		case SMP_ITIMELINECTL:
		{
			// Check that the caller passed in an IUnknown pointer
			if( variant.vt != VT_UNKNOWN )
			{
				return E_INVALIDARG;
			}

			// If we were previously attached to a timeline
			if( m_pTimeline )
			{
				// Make sure our property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

				// Release our reference on our property page manager
				RELEASE( m_pPropPageMgr );

				// Remove our strips from the Timeline
				AllObjects_RemoveAllStripsFromTimeline();

				// Remove ourself from the Timeline's notification list
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Conductor_OutputPortsChanged, m_dwOldGroupBits );
				m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Conductor_OutputPortsRemoved, m_dwOldGroupBits );

				// Release our reference on the Timeline
				RELEASE( m_pTimeline );
			}

			// If a non-NULL pointer was passed in
			if( V_UNKNOWN( &variant ) )
			{
				// Query the pointer for a Timeline interface
				if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
				{
					return E_FAIL;
				}
				else
				{
					// Add our strips to the timeline
					AllObjects_AddAllStripsToTimeline();

					// Add ourself to the Timeline's notification list
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TempoParam, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimelineSetSnapTo, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Conductor_OutputPortsChanged, m_dwGroupBits );
					m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Conductor_OutputPortsRemoved, m_dwGroupBits );
				}
			}
			return S_OK;
		}
		case SMP_DMUSIOTRACKEXTRASHEADER:
		{
			if( variant.vt != VT_BYREF )
			{
				return E_INVALIDARG;
			}
			else
			{
				DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
				if( pioTrackExtrasHeader == NULL )
				{
					return E_POINTER;
				}

				m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
			}
			return S_OK;
		}
	}

	// Let CBaseMgr handle
	return CBaseMgr::SetStripMgrProperty( stripMgrProperty, variant );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Load

HRESULT CTrackMgr::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Verify that the stream pointer is non-null
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	// Try and allocate a RIFF stream
	if(FAILED(hr = AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return hr;
	}

	// Delete all the items in m_lstTrackObjects
	while(!m_lstTrackObjects.IsEmpty())
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.RemoveHead();
		delete pTrackObject;
	}

	// Variables used when loading the Wave track
	MMCKINFO ckTrack;
	MMCKINFO ckList;

	// Interate through every chunk in the stream
	while(pIRiffStream->Descend(&ckTrack, NULL, 0) == 0)
	{
		switch(ckTrack.ckid)
		{
			case FOURCC_LIST:
			{
				switch(ckTrack.fccType)
				{
					case DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST:
					{
						while(pIRiffStream->Descend(&ckList, &ckTrack, 0) == 0)
						{
							switch(ckList.ckid)
							{
								case FOURCC_LIST:
								{
									switch(ckList.fccType)
									{
										case DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST:
										{
											CTrackObject* pNewTrackObject = new CTrackObject(this);
											if(pNewTrackObject == NULL)
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}
											hr = pNewTrackObject->LoadObject(pIRiffStream, &ckList);
											if( FAILED ( hr ) )
											{
												delete pNewTrackObject;
												goto ON_ERROR;
											}
											InsertInAlphabeticalOrder(&m_lstTrackObjects, pNewTrackObject );
											break;
										}
									}
									break;
								}
							}

							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
					}
				}
				break;
			}
		}

		pIRiffStream->Ascend( &ckTrack, 0 );
	}

	// If we're here without errors and there are jo objects then this must be an empty track?
	if(m_lstTrackObjects.IsEmpty())
	{
		CTrackObject* pTrackObject = new CTrackObject(this);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			m_lstTrackObjects.AddTail(pTrackObject);
		}
	}

	SyncWithDirectMusic();

ON_ERROR:
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::Save

HRESULT CTrackMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Verify that the stream pointer is non-null
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a DirectMusic stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusic parameter control track (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )
	&&	!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Allocate an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Create a LIST chunk to store the track data
	MMCKINFO ckTrack;
 	ckTrack.fccType = DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST;
	if( pIRiffStream->CreateChunk( &ckTrack, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the LIST chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}


	// Save all objects in the parameter control track
	if( !m_lstTrackObjects.IsEmpty() )
	{
		// Iterate through the object list
		POSITION pos = m_lstTrackObjects.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

			// Save each object
			hr = pTrackObject->SaveObject( pIRiffStream );
			if(FAILED(hr))
			{
				goto ON_ERROR;
			}
		}
	}

	pIRiffStream->Ascend( &ckTrack, 0 );

	// If we're supposed to clear our dirty flag, do so now (since the save succeeded)
	if( fClearDirty )
	{
		m_fDirty = false;
	}

ON_ERROR:
	// Release our pointer to the IDMUSProdRIFFStream
	pIRiffStream->Release();

	// Return the success/failure code
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetData

HRESULT STDMETHODCALLTYPE CTrackMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	if( m_pParamStripForPropSheet == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Group Bits tab
		case 0:
		{
			ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(*ppData);

			pioGroupBitsPPG->dwGroupBits = m_dwGroupBits;
			break;
		}

		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
			pPPGTrackFlagsParams->dwTrackExtrasFlags = m_dwTrackExtrasFlags;
			pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
			pPPGTrackFlagsParams->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
			pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
			break;
		}
		// Object tab
		case 2:
		{
			ioObjectPPG *pioObjectPPG = static_cast<ioObjectPPG *>(*ppData);
			
			CTrackObject* pTrackObject = m_pParamStripForPropSheet->GetTrackObject();
			ASSERT(pTrackObject);
			if(pTrackObject)
			{
				pTrackObject->RefreshObjectProperties();
				pioObjectPPG->strStageName = pTrackObject->m_sStageName;
				pioObjectPPG->strObjectName = pTrackObject->m_sObjectName;
				pioObjectPPG->dwPChannel = pTrackObject->m_dwPChannel;
				pioObjectPPG->strPChannelText = pTrackObject->m_sPChannelText;
				pioObjectPPG->dwParamFlagsDM = m_pParamStripForPropSheet->GetDMParamFlags();
				pioObjectPPG->strStripName = m_pParamStripForPropSheet->GetName();
				GetPChannelName(pTrackObject->m_dwPChannel, pioObjectPPG->strPChannelName );
			}
			break;
		}

		default:
			ASSERT(FALSE);
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetData

HRESULT STDMETHODCALLTYPE CTrackMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pParamStripForPropSheet == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Group bits
		case 0:
		{
			ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(pData);

			// m_dwGroupBits
			if( pioGroupBitsPPG->dwGroupBits != m_dwGroupBits )
			{
				m_nLastEdit = IDS_UNDO_TRACK_GROUP;
				m_dwGroupBits = pioGroupBitsPPG->dwGroupBits;
				OnUpdate( GUID_TimeSignature, m_dwGroupBits, NULL );
				OnDataChanged();
				m_dwOldGroupBits = pioGroupBitsPPG->dwGroupBits;
			}

			break;
		}

		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);
			if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_dwTrackExtrasFlags )
			{
				m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
				bool fWasRefTimeTrack = IsRefTimeTrack();
				m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
				bool fIsRefTimeTrack = IsRefTimeTrack();

				if( fWasRefTimeTrack != fIsRefTimeTrack )
				{
					AllObjects_SwitchTimeBase();
				}

				OnDataChanged();
				AllObjects_Invalidate();
			}
			else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_dwProducerOnlyFlags )
			{
				m_nLastEdit = IDS_UNDO_PRODUCERONLY;
				m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
				OnDataChanged();
			}
			return S_OK;
			break;
		}

		// Object tab
		case 2:
		{
			ioObjectPPG *pioObjectPPG = static_cast<ioObjectPPG *>(pData);

			CTrackObject* pTrackObject = m_pParamStripForPropSheet->GetTrackObject();
			ASSERT(pTrackObject);
			if(pTrackObject == NULL)
			{
				return E_UNEXPECTED;
			}

			// m_pParamStripForPropSheet->m_dwPChannel
			if( pioObjectPPG->dwPChannel != pTrackObject->m_dwPChannel )
			{
				m_nLastEdit = IDS_UNDO_OBJECT_PCHANNEL;
				pTrackObject->m_dwPChannel = pioObjectPPG->dwPChannel;
				OnDataChanged();
				m_pTimeline->StripInvalidateRect( m_pParamStripForPropSheet, NULL, FALSE );
			}

			// m_pParamStripForPropSheet->m_dwParamFlagsDM
			else if( pioObjectPPG->dwParamFlagsDM != m_pParamStripForPropSheet->GetDMParamFlags())
			{
				m_nLastEdit = IDS_UNDO_OBJECT_FLAGS;
				m_pParamStripForPropSheet->SetDMParamFlags(pioObjectPPG->dwParamFlagsDM);
				OnDataChanged();
			}

			// m_pParamStripForPropSheet->m_strStripName
			else if( pioObjectPPG->strStripName != m_pParamStripForPropSheet->GetName())
			{
				m_nLastEdit = IDS_UNDO_OBJECT_NAME;
				m_pParamStripForPropSheet->SetName(pioObjectPPG->strStripName);
				OnDataChanged();
				m_pTimeline->StripInvalidateRect( m_pParamStripForPropSheet, NULL, FALSE );
			}

			// m_pParamStripForPropSheet's PChannel name
			else if( m_pDMProdFramework )
			{
				IDMUSProdProject* pIProject;
				if( SUCCEEDED ( m_pDMProdFramework->FindProject( m_pIDocRootNode, &pIProject ) ) ) 
				{
					IDMUSProdPChannelName* pIPChannelName;
					if( SUCCEEDED( pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
					{
						WCHAR wstrText[MAX_PATH];
						if( SUCCEEDED ( pIPChannelName->GetPChannelName( pTrackObject->m_dwPChannel, wstrText ) ) )
						{
							CString strPChName = wstrText;
							if( strPChName.Compare( pioObjectPPG->strPChannelName ) != 0 )
							{
								MultiByteToWideChar( CP_ACP, 0, pioObjectPPG->strPChannelName, -1, wstrText, MAX_PATH );
								pIPChannelName->SetPChannelName( pTrackObject->m_dwPChannel, wstrText );

								// This doesn't affect anything in the segment - just the PChannel names
								// in the Producer project file.
							}
						}
					
						RELEASE( pIPChannelName );
					}

					RELEASE( pIProject );
				}
			}

			break;
		}

		default:
			ASSERT(FALSE);
			break;
	}

	// Sync track with DirectMusic
	SyncWithDirectMusic();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTrackMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pointers
	if( m_pTimeline == NULL
	||  m_pDMProdFramework == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, refresh and exit
	if( pIPropSheet->IsEqualPageManagerObject( (IDMUSProdPropPageObject*)this ) == S_OK )
	{
		ASSERT( m_pPropPageMgr != NULL );
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
		pIPropSheet->Release();
		return S_OK;
	}

	// release our reference to the property sheet
	pIPropSheet->Release();

	// Check if our property page manager exists yet
	if( m_pPropPageMgr == NULL )
	{
		// Nope, need to create it
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr( m_pDMProdFramework, this );

		// Check if the creation succeeded.
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Set m_pPropPageMgr with a reference to the IDMUSProdPropPageManager interface
		HRESULT hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );

		// Release our original reference on the property page manager (added when it
		// was created).
		m_pPropPageMgr->Release();

		// If the QueryInterface failed, return.
		if( FAILED(hr) )
		{
			// Nothing to release, since no reference was added by the call to QueryInterface.
			return hr;
		}
	}

	// Store the last active tab
	short nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;

	// Set the property page to refer to the group bits property page.
	m_pTimeline->SetPropertyPage( m_pPropPageMgr, (IDMUSProdPropPageObject*)this );

	// Set the active tab
	if( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		CWnd* pWndHadFocus = CWnd::GetFocus();

		pIPropSheet->SetActivePage( nActiveTab ); 
		RELEASE( pIPropSheet );

		if( pWndHadFocus )
		{
			pWndHadFocus->SetFocus();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::OnRemoveFromPageManager

HRESULT CTrackMgr::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Clear our property page manager
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject( NULL );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr implementation


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SyncWithDirectMusic

HRESULT CTrackMgr::SyncWithDirectMusic( void )
{
	// If there is no DirectMusic Track, return S_FALSE
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	if( m_pIDMPerformance == NULL )
	{
		// Get IDirectMusicPerformance interface pointers 
		if( m_pDMProdFramework )
		{
			IDMUSProdComponent* pIComponent;
			if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ) )
			{
				IDMUSProdConductor* pIConductor;
				if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
				{
					if( FAILED ( pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
					{
						m_pIDMPerformance = NULL;
					}

					RELEASE( pIConductor );
				}

				RELEASE( pIComponent );
			}
		}

		if( m_pIDMPerformance == NULL )
		{
			ASSERT( 0 );
			return E_FAIL;
		}
	}

	// Hand DirectMusic new parameter control track
	return CBaseMgr::SyncWithDirectMusic();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RecomputeTimes

// Return true if anything changed
bool CTrackMgr::RecomputeTimes( void )
{
	return AllObjects_RecomputeTimes();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::SetDirtyFlag

void CTrackMgr::SetDirtyFlag( bool fDirty )
{
	m_fDirty = fDirty;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::InsertByAscendingPChannel

void CTrackMgr::InsertByAscendingPChannel( CTrackObject *pTrackObjectToInsert )
{
	// Ensure the pTrackObjectToInsert pointer is valid
	if ( pTrackObjectToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CTrackObject *pTrackObject;
	POSITION posCurrent, posNext = m_lstTrackObjects.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pTrackObject = m_lstTrackObjects.GetNext( posNext );

		if( pTrackObject->m_dwPChannel > pTrackObjectToInsert->m_dwPChannel )
		{
			// insert before posCurrent (which is the position of pTrackObject)
			m_lstTrackObjects.InsertBefore( posCurrent, pTrackObjectToInsert );
			return;
		}
	}

	// pTrackObjectToInsert has higher PChannel than all items in the list
	// add it at the end of the list
	m_lstTrackObjects.AddTail( pTrackObjectToInsert );
	return;
}

void CTrackMgr::InsertInAlphabeticalOrder(CPtrList* plstObjects, CTrackObject* pTrackObject)
{
	ASSERT(plstObjects);
	if(plstObjects == NULL)
	{
		return;
	}

	ASSERT(pTrackObject);
	if(pTrackObject == NULL)
	{
		return;
	}
	
	POSITION position = plstObjects->GetHeadPosition();
	while(position)
	{
		POSITION insertPosition = position;
		CTrackObject* pObjectInList = (CTrackObject*) plstObjects->GetNext(position);
		ASSERT(pObjectInList);
		if(pObjectInList)
		{
			if(CompareObjectAlphabetical(pTrackObject, pObjectInList) <= 0)
			{
				plstObjects->InsertBefore(insertPosition, pTrackObject);
				return;
			}
		}
	}

	// This will go to the end of the list
	plstObjects->AddTail(pTrackObject);
}

CPtrList* CTrackMgr::SortListAlphabetically(CPtrList* plstObjects)
{
	ASSERT(plstObjects);
	if(plstObjects == NULL)
	{
		return NULL;
	}

	CPtrList* pSorted = new CPtrList();
	POSITION position = plstObjects->GetHeadPosition();
	while(position)
	{
		CTrackObject* pTrackObject = (CTrackObject*)plstObjects->GetNext(position);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			InsertInAlphabeticalOrder(pSorted, pTrackObject);
		}
	}
	
	return pSorted;
}


int CTrackMgr::CompareObjectAlphabetical(CTrackObject* pTrackObject1, CTrackObject* pTrackObject2)
{
	ASSERT(pTrackObject1);
	if(pTrackObject1 == NULL)
	{
		return -1;
	}

	ASSERT(pTrackObject2);
	if(pTrackObject2 == NULL)
	{
		return -1;
	}

	CString sName1 = pTrackObject1->GetName();
	CString sName2 = pTrackObject2->GetName();

	return sName1.CompareNoCase(sName2);
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToMeasureBeatTick

HRESULT CTrackMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime,
											long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatTickToClocks

HRESULT CTrackMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick,
											MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


HRESULT CTrackMgr::AddNewObject()
{
	// Throw up a dialog that gets the stage, object and the parameter for the new strip
	CNewParameterDialog dlgParam(this);
	if(dlgParam.DoModal() == IDOK)
	{
		// Collect all the information from the dialog
		StripInfo newStripInfo;
		newStripInfo = dlgParam.m_StripInfo;

		CTrackObject* pTrackObject = NULL;
		POSITION pos = m_lstTrackObjects.GetHeadPosition();
		while(pos)
		{
			pTrackObject = (CTrackObject*)m_lstTrackObjects.GetNext(pos);
			if(pTrackObject->IsEqualObject(&newStripInfo) == TRUE)
			{
				break;
			}

			pTrackObject = NULL;
		}

		if(pTrackObject == NULL && m_lstTrackObjects.GetCount() == 1)
		{
			CTrackObject* pObject = (CTrackObject*)m_lstTrackObjects.GetHead();
			ASSERT(pObject);
			if(pObject && pObject->IsEmptyTrackObject() == TRUE)
			{
				pTrackObject = pObject;
			}

		}

		bool bNewObject = false;
		if(pTrackObject == NULL)
		{
			pTrackObject = new CTrackObject(this);
			ASSERT(pTrackObject);
			if(pTrackObject == NULL)
			{
				return E_OUTOFMEMORY;
			}
			
			bNewObject = true;
		}

		HRESULT hr = AddNewObject(pTrackObject, &newStripInfo);
		if(FAILED(hr))
		{
			if(bNewObject)
			{
				delete pTrackObject;
			}
			return hr;
		}


		if(bNewObject)
		{
			InsertInAlphabeticalOrder(&m_lstTrackObjects, pTrackObject);
		}
	
		return S_OK;

	}
	
	return E_FAIL;
}


HRESULT CTrackMgr::AddNewObject(CTrackObject* pTrackObject, StripInfo* pStripInfo)
{
	ASSERT(pTrackObject);
	if(pTrackObject == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pStripInfo);
	if(pStripInfo == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = pTrackObject->AddStrip(pStripInfo);
	return hr;

}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetPChannelName

HRESULT CTrackMgr::GetPChannelName( DWORD dwPChannel, CString& strPChannelName )
{
	HRESULT hr = E_FAIL;

	strPChannelName.Empty();

	if( m_pDMProdFramework )
	{
		IDMUSProdProject* pIProject;
		if( SUCCEEDED ( m_pDMProdFramework->FindProject( m_pIDocRootNode, &pIProject ) ) ) 
		{
			IDMUSProdPChannelName* pIPChannelName;
			if( SUCCEEDED( pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
			{
				WCHAR wstrText[MAX_PATH];
				if( SUCCEEDED ( pIPChannelName->GetPChannelName( dwPChannel, wstrText ) ) )
				{
					strPChannelName = wstrText;
					hr = S_OK;
				}
			
				RELEASE( pIPChannelName );
			}

			RELEASE( pIProject );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::PChannelExists

bool CTrackMgr::PChannelExists( DWORD dwPChannel )
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		if( pTrackObject->m_dwPChannel == dwPChannel )
		{
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetGreatestUsedPChannel

DWORD CTrackMgr::GetGreatestUsedPChannel( void )
{
	DWORD dwPChannel = 0;

	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		dwPChannel = max( dwPChannel, pTrackObject->m_dwPChannel );
	}

	return dwPChannel;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_OnUpdate

void CTrackMgr::AllObjects_OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		pTrackObject->AllStrips_OnUpdate( rguidType, dwGroupBits, pData );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_Invalidate

void CTrackMgr::AllObjects_RefreshInfo()
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			pTrackObject->RefreshObjectProperties();
		}
	}

	// Sort the track objects list by names
	CPtrList* plstSorted = SortListAlphabetically(&m_lstTrackObjects);
	if(plstSorted)
	{
		while(!m_lstTrackObjects.IsEmpty())
		{
			m_lstTrackObjects.RemoveHead();
		}

		while(!plstSorted->IsEmpty())
		{
			CTrackObject* pTrackObject = (CTrackObject*)plstSorted->RemoveHead();
			ASSERT(pTrackObject);
			if(pTrackObject)
			{
				m_lstTrackObjects.AddTail(pTrackObject);
			}
		}

		delete plstSorted;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_Invalidate

void CTrackMgr::AllObjects_Invalidate( void )
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		pTrackObject->AllStrips_Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_AddAllStripsToTimeline

void CTrackMgr::AllObjects_AddAllStripsToTimeline( void )
{

	POSITION positionObject = m_lstTrackObjects.GetHeadPosition();
	while(positionObject)
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext(positionObject);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			pTrackObject->AllStrips_AddToTimeline();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_RecomputeMeasureBeats

void CTrackMgr::AllObjects_RecomputeMeasureBeats()
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		pTrackObject->AllStrips_RecomputeMeasureBeats();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllObjects_RecomputeTimes

bool CTrackMgr::AllObjects_RecomputeTimes()
{
	bool fChanged = FALSE;

	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while( pos )
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext( pos );

		fChanged |= pTrackObject->AllStrips_RecomputeTimes();
	}

	return fChanged;
}


void CTrackMgr::AllObjects_RemoveAllStripsFromTimeline()
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while(pos)
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext(pos);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			pTrackObject->AllStrips_RemoveFromTimeline();
		}
	}
}


void CTrackMgr::AllObjects_SwitchTimeBase()
{
	POSITION position = m_lstTrackObjects.GetHeadPosition();
	while(position)
	{
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext(position);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			pTrackObject->AllStrips_SwitchTimeBase();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteAllObjects

void CTrackMgr::DeleteAllObjects()
{
	POSITION pos = m_lstTrackObjects.GetHeadPosition();
	while(!m_lstTrackObjects.IsEmpty())
	{
		CTrackObject* pTrackObject = (CTrackObject*)m_lstTrackObjects.RemoveHead();
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			DeleteAllStripsInObject(pTrackObject);
			delete pTrackObject;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::DeleteSelectedStripsFromObjects

void CTrackMgr::DeleteSelectedStripsFromObjects()
{
	POSITION position = m_lstTrackObjects.GetHeadPosition();
	while(position)
	{
		POSITION objectPos = position;
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext(position);
		ASSERT(pTrackObject);
		if(pTrackObject && pTrackObject->IsEmptyTrackObject() == FALSE)
		{
			pTrackObject->DeleteAllSelectedStrips();
		}
	}

	position = m_lstTrackObjects.GetHeadPosition();
	while(position)
	{
		POSITION removePosition = position;
		CTrackObject* pTrackObject = m_lstTrackObjects.GetNext(position);
		ASSERT(pTrackObject);
		if(pTrackObject && pTrackObject->GetNumberOfStrips() == 0)
		{
			m_lstTrackObjects.RemoveAt(removePosition);
			delete pTrackObject;
		}
	}

	if(m_lstTrackObjects.IsEmpty())
	{
		CTrackObject* pTrackObject = new CTrackObject(this);
		ASSERT(pTrackObject);
		if(pTrackObject)
		{
			m_lstTrackObjects.AddTail(pTrackObject);
			pTrackObject->AllStrips_AddToTimeline();
		}
	}

	// Save the undo state
	//SetLastEdit(IDS_UNDO_DELETE_PARAM);
	//TrackDataChanged();
	NotifyDataChange(IDS_UNDO_DELETE_PARAM);

	if(m_lstTrackObjects.IsEmpty())
	{
		IDMUSProdSegmentEdit8* pISegmentEdit8 = GetSegment();
		ASSERT(pISegmentEdit8);
		if(pISegmentEdit8 == NULL)
		{
			return;
		}

		pISegmentEdit8->RemoveStripMgr((IDMUSProdStripMgr *)this);
		RELEASE(pISegmentEdit8);
	}

}

HRESULT CTrackMgr::DeleteAllStripsInObject(CTrackObject* pTrackObject)
{
	ASSERT(pTrackObject);
	if(pTrackObject == NULL)
	{
		return E_POINTER;
	}

	if(FAILED(pTrackObject->DeleteAllStrips()))
	{
		return E_FAIL;
	}

	if(m_lstTrackObjects.IsEmpty())
	{
		IDMUSProdSegmentEdit8* pISegmentEdit8 = GetSegment();
		ASSERT(pISegmentEdit8);
		if(pISegmentEdit8 == NULL)
		{
			return E_UNEXPECTED;
		}

		pISegmentEdit8->RemoveStripMgr((IDMUSProdStripMgr *)this);
		RELEASE(pISegmentEdit8);
		return S_OK;		// Call to RemoveStripMgr should have deleted us!
	}
	else
	{
		// Update Undo queue
		m_nLastEdit = IDS_UNDO_DELETE_PART;
		OnDataChanged();
	}


	return S_OK;
}

IDMUSProdFramework* CTrackMgr::GetFramework()
{
	return m_pDMProdFramework;
}

IDMUSProdConductor* CTrackMgr::GetConductor()
{
	if( m_pDMProdFramework )
	{
		IDMUSProdComponent* pIComponent = NULL;
		if(SUCCEEDED(m_pDMProdFramework->FindComponent(CLSID_CConductor,  &pIComponent)))
		{
			IDMUSProdConductor* pIConductor = NULL;
			if(SUCCEEDED(pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor)))
			{
				RELEASE(pIComponent);
				return pIConductor;

			}

			RELEASE(pIComponent);
		}
	}

	return NULL;
}


IDMUSProdTimeline* CTrackMgr::GetTimeline()
{
	return m_pTimeline;
}

CParamStrip* CTrackMgr::GetParamStripForPropSheet()
{
	return m_pParamStripForPropSheet;
}

void CTrackMgr::RemoveFromPropSheet(CParamStrip* pParamStrip)
{
	ASSERT(pParamStrip);
	if(pParamStrip == NULL)
	{
		return;
	}

	if(pParamStrip == m_pParamStripForPropSheet)
	{
		m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
		RELEASE(m_pPropPageMgr);
	}
}

CLSID CTrackMgr::GetCLSID()
{
	return m_clsid;
}

DWORD CTrackMgr::GetGroupBits()
{
	return m_dwGroupBits;
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::IsRefTimeTrack

bool CTrackMgr::IsRefTimeTrack()
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}


IDMUSProdSegmentEdit8* CTrackMgr::GetSegment()
{
	ASSERT(m_pIDocRootNode != NULL);
	if(m_pIDocRootNode)
	{
		IDMUSProdSegmentEdit8* pISegmentEdit8 = NULL;
		if(SUCCEEDED(m_pIDocRootNode->QueryInterface(IID_IDMUSProdSegmentEdit8, (void **)&pISegmentEdit8)))
		{
			return pISegmentEdit8;		
		}
	}

	return NULL;
}



/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToMinSecGridMs

HRESULT	CTrackMgr::RefTimeToMinSecGridMs( CParamStrip* pParamStrip,
										  REFERENCE_TIME rtTime,
										  long* plMinute, long* plSecond, long* plGrid, long* plMillisecond )
{
	ASSERT( pParamStrip != NULL );
	ASSERT( plMinute != NULL );
	ASSERT( plSecond != NULL );
	ASSERT( plGrid != NULL );
	ASSERT( plMillisecond != NULL );

	REFERENCE_TIME rtRefClocksPerGrid = REFCLOCKS_PER_SECOND / pParamStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	*plMinute = (long)(rtTime / REFCLOCKS_PER_MINUTE);
	rtTime = rtTime % REFCLOCKS_PER_MINUTE;

	*plSecond = (long)(rtTime / REFCLOCKS_PER_SECOND);
	rtTime = rtTime % REFCLOCKS_PER_SECOND;

	*plGrid = (long)(rtTime / rtRefClocksPerGrid);
	rtTime = rtTime % rtRefClocksPerGrid;

	*plMillisecond = (long)(rtTime / REFCLOCKS_PER_MILLISECOND);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MinSecGridMsToRefTime

HRESULT	CTrackMgr::MinSecGridMsToRefTime( CParamStrip* pParamStrip,
										  long lMinute, long lSecond, long lGrid, long lMillisecond,
										  REFERENCE_TIME* prtTime )
{
	ASSERT( pParamStrip != NULL );
	ASSERT( prtTime != NULL );

	REFERENCE_TIME rtRefClocksPerGrid = REFCLOCKS_PER_SECOND / pParamStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond;

	*prtTime =  lMinute * REFCLOCKS_PER_MINUTE;
	*prtTime += lSecond * REFCLOCKS_PER_SECOND;
	*prtTime += lGrid * rtRefClocksPerGrid;
	*prtTime += lMillisecond * REFCLOCKS_PER_MILLISECOND;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToMeasureBeatGridTick

HRESULT	CTrackMgr::ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plGrid != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lGrid = -1;
	long lTick = -1;
	long lGridsAndTicks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lGrid = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lGridsAndTicks = mtTime - lClocks;

					// Get the TimeSig for this measure/beat
					DMUS_TIMESIGNATURE ts;
					if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lClocks, NULL, &ts ) ) )
					{
						// Compute the grid and tick
						long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
						lGrid = lGridsAndTicks / lClocksPerGrid;
						lTick = lGridsAndTicks % lClocksPerGrid;

						// Try and preserve negative tick offsets
						if( lTick > 0 )
						{
							long lNewClocks = lClocks + lClocksPerGrid;

							if( lTick >= (lClocksPerGrid >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lGrid++;
									lTick -= lClocksPerGrid;
									if( lGrid >= ts.wGridsPerBeat )
									{
										lGrid = 0;
										mtTime += lClocksPerGrid;
										hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
									}
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plGrid = lGrid;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToMeasureBeatGridTick

HRESULT	CTrackMgr::UnknownTimeToMeasureBeatGridTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}
	
	MUSIC_TIME mtTime;
	UnknownTimeToClocks( rtTime, &mtTime );

	return ClocksToMeasureBeatGridTick( mtTime, plMeasure, plBeat, plGrid, plTick );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatGridTickToUnknownTime

HRESULT	CTrackMgr::MeasureBeatGridTickToUnknownTime( long lMeasure, long lBeat, long lGrid, long lTick, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}
	
	MUSIC_TIME mtTime;
	HRESULT hr = MeasureBeatGridTickToClocks( lMeasure, lBeat, lGrid, lTick, &mtTime );

	ClocksToUnknownTime( mtTime, prtTime );

	return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::ClocksToUnknownTime

HRESULT CTrackMgr::ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		return S_FALSE;
	}
	
	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->ClocksToRefTime( mtTime, prtTime );
	}
	else
	{
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToClocks

HRESULT CTrackMgr::UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		hr = m_pTimeline->RefTimeToClocks( rtTime, pmtTime );
	}
	else
	{
		*pmtTime = (MUSIC_TIME)rtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::RefTimeToUnknownTime

HRESULT CTrackMgr::RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		MUSIC_TIME mtTime;
		hr = m_pTimeline->RefTimeToClocks( rtTime, &mtTime );
		*prtTime = mtTime;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::UnknownTimeToRefTime

HRESULT CTrackMgr::UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime )
{
	if( m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	if( IsRefTimeTrack() )
	{
		*prtTime = rtTime;
	}
	else
	{
		hr = m_pTimeline->ClocksToRefTime( (MUSIC_TIME)rtTime, prtTime );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::MeasureBeatGridTickToClocks

HRESULT	CTrackMgr::MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;
	long lGridClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, lClocks, NULL, &ts ) ) )
			{
				long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
				lGridClocks = lGrid * lClocksPerGrid;

				mtTime = lClocks + lGridClocks + lTick;
			}
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::GetSegmentLength

REFERENCE_TIME CTrackMgr::GetSegmentLength( void )
{
	MUSIC_TIME mtSegmentLength = LONG_MAX;

	VARIANT varLength;
	if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
	{
		mtSegmentLength = V_I4(&varLength);
	}

	REFERENCE_TIME rtSegmentLength;
	ClocksToUnknownTime( mtSegmentLength, &rtSegmentLength );

	return rtSegmentLength;
}

void CTrackMgr::NotifyDataChange(UINT nLastEdit)
{
	m_nLastEdit = nLastEdit;
	OnDataChanged();
	SyncWithDirectMusic();
}


void CTrackMgr::SetParamStripForPropSheet(CParamStrip* pParamStrip, BOOL bSetToNULL)
{
	if(bSetToNULL)
	{
		if(m_pParamStripForPropSheet == pParamStrip)
		{
			m_pParamStripForPropSheet = NULL;
			return;
		}
	}
	else
	{
		m_pParamStripForPropSheet = pParamStrip;
	}


}

IDMUSProdNode* CTrackMgr::GetDocRootNode()
{
	return m_pIDocRootNode;
}

void CTrackMgr::TrackDataChanged()
{
	OnDataChanged();
}

IDMUSProdPropPageManager* CTrackMgr::GetPropPageMgr()
{
	return m_pPropPageMgr;
}

UINT CTrackMgr::GetLastEdit()
{
	return m_nLastEdit;
}

void CTrackMgr::SetLastEdit(UINT nLastEdit)
{
	m_nLastEdit = nLastEdit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackMgr.h ===
// TrackMgr.h : Declaration of the CTrackMgr

#ifndef __PARAM_TRACKMGR_H_
#define __PARAM_TRACKMGR_H_

class CTrackMgr;
class CParamStrip;
class CTrackItem;
class CDllJazzDataObject;
interface IDirectMusicTrack;

#include "resource.h"		// main symbols
#include "ParamStripMgr.h"
#include "TrackItem.h"
#include "selectedregion.h"
#include "BaseMgr.h"
#include "SegmentDesigner.h"
#include "SegmentGUIDs.h"
#include <conductor.h>
#include <dmusicf.h>
#include "TrackObject.h"


class CCurveTracker;

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define MAX_TICK (DMUS_PPQ << 1)

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE			600000000
#endif

#ifndef REFCLOCKS_PER_SECOND
#define REFCLOCKS_PER_SECOND			10000000
#endif

#ifndef REFCLOCKS_PER_MILLISECOND	
#define REFCLOCKS_PER_MILLISECOND		10000
#endif

#define INSERT_CURVE_START_VALUE		1

#define CRV_MINIMIZE_HEIGHT				20
#define CRV_DEFAULT_HEIGHT				80
#define CRV_MAXHEIGHT_HEIGHT			200
#define CURVE_MIN_SIZE					6
#define	MAX_DEFAULT_CURVE_VALUE			127

#define INSERT_CURVE_FALSE				0
#define INSERT_CURVE_START_VALUE		1
#define INSERT_CURVE_END_VALUE			2

#define MIN_NBR_GRIDS_PER_SECOND		1
#define MAX_NBR_GRIDS_PER_SECOND		100
#define DEFAULT_NBR_GRIDS_PER_SECOND	1

#define STRIP_MINIMIZE_HEIGHT			20
#define STRIP_MIN_HEIGHT				STRIP_MINIMIZE_HEIGHT
#define STRIP_MAX_HEIGHT				(STRIP_MINIMIZE_HEIGHT << 3)
#define STRIP_DEFAULT_HEIGHT			STRIP_MINIMIZE_HEIGHT

// Chunk ID used for strip's design data
#define DMUS_FOURCC_STRIP_UI_LIST       mmioFOURCC('s','p','l','u')
#define DMUS_FOURCC_STRIP_UI_CHUNK      mmioFOURCC('s','p','c','u')
#define DMUS_FOURCC_OBJECT_UI_CHUNK     mmioFOURCC('o','p','c','u')
#define DMUS_FOURCC_COPYPASTE_UI_CHUNK	mmioFOURCC('c','p','c','u')

// Strip State flags
#define STRIPUI_ACTIVESTRIP				0x00000001

#define TRACKCONFIG_VALID_MASK			DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME
#define PARAMTRACK_DEFAULT				DMUS_TRACKCONFIG_PLAY_ENABLED
/////////////////////////////////////////////////////////////////////////////
// DirectMusicTimeSig structure

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }
	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr
class ATL_NO_VTABLE CTrackMgr : public CBaseMgr, public CComCoClass<CTrackMgr, &CLSID_ParamMgr>,public IParamMgr
{

public:
	CTrackMgr();
	~CTrackMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_TRACKMGR)

BEGIN_COM_MAP(CTrackMgr)
	COM_INTERFACE_ENTRY_IID(IID_IParamMgr,IParamMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr overrides

// IParamMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist overrides

// IPersistStream overrides
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );

// IDMUSProdPropPageObject overrides
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
	// Overrides of CBaseMgr
	bool	RecomputeTimes();			 // Returns true if anything changed
	
	// Performs action on CTrackMgr
	void		InsertByAscendingPChannel(CTrackObject* pTrackObject);
	void		InsertInAlphabeticalOrder(CPtrList* plstObjects, CTrackObject* pTrackObject);
	CPtrList*	SortListAlphabetically(CPtrList* plstObjects);
	int			CompareObjectAlphabetical(CTrackObject* pObjectInList, CTrackObject* pTrackObject);



	// Performs action on all CTrackObjects
	void	AllObjects_OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData );
	void	AllObjects_RefreshInfo(); 
	void	AllObjects_Invalidate();
	bool	AllObjects_RecomputeTimes(); // Returns true if anything changed
	void	AllObjects_RecomputeMeasureBeats();
	void	AllObjects_AddAllStripsToTimeline();
	void	AllObjects_RemoveAllStripsFromTimeline();
	void	AllObjects_SwitchTimeBase();
	void	DeleteAllObjects();

	// Performs action on one CParamStrip
	HRESULT AddStripToTimeline( CParamStrip* pParamStrip, int nPosition );
	HRESULT RemoveStripFromTimeline( CParamStrip* pParamStrip );

public:
	
	// Add and delete objects from the track
	HRESULT AddNewObject();
	HRESULT AddNewObject(CTrackObject* pTrackObject, StripInfo* pStripInfo);
	HRESULT DeleteAllStripsInObject(CTrackObject* pTrackObject);

	// General Helpers
	IDMUSProdSegmentEdit8* GetSegment();

	HRESULT	RefTimeToMinSecGridMs(CParamStrip* pParamStrip, REFERENCE_TIME rtTime, long* plMinute, long* plSecond, long* plGrid, long* plMillisecond);
	HRESULT	MinSecGridMsToRefTime(CParamStrip* pParamStrip, long lMinute, long lSecond, long lGrid, long lMillisecond, REFERENCE_TIME* prtTime);
	HRESULT	ClocksToMeasureBeatGridTick(MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick);
	HRESULT	MeasureBeatGridTickToClocks(long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime);
	HRESULT RefTimeToUnknownTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );
	HRESULT ClocksToUnknownTime( MUSIC_TIME mtTime, REFERENCE_TIME* prtTime );
	HRESULT	MeasureBeatGridTickToUnknownTime( long lMeasure, long lBeat, long lGrid, long lTick, REFERENCE_TIME* prtTime);

	
	HRESULT	UnknownTimeToMeasureBeatGridTick( REFERENCE_TIME rtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick );
	HRESULT UnknownTimeToClocks( REFERENCE_TIME rtTime, MUSIC_TIME* pmtTime );
	HRESULT UnknownTimeToRefTime( REFERENCE_TIME rtTime, REFERENCE_TIME* prtTime );

	HRESULT GetPChannelName( DWORD dwPChannel, CString& strPChannelName );
	bool	PChannelExists( DWORD dwPChannel );
	DWORD	GetGreatestUsedPChannel();

	void	RemoveFromPropSheet(CParamStrip* pParamStrip);
	bool	IsRefTimeTrack();

	void	DeleteSelectedStripsFromObjects();
	

	void	NotifyDataChange(UINT nLastEdit); 

	// Performs action on CTrackMgr
	HRESULT	SyncWithDirectMusic( void ); // Returns S_OK if succeeded, S_FALSE if no track, E_* if failed.
	void	SetDirtyFlag( bool fDirty );
	void	TrackDataChanged();			// Dowa nothing but calles th


	HRESULT	ClocksToMeasureBeatTick( MUSIC_TIME mTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT	MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmTime );
	
	REFERENCE_TIME GetSegmentLength( void );

	HRESULT GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Accessors / Mutators
	IDMUSProdPropPageManager* GetPropPageMgr();

	IDMUSProdNode*		GetDocRootNode();
	IDMUSProdFramework* GetFramework();
	IDMUSProdConductor* GetConductor();
	IDMUSProdTimeline*  GetTimeline();

	UINT				GetLastEdit();
	void				SetLastEdit(UINT nLastEdit);
	
	CParamStrip*		GetParamStripForPropSheet();
	void				SetParamStripForPropSheet(CParamStrip* pParamStrip, BOOL bSetToNULL = FALSE);


	CLSID				GetCLSID();
	DWORD				GetGroupBits();

	


protected:
	IDirectMusicPerformance* m_pIDMPerformance;
	CParamStrip*			 m_pParamStripForPropSheet;

	// Fields that are persisted (DirectMusic parameter control track data)
	CTypedPtrList<CPtrList, CTrackObject*> m_lstTrackObjects;
};




#endif //__PARAM_TRACKMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackObject.cpp ===
// TrackObject.cpp : implementation file
//

#include "stdafx.h"
#include "RiffStrm.h"
#include "TrackMgr.h"
#include "ParamStrip.h"
//#include "TrackObject.h"


// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTrackObject constructor/destructor 

CTrackObject::CTrackObject( CTrackMgr* pTrackMgr )
{
	ASSERT( pTrackMgr != NULL );
	m_pTrackMgr = pTrackMgr;

	m_dwPChannel = 0;	
	m_dwBuffer = 0;
	m_dwStage = 0;		
	memset( &m_guidObject, 0, sizeof(GUID) );
	m_dwObjectIndex = 0;
	m_dwObjectFlagsDM = 0;

	m_bDisabled = FALSE;
	m_ParamStripView = SV_MINIMIZED;

	m_pMinimizedStrip = new CParamStrip(pTrackMgr, this);
	ASSERT(m_pMinimizedStrip);
}

CTrackObject::~CTrackObject()
{
	// Release all the items in m_lstParamStrips
	while( !m_lstParamStrips.IsEmpty() )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.RemoveHead();

		long cRef = pParamStrip->Release();
		ASSERT( cRef == 0 );
	}

	if(m_pMinimizedStrip)
	{
		m_pMinimizedStrip->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::LoadObject

HRESULT CTrackObject::LoadObject(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	MMCKINFO		ck;
	MMCKINFO		ckList;
	DWORD			dwByteCount = 0;
	DWORD			dwSize = 0;
	HRESULT			hr = E_FAIL;

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckParent);
	if(pckParent == NULL )
	{
		return E_POINTER;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	// Load the items
	while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
	{
		switch(ck.ckid)
		{
            case DMUS_FOURCC_OBJECT_UI_CHUNK:
            {
                ioObjectUI iObjectUI;
                hr = pIStream->Read(&iObjectUI, sizeof(ioObjectUI), &dwByteCount);
                if(FAILED(hr) || dwByteCount != sizeof(ioObjectUI))
                {
                    goto ON_ERROR;
                }

                m_guidInstance = iObjectUI.m_guidInstance;

                break;
            }

			case DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK:
			{
				DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER iObjectHeader;

				// Read in the item's header structure
				dwSize = min( sizeof( DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER ), ck.cksize );
				hr = pIStream->Read( &iObjectHeader, dwSize, &dwByteCount );

				// Handle any I/O error by returning a failure code
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwObjectFlagsDM = iObjectHeader.dwFlags;
				m_guidTimeFormat = iObjectHeader.guidTimeFormat;
				m_dwPChannel = iObjectHeader.dwPChannel;
				m_dwBuffer = iObjectHeader.dwBuffer;
				m_dwStage = iObjectHeader.dwStage;
				m_guidObject = iObjectHeader.guidObject;
				m_dwObjectIndex = iObjectHeader.dwIndex;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST:
					{
						CParamStrip* pNewStrip = new CParamStrip( m_pTrackMgr, this);
						if( pNewStrip == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}
						hr = pNewStrip->LoadStrip( pIRiffStream, &ckList );
						if( FAILED ( hr ) )
						{
							delete pNewStrip;
							goto ON_ERROR;
						}
						InsertByAscendingParameter( pNewStrip );
						m_ParamStripView = pNewStrip->m_StripUI.m_nStripView == SV_MINIMIZED ? SV_MINIMIZED : SV_NORMAL;
						break;
					}
				}
				break;
		}

		// Ascend out of the chunk
		pIRiffStream->Ascend( &ck, 0 );
	}

	RefreshObjectProperties();

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::SaveObject

HRESULT CTrackObject::SaveObject( IDMUSProdRIFFStream* pIRiffStream )
{
	MMCKINFO ckObject;
	MMCKINFO ck;
	HRESULT hr = E_FAIL;

	// No need to save if this is an empty object....
	if(IsEmptyTrackObject())
	{
		return S_FALSE;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}
    
	// Structures for determining the stream type
	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}


	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST list chunk
	ckObject.fccType = DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST;
	if( pIRiffStream->CreateChunk( &ckObject, MMIO_CREATELIST ) != 0 )
	{
		// If unable to create the chunk, return E_FAIL
		hr = E_FAIL;
		goto ON_ERROR;
	}

    // Create the UI chunk
    if(ftFileType == FT_DESIGN)
    {
        ck.ckid = DMUS_FOURCC_OBJECT_UI_CHUNK;
        if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

        ioObjectUI oObjectUI;
        oObjectUI.cbSize = sizeof(ioObjectUI);
        oObjectUI.m_guidInstance = m_guidInstance;
        
        DWORD dwBytesWritten = 0;
        hr = pIStream->Write(&oObjectUI, sizeof(ioObjectUI), &dwBytesWritten);
        if(FAILED(hr) || dwBytesWritten != sizeof(ioObjectUI))
        {
            goto ON_ERROR;
        }

        if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
     }

	// Create the DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK chunk
	{
		ck.ckid = DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			// If unable to create the chunk, return E_FAIL
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Clear out the structure (clears out the padding bytes as well).
		DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER oObjectHeader;
		ZeroMemory( &oObjectHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER) );

		// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER structure
		oObjectHeader.dwFlags = m_dwObjectFlagsDM;
		// TODO - set time guid
		oObjectHeader.guidTimeFormat = m_guidTimeFormat;
		oObjectHeader.dwPChannel = m_dwPChannel;
		oObjectHeader.dwStage = m_dwStage;
		oObjectHeader.dwBuffer = m_dwBuffer;
		oObjectHeader.guidObject = m_guidObject;
		oObjectHeader.dwIndex = m_dwObjectIndex;

		// Write the structure out to the stream
		DWORD dwBytesWritten;
		hr = pIStream->Write( &oObjectHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER) )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK chunk
		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			// Handle I/O errors by return an error code
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Save the parameter control strips
	if( !m_lstParamStrips.IsEmpty() )
	{

		// Iterate through the item list
		POSITION pos = m_lstParamStrips.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each item
			CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

			// Save each strip
			hr = pParamStrip->SaveStrip( pIRiffStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

	// Ascend out of the DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST list chunk
	if( pIRiffStream->Ascend(&ckObject, 0) != 0 )
	{
		// Handle I/O errors by return an error code
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::InsertByAscendingParameter

void CTrackObject::InsertByAscendingParameter( CParamStrip* pParamStripToInsert )
{
	// Ensure the pParamStripToInsert pointer is valid
	if ( pParamStripToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CParamStrip* pParamStrip;
	POSITION posCurrent, posNext = m_lstParamStrips.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pParamStrip = m_lstParamStrips.GetNext( posNext );

		CString sName1 = pParamStripToInsert->GetName();
		CString sName2 = pParamStrip->GetName();

		if( sName1.CompareNoCase(sName2) <= 0 )
		{
			// insert before posCurrent (which is the position of pParamStrip)
			m_lstParamStrips.InsertBefore( posCurrent, pParamStripToInsert );
			return;
		}
	}

	// pParamStripToInsert has higher parameter than all items in the list
	// add it at the end of the list
	m_lstParamStrips.AddTail( pParamStripToInsert );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_OnUpdate

void CTrackObject::AllStrips_OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData )
{
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

		pParamStrip->OnUpdate( rguidType, dwGroupBits, pData );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_Invalidate

void CTrackObject::AllStrips_Invalidate( void )
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL )
	{
		return;
	}

	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

		ASSERT(pParamStrip);
		if(pParamStrip == NULL)
		{
			return;
		}

		pParamStrip->InvalidateFBar();

		IDMUSProdPropPageManager* pPropPageMgr = pParamStrip->GetPropPageMgr();
		// Refresh strip properties
		if( pPropPageMgr )
		{
			pPropPageMgr->RefreshData();
		}

		// Redraw strip
		pTimeline->StripInvalidateRect( pParamStrip, NULL, TRUE );
	}


	// Invalidate the minimized strip too...
	pTimeline->StripInvalidateRect( m_pMinimizedStrip, NULL, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_RecomputeMeasureBeats

void CTrackObject::AllStrips_RecomputeMeasureBeats()
{
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

		pParamStrip->RecomputeMeasureBeats();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_RecomputeTimes

bool CTrackObject::AllStrips_RecomputeTimes()
{
	bool fChanged = FALSE;

	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

		fChanged |= pParamStrip->RecomputeTimes();
	}

	return fChanged;
}


void CTrackObject::AllStrips_AddToTimeline()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return;
	}

	int nPosition = -1;
	
	POSITION positionStrip = m_lstParamStrips.GetHeadPosition();
	if(positionStrip == NULL)
	{
		AddStripToTimeline(m_pMinimizedStrip, nPosition);
		return;
	}

	while(positionStrip)
	{
		CParamStrip* pParamStrip = (CParamStrip*)m_lstParamStrips.GetNext(positionStrip);
		ASSERT(pParamStrip);
		if(pParamStrip)
		{
			if(pParamStrip->m_StripUI.m_nStripView == SV_MINIMIZED)
			{
				AddStripToTimeline(m_pMinimizedStrip, nPosition);
				return;
			}

			AddStripToTimeline( pParamStrip, nPosition );

			if( nPosition == -1 )
			{
				VARIANT var;
				if( SUCCEEDED( pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)pParamStrip, STP_POSITION, &var) ) )
				{
					nPosition = V_I4(&var);
					ASSERT( nPosition > 0 );
				}
			}

			nPosition++;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_SetNbrGridsPerSecond

BOOL CTrackObject::AllStrips_SetNbrGridsPerSecond( short nNbrGridsPerSecond )
{
	BOOL fChanged = FALSE;

	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );

		if( pParamStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond != nNbrGridsPerSecond )
		{
			pParamStrip->m_StripUI.m_nSnapToRefTime_GridsPerSecond = nNbrGridsPerSecond;
			fChanged = TRUE;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AllStrips_SwitchTimeBase

void CTrackObject::AllStrips_SwitchTimeBase( void )
{
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext( pos );
		pParamStrip->SwitchTimeBase();
	}
}


BOOL CTrackObject::IsEmptyTrackObject()
{
	// Is the strip list empty? 
	if(m_lstParamStrips.IsEmpty())
	{
		return TRUE;
	}

	// Is this the first dummy object we insert
	GUID guid;
	memset(&guid, 0, sizeof(GUID));

	if(m_dwPChannel == 0 &&	m_dwStage == 0 && m_dwBuffer == 0 &&
		::IsEqualGUID(m_guidObject, guid) && 
		m_dwObjectIndex == 0 && m_dwObjectFlagsDM == 0)
	{
		return TRUE;
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTrackObject::OnChangeCurveStripView

void CTrackObject::OnChangeParamStripView( STRIPVIEW svNewStripView )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pTrackMgr != NULL );
	if( m_ParamStripView == svNewStripView )
	{
		return;
	}

	CParamStrip* pParamStrip = NULL;

	// Don't allow SV_NORMAL when there are no ParamStrips
	if( svNewStripView == SV_NORMAL && IsEmptyTrackObject())
	{
		m_ParamStripView = SV_MINIMIZED;

		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = m_ParamStripView;

		if(m_lstParamStrips.IsEmpty())
		{
			m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)m_pMinimizedStrip, STP_STRIPVIEW, var );
		}

		POSITION pos = m_lstParamStrips.GetHeadPosition();
		while( pos )
		{
			pParamStrip = m_lstParamStrips.GetNext( pos );
			m_pTrackMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pParamStrip, STP_STRIPVIEW, var );
		}

		return;
	}

	if(m_ParamStripView == SV_MINIMIZED)
	{
		RemoveStripFromTimeline(m_pMinimizedStrip);
		m_pTrackMgr->NotifyDataChange(IDS_UNDO_STRIP_MAXIMIZED);
	}
	else
	{
		m_pTrackMgr->NotifyDataChange(IDS_UNDO_STRIP_MINIMIZED);
	}

	// Change Param StripView field
	m_ParamStripView = svNewStripView;

	// Remove all existing Param Strips
	AllStrips_RemoveFromTimeline();

	// Go through all the strips and set their view state
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while(pos)
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext(pos);
		ASSERT(pParamStrip);
		if(pParamStrip)
		{
			pParamStrip->m_StripUI.m_nStripView = svNewStripView;

		}
	}

	// Add new Param Strips
	if(m_ParamStripView == SV_MINIMIZED)
	{
		AddStripToTimeline(m_pMinimizedStrip, -1);
	}
	else
	{
		AllStrips_AddToTimeline();
	}

	// Let the object know about the changes
	m_pTrackMgr->SetDirtyFlag(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// CTrackObject::AddStripToTimeline

HRESULT CTrackObject::AddStripToTimeline(CParamStrip* pParamStrip, int nPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(pParamStrip);
	if( pParamStrip == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = E_FAIL;
	// Place strip in timeline
	if( nPosition <= 0 )
	{
		CLSID clsid = m_pTrackMgr->GetCLSID();
		DWORD dwGroupBits = m_pTrackMgr->GetGroupBits();
		hr = pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)pParamStrip, clsid, dwGroupBits, 0 );
	}
	else
	{
		hr = pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pParamStrip, nPosition );
	}

	// Set strip state information
	pParamStrip->StripUIToTimeline();

	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CTrackObject::RemoveStripFromTimeline
HRESULT CTrackObject::RemoveStripFromTimeline( CParamStrip* pParamStrip )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(pParamStrip);
	if( pParamStrip == NULL )
	{
		return E_POINTER;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	// Don't assert since this gets called in OnUpdate after the 
	// track's deleted in which case m_pTimeline is always NULL
	// ASSERT(pTimeline); 
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Make sure we are storing the latest UI state information
	pParamStrip->TimelineToStripUI();

	// Make sure our strip's property page isn't displayed
	m_pTrackMgr->RemoveFromPropSheet(pParamStrip);
	
	pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)pParamStrip);

	IDMUSProdPropPageManager* pPropPageMgr = pParamStrip->GetPropPageMgr();
	RELEASE(pPropPageMgr);

	pTimeline->RemoveStrip((IDMUSProdStrip *)pParamStrip);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackMgr::AllStrips_RemoveFromTimeline

void CTrackObject::AllStrips_RemoveFromTimeline( void )
{
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while( pos )
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext(pos);
		ASSERT(pParamStrip);
		RemoveStripFromTimeline( pParamStrip );
	}

	if(m_pMinimizedStrip)
	{
		RemoveStripFromTimeline(m_pMinimizedStrip);
	}
}


HRESULT CTrackObject::AddStrip(StripInfo* pStripInfo)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(pStripInfo);
	if(pStripInfo == NULL)
	{
		return E_POINTER;
	}
	
	m_sStageName = pStripInfo->m_sStageName;
	m_sObjectName = pStripInfo->m_sObjectName;
	m_dwPChannel = pStripInfo->m_dwPChannel;
	m_dwBuffer = pStripInfo->m_dwBuffer;
	m_sPChannelText = pStripInfo->m_sPChannelText; 
	m_dwStage = pStripInfo->m_dwStage;
	m_guidObject = pStripInfo->m_guidObject;
    m_guidInstance = pStripInfo->m_guidInstance;
	m_guidTimeFormat = pStripInfo->m_guidTimeFormat;
	m_dwObjectIndex = pStripInfo->m_dwObjectIndex;

	CParamStrip* pStrip = new CParamStrip(m_pTrackMgr, this);
	ASSERT(pStrip);
	if(pStrip == NULL)
	{
		return E_OUTOFMEMORY;
	}
	
	if(FAILED(pStrip->SetProperties(pStripInfo)))
	{
		delete pStrip;
		return E_FAIL;
	}

	pStrip->m_StripUI.m_nStripView = m_ParamStripView;

	// Get position of first wave strip in the timeline
	/*int nPosition = -1;
	if( m_lstParamStrips.IsEmpty() == FALSE  && m_ParamStripView != SV_MINIMIZED)
	{
		CParamStrip* pFirstStrip = m_lstParamStrips.GetHead();

		VARIANT var;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)pFirstStrip, STP_POSITION, &var) ) )
		{
			nPosition = V_I4(&var);
		}
	}
	else
	{
		VARIANT var;
		if( SUCCEEDED( m_pTrackMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pMinimizedStrip, STP_POSITION, &var) ) )
		{
			nPosition = V_I4(&var);
		}

		 if(m_lstParamStrips.IsEmpty())
		 {
			 RemoveStripFromTimeline(m_pMinimizedStrip);
		 }
	}
	
	if(m_ParamStripView != SV_MINIMIZED || m_lstParamStrips.IsEmpty())
	{
		nPosition += m_lstParamStrips.GetCount();

		if(FAILED(AddStripToTimeline(pStrip, nPosition)))
		{	
			delete pStrip;
			return E_FAIL;
		}
	}*/

	AllStrips_RemoveFromTimeline();
	InsertByAscendingParameter(pStrip);
	AllStrips_AddToTimeline();

	AllStrips_Invalidate();
	pStrip->InvalidateFBar();

	m_pTrackMgr->SetLastEdit(IDS_UNDO_ADD_PARAM);
	m_pTrackMgr->TrackDataChanged();

	return S_OK;
	

}

CString CTrackObject::GetMinimizedStripText()
{
	CString sText;
	POSITION position= m_lstParamStrips.GetHeadPosition();
	while(position)
	{
		CParamStrip* pStrip = (CParamStrip*)m_lstParamStrips.GetNext(position);
		ASSERT(pStrip);
		if(pStrip)
		{
			CString sStripName = pStrip->GetName();
			if(!sStripName.IsEmpty())
			{
				if(!sText.IsEmpty())
				{
					sText += ",";
				}

				sText += sStripName;
			}
		}
	}

	if(sText.IsEmpty())
	{
		sText.LoadString(IDS_NO_PARAM_TEXT);
	}

	CString sFullText = sText;

	return sFullText;
}

HRESULT CTrackObject::DeleteAllStrips()
{
	POSITION position = m_lstParamStrips.GetHeadPosition();
	while(position)
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext(position);
		DeleteStrip(pParamStrip);
	}

	return S_OK;	
}

HRESULT CTrackObject::DeleteAllSelectedStrips()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return E_UNEXPECTED;
	}


	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	ASSERT(pTimeline);
	if(pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	BOOL fStripWasDeleted = FALSE;
	VARIANT var;

	// Delete all gutter selected strips
	POSITION pos = m_lstParamStrips.GetHeadPosition();
	while(pos)
	{
		CParamStrip* pParamStrip = m_lstParamStrips.GetNext(pos);
		if(SUCCEEDED(pTimeline->StripGetTimelineProperty( pParamStrip, STP_GUTTER_SELECTED, &var)))
		{
			if(V_BOOL(&var) == TRUE)
			{
				DeleteStrip(pParamStrip);
				fStripWasDeleted = TRUE;
			}
		}
	}
	
	// If none of the parameter control strips were gutter selected, delete the active strip
	IDMUSProdStrip* pIActiveStrip = NULL;
	if(fStripWasDeleted == FALSE)
	{
		if(SUCCEEDED(pTimeline->GetTimelineProperty(TP_ACTIVESTRIP, &var)))
		{
			if(V_UNKNOWN(&var) != NULL)
			{
				if(SUCCEEDED(V_UNKNOWN(&var)->QueryInterface(IID_IDMUSProdStrip, (void **) &pIActiveStrip)))
				{
					pos = m_lstParamStrips.GetHeadPosition();
					while(pos)
					{
						CParamStrip* pParamStrip = m_lstParamStrips.GetNext(pos);
						if(pParamStrip == pIActiveStrip)
						{
							DeleteStrip(pParamStrip);
						}
					}

					RELEASE(pIActiveStrip);
				}

				V_UNKNOWN(&var)->Release();
			}
		}
	}

	return S_OK;
}


void CTrackObject::DeleteStrip(CParamStrip* pParamStrip)
{
	ASSERT(pParamStrip);
	if(pParamStrip == NULL)
	{
		return;
	}

	RemoveStripFromTimeline(pParamStrip);

	POSITION position = m_lstParamStrips.Find(pParamStrip);
	if(position)
	{
		m_lstParamStrips.RemoveAt(position);
		pParamStrip->CleanUp();
		RELEASE(pParamStrip);
	}

	return;
}

DWORD CTrackObject::GetNumberOfStrips()
{
	return m_lstParamStrips.GetCount();
}

void CTrackObject::RefreshAllStrips()
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return;
	}

	IDMUSProdTimeline* pTimeline = m_pTrackMgr->GetTimeline();
	if(pTimeline == NULL)
	{
		return;
	}

	POSITION position = m_lstParamStrips.GetHeadPosition();
	while(position)
	{
		CParamStrip* pStrip = (CParamStrip*)m_lstParamStrips.GetNext(position);
		ASSERT(pStrip);
		if(pStrip)
		{
			pTimeline->StripInvalidateRect((IDMUSProdStrip*)pStrip, NULL, TRUE);
		}
	}
}

CString CTrackObject::GetName()
{
	return m_sObjectName;
}

HRESULT CTrackObject::GetParamEnumTypeText(GUID guidObject, DWORD dwParamIndex, WCHAR** ppwchParamEnums)
{
	IUnknown* pIUnkObject = NULL;
	if(FAILED(::CoCreateInstance(guidObject, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &pIUnkObject)))
	{
		return E_FAIL;
	}

	ASSERT(pIUnkObject);

	IMediaParamInfo* pIParamInfo = NULL;
	if(FAILED(pIUnkObject->QueryInterface(IID_IMediaParamInfo, (void**)&pIParamInfo)))
	{
		return E_FAIL;
	}

	if(FAILED(pIParamInfo->GetParamText(dwParamIndex, ppwchParamEnums)))
	{
		pIParamInfo->Release();
		pIUnkObject->Release();
		return E_FAIL;
	}

	CString sParamText = *ppwchParamEnums;
	
	pIParamInfo->Release();
	pIUnkObject->Release();
	return S_OK;
}

HRESULT CTrackObject::ParseEnumText(WCHAR* pwszParamText, CString& sParamName, CString& sParamUnitLabel, CList<CString, CString&>* plstEnumTypes, DWORD* pdwCount)
{
	ASSERT(pwszParamText);
	if(pwszParamText == NULL)
	{
		return E_POINTER;
	}

	ASSERT(plstEnumTypes);
	if(plstEnumTypes == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pdwCount);
	if(pdwCount == NULL)
	{
		return E_POINTER;
	}

	// The paramtext format is [ParamName]\0[Unit]\0[Val1]\0[Val2]\0....\0[Val(n)]\0\0

	// Skip the Param Name and Unit label
	sParamName = pwszParamText;
	int nParamNameLength = sParamName.GetLength() + 1;

	WCHAR* pwszUnitLabel = pwszParamText + nParamNameLength;
	sParamUnitLabel = pwszUnitLabel;
	int nUnitLabelLength = sParamUnitLabel.GetLength() + 1;

	WCHAR* pwszText = pwszUnitLabel + nUnitLabelLength;

	while(1)
	{
		CString sText = pwszText;
		if(sText != "\0")
		{
			plstEnumTypes->AddTail(sText);
			int nTextLength = sText.GetLength() + 1;
			pwszText += nTextLength;
		}
		else
		{
			break;
		}
	}
	

	return S_OK;
}

GUID CTrackObject::GetCLSID()
{
	return m_guidObject;
}

void CTrackObject::GetObjectHeader(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER& oObjectHeader)
{
	ZeroMemory( &oObjectHeader, sizeof(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER) );

	// Fill in the members of the DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER structure
	oObjectHeader.dwFlags = m_dwObjectFlagsDM;
	oObjectHeader.guidTimeFormat = m_guidTimeFormat;
	oObjectHeader.dwPChannel = m_dwPChannel;
	oObjectHeader.dwBuffer = m_dwBuffer;
	oObjectHeader.dwStage = m_dwStage;
	oObjectHeader.guidObject = m_guidObject;
	oObjectHeader.dwIndex = m_dwObjectIndex;
}

void CTrackObject::RefreshObjectProperties()
{
	
	if(m_dwStage == DMUS_PATH_SEGMENT_TOOL || m_dwStage == DMUS_PATH_AUDIOPATH_TOOL ||
		m_dwStage == DMUS_PATH_PERFORMANCE_TOOL)
	{
		CDMToolInfo* pToolInfo = GetToolInfo(m_dwStage, m_guidObject);
		if(pToolInfo)
		{
			m_sObjectName = pToolInfo->m_ToolInfo.awchToolName;
			m_sPChannelText = pToolInfo->m_ToolInfo.awchPChannels;
			m_dwPChannel = pToolInfo->m_ToolInfo.dwFirstPChannel;
			m_dwBuffer = 0;

			delete pToolInfo;
		}

		m_sStageName = GetToolStageName(m_dwStage);
	}
	else if(m_dwStage == DMUS_PATH_BUFFER_DMO || m_dwStage == DMUS_PATH_MIXIN_BUFFER_DMO || m_dwStage == DMUS_PATH_PERFORMANCE)
	{
		CDMOInfo* pDMOInfo = GetDMOInfo(this);
		if(pDMOInfo)
		{
			m_sObjectName = pDMOInfo->m_DMOInfo.awchDMOName;
			m_sPChannelText = pDMOInfo->m_DMOInfo.awchPChannelText;
			m_dwPChannel = pDMOInfo->m_DMOInfo.dwPChannel;
			m_dwBuffer = pDMOInfo->m_DMOInfo.dwBufferIndex;
            m_guidInstance = pDMOInfo->m_DMOInfo.guidDesignGUID;

			m_bDisabled = FALSE;

			delete pDMOInfo;
		}
		else
		{
			m_bDisabled = TRUE;
		}

		if(m_sStageName.IsEmpty())
		{
			m_sStageName = GetDMOStageName(m_dwStage);
		}

	}
}

CDMToolInfo* CTrackObject::GetToolInfo(DWORD dwStage, GUID clsidObject)
{
	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdSegmentEdit8* pISegment = m_pTrackMgr->GetSegment();
	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return NULL;
	}

	IDMUSProdConductor* pIConductor = m_pTrackMgr->GetConductor();
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return NULL;
	}

	CPtrList lstObjects;
	if(FAILED(CNewParameterDialog::GetToolList(pISegment, pIConductor, dwStage, &lstObjects)))
	{
		pISegment->Release();
		pIConductor->Release();
		return NULL;
	}

	CDMToolInfo* pMatchingTool = NULL;
	while(!lstObjects.IsEmpty())
	{
		CDMToolInfo* pToolInfo = (CDMToolInfo*) lstObjects.RemoveHead();
		ASSERT(pToolInfo);
		if(pToolInfo && ::IsEqualCLSID(pToolInfo->m_ToolInfo.clsidTool, clsidObject) == FALSE)
		{
			delete pToolInfo;
		}
		else
		{
			pMatchingTool = pToolInfo;
		}
	}

	pISegment->Release();
	pIConductor->Release();
	return pMatchingTool;
}

CDMOInfo* CTrackObject::GetDMOInfo(CTrackObject* pTrackObject)
{
	ASSERT(pTrackObject);
	if(pTrackObject == NULL)
	{
		return NULL;
	}

	ASSERT(m_pTrackMgr);
	if(m_pTrackMgr == NULL)
	{
		return NULL;
	}

	IDMUSProdSegmentEdit8* pISegment = m_pTrackMgr->GetSegment();
	ASSERT(pISegment);
	if(pISegment == NULL)
	{
		return NULL;
	}

	IDMUSProdConductor* pIConductor = m_pTrackMgr->GetConductor();
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return NULL;
	}
	
	CPtrList lstObjects;
	CDMOInfo* pMatchingDMO = NULL;
	if(SUCCEEDED(CNewParameterDialog::GetDMOList(pISegment, pIConductor, pTrackObject->m_dwStage, &lstObjects)))
	{
		pMatchingDMO = CheckListForEqualObject(lstObjects, pTrackObject);
	}

	// No matching DMO? Then delete this list and get a new one
	if(pMatchingDMO == NULL)
	{
		// Delete the list
		while(!lstObjects.IsEmpty())
		{
			CDMOInfo* pDMOInfo = (CDMOInfo*)lstObjects.RemoveHead();
			if(pMatchingDMO != pDMOInfo)
			{
				delete pDMOInfo;
			}
		}
	}

	if(pMatchingDMO == NULL && SUCCEEDED(CNewParameterDialog::GetDMOList(pISegment, pIConductor, DMUS_PATH_PERFORMANCE, &lstObjects)))
	{
		pMatchingDMO = CheckListForEqualObject(lstObjects, pTrackObject);
	}

	// Delete the list
	while(!lstObjects.IsEmpty())
	{
		CDMOInfo* pDMOInfo = (CDMOInfo*)lstObjects.RemoveHead();
		if(pMatchingDMO != pDMOInfo)
		{
			delete pDMOInfo;
		}
	}

	pISegment->Release();
	pIConductor->Release();
	return pMatchingDMO;
}

CString CTrackObject::GetToolStageName(DWORD dwStage)
{
	for(int nIndex = 0; nIndex < MAX_STAGES_TOOLS; nIndex++)
	{
		CString sStageName;
		StageInfo stageInfo = CNewParameterDialog::m_arrToolsStages[nIndex];
		if(stageInfo.m_dwStage == dwStage)
		{
			sStageName.LoadString(stageInfo.m_uStageName);
			return sStageName;
		}
	}

	return "";
}

CString CTrackObject::GetDMOStageName(DWORD dwStage)
{
	for(int nIndex = 0; nIndex < MAX_STAGES_DMOS; nIndex++)
	{
		CString sStageName;
		StageInfo stageInfo = CNewParameterDialog::m_arrDMOStages[nIndex];
		if(stageInfo.m_dwStage == dwStage)
		{
			sStageName.LoadString(stageInfo.m_uStageName);
			return sStageName;
		}
	}

	return "";
}

CString CTrackObject::GetPChannelText()
{
	return m_sPChannelText;
}

CString	CTrackObject::GetObjectName()
{
	return m_sObjectName;
}

BOOL CTrackObject::IsEqualObject(GUID guidInstance)
{
    return ::IsEqualGUID(m_guidInstance, guidInstance);
}

BOOL CTrackObject::IsEqualObject(StripInfo* pStripInfo)
{
	ASSERT(pStripInfo);
	if(pStripInfo == NULL)
	{
		return FALSE;
	}

    if(pStripInfo->m_guidInstance == m_guidInstance)
    {
        return TRUE;
    }

	if(::IsEqualGUID(m_guidObject, pStripInfo->m_guidObject) == FALSE)
	{
		return FALSE;
	}

	if(m_dwStage != pStripInfo->m_dwStage)
	{
		return FALSE;
	}

	if(m_dwBuffer != pStripInfo->m_dwBuffer)
	{
		return FALSE;
	}

	if(m_dwPChannel != pStripInfo->m_dwPChannel)
	{
		return FALSE;
	}

	if(m_dwObjectIndex != pStripInfo->m_dwObjectIndex)
	{
		return FALSE;
	}

	return TRUE;
}

BOOL CTrackObject::IsDisabled()
{
	return m_bDisabled;
}

CDMOInfo* CTrackObject::CheckListForEqualObject(CPtrList& lstObjects, CTrackObject* pTrackObject)
{
	ASSERT(pTrackObject);
	if(pTrackObject == NULL)
	{
		return NULL;
	}

    CDMOInfo* pMatchingDMO = NULL;
	POSITION position = lstObjects.GetHeadPosition();
	while(position)
	{
		CDMOInfo* pDMOInfo = (CDMOInfo*) lstObjects.GetNext(position);
		ASSERT(pDMOInfo);
		if(pDMOInfo)
		{
            // Checking for instance GUID failed so check for everything else
			StripInfo stripInfo;
			stripInfo.m_dwStage = pDMOInfo->m_DMOInfo.dwStage;
			stripInfo.m_guidObject = pDMOInfo->m_DMOInfo.clsidDMO;
            stripInfo.m_guidInstance = pDMOInfo->m_DMOInfo.guidDesignGUID;
			stripInfo.m_dwBuffer = pDMOInfo->m_DMOInfo.dwBufferIndex;
			stripInfo.m_dwPChannel = pDMOInfo->m_DMOInfo.dwPChannel;
			stripInfo.m_dwObjectIndex = pDMOInfo->m_DMOInfo.dwEffectIndex;

			if(pTrackObject->IsEqualObject(&stripInfo) == TRUE)
			{
				return pDMOInfo;

			}
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Chord.cpp ===
//	chord.cpp

#include "stdafx.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <time.h>
#include <dmusici.h>
#include <dmusicf.h>
#include "chord.h"
#include "..\chordio.h"
#include "..\propchord.h"
#include "RiffStrm.h"
#include "ChordMapStripMgr.h"

ChordChangeCallback::~ChordChangeCallback()
{
	if(m_pChordEntry)delete m_pChordEntry;
}

HRESULT ChordChangeCallback::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_ChordChangeCallback))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG ChordChangeCallback::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG ChordChangeCallback::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}



HRESULT PreEditNotification::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_PreEditNotification))
	{
		AddRef();
		*ppvObj = this;
		return S_OK;
	}


    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG PreEditNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG PreEditNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


HRESULT CheckForOrphansNotification::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_CheckForOrphansNotification))
	{
		AddRef();
		*ppvObj = this;
		return S_OK;
	}


    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CheckForOrphansNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CheckForOrphansNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

ULONG ZoomChangeNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG ZoomChangeNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}




/*
#ifndef CHORDMAP
#pragma pack(6)
#endif
*/

DWORD OldChordEntry::SizeExtendedChordEntry()
{
	return sizeof(OldChordEntry);
}
DWORD OldChordEntry::SizeSmallChordEntry()
{
	return SizeExtendedChordEntry() - 5*sizeof(short);
}
DWORD OldChordEntry::SizeChordSelection()
{
	return SizeExtendedChordEntry() - (5*sizeof(short) + sizeof(short) + sizeof(DWORD));
}

DMChord::DMChord()
{
	m_dwChordPattern = 0x91;
	m_bChordRoot = 12;
	m_bScaleRoot = 0;
	m_bFlat = FALSE;
	m_bBits = 3 | CHORD_INVERT | CHORD_SIMPLE;
	m_wFlags =0;
	m_dwScalePattern = 0xAB5AB5;
	m_dwLevels = ~(unsigned)0;	// all levels
	m_bInUse = false;
	m_dwInvertPattern = ~(unsigned)0;
}

int DMChord::BassNote()
{
	int retval = -1;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			retval = i;
			break;
		}
	}
	return retval;
}

int DMChord::Third(int* bass)
{
	int third = -1;
	int bassnote = BassNote();

	if(bassnote != third)
	{
		for(int i = bassnote + 1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					third = i;
					break;
			}
		}
	}

	if(bass)
	{
		*bass = bassnote;
	}
	return third;
}

int DMChord::Fifth(int* bass, int* third)
{
	int fifth = -1;
	int thirdnote = Third(bass);

	if(thirdnote != fifth)
	{
		for(int i = thirdnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					fifth = i;
					break;
			}
		}
	}

	if(third)
	{
		*third = thirdnote;
	}
	return fifth;
}

int DMChord::Seventh(int* bass, int* third, int* fifth)
{
	int seventh = -1;
	int fifthnote = Fifth(bass, third);

	if(fifthnote != seventh)
	{
		for(int i = fifthnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
				seventh = i;
				break;
			}
		}
	}

	if(fifth)
	{
		*fifth = fifthnote;
	}
	return seventh;
}

void DMChord::ChordNotes(int& bass, int& third, int& fifth, int& seventh)
{
	seventh = Seventh(&bass, &third, &fifth);
}

int DMChord::NoteCount()
{
	int count  = 0;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			++count;
		}
	}
	return count;
}

DMPolyChord::DMPolyChord()
{
	strcpy(m_szName, _T("M"));
	m_dwTime = 0;
	m_nMeasure = 0;
	m_bBeat = 0;
	m_bRootIndex = 0;
	m_keydown = false;
	InitLevels();
}

DMPolyChord::DMPolyChord(const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
}

DMPolyChord& DMPolyChord::operator = (const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
	return *this;
}

void DMPolyChord::Load(OldChordEntry& oce)
{
	m_dwTime = oce.time;
	m_nMeasure = oce.measure;
	m_bBeat = oce.beat;
	strcpy(m_szName, _T(oce.name));
	m_keydown = oce.keydown ? true : false;
	m_bRootIndex = 0;
	DMChord* pChord = 0;

	// old chords are single level, bottom 4 notes = level 1 (bass), top 4 notes = level two (upper).
	DWORD bass = 0, upper = 0;
	DWORD cbass = 4, cupper = 4;
	int bits = sizeof(DWORD) * 8;	// should be 32
	for(int j = 0; j < sizeof(DWORD)*8; j++)
	{
		if( (oce.pattern & (1 << j)) && cbass > 0)
		{
			--cbass;
			bass |= (1 << j);
		}
		if( (oce.pattern & (1 << (bits - 1 - j))) && cupper > 0)
		{
			--cupper;
			upper |= 1 << (bits - 1 - j);
		}
	}

	// make sure that upper pattern is packed (lowest bit filled)
	long upper_root = oce.root;
	while( !(upper & 0x1) )
	{
		upper = upper >> 1;
		upper_root++;
	}
	upper_root = upper_root % 24;

	// now fill in rest of chord information
	for(int i = 0; i < MAX_POLY; i++)
	{
		pChord = (*this)[i];
		pChord->ChordRoot() = oce.root;
//		pChord->ScaleRoot() = oce.root;
		pChord->ScaleRoot() = 0;
		switch(i)
		{
		case 0:	// bass chord
			pChord->ChordPattern() = bass;
			pChord->InUse() = true;
			break;
		case 1: // upper chord
			pChord->ChordPattern() = upper;
			pChord->ChordRoot() = static_cast<BYTE>(upper_root);
			break;
		default:	// rest of the levels
			pChord->ChordPattern() = oce.pattern;
			break;
		}
		pChord->ScalePattern() = oce.scalepattern;
		pChord->Flags() = oce.varflags;
		pChord->UseFlat() = oce.flat;
		pChord->Bits() = oce.bits;
		pChord->InUse() = false;
	}
	InitLevels();
}

void DMPolyChord::Save(OldChordEntry& oce)
{
	oce.time = m_dwTime;
	oce.measure = m_nMeasure;
	oce.beat = m_bBeat;

	ASSERT(sizeof(m_szName) == sizeof(oce.name));	// catch wide char conversion

	strcpy(oce.name, m_szName);
	oce.keydown = m_keydown;
	DMChord* pChord = SubChord(m_bRootIndex);
	oce.root = pChord->ChordRoot();
	oce.pattern = pChord->ChordPattern();
	oce.varflags = pChord->Flags();
	oce.flat = pChord->UseFlat();
	oce.bits = pChord->Bits();
	oce.scalepattern = pChord->ScalePattern();
	oce.melodypattern = 0;
	oce.inscale = InScale(oce.root, oce.pattern, oce.scalepattern);
}

	// mass copy functions, from base to other subchords
void DMPolyChord::PropagateChordPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordPattern() = m_Chords[root].ChordPattern();
	}
}

void DMPolyChord::PropagateScalePattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScalePattern() = m_Chords[root].ScalePattern();
	}
}

void DMPolyChord::PropagateInvertPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InvertPattern() = m_Chords[root].InvertPattern();
	}
}

void DMPolyChord::PropagateLevels()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Levels() = m_Chords[root].Levels();
	}
}

void DMPolyChord::PropagateFlags()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Flags() = m_Chords[root].Flags();
	}
}

void DMPolyChord::PropagateChordRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordRoot() = m_Chords[root].ChordRoot();
	}
}

void DMPolyChord::PropagateScaleRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScaleRoot() = m_Chords[root].ScaleRoot();
	}
}

void DMPolyChord::PropagateUseFlat()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].UseFlat() = m_Chords[root].UseFlat();
	}
}

void DMPolyChord::PropagateBits()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Bits() = m_Chords[root].Bits();
	}
}
void DMPolyChord::PropagateInUse()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InUse() = m_Chords[root].InUse();
	}
}

void DMPolyChord::PropagateAll()
{
	PropagateChordPattern();
	PropagateScalePattern();
	PropagateInvertPattern();
	PropagateLevels();
	PropagateFlags();
	PropagateChordRoot();
	PropagateScaleRoot();
	PropagateUseFlat();
	PropagateBits();
	PropagateInUse();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void swaplong(char data[])
{
    char temp;
    temp = data[0];
    data[0] = data[3];
    data[3] = temp;
    temp = data[1];
    data[1] = data[2];
    data[2] = temp;
}

void WriteID( IStream *pIStream, DWORD id )
{
	pIStream->Write( &id, 4, NULL );
}

void WriteSize( IStream *pIStream, long size )
{
	swaplong((char *)&size);
	pIStream->Write( &size, 4, NULL );
}

long ReadID( IStream *pIStream )
{
	DWORD	dwTemp;
	long	lID;
	
	pIStream->Read( &lID, 4, &dwTemp );
	return lID;
}

long ReadSize( IStream *pIStream )
{
    long	lTemp,
			lSize;
	
	pIStream->Read( &lSize, 4, (DWORD*)&lTemp );
	swaplong( (char*)&lSize );

	return lSize;
}


void ChordSelection::SetBits(int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return;	// out of range
	}

	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		LONG    i ;
		short   count = 0 ;

		for( i=0L ;  i<32L ;  i++ ) {
			if( m_Chords[k].ChordPattern() & (1L << i) )
				count++ ;
		}
		
		if( !m_Chords[k].Bits() ) {
			m_Chords[k].Bits() |= CHORD_INVERT ;
			if( count > 3 )
				m_Chords[k].Bits() |= CHORD_FOUR ;
			if( m_Chords[k].ChordPattern() & (15L << 18L) )
				m_Chords[k].Bits() |= CHORD_UPPER ;
		}
		m_Chords[k].Bits() &= ~CHORD_COUNT ;
		m_Chords[k].Bits() |= count ;
	}
}

void ChordSelection::SetChordPattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordPattern() = dwPattern;
	}
}

void ChordSelection::SetScalePattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScalePattern() = dwPattern;
	}
}

void ChordSelection::SetChordRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordRoot() = root;
	}
}

void ChordSelection::SetScaleRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = root;
	}
}

void ChordSelection::SetUseFlats(BYTE bFlat, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = bFlat;
	}
}


ChordSelection::ChordSelection()
{
}

BOOL ChordSelection::Equals(ChordSelection *second, int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return FALSE;	// out of range
	}

	BOOL bMatch = TRUE;
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int i = nBegin; bMatch && i < nEnd; i++)
	{
		if(!m_Chords[i].InUse())
		{
			// dont match empty chords
			continue;
		}
		char a = m_Chords[i].ChordRoot();
		char b = second->m_Chords[i].ChordRoot();
		while (a > 11) a -= 12;
		while (b > 11) b -= 12;
		bMatch = ((m_Chords[i].ChordPattern() == second->m_Chords[i].ChordPattern()) && (a == b));
	}
	return bMatch;
}


static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void ChordSelection::RootToString(char *string)
{
	int nSubChord = (int)m_bRootIndex;
	char note = (char)( m_Chords[nSubChord].ChordRoot() % 12 );
	if( m_Chords[nSubChord].UseFlat() )
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)flatconvert[note] ) ;
	else
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)convert[note] ) ;
}

void ChordSelection::GetName(char *string)
{
	char root[20];
	RootToString(root);
	wsprintf(string,"%s %s",root,m_szName);
}



ChordPalette::ChordPalette()
{
	InitChords(TRUE,TRUE,FALSE,FALSE);	// majors on all notes
}

static void autochord(ChordSelection *pchord, short type, short index, int nSubChord)
// this function is obsolete--we're just going to specify major chords and scales (default) here
{
	static long chordpatternarray[8] = {
		0x91,0x89,0x49,0x891,0x491,0x489,0x249,0x449
	};
	static char *namearray[8] = {
		"M","m","o","M7","7","m7","o7",""
	};
	char maj3table[12] = { 0,0,1,0,1,0,0,0,0,1,0,2 } ;
	char min3table[12] = { 1,0,2,0,2,1,2,0,0,2,0,2 } ;
	char maj4table[12] = { 3,6,5,6,5,3,6,4,6,5,3,6 } ;
	char min4table[12] = { 1,3,6,0,6,5,6,4,3,7,4,6 } ;
	static long  scalearray[4] = {0xAB5AB5, //Maj3 
												0x9AD9AD, // min3
												0xAB5AB4, // Maj4
												0x9AD9AD }; // min4

	
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? DMPolyChord::MAX_POLY : nSubChord + 1;
	ChordSelection& chord = *pchord;
	index = 0;	// this disables all the crap above
	for( int i = nBegin; i < nEnd; i++)
	{
		chord[i]->ScalePattern() = scalearray[type];
		if( type == 0 ) {        // major triads.
			index = maj3table[index];
		}
		else if( type == 1 ) {        // minor triads.
			index = min3table[index];
		}
		else if( type == 2 ) {        // major sevenths.
			index = maj4table[index];
		}
		else 
		{ 
			index = min4table[index];
		}
		strcpy(chord.Name(),namearray[index]);
		chord[i]->ChordPattern() = chordpatternarray[index];
	}
}  

void ChordPalette::InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat)

{
	short key;
	short index;
	short type;
	long pattern;
	if (fat) type = 2;
	else type = 0;
	if (major) 
	{
		pattern = 0xAB5AB5; 
	}
	else
	{
		pattern = 0x9AD9AD; 
		type++;
	}
	for( key = 0;  key < 24;  key++ ) 
	{
		index = (short)(key % 12);
		if( pattern & (1 << index)) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else if (allnotes) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else  {
			*m_chords[key].Name() = 0;
			m_chords[key].SetChordPattern(1, DMPolyChord::ALL);
		}
		m_chords[key].SetChordRoot((char) key, DMPolyChord::ALL);
		m_chords[key].SetScaleRoot(0, DMPolyChord::ALL);
		m_chords[key].SetUseFlats((char) flat, DMPolyChord::ALL);
		m_chords[key].SetBits(DMPolyChord::ALL);
	}
} 

ChordEntry::ChordEntry()

{
	DWListItem();
	m_nid = 0;
	m_dwflags = 0;
	m_parent = 0;
	m_page = 0;
	m_nextchordlist.RemoveAll();
}   

void ChordEntry::LoadSmall(OldChordEntry& oce)
{
	m_nid = oce.nid;
	m_dwflags = oce.dwflags;
	m_chordsel.Load(oce);
}

void ChordEntry::LoadExtended(OldChordEntry& oce)
{
	m_page = oce.page;
	memcpy(&m_rect, &oce.rect, sizeof(m_rect));
	LoadSmall(oce);
}

void ChordEntry::LoadFromPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel) = chord;
	m_dwflags = 0;
}

void ChordEntry::SaveToPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(chord) = dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel);
}

void ChordEntry::LoadFromChordItem(CChordItem& chord)
{
	m_chordsel.KeyDown() = chord.IsSelected() ? true : false;
	LoadFromPropChord(dynamic_cast<CPropChord&>(chord));
	if(chord.IsSignPost())
	{
/*
		if(chord.Measure() == 0)
		{
			m_dwflags |= CE_START;
		}
		else
		{
			m_dwflags |= CE_END;
		}
*/
		if(chord.FSelected() & CChordItem::BegSignPost)
		{
			m_dwflags |= CE_START;
		}
		else
		{
			m_dwflags |= CE_END;
		}
	}
}


void ChordEntry::SaveSmall(OldChordEntry& oce)
{
	oce.nid = m_nid;
	oce.dwflags = m_dwflags;
	m_chordsel.Save(oce);
}

void ChordEntry::SaveExtended(OldChordEntry& oce)
{
	oce.page = m_page;
	memcpy(&oce.rect, &m_rect, sizeof(m_rect));
	SaveSmall(oce);
}

void ChordEntry::Debug()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	TRACE("ChordEntry %ls: \n",m_chordsel.Name());
	for (;pnext;)
	{
		pnext->Debug();
		pnext = pnext->GetNext();
	}
}

void ChordEntry::AssignParents()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	for (;pnext;)
	{
		pnext->m_parent = this;
		pnext = pnext->GetNext();
	}
}

ChordEntry::~ChordEntry()

{
	m_nextchordlist.ClearList();
}

void ChordEntry::CleanupNexts()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	BOOL gotone = 0;
	CRect rect( m_rect.left, m_rect.top, m_rect.right, m_rect.bottom );
	rect.left += NEXT_INDENT;
	rect.bottom = rect.top;
	rect.top -= NEXT_HEIGHT;  
	for (;pnext;pnext = pnext->GetNext())
	{
		if (pnext->m_nextchord == NULL) gotone = TRUE;
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		rect.bottom -= NEXT_HEIGHT;
		rect.top -= NEXT_HEIGHT;
	}
	if (gotone) return;
	pnext = new NextChord;
	if (pnext)
	{
		m_nextchordlist.AddTail(pnext);
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		pnext->m_parent = this;
	}
}

void ChordEntry::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	NextChord *pnext;
	char string[50];
	if (page & m_page)
	{
		pnext = m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->Draw(pDC,page);
		}
		if (m_dwflags & CE_SELECTED) 
		{
			if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
		} 
		else if (m_dwflags & CE_PATH)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0xFF))) return;   
		}
		else if (m_dwflags & CE_TREE)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return;   
		}
		else 
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
		}
		pOldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(m_rect.left,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.top);
		if (font.CreateFont(14,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			oldfont = pDC->SelectObject(&font);
			strcpy(string, m_chordsel.Name());
			pDC->TextOut(m_rect.left + 4,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		}      
	//	if (brush.CreateSolidBrush(RGB(0,0,0xFF)))
	//	{
	//		CBrush *pOldBrush;
	//		pOldBrush = pDC->SelectObject(&brush);
			if (m_dwflags & CE_MEASURE)
				pDC->Ellipse(m_rect.right - 14,m_rect.bottom - 4,
							m_rect.right - 4,m_rect.bottom - 14);  
			if (m_dwflags & CE_START)  
			{
				pDC->MoveTo(m_rect.left,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.left + CENTER_Y,m_rect.top); 
			}
			if (m_dwflags & CE_END)  
			{
				pDC->MoveTo(m_rect.right,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.right - CENTER_Y,m_rect.top); 
			}
	//		pDC->SelectObject(pOldBrush);
	//	}
		pDC->SelectObject(pOldPen);
	}
}

void NextChord::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	short cx,cy;
	if (m_dwflags & NC_SELECTED) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
	} 
	else if (m_dwflags & NC_TREE) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return; 
	} 
	else 
	{ 
		if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
	}
	pOldPen = pDC->SelectObject(&pen);
	pDC->MoveTo(m_rect.right,m_rect.bottom);
	pDC->LineTo(m_rect.right,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.bottom);
	if (m_nextchord)
	{
		cx = (short)(m_rect.right - 6);
		cy = (short)((m_rect.top + m_rect.bottom) >> 1);
		pDC->Ellipse(cx - 3,cy - 3,cx + 3, cy + 3);
		if (m_nextchord->m_page & page)
		{
			pDC->MoveTo(cx,cy);
			pDC->LineTo(m_nextchord->m_rect.left,
				(m_nextchord->m_rect.top + m_nextchord->m_rect.bottom) >> 1); 
		}
		if (brush.CreateSolidBrush(RGB(0,0,0)))
		{
			CBrush *pOldBrush; 
			short w = (short)(m_nweight * (m_rect.right - m_rect.left - (CHORD_WIDTH >> 1)));
			w /= 101;
			pOldBrush = pDC->SelectObject(&brush);
			pDC->Rectangle(m_rect.left + 3,m_rect.top + 3,
				m_rect.left + 3 + w,m_rect.bottom - 3);
			pDC->SelectObject(pOldBrush);
		}		
		if (font.CreateFont(10,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			char string[20];
			oldfont = pDC->SelectObject(&font);
			wsprintf(string,"%d:%d",m_nminbeats,m_nmaxbeats);
			cx = (short)(m_rect.right - (CHORD_WIDTH >> 1) + 3);
			pDC->TextOut(cx,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		} 
	}        
	pDC->SelectObject(pOldPen);
}

void NextChord::Debug()

{
	TRACE("NextChord: Flags: %lx, ",m_dwflags);
	if (m_nextchord) TRACE("Connecting to %ls\n",m_nextchord->m_chordsel.Name());
	else TRACE("No connection\n");
}

NextChord::NextChord()

{
	DWListItem();
	m_nextchord = NULL;
	m_nid = 0;
	m_dwflags = 0; 
	m_nweight = 50;
	m_nminbeats = 1;
	m_nmaxbeats = 12; 
}



long totalnext = 0;

void NextList::Save( IStream *pIStream, BOOL bSmall )
{
	NextChord *pnext = GetHead();
	long size;
	if( bSmall )
	{
		size = SmallNextChordFileSize; 
		WriteID( pIStream, ID_NEXTLIST );
	}
	else
	{
	    size = NextChordFileSize;
		WriteID( pIStream, ID_ENEXTLIST );
	}
	WriteSize( pIStream, Size(bSmall) );
	WriteSize( pIStream, size );
	for (;pnext;pnext = pnext->GetNext())
	{
		if( bSmall )
		{
			if (!pnext->m_nextchord) continue;
		}
		pIStream->Write( (void *)&pnext->m_dwflags, (short)size, NULL );
		totalnext++;
	}
}

long NextList::Size(BOOL bSmall)

{
	NextChord *pnext = GetHead();
	long size = 4;
	if( bSmall )
	{
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nextchord) size += SmallNextChordFileSize;
		}
	}
	else size += (GetCount() * NextChordFileSize);
	return(size);
}

void NextList::Load( IStream *pIStream,long lsize)

{
	long lrecordsize = ReadSize( pIStream );
	lsize -= 4;
	ClearList();
	for (;lsize > 0;)
	{
		NextChord *pnext = new NextChord;
		if (pnext)
		{
			pIStream->Read( &pnext->m_dwflags, NextChordFileSize, NULL );
			pnext->SetNext(NULL);
			AddTail(pnext);
		}
		else
		{
			StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
		}
		lsize -= lrecordsize;
	}
}

void NextList::ClearList()

{
	NextChord *pnext = GetHead();
	for (;pnext;)
	{
		NextChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

void ChordEntry::Save( IStream *pIStream, BOOL bSmall )
{
	OldChordEntry oce;
	if (bSmall)
	{
		WriteID( pIStream, ID_CHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, SmallChordEntryFileSize );
		SaveSmall(oce);
		pIStream->Write( &oce, SmallChordEntryFileSize, NULL ); 
	}
	else 
	{
		WriteID( pIStream, ID_ECHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, ChordEntryFileSize );
		SaveExtended(oce);
		pIStream->Write( &oce, ChordEntryFileSize, NULL );
	}
	m_nextchordlist.Save( pIStream,bSmall );
}


long ChordEntry::Size(BOOL bSmall, long version)
{
	if(version == ID_DMCHORDENTRY)
	{
		ASSERT(FALSE);	// not implemented yet
		return 0;
	}
	else
	{
		long lsize = 0; 
		lsize += 4;						// Size of record field. 
		if (bSmall) lsize += SmallChordEntryFileSize;
		else lsize += (ChordEntryFileSize);  
		lsize += (m_nextchordlist.Size(bSmall) + 8);
		return(lsize);
	}
}

ChordEntry *ChordEntry::Load( IStream *pIStream,long lfilesize, long id)

{
	ChordEntry *pchord = new ChordEntry;
	long lrecordsize = ReadSize( pIStream );
	lfilesize -= 4;
	if (pchord)
	{
		if(id == ID_DMCHORDENTRY)
		{
			ASSERT(FALSE);	// not implemented
		}
		else
		{
			OldChordEntry oce;
			pIStream->Read( &oce, lrecordsize, NULL );
			if(id == ID_ECHORDENTRY)
			{
				pchord->LoadExtended(oce);
			}
			else
			{
				pchord->LoadSmall(oce);
			}
			lfilesize -= lrecordsize;
			pchord->m_nextchordlist.RemoveAll();
			for (;lfilesize > 0;)
			{
				long dwid = ReadID( pIStream );
				lrecordsize = ReadSize( pIStream );
				lfilesize -= 8;
				if (dwid == ID_ENEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else if (dwid == ID_NEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else
				{
					StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
				}
				lfilesize -= lrecordsize;
			}
		}
		if (lfilesize) TRACE("ERROR: Chord read leaves filesize at %ld\n",
			lfilesize);
	}
	else
	{
		StreamSeek( pIStream, lfilesize, STREAM_SEEK_CUR );
	}
	return(pchord);		
}

static char drivename[_MAX_DRIVE];
static char dirname[_MAX_DIR];

void SignPost::Save( IStream *pIStream )

{
	WriteID( pIStream, ID_SIGNPOST );
	WriteSize( pIStream, Size() );
	OldChordEntry oce;

	WriteSize( pIStream, 0L);	// must write space for signpost's DWListItem pointer

	WriteSize( pIStream, 0L);	// must write space for chord's DWListItem pointer
	m_chord.Save(oce);
	DWORD size = OldChordEntry::SizeChordSelection();
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[0].Save(oce);
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[1].Save(oce);
	pIStream->Write(&oce, size, NULL);

    pIStream->Write( &m_chords, sizeof(DWORD)*3, NULL );
}

long SignPost::Size(long version)
{
	if(version == ID_DMSIGNPOST)
	{
		ASSERT(FALSE); // not implemented
		return 0;
	}
	else
	{
		long size = OldChordEntry::SizeChordSelection()*(MAX_CADENCE+1);
		size += 3*sizeof(DWORD);
		size += 4*sizeof(void *);
		return size;
	}
}

SignPost *SignPost::Load( IStream *pIStream,long /*lfilesize*/)

{
    SignPost *psignpost = new SignPost;
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	/*
	long id = ReadID(pIStream);
	ReadSize(pIStream);	// move past size record
	if(id == ID_DMSIGNPOST)
	{
		ASSERT(FALSE);	// not implemented
	}
	*/
	OldChordEntry oce;
	DWORD size = OldChordEntry::SizeChordSelection();
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_chord.Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[0].Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[1].Load(oce);
    pIStream->Read( &(psignpost->m_chords), sizeof(DWORD)*3, NULL );
    return(psignpost);      
}

PlayChord::PlayChord()
{
    m_pchord = NULL;
    m_pnext = NULL;
    m_dwflags = 0;
//  m_time = 0;
    m_beat = 0;
    m_measure = 0;
}


void Personality::Load( IStream *pIStream,long /*lfilesize*/, long version)
// load only personality, not contained objects
{
	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
	}
	// else
	DWORD size;
	ReadSize(pIStream);	// Personality is a DWListItem, read past the pointer
	pIStream->Read(&m_chordlist, sizeof(m_chordlist), &size);	// m_chordlist
	pIStream->Read(&m_signpostlist, sizeof(m_signpostlist), &size);
	pIStream->Read(&m_scalepattern, sizeof(m_scalepattern), &size);
	pIStream->Read(&m_name, sizeof(m_name), &size);
	pIStream->Read(&m_description, sizeof(m_description), &size);
	pIStream->Read(&m_username, sizeof(m_username), &size);

	m_chordpalette.Load(pIStream);

	pIStream->Read( &m_dwflags, sizeof(m_dwflags), NULL );
	pIStream->Read( &m_playlist, sizeof(m_playlist), NULL);
	pIStream->Read( &m_pfirstchord, sizeof(m_pfirstchord), NULL);
	pIStream->Read( &m_personref, sizeof(m_personref), NULL);
	pIStream->Read( &m_cx, sizeof(m_cx), NULL);
	pIStream->Read( &m_cy, sizeof(m_cy), NULL);

//		pIStream->Read(pcmap,lrecordsize,NULL);
	m_pfirstchord = NULL;
	m_playlist.RemoveAll();
	m_chordlist.RemoveAll();
	m_signpostlist.RemoveAll();
}

void Personality::InsertChords(short leftedge,DWORD flags)

{
	CRect rect;
	ChordEntryList list;
	ChordEntry *pchord;
   	rect.left = leftedge;
   	rect.right = rect.left + CHORD_WIDTH;
   	rect.bottom = -20;
   	rect.top = rect.bottom - CHORD_HEIGHT;
	BuildNeededChords(&list,flags);
	m_chordlist.Cat(list.GetHead());
	pchord = list.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_rect.top = (short)rect.top;
		pchord->m_rect.left = (short)rect.left;
		pchord->m_rect.right = (short)rect.right;
		pchord->m_rect.bottom = (short)rect.bottom;
		pchord->m_dwflags |= flags;  
		rect.bottom -= (CHORD_HEIGHT * 4);
		rect.top -= (CHORD_HEIGHT * 4);
		pchord->m_parent = this;
		pchord->CleanupNexts(); 
	}
	AssignIDs();
}


static BOOL inchordlist(ChordEntry *plist,ChordSelection *pchord,DWORD flags)

{
	for (;plist;plist = plist->GetNext())
	{
		if (pchord->Equals(&plist->m_chordsel, DMPolyChord::ALL) && (plist->m_dwflags & flags))
		{
			return(TRUE);
		}
	}
	return(FALSE);			
}

static void addchordtolist(ChordEntryList *list,ChordSelection *chord,DWORD flags)

{
	ChordEntry *pchord = new ChordEntry;
	if (pchord)
	{
		pchord->m_chordsel = *chord;
		pchord->m_dwflags = flags;
		list->AddTail(pchord);
	}
}

static void maybeputinlist(
	ChordEntryList *newlist,ChordEntryList *oldlist,
	ChordSelection *pcsel,DWORD flags)

{
	if (!inchordlist(newlist->GetHead(),pcsel,flags))
	{
		if (!inchordlist(oldlist->GetHead(),pcsel,flags))
		{
			addchordtolist(newlist,pcsel,flags);
		}
	}
}

void Personality::BuildNeededChords(ChordEntryList *list,DWORD flags)

{
	SignPost *psign = m_signpostlist.GetHead();
	for (;psign;psign = psign->GetNext())
	{
		maybeputinlist(list,&m_chordlist,&psign->m_chord,flags);
		if (flags & CE_END)
		{
			if (psign->m_dwflags & SPOST_CADENCE1)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[0],flags);
			}
			else if (psign->m_dwflags & SPOST_CADENCE2)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[1],flags);
			}
		}
	}
} 

Personality::Personality()

{
	static short count = 1;
	m_chordlist.RemoveAll();
	m_playlist.RemoveAll(); 
	m_signpostlist.RemoveAll();
	m_scalepattern = 0xAB5AB5; 
	m_description[0] = 0; 
	m_personref.m_stylename[0] = 0;
	m_dwflags = DMUS_CHORDMAPF_VERSION8;
	wsprintf(m_name,"ChordMap %d",count++);
				
}

void PlayList::ClearList()

{
	PlayChord *pnext = GetHead();
	for (;pnext;)
	{
		PlayChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

SignPost::SignPost()
{
    m_chords = 0;
    m_dwflags = SPOST_CADENCE1 | SPOST_CADENCE2;
    m_tempflags = 0;
}

void Personality::AssignIDs()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{ 
		if (!pchord->m_nid) 
		{
			short scan = 1;
			for (scan = 1;;scan++)
			{
				ChordEntry *pscan = m_chordlist.GetHead();   
				for (;pscan;pscan = pscan->GetNext())
				{
					if (pscan->m_nid == scan) break;
				}
				if (!pscan) break;
			}
			pchord->m_nid = scan;
		}
	}
}

void Personality::RenumberIDs()

{
	short nNextID = 1;
	
	// Assign numbers to all chords
	ChordEntry* pchord = m_chordlist.GetHead();  
	for( ;  pchord ;  pchord = pchord->GetNext() )
	{ 
		pchord->m_nid = nNextID++;
	}
	
	// Sync connecting chords
	pchord = m_chordlist.GetHead();  
	for( ;  pchord ;  pchord = pchord->GetNext() )
	{ 
		NextChord* pnext = pchord->m_nextchordlist.GetHead();
		for( ;  pnext ;  pnext = pnext->GetNext() )
		{
			if( pnext->m_nextchord )
			{
				pnext->m_nid = pnext->m_nextchord->m_nid;
			}
		} 
	}
}

void Personality::ResolveConnections()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->m_nextchord = NULL;
		} 
	}
	pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nid)
			{
				ChordEntry *pconnect = m_chordlist.GetHead();   
				for (;pconnect;pconnect = pconnect->GetNext())
				{
                	if (pconnect->m_nid == pnext->m_nid) break;
                }
				pnext->m_nextchord = pconnect;
			}
		} 
	}
}

Personality::~Personality()

{
	ChordEntry *pchord = m_chordlist.GetHead();
	SignPost *psignpost = m_signpostlist.GetHead();
	m_playlist.ClearList();
	for (;pchord;)
	{
		ChordEntry *next = pchord->GetNext();
		delete pchord;
		pchord = next;	
	}
	m_chordlist.RemoveAll();
	for (;psignpost;)
	{
		SignPost *next = psignpost->GetNext();
		delete psignpost;
		psignpost = next;	
	}
	m_signpostlist.RemoveAll();
}

void Personality::Debug()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	TRACE("Chord List:\n");
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Debug();
	}
/*	TRACE("Play List:\n");
	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->Debug();
	}  */
}

void Personality::AssignParents()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_parent = this;
		pchord->AssignParents();
	}
/*	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->m_parent = NULL;
	}  */
}

void Personality::Draw(CDC *pDC,short page)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Draw(pDC,page);
	}
}   

BOOL Personality::IsValidChord(ChordEntry *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord == ptest) return(TRUE);
	}
	return (FALSE);
	
}

BOOL Personality::IsValidNext(NextChord *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext == ptest) return(TRUE);
		}
	}
	return (FALSE);
}

void Personality::ClearChordFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_dwflags &= ~flag;
	}
}

void Personality::ClearNextFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pscan = pchord->m_nextchordlist.GetHead();
		for (;pscan;pscan = pscan->GetNext())
		{
			pscan->m_dwflags &= ~flag;
		}
	}
}


void ChordEntry::MarkTree()

{
	m_dwflags |= CE_TREE;
	NextChord *pscan = m_nextchordlist.GetHead();
	for (;pscan;pscan = pscan->GetNext())
	{
		pscan->MarkTree();
	}
}

void NextChord::MarkTree()

{
	m_dwflags |= NC_TREE;
	if (m_nextchord) m_nextchord->MarkTree();
}

void Personality::MarkTree(ChordEntry *pchord)

{
//	ClearNextFlags(NC_TREE);
//	ClearChordFlags(CE_TREE);
	if (pchord)
	{
		pchord->MarkTree();
	}
}

ChordEntry *Personality::FindXYChord(CPoint point,short page)

{
	CRect crTemp;
	ChordEntry *pchord = m_chordlist.GetHead();

	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			crTemp.left = pchord->m_rect.left;
			crTemp.right = pchord->m_rect.right;
			crTemp.top = pchord->m_rect.top;
			crTemp.bottom = pchord->m_rect.bottom;
//			if (pchord->m_rect.PtInRect(point)) break;
			if (crTemp.PtInRect(point)) break;
		}
	}
	return (pchord);
}

NextChord *Personality::FindXYNext(CPoint point,short page)

{
	CRect crTemp;

	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			NextChord *pnext = (NextChord *) pchord->m_nextchordlist.GetHead();
			for (;pnext;pnext = (NextChord *) pnext->GetNext())
			{
				crTemp.SetRect( pnext->m_rect.left, pnext->m_rect.top,
								pnext->m_rect.right, pnext->m_rect.bottom );
//				if (findall || (pnext->m_dwflags & NC_TREE))
//				{
//					if (pnext->m_rect.PtInRect(point)) return(pnext);  
					if (crTemp.PtInRect(point)) return(pnext);  
//				}
			}   
		}
	}
	return (NULL);
}   

BOOL Personality::GetChord(ChordSelection *pcsel,DWORD flag,short index)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (!index) 
			{
				*pcsel = pchord->m_chordsel; 
				return(TRUE);
			}
			index--;
		}
	}
	return(FALSE);
}

short Personality::GetChordIndex(ChordSelection *pcsel,DWORD flag)

{
	short index = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (pcsel->Equals(&pchord->m_chordsel, DMPolyChord::ALL)) return(index); 
			index++;
		}
	}
	return(0);
}

short Personality::GetChordCount(DWORD flag)

{
	short count = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag) count++;
	}
	return(count);
}

Instruments::Instruments()

{
	static unsigned char defaults[16] = { 73,48,25,0,32,0,0,0,0,0,0,0,0,0,0,0 };
	short i;
	for (i=0;i<16;i++) m_patch[i] = defaults[i]; 
	strcpy(m_name,"new");
	m_default = 0;
}

GrooveName * GrooveNameList::GetGrooveName(DWORD grooveid)

{
	GrooveName *pgroove = GetHead();
	for (;pgroove;pgroove = pgroove->GetNext())
	{
		if (pgroove->m_grooveid == grooveid) break;
	}
	return (pgroove);
}

void GrooveNameList::AddGrooveName(char *name,DWORD grooveid)

{
	GrooveName *pgroove;
	pgroove = new GrooveName;
	if (pgroove)
	{
		strncpy(pgroove->m_name,name,sizeof(pgroove->m_name));
		pgroove->m_grooveid = grooveid;
		AddTail(pgroove);
	}
}

void GrooveNameList::SetDefaults()

{
	AddGrooveName("Relaxed",PF_A);
	AddGrooveName("Medium",PF_B);
	AddGrooveName("Active",PF_C);
	AddGrooveName("Frantic",PF_D);
}
     
void Instruments::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_INSTRUMENTS );
	pIStream->Write( this, sizeof( Instruments ), NULL );
}

long Instruments::Size()

{
	return(sizeof(Instruments));
}

Instruments * Instruments::Load( IStream *pIStream,long /*lfilesize*/)

{
	Instruments *pinst = new Instruments;
	pIStream->Read( pinst, sizeof(Instruments), NULL );
	return(pinst);		
}

GrooveName::GrooveName()

{
	strcpy(m_name,"Duh...");
	m_grooveid = 0;
}

void GrooveName::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_GROOVENAME );
	pIStream->Write(this, sizeof(GrooveName), NULL );
}

long GrooveName::Size()

{
	return(sizeof(GrooveName));
}

GrooveName * GrooveName::Load( IStream *pIStream,long /*lfilesize*/)

{
	GrooveName *pinst = new GrooveName;
	pIStream->Read( pinst, sizeof(GrooveName),NULL );
	return(pinst);		
}


void InstrumentsList::ClearList()

{
	Instruments *pinst;
	while ( (pinst = GetHead()) != 0 )
	{
		Remove(pinst);
		delete pinst;
	}
}

void GrooveNameList::ClearList()

{
	GrooveName *pgroove;
	while ( (pgroove = GetHead()) != 0 )
	{
		Remove(pgroove);
		delete pgroove;
	}
}

void PersonalityList::ClearList()

{
	Personality *map;
	while ( (map = GetHead()) != 0 )
	{
		Remove(map);
		delete map;
	}
}


void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt)
{
	ASSERT(pChordEntry);
	ASSERT(pChordExt);


	*dynamic_cast<DMPolyChord*>(pChordExt) = pChordEntry->m_chordsel;
//	pChordExt->KeyDown() = pChordEntry->KeyDown();
}


long ChordPalette::Size(long version)
{
	if(version == ID_DMCHORDPALETTE)
	{
		return sizeof(ChordPalette);
	}
	else
	{
		return 24 * (sizeof(void*) + OldChordEntry::SizeChordSelection());
	}
}

HRESULT ChordPalette::Save(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			WriteSize(pStream, 0);	// dwlistitem ptr
			m_chords[i].Save(oce);
			hr = pStream->Write(&oce, OldChordEntry::SizeChordSelection(), NULL);
		}
	}
	return hr;
}

HRESULT ChordPalette::Load(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			ReadSize(pStream);	// dwlistitem ptr
			hr = pStream->Read(&oce, OldChordEntry::SizeChordSelection(), NULL);
			m_chords[i].Load(oce);
		}
	}
	return hr;
}




void DMPolyChord::InitLevels()
{
	for(int i = 0; i < MAX_POLY; i++)
	{
		SubChord(i)->Levels() = (1 << i);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordBuilder.h ===
#ifndef CHORDBUILDER_H
#define CHORDBUILDER_H


class ChordBuilder
{
	long m_chordpattern[24];
	char m_chordname[24][20];
public:
	enum {Triad, Seventh, AllMaj, AllMin, AllMaj7, AllMin7, AllDom7};	// types
	ChordBuilder(long scale, int type, int transpose);	// deduce diatonic chords in scale
	ChordBuilder(long pattern, const char* name);	// build identical chords with given pattern and name
	long ChordPattern(int root)	// chord pattern on ith root
	{
		if(-1 < root && root < 24)
		{
			return m_chordpattern[root];
		}
		else
			return -1;
	}
	const char* ChordName(int root)	// chord name on ith root
	{
		if(-1 < root && root < 24)
		{
			return m_chordname[root];
		}
		else
			return 0;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ParamStripMgr\TrackObject.h ===
// TrackObject.h : Declaration of the CTrackMgr

#ifndef __PARAM_OBJECT_H_
#define __PARAM_OBJECT_H_

#include <dmusicf.h>
#include "MedParam.h"
#include "RiffStrm.h"
#include "newparameterdialog.h"

/////////////////////////////////////////////////////////////////////////////
// CTrackObject
class CTrackObject  
{
friend class CTrackMgr;
friend class CParamStrip;

public:
	CTrackObject( CTrackMgr* pTrackMgr );
	~CTrackObject();

	BOOL	IsEmptyTrackObject();
	HRESULT AddStrip(StripInfo* pStripInfo);
	CString GetMinimizedStripText();
	void	RefreshAllStrips();
	CString GetName();
	static	HRESULT GetParamEnumTypeText(GUID guidObject, DWORD dwParamIndex, WCHAR** ppwchParamEnums);
	static	HRESULT ParseEnumText(WCHAR* pwchParamText, CString& sParamName, CString& sUnitLabel, CList<CString, CString&>* plstEnumTypes, DWORD* pdwCount);
	GUID	GetCLSID();
	void	GetObjectHeader(DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER& oObjectHeader);
	void	RefreshObjectProperties();	
	BOOL	IsEqualObject(StripInfo* pStripInfo);
    BOOL    IsEqualObject(GUID guidInstance);
	BOOL	IsDisabled();

protected:
	HRESULT LoadObject( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT SaveObject( IDMUSProdRIFFStream* pIRiffStream );
	void InsertByAscendingParameter( CParamStrip *pParamStrip );
    HRESULT SaveObjectDesignData( IDMUSProdRIFFStream* pIRiffStream );


	// Change of view on param strips
	void OnChangeParamStripView(STRIPVIEW svNewStripView);

	// Performs action on all CParamStrips
	void	AllStrips_OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void* pData );
	void	AllStrips_Invalidate();
	bool	AllStrips_RecomputeTimes(); // Returns true if anything changed
	void	AllStrips_RecomputeMeasureBeats();
	void	AllStrips_AddToTimeline();
	void	AllStrips_RemoveFromTimeline();
	BOOL	AllStrips_SetNbrGridsPerSecond( short nNbrGridsPerSecond );
	void	AllStrips_SwitchTimeBase( void );


	HRESULT	RemoveStripFromTimeline(CParamStrip* pParamStrip);
	HRESULT AddStripToTimeline(CParamStrip* pParamStrip, int nPosition);
	void	DeleteStrip(CParamStrip* pParamStrip);
	HRESULT DeleteAllStrips();
	HRESULT DeleteAllSelectedStrips();
	
	CDMOInfo* CheckListForEqualObject(CPtrList& lstObjects, CTrackObject* pTrackObject);

	// Helpers
	DWORD			GetNumberOfStrips();
	CDMToolInfo*	GetToolInfo(DWORD dwStage, GUID clsidObject);
	CDMOInfo*		GetDMOInfo(CTrackObject* pTrackObject);
	CString			GetToolStageName(DWORD dwStage);
	CString			GetDMOStageName(DWORD dwStage);
	CString			GetPChannelText();
	CString			GetObjectName();


protected:
	// Fields used for UI 
	CTrackMgr*		m_pTrackMgr;

	// Fields that are persisted (DirectMusic parameter control track data)
	CString			m_sObjectName;			// The Object Name
	DWORD			m_dwPChannel;			// PChannel number
	DWORD			m_dwBuffer;				// Buffer index
	DWORD			m_dwEffectIndex;		// EffectIndex
	CString			m_sPChannelText;		// PChannel text for the tool/DMO
	CString			m_sStageName;			// Stage Name
	DWORD			m_dwStage;				// Where object is located
	GUID			m_guidObject;			// GUID of object
    GUID            m_guidInstance;         // GUID for the instance of this DMO
	GUID			m_guidTimeFormat;		// GUID for the timeformat
	DWORD			m_dwObjectIndex;		// index of object
	DWORD			m_dwObjectFlagsDM;		// Various flags pertaining to object
	CParamStrip*	m_pMinimizedStrip;		// minimized strip
	BOOL			m_bDisabled;			// Object doesn't affect the playback


	STRIPVIEW		m_ParamStripView;
	CTypedPtrList<CPtrList, CParamStrip*> m_lstParamStrips;
};


#endif //__PARAM_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Chord.h ===
// chord.h

#include "DWList.h"
#include "chordmapstripmgr.h"
#ifndef __CHORD_H__
#define __CHORD_H__

#pragma pack(1)

#define FIELDOFFSET(s,f)     (long)(& (((s __RPC_FAR *)0)->f))


#define MakeID(a,b,c,d)  ( (LONG)(a)<<24L | (LONG)(b)<<16L | (c)<<8 | (d) )

#define ID_CHORDENTRY   MakeID('s','C','E','N')
#define ID_NEXTLIST     MakeID('s','N','X','L')
#define ID_PERSONALITY  MakeID('s','P','E','R')
#define ID_PERSONREF    MakeID('s','P','R','F')
#define ID_NEWSTYLE     MakeID('s','S','T','Y')
#define ID_CHORDPALETTE MakeID('s','C','P','L')
#define ID_TEMPLATE     MakeID('s','T','P','L')
#define ID_TEMPLATELIST MakeID('s','T','L','S')
#define ID_SIGNPOST     MakeID('s','S','N','P')
#define ID_INSTRUMENTS  MakeID('s','I','N','S')
#define ID_COMMAND      MakeID('s','C','M','D')
#define ID_GROOVENAME   MakeID('s','G','R','N')

// Large versions for editing:
#define ID_EPERSONALITY MakeID('s','C','M','P')
#define ID_ECHORDENTRY  MakeID('e','C','E','N')
#define ID_ENEXTLIST    MakeID('e','N','X','L')
#define ID_ESTYLE       MakeID('e','S','T','Y')
#define ID_EPERSONREF   MakeID('e','P','R','F')

// new DM ids
#define ID_DMCHORDENTRY		MakeID('x','C','E','N')
#define ID_DMNEXTLIST		MakeID('x','N','X','L')
#define ID_DMSIGNPOST		MakeID('x','S','N','P')
#define ID_DMCHORDPALETTE	MakeID('x','C','P','L')
#define ID_DMPERSONALITY	MakeID('x','P','E','R')

// extended version for Jazz
#define ID_JPERSONALITY MakeID('j','C','M','P')
#define ID_J4PERSONALITY MakeID('4', 'C', 'M', 'P')
#define ID_J5PERSONALITY MakeID('5', 'C', 'M', 'P')

/*  SCTchord bBits flags ===============================================*/
#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

#define CHORD_KEYDOWN 0x8000/* chord is selected (used in upper bit of ioChordEntryEdit::page) */
#define CHORD_CONNECTION_TOCHORD 0x4000 /* chord is "to" part of a connection */
#define CHORD_CONNECTION_FROMCHORD 0x2000 /* chord is "from" part of a connection */

// enums for selection type (matches Chordmapmgr enums
#define CHORD_NO_SELECTION						0
#define CHORD_PALETTE_SELECTED					1
#define CHORD_MAP_SELECTED							2
#define CHORD_CONNECTION_SELECTED			3


#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

void swaplong(char data[]);
void WriteID( IStream *pIStream, DWORD id );
void WriteSize( IStream *pIStream, long size );
long ReadID( IStream *pIStream );
long ReadSize( IStream *pIStream );


inline long Rotate24(long val, long shift)
{
	__int64 mask64 = 0xffffff;
	__int64 val64 = val;

	ASSERT(shift > -24 && shift < 24);
	if(shift < 0)
	{
		shift = 24 + shift;
	}
	val64 = (val64 & mask64) << shift;
	__int64 excess = (val64 >> 24) & mask64;	// rotate
	val64 |= (excess & ~(1<<shift));
	val =  long(val64 & mask64);
	return val;
}


inline unsigned long Canonical24(unsigned long pattern, unsigned long root)
//
// convert pattern (scale or chord) to a canonical representation where octave 
// equivalences are filled in.
//
{
	if(!(pattern & 0xf00000))
	{
		// dup at octave
		pattern |= pattern << 12;
	}
	pattern = Rotate24(pattern, root%12);
	// fill in lower bits
	pattern |= pattern>>12;
	return pattern;
}

inline DWORD BlueBits(DWORD& cp, DWORD cr, DWORD& sp, DWORD sr, bool bReturnCanonicalForm = true)
// ~(chord -> scale) = ~(scale | ~chord) = ~scale & chord
{
	DWORD scale, chord;
	scale = Canonical24(sp,sr);
	chord = Canonical24(cp,cr);
	DWORD pattern = ~scale  & chord;
	if(bReturnCanonicalForm)
	{
		sp = scale;
		cp = chord;
	}
	return pattern;
}


inline bool InScale(char root, long chordpattern, long scalepattern)
{
	bool match = (Rotate24(chordpattern, (long)root) | scalepattern) == scalepattern;
	return match;
}


// structs for loading old personalities
struct OldChordEntry
{
	// ChordSelection = 38
	long time;
	long pattern;
	char name[12];
	char keydown;
	char root;
	char inscale;
	char flat;
	short varflags;
	short measure;
	char beat;
	BYTE bits;
	long scalepattern;
	long melodypattern;
	// SmallChordEntry = 44
	DWORD dwflags;
	short nid;
	// extended = 54
	short rect[4];
	short page;
	static DWORD	SizeExtendedChordEntry();
	static DWORD	SizeChordSelection();
	static DWORD	SizeSmallChordEntry();
};

struct OldNextChord
{
	// small
	DWORD	dwflags;
	short	nweight;
	short	nminbeats;
	short	nmaxbeats;
	short	nid;
	// extended
	short	rect[4];
};

// DM structures
// DMChord represents a subchord in a multi chord structure
class DMPolyChord;
class DMChord
{
	DWORD	m_dwChordPattern;
	DWORD	m_dwScalePattern;
	DWORD	m_dwInvertPattern;
	DWORD	m_dwLevels;		// which levels of multi chord this subchord supports
	WORD	m_wFlags;
	BYTE	m_bChordRoot;
	BYTE	m_bScaleRoot;
	BYTE	m_bFlat;
	BYTE	m_bBits;
	bool	m_bInUse;
public:
	DWORD&	ChordPattern()
	{
		return m_dwChordPattern;
	}
	DWORD ChordPattern() const
	{
		return m_dwChordPattern;
	}
	DWORD&	ScalePattern()
	{
		return m_dwScalePattern;
	}
	DWORD	ScalePattern() const
	{
		return m_dwScalePattern;
	}
	DWORD&	InvertPattern()
	{
		return m_dwInvertPattern;
	}
	DWORD	InvertPattern() const
	{
		return m_dwInvertPattern;
	}
	DWORD& Levels()
	{
		return m_dwLevels;
	}
	DWORD Levels() const
	{
		return m_dwLevels;
	}
	WORD&	Flags()
	{
		return m_wFlags;
	}
	WORD	Flags() const
	{
		return m_wFlags;
	}
	BYTE&	ChordRoot()
	{
		return m_bChordRoot;
	}
	BYTE	ChordRoot() const
	{
		return m_bChordRoot;
	}
	BYTE&	ScaleRoot()
	{
		return m_bScaleRoot;
	}
	BYTE	ScaleRoot() const
	{
		return m_bScaleRoot;
	}
	BYTE&	UseFlat()
	{
		return m_bFlat;
	}
	BYTE	UseFlat() const
	{
		return m_bFlat;
	}
	BYTE&	Bits()
	{
		return m_bBits;
	}
	BYTE	Bits() const
	{
		return m_bBits;
	}
	bool&	InUse()
	{
		return m_bInUse;
	}
	bool	InUse() const
	{
		return m_bInUse;
	}
	DMChord();
	DMChord(const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
	}
	DMChord& operator = (const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
		return *this;
	}
	int BassNote();
	int Third(int * bass);
	int Fifth(int * bass, int * third);
	int Seventh(int* bass, int* third, int* fifth);
	void ChordNotes(int& bass, int& third, int& fifth, int& seventh);
	int NoteCount();	// number of notes in chord
};

// DMPolyChord represents a multi chord
class DMPolyChord
{
public:
	void InitLevels();
	enum { ALL = -1, MAX_POLY = 4, MAX_NAME = 12 };
	DMPolyChord();
	DMPolyChord(const DMPolyChord&);
	DMChord* const	operator[] (int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DMChord* const SubChord(int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DWORD&	Time()
	{
		return m_dwTime;
	}
	DWORD	Time() const
	{
		return m_dwTime;
	}
	short&	Measure()
	{
		return m_nMeasure;
	}
	short Measure() const
	{
		return m_nMeasure;
	}
	BYTE&	Beat()
	{
		return m_bBeat;
	}
	BYTE	Beat() const
	{
		return m_bBeat;
	}
	TCHAR* const Name()
	{
		return m_szName;
	}
	DMPolyChord& operator = (const DMPolyChord&);
	BYTE& RootIndex()
	{
		return m_bRootIndex;
	}
	void Load(OldChordEntry& oce);
	void Save(OldChordEntry& oce);
	bool& KeyDown() 
	{
		return m_keydown;
	}
	// some convenience funcs for old code
	DMChord* const Base()
	{
		return SubChord(m_bRootIndex);
	}
	DMChord* operator->()
	{
		return Base();
	}

	void SetBase(int v)
	{
		m_bRootIndex = static_cast<BYTE>(v);
	}

	// mass copy functions, from base to other subchords
	void PropagateChordPattern();
	void PropagateScalePattern();
	void PropagateInvertPattern();
	void PropagateLevels();
	void PropagateFlags();
	void PropagateChordRoot();
	void PropagateScaleRoot();
	void PropagateUseFlat();
	void PropagateBits();
	void PropagateInUse();
	void PropagateAll();

protected:
	DMChord	m_Chords[MAX_POLY];
	DWORD	m_dwTime;
	short	m_nMeasure;
	BYTE	m_bBeat;
	BYTE	m_bRootIndex;	// identifies which chord in m_Chords is the root
	TCHAR	m_szName[12];
	bool	m_keydown;
};




class ChordSelection : public DWListItem, public DMPolyChord {
public:
            ChordSelection();
    void    SetBits(int nSubChord);		// nSubChord == -1 --> match all subchords
    BOOL    Equals(ChordSelection *second, int nSubChord);	// nSubChord == -1 --> match all subchords
    void    GetName(char *string);
    void    RootToString(char *string); // Convert from root to text name.

	void SetChordPattern(DWORD dwPattern, int nSubChord);
	void SetScalePattern(DWORD dwPattern, int nSubChord);
	void SetChordRoot(BYTE root, int nSubChord);
	void SetScaleRoot(BYTE root, int nSubChord);
	void SetUseFlats(BYTE bFlat, int nSubChord);
};


#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

#define CHORD_WIDTH     80
#define CHORD_HEIGHT    26
#define CENTER_X        (CHORD_WIDTH >> 1)
#define CENTER_Y        (CHORD_HEIGHT >> 1)
#define NEXT_HEIGHT     14
#define NEXT_INDENT     10

class Personality;
//class MyFile;
class NextChord;
class SearchInfo;

class NextList : public DWList {
public:
    NextChord *     GetHead() { return(NextChord*)DWList::GetHead();};
    void            ClearList();
    void			Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall);
    void            Load( IStream *pIStream,long lsize);
};

class SmallChordEntry : public DWListItem {
public:
    NextList        m_nextchordlist;// List of chords to go to next.
    ChordSelection  m_chordsel;     // Chord definition.
    unsigned long   m_dwflags;      // Various flags.
    short           m_nid;          // ID for pointer maintenance.
};


#define SmallChordEntryFileSize (OldChordEntry::SizeSmallChordEntry())

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

#define CE_MATCHED			(1 << 8)	// if signpost chord, indicates chord is matched by chord in signpost list
#define CE_DRAGSELECT		(1 << 9)
#define CE_DROPSELECT		(1 << 10)

class CChordItem;
class CPropChord;
class ChordEntry : public SmallChordEntry {
public:
                    ChordEntry();
                    ~ChordEntry();
	bool			IsSignPost()
	{
		return (m_dwflags & CE_START) || (m_dwflags & CE_END);
	}

    ChordEntry *    GetNext(){ return (ChordEntry *)(DWListItem::GetNext()); };
    void            Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall, long version = 0);
    static ChordEntry * Load( IStream *pIStream,long filesize, long id);
    void            Draw(CDC *pDC,short page);
    void            CleanupNexts();
	void			LoadSmall(OldChordEntry& oce);
	void			LoadExtended(OldChordEntry& oce);
	void			SaveSmall(OldChordEntry& oce);
	void			SaveExtended(OldChordEntry& oce);
    void            Debug();
    void            AssignParents();
    void            MarkTree();
	void			LoadFromChordItem(CChordItem&);
	void			LoadFromPropChord(CPropChord& chord);
	void			SaveToPropChord(CPropChord& chord);
    struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    short           m_page;
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_lastrect;
    Personality     *m_parent;      // The parent chord map.
};

#define ChordEntryFileSize (OldChordEntry::SizeExtendedChordEntry())

class ChordEntryList : public DWList {
public:
    ChordEntry *    GetHead() {return(ChordEntry *)DWList::GetHead();};
	ChordEntry *	RemoveHead() {return (ChordEntry *)DWList::RemoveHead();};
};

#define PAGE_1      1
#define PAGE_2      2
#define PAGE_3      4
#define PAGE_4      8
#define PAGE_5      0x10
#define PAGE_6      0x20
#define PAGE_7      0x40
#define PAGE_8      0x80




class SmallNextChord : public DWListItem {
public:
    ChordEntry      *m_nextchord;   // Destination chord.
    unsigned long   m_dwflags;
    short           m_nweight;      // Importance of destination chord.
    short           m_nminbeats;    // Min beats to wait till chord.
    short           m_nmaxbeats;    // Max beats to wait till chord.
    short           m_nid;          // ID of destination chord.
};

#define SmallNextChordFileSize (sizeof(SmallNextChord) - sizeof(ChordEntry *))

class NextChord : public SmallNextChord {
public:
                    NextChord();
    NextChord *     GetNext() {return(NextChord *)DWListItem::GetNext();};
    void            Debug();
    void            MarkTree();
    void            Draw(CDC *pDC,short page);
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    ChordEntry      *m_parent;      // Source chord.
};

#define NextChordFileSize (SmallNextChordFileSize + sizeof(ChordEntry *))

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.

class TempCommand;
class PlayChord;

class FailSearch {
public:
                    FailSearch()
                    {
                        m_toomanybeats = 0;
                        m_toofewbeats = 0;
                        m_toomanychords = 0;
                        m_toofewchords = 0;
                    }
    short           m_toomanybeats;
    short           m_toofewbeats;
    short           m_toomanychords;
    short           m_toofewchords;
};

class SearchInfo {
public:
                    SearchInfo()
                    {
                        m_pfirstchord = NULL;
                        m_pplaychord = NULL;
                    };
    ChordSelection  m_start;
    ChordSelection  m_end;
    PlayChord *     m_pplaychord;
    ChordEntry *    m_pfirstchord;
    short           m_beats;
    short           m_minbeats;
    short           m_maxbeats;
    short           m_chords;
    short           m_minchords;
    short           m_maxchords;
    short           m_activity;
    FailSearch      m_fail;
};

#define ACTIVITY_SLOW   2
#define ACTIVITY_MEDIUM 1
#define ACTIVITY_FAST   0

class ChordPalette {
public:
                    ChordPalette();
    void            InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat);
	HRESULT			Load(IStream* pStream, long version = 0);
	HRESULT			Save(IStream*, long version = 0);
	static long		Size(long version);
	ChordSelection&	Chord(int i) { return m_chords[i]; }
    ChordSelection  m_chords[24];
};



#define PF_FILL     1           /* Fill pattern.                    */
#define PF_INTRO    2
#define PF_WHOLE    4           /* Handles chords on measures.      */
#define PF_HALF     8           /* Chords every two beats.          */
#define PF_QUARTER  0x10        /* Chords on beats.                 */
#define PF_BREAK    0x20
#define PF_END      0x40
#define PF_A        0x80
#define PF_B        0x100
#define PF_C        0x200
#define PF_D        0x400
#define PF_E        0x800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_BEATS    (PF_WHOLE | PF_HALF | PF_QUARTER)
#define PF_RIFF     (PF_INTRO | PF_BREAK | PF_FILL | PF_END)
#define PF_GROOVE   (PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H)

#define SP_A        1
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

// Structure shape:

#define STR_FALLING     1
#define STR_LEVEL       2
#define STR_LOOPABLE    3
#define STR_LOUD        4
#define STR_QUIET       5
#define STR_PEAKING     6
#define STR_RANDOM      7
#define STR_RISING      8
#define STR_SONG        9  

class SignPost : public DWListItem {
public:
	enum { MAX_CADENCE = 2 };
                    SignPost();
    SignPost *      GetNext() {return(SignPost *) DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    static long            Size(long version = 0);
    static SignPost *Load( IStream *pIStream,long lsize);
    ChordSelection  m_chord;            // Chord for sign post.
    ChordSelection  m_cadence[MAX_CADENCE];       // Chords for cadence.
    DWORD           m_chords;       // Which kinds of signpost supported.
    DWORD           m_dwflags;
    DWORD           m_tempflags;
};

class SignPostList : public IndexList {
public:
    SignPost *      GetHead() {return(SignPost *) IndexList::GetHead();};
};


#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

#define	SPOST_MATCHED	(1 << 8)	// indicates matched by signpost chord in chordmap

class PlayChord : public DWListItem {
public:
                    PlayChord();
    PlayChord *     GetNext() {return (PlayChord *)DWListItem::GetNext();};
    ChordSelection *m_pchord;       // Chord to perform.
    NextChord *     m_pnext;        // Transition pointer to chord.
    unsigned long   m_dwflags;
    short           m_measure;
    short           m_beat;
    short           m_minbeats;
    short           m_maxbeats;
};

class PlayList : public DWList {
public:
    void            ClearList();
    PlayChord *     GetHead() {return(PlayChord *) DWList::GetHead();};
};


class PersonalityRef {
public:
    char            m_stylename[20];// Unique name for UI display.
    char            m_name[20];     // Personality name for internal use.
    char            m_filename[9];  // Unique name for file.
    char            m_isdefault;    // Set for default personality.
};

class Personality : public DWListItem {
public:
                    Personality();
                    ~Personality();
    Personality *   GetNext() {return(Personality *)DWListItem::GetNext();};

    void			Load( IStream *pIStream,long lsize, long version = 0); // load just personality

    void            Debug();
    void            AssignParents();
    void            Draw(CDC *pDC,short page);
    void            MarkTree(ChordEntry *pchord);
    BOOL            IsValidChord(ChordEntry *ptest);
    BOOL            IsValidNext(NextChord *ptest);
    void            ClearChordFlags(unsigned long flag);
    void            ClearNextFlags(unsigned long flag);
    ChordEntry *    FindXYChord(CPoint point,short page);
    NextChord *     FindXYNext(CPoint point,short page);
    void            AssignIDs();    // Make sure all chords have IDs.
    void            RenumberIDs();    // Renumber all IDs.
    void            ResolveConnections(); // Resolve pointers.
    BOOL            GetChord(ChordSelection *pchord,DWORD flag,short index);
    short             GetChordCount(DWORD flag);
    short             GetChordIndex(ChordSelection *pcsel,DWORD flag);
    void            InsertChords(short leftedge,DWORD flags);
    void            BuildNeededChords(ChordEntryList *list,DWORD flags);
    ChordEntryList  m_chordlist;    // All chords in the map.
    SignPostList    m_signpostlist; // All available sign posts.
    long            m_scalepattern; // Scale for map.
    char            m_name[20];     // ID Name (not used by application.) Musical Name
    char            m_description[80];
    char			m_username[20]; // Generic name for display.
    ChordPalette    m_chordpalette; // Palette of Chords for static Map.
	unsigned long   m_dwflags;
    PlayList        m_playlist;     // Collection of NextChords for playback.
    ChordEntry *    m_pfirstchord;
    PersonalityRef  m_personref;    // Used to track name and file io.
    short			m_cx;
	short			m_cy;				// CSize           m_size;
};

class PersonalityList : public IndexList {
public:
    Personality *   GetHead() {return(Personality *) IndexList::GetHead();};
    Personality *   GetIndexedItem()
                    {
                        return(Personality *) IndexList::GetIndexedItem();
                    };
    void            ClearList();
};

#define INST_LEAD       0
#define INST_STRINGS    1
#define INST_GUITAR     2
#define INST_PIANO      3
#define INST_BASS       4
#define INST_DRUMS      5


class Instruments : public DWListItem {
public:
                    Instruments();
    Instruments *   GetNext() {return(Instruments *)DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    long            Size();
    static Instruments * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    unsigned char   m_patch[16];
    char            m_default;
};

class InstrumentsList : public DWList {
public:
    Instruments *   GetHead() {return(Instruments *) DWList::GetHead();};
    void            ClearList();
};

class GrooveName : public DWListItem {
public:
                    GrooveName();
    GrooveName *    GetNext() {return(GrooveName *)DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    long            Size();
    static GrooveName * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    DWORD           m_grooveid;
};

class GrooveNameList : public DWList {
public:
    GrooveName *    GetHead() {return(GrooveName *) DWList::GetHead();};
    void            ClearList();
    void            SetDefaults();
    void            AddGrooveName(char *name,DWORD grooveid);
    GrooveName *    GetGrooveName(DWORD grooveid);
};

class ChordChangeCallback : public IUnknown
{
public:

	ChordChangeCallback() : m_pChordEntry(0), m_callbackType(Unknown), m_dwRef(0) { AddRef();}
	ChordChangeCallback(int ct) : m_pChordEntry(0), m_callbackType(ct), m_dwRef(0) { AddRef();}
	~ChordChangeCallback();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// callback info determination
	enum   { Unknown, ChordMapNewSelection,  ParentShowProps};

//	void SetCallbackType(CallbackType ct) { m_callbackType = ct; }
	int GetCallbackType() { return m_callbackType; }

	void SetChordEntry(ChordEntry* pChordEntry) {ASSERT(pChordEntry); 
											   m_pChordEntry = pChordEntry;}

	ChordEntry* GetChordEntry() {return m_pChordEntry;}
	
private:
	ChordEntry* m_pChordEntry;
	int m_callbackType;
	DWORD		m_dwRef;
};

class PreEditNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	PreEditNotification(CString reason) : m_strReason(reason), m_dwRef(0)
	{
		AddRef();
	}

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	CString	m_strReason;
};

// sent when chordmap detects that orphan status of chords or signposts may need to be rechecked
class CheckForOrphansNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	CheckForOrphansNotification() 
		: m_dwRef(0)
	{
		AddRef();
	}

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
};

// sent when chordmap notifies personality of change of zoom
class ZoomChangeNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	ZoomChangeNotification() 
		: m_dwRef(0)
	{
		AddRef();
	}

	double m_dblZoom;

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppvObj )
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		if(::IsEqualIID(riid, IID_IUnknown))
		{
			AddRef();
			*ppvObj = this;
			return S_OK;
		}

		if(::IsEqualIID(riid, IID_ZoomChangeNotification))
		{
			AddRef();
			*ppvObj = this;
			return S_OK;
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;

	}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
};


//////////////////////////////////////////
// ChordExt Structure
// Used to store a Section's single linked chord list.
// Use: CSection::m_paChordChanges.
class ChordExt	: public DMPolyChord
{
//	bool		m_keydown;
public:
	ChordExt()
	{
		m_keydown = false;
		pNext = 0;
	}
    ChordExt		*pNext;
//	bool& KeyDown()
//	{
//		return m_keydown;
//	}
};

typedef struct CommandExt
{
    CommandExt* pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;



void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt);

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordDatabase.cpp ===
#include "stdafx.h"
#include <afxtempl.h>
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#pragma warning(default:4201)
#include "StyleDesigner.h"
#include "Personality.h"
#include "RiffStructs.h"					// Definition of ioPersonality.
#include "ChordDatabase.h"

HRESULT DMLoadChordData(ChordEntryList& chordEntryList, IStream* pIStream)
{
	MMCKINFO		ck;
	HRESULT			hr=S_OK;

	DMSubChordSet subchords;
	bool bDMSubChordSetRead = false;
	bool bDMChordMapRead = false;

	IDMUSProdRIFFStream* pIRiffStream;;
	ASSERT( pIStream != NULL );

	hr = AllocRIFFStream(pIStream, &pIRiffStream);



	while(SUCCEEDED(hr) && pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_SUBCHORD:			
			hr = subchords.Read(pIRiffStream, &ck);
			bDMSubChordSetRead = true;
			if(FAILED(hr))
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			break;

		case FOURCC_CHORDENTRYEDIT:
			ASSERT(bDMChordMapRead);
			if(bDMChordMapRead)
			{
				hr = ReadChordEntryEditChunk(pIRiffStream, &chordEntryList, &ck);
			}
			break;

		case FOURCC_LIST:
			switch( ck.fccType )
			{

/*
			case FOURCC_LISTCHORDPALETTE:
				{
					ChordPaletteList chordpalette;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordpalette.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordpalette.Insert(m_pPersonality->m_chordpalette, subchords);
				}
				break;
*/
			case FOURCC_LISTCHORDMAP:
				{
					ChordMapList chordmap;
 					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordmap.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordmap.Insert(chordEntryList, subchords);
				}
				bDMChordMapRead = true;
				break;
/*
			case FOURCC_SIGNPOSTLIST:
				{
					SignPostListChunk signposts;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = signposts.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					signposts.Insert(m_pPersonality->m_signpostlist, subchords);
				}
				break;
*/
			}
		}
        pIRiffStream->Ascend( &ck, 0 );
    }


ON_ERR:
    if ( pIRiffStream != NULL )
	{
		pIRiffStream->Release();
	}

    return hr;
}


/////////////////////////////////////////////// SignPostChunk members
//
SignPostChunk::SignPostChunk(const SignPost* pSignPost)
{
	dwFlags = pSignPost->m_dwflags;
	dwChords = pSignPost->m_chords;
}

HRESULT SignPostChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;
	// Write SignPost chunk header
	WriteChunk chunk(pRiffStream, FOURCC_IOSIGNPOST);
	hr = chunk.State();
	if(  hr  == 0 )
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );

		// Write Signpost chunk data
		hr = pIStream->Write( this, sizeof(SignPostChunk), &dwBytesWritten) == 0
			&& dwBytesWritten == sizeof(ioSignPost) ? S_OK : E_FAIL;
	    pIStream->Release();
	}
    return hr;
}

HRESULT SignPostChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	HRESULT hr;
	DWORD dwBytesRead;
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	hr = pIStream->Read(this, sizeof(SignPostChunk), &dwBytesRead) == 0
		&& dwBytesRead == sizeof(ioSignPost) ? S_OK : E_FAIL;
	pIStream->Release();
	return hr;
}

HRESULT SignPostChunk::Extract(const SignPost* pSignPost)
{
	ASSERT(pSignPost);
	if(!pSignPost)
		return E_INVALIDARG;

	dwFlags = pSignPost->m_dwflags;
	dwChords = pSignPost->m_chords;

	return S_OK;
}

HRESULT  SignPostChunk::Insert(SignPost* pSignPost)
{
	ASSERT(pSignPost);
	if(!pSignPost)
		return E_INVALIDARG;

	pSignPost->m_dwflags = dwFlags;
	pSignPost->m_chords = dwChords;

	return S_OK;
}

//////////////////////////////////////////// NextChordChunk members
//
NextChordChunk::NextChordChunk(const NextChord* pNext)
{
	dwFlags = pNext->m_dwflags;
	nWeight = pNext->m_nweight;
	wMinBeats = pNext->m_nminbeats;
	wMaxBeats = pNext->m_nmaxbeats;
	wConnectionID = pNext->m_nid;
}

HRESULT NextChordChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;
	
	ASSERT(pRiffStream);

// Deliberitely commented out
//	WriteChunk chunk(pRiffStream, FOURCC_IONEXTCHORD);
//	hr = chunk.State();
	if( hr == S_OK )
	{

	    pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );

		// Write NextChord chunk data
		hr = pIStream->Write( this, sizeof(NextChordChunk), &dwBytesWritten) == 0
			&& dwBytesWritten == sizeof(ioNextChord) ? S_OK : E_FAIL;

	    pIStream->Release();
	}

    return hr;
}

HRESULT NextChordChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;
	
	ASSERT(pIRiffStream);

	pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	hr = pIStream->Read(this, sizeof(NextChordChunk), &dwBytesRead) == 0
		&& dwBytesRead == sizeof(ioNextChord) ? S_OK : E_FAIL;
	pIStream->Release();
	return hr;
}

HRESULT NextChordChunk::Extract(const NextChord* pNext)
{
	dwFlags = pNext->m_dwflags;
	nWeight = pNext->m_nweight;
	wMinBeats = pNext->m_nminbeats;
	wMaxBeats = pNext->m_nmaxbeats;
	wConnectionID = pNext->m_nid;
	return S_OK;
}

HRESULT NextChordChunk::Insert( NextChord* pNext)
{
	pNext->m_dwflags = dwFlags;
	pNext->m_nweight = nWeight;
	pNext->m_nminbeats = wMinBeats;
	pNext->m_nmaxbeats = wMaxBeats;
	pNext->m_nid = wConnectionID;
	return S_OK;
}

//////////////////////////////////////////////// ChordEntryChunk members
//
ChordEntryChunk::ChordEntryChunk(const ChordEntry* pChord)
{
	dwFlags = pChord->m_dwflags;
	wConnectionID = pChord->m_nid;
}

HRESULT ChordEntryChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;

	ASSERT(pRiffStream);

	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRY);
	hr = chunk.State();

	if(hr == 0)
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		// Write ChordEntry chunk data
		hr = pIStream->Write( this, sizeof(ChordEntryChunk), &dwBytesWritten)
				&&  dwBytesWritten == sizeof(ioChordEntry);
		pIStream->Release();
	}

    return hr;
}

HRESULT ChordEntryChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;

	ASSERT(pIRiffStream);
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	hr = (pIStream->Read( this, sizeof(ChordEntryChunk), &dwBytesRead) == 0
		&&  dwBytesRead == sizeof(ioChordEntry)) ? S_OK : E_FAIL;
	pIStream->Release();

    return hr;
}

HRESULT ChordEntryChunk::Extract(const ChordEntry* pChord)
{
	dwFlags = pChord->m_dwflags;
	wConnectionID = pChord->m_nid;
	return S_OK;
}

HRESULT ChordEntryChunk::Insert( ChordEntry* pChord)
{
	pChord->m_dwflags = dwFlags;
	pChord->m_nid = wConnectionID;
	return S_OK;
}

///////////////////////////////////////////////// ChordEntryEdit helpers
//
HRESULT WriteChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist)
{
	ASSERT(pRiffStream);
	ASSERT(plist);
	if(pRiffStream == NULL || plist == NULL)
	{
		return E_INVALIDARG;
	}
	if(plist->GetHead() == NULL)
	{
		// nothing to do
		return S_OK;
	}
	IStream* pStream = pRiffStream->GetStream();
	ASSERT(pStream);
	if(pStream == NULL)
	{
		return E_FAIL;
	}

	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRYEDIT);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		DWORD size = sizeof(ChordEntryEditChunk);
		hr = pStream->Write(&size, sizeof(DWORD), 0);
		ChordEntry* pChord = plist->GetHead();
		while(pChord != NULL && hr == S_OK)
		{
			ChordEntryEditChunk chunk(pChord);
			chunk.Write(pRiffStream);
			pChord = pChord->GetNext();
		}
	}
	pStream->Release();
	return hr;
}

HRESULT ReadChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist, MMCKINFO* pckInfo)
{
	ASSERT(pRiffStream);
	ASSERT(pckInfo);
	ASSERT(plist);
	if(pRiffStream == NULL || pckInfo == NULL || plist == NULL)
	{
		return E_INVALIDARG;
	}
	IStream* pStream = pRiffStream->GetStream();
	ASSERT(pStream);
	if(pStream == NULL)
	{
		return E_FAIL;
	}
	
	CMap<short,short, ChordEntryEditChunk, ChordEntryEditChunk&> chunkmap;
	DWORD size, cbSize;
	HRESULT hr = pStream->Read(&size, sizeof(DWORD), &cbSize);
	ASSERT(size == sizeof(ChordEntryEditChunk));
	DWORD count = (pckInfo->cksize - sizeof(DWORD)) / size;
	if(hr == S_OK && size == sizeof(ChordEntryEditChunk))
	{
		// read in edit chunks
		for(DWORD i = 0; hr == S_OK && i < count; i++)
		{
			ChordEntryEditChunk chunk;
			hr = chunk.Read(pRiffStream);
			chunkmap.SetAt(chunk.wConnectionId, chunk);
		}
	}
	ASSERT(hr == S_OK);
	if(hr == S_OK)
	{
		// assign positional coords to chordentries
		for(ChordEntry* pChord = plist->GetHead(); pChord; pChord = pChord->GetNext())
		{
			ChordEntryEditChunk chunk;
			if(chunkmap.Lookup(pChord->m_nid, chunk))
			{
				chunk.Insert(pChord);
			}
			else
			{
				hr = E_FAIL;
				break;
			}
		}
	}
	pStream->Release();
	return hr;
}

//////////////////////////////////////////////// ChordEntryEditChunk members
//
ChordEntryEditChunk::ChordEntryEditChunk(const ChordEntry* pChord)
{
	ChordSelection* psel = &(const_cast<ChordEntry*>(pChord)->m_chordsel);

	for(int i = 0; i < MaxSubChords; i++)
	{
		bBits[i] = psel->SubChord(i)->Bits();
		bUseFlat[i] = psel->SubChord(i)->UseFlat();
	}
	wMeasure = psel->Measure();
	bBeat = psel->Beat();
	wConnectionId = pChord->m_nid;
	left = pChord->m_rect.left;
	top = pChord->m_rect.top;
	right = pChord->m_rect.right;
	bottom = pChord->m_rect.bottom;
	page = pChord->m_page;
	if(psel->KeyDown())
	{
		page |= CHORD_KEYDOWN;
	}
	else
	{
		page &= ~CHORD_KEYDOWN;
	}
}

HRESULT ChordEntryEditChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;

	ASSERT(pRiffStream);

// deliberately commented out
//	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRYEDIT);
//	hr = chunk.State();

	if(hr == 0)
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		// Write ChordEntryEdit chunk data
		hr = pIStream->Write( this, sizeof(ChordEntryEditChunk), &dwBytesWritten)
				&&  dwBytesWritten == sizeof(ioChordEntryEdit);
		pIStream->Release();
	}

    return hr;
}

HRESULT ChordEntryEditChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;

	ASSERT(pIRiffStream);
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	hr = (pIStream->Read( this, sizeof(ChordEntryEditChunk), &dwBytesRead) == 0
		&&  dwBytesRead == sizeof(ioChordEntryEdit)) ? S_OK : E_FAIL;
	pIStream->Release();

    return hr;
}

HRESULT ChordEntryEditChunk::Extract(const ChordEntry* pChord)
{
	ChordSelection* psel = &(const_cast<ChordEntry*>(pChord)->m_chordsel);

	for(int i = 0; i < MaxSubChords; i++)
	{
		bBits[i] = psel->SubChord(i)->Bits();
		bUseFlat[i] = psel->SubChord(i)->UseFlat();
	}
	wMeasure = psel->Measure();
	bBeat = psel->Beat();
	wConnectionId = pChord->m_nid;
	left = pChord->m_rect.left;
	top = pChord->m_rect.top;
	right = pChord->m_rect.right;
	bottom = pChord->m_rect.bottom;
	page = pChord->m_page;
	if(psel->KeyDown())
	{
		page |= CHORD_KEYDOWN;
	}
	else
	{
		page &= ~CHORD_KEYDOWN;
	}
	return S_OK;
}

HRESULT ChordEntryEditChunk::Insert( ChordEntry* pChord)
{
	ChordSelection* psel = &((pChord)->m_chordsel);
	if(page & CHORD_KEYDOWN)
	{
		psel->KeyDown() = true;
		page &= ~ CHORD_KEYDOWN;
	}
	for(int i = 0; i < MaxSubChords; i++)
	{
		psel->SubChord(i)->Bits() = bBits[i];
		psel->SubChord(i)->UseFlat() = bUseFlat[i];
	}
	pChord->m_chordsel.Measure() = wMeasure;
	pChord->m_chordsel.Beat() = bBeat;
	pChord->m_nid = wConnectionId;
	pChord->m_rect.left = left;
	pChord->m_rect.top = top;
	pChord->m_rect.right = right;
	pChord->m_rect.bottom = bottom;
	pChord->m_page = page;
	return S_OK;
}

////////////////////////////////////////////// ChordListChunk members
//
ChordListChunk::ChordListChunk(DMPolyChord& Chord, DMSubChordSet& chordset, bool bIncludeEditInfo)
{
	memset(name, 0, sizeof(name));
	m_bIncludeEditInfo = bIncludeEditInfo;
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Extract(Chord);
	}
	chordset.Add(Chord, *this);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrncpy(name, Chord.Name(), 12);
#else
	// use conversion
    MultiByteToWideChar( CP_ACP, 0, Chord.Name(), -1, name, sizeof( name) / sizeof( wchar_t ) );
#endif
}

HRESULT ChordListChunk::Write(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;

	// Write ChordList chunk header
	WriteListChunk	list(pIRiffStream, FOURCC_LISTCHORD);
	hr = list.State();

	if(hr == 0)
	{
	    pIStream = pIRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		hr = (pIStream != 0) ? S_OK : E_FAIL;

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_CHORDNAME);
			hr = pchunk->State();
			if(hr == 0)
			{
				hr = pIStream->Write(name, sizeof(name), &dwBytesWritten) == 0 
					&& dwBytesWritten == sizeof(name) ? S_OK : E_FAIL;
			}
			delete pchunk;
		}

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_SUBCHORDID);
			hr = pchunk->State();
			hr = pIStream->Write( subchordids, sizeof(subchordids), &dwBytesWritten) == 0
				&&  dwBytesWritten == sizeof(subchordids) ? S_OK : E_FAIL;
			delete pchunk;
		}

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_CHORDEDIT);
			hr = pchunk->State();
			if(hr == 0)
			{
				hr = pIStream->Write(&m_chordedit, sizeof (m_chordedit), &dwBytesWritten);
				hr = (hr == S_OK) && (dwBytesWritten == sizeof(m_chordedit)) ? S_OK : E_FAIL;
			}
			delete pchunk;
		}

	    pIStream->Release();
	}

    return hr;
}

HRESULT ChordListChunk::Read(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	HRESULT hr1=S_OK, hr2=S_OK;
	HRESULT hr3 = S_OK;
	ASSERT(pIRiffStream && pckParent);
	MMCKINFO ck;
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(!pIStream)
		return E_FAIL;

	while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
	{
		switch(ck.ckid)
		{
		case FOURCC_CHORDNAME:
			hr1 = pIStream->Read(name, sizeof(name), 0);
			break;
		case FOURCC_SUBCHORDID:
			hr2 = pIStream->Read(subchordids, sizeof(subchordids), 0);
			break;
		case FOURCC_CHORDEDIT:
			hr3 = pIStream->Read(&m_chordedit, sizeof(m_chordedit), 0);
			m_bIncludeEditInfo = true;
			break;
		}
		pIRiffStream->Ascend(&ck, 0);
	}
	pIStream->Release();
	return (hr1 == S_OK && hr2 == S_OK) ? S_OK : E_FAIL;
}

HRESULT ChordListChunk::Extract( DMPolyChord& Chord, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Extract(Chord);
	}
	m_bIncludeEditInfo = bIncludeEditInfo;
	subchords.Add(Chord, *this);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrncpy(name, Chord.Name(), NameSize);
#else
	// use conversion
    MultiByteToWideChar( CP_ACP, 0, Chord.Name(), -1, name, sizeof( name) / sizeof( wchar_t ) );
#endif
	return S_OK;
}

HRESULT ChordListChunk::Insert( DMPolyChord& Chord,  const DMSubChordSet& subchords)
{
	memset(Chord.Name(), 0, NameSize);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrcpy(Chord.Name(), name);
#else
	// use conversion
	WideCharToMultiByte( CP_ACP, 0, name, -1, Chord.Name(), NameSize, NULL, NULL );
#endif
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Insert(Chord);
	}
	return const_cast<DMSubChordSet&>(subchords).Retrieve(Chord, *this);
}

//////////////////////////////////////////////////////////////////// ChordEntryListItem members
//

ChordEntryListItem::ChordEntryListItem(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	ASSERT(pChord);
	m_chordentry.Extract(pChord);
	m_chordlist.Extract(pChord->m_chordsel, subchords, m_bIncludeEditInfo);
	for(NextChord* pNext = pChord->m_nextchordlist.GetHead(); pNext; pNext = pNext->GetNext())
	{
		NextChordChunk nextchunk(pNext);
		m_nextchordlist.AddTail(nextchunk);
	}
}

HRESULT ChordEntryListItem::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDENTRY);
	HRESULT hr = list.State();
	if(hr == 0)
	{
		hr = m_chordentry.Write(pRiffStream) == 0
			&& m_chordlist.Write(pRiffStream) == 0 ? S_OK : E_FAIL;
		if(hr == 0)
		{
			WriteChunk chunk(pRiffStream, FOURCC_NEXTCHORDSEQ);
			hr = chunk.State();
			WORD cbioNextChord = sizeof(ioNextChord);
			WriteWord(pRiffStream, cbioNextChord);
			POSITION pos = m_nextchordlist.GetHeadPosition();
			while(pos && hr == 0)
			{
				NextChordChunk nextchunk;
				nextchunk = m_nextchordlist.GetNext(pos);
				hr = nextchunk.Write(pRiffStream);
			}
		}

	}
	return hr;
}

HRESULT ChordEntryListItem::Read(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pIRiffStream);
	HRESULT hr1=S_OK,hr2=S_OK,hr3=S_OK;
	ASSERT(pIRiffStream && pckParent);
	MMCKINFO ck;

	m_nextchordlist.RemoveAll();

	while(pIRiffStream->Descend(&ck, pckParent, 0)==0)
	{
		switch(ck.ckid)
		{
		case FOURCC_CHORDENTRY:
			hr1 = m_chordentry.Read(pIRiffStream);
			break;
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				hr2 = m_chordlist.Read(pIRiffStream, &ck);
				break;
			}
			break;
			case FOURCC_NEXTCHORDSEQ:
				{
					WORD count;
					if(ReadWord(pIRiffStream, count) == 0)
					{
						count = static_cast<short>((ck.cksize-sizeof(WORD)) / count);
						hr3 = hr2;
						for(WORD i = 0; i < count && hr3 == S_OK; i++)
						{
							NextChordChunk nextchunk;
							hr3 = nextchunk.Read(pIRiffStream);
							m_nextchordlist.AddTail(nextchunk);
						}
					}
				}
				break;
		}
		pIRiffStream->Ascend(&ck, 0);
	}
	return (hr1 || hr2 || hr3) == 0 ? S_OK : E_FAIL;
}

HRESULT	ChordEntryListItem::Extract(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	ASSERT(pChord);
	m_bIncludeEditInfo = bIncludeEditInfo;
	HRESULT hr = m_chordentry.Extract(pChord)
					|| m_chordlist.Extract(pChord->m_chordsel, subchords, m_bIncludeEditInfo);
	if(hr == 0)
	{
		for(NextChord* pNext = pChord->m_nextchordlist.GetHead(); pNext; pNext = pNext->GetNext())
		{
			NextChordChunk nextchunk;
			hr |= nextchunk.Extract(pNext);
			m_nextchordlist.AddTail(nextchunk);
		}
	}
	return hr;
}

HRESULT ChordEntryListItem::Insert( ChordEntry* pChord, const DMSubChordSet& subchords)
{
	ASSERT(pChord);
	HRESULT hr = m_chordentry.Insert(pChord)
					|| m_chordlist.Insert(pChord->m_chordsel, subchords);

	if(hr == 0)
	{
		POSITION pos = m_nextchordlist.GetHeadPosition();
		while(pos)
		{
			NextChordChunk nextchunk;
			nextchunk = m_nextchordlist.GetNext(pos);
			NextChord* pNext = new NextChord;
			nextchunk.Insert(pNext);
			pNext->m_parent = pChord;
			pChord->m_nextchordlist.AddTail(pNext);
		}			
	}
	
	return hr;
}


//////////////////////////////////////////////////////////////////// CadenceListChunk members
//
CadenceListChunk::CadenceListChunk(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[0],  subchords, m_bIncludeEditInfo);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[1],  subchords, m_bIncludeEditInfo);
	}
}



HRESULT CadenceListChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;

	// Write ChordList chunk header
	if(m_bHasCadenceChord1 || m_bHasCadenceChord2)
	{
		WriteListChunk	list(pRiffStream, FOURCC_LISTCADENCE);
		hr = list.State();

		if(hr == 0)
		{
			// Write Cadence1 chordlist chunk data
			if(m_bHasCadenceChord1)
			{
				hr = m_CadenceChord1.Write(pRiffStream);
			}


			// Write Cadence2 chordlist chunk data
			if(hr == 0 && m_bHasCadenceChord2)
			{
				hr = m_CadenceChord2.Write(pRiffStream);
			}
		}
	}
    return hr;
}

HRESULT CadenceListChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
// for this to work properly, user must first read in signpost chunk to get which cadence chords,
// otherwise first chord read goes to cadence chord 1 etc.
{
	ASSERT(pRiffStream && pckParent);
	MMCKINFO ck;
	HRESULT hr = S_OK;
	int nextToRead  = 1;
	if(m_bHasCadenceChord2 && !m_bHasCadenceChord1)
	{
		nextToRead = 2;
	}

	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(nextToRead)
		{
		case 1:
			hr = m_CadenceChord1.Read(pRiffStream, &ck);
			nextToRead = 2;
			break;
		case 2:
			hr = m_CadenceChord2.Read(pRiffStream, &ck);
			nextToRead = 1;
			break;
		}
		pRiffStream->Ascend(&ck, 0);
	}
	return hr;
}

HRESULT CadenceListChunk::Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[0],  subchords, m_bIncludeEditInfo);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord2.Extract(pSignPost->m_cadence[1],  subchords, m_bIncludeEditInfo);
	}
	return S_OK;
}

HRESULT CadenceListChunk::Insert( SignPost* pSignPost, const DMSubChordSet& subchords)
// pSignpost should have been filled in from SignPostChunk before calling this function
{
	ASSERT(pSignPost);
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Insert(pSignPost->m_cadence[0],  subchords);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord2.Insert(pSignPost->m_cadence[1],  subchords);
	}
	return S_OK;
}

////////////////////////////////////////////////////////// SignPostListItemChunk members
//
SignPostListItemChunk::SignPostListItemChunk(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	m_signpost.Extract(pSignPost);
	m_signpostchord.Extract(pSignPost->m_chord, subchords, m_bIncludeEditInfo);
	m_cadencelist.Extract(pSignPost, subchords, m_bIncludeEditInfo);
};

HRESULT SignPostListItemChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr;

	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	WriteListChunk list(pRiffStream, FOURCC_LISTSIGNPOSTITEM);
	hr = list.State();

	if(hr == S_OK)
	{
		hr =  m_signpost.Write(pRiffStream)
				||m_signpostchord.Write(pRiffStream)
				|| m_cadencelist.Write(pRiffStream);
	}

	return hr;
}

HRESULT SignPostListItemChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_IOSIGNPOST:
			hr = m_signpost.Read(pRiffStream);
			m_cadencelist.HasCadenceChord1() = m_signpost.dwFlags & SPOST_CADENCE1;
			m_cadencelist.HasCadenceChord2() = m_signpost.dwFlags & SPOST_CADENCE2;
			break;
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				hr = m_signpostchord.Read(pRiffStream, &ck);
				break;
			case FOURCC_LISTCADENCE:
				hr = m_cadencelist.Read(pRiffStream, &ck);
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT SignPostListItemChunk::Extract(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	HRESULT hr;
	ASSERT(pSignPost);
	if(pSignPost == 0)
	{
		return E_INVALIDARG;
	}

	hr =  m_signpost.Extract(pSignPost)
			|| m_signpostchord.Extract(pSignPost->m_chord, subchords, m_bIncludeEditInfo)
			|| m_cadencelist.Extract(pSignPost, subchords, m_bIncludeEditInfo);

	return hr;
}

HRESULT SignPostListItemChunk::Insert( SignPost* pSignPost, const DMSubChordSet& subchords)
{
	HRESULT hr;
	ASSERT(pSignPost);
	if(pSignPost == 0)
	{
		return E_INVALIDARG;
	}

	hr =	m_signpost.Insert(pSignPost)
			|| m_signpostchord.Insert(pSignPost->m_chord, subchords)
			|| m_cadencelist.Insert(pSignPost, subchords);

	return hr;
}


///////////////////////////////////////////////////////// SignPostListChunk members
//
SignPostListChunk::SignPostListChunk(SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	for(SignPost* pSignPost = signpostlist.GetHead(); pSignPost; pSignPost = pSignPost->GetNext())
	{
		SignPostListItemChunk* pItem = new SignPostListItemChunk(pSignPost, subchords, m_bIncludeEditInfo);
		AddTail(pItem);
	}
}

SignPostListChunk::~SignPostListChunk()
{
	while(!IsEmpty())
	{
		SignPostListItemChunk* pItem = RemoveHead();
		delete pItem;
	}
}

HRESULT	SignPostListChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;
	POSITION pos = GetHeadPosition();
	if(pos != NULL)
	{
		WriteListChunk	list(pRiffStream, FOURCC_SIGNPOSTLIST);
		hr = list.State();
		while(pos != NULL && hr==S_OK)
		{
			SignPostListItemChunk* pItem = GetNext(pos);
			hr = pItem->Write(pRiffStream);
		}
	}
	return hr;
}

HRESULT SignPostListChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTSIGNPOSTITEM:
				{
					SignPostListItemChunk* pchunk = new SignPostListItemChunk;
					hr = pchunk->Read(pRiffStream, &ck);
					if(hr == S_OK)
					{
						AddTail(pchunk);
					}
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT SignPostListChunk::Extract(SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	for(SignPost* pSignPost = signpostlist.GetHead(); pSignPost; pSignPost = pSignPost->GetNext())
	{
		SignPostListItemChunk* pItem = new SignPostListItemChunk(pSignPost, subchords, m_bIncludeEditInfo);
		AddTail(pItem);
	}
	return S_OK;
}

HRESULT SignPostListChunk::Insert(SignPostList& signpostlist, const DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	POSITION pos = GetHeadPosition();
	while(pos != NULL && hr==S_OK)
	{
		SignPostListItemChunk* pItem = GetNext(pos);
		SignPost* pSignPost = new SignPost;
		if(pSignPost)
		{
			hr = pItem->Insert(pSignPost, subchords);
			signpostlist.AddTail(pSignPost);
		}
		else
		{
			hr = E_FAIL;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////// ChordPaletteList members
//
ChordPaletteList::ChordPaletteList(ChordPalette& chordpalette, DMSubChordSet& subchords)
{
	for(int i = 0; i < 24; i++)
	{
		m_chordlist[i].Extract(chordpalette.m_chords[i], subchords, false);
	}
}

HRESULT ChordPaletteList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr;

	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDPALETTE);
	hr = list.State();

	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Write(pRiffStream);
	}
	return hr;
}

HRESULT ChordPaletteList::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO*pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	WORD count=0;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				{
					hr = m_chordlist[count++].Read(pRiffStream, &ck);
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}
	ASSERT(count == 24);
	return hr;
}

HRESULT ChordPaletteList::Extract(ChordPalette& chordpalette, DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Extract(chordpalette.m_chords[i], subchords, false);
	}

	return hr;
}

HRESULT ChordPaletteList::Insert(ChordPalette& chordpalette,  const DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Insert(chordpalette.m_chords[i], subchords);
	}

	return hr;
}

//////////////////////////////////////////////////////// DMChordMapList 
//
ChordMapList::ChordMapList(ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	int idx = 0;
	for(ChordEntry* pchord = chordlist.GetHead(); pchord; pchord = pchord->GetNext())
	{
			ChordEntryListItem*	pItem = new ChordEntryListItem(pchord, subchords, m_bIncludeEditInfo);
			SetAt(idx++, pItem);	// does a copy
	}
}

ChordMapList::~ChordMapList()
{
	POSITION pos = GetStartPosition();
	while(pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		GetNextAssoc(pos, key, pItem);
		delete pItem;
		RemoveKey(key);
	}
}

HRESULT ChordMapList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	POSITION pos = GetStartPosition();
	HRESULT hr = S_OK;

	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDMAP);
	hr = list.State();
	
	while(hr == S_OK && pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		GetNextAssoc(pos, key, pItem);
		hr = pItem->Write(pRiffStream);
	}
	return hr;
}

HRESULT ChordMapList::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	WORD count = 0;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0&& hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORDENTRY:
				{
					ChordEntryListItem* item = new ChordEntryListItem;
					hr = item->Read(pRiffStream, &ck);
					if(hr == S_OK)
					{
						SetAt(count++, item);
					}
					else
					{
						delete item;
					}
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT ChordMapList::Extract( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	HRESULT hr = S_OK;
	m_bIncludeEditInfo = bIncludeEditInfo;
	int idx = 0;
	for(ChordEntry* pchord = chordlist.GetHead(); pchord; pchord = pchord->GetNext())
	{
			ChordEntryListItem*	pItem = new ChordEntryListItem(pchord, subchords, m_bIncludeEditInfo);
			SetAt(idx++, pItem);	// does a copy
	}
	return hr;
}

HRESULT ChordMapList::Insert(ChordEntryList& chordlist, const DMSubChordSet& subchords)
{
	POSITION pos = GetStartPosition();
	HRESULT hr = S_OK;
	while(hr == S_OK && pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		ChordEntry* pchord = new ChordEntry;
		if(!pchord)
		{
			hr = E_FAIL;
		}
		else
		{
			GetNextAssoc(pos, key, pItem);
			hr = pItem->Insert(pchord, subchords);
			chordlist.AddTail(pchord);
		}
	}
	return hr;
	
}

//////////////////////////////////////////////////////// DMSubChordSet members
//
DMSubChordSet::~DMSubChordSet()
{
	if(m_aSubChord)
	{
		delete [] m_aSubChord;
		m_aSubChord = 0;
		m_cSubChord = 0;
	}

	POSITION pos = GetStartPosition();
	while(pos != NULL)
	{
		WORD idx;
		ioSubChord Item;
		GetNextAssoc(pos, Item, idx);
		RemoveKey(Item);
	}
}

HRESULT	DMSubChordSet::Add(DMPolyChord& Chord,  ChordListChunk& chordlist)
{

	int n = min(DMPolyChord::MAX_POLY, ChordListChunk::maxsubchords);

	for(int i = 0; i < n; i++)
	{
		ioSubChord	Sub(*Chord[i]);
		WORD id;
		if(!Lookup(Sub, id))
		{
			id = wNextKey++;
			SetAt(Sub, id);
		}
		chordlist.subchordids[i] = id;
	}
	return S_OK;
}

HRESULT DMSubChordSet::Retrieve( DMPolyChord& Chord, const ChordListChunk& chordlist) 
{
	int n = min(DMPolyChord::MAX_POLY, ChordListChunk::maxsubchords);

	HRESULT hr = S_OK;

	if(!m_aSubChord)
	{
		BuildSubChordArray();
	}
	ASSERT(m_cSubChord > 0);
	if(m_cSubChord == 0)
	{
		return E_FAIL;
	}

	for(int i = 0; i < n; i++)
	{
		WORD id = chordlist.subchordids[i];
		if(id < m_cSubChord)
		{
//			ioSubChord sub;
			m_aSubChord[id].CopyToDMChord(*Chord.SubChord(i));
			// make sure root in range
			if(i == Chord.RootIndex() && Chord.SubChord(i)->ChordRoot() > 23)
			{
				// make this chord unique
				while(Chord.SubChord(i)->ChordRoot() > 23)
				{
					Chord.SubChord(i)->ChordRoot() -= 12;
				}
				Chord.SubChord(i)->Flags() |= CSF_SHIFTED;	// make this chord unique
				AfxMessageBox(IDS_ILLEGALCHORD);
			}
		}
	}
	return hr;
}

HRESULT DMSubChordSet::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	IStream* pStream;
	HRESULT hr;
	DWORD dwBytesWritten;
	if(!m_aSubChord)
	{
		BuildSubChordArray();
	}

	ASSERT(m_cSubChord > 0);
	if(m_cSubChord == 0)
	{
		return E_FAIL;
	}

	WriteChunk	chunk(pRiffStream, FOURCC_SUBCHORD);
	hr = chunk.State();

	if(hr == S_OK)
	{
		pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == NULL)
		{
			return E_FAIL;
		}
		unsigned short cb = static_cast<unsigned short>(sizeof(ioSubChord));
		hr = pStream->Write(&cb, sizeof(unsigned short), &dwBytesWritten);
		if(hr == S_OK && dwBytesWritten == sizeof(unsigned short))
		{
			for(WORD i = 0; hr == S_OK && i < m_cSubChord; i++)
			{
				hr = pStream->Write(&m_aSubChord[i], sizeof(ioSubChord), &dwBytesWritten);
				if(dwBytesWritten != sizeof(ioSubChord))
				{
					hr = E_FAIL;
				}
			}
		}
		pStream->Release();
	}
	return hr;
}

HRESULT DMSubChordSet::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pck)
{
	ASSERT(pRiffStream);
	HRESULT hr = S_OK;
	DWORD dwBytesRead;
	IStream* pIStream = pRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	WORD cbioSubChordSize;	
	hr = pIStream->Read(&cbioSubChordSize, sizeof(WORD), &dwBytesRead);
	ASSERT(cbioSubChordSize==sizeof(ioSubChord));
	WORD count = static_cast<WORD>((pck->cksize - sizeof(WORD)) / cbioSubChordSize);
	WORD key = 0;
	DWORD	cbRead = sizeof(WORD);	// already read size of ioSubChord

	if(cbioSubChordSize != sizeof(ioSubChord))
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	while(cbRead < pck->cksize && hr == S_OK)
	{
		ioSubChord sub;
		DWORD	cb;
		hr = pIStream->Read(&sub, cbioSubChordSize, &cb);
		if(cb != cbioSubChordSize)
		{
			hr = E_FAIL;
		}
		// make sure we got the lowest bit pattern in chords
		while(sub.dwChordPattern && !(sub.dwChordPattern & 0x1))
		{
			sub.dwChordPattern = sub.dwChordPattern >> 1;
			sub.bChordRoot++;
			sub.wCFlags |= CSF_SHIFTED;	// make this chord unique
		}
		// make sure root in range
		/*
		if(sub.bChordRoot > 23)
		{
			// make this chord unique
			while(sub.bChordRoot > 23)
			{
				sub.bChordRoot -= 12;
			}
			sub.wCFlags |= CSF_SHIFTED;	// make this chord unique
			AfxMessageBox(IDS_ILLEGALCHORD);
		}
*/
		WORD id;
		if(!Lookup(sub, id))
		{
			id = key++;
			SetAt(sub, id);
		}

		cbRead += cb;
	}

	ASSERT(count == key);
	if(count != key)
	{
		hr = E_FAIL;
	}
	else
	{
		m_cSubChord = count;
	}
ON_ERR:
	pIStream->Release();
	return hr;
}


void DMSubChordSet::BuildSubChordArray()
{
	if(m_aSubChord)
	{
		delete [] m_aSubChord;
		m_aSubChord = 0;
		m_cSubChord = 0;
	}

	m_cSubChord = static_cast<unsigned short>(GetCount());

	m_aSubChord = new ioSubChord[m_cSubChord];
	POSITION pos = GetStartPosition();
	while(pos)
	{
		ioSubChord Sub;
		WORD idx;
		GetNextAssoc(pos, Sub, idx);
		ASSERT(idx < m_cSubChord);
		memcpy(&m_aSubChord[idx], &Sub, sizeof(ioSubChord));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordBuilder.cpp ===
#include "stdafx.h"
#include <string.h>
#include "chordbuilder.h"

/*  
Rules for deducing the diatonic chords in a scale.

  Let scale = scale pattern(24 bits);
  Let root = root of scale (0 - 11);

  if(root != 0 mod 12) then scale = rotate(scale, -root);

  Assert (0x1 & scale);	// root is defined

	Let NthOne(X, n) = bit pos of nth '1' in X. Bit pos is equivalent to chromatic steps
	Thus if X = 0x5B (01011011), NthOne(X,0) = -1 (all X)
								 NthOne(X,1) = 0
								 NthOne(X,2) = 1
								 NthOne(X,3) = 3
								 NthOne(X,4) = 4
								 NthOne(X,5) = 6
								 NthOne(X,n) = -1 n > 6

	Third(scale) =  NthOne(scale, 3)	// third of chord
	Fifth(scale) = NthOne(scale, 5)		// fifth of chord
	Seventh(scale) = NthOne(scale, 7)	// seventh of chord

	// classifying intervals:

	Thirds:	2 = dim, 3 = min, 4 = maj, 5 = aug
	Fifths: 6 = dim, 7 = Per, 8 = aug
	Sevenths 9 = dim, 10 = min, 11 = major

	// classifying triads (parenthesis show root relative to unison, eg, if C is unison, then
	// bVI 63 means the a flat chord in 1st inversion):

	3rd \ 5th  dim		per		aug

	dim			b5sus2	sus2	#5sus2
	min			dim		min		63	(bVI 63)
	maj			b5		maj		aug
	aug			b5sus4	sus4	64	(iv 64)

	// classifying seventh chords (dim7 enharmonic to maj6).

	triad \ 7th chord	maj7		min7		dim7

	sus2				maj7sus2	7sus2		sus2add6
	dim					min-maj7b5	min7b5		o7
	min					min-maj7	min7		minadd6
	maj					maj7		7			majadd6
	aug					maj7#5		7#5			#5add6
	sus4				maj7sus4	7sus4		sus4add6
	b5sus2				maj7b5sus2	7b5sus2		42 (II 42)
	#5sus2				maj7#5sus2	7#5sus2		#5sus2add6
	b5sus4				maj7b5sus2	7b5sus4		b5sus4add6
	63					min-maj7#5	min7#5		o7#5				
	64					maj7#5sus4	min7#5sus4	o7#5sus4	
		  

  */


namespace ChordAnalysis
{
inline long Rotate24(long val, long shift)
{
//	ASSERT(shift > -24 && shift < 24);
	int newval = 0;
	for(int i = 0; i < 24; i++)
	{
		long onMask = 1 << i;
		int newpos = (i + shift) % 24;
		if(newpos < 0) newpos = newpos + 24;
		long newOnMask = 1 << newpos;
		if(val & onMask)
		{
			newval |= newOnMask;
		}
	}
	return newval;
}

long NthOne(long scale, long ordinal)
{
	if(ordinal < 0)
		return -1;
	long count = 0;
	long pos = 0;
	for(pos; pos < sizeof(scale)*8 && count < ordinal; pos++)
	{
		if(scale & 0x1)
		{
			count++;
		}
		scale = scale / 2;
	}
	if(count == ordinal)
		return pos - 1;
	else
		return -1;
}

long Third(long scale)
{
	return NthOne(scale, 3);
}

long Fifth(long scale)
{
	return NthOne(scale, 5);
}

long Seventh(long scale)
{
	return NthOne(scale, 7);
}

long ClassifyThird(long interval)
{
	switch(interval)
	{
	case 2:	// dim 3rd
		return 0;
	case 3:	// min 3rd
		return 1;
	case 4:	// maj 3rd
		return 2;
	case 5:	//. aug 3rd
		return 3;
	default:
		return -1;
	}
}

long ClassifyFifth(long interval)
{
	switch(interval)
	{
	case 6:	// dim 5th
		return 0;
	case 7:	// per 5th
		return 1;
	case 8:	// aug 5th
		return 2;
	default:
		return -1;
	}
}

long ClassifySeventh(long interval)
{
	switch(interval)
	{
	case 9:
		return 0;
	case 10:
		return 1;
	case 11:
		return 2;
	default:
		return -1;
	}
}

long Triads[4][3] = 
{
	// dim5, per5, aug5
	{0, 1, 2},	//	dim	3
	{3, 4, 5},	//  min 3
	{6, 7, 8},	//  maj 3
	{9, 10,11}	// aug 3
};

char* TriadNames[12] =
{
	"b5sus2",
	"sus2",
	"#5sus2",
	"dim",
	"min",
	"63",
	"b5",
	"maj",
	"aug",
	"b5sus4",
	"sus4",
	"64"
};


long ClassifyTriad(long third, long fifth)
{
	if(third < 0 || third > 3 || fifth < 0 || fifth > 2)
		return -1;
	else
		return Triads[third][fifth];
}

long SeventhChords[12][3] =
{
	// dim7th, min7th, maj7th
	{0, 1, 2},		// b5sus2
	{3, 4, 5},		// sus2
	{6, 7, 8},		// #5sus2
	{9, 10, 11},	// dim
	{12, 13, 14},	// min
	{15, 16, 17},	// 63
	{18, 19, 20},	// b5
	{21, 22, 23},	// maj
	{24, 25, 26},	// aug
	{27, 28, 29},	// b5sus4
	{30, 31, 32},	// sus4
	{33, 34, 35},	// 64
};

char*	SeventhChordNames[36] =
{
	"42",			"7b5sus2",		"maj7b5sus2",
	"sus2add6",		"7sus2",		"maj7sus2",
	"#5sus2add6",	"7#5sus2",		"maj7#5sus2",
	"o7",			"min7b5",		"min-maj7b5",
	"min-add6",		"min7",			"min-maj7",
	"o7#5",			"min7#5",		"min-maj7#5",
	"b5add6",		"7b5",			"maj7b5",
	"maj-add6",		"7",			"maj7",
	"#5add6",		"7#5",			"maj7#5",
	"b5sus4add6",	"7b5sus4",		"maj7b4sus4",
	"sus4add6",		"7sus4",		"maj7sus4",
	"o7#5sus4",		"min7#5sus4",	"maj7#5sus4"
};

long ClassifySeventhChord(long triad, long seventh)
{
	if(triad < 0 || triad > 11 || seventh < 0 || seventh > 2)
		return -1;
	else
		return SeventhChords[triad][seventh];
}


char* ClassifyChord(long root, long scale)
{
	scale = Rotate24(scale, -root);
	long third, fifth, seventh, triad, seventhchord;
	third = ClassifyThird(Third(scale));
	fifth = ClassifyFifth(Fifth(scale));
	seventh = ClassifySeventh(Seventh(scale));
	triad = ClassifyTriad(third, fifth);
	seventhchord = ClassifySeventhChord(triad, seventh);
	if(seventhchord > 0)
		return SeventhChordNames[seventhchord];
	else if(triad > 0)
		return TriadNames[triad];
	else
		return 0;
}

char* notes[] = { "C", "C#/Db", "D", "D#/Eb", "E", "F", "F#/Gb", "G", "G#/Ab", "A", "A#/Bb", "B" };

long ChordPattern(long root, long scale)
{
	scale = Rotate24(scale, -root);
	long third, fifth, seventh;
	third = Third(scale);
	fifth = Fifth(scale);
	seventh = Seventh(scale);
	long pattern = 1 + (1 << third) + (1 << fifth) + (1 << seventh);
//	pattern = pattern + (pattern << 12);
	pattern = pattern & 0x00ffffff;
	return pattern;
}

long TriadPattern(long root, long scale)
{
	scale = Rotate24(scale, -root);
	long third, fifth;
	third = Third(scale);
	fifth = Fifth(scale);
	long pattern = 1 + (1 << third) + (1 << fifth);
	pattern = pattern & 0x00ffffff;
	return pattern;
}

}




ChordBuilder::ChordBuilder(long scale, int type, int transpose)
{
	UNREFERENCED_PARAMETER(transpose);

	using namespace	ChordAnalysis;
	long mask = 1;
	long idx;
	if(type == Triad)
	{
		for(idx = 0; idx < 12 ; idx++)
		{
			if( scale & mask)
			{
				long tscale = Rotate24(scale, -idx);
				long third, fifth, triad;
				third = ClassifyThird(Third(tscale));
				fifth = ClassifyFifth(Fifth(tscale));
				triad = ClassifyTriad(third, fifth);
				if(triad > 0)
				{
					strcpy(m_chordname[idx], TriadNames[triad]);
					m_chordpattern[idx] = TriadPattern(idx, scale);
					strcpy(m_chordname[idx+12], m_chordname[idx]);
					m_chordpattern[idx+12] = m_chordpattern[idx];
				}
				else
				{
					strcpy(m_chordname[idx], "maj");
					strcpy(m_chordname[idx+12], "maj");
					m_chordpattern[idx] = m_chordpattern[idx+12] = 0x91;
				}
			}
			else
			{
				m_chordpattern[idx] = m_chordpattern[idx+12] = 0x91;
					strcpy(m_chordname[idx], "maj");
					strcpy(m_chordname[idx+12], "maj");
			}
			mask *= 2;
		}
	}
	else
	{
		for(idx = 0; idx < 12 ; idx++)
		{
			if( scale & mask)
			{
				char* pChordName = ClassifyChord(idx, scale);
				if(pChordName)
				{
					strcpy(m_chordname[idx], ClassifyChord(idx, scale));
					m_chordpattern[idx] = ChordAnalysis::ChordPattern(idx, scale);
					strcpy(m_chordname[idx+12], m_chordname[idx]);
					m_chordpattern[idx+12] = m_chordpattern[idx];
				}
				else
				{
					strcpy(m_chordname[idx], "maj");
					strcpy(m_chordname[idx+12], "maj");
					m_chordpattern[idx] = m_chordpattern[idx+12] = 0x91;
				}
			}
			else
			{
				m_chordpattern[idx] = m_chordpattern[idx+12] = 0x91;
				strcpy(m_chordname[idx], "maj");
				strcpy(m_chordname[idx+12], "maj");
			}
			mask *= 2;
		}
	}
}

ChordBuilder::ChordBuilder(long pattern, const char* name)
{
	for(int idx = 0; idx < 24; idx++)
	{
		strcpy(m_chordname[idx], name);
		m_chordpattern[idx] = pattern;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordDatabase.h ===
#ifndef CHORDDATABASE_H
#define CHORDDATABASE_H

#include "Chord.h"
#include "PersonalityRIFF.h"

HRESULT DMLoadChordData(ChordEntryList& chordEntryList, IStream* pIStream);

// pattern for single data chunk objects:
// To save to a riffstream: XChunk myChunk(pData); myChunk.Write(pRiffStream);
// To extract from a riffstream: extern XChunk myChunk; mChunk.Read(pRiffStream); myChunk.Insert(pData);


class SignPostChunk : public ioSignPost
{
public:
	SignPostChunk() {}
	SignPostChunk(IDMUSProdRIFFStream* pRiffStream)
	{
		Read(pRiffStream);
	}
	SignPostChunk( const SignPost* pSignPost);
	HRESULT	Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const SignPost* pSignPost);
	HRESULT Insert( SignPost* pSignPost);
};

class NextChordChunk: public ioNextChord
{
public:
	NextChordChunk() {}
	NextChordChunk(const NextChord* pNext);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const NextChord* pNext);
	HRESULT Insert( NextChord* pNext);
};

class ChordEntryChunk: public ioChordEntry
{
public:
	ChordEntryChunk() {}
	ChordEntryChunk(const ChordEntry* pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const ChordEntry* pChord);
	HRESULT Insert( ChordEntry* pChord);
};

// chord entry edit info helpers
HRESULT WriteChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist);
HRESULT ReadChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist, MMCKINFO* pckInfo);

class ChordEntryEditChunk : public ioChordEntryEdit
{
public:
	ChordEntryEditChunk() {}
	ChordEntryEditChunk(const ChordEntry* pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Extract(const ChordEntry* pChord);
	HRESULT Insert(ChordEntry* pChord);
};

class DMSubChordSet;

class ChordListChunk
{
	DMChordEdit m_chordedit;
	bool m_bIncludeEditInfo;
public:
	enum {NameSize = DMPolyChord::MAX_NAME};
	ChordListChunk() {m_bIncludeEditInfo = false;  memset(name, 0, sizeof(name));}
	ChordListChunk(DMPolyChord& pChord, DMSubChordSet& chordset, bool bIncludeEditInfo);
	enum { maxsubchords = MaxSubChords};
	WCHAR	name[NameSize];
	WORD	subchordids[maxsubchords];
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( DMPolyChord& pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( DMPolyChord& pChord, const DMSubChordSet& subchords);
};


class ChordEntryListItem
{
	bool m_bIncludeEditInfo;
public:
	ChordEntryListItem() {m_bIncludeEditInfo = false;}
	ChordEntryListItem(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		Read(pRiffStream, pckParent);
	}
	ChordEntryListItem( ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( ChordEntry* pChord, const DMSubChordSet& subchords);
private:
	ChordEntryChunk	m_chordentry;
	ChordListChunk	  m_chordlist;
	CList<NextChordChunk, NextChordChunk&> m_nextchordlist;
};


class CadenceListChunk
{
	bool m_bIncludeEditInfo;
public:
	CadenceListChunk() {m_bHasCadenceChord1 = false; m_bHasCadenceChord2 = false; m_bIncludeEditInfo = false;};
	CadenceListChunk( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPost* pSignPost, const DMSubChordSet& subchords);
	BOOL& HasCadenceChord1()
	{
		return m_bHasCadenceChord1;
	}
	BOOL& HasCadenceChord2()
	{
		return m_bHasCadenceChord2;
	}
private:
	ChordListChunk	m_CadenceChord1;
	ChordListChunk	m_CadenceChord2;
	BOOL					m_bHasCadenceChord1;
	BOOL					m_bHasCadenceChord2;
};

class SignPostListItemChunk
{
	bool m_bIncludeEditInfo;
public:
	SignPostListItemChunk() {m_bIncludeEditInfo = false;}
	SignPostListItemChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	SignPostListItemChunk( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPost* pSignPost, const DMSubChordSet& subchords);
private:
	SignPostChunk	m_signpost;
	ChordListChunk	m_signpostchord;
	CadenceListChunk	m_cadencelist;
};

class SignPostListChunk : public 	CList<SignPostListItemChunk*, SignPostListItemChunk*&>
{
	bool m_bIncludeEditInfo;
public:
	SignPostListChunk() {m_bIncludeEditInfo = false;}
	SignPostListChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	SignPostListChunk( SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	~SignPostListChunk();
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPostList& signpostlist, const DMSubChordSet& subchords);
};

class ChordPaletteList
{
public:
	ChordPaletteList() {}
	ChordPaletteList(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	ChordPaletteList( ChordPalette& chordpalette, DMSubChordSet& subchords);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( ChordPalette& chordpalette, DMSubChordSet& subchords);
	HRESULT Insert(ChordPalette& chordpalette, const DMSubChordSet& subchords);
private:
	ChordListChunk	m_chordlist[24];
};

class ChordMapList : public CMap<int, int, ChordEntryListItem*, ChordEntryListItem*&>
{
	bool m_bIncludeEditInfo;
public:
	ChordMapList() {m_bIncludeEditInfo = false;}
	ChordMapList(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	ChordMapList( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	~ChordMapList();
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert(ChordEntryList& chordlist, const DMSubChordSet& subchords);

};



inline BOOL	operator == (ioSubChord p1, ioSubChord p2)
{
	return !memcmp(&p1, &p2, sizeof(ioSubChord));
}


class DMSubChordSet : public CMap<ioSubChord, ioSubChord&, WORD, WORD&>
//
// This class used to prepare subChords to be saved.  Add screens for duplications.
//
{
	WORD	wNextKey;
	ioSubChord*  m_aSubChord;
	WORD		 m_cSubChord;
	void		 BuildSubChordArray();
public:
	DMSubChordSet() { wNextKey = 0; m_cSubChord = 0; m_aSubChord = 0;}
	~DMSubChordSet();
	// access functions
	HRESULT Add( DMPolyChord& Chord, ChordListChunk& chordlist);
	HRESULT Retrieve(DMPolyChord& Chord, const ChordListChunk& chordlist) ;
	// storage functions
	HRESULT	Write(IDMUSProdRIFFStream* pRiffStream);				// writes chord data to pStream
	HRESULT	Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pck);	// reads chord data to pStream
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordInversionPropPage.cpp ===
// ChordInversionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#pragma warning(disable:4201)
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordInversionPropPage.h"
#pragma warning(default:4201)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage property page

IMPLEMENT_DYNCREATE(CChordInversionPropPage, CPropertyPage)

CChordInversionPropPage::CChordInversionPropPage() : CPropertyPage(CChordInversionPropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//{{AFX_DATA_INIT(CChordInversionPropPage)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
	AddRef();
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
}

CChordInversionPropPage::~CChordInversionPropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordInversionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordInversionPropPage)
	DDX_Control(pDX, IDC_KEYS_INVERSIONS4, m_keysinv4);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS3, m_keysinv3);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS2, m_keysinv2);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS1, m_keysinv1);
	DDX_Control(pDX, IDC_KEYS_BASECHORD4, m_keysbase4);
	DDX_Control(pDX, IDC_KEYS_BASECHORD3, m_keysbase3);
	DDX_Control(pDX, IDC_KEYS_BASECHORD2, m_keysbase2);
	DDX_Control(pDX, IDC_KEYS_BASECHORD1, m_keysbase1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordInversionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordInversionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_INVERT1, OnButtonInvert1)
	ON_BN_CLICKED(IDC_BUTTON_INVERT2, OnButtonInvert2)
	ON_BN_CLICKED(IDC_BUTTON_INVERT3, OnButtonInvert3)
	ON_BN_CLICKED(IDC_BUTTON_INVERT4, OnButtonInvert4)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY1, OnButtonIplay1)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY2, OnButtonIplay2)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY3, OnButtonIplay3)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY4, OnButtonIplay4)
	ON_BN_CLICKED(IDC_CHECK_LEGAL1, OnCheckLegal1)
	ON_BN_CLICKED(IDC_CHECK_LEGAL2, OnCheckLegal2)
	ON_BN_CLICKED(IDC_CHECK_LEGAL3, OnCheckLegal3)
	ON_BN_CLICKED(IDC_CHECK_LEGAL4, OnCheckLegal4)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage message handlers



////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage other funcs


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordInversionPropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

int CChordInversionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordInversionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	CPropertyPage::OnDestroy();	
}

// required to get owner draw controls to paint 
void CChordInversionPropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CChordInversionPropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

BOOL CChordInversionPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	
	m_nextinvert4.AutoLoad(IDC_BUTTON_INVERT4, this);
	m_nextinvert3.AutoLoad(IDC_BUTTON_INVERT3, this);
	m_nextinvert2.AutoLoad(IDC_BUTTON_INVERT2, this);
	m_nextinvert1.AutoLoad(IDC_BUTTON_INVERT1, this);

	m_play4.AutoLoad(IDC_BUTTON_IPLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_IPLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_IPLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_IPLAY1, this);

	CPropertyPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordInversionPropPage::OnButtonInvert1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[0].Rotate(m_Chord.SubChord(0)->NoteCount());
	SetChord(&m_Chord, 0);
}

void CChordInversionPropPage::OnButtonInvert2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[1].Rotate(m_Chord.SubChord(1)->NoteCount());
	SetChord(&m_Chord, 1);
}

void CChordInversionPropPage::OnButtonInvert3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[2].Rotate(m_Chord.SubChord(2)->NoteCount());
	SetChord(&m_Chord, 2);
}

void CChordInversionPropPage::OnButtonInvert4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[3].Rotate(m_Chord.SubChord(3)->NoteCount());
	SetChord(&m_Chord, 3);
}

void CChordInversionPropPage::OnButtonIplay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(0);
}

void CChordInversionPropPage::OnButtonIplay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(1);	
}

void CChordInversionPropPage::OnButtonIplay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(2);	
}

void CChordInversionPropPage::OnButtonIplay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(3);	
}

void CChordInversionPropPage::OnCheckLegal1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL1);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[0].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[0].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(0)->InvertPattern() = m_invertVector[0].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL2);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[1].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[1].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(1)->InvertPattern() = m_invertVector[1].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL3);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[2].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[2].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(2)->InvertPattern() = m_invertVector[2].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::OnCheckLegal4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL4);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[3].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[3].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(3)->InvertPattern() = m_invertVector[3].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordInversionPropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}

void CChordInversionPropPage::SetChord(CPropChord * pChord, int subchord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;
	

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_INAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_IROOT,str);
//	SetCheckBox(pChord, UD_FLAT, IDC_CHECKBOX_FLATS, pChord->Base()->UseFlat() && 1);
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	int k0 = subchord == -1 ? 0 : subchord;
	int k1 = subchord == -1 ? CPropChord::MAX_POLY : subchord + 1;
	bool globalset = (subchord == -1);
	
	for(int n = k0; n < k1; n++)
	{
		// clear keyboards
		GetChordKeyboard(n)->ClearKeys();
		GetInversionKeyboard(n)->ClearKeys();

		// determine chord inversions
		int bass,third,fifth, seventh;
		BitFlag bfChord(pChord->SubChord(n)->ChordPattern());
		pChord->SubChord(n)->ChordNotes(bass, third, fifth, seventh);
		int inversion = m_invertStates[n].Get();
		if(inversion >= InversionState::First && third > -1)
		{
			bfChord.ClearBit(bass);
			bfChord.SetBit(bass+12);
		}
		if(inversion >= InversionState::Second && fifth > -1)
		{
			bfChord.ClearBit(third);
			bfChord.SetBit(third+12);
		}
		if(inversion >= InversionState::Third &&  seventh > -1)
		{
			bfChord.ClearBit(fifth);
			bfChord.SetBit(fifth+12);
		}
		DWORD dwChord = bfChord;
		// make sure pattern is tranposed
		dwChord = Rotate24(dwChord, pChord->SubChord(n)->ChordRoot() % 24);

		GetChordKeyboard(n)->Transpose(pChord->SubChord(n)->ChordRoot(), true);
		int shift = (pChord->SubChord(n)->ChordRoot())%24;
		if(globalset)
		{
			// only do this when all keys chords change (ie you've switched to this prop page)
			GetInversionKeyboard(n)->SetLowerBound(shift);
		}
		for (nX = 0; nX < 24; nX++)
		{
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> nX) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
			DrawInversionNote(pChord, dwChord, n, static_cast<short>(nX));
		}
		// finally set check box according to legality of inversion
		m_invertVector[n].SetChord(m_Chord.SubChord(n)->ChordPattern());
		m_invertVector[n].SetInversion(m_Chord.SubChord(n)->InvertPattern());
		CButton* pButton=0;
		switch(n)
		{
		case 0:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL1);
			break;
		case 1:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL2);
			break;
		case 2:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL3);
			break;
		case 3:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL4);
			break;
		}
		if(pButton)
		{
			if(inversion == 0)
			{
				pButton->SetCheck(1);
			}
			else if(m_invertVector[n].GetAllowedInversion(inversion-1))
			{
				pButton->SetCheck(1);
			}
			else
			{
				pButton->SetCheck(0);
			}
		}
	}

}

CKeyboard* CChordInversionPropPage::GetChordKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysbase1;			
			break;
		case 1:
			return &m_keysbase2;
			break;
		case 2:
			return &m_keysbase3;
			break;
		case 3:
			return &m_keysbase4;
			break;
		default:
			return 0;
			break;
		}
}

int CChordInversionPropPage::GetChordKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}

CKeyboard* CChordInversionPropPage::GetInversionKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysinv1;			
			break;
		case 1:
			return &m_keysinv2;
			break;
		case 2:
			return &m_keysinv3;
			break;
		case 3:
			return &m_keysinv4;
			break;
		default:
			return 0;
			break;
		}

}

int CChordInversionPropPage::GetInversionKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetInversionKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}


void CChordInversionPropPage::DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
#pragma warning(disable:4244)
	nX += GetInversionKeyboard(index)->LowerBound();
	short nX24 = nX%24;
	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	short nState = nGrayed;
	if ((dwChordInversion >> nX24) & 1) 
		nState += 2;
	GetInversionKeyboard(index)->SetNoteState(nX,"",nState);
#pragma warning(default:4244)
}

BOOL CChordInversionPropPage::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// make sure chord in sync from any changes in chordscaleproppage.
	CChordScalePropPageData chordscalePropPageData;
	CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;
	if( SUCCEEDED ( m_pPropPageMgr->m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
	{
		SetChordData(pChordScalePropPageData);
	}
	return CPropertyPage::OnSetActive();
}

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48


void CChordInversionPropPage::PlayChordInversion(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pIConductor == NULL)
	{
		IDMUSProdComponent* pIComponent = NULL;
		if (m_pPropPageMgr->m_pIFramework)
		{
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				HRESULT hr = pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
				pIComponent->Release();
				if(FAILED(hr))
				{
					ASSERT(FALSE);
					return;
				}

			}
		}
	}
	
	short nX;
	DWORD dwTime = 0;
	ChangePatch(0,0,0,0);

	// determine chord inversions
	int bass,third,fifth, seventh;
	BitFlag bfChord(m_Chord.SubChord(index)->ChordPattern());
	m_Chord.SubChord(index)->ChordNotes(bass, third, fifth, seventh);
	int inversion = m_invertStates[index].Get();
	if(inversion >= InversionState::First && third > -1)
	{
		bfChord.ClearBit(bass);
		bfChord.SetBit(bass+12);
	}
	if(inversion >= InversionState::Second && fifth > -1)
	{
		bfChord.ClearBit(third);
		bfChord.SetBit(third+12);
	}
	if(inversion >= InversionState::Third &&  seventh > -1)
	{
		bfChord.ClearBit(fifth);
		bfChord.SetBit(fifth+12);
	}
	DWORD dwChord = bfChord;
	DWORD root = m_Chord.SubChord(index)->ChordRoot() % 12;

	for (nX = 0; nX < 24; nX++)
	{
		if ((dwChord >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + root);
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
			dwTime += CHORDNOTE_DUR;
		}
	}
}

HRESULT CChordInversionPropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = static_cast<BYTE>(0x90 + (ch&0xf));	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = static_cast<BYTE>(0x80 + (ch&0xf));	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordInversionPropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordDialog.cpp ===
// ChordDialog.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#pragma warning(default:4201)
#include "ChordDialog.h"
#include "PersonalityCtl.h"
#include "ChordMapStripMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void SetFocusCallback(long hint)
{
	((CPersonalityCtrl*)hint)->SetLastFocus(CPersonalityCtrl::ChordMap);
}

/////////////////////////////////////////////////////////////////////////////
// CChordDialog dialog


CChordDialog::CChordDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CChordDialog::IDD, pParent)
{
	m_pITimeline = NULL;
	m_pPersonality = NULL;
	m_pChordMapStrip = NULL;
	EnableAutomation();

	//{{AFX_DATA_INIT(CChordDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChordDialog::~CChordDialog()
{
	ASSERT( m_pITimeline == NULL );
	ASSERT( m_pPersonality == NULL );
	ASSERT( m_pChordMapStrip == NULL );
}

void CChordDialog::OnFinalRelease()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CDialog::OnFinalRelease();
}

void CChordDialog::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordDialog, CDialog)
	//{{AFX_MSG_MAP(CChordDialog)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CChordDialog, CDialog)
	//{{AFX_DISPATCH_MAP(CChordDialog)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IChordDialog to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {2B651782-E908-11D0-9EDC-00AA00A21BA9}
static const IID IID_IChordDialog =
{ 0x2b651782, 0xe908, 0x11d0, { 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9 } };

BEGIN_INTERFACE_MAP(CChordDialog, CDialog)
	INTERFACE_PART(CChordDialog, IID_IChordDialog, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordDialog message handlers

BOOL CChordDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1) );

	// Initialize the Timeline
	CWnd *pWnd = GetDlgItem(IDC_TIMELINECTL);
	if( pWnd == NULL ) return FALSE;

	IUnknown *punk = pWnd->GetControlUnknown();
	if( punk == NULL ) return FALSE;

	if( (FAILED(punk->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pITimeline ))) ||
		(m_pITimeline == NULL) )
	{
		return FALSE;
	}

	// Set Timeline properties and then Add the Strip Manager
	ASSERT( m_pPersonality->m_punkChordMapMgr != NULL );
	VARIANT vtInit;
	V_UNKNOWN(&vtInit) = m_pPersonality->m_pComponent->m_pIFramework;
	vtInit.vt = VT_UNKNOWN;
	m_pITimeline->SetTimelineProperty( TP_DMUSPRODFRAMEWORK, vtInit );

	// set the zoom factor
	vtInit.vt = VT_R8;
	V_R8(&vtInit) = m_pPersonality->ZoomFactor();
	m_pITimeline->SetTimelineProperty(TP_ZOOM, vtInit);

	// set the functionbar width
	vtInit.vt = VT_I4;
	V_I4(&vtInit) = m_pPersonality->FunctionbarWidth();
	m_pITimeline->SetTimelineProperty(TP_FUNCTIONBAR_WIDTH, vtInit);

	// give personality a pointer to me
	m_pPersonality->m_pChordDlg = this;

	// Initialize the ChordStrip Manager.
	IDMUSProdStripMgr* pStripMgr;
	punk = m_pPersonality->m_punkChordMapMgr;
	if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr )))
	{
		m_pITimeline->AddStripMgr( pStripMgr, 1 );
		IChordMapMgr *pIChordMapMgr;
		if( SUCCEEDED( pStripMgr->QueryInterface( IID_IChordMapMgr, (void**)&pIChordMapMgr ) ) )
		{
			if( SUCCEEDED( pIChordMapMgr->CreateChordMapStrip( &m_pChordMapStrip )))
			{
				m_pITimeline->AddStrip( m_pChordMapStrip );

				vtInit.vt = VT_BOOL;
				V_BOOL(&vtInit) = (short)m_pPersonality->VariableNotFixed();
				m_pChordMapStrip->SetStripProperty((STRIPPROPERTY)666, vtInit);

				// set focus call back
				vtInit.vt = VT_INT;
				V_INT(&vtInit) = (long)SetFocusCallback;
				m_pChordMapStrip->SetStripProperty((STRIPPROPERTY)(WM_USER+1), vtInit);
				vtInit.vt = VT_INT;
				V_INT(&vtInit) = (long)m_pPersonalityCtrl;
				m_pChordMapStrip->SetStripProperty((STRIPPROPERTY)(WM_USER+2), vtInit);

	//			m_pChordMapStrip->Release(); // Intentionally missing (needed for 'this' Strip reference).

				// Set the Timeline's callback member so we get callbacks when data changes
				// in the ChordMap Strip.
				IUnknown *punkPersonality;
				if( SUCCEEDED( m_pPersonality->QueryInterface( IID_IDMUSProdTimelineCallback, (void**)&punkPersonality )) )
				{
					vtInit.vt = VT_UNKNOWN;
					V_UNKNOWN(&vtInit) = punkPersonality;
					m_pITimeline->SetTimelineProperty( TP_TIMELINECALLBACK, vtInit );

					DMUS_TIMESIGNATURE timesig;
					timesig.mtTime = 0;
					timesig.bBeatsPerMeasure = static_cast<BYTE>(m_pPersonality->GetBPM());
					timesig.bBeat = static_cast<BYTE>(m_pPersonality->GetBeat());
					if(timesig.bBeat > 4)
					{
						// compound meter
						timesig.wGridsPerBeat = 3;
					}
					else
					{
						// simple meter
						timesig.wGridsPerBeat = 4;
					}

					m_pITimeline->SetParam(GUID_TimeSignature, 0xFFFFFFFF, 0, 0, static_cast<void*>(&timesig));


					punkPersonality->Release();
				}			
			}
			pIChordMapMgr->Release();
		}
		pStripMgr->Release();
	}



	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordDialog::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnSize(nType, cx, cy);
	

	CWnd *pWnd = GetDlgItem( IDC_TIMELINECTL );
	if( pWnd != NULL )
	{
		pWnd->MoveWindow( 0, 0, cx, cy );

		// now resize my window
		RECT rect;

		pWnd->GetClientRect(&rect);
		pWnd->CalcWindowRect(&rect);
		CalcWindowRect(&rect);
		MoveWindow(&rect);		
	}	
}

void CChordDialog::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// persist zoom factor to personality
	VARIANT var;
	m_pITimeline->GetTimelineProperty(TP_ZOOM, &var);
	double zoom = V_R8(&var);
	if(zoom != m_pPersonality->ZoomFactor())
	{
		m_pPersonality->ZoomFactor() = zoom;
		m_pPersonality->Modified() = TRUE;
	}

	m_pITimeline->GetTimelineProperty(TP_FUNCTIONBAR_WIDTH, &var);
	const long lFunctionbarWidth = V_I4(&var);
	if( lFunctionbarWidth != m_pPersonality->FunctionbarWidth() )
	{
		m_pPersonality->FunctionbarWidth() = lFunctionbarWidth;
		m_pPersonality->Modified() = TRUE;
	}

	// tell personality we're no longer around
	m_pPersonality->m_pChordDlg = 0;

	// Release the Timeline/CPersonality callback mechanism.
	VARIANT vtInit;
	V_UNKNOWN(&vtInit) = NULL;
	vtInit.vt = VT_UNKNOWN;
	m_pITimeline->SetTimelineProperty( TP_TIMELINECALLBACK, vtInit );

	RELEASE( m_pITimeline );
	m_pITimeline = NULL;

	RELEASE( m_pPersonality );
	m_pPersonality = NULL;

	m_pPersonalityCtrl = NULL;

	RELEASE( m_pChordMapStrip );
	m_pChordMapStrip = NULL;

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}
	

	CDialog::OnDestroy();
}

void CChordDialog::InitializeDialog( CPersonality* pPersonality, CPersonalityCtrl* const pCtl )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pPersonality);
	ASSERT(pCtl);

	ASSERT( m_pPersonality == NULL );
	m_pPersonality = pPersonality;
	m_pPersonality->AddRef();

	m_pPersonalityCtrl = pCtl;

	// this could go here or in CChordDialog as long as the two are opened at same time
	// basically, we need a place to initialize the style reference
	pPersonality->InitializeStyleReference();
	pPersonality->SyncPersonalityWithEngine(CPersonality::syncAudition);
}



BOOL CChordDialog::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	::TranslateAccelerator(m_hWnd, m_hAcceleratorTable, pMsg);
	
	return CDialog::PreTranslateMessage(pMsg);
}

void CChordDialog::Refresh(bool isStructual)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pChordMapStrip && m_pITimeline);
	if(isStructual)
	{
		KillProps();
	}
	m_pITimeline->StripInvalidateRect(m_pChordMapStrip, NULL, TRUE);
	m_pITimeline->Refresh();
}

void CChordDialog::KillProps()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pChordMapStrip->OnWMMessage(WM_COMMAND, IDM_KILLPROPS,  0,0,0);
}

void CChordDialog::ClearSelections()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pChordMapStrip->OnWMMessage(WM_COMMAND, IDM_CLEARSELECT,  0,0,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordInversionPropPage.h ===
#if !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
#include "..\shared\invertvector.h"

// ChordInversionPropPage.h : header file
//

class BitFlag
{
	unsigned long	dw;
public:
	BitFlag() { dw = 0; }
	BitFlag(unsigned long l) { dw = l; }
	BitFlag& operator = (unsigned long l)
	{
		dw = l;
		return *this;
	}
	unsigned long GetBit(int bit)
	{
		return dw & (1 << bit);
	}
	void SetBit(int bit)
	{
		dw |= (1 << bit);
	}
	void ClearBit(int bit)
	{
		dw &= ~(1<<bit);
	}
	operator unsigned long()
	{
		return dw;
	}
};

class InversionState
{
	int m_state;
public:
	enum { Root=0, First, Second, Third, NStates };
	InversionState()
	{
		m_state = Root;
	}
	void Reset()
	{
		m_state = Root;
	}
	int Get() const { return m_state; }
	void Set(int m)
	{
		ASSERT(Root <= m && m <= Third);
		if(Root <=m && m <= Third)
		{
			m_state = m;
		}
	}
	int Rotate(int highestInvert = -1)
	{
		//highestInvert == # notes in chord
		//highestInvert == -1 -> no inversion limit
		//highestInvert == 0 -> only a single note--nothing to invert
		if(highestInvert > NStates)
			highestInvert = NStates;	// 3 inversions is limit
		if(highestInvert != 0)
		{
			m_state = (m_state + 1) % ((highestInvert==-1) ? NStates : highestInvert );
		}
		return m_state;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage dialog
class CChordPropPageMgr;

class CChordInversionPropPage : public CPropertyPage
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordInversionPropPage)

// Construction
public:
	CChordInversionPropPage();
	~CChordInversionPropPage();
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=125};

// Dialog Data
	//{{AFX_DATA(CChordInversionPropPage)
	enum { IDD = IDD_CHORDINVERSION_PROPPAGE };
	CKeyboard	m_keysinv4;
	CKeyboard	m_keysinv3;
	CKeyboard	m_keysinv2;
	CKeyboard	m_keysinv1;
	CKeyboard	m_keysbase4;
	CKeyboard	m_keysbase3;
	CKeyboard	m_keysbase2;
	CKeyboard	m_keysbase1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordInversionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordInversionPropPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonInvert1();
	afx_msg void OnButtonInvert2();
	afx_msg void OnButtonInvert3();
	afx_msg void OnButtonInvert4();
	afx_msg void OnButtonIplay1();
	afx_msg void OnButtonIplay2();
	afx_msg void OnButtonIplay3();
	afx_msg void OnButtonIplay4();
	afx_msg void OnCheckLegal1();
	afx_msg void OnCheckLegal2();
	afx_msg void OnCheckLegal3();
	afx_msg void OnCheckLegal4();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayChordInversion(int index);
	int GetInversionKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetInversionKeyboard(int index);
	int GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetChordKeyboard(int index);
	void SetChord(CPropChord* pChord, int SubChord = -1 /* default = all subchords */);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();
	void DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX);
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

private:
	CBitmapButton	m_nextinvert4;
	CBitmapButton	m_nextinvert3;
	CBitmapButton	m_nextinvert2;
	CBitmapButton	m_nextinvert1;
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;

	InversionState	m_invertStates[CPropChord::MAX_POLY];
	InvertVector	m_invertVector[CPropChord::MAX_POLY];
	
	CPropChord		m_Chord;
	bool			m_fLockAllScales;
	bool			m_fSyncLevelOneToAll;

	DWORD			m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor* m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	bool	m_bValidChord;
	BOOL	m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordDialog.h ===
#if !defined(AFX_CHORDDIALOG_H__2B651783_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_CHORDDIALOG_H__2B651783_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ChordDialog.h : header file
//

#ifndef	__CHORDDIALOG_H__
#define __CHORDDIALOG_H__

#include "Timeline.h"
#include "Personality.h"

/////////////////////////////////////////////////////////////////////////////
// CChordDialog dialog

class CPersonalityCtrl;

class CChordDialog : public CDialog
{
	friend CPersonalityCtrl;
public:
	IDMUSProdStrip	*m_pChordMapStrip;
	
// Construction
public:
	void ClearSelections();
	void KillProps();
	void Refresh(bool isStructual);
	CChordDialog(CWnd* pParent = NULL);   // standard constructor
	~CChordDialog();
	double GetZoom()
	{
		// persist zoom factor to personality
		if(!m_pITimeline)
			return 0.0;
		VARIANT var;
		var.vt = VT_R8;
		m_pITimeline->GetTimelineProperty(TP_ZOOM, &var);
		return V_R8(&var);
	}
	LONG GetFunctionbarWidth()
	{
		// persist function bar width to personality
		if(!m_pITimeline)
			return 0;
		VARIANT var;
		m_pITimeline->GetTimelineProperty(TP_FUNCTIONBAR_WIDTH, &var);
		return V_I4(&var);
	}

	void InitializeDialog( CPersonality* pPersonality, CPersonalityCtrl* const pCtl );

	IDMUSProdTimeline	*m_pITimeline;
	CPersonality		*m_pPersonality;
	CPersonalityCtrl	*m_pPersonalityCtrl;

// Dialog Data
	//{{AFX_DATA(CChordDialog)
	enum { IDD = IDD_CHORD_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChordDialog)
	public:
	virtual void OnFinalRelease();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HACCEL					m_hAcceleratorTable;

	// Generated message map functions
	//{{AFX_MSG(CChordDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CChordDialog)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#endif

#endif // !defined(AFX_CHORDDIALOG_H__2B651783_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordIO.cpp ===
#include "stdafx.h"
#include "ChordIO.h"
#include "riffstrm.h"
#include "chord.h"

CChordItem::CChordItem()

{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
}

CChordItem::CChordItem(const CChordItem& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = chord.m_lDrawPosition;
	m_dwIndex = chord.m_dwIndex;
	m_fSelected = chord.m_fSelected;
	*((CPropChord*)this) = chord;
}

CChordItem::CChordItem(const ChordEntry& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	SetSelected(const_cast<ChordEntry&>(chord).m_chordsel.KeyDown());
	if( (chord.m_dwflags & CE_START) || (chord.m_dwflags & CE_END) )
	{
		m_fSelected |= SignPost;
		if(chord.m_dwflags & CE_START)
		{
			m_fSelected |= BegSignPost;
		}
		else
		{
			m_fSelected |= EndSignPost;
		}
	}
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chord).SaveToPropChord(*pProp);
}

CChordItem::CChordItem(const ChordSelection& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	ChordEntry chordentry;
	chordentry.m_chordsel = chord;
	SetSelected(const_cast<ChordSelection&>(chord).KeyDown());
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chordentry).SaveToPropChord(*pProp);
}


DWORD CChordList::PreparePropChord( CPropChord *pPropChord )

/*	Scan through the chord list and combine all chords that have
	m_fSelected set into the one chord for the property page.
*/

{
	DWORD dwSelectCount = 0;	// How many are selected.
	memset( (void *) pPropChord, 0, sizeof (CPropChord));
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			if (dwSelectCount == 0)
			{
				*pPropChord = *pChord;
				pPropChord->SetUndetermined(-1, 0);
			}
			else
			{
				pChord->CopyToPropChord(pPropChord, CPropChord::ALL);
			}
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

DWORD CChordList::RetrievePropChord( CPropChord *pPropChord )

{
	DWORD dwSelectCount = 0;	// How many are selected.
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			pChord->CopyFromPropChord(pPropChord, CPropChord::ALL);
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

void CChordList::InsertByAscendingTime(CChordItem* pChord)
{
	ASSERT(pChord);
	CChordItem* pItem = GetHead();
	while(pItem && *pItem < *pChord)
	{
		pItem = pItem->GetNext();
	}
	if(pItem)
	{
		InsertBefore(pItem, pChord);
	}
	else
	{
		AddTail(pChord);
	}
}

void CChordList::ClearSelections( )

{
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		pChord->SetSelected(FALSE);
	}
}

void CChordList::ClearList()
{
	CChordItem* pChord=RemoveHead();
	while( pChord )
	{
		delete pChord;
		pChord = RemoveHead();
	}
}


HRESULT CChordList::Load( LPSTREAM pStream )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioOldChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	hr = pStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED(hr) )
	{
		return hr;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMLoad(pStream);
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioOldChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioOldChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioOldChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioOldChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);
        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL );
        if( iChordSelection.fCSFlags & CSF_FLAT )
        {
            pChord->Base()->UseFlat() = 1;
        }
		if( iChordSelection.fCSFlags & CSF_SELECTED)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			pChord->SetSignPost(TRUE);
		}
		else
		{
			pChord->SetSignPost(FALSE);
		}
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.wMeasure;
		pChord->Base()->ChordPattern() = iChordSelection.aChord[0].lChordPattern;
		pChord->Base()->ScalePattern() = iChordSelection.aChord[0].lScalePattern;
		pChord->Base()->InvertPattern() = iChordSelection.aChord[0].lInvertPattern;
		pChord->Base()->Flags() = iChordSelection.aChord[0].wCFlags;
		pChord->Base()->ChordRoot() = iChordSelection.aChord[0].bRoot;
		pChord->Base()->ScaleRoot() = pChord->Base()->ChordRoot();
        pChord->SetBits(pChord->RootIndex());
		pChord->m_dwIndex = dwIndex++;
		pChord->PropagateAll();	// legacy: set all subchords to base chord
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

// Save the chordlist to a normal stream
HRESULT CChordList::Save( LPSTREAM pStream, BOOL bClearDirty )
{
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioOldChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMSave(pStream, bClearDirty);
	}

    wSize = sizeof( ioOldChordSelection );
//	FixBytes( FBT_SHORT, &wSize );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( ioOldChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.fCSFlags |= CSF_SELECTED;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
		}
/* not available in CChordItem
        if( pChord->inscale != 0 )
        {
            iChordSelection.fCSFlags |= CSF_INSCALE;
        }
        if( pChord->keydown != 0 )
        {
            iChordSelection.fCSFlags |= CSF_KEYDOWN;
        }
        if( ( pChord->bits & CHORD_SIMPLE ) != 0 )
        {
            iChordSelection.fCSFlags |= CSF_SIMPLE;
        }
*/
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.wMeasure = pChord->Measure();
        for( i = 0 ; i < 4 ; ++i )
        {
            iChordSelection.aChord[i].lChordPattern = pChord->Base()->ChordPattern();
            iChordSelection.aChord[i].lScalePattern = pChord->Base()->ScalePattern();
/* not available in CChordItem
            iChordSelection.aChord[i].lInvertPattern = ~0;
*/
            iChordSelection.aChord[i].bRoot = pChord->Base()->ChordRoot();
        }
//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}

HRESULT CChordList::DMLoad(IStream* pStream)
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	hr = pStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED(hr) )
	{
		return hr;
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);
        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL );

		if( iChordSelection.bKeydown)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			pChord->SetSignPost(TRUE);
		}
		else
		{
			pChord->SetSignPost(FALSE);
		}

		pChord->m_dwIndex = dwIndex++;
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.nMeasure;

		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			DMChord* pDM = pChord->SubChord(i);
			pDM->ChordPattern() = iChordSelection.aChord[i].dwChordPattern;
			pDM->ScalePattern() = iChordSelection.aChord[i].dwScalePattern;
			pDM->InvertPattern() = iChordSelection.aChord[i].dwInvertPattern;
			pDM->ChordRoot() = iChordSelection.aChord[i].bChordRoot;
			pDM->ScaleRoot() = iChordSelection.aChord[i].bScaleRoot;
			pDM->Flags() = iChordSelection.aChord[i].wFlags;
			pDM->Levels() = iChordSelection.aChord[i].dwLevels;
			pDM->UseFlat() = iChordSelection.aChord[i].bFlat;
			pDM->InUse() = iChordSelection.aChord[i].bInUse;
			pDM->Bits() = iChordSelection.aChord[i].bBits;
		}
		
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

HRESULT CChordList::DMSave(IStream* pStream, BOOL bClearDirty)
{
	UNREFERENCED_PARAMETER(bClearDirty);
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

    wSize = sizeof( ioChordSelection );
//	FixBytes( FBT_SHORT, &wSize );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( iChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.bKeydown = TRUE;
		}
		else
		{
			iChordSelection.bKeydown = FALSE;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
		}
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.nMeasure = pChord->Measure();
        for( i = 0 ; i < DMPolyChord::MAX_POLY ; ++i )
        {
			DMChord* pDM = pChord->SubChord(i);
            iChordSelection.aChord[i].dwChordPattern = pDM->ChordPattern();
            iChordSelection.aChord[i].dwScalePattern = pDM->ScalePattern();
			iChordSelection.aChord[i].dwInvertPattern = pDM->InvertPattern();
            iChordSelection.aChord[i].bChordRoot = pDM->ChordRoot();
			iChordSelection.aChord[i].bScaleRoot = pDM->ScaleRoot();
			iChordSelection.aChord[i].dwLevels = pDM->Levels();
			iChordSelection.aChord[i].bFlat = pDM->UseFlat();
			iChordSelection.aChord[i].bInUse = pDM->InUse();
			iChordSelection.aChord[i].wFlags = pDM->Flags();
			iChordSelection.aChord[i].bBits = pDM->Bits();
        }
//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordIO.h ===
#ifndef __CHORDIO_H_
#define __CHORDIO_H_

#include "dmusprod.h"
#include "DWList.h"
#include "PropChord.h"

class ChordEntry;
class ChordSelection;
class CChordItem : public DWListItem, public CPropChord
{
//	Used to track the selection of the chord in display.
	DWORD		m_fSelected;		// Selection and more
public:
	enum {Selected = 1, SignPost = 2, BegSignPost = 4, EndSignPost = 8}; 
	CChordItem();
	CChordItem(const CChordItem&);
	CChordItem(const ChordEntry&);
	CChordItem(const ChordSelection&);
	CChordItem& operator = (const CChordItem& item)
	{
		*dynamic_cast<CPropChord*>(this) = dynamic_cast<const CPropChord&>(item);
		m_fSelected = item.m_fSelected;
		return *this;
	}
	CChordItem *    GetNext() {return(CChordItem *)DWListItem::GetNext();};

	BOOL IsSelected() { return m_fSelected & Selected; }
	void SetSelected(BOOL b)
	{
		if(b)
		{
			m_fSelected |= Selected;
		}
		else
		{
			m_fSelected &= ~Selected;
		}
	}

	BOOL IsSignPost() { return m_fSelected & SignPost; }
	DWORD FSelected() { return m_fSelected; }
	void SetSignPost(BOOL b)
	{
		if(b)
		{
			m_fSelected |= SignPost;
		}
		else
		{
			m_fSelected &= ~SignPost;
		}
	}

//	Used to manage drawing and indexing.
	long		m_lDrawPosition;	// Drawn position in strip.
	DWORD		m_dwIndex;			// Index in list. (probably not needed anymore)
}; 

class CChordList : public DWList
{
public:
    CChordItem *    GetHead() {return(CChordItem *)DWList::GetHead();};
	CChordItem *	RemoveHead() { return(CChordItem *)DWList::RemoveHead();};
	void		ClearList();
	void		ClearSelections();
	DWORD		PreparePropChord( CPropChord *pPropChord );
	DWORD		RetrievePropChord( CPropChord *pPropChord );
	void		InsertByAscendingTime(CChordItem *pChord);	// *pChord <= *(pChord->next)
	HRESULT		Load( LPSTREAM pStream );
	HRESULT		Save( LPSTREAM pStream, BOOL bClearDirty );
	HRESULT		DMLoad(IStream* pStream);
	HRESULT		DMSave(IStream* pStream, BOOL bClearDirty);
};


typedef struct ioOldChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;			// root note of chord
	BYTE    bReserved;		// expansion room
	WORD    wCFlags;		// bit flags
	long	lReserved;		// expansion room
} ioOldChord;

typedef struct ioOldChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioOldChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioOldChordSelection;


typedef struct ioChord
{
	DWORD	dwChordPattern;	// pattern that defines chord
	DWORD	dwScalePattern;	// scale pattern for the chord
	DWORD	dwInvertPattern;	// inversion pattern
	DWORD	dwLevels;				// what levels this chord supports
    BYTE    bChordRoot;			// root note of chord
	BYTE    bScaleRoot;		// root note of scale
	BYTE	bFlat;
	BYTE	bBits;
	WORD    wFlags;		// bit flags
	bool		bInUse;
} ioChord;

typedef struct ioChordSelection
{
    ioChord aChord[DMPolyChord::MAX_POLY];      // array of chords: levels
	DWORD	dwTime;
	short		nMeasure;
	BYTE	bBeat;
	BYTE	bRootIndex;
    wchar_t wstrName[DMPolyChord::MAX_NAME];   // text for display
	bool		bKeydown;
	BYTE	fCSFlags;
} ioChordSelection;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80, // this chord is selected
	CSF_SIGNPOST = 0x40, // this chord is from a signpost
	CSF_SHIFTED = 0x20	// this chord has been altered from an illegal chord
						// used to make chord unique so that Load subchord database code works correctly
						// (see use in ChordDatabase.cpp)
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
*/
#endif // __CHORDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\DWList.cpp ===
//
// DWList.cpp
//

#include "stdafx.h"  

#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include "DWList.h"

LONG DWListItem::GetCount(void) const
{
    LONG l;
    const DWListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

DWListItem* DWListItem::Cat(DWListItem *pItem)
{
    DWListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

DWListItem* DWListItem::Remove(DWListItem *pItem)
{
    DWListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

DWListItem* DWListItem::GetPrev(DWListItem *pItem) const
{
    const DWListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (DWListItem*)prev;
}

DWListItem * DWListItem::GetItem(LONG index)

{
	DWListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void DWList::InsertBefore(DWListItem *pItem,DWListItem *pInsert)

{
	DWListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\DWList.h ===
//
// DWList.h
//
#ifndef __DWList_H__
#define __DWList_H__

//#pragma warning(disable: 4505)

class DWListItem
{
public:
    DWListItem() { m_pNext=NULL; };
    DWListItem *GetNext() const {return m_pNext;};
    void SetNext(DWListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    DWListItem* Cat(DWListItem* pItem);
    DWListItem* AddTail(DWListItem* pItem) {return Cat(pItem);};
    DWListItem* Remove(DWListItem* pItem);
    DWListItem* GetPrev(DWListItem *pItem) const;
    DWListItem* GetItem(LONG index);

private:
    DWListItem *m_pNext;
};

class DWList
{
public:
    DWList() {m_pHead=NULL;};
    DWListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    DWListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(DWListItem *pItem,DWListItem *pInsert);
    void Cat(DWListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(DWList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(DWListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(DWListItem *pItem) {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(DWListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    DWListItem *GetPrev(DWListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    DWListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    DWListItem *RemoveHead(void)
        {
            DWListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            return li;
        }

protected:
    DWListItem *m_pHead;
};

class IndexList : public DWList 
{
public:
				IndexList() { 
					DWList();
					m_index = 0; 
				};
	DWListItem	*GetIndexedItem() { return(GetItem(m_index)); }
	void		SetIndex(LONG index)
				{
					m_index = index;
					if (GetCount() <= (LONG) index) m_index = 0;
				}
	DWListItem	*RemoveIndexedItem()
				{
					DWListItem *item = GetIndexedItem();
					if (item) Remove(item);
					return (item);
				}
	void		AddIndexedItem(DWListItem *item)
				{
					AddHead(item);
					m_index = 0;
				}

	LONG		m_index;
};

#endif // __DWList_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordScalePropPage.cpp ===
// ChordScalePropPage.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "DllBasePropPageManager.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordScalePropPage.h"
#include "IllegalChord.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////// Callbacks for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}

void RMouseKeyboardCallback(CKeyboard* pKeyboard, void* hint, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchRightMouseKeyboard(pKeyboard, nKey, ptMouse);
}

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage property page

IMPLEMENT_DYNCREATE(CChordScalePropPage, CPropertyPage)

CChordScalePropPage::CChordScalePropPage() : CPropertyPage(CChordScalePropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	//{{AFX_DATA_INIT(CChordScalePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
	AddRef();

	m_MidiInIds[0] = IDC_BUTTON_MIDICHORD1;
	m_MidiInIds[1] = IDC_BUTTON_MIDICHORD2;
	m_MidiInIds[2] = IDC_BUTTON_MIDICHORD3;
	m_MidiInIds[3] = IDC_BUTTON_MIDICHORD4;

	m_MidiInIds[4] = IDC_BUTTON_MIDISCALE1;
	m_MidiInIds[5] = IDC_BUTTON_MIDISCALE2;
	m_MidiInIds[6] = IDC_BUTTON_MIDISCALE3;
	m_MidiInIds[7] = IDC_BUTTON_MIDISCALE4;

	m_MidiInIds[8] = 0;

	m_nLastKeyboardLevel = -1;

	m_bNotWarn = FALSE;
}

CChordScalePropPage::~CChordScalePropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordScalePropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordScalePropPage)
	DDX_Control(pDX, IDC_SPIN_ROOT, m_spinRoot);
	DDX_Control(pDX, IDC_EDIT_NAME, m_chordname);
	DDX_Control(pDX, IDC_KEYS_SCALE4, m_keysscale4);
	DDX_Control(pDX, IDC_KEYS_SCALE3, m_keysscale3);
	DDX_Control(pDX, IDC_KEYS_SCALE2, m_keysscale2);
	DDX_Control(pDX, IDC_KEYS_SCALE1, m_keysscale1);
	DDX_Control(pDX, IDC_KEYS_CHORD4, m_keyschord4);
	DDX_Control(pDX, IDC_KEYS_CHORD3, m_keyschord3);
	DDX_Control(pDX, IDC_KEYS_CHORD2, m_keyschord2);
	DDX_Control(pDX, IDC_KEYS_CHORD1, m_keyschord1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordScalePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordScalePropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD4, OnButtonMidichord4)
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD1, OnButtonMidichord1)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD2, OnButtonMidichord2)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD3, OnButtonMidichord3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE1, OnButtonMidiscale1)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE2, OnButtonMidiscale2)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE3, OnButtonMidiscale3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE4, OnButtonMidiscale4)
	ON_BN_CLICKED(IDC_BUTTON_PLAY1, OnButtonPlay1)
	ON_BN_CLICKED(IDC_BUTTON_PLAY2, OnButtonPlay2)
	ON_BN_CLICKED(IDC_BUTTON_PLAY3, OnButtonPlay3)
	ON_BN_CLICKED(IDC_BUTTON_PLAY4, OnButtonPlay4)
	ON_BN_CLICKED(IDC_BUTTON_PLAYALL, OnButtonPlayall)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_WM_KILLFOCUS()
	ON_BN_CLICKED(IDC_USEFLATS, OnUseflats)
	ON_BN_CLICKED(IDC_USESHARPS, OnUsesharps)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ROOT, OnDeltaposSpinRoot)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage message handlers


///////////////////////////////////////////////////////////////////////////
// CChordScalePropPage other funcs
const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48

HRESULT CChordScalePropPage::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	UNREFERENCED_PARAMETER(rtTime);

	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);

		// set note
		short nKey = static_cast<short>(bData1 - KeyOCXTrans);

		if(m_fMidiInputTarget < 4)
		{
			bool rootHasChanged = m_fMidiInputTarget == 0 && (nKey <= m_Chord.Base()->ChordRoot());
			DispatchKeyboardChange(GetChordKeyboard(m_fMidiInputTarget), nKey);
			if(rootHasChanged)
			{
//				GetChordKeyboard(m_fMidiInputTarget)->SetLowerBound(GetChordKeyboard(m_fMidiInputTarget)->Transpose());
			}
		}
		else if(m_fMidiInputTarget < 8)
		{
			DispatchKeyboardChange(GetScaleKeyboard(m_fMidiInputTarget - 4), nKey);
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 7, 100, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 10, 63, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 32, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 0, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent(static_cast<BYTE>(bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void CChordScalePropPage::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void CChordScalePropPage::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordScalePropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

BOOL CChordScalePropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	
	for(int i = 0; i < MAX_POLY; i++)
	{
		GetChordKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetScaleKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetChordKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetExtent(12);
		GetChordKeyboard(i)->SetExtent(48);
		GetChordKeyboard(i)->SetRootKeys(24);
		GetScaleKeyboard(i)->SetRootKeys(0);
	}
	
	m_midichord4.AutoLoad(IDC_BUTTON_MIDICHORD4, this);
	m_midichord3.AutoLoad(IDC_BUTTON_MIDICHORD3, this);
	m_midichord2.AutoLoad(IDC_BUTTON_MIDICHORD2, this);
	/*
	m_midichord1.Create( "MIDIPLUG", 
									 BS_OWNERDRAW | BS_AUTOCHECKBOX | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
									 CRect(14,84,26,94), 
									 this, 
									 IDC_BUTTON_MIDICHORD1 );
									 */
	m_midichord1.AutoLoad(IDC_BUTTON_MIDICHORD1, this);
//	m_midichord1.LoadBitmaps( "MIDIPLUGU", "MIDIPLUGD");



	m_midiscale4.AutoLoad(IDC_BUTTON_MIDISCALE4, this);
	m_midiscale3.AutoLoad(IDC_BUTTON_MIDISCALE3, this);
	m_midiscale2.AutoLoad(IDC_BUTTON_MIDISCALE2, this);
	m_midiscale1.AutoLoad(IDC_BUTTON_MIDISCALE1, this);


//	m_midiroot.AutoLoad(IDC_BUTTON_MIDIROOT, this);


	m_play4.AutoLoad(IDC_BUTTON_PLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_PLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_PLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_PLAY1, this);

	m_playall.AutoLoad(IDC_BUTTON_PLAYALL, this);



	CPropertyPage::OnInitDialog();

	m_chordname.LimitText(11);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CChordScalePropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordScalePropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}


void CChordScalePropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	CButton* pButton = GetButton(nIDCtl);
	if(pButton)
	{
		lpDrawItemStruct->itemState = pButton->GetChecked() ? ODS_SELECTED : ODS_DEFAULT;
	}
*/		
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);	
}

void CChordScalePropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

void CChordScalePropPage::OnButtonMidichord1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord1);
}

void CChordScalePropPage::OnButtonMidichord2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord2);
}

void CChordScalePropPage::OnButtonMidichord3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord3);
}
void CChordScalePropPage::OnButtonMidichord4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord4);	
}

void CChordScalePropPage::OnButtonMidiroot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Root);
}

void CChordScalePropPage::OnButtonMidiscale1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale1);
}

void CChordScalePropPage::OnButtonMidiscale2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale2);
}

void CChordScalePropPage::OnButtonMidiscale3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale3);
}

void CChordScalePropPage::OnButtonMidiscale4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale4);
}

void CChordScalePropPage::OnButtonPlay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(0);
}

void CChordScalePropPage::OnButtonPlay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(1);	
}

void CChordScalePropPage::OnButtonPlay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(2);
}

void CChordScalePropPage::OnButtonPlay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(3);
}

void CChordScalePropPage::OnButtonPlayall() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayAllChords();
}

void CChordScalePropPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	char szName[30];
	GetDlgItemText(IDC_EDIT_NAME,szName,sizeof(szName));
	if (strcmp("",szName) && (strcmp(m_Chord.Name(),szName)))
	{
		strncpy(m_Chord.Name(),szName, DMPolyChord::MAX_NAME);
		m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_NAME;
		UpdateChordData();
	}

	
}

void CChordScalePropPage::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownChordKeys(pKeyboard, i, nKey);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownScaleKeys(pKeyboard, i, nKey);
	}
}

int CChordScalePropPage::GetChordKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

int CChordScalePropPage::GetScaleKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetScaleKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

void CChordScalePropPage::OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

	if(nKey < 0)
	{
		return;	// root too low
	}

	if (m_Chord.GetUndetermined(index) & UD_CHORDPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		for (short iKey = 0; iKey < 24; iKey++)
		{
			pKeyboard->SetNoteState(iKey,"",static_cast<short>((1 && ((m_Chord.SubChord(index)->ChordPattern() >> iKey) & 1)) << 1));
		}
	}
	else
	{
		bool rootHasChanged = false;
		short root = static_cast<short>(m_Chord.SubChord(index)->ChordRoot());
		if(nKey < root)
		{
			// root is lower, but we want to keep same chord members so shift up
			// but first make sure that we're not increasing span of chord > 2 octaves
			DWORD shift = root - nKey;
			DWORD pattern = 0xFFFFFFFF << (23 - shift);
			bool bTooHigh = m_Chord.SubChord(index)->ChordPattern() != 0 // an empty chord can never be too high
								&& (HighestBit(m_Chord.SubChord(index)->ChordPattern()) + root  - nKey) >= 24;

			if(root - nKey > 23)
			{
				WarnUser();
			}
			else if(!bTooHigh || (pattern & m_Chord.SubChord(index)->ChordPattern()) == 0)
			{
				// new root
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(nKey);
				rootHasChanged = true;
				m_Chord.SubChord(index)->ChordPattern() <<= shift;
				// make sure anything higher than two octaves of pattern is cutoff.
				m_Chord.SubChord(index)->ChordPattern() &= 0x00ffffff;
				// add member for root note
				m_Chord.SubChord(index)->ChordPattern() |= 0x1;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}
		else if(m_Chord.SubChord(index)->ChordPattern() == 0)
		{
			// this is the first note of chord hence it is the root.
			rootHasChanged = true;
			m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(nKey);

			m_Chord.SubChord(index)->ChordPattern() = 1;
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else if(nKey == root)
		{
			// root must be set so clear it
			pKeyboard->SetNoteState(static_cast<short>(nKey-pKeyboard->Transpose()),"",0);
			// new root
			rootHasChanged = true;
			// third of chord is now root
			root = static_cast<short>(m_Chord.SubChord(index)->Third(0));
			if(root < 0)
			{
				// no chord, set root to lowest note
				root = 0;
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(root);
				m_Chord.SubChord(index)->ChordPattern() = 0;
			}
			else
			{
				m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(root + nKey);
				// shift chord to "root" position, this also gets rid of old root note
				m_Chord.SubChord(index)->ChordPattern() >>= root;
			}
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else
		{
			//  just update chord
			// if further away from root than 24 semitones, don't allow it
			// TODO: warn user
			DWORD shift = nKey - m_Chord.SubChord(index)->ChordRoot();
			if(shift < 24)
			{
				shift = 1 << shift;
				m_Chord.SubChord(index)->ChordPattern() ^= shift;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
				short state = static_cast<short>(m_Chord.SubChord(index)->ChordPattern() & shift ? 2 : 0);
				pKeyboard->SetNoteState(static_cast<short>(nKey),"", state);
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}


		if(rootHasChanged)
		{
			// need to redraw chord and scale keyboards
			int root = m_Chord.SubChord(index)->ChordRoot();
			for (int nX = root; nX < root + 24; nX++)
			{
				if(nX >= 48)
					break;
				short nState;
				if (m_Chord.GetUndetermined(m_Chord.RootIndex()) & UD_CHORDPATTERN) 
					nState = 4;
				else 
					nState = 0;
				if ((m_Chord.SubChord(index)->ChordPattern() >> (nX-root)) & 1) 
					nState += 2;
				pKeyboard->SetNoteState(static_cast<short>(nX),"",nState);

			}
			DrawScale(&m_Chord, index);
			if(index == m_Chord.RootIndex())
			{
				OnChangeRoot( false );
			}
		}
		else
		{
			short	scaleKey = static_cast<short>(nKey % 12);
			DrawScale(&m_Chord, index, scaleKey);
		}
	}

	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ChordPattern() = m_Chord.SubChord(index)->ChordPattern();
				m_Chord.SubChord(i)->ChordRoot() = m_Chord.SubChord(index)->ChordRoot();
				m_Chord.Undetermined(i) &= ~UD_CHORDPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}


void CChordScalePropPage::OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

//	nKey = nKey - pKeyboard->Transpose();
	if(nKey < 0)
		nKey += 12;
	if(nKey > 23)
		nKey -= 12;
	short nOtherKey = static_cast<short>((nKey + 12) % 24);

	if (m_Chord.Undetermined(index) & UD_SCALEPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_SCALEPATTERN;
		DrawScale(&m_Chord, index);
	}
	else
	{
		DWORD dwScalePattern = m_Chord.SubChord(index)->ScalePattern();
		DWORD dwScaleRoot = m_Chord.SubChord(index)->ScaleRoot() % 12;
		dwScalePattern = Rotate24(dwScalePattern, dwScaleRoot);
		dwScalePattern ^= (1 << nKey);
		dwScalePattern ^= (1 << nOtherKey);
		dwScalePattern = Rotate24(dwScalePattern, 12-dwScaleRoot);
		m_Chord.SubChord(index)->ScalePattern() = dwScalePattern;
		DrawScale(&m_Chord, index);
	}

	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ScalePattern() = m_Chord.SubChord(index)->ScalePattern();
				m_Chord.Undetermined(i) &= ~UD_SCALEPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}

void CChordScalePropPage::DrawScale(CPropChord* pChord, int index, int note)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	// match bits
	DWORD dwScale = pChord->SubChord(index)->ScalePattern();
	DWORD dwChord = pChord->SubChord(index)->ChordPattern();
	DWORD dwBlueBits = BlueBits(dwChord, pChord->SubChord(index)->ChordRoot(),
													dwScale, pChord->SubChord(index)->ScaleRoot()
													);

	// draw scale
	int lower = (note == -1) ? 0 : note;
	int upper = (note == -1) ? 12 : note + 1;
	for(int i = lower; i < upper; i++)
	{
		short nState = nGrayed;
		if(dwScale & (1 << i))
		{
			nState = 2;
		}
		else if(dwBlueBits & (1 << i))
		{
			nState = 1;
		}
		GetScaleKeyboard(index)->SetNoteState(static_cast<short>(i),"",nState);
	}
}

void CChordScalePropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordScalePropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}

void CChordScalePropPage::SetChord(CPropChord * pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_NAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT,str);
	SetCheckBox(pChord, UD_FLAT, IDC_USEFLATS, pChord->Base()->UseFlat() && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_USESHARPS, !(pChord->Base()->UseFlat() && 1));
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for(int n = 0; n < CPropChord::MAX_POLY; n++)
	{
		GetChordKeyboard(n)->ClearKeys();
		GetScaleKeyboard(n)->ClearKeys();

		int root = static_cast<int>(pChord->SubChord(n)->ChordRoot());
		for (nX = root; nX < root+24; nX++)
		{
			if(nX >= 48)
				break;
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> (nX-root)) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
		}
		DrawScale(pChord, n);
	}
}

void CChordScalePropPage::SetCheckBox(CPropChord * pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->GetUndetermined(pChord->RootIndex()) & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(0);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}

}

BOOL CChordScalePropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RegisterMidi();
	
	return CPropertyPage::OnSetActive();
}


void CChordScalePropPage::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::OnKillFocus(pNewWnd);
	
	// TODO: Add your message handler code here
	
}


void CChordScalePropPage::OnChangeRoot( bool fUpdateChordData ) 
{

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	DMChord* pSub = m_Chord.SubChord(m_Chord.RootIndex());
	while(pSub->ChordRoot() > 23)
	{
		pSub->ChordRoot() -= 12;
		AfxMessageBox(IDS_ILLEGALCHORD);
		SetChord(&m_Chord);
	}
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;
	DrawScale(&m_Chord, m_Chord.RootIndex());

	if( fUpdateChordData )
	{
		UpdateChordData();
	}
}

void CChordScalePropPage::OnUseflats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 1;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::OnUsesharps() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 0;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::SetMidiIn(int keyboard)
{
	if(m_fMidiInputTarget == keyboard)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
			m_fMidiInputTarget  = None;
			UnRegisterMidi();
			return;
	}

	if(m_fMidiInputTarget != None)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
	}
	
	m_fMidiInputTarget = keyboard;
	CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
	pButton->SetState(TRUE);
	RegisterMidi();
}

CButton* CChordScalePropPage::GetButton(int id)
{
	CButton* pButton = 0;
	switch(id)
	{
	case IDC_BUTTON_MIDICHORD1:
		pButton = dynamic_cast<CButton*>(&m_midichord1);
		break;
	case IDC_BUTTON_MIDICHORD2:
		pButton = dynamic_cast<CButton*>(&m_midichord2);
		break;
	case IDC_BUTTON_MIDICHORD3:
		pButton = dynamic_cast<CButton*>(&m_midichord3);
		break;
	case IDC_BUTTON_MIDICHORD4:
		pButton = dynamic_cast<CButton*>(&m_midichord4);
		break;
	case IDC_BUTTON_MIDISCALE1:
		pButton = dynamic_cast<CButton*>(&m_midiscale1);
		break;
	case IDC_BUTTON_MIDISCALE2:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE3:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE4:
		pButton = dynamic_cast<CButton*>(&m_midiscale4);
		break;
	}
	return pButton;
}

void CChordScalePropPage::PlaySubChord(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for (nX = 0; nX < 24; nX++)
	{
		if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
		{
			 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR); 
			dwTime += CHORDNOTE_DUR;
		}
	}
	dwTime += CHORDNOTE_DELAY;
	for (nX = 0; nX < 25; nX++)
	{
		if ((m_Chord.SubChord(index)->ScalePattern() >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX+ m_Chord.SubChord(index)->ScaleRoot());
			PlayNote(0, note, 120, dwTime, SCALENOTE_DUR); 
			dwTime += SCALENOTE_DUR;
		}
	}
}

void CChordScalePropPage::PlayAllChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for(int index = 0; index < MAX_POLY; index++)
	{
		for (nX = 0; nX < 24; nX++)
		{
			if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
			{
				 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
				PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
				dwTime += CHORDNOTE_DUR;
			}
		}
		dwTime += CHORDNOTE_DUR*2;
	}
}

void CChordScalePropPage::OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// check that subchords is in range
	for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(j)->ChordRoot() - pNMUpDown->iDelta);
		DWORD pattern = m_Chord.SubChord(j)->ChordPattern();

		// skip empty patterns
		if(!pattern)
		{
			continue;
		}

		if(chordRoot < 0)
		{
			return;	// out of range
		}

		// check if highest note is in range
		short highestNote = 0;
		for(int k = 0; k < sizeof(DWORD)*8; k++)
		{
			if(pattern & (1 << k))
			{
				highestNote = k;
			}
		}
		if(highestNote + chordRoot >= 48)
		{
			return;	// out of range
		}
	}

	for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(i)->ChordRoot() - pNMUpDown->iDelta);
		bool changeScale = true;
		if (chordRoot < 0 || m_Chord.SubChord(i)->ChordPattern() == 0) 
		{
			chordRoot = 0;
			changeScale = false;
		}
		/*
		if (chordRoot  > 23) 
		{
			chordRoot = 23;
			changeScale = false;
		}
		*/
		m_Chord.SubChord(i)->ChordRoot() = (BYTE) chordRoot;

		if(changeScale)
		{
			if( m_fLockAllScales == false )
			{
				m_Chord.SubChord(i)->ScalePattern() = Rotate24(m_Chord.SubChord(i)->ScalePattern(), -pNMUpDown->iDelta);
			}
		}
	}

	char str[10];
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;

	SetChord(&m_Chord);
	OnChangeRoot( true );

	CWnd* pWnd = GetDlgItem(IDC_EDIT_ROOT);
	pWnd->SetFocus();

	*pResult = 0;
}

HRESULT CChordScalePropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = static_cast<BYTE>(0x90 + (ch&0xf));	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = static_cast<BYTE>(0x80 + (ch&0xf));	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordScalePropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}

BOOL CChordScalePropPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	int to, from, whatop;
	bool bModified = false;

	ComputeCopyOp((WORD)wParam, from, to, whatop);

	if(whatop > Nop)
	{
		switch(whatop)
		{
		case CopyChord:
			TRACE("CopyChord from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD3);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
				}
			}
			bModified = true;
			break;

		case CopyScale:
			TRACE("CopyScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;
		
		case CopyChordScale:
			TRACE("CopyChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD3);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;
		
		case ClearChordScale:
			TRACE("ClearChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ChordPattern() = 0;
				m_Chord[to]->ChordRoot() = 0;
				m_Chord[to]->ScalePattern() = 0;
				m_Chord[to]->ScaleRoot() = 0;
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					m_Chord[i]->ChordPattern() = 0;
					m_Chord[i]->ChordRoot() = 0;
					m_Chord[i]->ScalePattern() = 0;
					m_Chord[i]->ScaleRoot() = 0;
				}
			}
			bModified = true;
			break;
		
		default:
//			TRACE("No operation\n");
			break;
		}
	}
	else
	{
		// additional commands go here
		switch( wParam )
		{
			case IDM_LOCK_ALL_SCALES:
				m_fLockAllScales = m_fLockAllScales ? false : true;
				bModified = true;
				break;
			
			case IDM_SYNC_ALL_LEVELS:
				m_fSyncLevelOneToAll = m_fSyncLevelOneToAll ? false : true;
				bModified = true;
				break;
		}
	}

	if(bModified)
	{
		SetChord(&m_Chord);
		UpdateChordData();
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}

void CChordScalePropPage::DispatchRightMouseKeyboard(CKeyboard * pKeyboard, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(nKey);
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		TRACE("Right click on chord keyboard %d\n", i);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		TRACE("Right click on scale keyboard %d\n", i);
	}

	m_nLastKeyboardLevel = i;	// save keyboard that sent right click

	CMenu cMenu;
	if( cMenu.LoadMenu( MAKEINTRESOURCE(IDR_CHORDPROP) ) != 0 )
	{
		CMenu* pSubMenu = cMenu.GetSubMenu(0);
		if( pSubMenu )
		{
			pSubMenu->CheckMenuItem( IDM_LOCK_ALL_SCALES, (m_fLockAllScales ? MF_CHECKED : MF_UNCHECKED) );
			pSubMenu->CheckMenuItem( IDM_SYNC_ALL_LEVELS, (m_fSyncLevelOneToAll ? MF_CHECKED : MF_UNCHECKED) );

			for( int j = 3; j < 6; j++ )
			{
				CMenu* pSubSubMenu = pSubMenu->GetSubMenu( j );
				if( pSubSubMenu )
				{
					for( int k = 0; k < 4; k++ )
					{
						if( m_nLastKeyboardLevel == -1
						||  m_nLastKeyboardLevel == (3 - k) )
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_GRAYED );
						}
						else
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_ENABLED );
						}
					}
				}
			}

			pKeyboard->ClientToScreen( &ptMouse );

			MSG	msg;
			if( pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, (int)(ptMouse.x), (int)(ptMouse.y),
										  this ) != 0 )
			{
				::PeekMessage( &msg, pKeyboard->GetSafeHwnd(), 0, 0, PM_REMOVE ); // Remove the last mouse click msg from the queue.
			}
		}
	}
}



void CChordScalePropPage::ComputeCopyOp(WORD menuid, int & from, int & to, int & what)
{
	from = m_nLastKeyboardLevel;
	if(from == -1)
		return;		// not from a menu
	switch(menuid)
	{
	case ID_COPY_CHORD1:
		what = CopyChord;
		to = 0;
		break;
	case ID_COPY_CHORD2:
		what = CopyChord;
		to = 1;
		break;
	case ID_COPY_CHORD3:
		what = CopyChord;
		to = 2;
		break;
	case ID_COPY_CHORD4:
		what = CopyChord;
		to = 3;
		break;
	case ID_COPY_CHORDALL:
		what = CopyChord;
		to = All;
		break;

	case ID_COPY_SCALE1:
		what = CopyScale;
		to = 0;
		break;
	case ID_COPY_SCALE2:
		what = CopyScale;
		to = 1;
		break;
	case ID_COPY_SCALE3:
		what = CopyScale;
		to = 2;
		break;
	case ID_COPY_SCALE4:
		what = CopyScale;
		to = 3;
		break;
	case ID_COPY_SCALEALL:
		what = CopyScale;
		to = All;
		break;

	case ID_COPY_CHORDSCALE1:
		what = CopyChordScale;
		to = 0;
		break;
	case ID_COPY_CHORDSCALE2:
		what = CopyChordScale;
		to = 1;
		break;
	case ID_COPY_CHORDSCALE3:
		what = CopyChordScale;
		to = 2;
		break;
	case ID_COPY_CHORDSCALE4:
		what = CopyChordScale;
		to = 3;
		break;
	case ID_COPY_CHORDSCALEALL:
		what = CopyChordScale;
		to = All;
		break;

	case ID_CLEAR_CHORDSCALE1:
		what = ClearChordScale;
		to = 0;
		break;
	case ID_CLEAR_CHORDSCALE2:
		what = ClearChordScale;
		to = 1;
		break;
	case ID_CLEAR_CHORDSCALE3:
		what = ClearChordScale;
		to = 2;
		break;
	case ID_CLEAR_CHORDSCALE4:
		what = ClearChordScale;
		to = 3;
		break;
	case ID_CLEAR_CHORDSCALEALL:
		what = ClearChordScale;
		to = All;
		break;

	default:
		what = Nop;
		break;
	}
	m_nLastKeyboardLevel = -1;
}

void CChordScalePropPage::WarnUser()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(!m_bNotWarn)
	{
		CIllegalChord dlg;
		dlg.m_bDontWarn = m_bNotWarn;
		dlg.DoModal();
		m_bNotWarn = dlg.m_bDontWarn;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\ChordScalePropPage.h ===
#if !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxext.h>
#include "resource.h"
#include "dmusici.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
// ChordScalePropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPageData (used to transfer data to/from property tab)

class CChordScalePropPageData
{
public:
	CChordScalePropPageData()
	{
		m_pPropChord = NULL;
		m_fLockAllScales = true;
		m_fSyncLevelOneToAll = true;
	}
	
	~CChordScalePropPageData()
	{
	}

	CPropChord*			m_pPropChord;
	bool				m_fLockAllScales;
	bool				m_fSyncLevelOneToAll;
};


/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage dialog
class CChordPropPageMgr;

class CChordScalePropPage : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordScalePropPage)

// Construction
public:
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=25};
	CChordScalePropPage();
	~CChordScalePropPage();
// dispatch callbacks from keyboard controls
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(CChordScalePropPage)
	enum { IDD = IDD_CHORDSCALE_PROPPAGE };
	CSpinButtonCtrl	m_spinRoot;
	CEdit	m_chordname;
	CKeyboard	m_keysscale4;
	CKeyboard	m_keysscale3;
	CKeyboard	m_keysscale2;
	CKeyboard	m_keysscale1;
	CKeyboard	m_keyschord4;
	CKeyboard	m_keyschord3;
	CKeyboard	m_keyschord2;
	CKeyboard	m_keyschord1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordScalePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordScalePropPage)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMidichord4();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnButtonMidichord1();
	afx_msg void OnButtonMidichord2();
	afx_msg void OnButtonMidichord3();
	afx_msg void OnButtonMidiroot();
	afx_msg void OnButtonMidiscale1();
	afx_msg void OnButtonMidiscale2();
	afx_msg void OnButtonMidiscale3();
	afx_msg void OnButtonMidiscale4();
	afx_msg void OnButtonPlay1();
	afx_msg void OnButtonPlay2();
	afx_msg void OnButtonPlay3();
	afx_msg void OnButtonPlay4();
	afx_msg void OnButtonPlayall();
	afx_msg void OnChangeEditName();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnUseflats();
	afx_msg void OnUsesharps();
	afx_msg void OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void WarnUser();
	void DispatchRightMouseKeyboard(CKeyboard* pKeyboard, short nKey, CPoint& ptMouse);
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayAllChords();
	void PlaySubChord(int index);
	void SetMidiIn(int keyboard);
	void SetChord(CPropChord* pChord);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();

	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

private:
	BOOL m_bNotWarn;
	enum {All = -1, Nop = 1000, CopyChord, CopyScale, CopyChordScale, ClearChordScale};	// chord to chord copy ops
	void ComputeCopyOp(WORD menuid, int& from, int& to, int& what);
	CButton* GetButton(int id);
	enum {None = -1, Chord1 = 0, Chord2 = 1, Chord3 = 2, Chord4 = 3, Scale1 = 4, Scale2 = 5, Scale3 = 6, Scale4 = 7, Root = 8};
	UINT	m_MidiInIds[MAX_POLY*2 + 1];
	int m_fMidiInputTarget;
	void OnChangeRoot( bool fUpdateChordData );
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	void OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey);
	void OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey);
//	void DrawScaleNote(CPropChord* pChord, int index, short nX);
	void DrawScale(CPropChord* pChord, int index, int note = -1 /* set this to do only one note */);
	int	GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	int GetScaleKeyboardIndex(const CKeyboard* pKeyboard);
	int m_nLastKeyboardLevel;	// keyboard last rightclicked on (for copy ops)
	CKeyboard*		GetChordKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keyschord1;			
			break;
		case 1:
			return &m_keyschord2;
			break;
		case 2:
			return &m_keyschord3;
			break;
		case 3:
			return &m_keyschord4;
			break;
		default:
			return 0;
			break;
		}
	}
	CKeyboard*		GetScaleKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keysscale1;
			break;
		case 1:
			return &m_keysscale2;
			break;
		case 2:
			return &m_keysscale3;
			break;
		case 3:
			return &m_keysscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midichord4;
	CBitmapButton	m_midichord3;
	CBitmapButton	m_midichord2;
	CBitmapButton	m_midichord1;
	CBitmapButton* GetMidiChordButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midichord1;			
			break;
		case 1:
			return &m_midichord2;
			break;
		case 2:
			return &m_midichord3;
			break;
		case 3:
			return &m_midichord4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midiscale4;
	CBitmapButton	m_midiscale3;
	CBitmapButton	m_midiscale2;
	CBitmapButton	m_midiscale1;
	CBitmapButton*	GetMidiScaleButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midiscale1;
			break;
		case 1:
			return &m_midiscale2;
			break;
		case 2:
			return &m_midiscale3;
			break;
		case 3:
			return &m_midiscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	
	CBitmapButton	m_midiroot;
	
	CBitmapButton	m_shiftl4;
	CBitmapButton	m_shiftl3;
	CBitmapButton	m_shiftl2;
	CBitmapButton	m_shiftl1;
	CBitmapButton* GetShiftLButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftl1;
			break;
		case 1:
			return &m_shiftl2;
			break;
		case 2:
			return &m_shiftl3;
			break;
		case 3:
			return &m_shiftl4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_shiftr4;
	CBitmapButton	m_shiftr3;
	CBitmapButton	m_shiftr2;
	CBitmapButton	m_shiftr1;
	CBitmapButton* GetShiftRButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftr1;
			break;
		case 1:
			return &m_shiftr2;
			break;
		case 2:
			return &m_shiftr3;
			break;
		case 3:
			return &m_shiftr4;
			break;
		default:
			return 0;
			break;
		}
	}
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;
	CBitmapButton* GetPlayButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_play1;
			break;
		case 1:
			return &m_play2;
			break;
		case 2:
			return &m_play3;
			break;
		case 3:
			return &m_play4;
			break;
		default:
			return 0;
			break;
		}
	}
		
	CBitmapButton	m_playall;
	
	BOOL			m_fNeedToDetach;
	bool			m_bValidChord;
	CPropChord		m_Chord;
	bool			m_fLockAllScales;
	bool			m_fSyncLevelOneToAll;

	DWORD				m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor*	m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	DWORD m_cRegCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\IllegalChord.h ===
#if !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
#define AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IllegalChord.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog

class CIllegalChord : public CDialog
{
// Construction
public:
	CIllegalChord(CWnd* pParent = NULL);   // standard constructor


// Dialog Data
	//{{AFX_DATA(CIllegalChord)
	enum { IDD = IDD_ILLEGALCHORD };
	CStatic	m_infotext;
	BOOL	m_bDontWarn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIllegalChord)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIllegalChord)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\keysocx.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "keysocx.h"

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX

IMPLEMENT_DYNCREATE(CKeysOCX, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX properties

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX operations

void CKeysOCX::SetNoteState(short nKey, LPCTSTR pszName, short nState)
{
	static BYTE parms[] =
		VTS_I2 VTS_BSTR VTS_I2;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nKey, pszName, nState);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\DlgChangeLength.cpp ===
// DlgChangeLength.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "personalitydesigner.h"
#include "DlgChangeLength.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgChangeLength dialog


CDlgChangeLength::CDlgChangeLength(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgChangeLength::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgChangeLength)
	m_strLength = _T("");
	//}}AFX_DATA_INIT

	bValidate = FALSE;
}


void CDlgChangeLength::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgChangeLength)
	DDX_Control(pDX, IDC_SPIN1, m_spinLength);
	DDX_Text(pDX, IDC_EDITLENGTH, m_strLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgChangeLength, CDialog)
	//{{AFX_MSG_MAP(CDlgChangeLength)
	ON_EN_CHANGE(IDC_EDITLENGTH, OnChangeEditlength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgChangeLength message handlers

BOOL CDlgChangeLength::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_spinLength.SetRange(1,100);
	CEdit* pEdit = static_cast<CEdit*>(GetDlgItem(IDC_EDITLENGTH));
	pEdit->LimitText(3);
	bValidate = FALSE;	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgChangeLength::OnChangeEditlength() 
{
	if(bValidate)
	{
		BOOL b;
		short n = (short)(GetDlgItemInt(IDC_EDITLENGTH, &b));
		if(!b || n < 1 || n > 100)
		{
			AfxMessageBox("Illegal Length - resetting to original value");
			m_strLength.Format("%d", m_nChordMapLength);
			UpdateData(FALSE);
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\DlgChangeLength.h ===
#if !defined(AFX_DLGCHANGELENGTH_H__9F9541FC_4402_11D1_981C_00805FA67D16__INCLUDED_)
#define AFX_DLGCHANGELENGTH_H__9F9541FC_4402_11D1_981C_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgChangeLength.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgChangeLength dialog

class CDlgChangeLength : public CDialog
{
// Construction
public:
	CDlgChangeLength(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgChangeLength)
	enum { IDD = IDD_ChangeLength };
	CSpinButtonCtrl	m_spinLength;
	CString	m_strLength;
	//}}AFX_DATA

	// use this only to set initial value
	void SetChordMapLength(short n)
	{
		m_nChordMapLength = n;
		m_strLength.Format("%d", n);
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgChangeLength)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
// Implementation
protected:
	short m_nChordMapLength;
	BOOL  bValidate;
	// Generated message map functions
	//{{AFX_MSG(CDlgChangeLength)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditlength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGCHANGELENGTH_H__9F9541FC_4402_11D1_981C_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\keysocx.h ===
#if !defined(AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX wrapper class
#pragma warning( disable : 4100 )
class CKeysOCX : public CWnd
{
protected:
	DECLARE_DYNCREATE(CKeysOCX)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xcdd09f86, 0xe73c, 0x11d0, { 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void SetNoteState(short nKey, LPCTSTR pszName, short nState);
};
#pragma warning( default : 4100 )

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\keysocx1.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "keysocx1.h"

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX1

IMPLEMENT_DYNCREATE(CKeysOCX1, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX1 properties

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX1 operations

void CKeysOCX1::SetNoteState(short nKey, LPCTSTR pszName, short nState)
{
	static BYTE parms[] =
		VTS_I2 VTS_BSTR VTS_I2;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nKey, pszName, nState);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\font.h ===
#if !defined(AFX_FONT1_H__29387B4F_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
#define AFX_FONT1_H__29387B4F_948E_11D2_BC93_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FONT1_H__29387B4F_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\IllegalChord.cpp ===
// IllegalChord.cpp : implementation file
//
#include "stdafx.h"
#pragma warning(disable:4201)
#include "personalitydesigner.h"
#include "IllegalChord.h"
#pragma warning(default:4201)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog


CIllegalChord::CIllegalChord(CWnd* pParent /*=NULL*/)
	: CDialog(CIllegalChord::IDD, pParent)
{
	//{{AFX_DATA_INIT(CIllegalChord)
	m_bDontWarn = FALSE;
	//}}AFX_DATA_INIT

}


void CIllegalChord::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIllegalChord)
	DDX_Control(pDX, IDC_ILLEGALCHORD, m_infotext);
	DDX_Check(pDX, IDC_DONTWARN, m_bDontWarn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIllegalChord, CDialog)
	//{{AFX_MSG_MAP(CIllegalChord)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord message handlers

BOOL CIllegalChord::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString s1,s2;

	s1.LoadString(IDS_ILLEGALCHORD2);
	s2.LoadString(IDS_DONTWARN);

	m_infotext.SetWindowText(s1);
	
	SetDlgItemText(IDC_DONTWARN, s2);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\msflexgrid.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "msflexgrid.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"
#include "Picture.h"
#include "rowcursor.h"

/////////////////////////////////////////////////////////////////////////////
// CMSFlexGrid

IMPLEMENT_DYNCREATE(CMSFlexGrid, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMSFlexGrid properties

/////////////////////////////////////////////////////////////////////////////
// CMSFlexGrid operations

long CMSFlexGrid::GetRows()
{
	long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRows(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetCols()
{
	long result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCols(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetFixedRows()
{
	long result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFixedRows(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetFixedCols()
{
	long result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFixedCols(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSFlexGrid::GetVersion()
{
	short result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

CString CMSFlexGrid::GetFormatString()
{
	CString result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFormatString(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long CMSFlexGrid::GetTopRow()
{
	long result;
	InvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetTopRow(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetLeftCol()
{
	long result;
	InvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetLeftCol(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetRow()
{
	long result;
	InvokeHelper(0xa, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRow(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xa, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetCol()
{
	long result;
	InvokeHelper(0xb, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCol(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetRowSel()
{
	long result;
	InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRowSel(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetColSel()
{
	long result;
	InvokeHelper(0xd, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetColSel(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CMSFlexGrid::GetText()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

unsigned long CMSFlexGrid::GetBackColor()
{
	unsigned long result;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetForeColor()
{
	unsigned long result;
	InvokeHelper(DISPID_FORECOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetForeColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_FORECOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetBackColorFixed()
{
	unsigned long result;
	InvokeHelper(0xe, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetBackColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetForeColorFixed()
{
	unsigned long result;
	InvokeHelper(0xf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetForeColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetBackColorSel()
{
	unsigned long result;
	InvokeHelper(0x10, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetBackColorSel(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x10, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetForeColorSel()
{
	unsigned long result;
	InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetForeColorSel(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetBackColorBkg()
{
	unsigned long result;
	InvokeHelper(0x12, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetBackColorBkg(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x12, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL CMSFlexGrid::GetWordWrap()
{
	BOOL result;
	InvokeHelper(0x13, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetWordWrap(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x13, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

COleFont CMSFlexGrid::GetFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(DISPID_FONT, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CMSFlexGrid::SetRefFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(DISPID_FONT, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

float CMSFlexGrid::GetFontWidth()
{
	float result;
	InvokeHelper(0x54, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFontWidth(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x54, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

CString CMSFlexGrid::GetCellFontName()
{
	CString result;
	InvokeHelper(0x4d, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x4d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

float CMSFlexGrid::GetCellFontSize()
{
	float result;
	InvokeHelper(0x4e, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontSize(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x4e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL CMSFlexGrid::GetCellFontBold()
{
	BOOL result;
	InvokeHelper(0x4f, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontBold(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x4f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSFlexGrid::GetCellFontItalic()
{
	BOOL result;
	InvokeHelper(0x50, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontItalic(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x50, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSFlexGrid::GetCellFontUnderline()
{
	BOOL result;
	InvokeHelper(0x51, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontUnderline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x51, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CMSFlexGrid::GetCellFontStrikeThrough()
{
	BOOL result;
	InvokeHelper(0x52, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontStrikeThrough(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x52, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

float CMSFlexGrid::GetCellFontWidth()
{
	float result;
	InvokeHelper(0x53, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellFontWidth(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x53, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long CMSFlexGrid::GetTextStyle()
{
	long result;
	InvokeHelper(0x14, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetTextStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetTextStyleFixed()
{
	long result;
	InvokeHelper(0x15, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetTextStyleFixed(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSFlexGrid::GetScrollTrack()
{
	BOOL result;
	InvokeHelper(0x16, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetScrollTrack(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x16, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSFlexGrid::GetFocusRect()
{
	long result;
	InvokeHelper(0x17, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFocusRect(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x17, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetHighLight()
{
	long result;
	InvokeHelper(0x18, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetHighLight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSFlexGrid::GetRedraw()
{
	BOOL result;
	InvokeHelper(0x19, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRedraw(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x19, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSFlexGrid::GetScrollBars()
{
	long result;
	InvokeHelper(0x1a, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetScrollBars(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetMouseRow()
{
	long result;
	InvokeHelper(0x1b, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetMouseCol()
{
	long result;
	InvokeHelper(0x1c, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetCellLeft()
{
	long result;
	InvokeHelper(0x1d, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetCellTop()
{
	long result;
	InvokeHelper(0x1e, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetCellWidth()
{
	long result;
	InvokeHelper(0x1f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetCellHeight()
{
	long result;
	InvokeHelper(0x20, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CMSFlexGrid::GetRowHeightMin()
{
	long result;
	InvokeHelper(0x21, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRowHeightMin(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x21, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetFillStyle()
{
	long result;
	InvokeHelper(0xfffffe01, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetFillStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xfffffe01, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetGridLines()
{
	long result;
	InvokeHelper(0x22, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetGridLines(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x22, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetGridLinesFixed()
{
	long result;
	InvokeHelper(0x23, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetGridLinesFixed(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x23, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

unsigned long CMSFlexGrid::GetGridColor()
{
	unsigned long result;
	InvokeHelper(0x24, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetGridColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x24, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetGridColorFixed()
{
	unsigned long result;
	InvokeHelper(0x25, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetGridColorFixed(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x25, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetCellBackColor()
{
	unsigned long result;
	InvokeHelper(0x26, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x26, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CMSFlexGrid::GetCellForeColor()
{
	unsigned long result;
	InvokeHelper(0x27, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellForeColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x27, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CMSFlexGrid::GetCellAlignment()
{
	short result;
	InvokeHelper(0x28, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellAlignment(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x28, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetCellTextStyle()
{
	long result;
	InvokeHelper(0x29, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellTextStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x29, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSFlexGrid::GetCellPictureAlignment()
{
	short result;
	InvokeHelper(0x2b, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetCellPictureAlignment(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CMSFlexGrid::GetClip()
{
	CString result;
	InvokeHelper(0x2d, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetClip(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x2d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

void CMSFlexGrid::SetSort(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x2e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetSelectionMode()
{
	long result;
	InvokeHelper(0x2f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetSelectionMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetMergeCells()
{
	long result;
	InvokeHelper(0x30, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetMergeCells(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x30, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CMSFlexGrid::GetAllowBigSelection()
{
	BOOL result;
	InvokeHelper(0x33, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetAllowBigSelection(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x33, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSFlexGrid::GetAllowUserResizing()
{
	long result;
	InvokeHelper(0x34, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetAllowUserResizing(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x34, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetBorderStyle()
{
	long result;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetBorderStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetHWnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL CMSFlexGrid::GetEnabled()
{
	BOOL result;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetEnabled(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSFlexGrid::GetAppearance()
{
	long result;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetAppearance(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CMSFlexGrid::GetMousePointer()
{
	long result;
	InvokeHelper(0x35, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetMousePointer(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x35, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CPicture CMSFlexGrid::GetMouseIcon()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x36, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CPicture(pDispatch);
}

void CMSFlexGrid::SetRefMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x36, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

long CMSFlexGrid::GetPictureType()
{
	long result;
	InvokeHelper(0x32, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetPictureType(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x32, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CPicture CMSFlexGrid::GetPicture()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x31, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CPicture(pDispatch);
}

CPicture CMSFlexGrid::GetCellPicture()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x2a, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CPicture(pDispatch);
}

void CMSFlexGrid::SetRefCellPicture(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x2a, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

CString CMSFlexGrid::GetTextArray(long index)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x37, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetTextArray(long index, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BSTR;
	InvokeHelper(0x37, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, lpszNewValue);
}

short CMSFlexGrid::GetColAlignment(long index)
{
	short result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x38, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetColAlignment(long index, short nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2;
	InvokeHelper(0x38, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long CMSFlexGrid::GetColWidth(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x39, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetColWidth(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x39, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long CMSFlexGrid::GetRowHeight(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3a, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetRowHeight(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

BOOL CMSFlexGrid::GetMergeRow(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3b, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetMergeRow(long index, BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BOOL;
	InvokeHelper(0x3b, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, bNewValue);
}

BOOL CMSFlexGrid::GetMergeCol(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3c, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetMergeCol(long index, BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_BOOL;
	InvokeHelper(0x3c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, bNewValue);
}

void CMSFlexGrid::SetRowPosition(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

void CMSFlexGrid::SetColPosition(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3e, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long CMSFlexGrid::GetRowData(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetRowData(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

long CMSFlexGrid::GetColData(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x40, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetColData(long index, long nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x40, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

CString CMSFlexGrid::GetTextMatrix(long Row, long Col)
{
	CString result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x41, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		Row, Col);
	return result;
}

void CMSFlexGrid::SetTextMatrix(long Row, long Col, LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_BSTR;
	InvokeHelper(0x41, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 Row, Col, lpszNewValue);
}

void CMSFlexGrid::AddItem(LPCTSTR Item, const VARIANT& index)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x42, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Item, &index);
}

void CMSFlexGrid::RemoveItem(long index)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x43, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 index);
}

void CMSFlexGrid::Clear()
{
	InvokeHelper(0x44, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMSFlexGrid::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CRowCursor CMSFlexGrid::GetDataSource()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x4c, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CRowCursor(pDispatch);
}

void CMSFlexGrid::SetDataSource(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4c, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

BOOL CMSFlexGrid::GetRowIsVisible(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x55, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, parms,
		index);
	return result;
}

BOOL CMSFlexGrid::GetColIsVisible(long index)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x56, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, parms,
		index);
	return result;
}

long CMSFlexGrid::GetRowPos(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x57, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

long CMSFlexGrid::GetColPos(long index)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x58, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, parms,
		index);
	return result;
}

short CMSFlexGrid::GetGridLineWidth()
{
	short result;
	InvokeHelper(0x59, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetGridLineWidth(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x59, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CMSFlexGrid::GetFixedAlignment(long index)
{
	short result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x5a, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, parms,
		index);
	return result;
}

void CMSFlexGrid::SetFixedAlignment(long index, short nNewValue)
{
	static BYTE parms[] =
		VTS_I4 VTS_I2;
	InvokeHelper(0x5a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 index, nNewValue);
}

BOOL CMSFlexGrid::GetRightToLeft()
{
	BOOL result;
	InvokeHelper(0xfffffd9d, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetRightToLeft(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0xfffffd9d, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CMSFlexGrid::GetOLEDropMode()
{
	long result;
	InvokeHelper(0x60f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CMSFlexGrid::SetOLEDropMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x60f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CMSFlexGrid::OLEDrag()
{
	InvokeHelper(0x610, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\keysocx1.h ===
#if !defined(AFX_KEYSOCX1_H__1DF95106_798A_11D1_984C_00805FA67D16__INCLUDED_)
#define AFX_KEYSOCX1_H__1DF95106_798A_11D1_984C_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX1 wrapper class
#pragma warning(disable: 4100)
class CKeysOCX1 : public CWnd
{
protected:
	DECLARE_DYNCREATE(CKeysOCX1)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xcdd09f86, 0xe73c, 0x11d0, { 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void SetNoteState(short nKey, LPCTSTR pszName, short nState);
};
#pragma warning(default: 4100)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCX1_H__1DF95106_798A_11D1_984C_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\msflexgrid.h ===
#if !defined(AFX_MSFLEXGRID1_H__29387B4E_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
#define AFX_MSFLEXGRID1_H__29387B4E_948E_11D2_BC93_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;
class CPicture;
class CRowCursor;

/////////////////////////////////////////////////////////////////////////////
// CMSFlexGrid wrapper class

class CMSFlexGrid : public CWnd
{
protected:
	DECLARE_DYNCREATE(CMSFlexGrid)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x6262d3a0, 0x531b, 0x11cf, { 0x91, 0xf6, 0xc2, 0x86, 0x3c, 0x38, 0x5e, 0x30 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR /*lpszClassName*/,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* /*pContext = NULL*/)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	long GetRows();
	void SetRows(long nNewValue);
	long GetCols();
	void SetCols(long nNewValue);
	long GetFixedRows();
	void SetFixedRows(long nNewValue);
	long GetFixedCols();
	void SetFixedCols(long nNewValue);
	short GetVersion();
	CString GetFormatString();
	void SetFormatString(LPCTSTR lpszNewValue);
	long GetTopRow();
	void SetTopRow(long nNewValue);
	long GetLeftCol();
	void SetLeftCol(long nNewValue);
	long GetRow();
	void SetRow(long nNewValue);
	long GetCol();
	void SetCol(long nNewValue);
	long GetRowSel();
	void SetRowSel(long nNewValue);
	long GetColSel();
	void SetColSel(long nNewValue);
	CString GetText();
	void SetText(LPCTSTR lpszNewValue);
	unsigned long GetBackColor();
	void SetBackColor(unsigned long newValue);
	unsigned long GetForeColor();
	void SetForeColor(unsigned long newValue);
	unsigned long GetBackColorFixed();
	void SetBackColorFixed(unsigned long newValue);
	unsigned long GetForeColorFixed();
	void SetForeColorFixed(unsigned long newValue);
	unsigned long GetBackColorSel();
	void SetBackColorSel(unsigned long newValue);
	unsigned long GetForeColorSel();
	void SetForeColorSel(unsigned long newValue);
	unsigned long GetBackColorBkg();
	void SetBackColorBkg(unsigned long newValue);
	BOOL GetWordWrap();
	void SetWordWrap(BOOL bNewValue);
	COleFont GetFont();
	void SetRefFont(LPDISPATCH newValue);
	float GetFontWidth();
	void SetFontWidth(float newValue);
	CString GetCellFontName();
	void SetCellFontName(LPCTSTR lpszNewValue);
	float GetCellFontSize();
	void SetCellFontSize(float newValue);
	BOOL GetCellFontBold();
	void SetCellFontBold(BOOL bNewValue);
	BOOL GetCellFontItalic();
	void SetCellFontItalic(BOOL bNewValue);
	BOOL GetCellFontUnderline();
	void SetCellFontUnderline(BOOL bNewValue);
	BOOL GetCellFontStrikeThrough();
	void SetCellFontStrikeThrough(BOOL bNewValue);
	float GetCellFontWidth();
	void SetCellFontWidth(float newValue);
	long GetTextStyle();
	void SetTextStyle(long nNewValue);
	long GetTextStyleFixed();
	void SetTextStyleFixed(long nNewValue);
	BOOL GetScrollTrack();
	void SetScrollTrack(BOOL bNewValue);
	long GetFocusRect();
	void SetFocusRect(long nNewValue);
	long GetHighLight();
	void SetHighLight(long nNewValue);
	BOOL GetRedraw();
	void SetRedraw(BOOL bNewValue);
	long GetScrollBars();
	void SetScrollBars(long nNewValue);
	long GetMouseRow();
	long GetMouseCol();
	long GetCellLeft();
	long GetCellTop();
	long GetCellWidth();
	long GetCellHeight();
	long GetRowHeightMin();
	void SetRowHeightMin(long nNewValue);
	long GetFillStyle();
	void SetFillStyle(long nNewValue);
	long GetGridLines();
	void SetGridLines(long nNewValue);
	long GetGridLinesFixed();
	void SetGridLinesFixed(long nNewValue);
	unsigned long GetGridColor();
	void SetGridColor(unsigned long newValue);
	unsigned long GetGridColorFixed();
	void SetGridColorFixed(unsigned long newValue);
	unsigned long GetCellBackColor();
	void SetCellBackColor(unsigned long newValue);
	unsigned long GetCellForeColor();
	void SetCellForeColor(unsigned long newValue);
	short GetCellAlignment();
	void SetCellAlignment(short nNewValue);
	long GetCellTextStyle();
	void SetCellTextStyle(long nNewValue);
	short GetCellPictureAlignment();
	void SetCellPictureAlignment(short nNewValue);
	CString GetClip();
	void SetClip(LPCTSTR lpszNewValue);
	void SetSort(short nNewValue);
	long GetSelectionMode();
	void SetSelectionMode(long nNewValue);
	long GetMergeCells();
	void SetMergeCells(long nNewValue);
	BOOL GetAllowBigSelection();
	void SetAllowBigSelection(BOOL bNewValue);
	long GetAllowUserResizing();
	void SetAllowUserResizing(long nNewValue);
	long GetBorderStyle();
	void SetBorderStyle(long nNewValue);
	long GetHWnd();
	BOOL GetEnabled();
	void SetEnabled(BOOL bNewValue);
	long GetAppearance();
	void SetAppearance(long nNewValue);
	long GetMousePointer();
	void SetMousePointer(long nNewValue);
	CPicture GetMouseIcon();
	void SetRefMouseIcon(LPDISPATCH newValue);
	long GetPictureType();
	void SetPictureType(long nNewValue);
	CPicture GetPicture();
	CPicture GetCellPicture();
	void SetRefCellPicture(LPDISPATCH newValue);
	CString GetTextArray(long index);
	void SetTextArray(long index, LPCTSTR lpszNewValue);
	short GetColAlignment(long index);
	void SetColAlignment(long index, short nNewValue);
	long GetColWidth(long index);
	void SetColWidth(long index, long nNewValue);
	long GetRowHeight(long index);
	void SetRowHeight(long index, long nNewValue);
	BOOL GetMergeRow(long index);
	void SetMergeRow(long index, BOOL bNewValue);
	BOOL GetMergeCol(long index);
	void SetMergeCol(long index, BOOL bNewValue);
	void SetRowPosition(long index, long nNewValue);
	void SetColPosition(long index, long nNewValue);
	long GetRowData(long index);
	void SetRowData(long index, long nNewValue);
	long GetColData(long index);
	void SetColData(long index, long nNewValue);
	CString GetTextMatrix(long Row, long Col);
	void SetTextMatrix(long Row, long Col, LPCTSTR lpszNewValue);
	void AddItem(LPCTSTR Item, const VARIANT& index);
	void RemoveItem(long index);
	void Clear();
	void Refresh();
	CRowCursor GetDataSource();
	void SetDataSource(LPDISPATCH newValue);
	BOOL GetRowIsVisible(long index);
	BOOL GetColIsVisible(long index);
	long GetRowPos(long index);
	long GetColPos(long index);
	short GetGridLineWidth();
	void SetGridLineWidth(short nNewValue);
	short GetFixedAlignment(long index);
	void SetFixedAlignment(long index, short nNewValue);
	BOOL GetRightToLeft();
	void SetRightToLeft(BOOL bNewValue);
	long GetOLEDropMode();
	void SetOLEDropMode(long nNewValue);
	void OLEDrag();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSFLEXGRID1_H__29387B4E_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityAbout.h ===
#if !defined(AFX_PERSONALITYABOUT_H__9497C282_01E4_11D1_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_PERSONALITYABOUT_H__9497C282_01E4_11D1_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PersonalityAbout.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPersonalityAbout dialog

class CPersonalityAbout : public CDialog
{
// Construction
public:
	CPersonalityAbout(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPersonalityAbout)
	enum { IDD = IDD_ABOUTBOX_PERSONALITY };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonalityAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPersonalityAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALITYABOUT_H__9497C282_01E4_11D1_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityComponent.cpp ===
// PersonalityComponent.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "Personality.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent constructor/destructor

CPersonalityComponent::CPersonalityComponent()
{
    m_dwRef			= 0;
	m_pIEngine		= NULL;
	m_pIFramework	= NULL;
	m_pIDocType8	= NULL;
	m_pIConductor	= NULL;

	m_bDirty		= FALSE;

	m_nFirstPersonalityImage = 0;
	m_nNextPersonality = 0;		

	m_cfStyle = 0;
	m_cfPersonality = 0;
}

CPersonalityComponent::~CPersonalityComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::ReleaseAll

void CPersonalityComponent::ReleaseAll( void )
{
	CPersonality *pPersonality;

	while( !m_lstPersonalities.IsEmpty() )
	{
		pPersonality = static_cast<CPersonality*>( m_lstPersonalities.RemoveHead() );
		pPersonality->Release();
	}

	RELEASE( m_pIDocType8 );
	m_pIDocType8 = NULL;

	RELEASE( m_pIFramework );
	m_pIFramework = NULL;
	
	RELEASE( m_pIEngine );
	m_pIEngine = NULL;

	RELEASE( m_pIConductor );
	m_pIConductor = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IUnknown implementation

HRESULT CPersonalityComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CPersonalityComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CPersonalityComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdComponent::Initialize

HRESULT CPersonalityComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	if( pIFramework == NULL
	||  pbstrErrMsg == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	if( !SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  !SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  !SUCCEEDED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIEngine ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	pIComponent->Release();

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .cdp file 
	CString strExt = _T(".cdp");
	BSTR bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfPersonality, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}


	
	m_pIDocType8 = new CPersonalityDocType( this );
    if( m_pIDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIDocType8->AddRef();

	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if( !SUCCEEDED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdComponent::CleanUp

HRESULT CPersonalityComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPersonality *pPersonality;

	while( !m_lstPersonalities.IsEmpty() )
	{
		pPersonality = static_cast<CPersonality*>( m_lstPersonalities.RemoveHead() );
		pPersonality->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdComponent::GetName

HRESULT CPersonalityComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_PERSONALITY_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdComponent::OnActivate
HRESULT CPersonalityComponent::OnActivateApp(BOOL fActivate)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::AllocReferenceNode

HRESULT CPersonalityComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_PersonalityRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create PersonalityRefNode
	CPersonalityRef* pPersonalityRef = new CPersonalityRef( this );
	if( pPersonalityRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pPersonalityRef;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CPersonalityComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPersonality* pPersonality;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Personality 
	pPersonality = new CPersonality( this );
	if( pPersonality == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Load the Personality file
	hr = pPersonality->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		pPersonality->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pPersonality;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent additional functions


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::AddNodeImageLists

HRESULT CPersonalityComponent::AddNodeImageLists( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 6, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PERSONALITY_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_PERSONALITY_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_PERSONALITYREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_PERSONALITYREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstPersonalityImage ) ) )
	{
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::GetPersonalityImageIndex

HRESULT CPersonalityComponent::GetPersonalityImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pnFirstImage = (short)(m_nFirstPersonalityImage + FIRST_PERSONALITY_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::GetFolderImageIndex

HRESULT CPersonalityComponent::GetFolderImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pnFirstImage = m_nFirstPersonalityImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::GetPersonalityRefImageIndex

HRESULT CPersonalityComponent::GetPersonalityRefImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnFirstImage = (short)(m_nFirstPersonalityImage + FIRST_PERSONALITYREF_IMAGE);
	
	return S_OK;
}


#define NBR_SCALES 10

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::ScalePatternToScaleName

void CPersonalityComponent::ScalePatternToScaleName( long lScalePattern, CString& strScaleName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    static long scalepattern[NBR_SCALES] =
    { 
        0xAB5AB5,       // Major
        0x6AD6AD,       // Dorian
        0x5AB5AB,       // Phrygian
        0xAD5AD5,       // Lydian
        0x6B56B5,       // Mixolydian
        0x5AD5AD,       // Aeolian
        0xAADAAD,       // Mel Minor
        0x9AD9AD,       // H Minor
        0x555555,       // Whole Tone 
        0x56B56B        // Locrian
    };

    short i;
    
    for( i=0 ;  i<NBR_SCALES ;  i++ )
    {
        if( lScalePattern == scalepattern[i] )
        {
            strScaleName.LoadString( IDS_MAJOR + i );
            return;
        }
    }
     
    strScaleName.LoadString( IDS_UNKNOWN );
}

HRESULT STDMETHODCALLTYPE CPersonalityComponent::GetConductor(IDMUSProdConductor** ppI)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIConductor);

	if(ppI == NULL)
	{
		return E_INVALIDARG;
	}


	*ppI = m_pIConductor;
	m_pIConductor->AddRef();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::RegisterClipboardFormats

BOOL CPersonalityComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfStyle = ::RegisterClipboardFormat( CF_STYLE );
	m_cfPersonality = ::RegisterClipboardFormat (CF_PERSONALITY);

	if( m_cfProducerFile == 0
	||  m_cfStyle == 0
	||  m_cfPersonality == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::AddToPersonalityFileList

void CPersonalityComponent::AddToPersonalityFileList( CPersonality* pPersonality )
{
	if( pPersonality )
	{
		GUID guidPersonality;
		pPersonality->GetGUID( &guidPersonality );

		// Prevent duplicate object GUIDs
		GUID guidPersonalityList;
		POSITION pos = m_lstPersonalities.GetHeadPosition();
		while( pos )
		{
			CPersonality* pPersonalityList = m_lstPersonalities.GetNext( pos );

			pPersonalityList->GetGUID( &guidPersonalityList );
			if( ::IsEqualGUID( guidPersonalityList, guidPersonality ) )
			{
				::CoCreateGuid( &guidPersonality );
				pPersonality->SetGUID( guidPersonality );
				break;
			}
		}

		// Add to list
		pPersonality->AddRef();
		m_lstPersonalities.AddTail( pPersonality );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::RemoveFromPersonalityFileList

void CPersonalityComponent::RemoveFromPersonalityFileList( CPersonality* pPersonality )
{
	if( pPersonality )
	{
		// Remove from list
		POSITION pos = m_lstPersonalities.Find( pPersonality );
		if( pos )
		{
			m_lstPersonalities.RemoveAt( pos );
			pPersonality->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityComponent::DetermineRoot

char CPersonalityComponent::DetermineRoot( DWORD dwScale )
{
	BYTE bRoot = 0;

    switch( dwScale & 0xfff )
    {
		case 0x56b: bRoot += 1; break;  // C#
		case 0xad6: bRoot += 2; break;  // D
		case 0x5ad: bRoot += 3; break;  // D#

		case 0xb5a: bRoot += 4; break;  // E
		case 0x6b5: bRoot += 5; break;  // F
		case 0xd6a: bRoot += 6; break;  // F#
		case 0xad5: bRoot += 7; break;  // G

		case 0x5ab: bRoot += 8; break;  // G#
		case 0xb56: bRoot += 9; break;  // A
		case 0x6ad: bRoot += 10; break; // A#
		case 0xd5a: bRoot += 11; break; // B
    }

    return (char)((bRoot %= 12) + 12);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityAbout.cpp ===
// PersonalityAbout.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "personalitydesigner.h"
#include "PersonalityAbout.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPersonalityAbout dialog


CPersonalityAbout::CPersonalityAbout(CWnd* pParent /*=NULL*/)
	: CDialog(CPersonalityAbout::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPersonalityAbout)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPersonalityAbout::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPersonalityAbout)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPersonalityAbout, CDialog)
	//{{AFX_MSG_MAP(CPersonalityAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalityAbout message handlers

BOOL CPersonalityAbout::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	// Get version information
	TCHAR achJazzExeName[MAX_PATH + 1];
	TCHAR achFileVersion[MAX_PATH];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, MAX_PATH ) )
	{
		if( theApp.GetFileVersion( achJazzExeName, achFileVersion, MAX_PATH ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_PERSONALITY_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Personality.cpp ===
// Personality.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include <mmsystem.h>
#pragma warning(default:4201)
#include <mmreg.h>

#include "PersonalityDesigner.h"
#include "StyleDesigner.h"
#include "ChordMapStripMgr.h"
#include "PersonalityCtl.h"
#include "Personality.h"
#include "RiffStructs.h"					// Definition of ioPersonality.
#include "StyleRIFFID.h"					// Definition of FOURCC Macros.
#include "templates.h"
#include "PersonalityRiff.h"
#include "ChordDatabase.h"
#include "SignPostDialog.h"
#include <SegmentGuids.h>

#include "ChordBuilder.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#pragma warning(disable:4189)

// {BF272F00-F851-11d0-89AE-00A0C9054129}
static const GUID GUID_PersonalityPageManager = 
{ 0xBF272F00, 0xF851, 0x11d0, { 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29 } };





short CPersonalityPageManager::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CPersonalityPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPersonalityPageManager::CPersonalityPageManager( IDMUSProdFramework* pIFramework, CPersonality* pPersonality ) 
: CDllBasePropPageManager(), m_pPersonality(pPersonality)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pIFramework != NULL );

	m_GUIDManager = GUID_PersonalityPageManager;

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pTabPersonality = NULL;
	m_pTabAudition = NULL;
	m_pTabChordPalette = NULL;
	m_pTabPersonalityInfo = NULL;
}

CPersonalityPageManager::~CPersonalityPageManager()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}

	if( m_pTabPersonality )
	{
		delete m_pTabPersonality;
	}

	if( m_pTabAudition )
	{
		delete m_pTabAudition;
	}

	if( m_pTabChordPalette )
	{
		delete m_pTabChordPalette;
	}

	if(m_pTabPersonalityInfo)
	{
		delete m_pTabPersonalityInfo;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CPersonalityPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_PERSONALITY_TEXT );

	tabPersonality tabData;
	void* pTabData = &tabData;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pTabData))) )
	{
		strTitle = tabData.strName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CPersonalityPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	// Add Personality tab
	m_pTabPersonality = new CTabPersonality( this );
	if( m_pTabPersonality )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabPersonality->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}


	// Add ChordPalette tab
	m_pTabChordPalette = new CTabChordPalette (this, m_pIFramework);
	if( m_pTabChordPalette )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pTabChordPalette->m_psp, sizeof(m_pTabChordPalette->m_psp) );
		m_pTabChordPalette->PreProcessPSP(psp, FALSE );
		hPage = ::CreatePropertySheetPage( &psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Audition tab
	m_pTabAudition = new CTabAudition( this, m_pIFramework );
	if( m_pTabAudition )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabAudition->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add PersonalityInfo tab
	m_pTabPersonalityInfo = new CTabPersonalityInfo( this);
	if( m_pTabPersonalityInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabPersonalityInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}


	AfxSetResourceHandle( hInstance );

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CPersonalityPageManager::OnRemoveFromPropertySheet( void )
{
	AFX_MANAGE_STATE( _afxModuleAddrThis );

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CPersonalityPageManager::sm_nActiveTab );

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CPersonalityPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIPropPageObject == NULL )
	{
		m_pTabPersonality->CopyDataToTab( NULL );
		m_pTabAudition->CopyDataToTab( NULL );
		m_pTabChordPalette->CopyDataToTab( NULL );
		return S_OK;
	}

	tabPersonality tabData;
	void* pTabData = &tabData;
	if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pTabData ) ) )
	{
		/*
		// *********** Update CTabPersonalityInfo
		// Make sure changes to current Personality are processed in OnKillFocus
		// messages before setting the new Personality
		CWnd* pWndHadFocus = CWnd::GetFocus();
		CWnd* pWnd = pWndHadFocus;
		CWnd* pWndParent = m_pTabPersonality->GetParent();

		while( pWnd )
		{
			if( pWnd == pWndParent )
			{
				::SetFocus( NULL );
				break;
			}
			pWnd = pWnd->GetParent();
		}
		*/
		m_pTabPersonalityInfo->SetPersonality( tabData.pPersonality);

		/*
		// Restore focus
		if( pWndHadFocus
		&&  pWndHadFocus != CWnd::GetFocus() )
		{
			pWndHadFocus->SetFocus();
		}
		*/

		
		// ***************** Update other tabs
		m_pTabPersonality->CopyDataToTab( &tabData );
		m_pTabAudition->CopyDataToTab( &tabData );
		m_pTabChordPalette->CopyDataToTab( &tabData );
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPageManager IDMUSProdPropPageManager::UpdateObjectWithTabData

void CPersonalityPageManager::UpdateObjectWithTabData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropPageObject != NULL );

	tabPersonality tabData;
	tabPersonality* pTabData = &tabData;

	// since scale is shared by both tabs, need to arbitrate (active tab wins)
	// NB: assumes 0 -> personality tab active, 1-> ChordPalette tab active
//	long lScalePersonality, lScaleChordPalette;  // no longer have separate scales
	// make sure active tab variable is refreshed
	m_pIPropSheet->GetActivePage( &CPersonalityPageManager::sm_nActiveTab );

	// Populate the tabPersonality structure
	m_pTabPersonality->GetDataFromTab( &tabData );
//	lScalePersonality = tabData.lScalePattern;

	m_pTabAudition->GetDataFromTab( &tabData ); 

	m_pTabChordPalette->GetDataFromTab (&tabData);
//	lScaleChordPalette = tabData.lScalePattern;

	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&tabData );

	// get latest data including stuff that may have changed in previous instruction
	m_pIPropPageObject->GetData( (void **)&pTabData);

	if(sm_nActiveTab == 0)
	{
//		tabData.lScalePattern = lScalePersonality;
		// make sure that chord palette scale is updated
		m_pTabChordPalette->CopyDataToTab( pTabData );
	}
	else if(sm_nActiveTab == 1)
	{
//		tabData.lScalePattern = lScaleChordPalette;
		// make sure that personality scale is updated
		m_pTabPersonality->CopyDataToTab( pTabData );
	}
	
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPersonality constructor/destructor

CPersonality::CPersonality( CPersonalityComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;
	AddRef();

	m_fModified = FALSE;
	m_fVariableNotFixed = FALSE;

	m_dblZoom = 0.03125;
	m_lFunctionbarWidth = 0;

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_pIDirectMusicChordMap = NULL;
	m_pIDocRootNode = this;	// was NULL
	m_pIParentNode = NULL;
	m_hWndEditor = NULL;

	m_pUndoMgr = 0;

	CoCreateGuid( &m_guidPersonality ); 

	m_paletteChordType = ChordBuilder::AllMaj;
	m_selectiontype = CHORD_NO_SELECTION;
	m_nidToChord = -1;
	m_nidFromChord = -1;

	m_pPersonality = new Personality;
		ZeroMemory( &(m_pPersonality->m_username), MAX_LENGTH_PERSONALITYUSER_NAME );
		ZeroMemory( &(m_pPersonality->m_name), MAX_LENGTH_PERSONALITYUSER_NAME );
		m_pPersonality->m_dwflags = DMUS_CHORDMAPF_VERSION8;
		m_pPersonality->m_pfirstchord = 0;
		m_pPersonality->m_personref.m_stylename[0] = 0;
		m_pPersonality->m_personref.m_name[0] = 0;
		m_pPersonality->m_personref.m_filename[0] = 0;
		m_pPersonality->m_personref.m_isdefault = (char)0;
		m_pPersonality->m_cx = (short)0;
		m_pPersonality->m_cy = (short)0;

		m_wSplitterPos = 0;

		m_pIDMSegmentState = 0;
		
		
// We will persist to and from this IDirectMusicChordMap when we want to change the
// Engine's Personality data.
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIEngine != NULL );
// Its created when we either initialize a new personality or load one



////////////////////////////
// Initialize Strip Managers
	// Initialize the ChordMap Manager...
	m_punkChordMapMgr = NULL;
	if( SUCCEEDED( CoCreateInstance( CLSID_ChordMapMgr, NULL, CLSCTX_INPROC_SERVER,
		IID_IUnknown, (void**)&m_punkChordMapMgr )))
	{
		// Hand ChordMapMgr pointer to ChordMap's IDMUSProdNode interface
		IDMUSProdStripMgr* pIStripMgr;
		if( SUCCEEDED ( m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
		{
			if( pIStripMgr->IsParamSupported( GUID_DocRootNode ) == S_OK )
			{
				pIStripMgr->SetParam( GUID_DocRootNode, 0, (IDMUSProdNode *)this );
			}

			pIStripMgr->Release();
		}
	}
	else
	{
		MessageBox( 0, "ChordMapMgr initialization failed!", "ChordMapDesigner", MB_ICONEXCLAMATION );
		//ASSERT(FALSE); // couldn't create ChordMapMgr.
		m_punkChordMapMgr = NULL;
	}

	ASSERT( m_punkChordMapMgr != NULL );


// Personality data for Music Engine
	TCHAR achName[SMALL_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_PERSONALITY_TEXT, achName, SMALL_BUFFER );
    wsprintf( m_pPersonality->m_username, "%s%d", achName, ++m_pComponent->m_nNextPersonality );
	strcpy( m_pPersonality->m_name, m_pPersonality->m_username );

	m_fDefault = FALSE;

	
// Additional fields added to store Personality properties
	m_fUseTimeSignature = TRUE;
	m_nBPM = 4;
	m_nBeat = 4;
	m_dwKey = 12;	// 2C
	m_pIStyleRefNode = NULL;
	m_dwGroove = 50;
	m_nChordMapLength = 20;

    m_paChordChanges = 0;		// List of Chord changes.
	m_lstCommandList = 0;		// Command list.

	// used by Advise/UnAdviseConnection
	m_dwCookie = 0;
	m_bAdvised = FALSE;

	
	
	m_pISection = NULL;
	m_paChordChanges = NULL;
	m_bSectionStopping = FALSE;


	m_dwVersionMS = ioPersonalityVersion::PersonalityVersionMS;
	m_dwVersionLS = ioPersonalityVersion::PersonalityVersionLS;

	CreateUndoMgr();

	m_pSignPostDlg = 0;
	m_pChordDlg = 0;

	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
}

CPersonality::~CPersonality()
{
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Remove personality from Property Sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}

	RELEASE( m_pIDirectMusicChordMap );
	RELEASE( m_pComponent );
	RELEASE( m_punkChordMapMgr );

	// m_pPersonality will == NULL if an error occurs during loading and
	// this object is deleted.
	if( m_pPersonality )
	{
		ChordEntry *pchord = m_pPersonality->m_chordlist.GetHead();
		SignPost *psignpost = m_pPersonality->m_signpostlist.GetHead();
		for (;pchord;)
		{
			ChordEntry *next = pchord->GetNext();
			delete pchord;
			pchord = next;	
		}
		m_pPersonality->m_chordlist.RemoveAll();
		for (;psignpost;)
		{
			SignPost *next = psignpost->GetNext();
			delete psignpost;
			psignpost = next;	
		}
		m_pPersonality->m_signpostlist.RemoveAll();
		if( m_pPersonality )
		{
			delete m_pPersonality;
		}
	}

// Additional field added to store Personality properties
	if( m_pIStyleRefNode )
	{
		m_pIStyleRefNode->Release();
	}

	if( m_pISection )
	{
		m_pISection->Release();
		m_pISection = NULL;
	}

	if( m_pIDMSegmentState )
	{
		m_pIDMSegmentState->Release();
		m_pIDMSegmentState = NULL;
	}

	ClearChordList();
	List_Free( m_lstCommandList );

	// Clean up the undo mgr.
	if(m_pUndoMgr)
	{
		delete m_pUndoMgr;
		m_pUndoMgr = NULL;
	}

	m_pSignPostDlg = 0;
	m_pChordDlg = 0;
}


/////////////////////////////////////////////////////////////////////////////
//
HRESULT	CPersonality::Initialize()
{
		HRESULT hr = S_OK;

		hr = ::CoCreateInstance( CLSID_DirectMusicChordMap, NULL, CLSCTX_INPROC_SERVER,
										 IID_IDirectMusicChordMap, (void**)&m_pIDirectMusicChordMap );

		return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality::SyncPersonalityWithEngine
//


HRESULT CPersonality::SyncPersonalityWithEngine( int why )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(why & syncStopMusic)
		return S_FALSE;
// TODO: Fix for DirectMusic
//			if( why & syncStopMusic)
//			{
//				theApp.m_pStyleComponent->m_pIEngine->Stop( AAF_IMMEDIATE );
//			}


	HRESULT hr = E_FAIL;

	ASSERT( m_pIDirectMusicChordMap != NULL );
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	IDirectMusicSegment* pISection = NULL;
	IDMUSProdNode* pIStyle = NULL;
	IDMUSProdReferenceNode* pIDMUSProdRef = NULL;

	
	IStream* pIMemStream;
	IPersistStream* pIPersistStream;

	if(why & syncPersonality)
	{
		// make sure chord map is updated
//		SendChordMapAndPaletteToChordMapMgr();

		hr = m_pComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );

		if( SUCCEEDED ( hr ) )
		{
			hr = Save( pIMemStream, FALSE );
			if( SUCCEEDED ( hr ) )
			{
				m_pIDirectMusicChordMap->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
				if( pIPersistStream )
				{
					StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
					hr = pIPersistStream->Load( pIMemStream );
					ASSERT( SUCCEEDED(hr) );

					pIPersistStream->Release();
				}
			}
		}

		pIMemStream->Release();
	}
	if(why & syncAudition)
	{
		if(m_pIStyleRefNode == NULL)
		{
			// too early
			return S_OK;
		}
		hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIDMUSProdRef);
		if(FAILED(hr))
		{
			goto Leave;
		}
		hr = pIDMUSProdRef->GetReferencedFile(&pIStyle);
		pIDMUSProdRef->Release();
		if(pIStyle)
			pIStyle->Release();
		if(!m_paChordChanges  || FAILED(hr))
		{
			// no chord selected, nothing to do
			return S_OK;
		}
	
		if(FAILED(hr = ComposeSection(&pISection)))
		{
			goto Leave;
		}

		if(m_pISection)		// already have a composed section
		{
		// find out whether its playing
			m_pISection->Release();
			m_pISection = pISection;
			pISection = NULL;	
			if(S_OK == m_pComponent->m_pIConductor->IsTransportPlaying((IDMUSProdTransport*)this))
			{
				IDirectMusicPerformance* pIDMPerformance = 0;
				m_pComponent->m_pIConductor->GetPerformanceEngine( (IUnknown**)&pIDMPerformance);
				if(!pIDMPerformance)
				{
					hr = E_FAIL;
				}
				else
				{
					hr = pIDMPerformance->PlaySegment( m_pISection, DMUS_SEGF_BEAT, 0, &m_pIDMSegmentState );
					pIDMPerformance->Release();
				}
			}
		} // if(m_pISection)
		else
		{
			// section not defined
			m_pISection = pISection;
			pISection = NULL;
		}

	}
Leave:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IUnknown implementation

HRESULT CPersonality::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdTimelineCallback) )
    {
        AddRef();
        *ppvObj = (IDMUSProdTimelineCallback *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdTransport) )
	{
		AddRef();
		*ppvObj = (IDMUSProdTransport*)this;
		return S_OK;
	}
    if( ::IsEqualIID(riid, IID_IDMUSProdNotifyCPt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifyCPt *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink))
	{
		AddRef();
		*ppvObj = (IDMUSProdNotifySink*)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdChordMapInfo))
	{
		AddRef();
		*ppvObj = (IDMUSProdChordMapInfo*)this;
		return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CPersonality::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    ++m_dwRef;
//	TRACE( "CPersonality::AddRef: %ld\n", m_dwRef );
	return m_dwRef;
}

ULONG CPersonality::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

//	TRACE( "CPersonality::Release: %ld\n", m_dwRef );

    if( m_dwRef == 0 )
    {
//		TRACE( "PERSONALITY::Release: CPersonality destroyed!\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNodeImageIndex

HRESULT CPersonality::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return (m_pComponent->GetPersonalityImageIndex(pnFirstImage));
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetFirstChild

HRESULT CPersonality::GetFirstChild( IDMUSProdNode** /*ppIFirstChildNode*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNextChild

HRESULT CPersonality::GetNextChild( IDMUSProdNode* /*pIChildNode*/, IDMUSProdNode** /*ppINextChildNode*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;		// Personality nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetComponent

HRESULT CPersonality::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetDocRootNode

HRESULT CPersonality::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::SetDocRootNode

HRESULT CPersonality::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetParentNode

HRESULT CPersonality::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::SetParentNode

HRESULT CPersonality::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNodeId

HRESULT CPersonality::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_PersonalityNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNodeName

HRESULT CPersonality::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CString csName;
	csName = m_pPersonality->m_username;
	*pbstrName = csName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNodeNameMaxLength

HRESULT CPersonality::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnMaxLength = MAX_LENGTH_PERSONALITYUSER_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::ValidateNodeName

HRESULT CPersonality::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::SetNodeName

HRESULT CPersonality::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );
	
	if(!_tcscmp(m_pPersonality->m_name, m_pPersonality->m_username))
	{
		// if names were the same, keep in sync
		_tcscpy( m_pPersonality->m_name, (LPCTSTR)strName );
	}
	_tcscpy( m_pPersonality->m_username, (LPCTSTR)strName );
	m_fModified = TRUE;

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}

	// sync personality (with new name) to engine
	SyncPersonalityWithEngine(syncPersonality);

	// Notify connected nodes that Style name has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, PERSONALITY_NameChange, NULL );

	OnNameChange();	// notify internal components

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetNodeListInfo

HRESULT CPersonality::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pListInfo != NULL );

	CString strDescriptor;

	if( m_pPersonality )
	{
		ASSERT( m_pComponent != NULL );
		m_pComponent->ScalePatternToScaleName( m_pPersonality->m_scalepattern, strDescriptor );
	}

	// Put in place to provide Template 'username' requirement.
    CString csUserName = m_pPersonality->m_username;

	pListInfo->bstrName = csUserName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidPersonality, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetEditorClsId

HRESULT CPersonality::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    *pClsId = CLSID_PersonalityEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetEditorTitle

HRESULT CPersonality::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_PERSONALITY_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_pPersonality->m_username;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetEditorWindow

HRESULT CPersonality::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::SetEditorWindow

HRESULT CPersonality::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::UseOpenCloseImages

HRESULT CPersonality::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetRightClickMenuId

HRESULT CPersonality::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_PERSONALITY_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::OnRightClickMenuInit

HRESULT CPersonality::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::OnRightClickMenuSelect

HRESULT CPersonality::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

//	IDMUSProdNode* pIDocRootNode;


	switch( lCommandId )
	{
		case IDM_RENAME:
			if( SUCCEEDED ( m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::DeleteChildNode

HRESULT CPersonality::DeleteChildNode( IDMUSProdNode* /*pIChildNode*/, BOOL /*fPromptUser*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;	// Personality nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::InsertChildNode

HRESULT CPersonality::InsertChildNode( IDMUSProdNode* /*pIChildNode*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;	// Personality nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::DeleteNode

HRESULT CPersonality::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// If this pIChildNode is currently playing, then Stop it.
	StopIfPlaying( 0 );

	// Remove from Project Tree
	if( m_pComponent->m_pIFramework->RemoveNode( (IDMUSProdNode*)this, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Unadvise ConnectionPoint and unregister the CSection (JAZZNode) from the Transport.
	UnAdviseConnectionPoint();

	// Remove from Component Personality list
	m_pComponent->RemoveFromPersonalityFileList( this );

	m_fModified = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::OnNodeSelChanged

HRESULT CPersonality::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if ( fSelected )
	{
		ASSERT( m_pComponent );
		ASSERT( m_pComponent->m_pIConductor );
		if( !m_pComponent || !m_pComponent->m_pIConductor )
		{
			return E_UNEXPECTED;
		}

		m_pComponent->m_pIConductor->SetActiveTransport((IDMUSProdTransport *) this, NULL);
	}
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CPersonality Drag/Drop
/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CreateDataObject

HRESULT CPersonality::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Personality into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_PERSONALITY into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfPersonality, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveClipFormat( m_pComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Style nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			pIStream->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanCut

HRESULT CPersonality::CanCut( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CanDelete();
 
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanCopy

HRESULT CPersonality::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanDelete

HRESULT CPersonality::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanDeleteChildNode

HRESULT CPersonality::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UNREFERENCED_PARAMETER(pIChildNode);
	return S_FALSE;	
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::PasteCF_STYLE

HRESULT CPersonality::PasteCF_STYLE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
							  IDMUSProdNode* pIPositionNode )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	UNREFERENCED_PARAMETER(pIPositionNode);

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, m_pComponent->m_cfStyle, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// replace doc root node of section
		IDMUSProdNode* pIDocRootNode;
		IDMUSProdReferenceNode* pIDMUSProdReferenceNode;
		hr = m_pComponent->m_pIFramework->GetDocRootNodeFromData(pIDataObject, &pIDocRootNode);
		if(SUCCEEDED(hr))
		{
			if(m_pIStyleRefNode == NULL)
			{
				// Allocate a new reference node
				IDMUSProdComponent* pIStyleComponent;
				hr = m_pComponent->m_pIFramework->FindComponent( CLSID_StyleComponent,  &pIStyleComponent );
				if(FAILED(hr))
				{
					return E_FAIL;
				}
				hr = pIStyleComponent->AllocReferenceNode(GUID_StyleRefNode, &m_pIStyleRefNode);
				RELEASE(pIStyleComponent);
				if(FAILED(hr))
				{
					return  E_OUTOFMEMORY;
				}
			}

			hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void **)&pIDMUSProdReferenceNode);
			if(SUCCEEDED(hr))
			{
				hr = SetStyleReference(pIDocRootNode);
//				hr = pIDMUSProdReferenceNode->SetReferencedFile(pIDocRootNode);
				m_fModified = TRUE;
				pIDMUSProdReferenceNode->Release();
			}
			pIDocRootNode->Release();
		}
	}

	if(m_fModified)
	{
//		CPersonalityPageManager* pPageManager;
		if( theApp.m_pIPageManager
		&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PersonalityPageManager ) == S_OK )
		{
//			pPageManager = (CPersonalityPageManager *)theApp.m_pIPageManager;
//			pPageManager->Refresh();
			theApp.m_pIPageManager->RefreshData();
		}
		SyncPersonalityWithEngine(syncAudition);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanPasteFromData

HRESULT CPersonality::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if((pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfStyle ) == S_OK) )
	{
		*pfWillSetReference = TRUE;
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::PasteFromData

HRESULT CPersonality::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;


	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfStyle ) ) )
	{
		// Handle CF_Style format
		hr = PasteCF_STYLE( pDataObject, pIDataObject, NULL );
	}


	pDataObject->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::CanChildPasteFromData

HRESULT CPersonality::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											 BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if(pIDataObject == NULL || pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = E_FAIL;
	
	IDMUSProdNode* pINode;
	if(SUCCEEDED(m_pIStyleRefNode->QueryInterface(IID_IDMUSProdNode, (void**)&pINode)))
	{
		BOOL b2 = (pINode == m_pIStyleRefNode) 
						&&( S_OK ==  pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfStyle));
		pINode->Release();
		if(b2)
		{
			*pfWillSetReference = TRUE;
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	}

	pDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::ChildPasteFromData

HRESULT CPersonality::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pIDataObject == NULL || pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = E_FAIL;
	
	IDMUSProdNode* pINode;
	if(SUCCEEDED(m_pIStyleRefNode->QueryInterface(IID_IDMUSProdNode, (void**)&pINode)))
	{
		BOOL b2 = (pINode == m_pIStyleRefNode) 
						&&( S_OK ==  pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfStyle));
		pINode->Release();
		if(b2)
		{
			// Handle CF_STYLE format
			hr = PasteCF_STYLE( pDataObject, pIDataObject, NULL );
		}
		else
		{
			hr = S_FALSE;
		}
	}
	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdPropPageObject::GetData

HRESULT CPersonality::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );
	ASSERT( m_pPersonality != NULL );

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	tabPersonality* pData = (tabPersonality *)*ppData;

	// put personality in
	pData->pPersonality = this;

	// Get Project GUID for this personality 
	IDMUSProdProject* pIProject;

	memset( &pData->guidProject, 0, sizeof( pData->guidProject ) );
	if( SUCCEEDED ( m_pComponent->m_pIFramework->FindProject( this, &pIProject ) ) )
	{
		pIProject->GetGUID( &pData->guidProject );
		pIProject->Release();
	}


	// Get Style DocRoot and GUID
	IDMUSProdNode* pDocRoot = NULL;
	IDMUSProdReferenceNode* pIDMUSProdReferenceNode;
	HRESULT hr;
	if(m_pIStyleRefNode)
	{
		hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIDMUSProdReferenceNode);
		ASSERT(SUCCEEDED(hr));
		if(SUCCEEDED(hr))
		{
			hr = pIDMUSProdReferenceNode->GetReferencedFile(&pDocRoot);
		}
		pIDMUSProdReferenceNode->Release();
		pIDMUSProdReferenceNode = 0;
	}
	pData->pIStyleDocRootNode = pDocRoot;	// make assignment if succeed or not (pDocRoot == NULL)
/*
	memset(&pData->guidStyleProject, 0, sizeof(GUID));
	if( SUCCEEDED (hr))
	{
		hr = m_pComponent->m_pIFramework->FindProject( pData->pIStyleDocRootNode, &pIProject );
		if(SUCCEEDED(hr))
		{
			pIProject->GetGUID( &pData->guidStyleProject );
			pIProject->Release();
		}
	}
*/
	RELEASE(pDocRoot);	// this gets ref'ed by caller when data is copied




	// Fill remaining fields in tabPersonality structure
	pData->strName = m_pPersonality->m_username;
//	pData->strRefName = m_pPersonality->m_name;
	pData->strDescription = m_pPersonality->m_description;
	pData->fUseTimeSignature = m_fUseTimeSignature;
	pData->nBPM = m_nBPM;
	pData->nBeat = m_nBeat;
	pData->dwGroove = m_dwGroove;
	pData->nChordMapLength = m_nChordMapLength;
	pData->lScalePattern = Rotate24( m_pPersonality->m_scalepattern, GetAbsKey() );
	pData->dwKey = m_dwKey;
	pData->fVariableNotFixed = m_fVariableNotFixed;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdPropPageObject::SetData

HRESULT CPersonality::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HINSTANCE hInst = AfxGetInstanceHandle( );

	tabPersonality* pTabData = (tabPersonality *)pData;

	CString csName = m_pPersonality->m_username;

	// Name has changed
	if( pTabData->strName != csName )
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_NAMECHANGE);
		BSTR bstrNodeName = pTabData->strName.AllocSysString();
		SetNodeName( bstrNodeName );
	
		// change guid if name has changed
		//CoCreateGuid(&m_guidPersonality);

		// Update the Editor's Title.
		if( m_hWndEditor != NULL )
		{
			CString csName;
			csName.Format( "ChordMap: %s", m_pPersonality->m_username );
			SetWindowText( m_hWndEditor, csName );
		}

		// Update the Project Node.
		m_pComponent->m_pIFramework->RefreshNode( (IDMUSProdNode*)this );

		m_fModified = TRUE;
	}
/* refname is no longer editable by the user
	// Ref Name has changed
	if( _tcscmp( pTabData->strRefName, m_pPersonality->m_name ) != 0 )
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_REFNAME);
		// LimitText() in OnInitDialog() limits text to 20 bytes
		_tcscpy( m_pPersonality->m_name, pTabData->strRefName );
		m_fModified = TRUE;
	}
*/
	// Description has changed
	if( _tcscmp( pTabData->strDescription, m_pPersonality->m_description ) != 0 )
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_DESCR);
		// LimitText() in OnInitDialog() limits text to 20 bytes
		_tcscpy( m_pPersonality->m_description, pTabData->strDescription );
		m_fModified = TRUE;
	}

	// Use TimeSig has changed
	if( pTabData->fUseTimeSignature != m_fUseTimeSignature )
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_EDITMODE);
		m_fUseTimeSignature = pTabData->fUseTimeSignature;
		m_fModified = TRUE;
	}
	else if( m_fUseTimeSignature == TRUE )
	{
		// Time Signature has changed
		if( (pTabData->nBPM != m_nBPM)
		||  (pTabData->nBeat != m_nBeat) )
		{
			if(m_pUndoMgr)
				m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_TIMESIG);
			m_nBPM = pTabData->nBPM;
			m_nBeat = pTabData->nBeat;
			
			ChangeChordSignPostTimeSig();
			ComputeChordMap();
			ChangeChordMapLength();	// need to make timeline know that there's a different number of
			// clocks (measures stay the same).
			SyncPersonalityWithEngine(syncAudition | syncPersonality);
			m_fModified = TRUE;
		}
	}

	// VariableNotFixed has changed
	if( pTabData->fVariableNotFixed != m_fVariableNotFixed)
	{
		if(m_pUndoMgr)
		{
			if(m_fVariableNotFixed == TRUE)
			{
				m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_SWITCHTOFIXED);
			}
			else
			{
				m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_SWITCHTOVAR);
			}
		}

		m_fVariableNotFixed = pTabData->fVariableNotFixed;
		ChangeChordMapEditMode();
		m_fModified = TRUE;
	}

	// Chordmap length has changed
	if( pTabData->nChordMapLength != m_nChordMapLength)
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_CHORDMAPLENGTH);
		m_nChordMapLength = pTabData->nChordMapLength;
		ChangeChordMapLength();
		m_fModified = TRUE;
	}

	// scalepattern has changed
	long lScalePattern = Rotate24( pTabData->lScalePattern, -(long)GetAbsKey() );
	if( lScalePattern != m_pPersonality->m_scalepattern)
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_SCALEPAT);
		m_pPersonality->m_scalepattern = lScalePattern;
		TransposeAllChords(pTabData->dwKey);
		SendChordMapAndPaletteToChordMapMgr();
		UpdateChordPalette( false );
//		RefreshSignPosts(false);		// no need to call this and it does bad things in some situations
		RefreshChordMap();
		m_fModified = TRUE;
	}

	// Audition Style has changed
	// no style?
	IDMUSProdNode* pDocRoot = NULL;
//	IDMUSProdReferenceNode* pIDMUSProdReferenceNode;
	HRESULT hr;
	if(m_pIStyleRefNode == NULL)
	{
		// Allocate a new reference node
		IDMUSProdComponent* pIStyleComponent;
		hr = m_pComponent->m_pIFramework->FindComponent( CLSID_StyleComponent,  &pIStyleComponent );
		if(FAILED(hr))
		{
			return E_FAIL;
		}
		hr = pIStyleComponent->AllocReferenceNode(GUID_StyleRefNode, &m_pIStyleRefNode);
		RELEASE(pIStyleComponent);
		if(FAILED(hr))
		{
			return  E_OUTOFMEMORY;
		}
	}

	// Get DocRoot of Style
//	m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIDMUSProdReferenceNode);
//	hr = pIDMUSProdReferenceNode->GetReferencedFile(&pDocRoot);
//	if(FAILED(hr))
//	{
//		// no doc root, that's ok
//		pDocRoot = NULL;
//	}
	pDocRoot = GetStyleDocRoot();

	// style has changed, NB, this catches newly created ref node as doc root will be null
	if( pDocRoot != pTabData->pIStyleDocRootNode )
	{
//		pIDMUSProdReferenceNode->SetReferencedFile(pTabData->pIStyleDocRootNode);
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_AUDSTYLE);
		hr = SetStyleReference(pTabData->pIStyleDocRootNode);
		m_fModified = TRUE;
	}


	RELEASE(pDocRoot);
//	RELEASE(pIDMUSProdReferenceNode);


	// Audition Groove has changed
	if( pTabData->dwGroove != m_dwGroove  )
	{
		if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_GROOVE);
		m_dwGroove = pTabData->dwGroove;						// xxxx
		m_fModified = TRUE;
	}

	if(pTabData->dwKey != m_dwKey)
	{
		if(m_pUndoMgr && ((pTabData->dwKey & 0x0fffffff) == (m_dwKey & 0x0fffffff)))
		{
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_UseFlat);
		}
		else if(m_pUndoMgr)
			m_pUndoMgr->SaveState(this, hInst, IDS_UNDO_KEY);
		TransposeAllChords(pTabData->dwKey);
		m_dwKey = pTabData->dwKey;
		SendChordMapAndPaletteToChordMapMgr();
		UpdateChordPalette( true );
		RefreshSignPosts(false);
		RefreshChordMap();
		m_fModified = TRUE;
	}

	if(m_fModified)
	{
		SyncPersonalityWithEngine(syncAudition | syncPersonality);
	}

	return S_OK;
}

void CPersonality::ChangeChordSignPostTimeSig()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Change the Time Signature of the Timeline
	if( m_punkChordMapMgr == NULL ) return;

	IDMUSProdStripMgr *pStripMgrChordMap = NULL;
	if( FAILED(m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap )) )
	{
		return;
	}

	IDMUSProdTimeline *pTimeline = NULL;
	VARIANT varTimeline;
	if( FAILED(pStripMgrChordMap->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline )) || (V_UNKNOWN( &varTimeline ) == NULL) )
	{
		pStripMgrChordMap->Release();
		return;
	}
	if( FAILED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void**)&pTimeline ) ) || (pTimeline == NULL) )
	{
		V_UNKNOWN( &varTimeline )->Release();
		pStripMgrChordMap->Release();
		return;
	}
	V_UNKNOWN( &varTimeline )->Release();


	DMUS_TIMESIGNATURE timesig;
	timesig.mtTime = 0;
	timesig.bBeatsPerMeasure = static_cast<BYTE>(m_nBPM);
	timesig.bBeat = static_cast<BYTE>(m_nBeat);
	if(timesig.bBeat > 4)
	{
		// compound meter
		timesig.wGridsPerBeat = 3;
	}
	else
	{
		// simple meter
		timesig.wGridsPerBeat = 4;
	}

	pTimeline->SetParam(GUID_TimeSignature, 0xFFFFFFFF, 0, 0, static_cast<void*>(&timesig));

	pTimeline->Refresh();
	pTimeline->Release();
	pStripMgrChordMap->Release();
}

void CPersonality::ChangeChordMapEditMode()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_punkChordMapMgr == NULL) return;

	IDMUSProdStripMgr *pStripMgrChordMap = NULL;
	if( FAILED(m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap )) )
	{
		return;
	}

	IDMUSProdTimeline *pTimeline = NULL;
	VARIANT varTimeline;
	if( FAILED(pStripMgrChordMap->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline )) || (V_UNKNOWN( &varTimeline ) == NULL) )
	{
		pStripMgrChordMap->Release();
		return;
	}
	if( FAILED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void**)&pTimeline ) ) || (pTimeline == NULL) )
	{
		V_UNKNOWN( &varTimeline )->Release();
		pStripMgrChordMap->Release();
		return;
	}
	V_UNKNOWN( &varTimeline )->Release();

	pStripMgrChordMap->SetParam(GUID_VariableNotFixed, 0, &m_fVariableNotFixed);


	pTimeline->Release();
	pStripMgrChordMap->Release();
}

void CPersonality::ChangeChordMapLength()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Update chord map
	TrimChordMap();


	// Change the Length of the Timeline
	if( m_punkChordMapMgr == NULL ) return;

	IDMUSProdStripMgr *pStripMgrChordMap = NULL;
	if( FAILED(m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap )) )
	{
		return;
	}

	IDMUSProdTimeline *pTimeline = NULL;
	VARIANT varTimeline;
	if( FAILED(pStripMgrChordMap->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline )) || (V_UNKNOWN( &varTimeline ) == NULL) )
	{
		pStripMgrChordMap->Release();
		return;
	}
	if( FAILED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void**)&pTimeline ) ) || (pTimeline == NULL) )
	{
		V_UNKNOWN( &varTimeline )->Release();
		pStripMgrChordMap->Release();
		return;
	}
	V_UNKNOWN( &varTimeline )->Release();

	// compute how many clocks in desired measure length
	long clocks;
	// BUGBUG: Assuming our ChordMapStrip is in group 1 and that we're using the default
	// TimeSig strip (the one displayed at the top of the timeline)
	if( FAILED(pTimeline->MeasureBeatToClocks( 1, 0, m_nChordMapLength, 0, &clocks)))
	{
		ASSERT(0);
	}
	
	// now set it.
	VARIANT vtInit;
	vtInit.vt = VT_I4;

	V_I4(&vtInit) = clocks;
	pTimeline->SetTimelineProperty( TP_CLOCKLENGTH, vtInit );


	pTimeline->Refresh();
	pTimeline->Release();
	pStripMgrChordMap->Release();
}


void CPersonality::DeleteAllConnectionsToChord( int nID )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Delete Connection
	for(ChordEntry *pchord = m_pPersonality->m_chordlist.GetHead();
		pchord != NULL;
		pchord = pchord->GetNext())
	{
		for(NextChord *pnext = pchord->m_nextchordlist.GetHead();
			pnext != NULL;
			)
		{
			// Delete all connections to the newly removed Chord.
			if( pnext->m_nid == nID )
			{
				NextChord* ptemp = pnext->GetNext();
				pchord->m_nextchordlist.Remove(pnext);
				delete pnext;
				pnext = ptemp;
			}
			else
			{
				pnext->m_nextchord = NULL;
				pnext = pnext->GetNext();
			}
		} 
	}
}

//////////////////////////////////////////////////////////////////////////////
//
void CPersonality::TrimChordMap()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(m_pPersonality);
	ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();
	for(pChord; pChord; )
	{
		if(pChord->m_chordsel.Measure() < m_nChordMapLength)
		{
			// leave this chord
			pChord = pChord->GetNext();
			continue;
		}
		else
		{
			// delete this sucker and all his connections
			int id = pChord->m_nid;
			m_pPersonality->m_chordlist.Remove(pChord);
			delete pChord;
			pChord = m_pPersonality->m_chordlist.GetHead();
			DeleteAllConnectionsToChord(id);
			m_pPersonality->ResolveConnections();			
		}
	}
}



/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdPropPageObject::OnShowProperties

HRESULT CPersonality::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Get the Personality page manager
	CPersonalityPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PersonalityPageManager ) == S_OK )
	{
		pPageManager = (CPersonalityPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CPersonalityPageManager( m_pComponent->m_pIFramework, this );
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Personality properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CPersonalityPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CPersonality::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersist::GetClassID

HRESULT CPersonality::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersistStream::IsDirty

HRESULT CPersonality::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	// check whether zoom has changed
	// need to do this here because chord dialog can't notify us if it has changed.
	if(m_pChordDlg)
	{
		double dblZoom = m_pChordDlg->GetZoom();
		if(dblZoom != m_dblZoom)
		{
			m_dblZoom = dblZoom;
			m_fModified = TRUE;
		}

		const long lFunctionbarWidth = m_pChordDlg->GetFunctionbarWidth();
		if( lFunctionbarWidth != m_lFunctionbarWidth )
		{
			m_lFunctionbarWidth = lFunctionbarWidth;
			m_fModified = TRUE;
		}
	}

	return (m_fModified == TRUE)?S_OK:S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersistStream::Load

HRESULT CPersonality::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ULONG	ulSize,
			ulID;
	Personality *pcmap = NULL;
	HRESULT	hr = E_FAIL;

	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_INVALIDARG;
	}


	CleanupObjects();
	
	DWORD dwPos = StreamTell(pIStream);	// save stream position
	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO ckMain;
	bool bFoundFormat = false;
	// check for Direct Music format
	if(SUCCEEDED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		ckMain.fccType = FOURCC_PERSONALITY;
		if(pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF)==0)
		{
			hr = LoadPersonality(pIRiffStream, &ckMain);
			bFoundFormat = true;
		}
		RELEASE(pIRiffStream);
	}

	if(!bFoundFormat)
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
		// Check for Old Format Personality .PEP file...
		ulID = ReadID( pIStream );
		ulSize = ReadSize( pIStream );
		if (ulID == ID_EPERSONALITY || ulID == ID_JPERSONALITY || ulID == ID_J4PERSONALITY || ulID == ID_J5PERSONALITY)
		{
			CPersonality::LoadPersonality( pIStream, ulSize, ulID );
			if (m_pPersonality)
			{
				m_pPersonality->AssignParents();
				hr = S_OK;
			}
			hr = LoadJazzStyleReference(pIStream);
			if(FAILED(hr))
			{
				TRACE("LoadJazzStyleReference failed, ignoring for now");
				hr = S_OK;
			}
		}
		else
		{
			AfxMessageBox(IDS_ERR_IMARUNTIME);
			hr = E_FAIL;	// .PER and non-personality RIFF files not supported.
		}
	}
	//
	if(SUCCEEDED(hr))
	{
		m_pPersonality->RenumberIDs();
		
		if(m_pIDirectMusicChordMap == NULL)
		{
			hr = ::CoCreateInstance( CLSID_DirectMusicChordMap, NULL, CLSCTX_INPROC_SERVER,
												 IID_IDirectMusicChordMap, (void**)&m_pIDirectMusicChordMap );
		}
		//
		//	Allocate a new Music Engine Personality and Persist it to the engine.
		//
		if( SUCCEEDED( hr ) )
		{
			// check for selected chords
			UpdateSelectedChordList();
			if( SUCCEEDED(hr = SyncPersonalityWithEngine(syncPersonality+syncAudition)) )
			{
//				/* this call made in SyncPersonalityWithEngine(syncPersonality)
				if( FAILED(hr = SendChordMapAndPaletteToChordMapMgr()) )
				{
					TRACE( "SendChordMapAndPaletteToChordMapMgr() Failed!\n" );
				}
				else
				{
//					LinkAll(true);
				}
//				*/
			}
		}
	}
	if(!SUCCEEDED(hr))
	{
		SyncPersonalityWithEngine(syncStopMusic);
	}

	// many functions called during load set this to true, we want to make sure that
	// a newly loaded Personality is "clean"
	m_fModified = FALSE;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IPersistStream::Save

HRESULT CPersonality::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	HRESULT hr = S_OK;
	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType	ftFileType;
	GUID		guidDataFormat;

	// We want to know what type of save we are doing because we
	// don't want to save UI information in Personality 'Release' files...	
	IDMUSProdPersistInfo *pIDMUSProdPersist = NULL;
	if( FAILED( hr = pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void**)&pIDMUSProdPersist ) ) )
	{
		ftFileType = FT_RUNTIME;
		guidDataFormat = GUID_CurrentVersion;
		hr = S_OK;
	}
	else
	{
		hr = pIDMUSProdPersist->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pIDMUSProdPersist->Release();
		if (FAILED( hr ))
		{
			return hr;
		}
	}		
	

	if( ::IsEqualGUID(guidDataFormat, GUID_CurrentVersion) )
	{
		return DMSave(pIStream, fClearDirty);
	}
	else if( ::IsEqualGUID(guidDataFormat, GUID_DirectMusicObject) )
	{
		return DMSave(pIStream, fClearDirty);
	}

	ASSERT( 0 );
	return E_UNEXPECTED;
}

HRESULT CPersonality::SaveChordList( IStream* pIStream, BOOL bReleaseSave )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ChordEntry *pchord = m_pPersonality->m_chordlist.GetHead();
	for(;pchord;pchord = pchord->GetNext())
	{       
		pchord->Save( pIStream, bReleaseSave );
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSection IPersistStream::GetSizeMax

HRESULT CPersonality::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality additional functions


/////////////////////////////////////////////////////////////////////////////
// CPersonality::LoadPersonality

HRESULT CPersonality::LoadPersonality( IStream* pIStream, DWORD dwSize, DWORD id)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pPersonality != NULL );

//	if( m_pPersonality ) delete m_pPersonality;
//	m_pPersonality = new Personality;
	long lrecordsize = ReadSize( pIStream );
	long lfilesize = (long)dwSize;

	lfilesize -= 4;   
	if (m_pPersonality)
	{
		m_fVariableNotFixed = TRUE;
		lfilesize -= lrecordsize; 
		m_pPersonality->Load(pIStream, lrecordsize);
//		pIStream->Read(m_pPersonality,lrecordsize,NULL);
		m_pPersonality->m_pfirstchord = NULL;
		m_pPersonality->m_playlist.RemoveAll();		
		m_pPersonality->m_chordlist.RemoveAll();
		m_pPersonality->m_signpostlist.RemoveAll();

		// load meter
		if( id == ID_JPERSONALITY)
		{
			pIStream->Read(&m_nBeat, sizeof(short), NULL);
			pIStream->Read(&m_nBPM, sizeof(short), NULL);
			lfilesize -= sizeof(short) * 2;
		}
		// load length and meter
		if( id == ID_J4PERSONALITY)
		{
			m_fVariableNotFixed = FALSE;
			long size;
			pIStream->Read(&size, sizeof(long), NULL);
			m_nChordMapLength = LOWORD(size);
			pIStream->Read(&m_nBeat, sizeof(short), NULL);
			pIStream->Read(&m_nBPM, sizeof(short), NULL);
			lfilesize -= (sizeof(short) * 2 + sizeof(long));
		}

		// load length and meter
		if( id == ID_J5PERSONALITY)
		{
			m_fVariableNotFixed = FALSE;
			long size;
			pIStream->Read(&size, sizeof(long), NULL);
			m_nChordMapLength = LOWORD(size);
			pIStream->Read(&m_nBeat, sizeof(short), NULL);
			pIStream->Read(&m_nBPM, sizeof(short), NULL);
			pIStream->Read(&m_fVariableNotFixed, sizeof(BOOL), NULL);
			lfilesize -= (sizeof(short) * 2 + sizeof(long) + sizeof(BOOL));
		}

		for (;lfilesize > 0;)
		{
			DWORD dwid = ReadID( pIStream );
			lrecordsize = ReadSize( pIStream );
			lfilesize -= 8;
			if (dwid == ID_ECHORDENTRY)
			{
				ChordEntry *pchord = ChordEntry::Load(pIStream,lrecordsize, dwid);
				if (pchord)
				{
					pchord->SetNext(NULL);
				    m_pPersonality->m_chordlist.AddTail(pchord);
				}
			}
			else if (dwid == ID_CHORDENTRY)
			{
				ChordEntry *pchord = ChordEntry::Load(pIStream,lrecordsize, dwid);
				if (pchord)
				{
					pchord->SetNext(NULL);
				    m_pPersonality->m_chordlist.AddTail(pchord);
					pchord->m_rect.left = 100 - CENTER_X;
					pchord->m_rect.right = 100 + CENTER_X;
					pchord->m_rect.top = -100 - CENTER_Y;
					pchord->m_rect.bottom = -100 + CENTER_Y;
					//pchord->m_lastrect = pchord->m_rect;
					pchord->m_lastrect.left = pchord->m_rect.left;
					pchord->m_lastrect.right = pchord->m_rect.right;
					pchord->m_lastrect.top = pchord->m_rect.top;
					pchord->m_lastrect.bottom = pchord->m_rect.bottom;

					pchord->CleanupNexts();
				}
			}
			else if (dwid == ID_DMSIGNPOST)
			{
				ASSERT(FALSE);	// not implemented yet
			}
			else if (dwid == ID_SIGNPOST)
			{
				SignPost *psign = SignPost::Load(pIStream,lrecordsize);
				if (psign)
				{
					psign->SetNext(NULL);
				    m_pPersonality->m_signpostlist.AddTail(psign);
				}
			}
			else
			{
				StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
			}
			lfilesize -= lrecordsize;
		}
		m_pPersonality->ResolveConnections();
		if (lfilesize)
		{
			TRACE("ERROR: Map read leaves filesize at %ld\n", lfilesize);
			return E_FAIL;
		}
	}
	else
	{
		StreamSeek( pIStream, lfilesize, STREAM_SEEK_CUR );
	}
	return(S_OK);		
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::LoadPersonality

HRESULT CPersonality::LoadPersonality( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IStream			*pIStream = NULL;
	IDMUSProdRIFFExt	*pIRIFFExt = NULL;
	MMCKINFO		ck;
	DWORD			dwByteCount;
	DWORD			dwSize;
	DWORD			dwPos;
	HRESULT			hr=S_OK;
	DMUS_IO_CHORDMAP		iPersonality;

	DMSubChordSet subchords;
	bool bDMSubChordSetRead = false;
	bool bDMChordMapRead = false;

	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
        case FOURCC_IOPERSONALITY:
			dwSize = min( ck.cksize, sizeof( iPersonality ) );
            hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
			if( FAILED( hr )
			||  dwByteCount != dwSize )
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			
			if(m_pPersonality)
			{
		        WideCharToMultiByte( CP_ACP, 0, iPersonality.wszLoadName, -1, 
									 m_pPersonality->m_name, sizeof(m_pPersonality->m_name), 
									 NULL, NULL );
				strcpy( m_pPersonality->m_username, m_pPersonality->m_name );
				m_pPersonality->m_dwflags = iPersonality.dwFlags;
				if( m_pPersonality->m_dwflags & PERH_INVALID_BITS )
				{
					// There was a time (pre-DX8) when this field was not initialized
					 m_pPersonality->m_dwflags = 0;
				}
				if( m_pPersonality->m_dwflags & DMUS_CHORDMAPF_VERSION8 )
				{
					// Root is stored in high MSByte
					m_dwKey = (iPersonality.dwScalePattern & 0xFF000000) >> 24;
					m_pPersonality->m_scalepattern = iPersonality.dwScalePattern & 0x00FFFFFF;
				}
				else
				{
					m_pPersonality->m_scalepattern = iPersonality.dwScalePattern & 0x00FFFFFF;
					m_dwKey = m_pComponent->DetermineRoot( m_pPersonality->m_scalepattern );
					m_pPersonality->m_scalepattern = Rotate24( m_pPersonality->m_scalepattern, -(long)m_dwKey );
					m_pPersonality->m_dwflags |= DMUS_CHORDMAPF_VERSION8;
				}
			}
            break;

		case DM_FOURCC_GROOVE_LEVEL:
			hr = ReadDword(pIRiffStream, m_dwGroove);
			break;
		case FOURCC_PERSONALITYKEY:
			hr = ReadDword(pIRiffStream, m_dwKey);
			break;
		case FOURCC_PERSONALITYEDIT:
			hr = DMLoadUI(pIRiffStream, &ck);
			break;

		case FOURCC_PERSONALITYSTRUCT:
			hr = DMLoadStructure(pIRiffStream);
			break;

        case FOURCC_DMUSPROD_FILEREF:
			StreamSeek( pIStream, dwPos, 0 );
			hr = LoadJazzStyleReference(pIStream);
			break;

		case FOURCC_GUID:
			hr = pIStream->Read(&m_guidPersonality, sizeof(GUID), &dwByteCount);
			if( FAILED( hr )
			||  dwByteCount != ck.cksize )
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			break;

		case DM_FOURCC_VERSION_CHUNK:
			hr = DMLoadVersionChunk(pIRiffStream, &ck);
			if(FAILED(hr))
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			break;


		case FOURCC_SUBCHORD:			
			hr = subchords.Read(pIRiffStream, &ck);
			bDMSubChordSetRead = true;
			if(FAILED(hr))
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			break;

		case FOURCC_CHORDENTRYEDIT:
			ASSERT(bDMChordMapRead);
			if(bDMChordMapRead)
			{
				hr = ReadChordEntryEditChunk(pIRiffStream, &(m_pPersonality->m_chordlist), &ck);
			}
			break;

		case FOURCC_LIST:
			switch( ck.fccType )
			{

			case DM_FOURCC_INFO_LIST:
			case DM_FOURCC_UNFO_LIST:
				hr = DMLoadInfoChunk(pIRiffStream, &ck);
				if(FAILED(hr))
				{
					hr = E_FAIL;
					goto ON_ERR;
				}
				break;

			case FOURCC_LISTCHORDPALETTE:
				{
					ChordPaletteList chordpalette;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordpalette.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordpalette.Insert(m_pPersonality->m_chordpalette, subchords);
				}
				break;

			case FOURCC_LISTCHORDMAP:
				{
					ChordMapList chordmap;
 					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordmap.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordmap.Insert(m_pPersonality->m_chordlist, subchords);
				}
				bDMChordMapRead = true;
				break;

			case FOURCC_SIGNPOSTLIST:
				{
					SignPostListChunk signposts;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = signposts.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					signposts.Insert(m_pPersonality->m_signpostlist, subchords);
				}
				break;
			}
		}
        pIRiffStream->Ascend( &ck, 0 );
		dwPos = StreamTell( pIStream );
    }


ON_ERR:
    if( FAILED( hr ) )
    {
		if( pIRIFFExt != NULL )
		{
			pIRIFFExt->Release();
		}
    }
	else
	{
		m_pPersonality->ResolveConnections();
	}

    if ( pIStream != NULL )
	{
		pIStream->Release();
	}

    return hr;

}


HRESULT CPersonality::SendChordMapAndPaletteToChordMapMgr()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;
	IPersistStream*	pIPS;
	LPSTREAM		pStream;
	LARGE_INTEGER	dlib;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	dlib.LowPart = 0;
	dlib.HighPart = 0;
	if( SUCCEEDED( m_pComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream )))
	{
		if( m_punkChordMapMgr )
		{
			if( SUCCEEDED( m_punkChordMapMgr->QueryInterface( IID_IPersistStream, (void**)&pIPS )))
			{
				// Just Persist the address of the chord list so ChordMapStripMgr can edit the
				// structure in realtime.
				DWORD	dwWritten = 0;
				DWORD	dwBuffer = (DWORD)&(m_pPersonality->m_chordlist);
				DWORD	dwBuffer2 = (DWORD)&(m_pPersonality->m_chordpalette);
				if( SUCCEEDED(pStream->Write( &dwBuffer, sizeof(dwBuffer), &dwWritten )) )
				{
					if( SUCCEEDED(pStream->Write(&dwBuffer2, sizeof(dwBuffer2), &dwWritten)))
					{
						if( SUCCEEDED(pStream->Write(&m_dwKey, sizeof(DWORD), &dwWritten)))
						{
							if(SUCCEEDED(pStream->Write(&m_selectiontype, sizeof(m_selectiontype), &dwWritten)))
							{
								if(SUCCEEDED(pStream->Write(&m_nidFromChord, sizeof(m_nidFromChord), &dwWritten)))
								{
									if(SUCCEEDED(pStream->Write(&m_nidToChord, sizeof(m_nidToChord), &dwWritten)))
									{
										pStream->Seek( dlib, STREAM_SEEK_SET, NULL ); //seek to beginning
										if( SUCCEEDED(pIPS->Load( pStream )) )
										{
											hr = S_OK;
										}
									}
								}
							}
						}
					}
				}
				pIPS->Release();
			}
		}
		pStream->Release();
	}

	if(hr == S_OK)
	{
		RefreshChordMap();
	}

	return hr;
}

DWORD CPersonality::GetSignPostListPtr()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (DWORD)&(m_pPersonality->m_signpostlist);
}

HRESULT STDMETHODCALLTYPE CPersonality::OnDataChanged(IUnknown *punk)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	ChordEntry* pChordEntry;
	if(punk)
	{
		ChordChangeCallback* pCallback;
		PreEditNotification* pEditNotify;
		CheckForOrphansNotification* pCheckForOrphans;
		ZoomChangeNotification* pZoomChangeNotify;
		if(SUCCEEDED(punk->QueryInterface(IID_ChordChangeCallback, (void**)&pCallback)))
		{
			if(pCallback->GetCallbackType() == ChordChangeCallback::ParentShowProps)
			{
				OnShowProperties();
			}
			else if (pCallback->GetChordEntry())
			{
				pChordEntry = pCallback->GetChordEntry();
				ClearChordList();
				m_paChordChanges = new ChordExt;
				memset(m_paChordChanges, 0, sizeof(ChordExt));
				ChordEntryToChordExt(pChordEntry, m_paChordChanges);
				hr = SyncPersonalityWithEngine(syncPersonality+syncAudition);
				if( (pChordEntry->m_dwflags & CE_START) || (pChordEntry->m_dwflags & CE_END) )
				{
					LinkAll(false);
				}
				m_fModified = TRUE;
			}
			else
			{
				ASSERT(FALSE);
				hr = E_FAIL;
			}
			pCallback->Release();
		}
		else if(SUCCEEDED(punk->QueryInterface(IID_CheckForOrphansNotification, (void**)&pCheckForOrphans)))
		{
			LinkAll(false);
			pCheckForOrphans->Release();
		}
		else if(SUCCEEDED(punk->QueryInterface(IID_PreEditNotification, (void**)&pEditNotify)))
		{
			// save old state
			if(m_pUndoMgr)
			{
				m_pUndoMgr->SaveState(this, const_cast<char*>((LPCSTR)(pEditNotify->m_strReason)));
			}
			m_fModified = TRUE;
			pEditNotify->Release();
		}
		else if(SUCCEEDED(punk->QueryInterface(IID_ZoomChangeNotification, (void**)&pZoomChangeNotify)))
		{
			m_dblZoom = pZoomChangeNotify->m_dblZoom;
			Modified() = TRUE;
			pZoomChangeNotify->Release();
		}
		else
		{
			ASSERT(FALSE);
			hr = E_FAIL;
		}
		punk->Release();
	}
	else
	{

		hr = SyncPersonalityWithEngine(syncPersonality);
		m_fModified = TRUE;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality::Modified
BOOL &CPersonality::Modified()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::Play

HRESULT CPersonality::Play(BOOL /*fPlayFromStart*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr;

	ASSERT(m_pComponent != NULL);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	CString str;
	if(m_paChordChanges == NULL)
	{
		str.LoadString(IDS_NOCHORD);
		AfxMessageBox(str);
		return E_FAIL;
	}

	IDMUSProdNode* pNode = GetStyleDocRoot();

	if(pNode == NULL)
	{
		SetStyleDocRootNode();
		pNode = GetStyleDocRoot();
		if(pNode)
			SyncPersonalityWithEngine(syncAudition);
		else
		{
			str.LoadString(IDS_NOSTYLE);
			AfxMessageBox(str);
			return E_FAIL;
		}
	}

	pNode->Release();

	if(m_pISection == NULL)
	{
		hr = SyncPersonalityWithEngine(syncAudition);
		if(FAILED(hr) || m_pISection == NULL)
		{
			str.LoadString(IDS_NOSTYLE);
			AfxMessageBox(str);
			return E_FAIL;
		}
	}


	hr = SyncPersonalityWithEngine(syncAudition);
/* this already done in sync personality
	if(SUCCEEDED(hr))
	{
		IDirectMusicPerformance* pIDMPerformance = 0;
		m_pComponent->m_pIConductor->GetPerformanceEngine( (IUnknown**)&pIDMPerformance);
		if(!pIDMPerformance)
		{
			hr = E_FAIL;
		}
		else
		{
			hr = pIDMPerformance->PlaySegment( m_pISection, DMUS_SEGF_BEAT, 0, &m_pIDMSegmentState );
			pIDMPerformance->Release();
		}
	}
*/
	if(FAILED(hr) && m_pISection)
	{
		m_pISection->Release();
		m_pISection = NULL;
	}
	return(hr);
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::Stop

HRESULT CPersonality::Stop(BOOL fStopImmediate)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bSectionStopping = TRUE;
	StopIfPlaying( fStopImmediate ? 0 : DMUS_SEGF_DEFAULT );
	m_bSectionStopping = FALSE;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::Transition

HRESULT CPersonality::Transition()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::Record

HRESULT CPersonality::Record(BOOL fPressed)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPressed);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::GetName

HRESULT CPersonality::GetName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	// Segment file name
	CString strName;
	BSTR bstrFileName;

	IDMUSProdNode*	iNode;

	HRESULT hr = QueryInterface(IID_IDMUSProdNode, (void**)&iNode);

	if(!SUCCEEDED(hr))
		return E_UNEXPECTED;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->GetNodeFileName( iNode, &bstrFileName ) ) )
	{
		// Node is in the Project tree
		strName = bstrFileName;
		::SysFreeString( bstrFileName );
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Segment is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}
	
	// Plus "name"
	strName += m_pPersonality->m_username;

    *pbstrName = strName.AllocSysString();
	
	iNode->Release();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdTransport::TrackCursor

HRESULT CPersonality::TrackCursor(BOOL fTrackCursor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fTrackCursor);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::StopIfPlaying()

void CPersonality::StopIfPlaying( DWORD dwFlags )
{
	ASSERT( m_pComponent );
	ASSERT( m_pComponent->m_pIConductor );
	// If this dialog is already playing, then Enable the Dialog's Timer.
	HRESULT hr = 
		m_pComponent->m_pIConductor->IsTransportPlaying( (IDMUSProdTransport*)this ) ;
	if (hr == S_OK)
	{
		IDirectMusicPerformance* pIDMPerformance = 0;
		m_pComponent->m_pIConductor->GetPerformanceEngine( (IUnknown**)&pIDMPerformance);
		if(!pIDMPerformance)
		{
			hr = E_FAIL;
		}
		else
		{
			pIDMPerformance->Stop( m_pISection, m_pIDMSegmentState, 0, dwFlags );
			pIDMPerformance->Release();
			if(m_pIDMSegmentState != NULL)
			{
				m_pIDMSegmentState->Release();
				m_pIDMSegmentState = NULL;
			}
		}
	}
}


namespace MyTime
{
	DWORD starttime;
void Time(char* s)
{
	UNREFERENCED_PARAMETER(s);
//	timeGetTime();
//	TRACE("%s done at %d\n", s, timeGetTime() - starttime);
}
void ResetTime()
{
//	starttime = timeGetTime();
}
}

using namespace MyTime;

///////////////////// Section Construction Methods
//
/////////////////////////////////////////////////////////////////////////////
// Personality IPersistStream::Save

HRESULT CPersonality::ComposeSection( IDirectMusicSegment** ppISection)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;
	IDirectMusicTrack*			pIChordTrack			=	NULL;

	IDirectMusicTrack*			pICommandTrack			=	NULL;

	IDirectMusicTrack*			pIBandTrack				=	NULL;
	IDirectMusicBand*			pBand					=	NULL;

	IDirectMusicTrack*			pIStyleTrack			=	NULL;

	IDirectMusicTrack*			pITempoTrack		= NULL;

	long						nClocks					=	0;
	GUID						Guid;

	IDirectMusicStyle*			pIStyle					=	NULL;

	DMPolyChord*				pChord					=	NULL;

	DWORD nPatternLength = 120;	// highly divisible number to get integral number of pattern repeats
	int i;	// index for for loop

	// check to see if any chords to audition
	if(m_paChordChanges == NULL)
	{
		return E_FAIL;
	}
	else
	{
		pChord = dynamic_cast<DMPolyChord*>(m_paChordChanges);
	}

	// GetStyle from selected node
	hr = GetDirectMusicStyle(&pIStyle);
	if(!SUCCEEDED(hr))
	{
		return E_FAIL;
	}


	// create a section segment
	hr = ::CoCreateInstance(	CLSID_DirectMusicSegment,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicSegment,
								(void**)ppISection
							);

	if(!SUCCEEDED(hr))
		goto ON_END;

	// extract the style's timesig
	DMUS_TIMESIGNATURE	TimeSig;
	pIStyle->GetTimeSignature(&TimeSig);

	// convert m_paChordChanges to ChordTrack
	hr = ::CoCreateInstance(	CLSID_DirectMusicChordTrack,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicTrack,
								(void**)&pIChordTrack);
	if(!SUCCEEDED(hr))
		goto ON_END;

	DMUS_CHORD_PARAM	dmchord;

	memset(dmchord.wszName, 0, sizeof(dmchord.wszName));

#ifdef _UNICODE
	// use straight wstrcpy
	_wstrncpy(dmchord.wszName, pChord->Name(), 12);
#else
	// use conversion
    MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, 
						dmchord.wszName, 12 );
#endif

	dmchord.wMeasure = 0;
	dmchord.bBeat = 0;
	dmchord.bSubChordCount = DMPolyChord::MAX_POLY;
	for(i = 0; i < DMPolyChord::MAX_POLY; i++)
	{
		DMUS_SUBCHORD* pdmsub = &(dmchord.SubChordList[i]);
		pdmsub->dwChordPattern = pChord->SubChord(i)->ChordPattern();
		pdmsub->dwScalePattern = pChord->SubChord(i)->ScalePattern();
		pdmsub->dwInversionPoints = pChord->SubChord(i)->InvertPattern();
		pdmsub->dwLevels = pChord->SubChord(i)->Levels();
		pdmsub->bChordRoot = pChord->SubChord(i)->ChordRoot();
		pdmsub->bScaleRoot = pChord->SubChord(i)->ScaleRoot();
	}

	Guid = GUID_ChordParam;
	hr = pIChordTrack->SetParam(Guid, 0, &dmchord);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}

	// now load command track
	hr = ::CoCreateInstance(	CLSID_DirectMusicCommandTrack,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicTrack,
								(void**)&pICommandTrack);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}

	DMUS_COMMAND_PARAM	dmcommand;
	memset(&dmcommand, 0, sizeof(dmcommand));
	dmcommand.bGrooveLevel = static_cast<BYTE>(m_dwGroove);
	Guid = GUID_CommandParam;
	hr = pICommandTrack->SetParam(Guid, 0, &dmcommand);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}

	// get length from patterns in style
	DWORD nMinLen, nMaxLen;
	hr = pIStyle->GetEmbellishmentLength(0, m_dwGroove, &nMinLen, &nMaxLen);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}

	// load style track
	hr = ::CoCreateInstance(	CLSID_DirectMusicStyleTrack,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicTrack,
								(void**)&pIStyleTrack);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}
	Guid = GUID_IDirectMusicStyle;
	hr = pIStyleTrack->SetParam(Guid, 0, pIStyle);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}

	// load band track
	hr = ::CoCreateInstance(	CLSID_DirectMusicBandTrack,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicTrack,
								(void**)&pIBandTrack);
	if(!SUCCEEDED(hr))
	{
		goto ON_END;
	}
	Guid = GUID_IDirectMusicBand;
	hr = pIStyle->GetDefaultBand(&pBand);
	if(!SUCCEEDED(hr))
	{
		goto NO_BAND;
	}
	else if(hr == S_FALSE)
	{
		// no default band, get first band in style
		WCHAR	name[MAX_PATH];
		hr = pIStyle->EnumBand(0, name);
		if(!SUCCEEDED(hr))
		{
			goto NO_BAND;
		}
		hr = pIStyle->GetBand(name, &pBand);
		if(!SUCCEEDED(hr))
		{
			goto NO_BAND;
		}
	}

	hr = pIBandTrack->SetParam(Guid, 0, pBand);
	if(!SUCCEEDED(hr))
	{
		goto NO_BAND;
	}

NO_BAND:
	hr = S_OK;

	// extract the style's tempo
	double	dblTempo;
	pIStyle->GetTempo(&dblTempo);

	// create tempo track
	hr = ::CoCreateInstance(	CLSID_DirectMusicTempoTrack,
								NULL,
								CLSCTX_INPROC,
								IID_IDirectMusicTrack,
								(void**)&pITempoTrack);
	if(!SUCCEEDED(hr))
		goto ON_END;

	DMUS_TEMPO_PARAM tempo;
	tempo.mtTime = 0;
	tempo.dblTempo = dblTempo;
	if( FAILED( pITempoTrack->SetParam(GUID_TempoParam, 0, &tempo) ) )
	{
			goto ON_END;
	}

	// initialize the segment and insert above tracks
	(*ppISection)->SetRepeats(999);
//	(*ppISection)->SetRepeats(8);
	nClocks = nPatternLength /* measure */ * TimeSig.bBeatsPerMeasure * (DMUS_PPQ * 4 / TimeSig.bBeat);
	(*ppISection)->SetLength(nClocks);
	(*ppISection)->InsertTrack(pIBandTrack, 1);
	(*ppISection)->InsertTrack(pIStyleTrack, 1);
	(*ppISection)->InsertTrack(pICommandTrack, 1);
	(*ppISection)->InsertTrack(pIChordTrack, 1);
	(*ppISection)->InsertTrack(pITempoTrack, 1);
	
 ON_END:

	if(pBand)
		pBand->Release();
	if(pIBandTrack)
		pIBandTrack->Release();
	if(pICommandTrack)
		pICommandTrack->Release();
	if(pIChordTrack)
		pIChordTrack->Release();
	if(pIStyle)
		pIStyle->Release();
	if(pIStyleTrack)
		pIStyleTrack->Release();
	if(pITempoTrack)
		pITempoTrack->Release();


    return hr;
}


// Save the chordlist to a normal stream
HRESULT CPersonality::SaveChordList( LPSTREAM pStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    HRESULT     hr=S_OK;
    DWORD       cb;
    WORD        wSize;
    ioChordSelection iChordSelection;
    ChordExt*   pChord;
    int         i;

//HRESULT GetStreamInfo(FileType* pftFileType, GUID* pguidDataFormat)

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}
	else
	{
		ASSERT(FALSE);
	}

	if(::IsEqualGUID(guidDataFormat, GUID_CurrentVersion))
	{
		wSize = sizeof( ioChordSelection );
	//	FixBytes( FBT_SHORT, &wSize );
		hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
		if( FAILED( hr ) || cb != sizeof( wSize ) )
		{
			return E_FAIL;
		}

		for( pChord = m_paChordChanges ; pChord; pChord = pChord->pNext )
		{
			memset( &iChordSelection, 0, sizeof( iChordSelection ) );
			MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
			if( pChord->SubChord(0)->UseFlat() != 0 )
			{
				iChordSelection.fCSFlags |= CSF_FLAT;
			}
			iChordSelection.fCSFlags |= CSF_INSCALE;
			iChordSelection.fCSFlags |= CSF_KEYDOWN;
			if( ( pChord->SubChord(0)->Bits() & CHORD_SIMPLE ) != 0 )
			{
				iChordSelection.fCSFlags |= CSF_SIMPLE;
			}
			iChordSelection.bBeat = pChord->Beat();
			iChordSelection.wMeasure = pChord->Measure();
			ASSERT(DMPolyChord::MAX_POLY >= 4);
			for( i = 0 ; i < 4 ; ++i )
			{
				iChordSelection.aChord[i].lChordPattern = pChord->SubChord(i)->ChordPattern();
				iChordSelection.aChord[i].lScalePattern = pChord->SubChord(i)->ScalePattern();
				iChordSelection.aChord[i].lInvertPattern = pChord->SubChord(i)->InvertPattern();
				iChordSelection.aChord[i].bRoot = pChord->SubChord(i)->ChordRoot();
			}
	//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
			if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
				cb != sizeof( iChordSelection ) )
			{
				hr = E_FAIL;
				break;
			}
		}
	}
	return hr;
}


// Save the chordlist to a JazzRIFFStream
HRESULT CPersonality::SaveChordList( IDMUSProdRIFFStream* pRIFF )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;

	// don't save null chord list
	if(m_paChordChanges == NULL)
	{
		return S_OK;
	}

    pStream = pRIFF->GetStream();

    hr = E_FAIL;
    ck.ckid = FOURCC_CHORD;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
		hr = SaveChordList( pStream );
        if( SUCCEEDED(hr) &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}

// Save the commandlist to a JazzRIFFStream
HRESULT CPersonality::SaveCommandList( IDMUSProdRIFFStream* pRIFF )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;

	// don't save empty command list
	if(m_lstCommandList == NULL)
	{
		return S_OK;
	}

    pStream = pRIFF->GetStream();

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
		hr = SaveCommandList( pStream );
		if( SUCCEEDED(hr) &&
			pRIFF->Ascend( &ck, 0 ) == 0 )
		{
			hr = S_OK;
		}
    }

    pStream->Release();
    return hr;
}

HRESULT CPersonality::SaveCommandList( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    DWORD       cb;
    WORD        wSize;
    ioCommand   iCommand;
    CommandExt* pCommand;
	HRESULT		hr = S_OK;

    wSize = sizeof( ioCommand );
//    FixBytes( FBT_SHORT, &wSize );
    hr = pIStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL; 
    }

    for( pCommand = m_lstCommandList ; pCommand != NULL ; pCommand = pCommand->pNext )
    {
        memset( &iCommand, 0, sizeof( iCommand ) );
        iCommand.lTime = pCommand->time;
        iCommand.dwCommand = pCommand->command;
//        FixBytes( FBT_IOCOMMAND, &iCommand );
        if( FAILED( pIStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
            cb != sizeof( iCommand ) )
        {
			hr = E_FAIL;
            break;
        }
    }

    return hr;
}

HRESULT CPersonality::GetDirectMusicStyle(IDirectMusicStyle** ppIStyle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pStyleDocRoot = NULL;
	IDMUSProdReferenceNode* pIStyleRef = NULL;
	
	HRESULT hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIStyleRef);
	if(FAILED(hr))
	{
		return E_FAIL;
	}
	hr = pIStyleRef->GetReferencedFile(&pStyleDocRoot);
	pIStyleRef->Release();
	pIStyleRef = NULL;
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	if(pStyleDocRoot)
	{
		hr = pStyleDocRoot->GetObject(CLSID_DirectMusicStyle, IID_IDirectMusicStyle, (void**)ppIStyle);
		pStyleDocRoot->Release();
	}
	return hr;
}

void CPersonality::ClearChordList()
{
	ChordExt *pTemp;

	while(m_paChordChanges)
	{
		pTemp = m_paChordChanges->pNext;
		delete m_paChordChanges;
		m_paChordChanges = pTemp;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::AdviseConnectionPoint()

HRESULT CPersonality::AdviseConnectionPoint()
{
	HRESULT hr = E_FAIL;

	if( m_bAdvised )
	{
		return S_OK;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIConductor != NULL );
	if ( !m_pComponent || !m_pComponent->m_pIConductor )
	{
		return E_UNEXPECTED;
	}

	// Register Segment with Conductor's Transport and notification system
	if( FAILED( m_pComponent->m_pIConductor->RegisterTransport( this, 0 ) ) )
	{
		return E_FAIL;
	}
	if( FAILED( m_pComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_SEGMENT ) ) )
	{
		return E_FAIL;
	}

	// Tell Conductor we are the active node in case it doesn't know already
	// this causes personality to get transport when it is opened instead of when it gets the forcus
//	if ( FAILED( m_pComponent->m_pIConductor->SetActiveTransport((IDMUSProdTransport *)this, NULL ) ) )
//	{
//		return E_FAIL;
//	}

	m_bAdvised = TRUE;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality::UnAdviseConnectionPoint()

HRESULT CPersonality::UnAdviseConnectionPoint()
{
	if(m_bAdvised == FALSE)
	{
		return S_OK;
	}

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIConductor != NULL );
	if ( !m_pComponent || !m_pComponent->m_pIConductor )
	{
		return E_UNEXPECTED;
	}

	// Make sure Segment is not playing
	if ( FAILED( Stop( TRUE ) ) )
	{
		return E_FAIL;
	}

	// Unregister the Transport's Play, Stop, Transition functionality.
	if( FAILED( m_pComponent->m_pIConductor->UnRegisterTransport( this ) ) )
	{
		return E_FAIL;
	}

	// Unregister notification messages
	if( FAILED( m_pComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_SEGMENT ) ) )
	{
		return E_FAIL;
	}

	m_bAdvised = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNotifyCPt implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNotifyCPt::OnNotify

HRESULT CPersonality::OnNotify(ConductorNotifyEvent* pConductorNotifyEvent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pConductorNotifyEvent != NULL );
	if( !pConductorNotifyEvent )
	{
		return E_POINTER;
	}

	switch( pConductorNotifyEvent->m_dwType )
	{
		case DMUS_PMSGT_NOTIFICATION:
		{
			DMUS_NOTIFICATION_PMSG* pNotifyEvent = (DMUS_NOTIFICATION_PMSG *)pConductorNotifyEvent->m_pbData;

			// Handle GUID_NOTIFICATION_SEGMENT notifications
			if( ::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
			{
				if( pNotifyEvent->punkUser == m_pIDMSegmentState )
				{
					switch( pNotifyEvent->dwNotificationOption )
					{
						case DMUS_NOTIFICATION_SEGSTART:
							break;
						case DMUS_NOTIFICATION_SEGLOOP:
							break;

						case DMUS_NOTIFICATION_SEGABORT:
						case DMUS_NOTIFICATION_SEGEND:
							// Notify the Conductor we stopped playing
							if( m_pComponent && m_pComponent->m_pIConductor )
							{
								m_pComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*) this );
							}
							else
							{
								ASSERT(FALSE);
							}
							break;
					}
				}
			}
		}
	}

	return S_OK;
}



////////////////////////////////////// more helper funcs
BOOL CPersonality::UpdateSelectedChordList()
{
	ClearChordList();
	ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();
	for(; pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown())
		{
			if(m_paChordChanges)
			{
				pChord->m_chordsel.KeyDown() = FALSE;
			}
			else
			{
				m_paChordChanges = new ChordExt;
				memset(m_paChordChanges, 0, sizeof(ChordExt));
				ChordEntryToChordExt(pChord, m_paChordChanges);
			}
		}
	}
	return m_paChordChanges ? TRUE : FALSE;
}


HRESULT CPersonality::SaveJazzStyleReference(IStream* pIStream)
{
	if(m_pIStyleRefNode == NULL)
	{
		return S_OK;
	}


	HRESULT hr;
	IDMUSProdReferenceNode* pIDMUSProdReferenceNode;

	hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void **)&pIDMUSProdReferenceNode);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		return E_UNEXPECTED;
	}

	IDMUSProdNode* pIDocRootNode;
	hr = pIDMUSProdReferenceNode->GetReferencedFile(&pIDocRootNode);
//	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		// nothing to save
		pIDMUSProdReferenceNode->Release();
		return S_OK;
	}

	pIDMUSProdReferenceNode->Release();
	
	if(pIDocRootNode == NULL)
	{
		return S_OK;	// nothing to save
	}

	IDMUSProdFileRefChunk* pIFileRefChunk;
	hr = m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		pIDocRootNode->Release();
		return E_UNEXPECTED;
	}

	hr = pIFileRefChunk->SaveRefChunk(pIStream, pIDocRootNode);
	pIFileRefChunk->Release();
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		pIDocRootNode->Release();
		return E_FAIL;
	}

	pIDocRootNode->Release();
	return S_OK;
}

HRESULT CPersonality::LoadJazzStyleReference(IStream* pIStream)
{
	// release current style reference
	if(m_pIStyleRefNode)
	{
		m_pIStyleRefNode->Release();
		m_pIStyleRefNode = 0;
	}
	// Get the IDMUSProdFileRefChunk
	IDMUSProdFileRefChunk* pIFileRefChunk;
	HRESULT hr;
	hr = m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		return E_UNEXPECTED;
	}

	// Load the chunk
	IDMUSProdNode* pIDocRootNode;
	hr = pIFileRefChunk->LoadRefChunk(pIStream, &pIDocRootNode);
	pIFileRefChunk->Release();

	if(FAILED(hr))
	{
		return E_FAIL;
	}

	GUID guidNodeId;
	hr = pIDocRootNode->GetNodeId(&guidNodeId);

	if(FAILED(hr))
	{
		return E_UNEXPECTED;
	}

	if(IsEqualGUID(guidNodeId, GUID_StyleNode))
	{

		if(m_pIStyleRefNode == NULL)
		{
			// Allocate a new reference node
			IDMUSProdComponent* pIStyleComponent;
			hr = m_pComponent->m_pIFramework->FindComponent( CLSID_StyleComponent,  &pIStyleComponent );
			if(FAILED(hr))
			{
				return E_FAIL;
			}
			hr = pIStyleComponent->AllocReferenceNode(GUID_StyleRefNode, &m_pIStyleRefNode);
			RELEASE(pIStyleComponent);
			if(FAILED(hr))
			{
				return  E_OUTOFMEMORY;
			}
		}
		
		ASSERT(m_pIStyleRefNode);
//		IDMUSProdReferenceNode* pIDMUSProdReferenceNode;

//		hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void **)&pIDMUSProdReferenceNode);
//		ASSERT(SUCCEEDED(hr));
//		if(FAILED(hr))
//		{
//			return E_UNEXPECTED;
//		}

//		hr = pIDMUSProdReferenceNode->SetReferencedFile(pIDocRootNode);
		hr = SetStyleReference(pIDocRootNode);

		pIDocRootNode->Release();
//		pIDMUSProdReferenceNode->Release();
		ASSERT(SUCCEEDED(hr));
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}
	}
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////
// CPersonality :: OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)

HRESULT CPersonality::OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdReferenceNode* pIReferenceNode;
	IDMUSProdNode* pIDocRoot;

	HRESULT hr = E_FAIL;

	// Is it our node
	if( m_pIStyleRefNode )
	{
		if( SUCCEEDED ( m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIReferenceNode ) ) )
		{
			if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIDocRoot ) ) )
			{
				if( pIDocRoot == pIDocRootNode )
				{
					// Notification is from our Style node
					if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileDeleted )
					||  ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileClosed ) )
					{
						// node deleted or closed
						SetStyleReference( NULL );
						if( theApp.m_pIPageManager
						&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PersonalityPageManager ) == S_OK )
						{
							theApp.m_pIPageManager->RefreshData();
						}
						SyncPersonalityWithEngine(syncAudition);
						hr = S_OK;
					}
					else if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileReplaced ) )
					{
						// node replaced with another node pointer
						SetStyleReference( NULL );
						if( pData )
						{
							SetStyleReference( (IDMUSProdNode *)pData );
							if( theApp.m_pIPageManager
							&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PersonalityPageManager ) == S_OK )
							{
								theApp.m_pIPageManager->RefreshData();
							}
							SyncPersonalityWithEngine(syncAudition);
							hr = S_OK;
						}
						else
						{
							hr = E_UNEXPECTED;
						}
					}
					else if( ::IsEqualGUID(guidUpdateType, DOCROOT_GuidChange ) )
					{
						// Style GUID changed so we have to resave the Personality
						m_fModified = TRUE;
						hr = S_OK;
					}
					else if( ::IsEqualGUID(guidUpdateType, STYLE_NameChange ) )
					{
						if( theApp.m_pIPageManager
						&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PersonalityPageManager ) == S_OK )
						{
							theApp.m_pIPageManager->RefreshData();
						}
						m_fModified = TRUE;
						hr = S_OK;
					}
					else if( ::IsEqualGUID(guidUpdateType, STYLE_TimeSigChange ) )
					{
//						Update UI?
						SyncPersonalityWithEngine(syncAudition);
						hr = S_OK;
					}
				}

				if( pIDocRoot )
				{
					pIDocRoot->Release();
					pIDocRoot = NULL;
				}
			}

			pIReferenceNode->Release();
		}
	}

	// is from our node?
	{
		IDMUSProdNode* pNode;
		hr = QueryInterface(IID_IDMUSProdNode, (void**)&pNode);
		if(SUCCEEDED(hr))
		{
			// Notification is from this Personality node
			if( pIDocRootNode == pNode && ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileNameChange ) 
			||  pIDocRootNode == pNode && ::IsEqualGUID( guidUpdateType, FRAMEWORK_AfterFileSave ) )
			{
				OnNameChange();
				hr = S_OK;
			}
			pNode->Release();
		}
	}



	return hr;
}

///////////////////////////////////////////////////////////////////////////
// CPersonality :: GetChordMapInfo(DMUSProdChordMapInfo* pChordMapInfo)

HRESULT CPersonality::GetChordMapInfo(DMUSProdChordMapInfo* pChordMapInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pChordMapInfo == NULL
	||  pChordMapInfo->wSize == 0 )
	{
		return E_INVALIDARG;
	}

	if( m_pPersonality == NULL )
	{
		return E_UNEXPECTED;
	}

	// Initialize structure
	WORD wSize = pChordMapInfo->wSize;
	memset( pChordMapInfo, 0, wSize );
	pChordMapInfo->wSize = wSize;

	// Fill in structure
	pChordMapInfo->lScalePattern = m_pPersonality->m_scalepattern;
	pChordMapInfo->bKey = (BYTE)GetAbsKey();
	pChordMapInfo->fUseFlats = (m_dwKey & CPersonality::UseFlats) ? TRUE : FALSE;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////
// CPersonality :: GetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo)

HRESULT CPersonality::GetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pChordMapUIInfo == NULL
	||  pChordMapUIInfo->wSize == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize structure
	WORD wSize = pChordMapUIInfo->wSize;
	memset( pChordMapUIInfo, 0, wSize );
	pChordMapUIInfo->wSize = wSize;

	// Fill in structure
	pChordMapUIInfo->fLockAllScales = m_fLockAllScales;
	pChordMapUIInfo->fSyncLevelOneToAll = m_fSyncLevelOneToAll;

	return S_OK;
}

#define MIN_SIZE_CHORDMAP_UI_STRUCT	8

///////////////////////////////////////////////////////////////////////////
// CPersonality :: SetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo)

HRESULT CPersonality::SetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pChordMapUIInfo == NULL
	||  pChordMapUIInfo->wSize < MIN_SIZE_CHORDMAP_UI_STRUCT )
	{
		return E_INVALIDARG;
	}

	// Update UI fields
	m_fLockAllScales = pChordMapUIInfo->fLockAllScales ? true : false;
	m_fSyncLevelOneToAll = pChordMapUIInfo->fSyncLevelOneToAll ? true : false;

	// Check pChordMapUIInfo->wSize before updating additional fields!

	m_fModified = TRUE;
	return S_OK;
}

//#pragma optimize("", off)
HRESULT CPersonality::SetStyleReference(IDMUSProdNode* pIStyleDocRootNode)
{
	HRESULT hr=S_OK;
	IDMUSProdNode* pOldDocRoot = GetStyleDocRoot();
	IDMUSProdNode* thisnode = static_cast<IDMUSProdNode*>(this);

	IDMUSProdReferenceNode* pRef = 0;
	if(m_pIStyleRefNode == NULL)
		return E_UNEXPECTED;
	hr = m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pRef);
	if(SUCCEEDED(hr))
	{
		if(pOldDocRoot)
		{
			// turn off notifications for this node
			hr = m_pComponent->m_pIFramework->RemoveFromNotifyList(pOldDocRoot, thisnode);
			pRef->SetReferencedFile(NULL);
			pOldDocRoot->Release();
		}

		if(pIStyleDocRootNode)
		{
			hr = pRef->SetReferencedFile(pIStyleDocRootNode);
			// turn on notifications
			hr = m_pComponent->m_pIFramework->AddToNotifyList(pIStyleDocRootNode, thisnode);
			m_fModified = TRUE;
		}

		pRef->Release();
	}
	return hr;
}
//#pragma optimize("", on)

IDMUSProdNode* CPersonality::GetStyleDocRoot()
// returns NULL if TRUE == IsNullReference 
// returned pointer needs to be released if non-null
{
	IDMUSProdReferenceNode* pRef = NULL;
	IDMUSProdNode* pDoc = NULL;
	if(m_pIStyleRefNode == NULL)
	{
		return NULL;
	}
	if(SUCCEEDED(m_pIStyleRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pRef)))
	{
		if(SUCCEEDED(pRef->GetReferencedFile(&pDoc)))
		{
		}
		pRef->Release();
	}
	return pDoc;
}


void CPersonality::SetChordChanges(DMPolyChord&pc)
{
	ClearChordList();
	m_paChordChanges = new ChordExt;
	*dynamic_cast<DMPolyChord*>(m_paChordChanges) = pc;
}

HRESULT CPersonality::DMSave(IStream * pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE( _afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdPersistInfo* pPersistInfo = NULL;
	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo, (void**)&pPersistInfo)))
	{
		pPersistInfo->GetStreamInfo(&StreamInfo);
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO ckMain;

	HRESULT hr = E_FAIL;

	hr = AllocRIFFStream(pIStream, &pIRiffStream);
	if(SUCCEEDED(hr))
	{
		ckMain.fccType = FOURCC_PERSONALITY;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF ) == 0
			&& SUCCEEDED( DMSavePersonality(pIRiffStream, ftFileType))
			&& pIRiffStream->Ascend(&ckMain, 0) == 0)
		{
			if(fClearDirty)
			{
				Modified() = FALSE;
			}
			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
			pIRiffStream->Release();
	}
	return hr;
}

HRESULT CPersonality::DMSavePersonality(IDMUSProdRIFFStream * pIRiffStream, FileType ftFileType)
{
	HRESULT hr;
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(!pIStream)
		return E_FAIL;

	if(ftFileType == FT_DESIGN)
	{
		SetSelectionType();			// for persisting what was selected on chord map
	}

	// write ioPersonality chunk
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_CHORDMAP personality;

	ck.ckid = FOURCC_IOPERSONALITY;
	if(pIRiffStream->CreateChunk(&ck,0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	// prepare ioPersonality chunk
	MultiByteToWideChar( CP_ACP, 0, m_pPersonality->m_name, -1, personality.wszLoadName, (size_t)20 );
	personality.dwScalePattern = m_pPersonality->m_scalepattern;
	personality.dwScalePattern |= GetAbsKey() << 24;	// MSByte is Root
	personality.dwFlags = m_pPersonality->m_dwflags;
	personality.dwFlags |= DMUS_CHORDMAPF_VERSION8;		// Scale saved in DX8 format.

	// write ioPersonality chunk
	pIStream->Write(&personality, sizeof(personality), &dwBytesWritten);
	if(pIRiffStream->Ascend(&ck, 0) == 0 && dwBytesWritten == sizeof(personality))
	{
		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

	if(!SUCCEEDED(hr))
	{
		goto ON_ERROR;
	}

	// write guid chunk
	ck.ckid = FOURCC_GUID;
	if(pIRiffStream->CreateChunk(&ck,0) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	pIStream->Write(&m_guidPersonality, sizeof(GUID),&dwBytesWritten);
	hr = pIRiffStream->Ascend(&ck, 0)  == 0 && dwBytesWritten == sizeof(GUID) ? S_OK : E_FAIL;

	if(!SUCCEEDED(hr))
	{
		goto ON_ERROR;
	}
		
	// write version chunk
	if(!SUCCEEDED(DMSaveVersion(pIRiffStream)))
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// write info chunk.
	if(!SUCCEEDED(DMSaveInfoList(pIRiffStream)))
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// write chord data
	if(!SUCCEEDED(DMSaveChordData(pIRiffStream, ftFileType == FT_DESIGN)))
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// write personality key
	{
		WriteChunk chunk(pIRiffStream, FOURCC_PERSONALITYKEY);
		if(!SUCCEEDED(WriteDWord(pIRiffStream, m_dwKey)))
		{
			goto ON_ERROR;
		}
	}

	// write personality groove
	{
		WriteChunk chunk(pIRiffStream, DM_FOURCC_GROOVE_LEVEL);
		if(!SUCCEEDED(WriteDWord(pIRiffStream, m_dwGroove)))
		{
			goto ON_ERROR;
		}
	}

	// if design time, write PersonalityEdit
	if(ftFileType == FT_DESIGN)
	{
		if(pIStream)
		{
			hr = SaveJazzStyleReference(pIStream);
		}
		if(!SUCCEEDED(DMSaveUI(pIRiffStream)))
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	else	// write Personality Structure info
	{
		if(!SUCCEEDED(DMSaveStructure(pIRiffStream)))
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}

HRESULT CPersonality::DMSaveInfoList(IDMUSProdRIFFStream * pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr=S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;
/* need to save empty chunk else undo won't properly update tab
	if( m_strName.IsEmpty()
	&&  m_strCategoryName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty()
	&&  m_strInfo.IsEmpty() )
	{
		return S_OK;
	}
*/
    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = DM_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Personality name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Personality category
	if( !m_strCategoryName.IsEmpty() )
	{
		ck.ckid = DM_FOURCC_CATEGORY_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCategoryName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Personality author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Personality copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Personality subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Personality comments
	if( !m_strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}

HRESULT CPersonality::DMSaveVersion(IDMUSProdRIFFStream * pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioPersonalityVersion oDMPersonalityVersion;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write PersonalityVersion chunk header
	ck.ckid = DM_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMPersonalityVersion structure
	memset( &oDMPersonalityVersion, 0, sizeof(ioPersonalityVersion) );

	oDMPersonalityVersion.m_dwVersionMS = m_dwVersionMS ;
	oDMPersonalityVersion.m_dwVersionLS = m_dwVersionLS;

	// Write PersonalityVersion chunk data
	hr = pIStream->Write( &oDMPersonalityVersion, sizeof(ioPersonalityVersion), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioPersonalityVersion) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}

HRESULT CPersonality::DMSaveUI(IDMUSProdRIFFStream * pIRiffStream)
{
	IStream* pIStream;
	DWORD dwBytesWritten;
	HRESULT hr;
	MMCKINFO ck;
	ck.ckid = FOURCC_PERSONALITYEDIT;
	if(pIRiffStream->CreateChunk(&ck,0) != 0)
	{
		return E_FAIL;
	}
	// prepare ioPersonalityEdit
	ioPersonalityEdit2 edit;
    MultiByteToWideChar( CP_ACP, 0, m_pPersonality->m_username, 
										-1, edit.wchUserName, sizeof( edit.wchUserName ) / sizeof( wchar_t ) );
    MultiByteToWideChar( CP_ACP, 0, m_pPersonality->m_description, 
										-1, edit.wchDescription, sizeof( edit.wchDescription ) / sizeof( wchar_t ) );
	edit.bVariableNotFixed = (m_fVariableNotFixed == TRUE);
	edit.wChordMapLength = m_nChordMapLength;
	edit.fUseTimeSignature = m_fUseTimeSignature;
	edit.lTimeSignature = MAKE_TIMESIG(m_nBPM, m_nBeat) ;
	edit.bKeySig = 0;	// this info stored in FOURCC_PERSONALITYKEY chunk

	// for next several fields: window and selection state not implemented
	edit.wSplitterYPos = GetSplitterPos();	
	edit.wScrollHorPos = 0;
	edit.wScrollVertPos = 0;

	edit.selection = static_cast<BYTE>(m_selectiontype);
	edit.wConnectionIdSelectedChord = 0;		// won't need this, info is in ioChordEntry keydown
	edit.wConnectionIdSelectedFromChord = m_nidFromChord;
	edit.wConnectionIdSelectedToChord = m_nidToChord;

	edit.wSelectedSignpostRow = 0;
	edit.wSelectedSignpostCol = 0;

	edit.fLockAllScales = m_fLockAllScales;
	edit.fSyncLevelOneToAll = m_fSyncLevelOneToAll;

	// check whether zoom has changed
	// need to do this here because chord dialog can't notify us if it has changed.
	if(m_pChordDlg)
	{
		double dblZoom = m_pChordDlg->GetZoom();
		if(dblZoom != m_dblZoom)
		{
			m_dblZoom = dblZoom;
		}

		const long lFunctionbarWidth = m_pChordDlg->GetFunctionbarWidth();
		if( lFunctionbarWidth != m_lFunctionbarWidth )
		{
			m_lFunctionbarWidth = lFunctionbarWidth;
		}
	}

	edit.dblZoom = m_dblZoom;
	edit.lFunctionbarWidth = m_lFunctionbarWidth;

	// write ioPersonalityEdit chunk
	pIStream = pIRiffStream->GetStream();
	if(pIStream)
	{
		pIStream->Write(&edit, sizeof(ioPersonalityEdit2), &dwBytesWritten);	
		hr = (pIRiffStream->Ascend(&ck, 0) == S_OK || dwBytesWritten == sizeof(ioPersonalityEdit2))
			? S_OK : E_FAIL;
	}
	else
	{
		hr = E_FAIL;
	}


	if(pIStream)
		pIStream->Release();
	return hr;
}



HRESULT CPersonality::DMSaveChordData(IDMUSProdRIFFStream * pIRiffStream, bool bIncludeDesignInfo)
{
	DMSubChordSet subchordset;
	ChordPaletteList chordpalette;
	ChordMapList	chordmap;
	SignPostListChunk	  signposts;

	HRESULT hr = S_OK;

	hr = chordpalette.Extract(m_pPersonality->m_chordpalette, subchordset)
			||  chordmap.Extract(m_pPersonality->m_chordlist, subchordset, false)
			|| signposts.Extract(m_pPersonality->m_signpostlist, subchordset, bIncludeDesignInfo);

	ASSERT(pIRiffStream);
	if(pIRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	if(hr == S_OK)
	{
		hr = subchordset.Write(pIRiffStream)
				|| chordpalette.Write(pIRiffStream)
				|| chordmap.Write(pIRiffStream)
				|| signposts.Write(pIRiffStream);
		if(hr == S_OK /* && bIncludeDesignInfo */)
		{
			hr = WriteChordEntryEditChunk(pIRiffStream, &(m_pPersonality->m_chordlist));
		}
	}
	return hr;
}


HRESULT CPersonality::DMLoadVersionChunk(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pIRiffStream);
	ASSERT(pckParent);
	if(pIRiffStream == NULL || pckParent == NULL)
	{
		return E_INVALIDARG;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	ioPersonalityVersion oDMPersonalityVersion;
	DWORD dwBytesRead;
	if(SUCCEEDED(pIStream->Read(&oDMPersonalityVersion, sizeof(oDMPersonalityVersion), &dwBytesRead))
		&& dwBytesRead == sizeof(oDMPersonalityVersion))
	{
		m_dwVersionMS = oDMPersonalityVersion.m_dwVersionMS;
		m_dwVersionLS = oDMPersonalityVersion.m_dwVersionLS;
	}
	else
	{
		hr = E_FAIL;
	}

	pIStream->Release();
	return hr;
}

HRESULT CPersonality::DMLoadInfoChunk(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pIRiffStream);
	ASSERT(pckParent);
	if(pIRiffStream == NULL || pckParent == NULL)
	{
		return E_INVALIDARG;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	MMCKINFO ckList;

	m_strName = "";
	m_strAuthor = "";
	m_strCopyright = "";
	m_strSubject = "";
	m_strInfo = "";
	m_strCategoryName = "";
	while( pIRiffStream->Descend( &ckList, pckParent, 0 ) == 0 )
	{
		switch( ckList.ckid )
		{
			case RIFFINFO_INAM:
			case DMUS_FOURCC_UNAM_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
				break;

			case RIFFINFO_IART:
			case DMUS_FOURCC_UART_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
				break;

			case RIFFINFO_ICOP:
			case DMUS_FOURCC_UCOP_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
				break;

			case RIFFINFO_ISBJ:
			case DMUS_FOURCC_USBJ_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
				break;

			case RIFFINFO_ICMT:
			case DMUS_FOURCC_UCMT_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
				break;

			case DM_FOURCC_CATEGORY_CHUNK:
				ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCategoryName );
				break;
		}
		pIRiffStream->Ascend( &ckList, 0 );
	}

	if(pIStream)
		pIStream->Release();
	return S_OK;
}

HRESULT CPersonality::DMLoadUI(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pIRiffStream);
	ASSERT(pckParent);
	if(pIRiffStream == NULL || pckParent == NULL)
	{
		return E_INVALIDARG;
	}
	ioPersonalityEdit2 edit;
	DWORD dwBytesRead;
	HRESULT hr = S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	DWORD dwTotalBytes = pckParent->cksize;
	ASSERT(dwTotalBytes <= sizeof(ioPersonalityEdit2));
	
	dwTotalBytes = min( sizeof(ioPersonalityEdit2), dwTotalBytes );

	hr = pIStream->Read(&edit, dwTotalBytes, &dwBytesRead);
	if(FAILED(hr) || dwBytesRead < sizeof(ioPersonalityEdit))
	{
		hr = E_FAIL;
	}
	else
	{
		WideCharToMultiByte(CP_ACP, 0, edit.wchUserName, -1, m_pPersonality->m_username, sizeof(m_pPersonality->m_username), 0,0);
		WideCharToMultiByte(CP_ACP, 0, edit.wchDescription, -1, m_pPersonality->m_description, sizeof(m_pPersonality->m_description), 0,0);
		m_fVariableNotFixed = edit.bVariableNotFixed ? TRUE : FALSE;
		m_nChordMapLength = edit.wChordMapLength;
		m_fUseTimeSignature = edit.fUseTimeSignature;
		m_nBPM = TIMESIG_BPM(edit.lTimeSignature);
		m_nBeat = TIMESIG_BEAT(edit.lTimeSignature);

		SetSplitterPos(edit.wSplitterYPos);

		m_selectiontype = edit.selection;
		m_nidToChord = edit.wConnectionIdSelectedToChord;
		m_nidFromChord = edit.wConnectionIdSelectedFromChord;

		if(dwTotalBytes >= sizeof(ioPersonality) + sizeof(double))
		{
			m_dblZoom = edit.dblZoom;
			if(m_dblZoom <= 0.0)
				m_dblZoom = 0.03125;
		}

		m_lFunctionbarWidth = edit.lFunctionbarWidth;

		m_fLockAllScales = edit.fLockAllScales;
		m_fSyncLevelOneToAll = edit.fSyncLevelOneToAll;
	}	

	pIStream->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersonality IDMUSProdNode::GetObject

HRESULT CPersonality::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMStyle object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicChordMap ) )
	{
		if( m_pIDirectMusicChordMap )
		{
			return m_pIDirectMusicChordMap->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}



////////////////////////////////////////////////////////// Personality static funcs

// conversions between personality key and root, flat/sharp
bool CPersonality::GetFlatsFlag(DWORD key)
{
	return (key & UseFlats) != 0;
}

void CPersonality::SetFlatsFlag(bool useflats, DWORD& key)
{
	if(useflats)
	{
		key |= CPersonality::UseFlats;
	}
	else
	{
		key &= ~CPersonality::UseFlats;
	}
}

static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void CPersonality::RootToString(char *string, DWORD key)
{
	bool useflats = GetFlatsFlag(key);
	SetFlatsFlag(false, key);
	if(useflats)
	{
		wsprintf( string,"%d %s",1 + key/12, (LPSTR)flatconvert[key%12] ) ;
	}
	else
	{
		wsprintf( string,"%d %s",1 + key/12, (LPSTR)convert[key%12] ) ;
	}
}

void CPersonality::CreateUndoMgr()
{
	// create undo mgr;
	if(m_pUndoMgr == NULL)
	{
		m_pUndoMgr = new CJazzUndoMan(m_pComponent->m_pIFramework);
		m_pUndoMgr->SetStreamAttributes(FT_DESIGN, GUID_CurrentVersion);
	}
}

void CPersonality::RefreshProperties()
{
	if( theApp.m_pIPageManager == NULL )
	{
		return;
	}

	theApp.m_pIPageManager->RefreshData();

	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				pIPageObject->Release();
			}
		}

		pIPropSheet->Release();
	}
}

bool CPersonality::GetLastEdit(CString & str)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IDMUSProdStripMgr* pChordMapMgr = NULL;
	HRESULT hr = m_punkChordMapMgr->QueryInterface(IID_IDMUSProdStripMgr, (void**)&pChordMapMgr);
	if(SUCCEEDED(hr))
	{
		pChordMapMgr->GetParam(GUID_ChordMapStripUndoText, 0, 0 , (void*)&str);
		pChordMapMgr->Release();
	}
	else
	{
		str = "";
	}
	return str.GetLength() > 0;
}

void CPersonality::CleanupObjects()
// delete objects held by personality
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// m_pPersonality will == NULL if an error occurs during loading and
	// this object is deleted.
	if( m_pPersonality )
	{
		ChordEntry *pchord = m_pPersonality->m_chordlist.GetHead();
		SignPost *psignpost = m_pPersonality->m_signpostlist.GetHead();
		for (;pchord;)
		{
			ChordEntry *next = pchord->GetNext();
			delete pchord;
			pchord = next;	
		}
		m_pPersonality->m_chordlist.RemoveAll();
		for (;psignpost;)
		{
			SignPost *next = psignpost->GetNext();
			delete psignpost;
			psignpost = next;	
		}
		m_pPersonality->m_signpostlist.RemoveAll();
  }

	ClearChordList();
	List_Free( m_lstCommandList );
}

/*
// enums for selection type (matches Chordmapmgr enums
#define CHORD_NO_SELECTION						0
#define CHORD_PALETTE_SELECTED					1
#define CHORD_MAP_SELECTED						2
#define CHORD_CONNECTION_SELECTED				3
*/

void CPersonality::SetSelectionType()
{
	IDMUSProdStripMgr *pStripMgrChordMap = NULL;

	m_selectiontype = CHORD_NO_SELECTION;
	m_nidToChord = -1;
	m_nidFromChord = -1;

	if( SUCCEEDED ( m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap ) ) )
	{
		// TO DO: This should be replaced by explicit calls to determine selection type
		// Note: until then DO NOT change order of enums in CChordMapMgr
		pStripMgrChordMap->GetParam(GUID_SelectedObjectType, 0,0, &(m_selectiontype));
		switch(m_selectiontype)
		{
		
			case CHORD_MAP_SELECTED:
				// nothing to do, keydown already set in chords
				break;
			
			case CHORD_CONNECTION_SELECTED:
				{
					NextChord* pNext;
					if(SUCCEEDED(pStripMgrChordMap->GetParam(GUID_SelectedConnection, 0,0, &pNext)))
					{
						if( pNext )
						{
							m_nidToChord = pNext->m_nid;
							m_nidFromChord = pNext->m_parent->m_nid;
						}
						else
						{
							m_selectiontype = CHORD_NO_SELECTION;
						}
					}
				}
				break;
			
			case CHORD_PALETTE_SELECTED:
					if(SUCCEEDED(pStripMgrChordMap->GetParam(GUID_SelectedPaletteIndex, 0,0, &m_idxPaletteChord)))
					{
					}
				break;
		}

		pStripMgrChordMap->Release();
	}

}


HRESULT CPersonality::DMSaveStructure(IDMUSProdRIFFStream * pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(!pIRiffStream)
		return E_INVALIDARG;
	PersonalityStructure	ps;
	ps.bVariableNotFixed = (m_fVariableNotFixed == TRUE);
	ps.wChordMapLength = m_nChordMapLength;
	ps.bUseTimeSignature = (m_fUseTimeSignature == TRUE);
	ps.lTimeSig = MAKE_TIMESIG(m_nBPM, m_nBeat);
	return ps.Write(pIRiffStream);
}

HRESULT CPersonality::DMLoadStructure(IDMUSProdRIFFStream * pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(!pIRiffStream)
		return E_INVALIDARG;
	PersonalityStructure	ps;
	HRESULT hr = ps.Read(pIRiffStream);
	if(hr == S_OK)
	{
		m_fVariableNotFixed = ps.bVariableNotFixed ? TRUE : FALSE;
		m_fUseTimeSignature = ps.bUseTimeSignature ? TRUE : FALSE;
		m_nBPM = TIMESIG_BPM(ps.lTimeSig);
		m_nBeat = TIMESIG_BEAT(ps.lTimeSig);
		m_nChordMapLength = ps.wChordMapLength;
	}
	return hr;
}

HRESULT CPersonality::InitializeStyleReference()
{
	ASSERT(m_pComponent->m_pIFramework);

	IDMUSProdDocType* pIDocType = NULL;
	IDMUSProdProject* pIProject = NULL;
	IDMUSProdNode* pIFileNode = NULL;
	IDMUSProdNode* pDocRoot = NULL;
	HRESULT hr = S_OK;

	IDMUSProdNode* pOldDocRoot = GetStyleDocRoot();
	if(pOldDocRoot)
	{
		// already set, nothing to do
		pOldDocRoot->Release();
		return hr;
	}

	if(m_pIStyleRefNode == NULL)
	{
		// Allocate a new reference node
		IDMUSProdComponent* pIStyleComponent;
		hr = m_pComponent->m_pIFramework->FindComponent( CLSID_StyleComponent,  &pIStyleComponent );
		if(FAILED(hr))
		{
			return E_FAIL;
		}
		hr = pIStyleComponent->AllocReferenceNode(GUID_StyleRefNode, &m_pIStyleRefNode);
		RELEASE(pIStyleComponent);
		if(FAILED(hr))
		{
			return  E_OUTOFMEMORY;
		}
	}

	if( FAILED ( m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		return E_FAIL;
	}

	hr = m_pComponent->m_pIFramework->FindProject(this, &pIProject);

	if(FAILED(hr))
	{
		pIDocType->Release();
		return E_FAIL;
	}

	hr = pIProject->GetFirstFileByDocType( pIDocType, &pIFileNode );

	if(hr == S_OK)
	{
		GUID guidFile;
		if(SUCCEEDED(m_pComponent->m_pIFramework->GetNodeFileGUID(pIFileNode, &guidFile)))
		{
			IDMUSProdNode* pIStyleDocRootNode = NULL;
			if(SUCCEEDED(m_pComponent->m_pIFramework->FindDocRootNodeByFileGUID(guidFile, &pIStyleDocRootNode)))
			{
				SetStyleReference(pIStyleDocRootNode);
				pIStyleDocRootNode->Release();
				Modified() = FALSE;	// setstylereference dirties us, need to be clean
			}
		}
		pIFileNode->Release();
	}

	if(pIProject)
		pIProject->Release();
	if(pIDocType)
		pIDocType->Release();
	return hr;
}

#pragma warning(default:4189)

void TransposeDMPolyChord(DMPolyChord& chord, int howmuch, bool bFlatsNotSharps)
{
	for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
	{
		// first do chord
		DMChord* pChord = chord.SubChord(i);
		int newKey = pChord->ChordRoot() + howmuch;
		while(newKey < 0)
		{
			newKey += 12;
		}
		while(newKey > 23)
		{
			newKey -= 12;
		}
		pChord->UseFlat() = bFlatsNotSharps;
		pChord->ChordRoot() = static_cast<BYTE>(newKey);
		// now transpose scale by same amount
		pChord->ScalePattern() = Rotate24(pChord->ScalePattern(), howmuch);
	}
}

void CPersonality::TransposeAllChords(DWORD dwNewKey)
{
	// compute transposition
	int nTranspose = ((dwNewKey &0x7f) - (m_dwKey & 0x7f));

	if(nTranspose < 0)
	{
		nTranspose += 24;
	}

	bool bFlatsNotSharps = (dwNewKey & UseFlats) != 0;

	ChordPalette pal;

	// Transpose chords in ChordPalette
	int i1;
	int j;
	TRACE("\r\nTranspose = %d\r\n", nTranspose);
	for(i1 = 0; i1 < 24; i1++)
	{
		int i2 = (i1 + nTranspose) % 24;
		strcpy(pal.m_chords[i2].Name(), m_pPersonality->m_chordpalette.m_chords[i1].Name());
		for(j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pal.m_chords[i2].SubChord(j)->ChordPattern()
				= m_pPersonality->m_chordpalette.m_chords[i1].SubChord(j)->ChordPattern();
			pal.m_chords[i1].SubChord(j)->ScalePattern() = m_pPersonality->m_scalepattern;
			pal.m_chords[i1].SubChord(j)->ScaleRoot() = (BYTE)GetAbsKey();
			pal.m_chords[i1].SubChord(j)->UseFlat() = bFlatsNotSharps;
		}
		TRACE("%d: Name: %s, Pattern: %x\r\n", i2, pal.m_chords[i2].Name(),
				pal.m_chords[i2].SubChord(0)->ChordPattern());
	}
	memcpy(&(m_pPersonality->m_chordpalette), &pal, sizeof(ChordPalette));

	

	// Go through the Chords in the ChordList and transpose each
	ChordEntry*	pChord		= NULL;
	for(pChord = m_pPersonality->m_chordlist.GetHead(); pChord != NULL;	pChord = pChord->GetNext())
	{
		TransposeDMPolyChord(pChord->m_chordsel, nTranspose, bFlatsNotSharps);
	}

	// go through chords in signpost list and transpose each
	SignPost* pSignPost = NULL;
	for(pSignPost = m_pPersonality->m_signpostlist.GetHead(); pSignPost != NULL; pSignPost = pSignPost->GetNext())
	{
		TransposeDMPolyChord(pSignPost->m_chord, nTranspose, bFlatsNotSharps);
		// check cadence chords
		if(pSignPost->m_dwflags & SPOST_CADENCE1)
		{
			TransposeDMPolyChord(pSignPost->m_cadence[0], nTranspose, bFlatsNotSharps);
		}
		if(pSignPost->m_dwflags & SPOST_CADENCE2)
		{
			TransposeDMPolyChord(pSignPost->m_cadence[1], nTranspose, bFlatsNotSharps);
		}
	}
}

void CPersonality::RefreshChordMap()
{
	if( m_punkChordMapMgr == NULL ) return;

	IDMUSProdStripMgr *pStripMgrChordMap = NULL;
	if( FAILED(m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap )) )
	{
		return;
	}

	IDMUSProdTimeline *pTimeline = NULL;
	VARIANT varTimeline;
	if( FAILED(pStripMgrChordMap->GetStripMgrProperty( SMP_ITIMELINECTL, &varTimeline )) || (V_UNKNOWN( &varTimeline ) == NULL) )
	{
		pStripMgrChordMap->Release();
		return;
	}
	if( FAILED( V_UNKNOWN( &varTimeline )->QueryInterface( IID_IDMUSProdTimeline, (void**)&pTimeline ) ) || (pTimeline == NULL) )
	{
		V_UNKNOWN( &varTimeline )->Release();
		pStripMgrChordMap->Release();
		return;
	}
	V_UNKNOWN( &varTimeline )->Release();

	pStripMgrChordMap->Release();

	pTimeline->Refresh();
	pTimeline->Release();
}

void CPersonality::RefreshSignPosts(bool bRefresh)
{
	if(m_pSignPostDlg)
		m_pSignPostDlg->Refresh(bRefresh);
}




void CPersonality::UpdateChordPalette( bool fUpdateChords )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	DWORD lScalePattern = Rotate24( m_pPersonality->m_scalepattern, GetAbsKey() );
	
	ChordBuilder* pcb = 0;
	try
	{
		if( m_paletteChordType == ChordBuilder::Seventh
		||  m_paletteChordType == ChordBuilder::Triad )
		{
			pcb = new ChordBuilder( lScalePattern, m_paletteChordType, GetAbsKey() );
		}
		else
		{
			switch(m_paletteChordType)
			{
			case ChordBuilder::AllMaj:
				pcb = new ChordBuilder(0x000091, "maj");
				break;
			case ChordBuilder::AllMin:
				pcb = new ChordBuilder(0x000089, "min");
				break;
			case ChordBuilder::AllMaj7:
				pcb = new ChordBuilder(0x000891, "maj7");
				break;
			case ChordBuilder::AllMin7:
				pcb = new ChordBuilder(0x000489, "min7");
				break;
			case ChordBuilder::AllDom7:
				pcb = new ChordBuilder(0x000491, "7");
				break;
			default:
				ASSERT(false);
				break;
			}
		}
	}
	catch(...)
	{
		ASSERT(false);
		return;
	}

	for( int i = 0;  i < 24;  i++ )
	{
		if( fUpdateChords )
		{
			strcpy( m_pPersonality->m_chordpalette.m_chords[i].Name(), pcb->ChordName(i) );
		}
		for( int j = 0;  j < DMPolyChord::MAX_POLY;  j++ )
		{
			if( fUpdateChords )
			{
				m_pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = pcb->ChordPattern(i);
			}
			m_pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = m_pPersonality->m_scalepattern;
			m_pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = GetAbsKey();
		}
	}

	if( pcb )
	{
		delete pcb;
	}
}

int& CPersonality::PaletteChordType()
{
	return m_paletteChordType;
}

void CPersonality::ClearSPLinks()
{
	for(SignPost* pSignPost = m_pPersonality->m_signpostlist.GetHead(); pSignPost; pSignPost = pSignPost->GetNext())
	{
		pSignPost->m_dwflags &= ~SPOST_MATCHED;
	}
}

void CPersonality::ClearCMLinks()
{
	for(ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();pChord;pChord = pChord->GetNext())
	{
		pChord->m_dwflags &= ~CE_MATCHED;
	}
}

bool CPersonality::Match(ChordEntry* ce, SignPost* sp)
{
	if(!ce->IsSignPost())
		return false;
	bool match = true;
	for(int i = 0; match && (i < DMPolyChord::MAX_POLY); i++)
	{
		if(ce->m_chordsel.SubChord(i)->ChordPattern() != sp->m_chord.SubChord(i)->ChordPattern())
		{
			match = false;
		}
		else if(ce->m_chordsel.SubChord(ce->m_chordsel.RootIndex())->ChordRoot()
					!= sp->m_chord.SubChord(sp->m_chord.RootIndex())->ChordRoot())
		{
			match = false;
		}
	}
	return match;
}

bool CPersonality::Match(SignPost* sp1, SignPost* sp2)
{
	bool match = true;
	for(int i = 0; match && (i < DMPolyChord::MAX_POLY); i++)
	{
		if(sp1->m_chord.SubChord(i)->ChordPattern() != sp2->m_chord.SubChord(i)->ChordPattern())
		{
			match = false;
		}
		else if(sp1->m_chord.SubChord(sp1->m_chord.RootIndex())->ChordRoot()
					!= sp2->m_chord.SubChord(sp2->m_chord.RootIndex())->ChordRoot())
		{
			match = false;
		}
	}
	return match;
}

void CPersonality::LinkCMToSP()
{
	for(ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();pChord;pChord = pChord->GetNext())
	{
		Link2SP(pChord, false);	
	}
}

bool CPersonality::Link2SP(ChordEntry* ce, bool bRefreshChordMap)
{
	UNREFERENCED_PARAMETER(bRefreshChordMap);
	if(!ce->IsSignPost())
		return false;
	bool match = false;
	for(SignPost* sp = m_pPersonality->m_signpostlist.GetHead(); sp; sp = sp->GetNext())
	{
		if(Match(ce,sp))
		{
			match = true;
			Link(ce,sp);
		}
	}
	return match;
}

bool CPersonality::Link2SP(SignPost* sp2)
{
	bool match = false;
	for(SignPost* sp = m_pPersonality->m_signpostlist.GetHead(); sp; sp = sp->GetNext())
	{
		if(sp == sp2)
			continue;	// don't try to match a signpost to itself
		if(Match(sp2,sp))
		{
			if(sp2->m_dwflags & SPOST_MATCHED)
			{
				match = true;
				Link(sp2,sp);
			}
		}
	}
	return match;
}

bool CPersonality::Link2CM(SignPost* sp)
{
	bool match = false;
	for(ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();pChord;pChord = pChord->GetNext())
	{
		if(Match(pChord, sp))
		{
			match = true;
			Link(pChord, sp);
		}
	}
	return match;
}


void CPersonality::LinkAll(bool bIsStructuralChange)
{
	UNREFERENCED_PARAMETER(bIsStructuralChange);

	ClearSPLinks();
	ClearCMLinks();
	LinkCMToSP();
	RefreshChordMap();
//	RefreshSignPosts(bIsStructuralChange);
	if(m_pSignPostDlg)
		m_pSignPostDlg->UpdateOrphanStatus(true);
}


void CPersonality::ComputeChordMap()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Change the Time Signature of the Timeline
	if( m_punkChordMapMgr == NULL ) return;

	IDMUSProdStripMgr *pStripMgrChordMap = NULL;
	if( FAILED(m_punkChordMapMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgrChordMap )) )
	{
		return;
	}
	
	pStripMgrChordMap->OnUpdate(GUID_TimeSignature, 0, 0);

	pStripMgrChordMap->Release();
}

ChordEntryList* CPersonality::GetChordList()
{
	return &(m_pPersonality->m_chordlist);
}

bool CPersonality::CheckForData(long lBeginMeasure)
{
	bool rc = false;
	for(ChordEntry* pChord = m_pPersonality->m_chordlist.GetHead();
		pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.Measure() >= lBeginMeasure)
		{
			rc = true;
			return rc;
		}
	}
	return rc;
}

void CPersonality::SetStyleDocRootNode()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent->m_pIFramework);

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdNode* pIFileNode, *pIStyleDocRootNode;

	if( FAILED ( m_pComponent->m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pComponent->m_pIFramework->FindProject(this, &pIProject);

	if(hr==S_OK)
	{
		hr = pIProject->GetFirstFileByDocType( pIDocType, &pIFileNode );		
		if(hr == S_OK)
		{
			GUID guidFile;
			if(SUCCEEDED(m_pComponent->m_pIFramework->GetNodeFileGUID(pIFileNode, &guidFile)))
			{
				if(SUCCEEDED(m_pComponent->m_pIFramework->FindDocRootNodeByFileGUID(guidFile, &pIStyleDocRootNode)))
				{
					SetStyleReference(pIStyleDocRootNode);
					pIStyleDocRootNode->Release();
				}
			}
			pIFileNode->Release();
		}

		pIProject->Release();
	}
	pIDocType->Release();

}


double& CPersonality::ZoomFactor()
{
	return m_dblZoom;
}

LONG& CPersonality::FunctionbarWidth()
{
	return m_lFunctionbarWidth;
}

void CPersonality::OnNameChange()
{
	// Our File name changed - Get new Segment file name
	CString strName;
	BSTR bstrName;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->GetNodeFileName( this, &bstrName ) ) )
	{
		// Node is in the Project tree
		strName = bstrName;
		::SysFreeString( bstrName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Segment is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}

	// Plus "name"
	strName += m_pPersonality->m_username;

	// Update the Conductor's Toolbars
	bstrName = strName.AllocSysString();
	m_pComponent->m_pIConductor->SetTransportName( this, bstrName );

	// Update the Framework
	m_pComponent->m_pIFramework->RefreshNode( this );
/*
	// Update our property sheet
	ASSERT(m_pComponent);
	ASSERT(m_pComponent->m_pIFramework);
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void **) &pIPropSheet)))
	{
		pIPropSheet->RefreshTitleByObject(this);
		pIPropSheet->Release();
	}
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::GetObjectDescriptor

HRESULT CPersonality::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidPersonality, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicChordMap, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_pPersonality->m_username, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::GetGUID

void CPersonality::GetGUID( GUID* pguidPersonality )
{
	if( pguidPersonality )
	{
		*pguidPersonality = m_guidPersonality;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::SetGUID

void CPersonality::SetGUID( GUID guidPersonality )
{
	m_guidPersonality = guidPersonality;

	// Sync Personality with DirectMusic
	m_fModified = TRUE;
	SyncPersonalityWithEngine(CPersonality::syncPersonality);

	// Notify connected nodes that Personality GUID has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Personality.h ===
#ifndef __PERSONALITY_H__
#define __PERSONALITY_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Personality.h : header file
//

#include "PersonalityComponent.h"
#include "PersonalityDocType.h"
#include "PersonalityRef.h"

#include "RiffStrm.h"
#include "Chord.h"

#include "dmusici.h"
#include "dmusicf.h"

#include "DllBasePropPageManager.h"
#include "TabPersonality.h"
#include "TabAudition.h"
#include "TabChordPalette.h"

#include "Timeline.h"
#include "DLLJazzDataObject.h"

#include "JazzUndoMan.h"

#include "TabPersonalityInfo.h"

#include "SignPostDialog.h"

//#include "chorddialog.h"

#define MAKE_TIMESIG( bpm, beat ) ( (long)( ((DWORD)(WORD)beat) | ( ((DWORD)(WORD)bpm) << 16 ) ) )
#define TIMESIG_BEAT( tsig ) ( (short)tsig )
#define TIMESIG_BPM( tsig ) ( (WORD)( ((DWORD)tsig) >> 16 ) )


class CChordDialog;
class CTabAudition;
class CTabPersonality;
class CTabChordPalette;
class CTabPersonalityInfo;

class CSignPostDialog;

#define PERH_INVALID_BITS	0x11110000


//////////////////////////////////////////////////////////////////////
//  CPersonalityPageManager

class CPersonalityPageManager : public CDllBasePropPageManager 
{
	friend class CTabPersonalityInfo;
	friend class CTabPersonality;
public:
	CPersonalityPageManager( IDMUSProdFramework* pIFramework, CPersonality* pPersonality );
	virtual ~CPersonalityPageManager();


    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
	//HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithTabData();

	// Member variables
private:
	IDMUSProdFramework*	m_pIFramework;
	CTabPersonality*	m_pTabPersonality;
	CTabAudition*		m_pTabAudition;
	CTabChordPalette*	m_pTabChordPalette;
	CTabPersonalityInfo* m_pTabPersonalityInfo;
	CPersonality*		m_pPersonality;
public:
	CPersonality*		GetPersonality()
	{
		return m_pPersonality;
	}
	static short		sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CPersonality
class CPersonality : public IDMUSProdNode, public IDMUSProdPropPageObject, public IPersistStream, 
					 public IDMUSProdTimelineCallback, public IDMUSProdTransport, public IDMUSProdNotifyCPt,
					 public IDMUSProdNotifySink, public IDMUSProdChordMapInfo
{
//friend class CPersonalityCtrl;
//friend class CPersonalityDlg;
friend class CPersonalityRef;
friend class CTabPersonalityInfo;

//	friend class CSignPostDialog;
public:
    CPersonality( CPersonalityComponent* pComponent );
	~CPersonality();
	HRESULT Initialize();

	static bool GetFlatsFlag(DWORD key);
	static void SetFlatsFlag(bool useflats, DWORD& key);
	static void RootToString(char* string, DWORD key);

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode **ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode *pIChildNode, IDMUSProdNode **ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

    HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );


	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

   	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	
	// IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdTimelineCallback method
	HRESULT STDMETHODCALLTYPE OnDataChanged(IUnknown *);

	// IDMUSProdTransport methods
	STDMETHOD(Play)(BOOL /*fPlayFromStart*/);
	STDMETHOD(Stop)(BOOL fStopImmediate);
	STDMETHOD(Transition)();
	STDMETHOD(Record)(BOOL fPressed);
	STDMETHOD(GetName)(BSTR* pbstrName);
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);

	// IAANotifyCPt methods
	STDMETHOD(OnNotify)( ConductorNotifyEvent* pEvent);

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

	// IDMUSProdChordMapInfo
    HRESULT STDMETHODCALLTYPE GetChordMapInfo(DMUSProdChordMapInfo* pChordMapInfo);
    HRESULT STDMETHODCALLTYPE GetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo);
    HRESULT STDMETHODCALLTYPE SetChordMapUIInfo(DMUSProdChordMapUIInfo* pChordMapUIInfo);

	// CPersonality native methods
	void	ChangeChordSignPostTimeSig(); // Changes the TimeSigs of all Chords and SignPosts
	void	ChangeChordMapLength();		  // Changes the length of the chord map
	void	ChangeChordMapEditMode();	  // Changes chordmap to fixed or variable mode
	void	StopIfPlaying( DWORD dwFlags );
	HRESULT UnAdviseConnectionPoint();
	HRESULT AdviseConnectionPoint();
	BOOL UpdateSelectedChordList();
	Personality*	GetPersonality() { return m_pPersonality; }
	// Additional functions
protected:

    // JazzNotify helpers
	HRESULT SetStyleReference(IDMUSProdNode* pDocRoot);
	IDMUSProdNode* GetStyleDocRoot();

	// section construction methods
	HRESULT ComposeSection( IDirectMusicSegment** ppISection);
	HRESULT SaveJazzStyleReference( LPSTREAM);
	HRESULT LoadJazzStyleReference( LPSTREAM);
	HRESULT SaveChordList( LPSTREAM pStream );
	HRESULT SaveChordList( IDMUSProdRIFFStream* pRIFF );
	HRESULT SaveCommandList( IDMUSProdRIFFStream* pRIFF );
	HRESULT SaveCommandList( IStream* pIStream );
	HRESULT GetDirectMusicStyle(IDirectMusicStyle** ppIStyle);

	// some chord map deletion helpers
	void DeleteAllConnectionsToChord( int nID );
	void TrimChordMap();

	// drag / drop helpers
	HRESULT PasteCF_STYLE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
							  IDMUSProdNode* pIPositionNode );


public:
	DWORD GetSignPostListPtr();
	BOOL &Modified();

	void  SetChordChanges(DMPolyChord& pc);

public:
    HRESULT LoadPersonality( IStream* pStream, DWORD dwSize, DWORD id = ID_PERSONALITY);
    HRESULT LoadPersonality( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

	enum { syncPersonality=0x1, syncAudition = 0x2, syncStopMusic=0x4};	//why SyncPersonalityWithEngine is being called, or'd
	enum { UseFlats = 0x10000000};
	HRESULT SyncPersonalityWithEngine(int why);

	HRESULT SendChordMapAndPaletteToChordMapMgr();
	HRESULT SaveChordList( IStream* pIStream, BOOL bReleaseSave );

	BOOL	VariableNotFixed() { return m_fVariableNotFixed; }
	void ClearChordList();

	short GetBeat() { return m_nBeat; }
	short GetBPM() { return m_nBPM; }
	short GetChordMapLength() { return m_nChordMapLength; }
public:
	HRESULT DMSaveChordData(IDMUSProdRIFFStream* pIRiffStream, bool bIncludeDesignInfo);
	HRESULT DMSaveUI(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT DMSaveVersion(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT DMSaveInfoList(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT DMSavePersonality(IDMUSProdRIFFStream* pIRiffStream, FileType ftFileType);
	HRESULT DMSave(IStream* pIStream, BOOL fClearDirty);

	HRESULT DMLoadVersionChunk(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT DMLoadInfoChunk(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent);
	HRESULT DMLoadUI(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent);

	DWORD GetKey()
	{
		return m_dwKey;
	}

	DWORD GetAbsKey()	// no flats flag
	{
		return m_dwKey & ~UseFlats;
	}

	void SetKey(DWORD key)
	{
			m_dwKey = key;
	}

	// returns palette chord corresponding to m_dwKey
	const ChordSelection&	GetKeyChord() const
	{
		return m_pPersonality->m_chordpalette.Chord(m_dwKey & ~UseFlats);
	}

	CPersonalityComponent	*m_pComponent;

	// Personality's Edit Strip Managers
	LPUNKNOWN		m_punkChordMapMgr;

	// Dialog Sizing Functions
	WORD	GetSplitterPos()
	{
		return m_wSplitterPos;
	}
	void SetSplitterPos(WORD pos, bool bMarkAsDirty=true)
	{
		m_wSplitterPos = pos;
		if(bMarkAsDirty)
			m_fModified = TRUE;
	}

	double& ZoomFactor();
	LONG& FunctionbarWidth();

	// Personality specific data.
protected:
	Personality*	m_pPersonality;		// Personality
	BOOL			m_fModified;
	
	int				m_paletteChordType;

private:
    DWORD			m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;
	IDirectMusicChordMap*	m_pIDirectMusicChordMap;
	HWND			m_hWndEditor;
	// used by Advise/UnAdviseConnection
	DWORD			m_dwCookie;
	BOOL			m_bAdvised;
	BOOL			m_fVariableNotFixed;
	WORD			m_wSplitterPos;
	double			m_dblZoom;
	LONG			m_lFunctionbarWidth;

	// used to determine what objects are selected when loading or saving chordmap chords.
	int					m_selectiontype;		// types #define'd in chord.h
	short					m_nidToChord;
	short					m_nidFromChord;
	int					m_idxPaletteChord;
	void				SetSelectionType();		// from chord map to internal state
//	void				GetSelectionType();		// from loaded chords to internal state

// Personality Reference data for Music Engine
//    CString			m_strName;
//	CString			m_strFileName;
    GUID			m_guidPersonality;
    BYTE			m_fDefault;           // 1=Default personality
	IDirectMusicSegment*		m_pISection;		  // section being auditioned
	IDirectMusicSegmentState	*m_pIDMSegmentState;
    ChordExt	*m_paChordChanges;		// List of Chord changes.
	CommandExt	*m_lstCommandList;		// Command list.
	BOOL			m_bSectionStopping;
// Additional fields added to store Personality properties
	BOOL			m_fUseTimeSignature;	// for edit mode
	short			m_nBPM;					// for edit mode
	short			m_nBeat;				// for edit mode
	short			m_nChordMapLength;		// for edit mode
	DWORD			m_dwKey;				// Loword is key, high bit is sharp, flat flag
	IDMUSProdNode*	m_pIStyleRefNode;		// for audition
	DWORD			m_dwGroove;				// for audition

	// personality info list
	CString		m_strName;
	CString		m_strCategoryName;
	CString		m_strAuthor;
	CString		m_strCopyright;
	CString		m_strSubject;
	CString		m_strInfo;


	// personality version
	DWORD	m_dwVersionLS;
	DWORD	m_dwVersionMS;

	// undo
	void	CreateUndoMgr();
public:
	void OnNameChange( void );
	CString		m_strOrigFileName;
	void SetStyleDocRootNode();
	bool CheckForData(long lBeginAtMeasure);
	ChordEntryList* GetChordList();
	void ComputeChordMap();
	// functions for matching signpost chords on grid to those in chordmap
	void ClearSPLinks();
	void ClearCMLinks();
	bool Match(ChordEntry* ce, SignPost* sp);
	bool Match(SignPost* sp1, SignPost* sp2);
	void Link(ChordEntry* ce, SignPost* sp)
	{
		ce->m_dwflags |= CE_MATCHED;
		sp->m_dwflags |= SPOST_MATCHED;
	}
	void Link(SignPost* sp1, SignPost* sp2)
	{
		sp1->m_dwflags |= SPOST_MATCHED;
		sp2->m_dwflags |= SPOST_MATCHED;
	}
	void LinkCMToSP();
	bool Link2SP(ChordEntry* ce, bool bRefreshChordMap);
	bool Link2SP(SignPost* sp);
	bool Link2CM(SignPost* sp);
	void LinkAll(bool bIsStructuralChange);


	int& PaletteChordType();
	void UpdateChordPalette(bool fUpdateChords);
	void RefreshSignPosts(bool bRefresh);
	void RefreshChordMap();
	void TransposeAllChords(DWORD dwNewKey);
	HRESULT InitializeStyleReference();
	HRESULT DMLoadStructure(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT DMSaveStructure(IDMUSProdRIFFStream* pIRiffStream);
    HRESULT GetObjectDescriptor( void* pObjectDesc );
	void CleanupObjects();
	bool GetLastEdit(CString& str);
	CJazzUndoMan*		m_pUndoMgr;
	void RefreshProperties();
	void GetGUID( GUID* pguidPersonality );
	void SetGUID( GUID guidPersonality );
	
	CSignPostDialog*	m_pSignPostDlg;
	CChordDialog*		m_pChordDlg;

	bool				m_fLockAllScales;
	bool				m_fSyncLevelOneToAll;
};

#endif // __PERSONALITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityComponent.h ===
#ifndef __PERSONALITYCOMPONENT_H__
#define __PERSONALITYCOMPONENT_H__

// PersonalityComponent.h : header file
//

#include <afxtempl.h>

#define	FIRST_PERSONALITY_IMAGE		2
#define FIRST_PERSONALITYREF_IMAGE	4

class CPersonality;

class CPersonalityComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt
{
friend class CPersonality;
public:
    CPersonalityComponent();
	~CPersonalityComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp(BOOL fActivate);

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists( void );
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetPersonalityImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex( short* pnFirstImage );
    HRESULT STDMETHODCALLTYPE GetPersonalityRefImageIndex( short* pnNbrFirstImage );
	void ScalePatternToScaleName( long lScalePattern, CString& strScaleName );
	void AddToPersonalityFileList( CPersonality* pPersonality );
	void RemoveFromPersonalityFileList( CPersonality* pPersonality );
	char DetermineRoot( DWORD dwScale );

	HRESULT STDMETHODCALLTYPE GetConductor(IDMUSProdConductor**);
private:
	BOOL	m_bDirty;

public:
	IDirectMusicPerformance*	m_pIEngine;
	IDMUSProdFramework* m_pIFramework;
	short				m_nNextPersonality;	// appended to name of new Personalitys
	UINT				m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format
	UINT				m_cfStyle;			// CF_STYLE clipboard format
	UINT				m_cfPersonality;	// CF_PERSONALITY clipboard format

private:
    DWORD				m_dwRef;
	IDMUSProdDocType8*  m_pIDocType8;
	IDMUSProdConductor* m_pIConductor;
	short				m_nFirstPersonalityImage;

	CTypedPtrList<CPtrList, CPersonality*> m_lstPersonalities;
};

#endif // __PERSONALITYCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityCtl.h ===
#if !defined(AFX_PERSONALITYCTL_H__D433F96C_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_PERSONALITYCTL_H__D433F96C_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_

#ifndef	__PERSONALITYCTL_H__
#define	__PERSONALITYCTL_H__
//#include "Personality.h"
#include "Splitter.h"
#include "ChordDialog.h"

#include "SignPostDialog.h"
class CSignPostDialog;

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// PersonalityCtl.h : Declaration of the CPersonalityCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl : See PersonalityCtl.cpp for implementation.

class CPersonalityCtrl : public COleControl
{
	friend CSignPostDialog;	// Declare CSignPostDialog as friend so static member (m_SignPostDialog) can resolve private IUnknown methods.

	DECLARE_DYNCREATE(CPersonalityCtrl)

private:
	CSplitter	m_wndSplitter;
	HWND		m_hWndContainer;
	HMENU		m_hMenuInPlace;
	CToolBar*	m_pToolBar;
	HACCEL					m_hAcceleratorTable;

	int			m_OnSizeCount;	// incremented first two times goes through OnSize, determines when
								// real size of window is determined. TODO: replace this with something more robust

// Constructor
public:
	CPersonalityCtrl();
	enum {DefaultSplitterWidth=6, MinSplitterXPos = 300, ChordMap, SignPost };
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonalityCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

public:
//	CPersonalityDlg *m_pPersonalityDlg;
//	PersonalityFrameWnd *m_pFrameWindow;
	void EndTrack( int nWidth );

	void SetLastFocus(int obj)
	{
		if(obj == ChordMap)
		{
			m_pdlgLastFocus = &m_ChordDialog;
		}
		else if(obj == SignPost)
		{
			m_pdlgLastFocus = &m_SignPostDialog;
			m_ChordDialog.ClearSelections();
		}
		else
		{
			m_pdlgLastFocus = 0;
		}
	}

private:
	CPersonality	*m_pPersonality;
	CSignPostDialog	m_SignPostDialog;
	CChordDialog	m_ChordDialog;
	CDialog*		m_pdlgLastFocus;

// Implementation
protected:
	~CPersonalityCtrl();

	BOOL EditAvailable(WPARAM wId);
	void SendEdit(WPARAM wId);
	void SendEditToTimeline(WPARAM wId);
	BOOL TimelineEditAvailable(WPARAM wId);
	void SendEditToSignPost(WPARAM wId);
	BOOL SignPostEditAvailable(WPARAM wId);

	DECLARE_OLECREATE_EX(CPersonalityCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CPersonalityCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CPersonalityCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CPersonalityCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CPersonalityCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void AboutBox();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnCut();
	afx_msg void OnUpdateCut(CCmdUI* pCmdUI);
	afx_msg void OnDelete();
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnInsert();
	afx_msg void OnUpdateInsert(CCmdUI* pCmdUI);
	afx_msg void OnSelectall();
	afx_msg void OnUpdateSelectall(CCmdUI* pCmdUI);
	afx_msg void OnProperties();
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDiatonic();
	afx_msg void OnUpdateDiatonic(CCmdUI* pCmdUI);
	afx_msg void OnDom7ths();
	afx_msg void OnUpdateDom7ths(CCmdUI* pCmdUI);
	afx_msg void OnMajor7ths();
	afx_msg void OnUpdateMajor7ths(CCmdUI* pCmdUI);
	afx_msg void OnMinor7ths();
	afx_msg void OnUpdateMinor7ths(CCmdUI* pCmdUI);
	afx_msg void OnAllmajor();
	afx_msg void OnUpdateAllmajor(CCmdUI* pCmdUI);
	afx_msg void OnAllminor();
	afx_msg void OnUpdateAllminor(CCmdUI* pCmdUI);
	afx_msg void OnDiatonictriad();
	afx_msg void OnUpdateDiatonictriad(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	afx_msg void OnEditCut();
	afx_msg void OnEditSelectAll();
	afx_msg void OnUndo();
	afx_msg void OnUpdateUndo(CCmdUI* pCmdUI);
	afx_msg void OnRedo();
	afx_msg void OnUpdateRedo(CCmdUI* pCmdUI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHelpFinder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CPersonalityCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CPersonalityCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CPersonalityCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};



#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALITYCTL_H__D433F96C_B588_11D0_9EDC_00AA00A21BA9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDesigner.h ===
#if !defined(AFX_PERSONALITYDESIGNER_H__D433F964_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_PERSONALITYDESIGNER_H__D433F964_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// PersonalityDesigner.h : main header file for PERSONALITYDESIGNER.DLL
#define RELEASE(x) if( (x) ) (x)->Release()

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "DMUSProd.h"
#include "dmusici.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "StyleDesigner.h"
#include "ChordMapDesigner.h"


/////////////////////////////////////////////////////////////////////////////
// DLL externs
//

#ifdef __cplusplus
extern "C"{
#endif 

extern const CLSID CLSID_PersonalityPropPage;

#ifdef __cplusplus
}
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256
#define TOOLBAR_HEIGHT	30
#define WM_MYPROPVERB	WM_USER+1267 

#define MAX_LENGTH_PERSONALITYUSER_NAME	19	// excluding NULL (NULL makes 20)


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDesignerApp : See PersonalityDesigner.cpp for implementation.

class CPersonalityDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
};

extern CPersonalityDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALITYDESIGNER_H__D433F964_B588_11D0_9EDC_00AA00A21BA9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityCtl.cpp ===
// PersonalityCtl.cpp : Implementation of the CPersonalityCtrl ActiveX Control class.

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "PersonalityCtl.h"
#include "PersonalityPpg.h"
#include "chordbuilder.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif





IMPLEMENT_DYNCREATE(CPersonalityCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CPersonalityCtrl, COleControl)
	//{{AFX_MSG_MAP(CPersonalityCtrl)
	ON_WM_CREATE()
	ON_WM_SETCURSOR()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_SETFOCUS()
	ON_WM_GETMINMAXINFO()
	ON_COMMAND(ID_CUT, OnCut)
	ON_UPDATE_COMMAND_UI(ID_CUT, OnUpdateCut)
	ON_COMMAND(ID_DELETE, OnDelete)
	ON_UPDATE_COMMAND_UI(ID_DELETE, OnUpdateDelete)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_INSERT, OnInsert)
	ON_UPDATE_COMMAND_UI(ID_INSERT, OnUpdateInsert)
	ON_COMMAND(ID_SELECTALL, OnSelectall)
	ON_UPDATE_COMMAND_UI(ID_SELECTALL, OnUpdateSelectall)
	ON_COMMAND(ID_PROPERTIES, OnProperties)
	ON_UPDATE_COMMAND_UI(ID_PROPERTIES, OnUpdateProperties)
	ON_WM_ERASEBKGND()
	ON_COMMAND(ID_DIATONIC, OnDiatonic)
	ON_UPDATE_COMMAND_UI(ID_DIATONIC, OnUpdateDiatonic)
	ON_COMMAND(ID_DOM7THS, OnDom7ths)
	ON_UPDATE_COMMAND_UI(ID_DOM7THS, OnUpdateDom7ths)
	ON_COMMAND(ID_MAJOR7THS, OnMajor7ths)
	ON_UPDATE_COMMAND_UI(ID_MAJOR7THS, OnUpdateMajor7ths)
	ON_COMMAND(ID_MINOR7THS, OnMinor7ths)
	ON_UPDATE_COMMAND_UI(ID_MINOR7THS, OnUpdateMinor7ths)
	ON_COMMAND(ID_ALLMAJOR, OnAllmajor)
	ON_UPDATE_COMMAND_UI(ID_ALLMAJOR, OnUpdateAllmajor)
	ON_COMMAND(ID_ALLMINOR, OnAllminor)
	ON_UPDATE_COMMAND_UI(ID_ALLMINOR, OnUpdateAllminor)
	ON_COMMAND(ID_DIATONICTRIAD, OnDiatonictriad)
	ON_UPDATE_COMMAND_UI(ID_DIATONICTRIAD, OnUpdateDiatonictriad)
	ON_WM_DESTROY()
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_COMMAND(ID_UNDO, OnUndo)
	ON_UPDATE_COMMAND_UI(ID_UNDO, OnUpdateUndo)
	ON_COMMAND(ID_REDO, OnRedo)
	ON_UPDATE_COMMAND_UI(ID_REDO, OnUpdateRedo)
	ON_WM_SIZE()
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CPersonalityCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CPersonalityCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CPersonalityCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CPersonalityCtrl, COleControl)
	//{{AFX_EVENT_MAP(CPersonalityCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl Interface map

BEGIN_INTERFACE_MAP(CPersonalityCtrl, COleControl)
    INTERFACE_PART(CPersonalityCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CPersonalityCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CPersonalityCtrl, 1)
	PROPPAGEID(CPersonalityPropPage::guid)
END_PROPPAGEIDS(CPersonalityCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CPersonalityCtrl, "CHORDMAPDESR.ChordMapCtrl.1",
	0xd433f95e, 0xb588, 0x11d0, 0x9e, 0xdc, 0, 0xaa, 0, 0xa2, 0x1b, 0xa9)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CPersonalityCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DPersonality =
		{ 0xd433f95c, 0xb588, 0x11d0, { 0x9e, 0xdc, 0, 0xaa, 0, 0xa2, 0x1b, 0xa9 } };
const IID BASED_CODE IID_DPersonalityEvents =
		{ 0xd433f95d, 0xb588, 0x11d0, { 0x9e, 0xdc, 0, 0xaa, 0, 0xa2, 0x1b, 0xa9 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwPersonalityOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CPersonalityCtrl, IDS_PERSONALITY, _dwPersonalityOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::CPersonalityCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CPersonalityCtrl

BOOL CPersonalityCtrl::CPersonalityCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_PERSONALITY,
			IDB_PERSONALITY,
			afxRegApartmentThreading,
			_dwPersonalityOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::CPersonalityCtrl - Constructor

CPersonalityCtrl::CPersonalityCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DPersonality, &IID_DPersonalityEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DPersonality;
	m_piidEvents = &IID_DPersonalityEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_pToolBar = NULL;
	m_pdlgLastFocus = NULL;

	m_OnSizeCount = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::~CPersonalityCtrl - Destructor

CPersonalityCtrl::~CPersonalityCtrl()
{
	TRACE( "CPersonalityCtrl destroying...\n" );

	RELEASE( m_pPersonality );
	if( m_pToolBar )
	{
		delete m_pToolBar;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CPersonalityCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CPersonalityCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CPersonalityCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CPersonalityCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::QueryInterface

STDMETHODIMP CPersonalityCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CPersonalityCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::AttachObjects

HRESULT CPersonalityCtrl::XEditor::AttachObjects( IDMUSProdNode* pNode )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	GUID guidNode;

	pNode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_PersonalityRefNode ) )
	{
		CPersonalityRef* pPersonalityRef = (CPersonalityRef *)pNode;
		ASSERT( pPersonalityRef->m_pPersonality != NULL );
		pThis->m_pPersonality = pPersonalityRef->m_pPersonality;
	}
	else
	{
		pThis->m_pPersonality = (CPersonality *)pNode;
	}

	ASSERT( pThis->m_pPersonality != NULL );
	pThis->m_pPersonality->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::OnInitMenuFilePrint

HRESULT CPersonalityCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::OnFilePrint

HRESULT CPersonalityCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CPersonalityCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::OnFilePrintPreview

HRESULT CPersonalityCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	return E_NOTIMPL;
}


HRESULT CPersonalityCtrl::XEditor::OnViewProperties( )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pPersonality )
	{
		ASSERT(pThis->m_pPersonality->m_pComponent != NULL);
		ASSERT( pThis->m_pPersonality->m_pComponent->m_pIFramework != NULL );
		IDMUSProdNode* pINode = (IDMUSProdNode *)pThis->m_pPersonality;
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( pThis->m_pPersonality->m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				IDMUSProdPropPageObject* pIPageObject;

				if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
				{
					if( SUCCEEDED ( pIPageObject->OnShowProperties() ) )
					{
						hr = S_OK;
					}
					pIPageObject->Release();
				}
			}
			else
			{
				hr = S_OK;
			}

			pIPropSheet->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XEditor::OnF1Help

HRESULT CPersonalityCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/ChordmapDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CPersonalityCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CPersonalityCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CPersonalityCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CPersonalityCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::OnDraw - Drawing function

void CPersonalityCtrl::OnDraw(
			CDC* /*pdc*/, const CRect& /*rcBounds*/, const CRect& /*rcInvalid*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::DoPropExchange - Persistence support

void CPersonalityCtrl::DoPropExchange(CPropExchange* pPX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::OnResetState - Reset control to default state

void CPersonalityCtrl::OnResetState()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl::AboutBox - Display an "About" box to the user

#include "PersonalityAbout.h"
void CPersonalityCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPersonalityAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityCtrl message handlers

int CPersonalityCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PERSONALITY_OPTIONS) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1) );

	// Create control's toolbar
	CWnd* pWndParent = CWnd::FromHandle( m_hWndContainer );
	if( pWndParent )
	{
		/* to display toolbar, uncomment this code
		m_pToolBar = new CToolBar;
		m_pToolBar->Create( pWndParent );
		m_pToolBar->LoadToolBar( IDR_PERSONALITY_OPTIONS );
		m_pToolBar->SetBarStyle( m_pToolBar->GetBarStyle() | CBRS_SIZE_DYNAMIC );
		m_pToolBar->SetOwner( this );
		*/
	}

	// Create the Splitter and position it in the Editor
	// (temporary values added until coords are saved to design-time file)
	RECT rect;
	GetClientRect(&rect);
//	rect.left = MinSplitterXPos*2;
//	rect.right = rect.left + 6;
	rect.left = lpCreateStruct->cx;
	rect.right = rect.left + DefaultSplitterWidth;
	rect.bottom = lpCreateStruct->cy;
	rect.top = lpCreateStruct->y;

	m_wndSplitter.Create( (CWnd*)this, &rect );

	// Create the ChordWindow and position it in the First Splitter Pane.
	m_ChordDialog.InitializeDialog( m_pPersonality, this );
	m_ChordDialog.Create( IDD_CHORD_DIALOG, this );
	m_ChordDialog.ShowWindow( SW_SHOW );
	m_wndSplitter.SetFirstPane( &m_ChordDialog );

	// Initialize the SignPostDialog's SignPost Grid.
	m_SignPostDialog.SetSignPostListPtr( m_pPersonality->GetSignPostListPtr() );

	// Create the SignPost Window and position it in the Second Splitter Pane.
	m_SignPostDialog.InitializeDialog( &m_ChordDialog, m_pPersonality, this );
	m_SignPostDialog.Create( IDD_SIGNPOST_DIALOG, this );
	m_SignPostDialog.ShowWindow( SW_SHOW );
	m_wndSplitter.SetSecondPane( &m_SignPostDialog );

	// set up chord map to personality's length and timesig
	m_pPersonality->ChangeChordSignPostTimeSig();
	m_pPersonality->ChangeChordMapLength();


	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame::EndTrack

void CPersonalityCtrl::EndTrack( int nWidth )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RECT rect;

	// tell personality the new position
	m_pPersonality->SetSplitterPos(nWidth);

	GetWindowRect( &rect );
	CalcWindowRect( &rect );


//	RecalcLayout();
}

BOOL CPersonalityCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (pWnd == this)?CWnd::OnSetCursor(pWnd, nHitTest, message):FALSE;
}



HMENU CPersonalityCtrl::OnGetInPlaceMenu() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_hMenuInPlace;
}


////////////////////////////////////////////////
void CPersonalityCtrl::OnHideToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPersonality != NULL );
	ASSERT( m_pPersonality->m_pComponent != NULL );

	if( m_pToolBar )
	{
		BORDERWIDTHS border;

		border.top = 0;
		border.left = 0;
		border.right = 0;
		border.bottom = 0;

		if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
		{
			m_pInPlaceFrame->SetBorderSpace( &border );
			m_pToolBar->ShowWindow( SW_HIDE );
			return;
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}

void CPersonalityCtrl::OnShowToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BORDERWIDTHS border;
	CRect rectBorder;

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	// Show the ToolBar
	if( m_pToolBar )
	{
		if( SUCCEEDED ( m_pInPlaceFrame->GetBorder(&rectBorder) ) )
		{
			border.top = TOOLBAR_HEIGHT;
			border.left = 0;
			border.right = 0;
			border.bottom = 0;

			if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
			{
				m_pInPlaceFrame->SetBorderSpace( &border );

				m_pToolBar->MoveWindow( rectBorder.left,
										rectBorder.top,
										rectBorder.Width(),
										TOOLBAR_HEIGHT );
				m_pToolBar->ShowWindow( SW_SHOWNORMAL );
				return;
			}
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}

void CPersonalityCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSetFocus(pOldWnd);

	IDMUSProdNode* pNode;
	IDMUSProdConductor* pConductor;

	if(SUCCEEDED(m_pPersonality->GetDocRootNode(&pNode)))
	{
		if(SUCCEEDED(m_pPersonality->m_pComponent->GetConductor(&pConductor)))
		{
			IDMUSProdTransport* pTransport;
			if(SUCCEEDED(pNode->QueryInterface(IID_IDMUSProdTransport, (void**)&pTransport)))
			{
				pConductor->SetActiveTransport(pTransport , NULL );
				pTransport->Release();
			}
			pConductor->Release();
		}
		else
		{
			ASSERT(FALSE);
		}
		pNode->Release();
	}
	else
	{
		ASSERT(FALSE);
	}
	
	if(m_pdlgLastFocus == NULL || m_pdlgLastFocus == &m_ChordDialog)
	{
		// Set the focus to the timeline
		IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
		m_ChordDialog.m_pITimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
		if (pIOleInPlaceObjectWindowless)
		{
			HWND hwnd;
			if (pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK)
			{
				::SetFocus(hwnd);
			}
			pIOleInPlaceObjectWindowless->Release();
		}
	}
	else
	{
		::SetFocus(m_SignPostDialog.m_hWnd);
	}
	// if null and a style has been added, this should set it.
	m_pPersonality->InitializeStyleReference();
}


void CPersonalityCtrl::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) 
{
	// TODO: Add your message handler code here and/or call default
	
	COleControl::OnGetMinMaxInfo(lpMMI);
}


void CPersonalityCtrl::OnCut() 
{
	SendEdit(ID_CUT);	
}

void CPersonalityCtrl::OnUpdateCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_CUT));	
	
}

void CPersonalityCtrl::OnDelete() 
{
	SendEdit(ID_DELETE);
}

void CPersonalityCtrl::OnUpdateDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_DELETE));
	
}

void CPersonalityCtrl::OnEditCopy() 
{
	SendEdit(ID_EDIT_COPY);	
}

void CPersonalityCtrl::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_EDIT_COPY));
	
}

void CPersonalityCtrl::OnEditPaste() 
{
	SendEdit(ID_EDIT_PASTE);	
}

void CPersonalityCtrl::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_EDIT_PASTE));
	
}



void CPersonalityCtrl::OnInsert() 
{
	SendEdit(ID_INSERT);
}

void CPersonalityCtrl::OnUpdateInsert(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_INSERT));
	
}

void CPersonalityCtrl::OnSelectall() 
{
	SendEdit(ID_SELECTALL);	
}

void CPersonalityCtrl::OnUpdateSelectall(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(EditAvailable(ID_SELECTALL));	
}

void CPersonalityCtrl::OnProperties() 
{
	m_xEditor.OnViewProperties();	
}

void CPersonalityCtrl::OnUpdateProperties(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
		
}

BOOL CPersonalityCtrl::EditAvailable(WPARAM wId)
{
	if(m_pdlgLastFocus == &m_ChordDialog)
	{
		return TimelineEditAvailable(wId);
	}
	else if(m_pdlgLastFocus == &m_SignPostDialog)
	{
		return SignPostEditAvailable(wId);
	}
	else
	{
		m_pdlgLastFocus = &m_ChordDialog;
		return TimelineEditAvailable(wId);
	}
}

void CPersonalityCtrl::SendEdit(WPARAM wId)
{
	if(m_pdlgLastFocus == &m_ChordDialog)
	{
		SendEditToTimeline(wId);
	}
	else if(m_pdlgLastFocus == &m_SignPostDialog)
	{
		SendEditToSignPost(wId);
	}
	else
	{
		m_pdlgLastFocus = &m_ChordDialog;
		SendEditToTimeline(wId);
	}
}

void CPersonalityCtrl::SendEditToTimeline(WPARAM wId)
{
	HRESULT			hr = S_OK;
	BOOL			bAvailable = FALSE;
	IDMUSProdTimelineEdit	*pITimelineEdit;
	if(m_ChordDialog.m_pITimeline != NULL)
	{
		if(SUCCEEDED(m_ChordDialog.m_pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
		{
			bAvailable = TimelineEditAvailable(wId);
			ASSERT(bAvailable);
			if(bAvailable)
			{
				switch(wId)
				{
				case ID_CUT:
				case ID_EDIT_CUT:
					hr = pITimelineEdit->Cut(NULL);
					break;
				case ID_EDIT_COPY:
					hr = pITimelineEdit->Copy(NULL);
					break;
				case ID_EDIT_PASTE:
					hr = pITimelineEdit->Paste(NULL);
					break;
				case ID_INSERT:
					hr = pITimelineEdit->Insert();
					break;
				case ID_DELETE:
					hr = pITimelineEdit->Delete();
					break;
				case ID_SELECTALL:
				case ID_EDIT_SELECT_ALL:
					hr = pITimelineEdit->SelectAll();
					break;
				default:
					break;
				}
			}
			pITimelineEdit->Release();
		}
	}

//	ASSERT(SUCCEEDED(hr) || hr == E_NOTIMPL || hr == E_UNEXPECTED);
}

BOOL CPersonalityCtrl::TimelineEditAvailable(WPARAM wId)
{
	HRESULT					hr = S_OK;
	IDMUSProdTimelineEdit	*pITimelineEdit;

	if(m_ChordDialog.m_pITimeline != NULL)
	{
		if(SUCCEEDED(m_ChordDialog.m_pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
		{
			switch(wId)
			{
			case ID_CUT:
			case ID_EDIT_CUT:
				hr = pITimelineEdit->CanCut();
				break;
			case ID_EDIT_COPY:
				hr = pITimelineEdit->CanCopy();
				break;
			case ID_EDIT_PASTE:
				hr = pITimelineEdit->CanPaste(NULL);
//				hr = S_FALSE;	// because we don't know where the mouse is				
				break;
			case ID_INSERT:
				hr = pITimelineEdit->CanInsert();
//				hr = S_FALSE;	// because we don't know where the mouse is				
				break;
			case ID_DELETE:
				hr = pITimelineEdit->CanDelete();
				break;
			case ID_SELECTALL:
			case ID_EDIT_SELECT_ALL:
				hr = pITimelineEdit->CanSelectAll();
				break;
			default:
				hr = S_FALSE;
			}
			pITimelineEdit->Release();
		}
		if(hr == S_OK)
		{
			return TRUE;
		}
	}
	return FALSE;
}


void CPersonalityCtrl::SendEditToSignPost(WPARAM wId)
{
	HRESULT			hr = S_OK;
	BOOL			bAvailable = FALSE;
	bAvailable = SignPostEditAvailable(wId);
	ASSERT(bAvailable);
	if(bAvailable)
	{
		switch(wId)
		{
		case ID_CUT:
			hr = m_SignPostDialog.Cut(NULL);
			break;
		case ID_EDIT_COPY:
			hr = m_SignPostDialog.Copy(NULL);
			break;
		case ID_EDIT_PASTE:
			hr = m_SignPostDialog.Paste(NULL);
			break;
		case ID_INSERT:
			hr = m_SignPostDialog.Insert(NULL);
			break;
		case ID_DELETE:
			hr = m_SignPostDialog.Delete();
			break;
		case ID_SELECTALL:
			hr = m_SignPostDialog.SelectAll();
			break;
		default:
			break;
		}
	}

	ASSERT(SUCCEEDED(hr) || hr == E_NOTIMPL);
}

BOOL CPersonalityCtrl::SignPostEditAvailable(WPARAM wId)
{
	HRESULT			hr;

	switch(wId)
	{
	case ID_CUT:
		hr = m_SignPostDialog.CanCut();
		break;
	case ID_EDIT_COPY:
		hr = m_SignPostDialog.CanCopy();
		break;
	case ID_EDIT_PASTE:
		hr = m_SignPostDialog.CanPaste();
		break;
	case ID_INSERT:
		hr = m_SignPostDialog.CanInsert();
		break;
	case ID_DELETE:
		hr = m_SignPostDialog.CanDelete();
		break;
	case ID_SELECTALL:
		hr = S_FALSE;	// this assumes knowledge of signpost
		break;
	default:
		hr = S_FALSE;
	}
	if(hr == S_OK)
	{
		return TRUE;
	}
	return FALSE;
}




BOOL CPersonalityCtrl::OnEraseBkgnd(CDC* pDC) 
{
	UNREFERENCED_PARAMETER(pDC);
	return FALSE;
}

void CPersonalityCtrl::OnDiatonic() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	Personality* pPersonality = m_pPersonality->GetPersonality();
	long lScalePattern = Rotate24( pPersonality->m_scalepattern, m_pPersonality->GetAbsKey() );
	ChordBuilder cb(lScalePattern, ChordBuilder::Seventh, m_pPersonality->GetAbsKey());
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::Seventh;
	m_ChordDialog.m_pITimeline->Refresh();
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);	
}

void CPersonalityCtrl::OnUpdateDiatonic(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}

void CPersonalityCtrl::OnDom7ths() 
{
	Personality* pPersonality = m_pPersonality->GetPersonality();
	ChordBuilder cb(0x000491, "7");
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::AllDom7;
	m_ChordDialog.m_pITimeline->Refresh();	
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);	
}

void CPersonalityCtrl::OnUpdateDom7ths(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}

void CPersonalityCtrl::OnMajor7ths() 
{
	Personality* pPersonality = m_pPersonality->GetPersonality();
	ChordBuilder cb(0x000891, "maj7");
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::AllMaj7;
	m_ChordDialog.m_pITimeline->Refresh();	
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);		
}

void CPersonalityCtrl::OnUpdateMajor7ths(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}

void CPersonalityCtrl::OnMinor7ths() 
{
	Personality* pPersonality = m_pPersonality->GetPersonality();
	ChordBuilder cb(0x000489, "min7");
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::AllMin7;
	m_ChordDialog.m_pITimeline->Refresh();	
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);	
}

void CPersonalityCtrl::OnUpdateMinor7ths(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}

void CPersonalityCtrl::OnAllmajor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	Personality* pPersonality = m_pPersonality->GetPersonality();
	ChordBuilder cb(0x000091, "maj");
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::AllMaj;
	m_ChordDialog.m_pITimeline->Refresh();	
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
}

void CPersonalityCtrl::OnUpdateAllmajor(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}

void CPersonalityCtrl::OnAllminor() 
{
	Personality* pPersonality = m_pPersonality->GetPersonality();
	ChordBuilder cb(0x000089, "min");
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::AllMin;
	m_ChordDialog.m_pITimeline->Refresh();	
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);	
}

void CPersonalityCtrl::OnUpdateAllminor(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
	
}


void CPersonalityCtrl::OnDiatonictriad() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	Personality* pPersonality = m_pPersonality->GetPersonality();
	long lScalePattern = Rotate24( pPersonality->m_scalepattern, m_pPersonality->GetAbsKey() );
	ChordBuilder cb(lScalePattern, ChordBuilder::Triad, m_pPersonality->GetAbsKey());
	for(int i = 0; i < 24; i++)
	{
		strcpy(pPersonality->m_chordpalette.m_chords[i].Name(), cb.ChordName(i));
		for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
		{
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ChordPattern() = cb.ChordPattern(i);
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScalePattern() = pPersonality->m_scalepattern;
			pPersonality->m_chordpalette.m_chords[i].SubChord(j)->ScaleRoot() = (BYTE)m_pPersonality->GetAbsKey();
		}
	}
	m_pPersonality->PaletteChordType() = ChordBuilder::Triad;	
	m_ChordDialog.m_pITimeline->Refresh();
	m_pPersonality->Modified() = TRUE;
	m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
}

void CPersonalityCtrl::OnUpdateDiatonictriad(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	pCmdUI->Enable(TRUE);
}

void CPersonalityCtrl::OnDestroy() 
{
	COleControl::OnDestroy();
	
	if( m_hMenuInPlace )
	{
		::DestroyMenu(m_hMenuInPlace);
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}
	
}

BOOL CPersonalityCtrl::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::TranslateAccelerator(m_hWnd, m_hAcceleratorTable, pMsg);
	
	return COleControl::PreTranslateMessage(pMsg);
}

void CPersonalityCtrl::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(EditAvailable(ID_EDIT_CUT))
		SendEdit(ID_EDIT_CUT);	
}

void CPersonalityCtrl::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(EditAvailable(ID_EDIT_SELECT_ALL))
		SendEdit(ID_EDIT_SELECT_ALL);	
	
}

void CPersonalityCtrl::OnUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pPersonality != NULL);
	TCHAR tbuf[256];
	if(m_pPersonality != NULL)
	{
		ASSERT(m_pPersonality->m_pUndoMgr != NULL);
		if(m_pPersonality->m_pUndoMgr != NULL && m_pPersonality->m_pUndoMgr->GetUndo(tbuf, 256))
		{
			HWND hwnd = ::GetFocus();

			CString person, chord, signpost, ins, del, cut, paste, str, length, timesig;
			person.LoadString(IDS_PERSONALITYUNDO_HEADER);
			chord.LoadString(IDS_CHORDMAPUNDO_HEADER);
			signpost.LoadString(IDS_SIGNPOSTUNDO_HEADER);
			ins.LoadString(IDS_INSERT_UNDO);
			del.LoadString(IDS_DELETE_UNDO);
			cut.LoadString(IDS_CUT_UNDO);
			paste.LoadString(IDS_PASTE_UNDO);
			length.LoadString(IDS_UNDO_CHORDMAPLENGTH);
			timesig.LoadString(IDS_UNDO_TIMESIG);
			str = tbuf;
			
			m_pPersonality->m_pUndoMgr->Undo(m_pPersonality);
			
			m_pPersonality->RefreshProperties();

			if(!_strnicmp(chord, tbuf, chord.GetLength()) && 
				( (str.Find(ins) > -1) || (str.Find(cut) > -1) || (str.Find(del) > -1) || (str.Find(paste) > -1))) 
			{
				m_ChordDialog.Refresh(true);
			}
			else if(str.Find(timesig) > -1)
			{
				m_pPersonality->ChangeChordSignPostTimeSig();
				m_pPersonality->ComputeChordMap();
//				m_ChordDialog.Refresh(true);
			}
			else if(str.Find(length) > -1)
			{
				m_pPersonality->ChangeChordMapLength();
				m_pPersonality->m_pComponent->m_pIFramework->RefreshNode( (IDMUSProdNode*)m_pPersonality );
//				m_ChordDialog.Refresh(false);
//				m_pPersonality->Modified() = TRUE;
//				return;
			}
			else
			{
				m_ChordDialog.Refresh(false);
			}

			if((str.Find(signpost) > -1) && 
				( (str.Find(ins) > -1) || (str.Find(del) > -1) || (str.Find(cut) > -1) || (str.Find(paste) > -1) ) )
			{
				m_pPersonality->LinkAll(true);
				m_SignPostDialog.Refresh(true);
			}
			else if(str.Find(signpost) > -1)
			{
				m_SignPostDialog.Refresh(false);
			}
			else
			{
				m_SignPostDialog.Refresh(false);
			}

			m_pPersonality->OnNameChange();
			m_pPersonality->m_pComponent->m_pIFramework->RefreshNode( (IDMUSProdNode*)m_pPersonality );
			m_pPersonality->Modified() = TRUE;
			::SetFocus(hwnd);
		}
	}	
}

void CPersonalityCtrl::OnUpdateUndo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pPersonality != NULL);
	TCHAR tbuf[256];
	
	if(m_pPersonality != NULL)
	{
		ASSERT(m_pPersonality->m_pUndoMgr != NULL);
		if(m_pPersonality->m_pUndoMgr != NULL)
		{
			if(m_pPersonality->m_pUndoMgr->GetUndo(tbuf, 256))
			{
				CString str,str1;
				str.LoadString(IDS_UNDO);
				str1.LoadString(IDS_UNDOACCEL);
				if(*tbuf)
				{
					str += " ";
					str += tbuf;
				}
				str += str1;
				pCmdUI->SetText(str);
				pCmdUI->Enable(TRUE);
				return;
			}
		}
	}
	pCmdUI->Enable(FALSE);
}

void CPersonalityCtrl::OnRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pPersonality != NULL);
	TCHAR tbuf[256];
	if(m_pPersonality != NULL)
	{
		ASSERT(m_pPersonality->m_pUndoMgr != NULL);
		if(m_pPersonality->m_pUndoMgr != NULL && m_pPersonality->m_pUndoMgr->GetRedo(tbuf, 256))
		{
			HWND hwnd = ::GetFocus();
			CString person, chord, signpost, ins, del, cut, paste, str, length, timesig;
			person.LoadString(IDS_PERSONALITYUNDO_HEADER);
			chord.LoadString(IDS_CHORDMAPUNDO_HEADER);
			signpost.LoadString(IDS_SIGNPOSTUNDO_HEADER);
			ins.LoadString(IDS_INSERT_UNDO);
			del.LoadString(IDS_DELETE_UNDO);
			cut.LoadString(IDS_CUT_UNDO);
			paste.LoadString(IDS_PASTE_UNDO);
			length.LoadString(IDS_UNDO_CHORDMAPLENGTH);
			timesig.LoadString(IDS_UNDO_TIMESIG);
			str = tbuf;

			m_pPersonality->m_pUndoMgr->Redo(m_pPersonality);

			m_pPersonality->RefreshProperties();

			if(!_strnicmp(chord, tbuf, chord.GetLength()) && 
				( (str.Find(ins) > -1) || (str.Find(cut) > -1) || (str.Find(del) > -1) || (str.Find(paste) > -1))) 
			{
				m_ChordDialog.Refresh(true);
			}
			else if(str.Find(timesig) > -1)
			{
				m_pPersonality->ChangeChordSignPostTimeSig();
				m_pPersonality->ComputeChordMap();
//				m_ChordDialog.Refresh(true);
			}
			else if(str.Find(length) > -1)
			{
				m_pPersonality->ChangeChordMapLength();
//				m_ChordDialog.Refresh(true);
			}
			else
			{
				m_ChordDialog.Refresh(false);
			}

			if((str.Find(signpost) > -1) && 
				( (str.Find(ins) > -1) || (str.Find(del) > -1) || (str.Find(cut) > -1) || (str.Find(paste) > -1) ) )
			{
				m_pPersonality->LinkAll(true);
				m_SignPostDialog.Refresh(true);
			}
			else if(str.Find(signpost) > -1)
			{
				m_SignPostDialog.Refresh(false);
			}
			else
			{
				m_SignPostDialog.Refresh(false);
			}

		// Update the Project Node.
			m_pPersonality->OnNameChange();
			m_pPersonality->m_pComponent->m_pIFramework->RefreshNode( (IDMUSProdNode*)m_pPersonality );
			m_pPersonality->Modified() = TRUE;
			::SetFocus(hwnd);
		}
	}	
}

void CPersonalityCtrl::OnUpdateRedo(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pPersonality != NULL);
	TCHAR tbuf[256];
	if(m_pPersonality != NULL)
	{
		ASSERT(m_pPersonality->m_pUndoMgr != NULL);
		if(m_pPersonality->m_pUndoMgr != NULL)
		{
			if(m_pPersonality->m_pUndoMgr->GetRedo(tbuf, 256))
			{
				CString str,str1;
				str.LoadString(IDS_REDO);
				str1.LoadString(IDS_REDOACCEL);
				if(*tbuf)
				{
					str += " ";
					str += tbuf;
				}
				str += str1;
				pCmdUI->SetText(str);
				pCmdUI->Enable(TRUE);
				return;
			}
		}
	}
	pCmdUI->Enable(FALSE);
}

void CPersonalityCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);
	if(m_OnSizeCount == 1)
	{
		// get splitter position from personality
		WORD pos = m_pPersonality->GetSplitterPos();
		// calculate where splitter should be
		if(pos == 0)
		{
			// put it right in the middle
			pos = (cx - DefaultSplitterWidth)/2;
			// tell personality where it is so it can save it
			m_pPersonality->SetSplitterPos(pos, false);
		}
		// splitter is right side of chord dialog and left side
		// of signpost dialog
		RECT rect;
		GetClientRect(&rect);
		MoveWindow(0,0,cx,cy);
		rect.left = pos;
		rect.right = rect.left + DefaultSplitterWidth;
		m_wndSplitter.SetTracker(rect);
		m_ChordDialog.MoveWindow(0,0,pos, rect.bottom);
		m_SignPostDialog.MoveWindow(rect.right, 0, cx - rect.right, rect.bottom);
//		m_ChordDialog.OnSize(nType, pos, rect.bottom);
//		m_SignPostDialog.OnSize(nType, rect.right - (pos + DefaultSplitterWidth), rect.bottom);
	}
	else if(m_OnSizeCount == 0)
	{
		++m_OnSizeCount;
	}
}

void CPersonalityCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDocType.cpp ===
// PersonalityDocType.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "Personality.h"
#include <mmsystem.h>
#include <mmreg.h>
#pragma warning(default:4201)

#include "PersonalityRIFF.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType constructor/destructor

CPersonalityDocType::CPersonalityDocType()
{
}

CPersonalityDocType::CPersonalityDocType( CPersonalityComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;

	m_pComponent = pComponent;
//  m_pComponent->AddRef() intentionally missing
}

CPersonalityDocType::~CPersonalityDocType()
{
}

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType IUnknown implementation

HRESULT CPersonalityDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType8)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CPersonalityDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CPersonalityDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

	if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::GetResourceId

HRESULT CPersonalityDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_PERSONALITY_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::DoesExtensionMatch

HRESULT CPersonalityDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_PERSONALITY_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::DoesIdMatch

HRESULT CPersonalityDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_PersonalityNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::AllocNode

HRESULT STDMETHODCALLTYPE CPersonalityDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	HRESULT hr;

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_PersonalityNode) == FALSE )
	{
		return E_INVALIDARG ;
	}

	// Create a new Personality
	CPersonality* pIPersonality = new CPersonality( m_pComponent );
	if( pIPersonality == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	hr = pIPersonality->Initialize();

	*ppINode = (IDMUSProdNode *)pIPersonality;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::OnFileNew

HRESULT CPersonalityDocType::OnFileNew( IDMUSProdProject* /*pITargetProject*/, IDMUSProdNode* /*pITargetDirectoryNode*/,
										IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	IDMUSProdNode* pIPersonalityNode=NULL;
	HRESULT hr = E_FAIL;

	if( ppIDocRootNode == NULL )
	{
		hr = E_POINTER; goto Leave;
	}

	*ppIDocRootNode = NULL;

	// Create a new Personality 
	if( FAILED(hr = AllocNode( GUID_PersonalityNode, &pIPersonalityNode )) )
	{
		goto Leave;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIPersonalityNode, pIPersonalityNode, NULL );

	// Add node to Project Tree
	if( FAILED(hr = m_pComponent->m_pIFramework->AddNode(pIPersonalityNode, NULL)) )
	{
		goto Leave;
	}

	// Initialize the ChordMapMgr and ChordMapStrip
	((CPersonality*)pIPersonalityNode)->SendChordMapAndPaletteToChordMapMgr();

	// Advise the ConnectionPoint for this CSection and register the
	// CSection in the Transport.
	((CPersonality*)pIPersonalityNode)->AdviseConnectionPoint();

	m_pComponent->AddToPersonalityFileList( (CPersonality *)pIPersonalityNode );
	*ppIDocRootNode = pIPersonalityNode;

//	((CPersonality*)pIPersonalityNode)->Modified() = TRUE;
	hr = S_OK;

Leave:
	if( FAILED( hr ) )
	{
		RELEASE( pIPersonalityNode );
	}
	else if(pIPersonalityNode)
	{
		((CPersonality*)pIPersonalityNode)->SyncPersonalityWithEngine(CPersonality::syncPersonality);
	}
	else
	{
		hr = E_FAIL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::OnFileOpen

HRESULT CPersonalityDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* /*pITargetProject*/,
										 IDMUSProdNode* /*pITargetDirectoryNode*/, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPersonality* pPersonality;
	HRESULT hr;

	ASSERT( m_pComponent != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Personality 
	pPersonality = new CPersonality( m_pComponent );
	if( pPersonality == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	m_pComponent->m_nNextPersonality--;

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pPersonality->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pPersonality->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pPersonality->m_strOrigFileName 
				= pPersonality->m_strOrigFileName.Right( pPersonality->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}


	// Load the Personality file
	CWaitCursor	wcCursor;
	hr = pPersonality->Load( pIStream );
	if( FAILED( hr ) )
	{
		pPersonality->Release();
		return hr;
	}

	// Insert a node into the Project Tree
	if( !SUCCEEDED ( hr = m_pComponent->m_pIFramework->AddNode(pPersonality, NULL) ) )
	{
		pPersonality->Release();
		return hr;
	}

	// Advise the ConnectionPoint for this CSection and register the
	// CSection in the Transport.
	pPersonality->AdviseConnectionPoint();

	// Add Personality to Personality component list 
	m_pComponent->AddToPersonalityFileList( (CPersonality *)pPersonality );

	*ppIDocRootNode = (IDMUSProdNode *)pPersonality;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::OnFileSave

HRESULT CPersonalityDocType::OnFileSave( IStream* /*pIStream*/, IDMUSProdNode* /*pIDocRootNode*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::IsFileTypeExtension

HRESULT CPersonalityDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( !(strExt.CompareNoCase(_T(".cdp"))) )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( !(strExt.CompareNoCase(_T(".cdm"))) )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::GetListInfo

HRESULT CPersonalityDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	ULONG ulSize;
	ULONG ulID;
    HRESULT hr;

    ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

    hr = DMGetListInfo(pIStream, pListInfo);

	if(hr == S_OK || FAILED(hr))
	{
		goto LEAVE;
	}

	ulID = ReadID( pIStream );
    ulSize = ReadSize( pIStream );

	if( (ulID == ID_EPERSONALITY)	// .cdp file
	||  (ulID == ID_PERSONALITY) )	// .cdm file
    {
		Personality personality;

		long lRecordSize = ReadSize( pIStream );
		DWORD dwSize = min( lRecordSize, sizeof( personality ) );
		DWORD dwByteCount;

		hr = pIStream->Read( &personality, dwSize, &dwByteCount );
		if( FAILED( hr )
		||  dwByteCount != dwSize )
		{
			hr = E_FAIL;
		}
		else
		{
			CString strName;
			CString strDescriptor;

			personality.m_pfirstchord = NULL;
			personality.m_playlist.RemoveAll();		
			personality.m_chordlist.RemoveAll();
			personality.m_signpostlist.RemoveAll();
			
			strName = personality.m_username;
			pListInfo->bstrName = strName.AllocSysString();

			m_pComponent->ScalePatternToScaleName( (personality.m_scalepattern & 0x00FFFFFF), strDescriptor );
			pListInfo->bstrDescriptor = strDescriptor.AllocSysString();

			// Must check pListInfo->wSize before populating additional fields
			hr = S_OK;
		}
	}
LEAVE:
	return hr;
}

HRESULT CPersonalityDocType::DMGetListInfo(IStream * pIStream, DMUSProdListInfo * pListInfo)
{
	DWORD dwPos = StreamTell(pIStream);	// save pos if we fail
	IDMUSProdRIFFStream* pIRiffStream;
	MMCKINFO ckMain;

	HRESULT hr = S_OK;

	if(SUCCEEDED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		ckMain.fccType = FOURCC_PERSONALITY;
		if(pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF)==0)
		{
			MMCKINFO	ck;
			DWORD		dwByteCount;
			DWORD		dwSize;
			CString		str;
			DMUS_IO_CHORDMAP	iPersonality;
			ioPersonalityEdit	iPersonalityEdit;

			while(pIRiffStream->Descend(&ck, &ckMain, 0) == 0)
			{
				switch(ck.ckid)
				{
				case FOURCC_IOPERSONALITY:
					dwSize = min(ck.cksize, sizeof(iPersonality));
					hr = pIStream->Read(&iPersonality, dwSize, &dwByteCount);
					if(FAILED(hr) || dwByteCount != dwSize)
					{
						hr = E_FAIL;
						goto Leave;
					}
					str = iPersonality.wszLoadName;
					pListInfo->bstrName = str.AllocSysString();

					if( iPersonality.dwFlags & PERH_INVALID_BITS )
					{
						// There was a time (pre-DX8) when this field was not initialized
						 iPersonality.dwFlags = 0;
					}
					if( iPersonality.dwFlags & DMUS_CHORDMAPF_VERSION8 )
					{
						// Root is stored in high MSByte
						m_pComponent->ScalePatternToScaleName( (iPersonality.dwScalePattern & 0x00FFFFFF), str);
					}
					else
					{
						DWORD dwKey;
						iPersonality.dwScalePattern &= 0x00FFFFFF;
						dwKey = m_pComponent->DetermineRoot( iPersonality.dwScalePattern );
						iPersonality.dwScalePattern = Rotate24( iPersonality.dwScalePattern, -(long)dwKey );
						m_pComponent->ScalePatternToScaleName( (iPersonality.dwScalePattern & 0x00FFFFFF), str);
					}
					pListInfo->bstrDescriptor = str.AllocSysString();
					break;
				case FOURCC_PERSONALITYEDIT:
					dwSize = min(ck.cksize, sizeof(iPersonalityEdit));
					hr = pIStream->Read(&iPersonalityEdit, dwSize, &dwByteCount);
					if(FAILED(hr) || dwByteCount != dwSize)
					{
						hr = E_FAIL;
						goto Leave;
					}
					// Use username when present
					str = iPersonalityEdit.wchUserName;
					pListInfo->bstrName = str.AllocSysString();
					break;
				case FOURCC_GUID:
					hr = pIStream->Read(&(pListInfo->guidObject), sizeof(GUID), &dwByteCount);
					if(FAILED(hr) || dwByteCount != ck.cksize)
					{
						hr = E_FAIL;
						goto Leave;
					}
					break;
				}
				pIRiffStream->Ascend(&ck, 0);
			}
		}
Leave:
		pIRiffStream->Release();
	}
	StreamSeek(pIStream, dwPos, STREAM_SEEK_SET);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::GetObjectDescriptorFromNode

HRESULT CPersonalityDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Personality Node
	CPersonality* pPersonality;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_PersonalityNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pPersonality = (CPersonality *)pIDocRootNode;

	return pPersonality->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::GetObjectRiffId

HRESULT CPersonalityDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Personality Node
	if( IsEqualGUID ( guidNodeId, GUID_PersonalityNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = FOURCC_PERSONALITY;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDocType::GetObjectExt

HRESULT CPersonalityDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Personality Node
	if( IsEqualGUID ( guidNodeId, GUID_PersonalityNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".cdp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".cdm";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDesigner.cpp ===
// PersonalityDesigner.cpp : Implementation of CPersonalityDesignerApp and DLL registration.

#include "stdafx.h"
#pragma warning(disable:4201)
#include <initguid.h>
#include "PersonalityDesigner.h"
#include "PersonalityComponent.h"
#include "ChordMapStripMgr.h"
#include "winver.h"
#include <SegmentGuids.h>
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CPersonalityDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd433f95b, 0xb588, 0x11d0, { 0x9e, 0xdc, 0, 0xaa, 0, 0xa2, 0x1b, 0xa9 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CPersonalityApp::SetNodePointers  (used by all components)
void CPersonalityDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		pIChild->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for Jazz components
 
static BOOL RegisterComponents( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
	DWORD    dwSkip = 0;
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

// Register Personality Editor Component
	if( SUCCEEDED( StringFromIID(CLSID_PersonalityEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_PERSONALITY_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_PersonalityComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_PERSONALITY_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, _T("Skip"), &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_PersonalityNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_PersonalityRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_PersonalityComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicChordMap, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_CHORDMAP_OBJECT_TEXT );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
// CPersonalityDesignerApp::InitInstance - DLL initialization

BOOL CPersonalityDesignerApp::InitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxEnableControlContainer();

	BOOL bInit = COleControlModule::InitInstance();

	if( bInit )
	{
		m_pIPageManager = NULL;
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CPersonalityDesignerApp::ExitInstance - DLL termination

int CPersonalityDesignerApp::ExitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityDesignerApp::GetHelpFileName

BOOL CPersonalityDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);
	*/

	if ( !RegisterComponents() )
		return ResultFromScode(SELFREG_E_FIRST+2);

	return NOERROR;
}

static BOOL UnregisterComponents( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR    szGuid[MID_BUFFER];
	
	if( SUCCEEDED( StringFromIID(CLSID_PersonalityEditor, &psz) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_PersonalityComponent, &psz) ) )
	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_PersonalityNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow
#pragma warning(disable:4518 4502)
extern "C" __declspec(dllexport)
STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return AfxDllCanUnloadNow();
}
#pragma warning(default:4518 4502)
//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp();
        }
        else
        {
			AfxOleUnlockApp();
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CPersonalityComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject
#pragma warning(disable:4518 4502)
extern "C" __declspec(dllexport)
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_PersonalityComponent) )
	{
        pfunc = CPersonalityComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_PersonalityEditor)
		 ||  IsEqualCLSID(rclsid, CLSID_PersonalityPropPage) )
	{
		AFX_MANAGE_STATE( AfxGetStaticModuleState() );
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
#pragma warning(default:4518 4502)
////////////////////////////////////////////////////////////////////////////
// CPersonalityDesignerApp::GetFileVersion

BOOL CPersonalityDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDlg.h ===
#if !defined(AFX_PERSONALITYDLG_H__E39DBB02_B70C_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_PERSONALITYDLG_H__E39DBB02_B70C_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PersonalityDlg.h : header file
//

#ifndef	__PERSONALITYDLG_H__
#define	__PERSONALITYDLG_H__

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CPersonalityCtrl;

class CPersonalityDlg : public CFormView
{
public:
	CPersonalityDlg();           // protected constructor used by dynamic creation
	virtual ~CPersonalityDlg();

protected:
	DECLARE_DYNCREATE(CPersonalityDlg)

// Form Data
public:
	//{{AFX_DATA(CPersonalityDlg)
	enum { IDD = IDD_DLG_PERSONALITY };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:
	CPersonalityCtrl *m_pPersonalityCtrl;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonalityDlg)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CPersonalityDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALITYDLG_H__E39DBB02_B70C_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDlg.cpp ===
// PersonalityDlg.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "PersonalityDlg.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDlg

IMPLEMENT_DYNCREATE(CPersonalityDlg, CFormView)

CPersonalityDlg::CPersonalityDlg()
	: CFormView(CPersonalityDlg::IDD)
{
	//{{AFX_DATA_INIT(CPersonalityDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPersonalityDlg::~CPersonalityDlg()
{
}

void CPersonalityDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPersonalityDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPersonalityDlg, CFormView)
	//{{AFX_MSG_MAP(CPersonalityDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDlg diagnostics

#ifdef _DEBUG
void CPersonalityDlg::AssertValid() const
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CFormView::AssertValid();
}

void CPersonalityDlg::Dump(CDumpContext& dc) const
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CPersonalityDlg message handlers

BOOL CPersonalityDlg::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// TODO: Add your specialized code here and/or call the base class
	
	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityDocType.h ===
#ifndef __PERSONALITYDOCTYPE_H__
#define __PERSONALITYDOCTYPE_H__

// PersonalityDocType.h : header file
//


class CPersonalityDocType : public IDMUSProdDocType8
{
public:
	HRESULT DMGetListInfo(IStream* pIStream, DMUSProdListInfo* pListInfo);
    CPersonalityDocType( CPersonalityComponent* pComponent );
	~CPersonalityDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IPersonalityDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
	HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
	HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

private:
    CPersonalityDocType();

private:
    DWORD			m_dwRef;
	CPersonalityComponent* m_pComponent;
};

#endif // __PERSONALITYDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityPpg.cpp ===
// PersonalityPpg.cpp : Implementation of the CPersonalityPropPage property page class.

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "PersonalityPpg.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CPersonalityPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CPersonalityPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CPersonalityPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Personality Editor Property Page  {03DE8B81-A76B-11d0-9EDC-00AA00A21BA9}
const CLSID CLSID_PersonalityPropPage = 
{ 0x8eaf7e00, 0xb6a1, 0x11d0, { 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9 } };

/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CPersonalityPropPage, "CHORDMAPDESR.ChordMapPropPage.1",
	0xd433f95f, 0xb588, 0x11d0, 0x9e, 0xdc, 0, 0xaa, 0, 0xa2, 0x1b, 0xa9)


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPropPage::CPersonalityPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CPersonalityPropPage

BOOL CPersonalityPropPage::CPersonalityPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_PERSONALITY_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPropPage::CPersonalityPropPage - Constructor

CPersonalityPropPage::CPersonalityPropPage() :
	COlePropertyPage(IDD, IDS_PERSONALITY_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CPersonalityPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPropPage::DoDataExchange - Moves data between page and properties

void CPersonalityPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_MAP(CPersonalityPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityEditorGuids.c ===
// PersonalityEditorGuids.c : Contains GUIDs not found in MIDL generated PersonalityEditor_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID GUID_PersonalityNode =					{0xf6797820,0xb5dd,0x11d0,{0x9e,0xdc,0x0,0xaa,0x0,0xa2,0x1b,0xa9}};
const GUID GUID_PersonalityRefNode =				{0x8ca7ab01,0xc803,0x11d0,{0x9e,0xdc,0x0,0xaa,0x0,0xa2,0x1b,0xa9}};
const GUID GUID_PersonalityChordListFolderNode =	{0x9c165020,0xc18a,0x11d0,{0x9e,0xdc,0x0,0xaa,0x0,0xa2,0x1b,0xa9}};
const GUID GUID_PersonalitySignPostFolderNode =		{0xfc5abbe1,0xc263,0x11d0,{0x9e,0xdc,0x0,0xaa,0x0,0xa2,0x1b,0xa9}};
const GUID GUID_PersonalityChordPaletteFolderNode =	{0x813a1161,0xc26b,0x11d0,{0x9e,0xdc,0x0,0xaa,0x0,0xa2,0x1b,0xa9}};
const GUID CLSID_PersonalityComponent = {0x6D432E20,0xB5E2,0x11d0,{0x9E,0xDC,0x00,0xAA,0x00,0xA2,0x1B,0xA9}};
const GUID PERSONALITY_NameChange = {0x68ce1323, 0x912f, 0x11d1,{0x98,0x4d,0x0,0x80,0x5f,0xa6,0x7d,0x16}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityRef.cpp ===
// PersonalityRef.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"

#include "Personality.h"
#include "StyleRiffId.h "
#pragma warning(default:4201)

/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef constructor/destructor

CPersonalityRef::CPersonalityRef( CPersonalityComponent* pComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pComponent != NULL );

    m_dwRef = 0;
	AddRef();

	m_pPersonalityComponent = pComponent;
	m_pPersonalityComponent->AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pPersonality = NULL;
}

CPersonalityRef::~CPersonalityRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonalityComponent )
	{
		m_pPersonalityComponent->Release();
	}

	if( m_pPersonality )
	{
		m_pPersonality->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef::SetModifiedFlag

void CPersonalityRef::SetModifiedFlag( BOOL fNeedsSaved )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPersonality != NULL );
	ASSERT( m_pPersonalityComponent->m_pIFramework != NULL );

	// Framework responsible for clearing its own modified flag.
	// Otherwise Project file containing multiple durty files
	// may be flagged as not dirty because one file is no 
	// longer dirty.
	if( fNeedsSaved )
	{
		m_pPersonality->Modified() = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IUnknown implementation

HRESULT CPersonalityRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CPersonalityRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CPersonalityRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

	TRACE( "CPersonalityRef: %ld\n", m_dwRef );

    if( m_dwRef == 0 )
    {
		TRACE( "CPersonalityRef destroying...\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNodeImageIndex

HRESULT CPersonalityRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPersonalityComponent != NULL );

	return( m_pPersonalityComponent->GetPersonalityRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetFirstChild

HRESULT CPersonalityRef::GetFirstChild( IDMUSProdNode** /*ppIFirstChildNode*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;		// PersonalityRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNextChild

HRESULT CPersonalityRef::GetNextChild( IDMUSProdNode* /*pIChildNode*/, IDMUSProdNode** /*ppINextChildNode*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// PersonalityRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetComponent

HRESULT CPersonalityRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPersonalityComponent != NULL );

	return m_pPersonalityComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetDocRootNode

HRESULT CPersonalityRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::SetDocRootNode

HRESULT CPersonalityRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetParentNode

HRESULT CPersonalityRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::SetParentNode

HRESULT CPersonalityRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNodeId

HRESULT CPersonalityRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_PersonalityRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNodeName

HRESULT CPersonalityRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		TCHAR achNoPersonality[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_PERSONALITY, achNoPersonality, MID_BUFFER );
		CString strNoPersonality = achNoPersonality;
		*pbstrName = strNoPersonality.AllocSysString();
		return S_OK;
	}

    return m_pPersonality->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CPersonalityRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a PersonalityRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::ValidateNodeName

HRESULT CPersonalityRef::ValidateNodeName( BSTR /*bstrName*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a PersonalityRef node
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::SetNodeName

HRESULT CPersonalityRef::SetNodeName( BSTR /*bstrName*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a PersonalityRef node
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetNodeListInfo

HRESULT CPersonalityRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return E_FAIL;
	}

    return m_pPersonality->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetEditorClsId

HRESULT CPersonalityRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_PersonalityEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetEditorTitle

HRESULT CPersonalityRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return E_FAIL;
	}

    return m_pPersonality->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetEditorWindow

HRESULT CPersonalityRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return E_FAIL;
	}

    return m_pPersonality->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::SetEditorWindow

HRESULT CPersonalityRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return E_FAIL;
	}

    return m_pPersonality->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::UseOpenCloseImages

HRESULT CPersonalityRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetRightClickMenuId

HRESULT CPersonalityRef::GetRightClickMenuId( HINSTANCE* /*phInstance*/, UINT* /*pnMenuId*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
/*
	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_PERSONALITYREF_NODE_RMENU;
*/
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CPersonalityRef::OnRightClickMenuInit( HMENU /*hMenu*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CPersonalityRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case 1 :
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::DeleteChildNode

HRESULT CPersonalityRef::DeleteChildNode( IDMUSProdNode* /*pIChildNode*/, BOOL /*fPromptUser*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// PersonalityRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::InsertChildNode

HRESULT CPersonalityRef::InsertChildNode( IDMUSProdNode* /*pIChildNode*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// PersonalityRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::DeleteNode

HRESULT CPersonalityRef::DeleteNode( BOOL /*fPromptUser*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_FAIL;		// Cannot delete PersonalityRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::OnNodeSelChanged

HRESULT CPersonalityRef::OnNodeSelChanged( BOOL /*fSelected*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
// Drag/Drop methods
/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CreateDataObject

HRESULT CPersonalityRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pPersonality )
	{
		// Let Personality create data object
		return m_pPersonality->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanCut

HRESULT CPersonalityRef::CanCut( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanCopy

HRESULT CPersonalityRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if(m_pPersonality)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanDelete

HRESULT CPersonalityRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIParentNode != NULL);
	return m_pIParentNode->CanDeleteChildNode( this );

}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanDeleteChildNode

HRESULT CPersonalityRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	
}



/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanPasteFromData

HRESULT CPersonalityRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Personality
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pPersonalityComponent->m_cfPersonality );

	pDataObject->Release();

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Personality
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pPersonality )
	{
		// Let Personality decide what can be dropped
		return m_pPersonality->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::PasteFromData

HRESULT CPersonalityRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Personality
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pPersonalityComponent->m_cfPersonality );

	pDataObject->Release();

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Personality
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pPersonality )
	{
		// Let Personality handle paste
		return m_pPersonality->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::CanChildPasteFromData

HRESULT CPersonalityRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											    BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::ChildPasteFromData

HRESULT CPersonalityRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;
}





/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CPersonalityRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pPersonality )
	{
		m_pPersonality->AddRef();
		*ppIDocRootNode = m_pPersonality;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CPersonalityRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			if( pINode )
			{
				pINode->Release();
			}
			return E_INVALIDARG;
		}
		pINode->Release();

		// Make sure method was passed a Personality Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_PersonalityNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	if( m_pPersonality )
	{
		m_pPersonality->Release();
		m_pPersonality = NULL;
	}

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pPersonality = (CPersonality *)pIDocRootNode;
		m_pPersonality->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonalityRef IDMUSProdNode::GetObject

HRESULT CPersonalityRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMStyle object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicChordMap ) )
	{
		if( m_pPersonality->m_pIDirectMusicChordMap )
		{
			return m_pPersonality->m_pIDirectMusicChordMap->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityRef.h ===
#ifndef __PERSONALITYREF_H__
#define __PERSONALITYREF_H__

// PersonalityRef.h : header file
//

#include "PersonalityComponent.h"
#include "PersonalityDocType.h"
#include "RiffStrm.h"
//#include "RiffStructs.h"

class CPersonalityRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CPersonalityRef( CPersonalityComponent* pPersonalityComponent );
	~CPersonalityRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
	HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode **ppIFirstChildNode );
	HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode *pIChildNode, IDMUSProdNode **ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

   	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// drag/drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions
public:
	void SetModifiedFlag( BOOL fNeedsSaved );

public:
	CPersonalityComponent*	m_pPersonalityComponent;
	CPersonality*			m_pPersonality;		// PersonalityRef refers to this Personality

private:
    DWORD					m_dwRef;
	IDMUSProdNode*				m_pIDocRootNode;
	IDMUSProdNode*				m_pIParentNode;
};

#endif // __PERSONALITYREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityRIFF.h ===
#ifndef PERSONALITYRIFF_H
#define PERSONALITYRIFF_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define FOURCC_GUID					mmioFOURCC('g','u','i','d')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')
#define FOURCC_PERSONALITYSTRUCT	mmioFOURCC('p','s','t','r')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// design time chunks
#define FOURCC_PERSONALITYKEY		 mmioFOURCC('p','k','e','y')
#define FOURCC_PERSONALITYEDIT		mmioFOURCC('p','e','d','t')
#define FOURCC_CHORDENTRYEDIT		mmioFOURCC('c','e','e','d')
#define FOURCC_CHORDEDIT				  mmioFOURCC('c','h','e','d')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_UNFO_LIST	        mmioFOURCC('U','N','F','O')
#define DM_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define DM_FOURCC_GROOVE_LEVEL		mmioFOURCC('g','r','o','v')

// constants
const int MaxSubChords = 4;

// simple riff read/writers
inline HRESULT ReadWord(IDMUSProdRIFFStream* pIRiffStream, WORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT ReadDword(IDMUSProdRIFFStream* pIRiffStream, DWORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteWord(IDMUSProdRIFFStream* pIRiffStream, WORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteDWord(IDMUSProdRIFFStream* pIRiffStream, DWORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}


// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};


// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};


// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
	ioPersonality()
	{
		memset(this, 0, sizeof(ioPersonality));
	}
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
	ioSubChord()
	{
		memset(this, 0, sizeof(ioSubChord));
	}
	ioSubChord(DMChord& chord)
	{
		dwChordPattern = chord.ChordPattern();
		dwScalePattern = chord.ScalePattern();
		dwInvertPattern = chord.InvertPattern();
		dwLevels = chord.Levels();
		wCFlags = chord.Flags();
		bChordRoot = chord.ChordRoot();
		bScaleRoot = chord.ScaleRoot();
	}
	void CopyToDMChord(DMChord& chord)
	{
		chord.ChordPattern() = dwChordPattern;
		chord.ScalePattern() = dwScalePattern;
		chord.InvertPattern() = dwInvertPattern;
		chord.Levels() = dwLevels;
		chord.Flags() = wCFlags;
		chord.ChordRoot() = bChordRoot;
		chord.ScaleRoot() = bScaleRoot;
	}
	BOOL operator==(const ioSubChord& sub)
	{
		return !(memcmp(this, &sub, sizeof(ioSubChord)));
	}
	operator unsigned long()
	{
		return dwChordPattern;
	}
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
	ioChordEntry()
	{
		memset(this, 0, sizeof(ioChordEntry));
	}
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
	ioNextChord()
	{
		memset(this, 0, sizeof(ioNextChord));
	}
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
	ioSignPost()
	{
		memset(this, 0, sizeof(ioSignPost));
	}
};


// design time data structs
struct ioPersonalityEdit
{
	WCHAR	wchUserName[20];
	WCHAR	wchDescription[80];
	BYTE		bVariableNotFixed; // variable or fixed grid chordmap
	WORD	wChordMapLength;
	BOOL	  fUseTimeSignature;
	LONG	lTimeSignature;
	BYTE		bKeySig;
	WORD	wSplitterYPos;
	WORD	wScrollHorPos;
	WORD	wScrollVertPos;
	BYTE		selection;
	WORD	wConnectionIdSelectedChord;
	// next two fields identify a selected connection
	WORD	wConnectionIdSelectedFromChord;
	WORD	wConnectionIdSelectedToChord;
	WORD	wSelectedSignpostRow;
	WORD	wSelectedSignpostCol;
	ioPersonalityEdit()
	{
		memset(this,0,sizeof(ioPersonalityEdit));
	}
};

struct ioPersonalityEdit2 : public ioPersonalityEdit
{
	double	dblZoom;
	bool	fLockAllScales;
	bool	fSyncLevelOneToAll;
	LONG	lFunctionbarWidth;
	ioPersonalityEdit2() : ioPersonalityEdit()
	{
		dblZoom = 0.0;
		fLockAllScales = true;
		fSyncLevelOneToAll = true;
		lFunctionbarWidth = 0;
	}
};

struct ioChordEntryEdit
{
	BYTE	bBits[MaxSubChords];
	BYTE	 bUseFlat[MaxSubChords];
	WORD	wMeasure;
	BYTE	 bBeat;
	// mrect
	short		left;
	short		top;
	short		right;
	short		bottom;
    short		page;
	WORD	wConnectionId;	// maplet to ioChordEntry
	ioChordEntryEdit()
	{
		memset(this,0,sizeof(ioChordEntryEdit));
	}
};

struct DMChordEdit
{
	BYTE	bBits[MaxSubChords];
	BYTE	 bUseFlat[MaxSubChords];
	DMChordEdit()
	{
		memset(this,0,sizeof(DMChordEdit));
	}
	DMChordEdit(const DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			DMChord* pchord = const_cast<DMPolyChord&>(chord).SubChord(i);
			bBits[i] = pchord->Bits();
			bUseFlat[i] = pchord->UseFlat();
		}
	}
	void Extract(const DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			DMChord* pchord = const_cast<DMPolyChord&>(chord).SubChord(i);
			bBits[i] = pchord->Bits();
			bUseFlat[i] = pchord->UseFlat();
		}
	}
	void Insert(DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			chord.SubChord(i)->Bits() = bBits[i];
			chord.SubChord(i)->UseFlat() = bUseFlat[i];
		}
	}
};

struct PersonalityStructure
{
	char	bVariableNotFixed;
	char	bKey;
	char	bUseTimeSignature;
	char	bReserved1;
	short  wChordMapLength;
	short	wReserved1;
	long	lTimeSig;
	PersonalityStructure()
	{
		bVariableNotFixed = FALSE;
		bKey = 0;
		bUseTimeSignature = TRUE;
		bReserved1 = 0;
		wChordMapLength = 20;
		wReserved1 = 0;
		lTimeSig = MAKE_TIMESIG(4,4) ;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		IStream* pIStream;
		HRESULT hr;
		DWORD dwBytesWritten;
		// Write  header
		WriteChunk chunk(pRiffStream, FOURCC_PERSONALITYSTRUCT);
		hr = chunk.State();
		if(  hr  == 0 )
		{
			pIStream = pRiffStream->GetStream();
			ASSERT( pIStream != NULL );

			// Write Signpost chunk data
			hr = pIStream->Write( this, sizeof(PersonalityStructure), &dwBytesWritten) == 0
				&& dwBytesWritten == sizeof(PersonalityStructure) ? S_OK : E_FAIL;
			pIStream->Release();
		}
		return hr;
	}

	HRESULT Read(IDMUSProdRIFFStream* pIRiffStream)
	{
		ASSERT(pIRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pIRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		hr = pIStream->Read(this, sizeof(PersonalityStructure), &dwBytesRead) == 0
			&& dwBytesRead == sizeof(PersonalityStructure) ? S_OK : E_FAIL;
		pIStream->Release();
		return hr;
	}

};

struct ioPersonalityVersion
{
	enum {PersonalityVersionMS = 0x00010000, PersonalityVersionLS = 0x00000000};
	DWORD	m_dwVersionMS;
	DWORD	m_dwVersionLS;
	ioPersonalityVersion()
	{
		m_dwVersionMS = PersonalityVersionMS;
		m_dwVersionLS = PersonalityVersionLS;
	}
};


#ifdef XXXXTryAndCompileThisXXXX

RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	<pstr-ck>			// personality structual info
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncrd-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<spsh-ck> ::= spsh(<ioSignPost>)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PersonalityPpg.h ===
#if !defined(AFX_PERSONALITYPPG_H__D433F96E_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_PERSONALITYPPG_H__D433F96E_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// PersonalityPpg.h : Declaration of the CPersonalityPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CPersonalityPropPage : See PersonalityPpg.cpp.cpp for implementation.

class CPersonalityPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CPersonalityPropPage)
	DECLARE_OLECREATE_EX(CPersonalityPropPage)

// Constructor
public:
	CPersonalityPropPage();

// Dialog Data
	//{{AFX_DATA(CPersonalityPropPage)
	enum { IDD = IDD_PROPPAGE_PERSONALITY };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CPersonalityPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALITYPPG_H__D433F96E_B588_11D0_9EDC_00AA00A21BA9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\picture.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "picture.h"


/////////////////////////////////////////////////////////////////////////////
// CPicture properties

long CPicture::GetHandle()
{
	long result;
	GetProperty(0x0, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHPal()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CPicture::SetHPal(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

short CPicture::GetType()
{
	short result;
	GetProperty(0x3, VT_I2, (void*)&result);
	return result;
}

long CPicture::GetWidth()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHeight()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CPicture operations
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\picture.h ===
#if !defined(AFX_PICTURE1_H__29387B50_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
#define AFX_PICTURE1_H__29387B50_948E_11D2_BC93_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CPicture wrapper class

class CPicture : public COleDispatchDriver
{
public:
	CPicture() {}		// Calls COleDispatchDriver default constructor
	CPicture(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	CPicture(const CPicture& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	long GetHandle();
	long GetHPal();
	void SetHPal(long);
	short GetType();
	long GetWidth();
	long GetHeight();

// Operations
public:
	// method 'Render' not emitted because of invalid return type or parameter type
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PICTURE1_H__29387B50_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PropChord.cpp ===
#include "stdafx.h"
#include "PropChord.h"

CPropChord::CPropChord()
{
	for(int i = 0; i < MAX_POLY; i++)
		m_dwUndetermined[i] = 0;
}

static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void CPropChord::RootToString(char *pszName, int nSubChord)
{
	ASSERT(nSubChord < MAX_POLY);
	nSubChord = nSubChord < 0 ? 0 : nSubChord;	// < 0 --> default root (0)
	int nX = (char)( SubChord(nSubChord)->ChordRoot() % 12 );
	if( SubChord(nSubChord)->UseFlat() )
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot() / 12), (LPSTR)flatconvert[nX] ) ;
	else
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot()/ 12), (LPSTR)convert[nX] ) ;
}


void CPropChord::SetBits(int nSubChord)
{
	LONG    nX;
	int   nCount = 0;

	DMChord* pSub = SubChord(nSubChord);

    for( nX=0L ;  nX<32L ;  nX++ )
    {
        if( pSub->ChordPattern() & (1L << nX) )
            nCount++;
    }

    if( !pSub->Bits() )
    {
        pSub->Bits() |= CHORD_INVERT;
        if( nCount > 3 )
            pSub->Bits() |= CHORD_FOUR;
        if( pSub->ChordPattern() & (15L << 18L) )
            pSub->Bits() |= CHORD_UPPER;
    }
    pSub->Bits() &= ~CHORD_COUNT;
    pSub->Bits() |= nCount;
}

void CPropChord::CopyToPropChord( CPropChord *pPropChord,  int nSubChord)
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord <0 ? 0 : nSubChord;
	int upper = nSubChord < -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = 0;
		pPropChord->m_dwUndetermined[i] = 0;
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (pSubL->ChordPattern() != pSubR->ChordPattern())
		{
			dwChangeFlags[i] |= UD_CHORDPATTERN;
		}

		if (pSubL->ScalePattern() != pSubR->ScalePattern())
		{
			dwChangeFlags[i] |= UD_SCALEPATTERN;
		}

		if (strcmp(Name(), pPropChord->Name()))
		{
			dwChangeFlags[i] |= UD_NAME;
		}

		if (pSubL->ChordRoot() != pSubR->ChordRoot())
		{
			dwChangeFlags[i] |= UD_CHORDROOT;
		}

		if (pSubL->ScaleRoot() != pSubR->ScaleRoot())
		{
			dwChangeFlags[i] |= UD_CHORDROOT;
		}

		if (pSubL->UseFlat() != pSubR->UseFlat())
		{
			dwChangeFlags[i] |= UD_FLAT;
		}

		if ((pSubL->Bits() & CHORD_INVERT) != (pSubR->Bits() & CHORD_INVERT))
		{
			dwChangeFlags[i] |= UD_INVERT;
		}

		if ((pSubL->Bits() & CHORD_FOUR) != (pSubR->Bits() & CHORD_FOUR))
		{
			dwChangeFlags[i] |= UD_FOUR;
		}

		if ((pSubL->Bits() & CHORD_UPPER) != (pSubR->Bits() & CHORD_UPPER))
		{
			dwChangeFlags[i] |= UD_UPPER;
		}

		if(pSubL->InvertPattern() != pSubR->InvertPattern())
		{
			dwChangeFlags[i] |= UD_INVERTPATTERN;
		}
		
		if(pSubL->Levels() != pSubR->Levels())
		{
			dwChangeFlags[i] |= UD_LEVELS;
		}

		pPropChord->m_dwUndetermined[i] = dwChangeFlags[i];
	}
}

  
void CPropChord::CopyFromPropChord( CPropChord *pPropChord, int nSubChord )
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord == -1 ? 0 : nSubChord;
	int upper = nSubChord == -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = ~(pPropChord->m_dwUndetermined[i]);
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (dwChangeFlags[i] & UD_CHORDPATTERN)
		{
			pSubL->ChordPattern() = pSubR->ChordPattern();
		}

		if (dwChangeFlags[i] & UD_SCALEPATTERN)
		{
			pSubL->ScalePattern() = pSubR->ScalePattern();
		}

		if (dwChangeFlags[i] & UD_NAME)
		{
			strcpy(Name(), pPropChord->Name());
		}

		if (dwChangeFlags[i] & UD_CHORDROOT)
		{
			pSubL->ChordRoot() = pSubR->ChordRoot();
		}

		if( dwChangeFlags[i] & UD_SCALEROOT)
		{
			pSubL->ScaleRoot() = pSubR->ScaleRoot();
		}

		if (dwChangeFlags[i] & UD_FLAT)
		{
			pSubL->UseFlat() = pSubR->UseFlat();
		}

		if (dwChangeFlags[i] & UD_INVERT)
		{
			pSubL->Bits() &= ~CHORD_INVERT;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_INVERT);
		}

		if (dwChangeFlags[i] & UD_FOUR)
		{
			pSubL->Bits() &= ~CHORD_FOUR;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_FOUR);
		}

		if (dwChangeFlags[i] & UD_UPPER)
		{
			pSubL->Bits() &= ~CHORD_UPPER;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_UPPER);
		}

		if(dwChangeFlags[i] & UD_INVERTPATTERN)
		{
			pSubL->InvertPattern() = pSubR->InvertPattern();
		}

		if(dwChangeFlags[i] & UD_LEVELS)
		{
			pSubL->Levels() = pSubR->Levels();
		}
	}
}


BOOL CPropChord :: operator < (const CPropChord& chord)
{
	if( Measure() == chord.Measure())
	{
		if(Beat() < chord.Beat())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else if (Measure() < chord.Measure())
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CPropChord& CPropChord::operator = (const CPropChord& chord)
{
	if(&chord == this)
	{
		return *this;
	}

	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}

	return *this;
}

CPropChord::CPropChord(const CPropChord& chord)
{
	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}
}

void	CPropChord::SetUndetermined(int nSubChord, DWORD value)
{
	ASSERT(nSubChord < MAX_POLY);
	int lower = nSubChord == -1 ? 0 : static_cast<int>(nSubChord);
	int upper = nSubChord == -1 ? MAX_POLY : static_cast<int>(nSubChord) + 1;
	for(int i = lower; i < upper; i++)
	{
		m_dwUndetermined[i] = value;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PropChord.h ===
#ifndef __PROPCHORD_H_
#define __PROPCHORD_H_

#include "chord.h"

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

class CPropChord : public DMPolyChord
{
//	Used to track which fields are shared by multiple 
//	chords and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined[MAX_POLY];
public:
	enum {ALL = -1};
				CPropChord();
				CPropChord(const CPropChord&);
	void		SetBits(int nSubChord);
	void		CopyToPropChord( CPropChord *pPropChord, int nSubChord );	// nSubChord = -1 -> all subchords
	void		CopyFromPropChord( CPropChord *pPropChord, int nSubChord ); // nSubChord = -1 -> all subchords
	void		RootToString(char *pszName, int nSubChord);
	CPropChord&	operator = (const CPropChord&);
	BOOL		operator < (const CPropChord&);
	void		SetUndetermined(int nSubChord, DWORD value);	// nSubChord = -1 -> all subchords
	DWORD	GetUndetermined(int nSubChord)
	{
		ASSERT(nSubChord < MAX_POLY);
		return m_dwUndetermined[nSubChord];
	}
	DWORD& Undetermined(int nSubChord)
	{
		ASSERT(nSubChord < MAX_POLY);
		return m_dwUndetermined[nSubChord];
	}
	/*
    DWORD		m_dwTime;
    DWORD		m_dwChordPattern;	// Pattern that defines chord
    DWORD		m_dwScalePattern;	// Scale Pattern for the chord
    short		m_nMeasure;			// What measure
    char		m_szName[12];		// Text for display
    BYTE		m_bRoot;			// Root note of chord
    BYTE		m_bFlat;			// Display with flat
    BYTE		m_bBeat;			// What beat this falls on
    BYTE		m_bBits;			// Invert and item count
	*/
};

// Flags for m_dwUndetermined:

#define UD_CHORDPATTERN		(1 << 0)
#define UD_SCALEPATTERN		(1 << 1)
#define UD_NAME				(1 << 2)
#define UD_CHORDROOT				(1 << 3)
#define UD_FLAT				(1 << 4)
#define UD_INVERT			(1 << 5)
#define UD_FOUR				(1 << 6)
#define UD_UPPER			(1 << 7)
#define UD_SIMPLE			(1 << 8)
#define UD_DRAGSELECT		(1 << 9)
#define UD_DROPSELECT		(1 << 10)
#define UD_FROMCHORDPALETTE	(1 << 11)
#define UD_SCALEROOT		(1<<12)
#define UD_INVERTPATTERN	(1 << 13)
#define UD_LEVELS (1 << 14)

#endif // __PROPCHORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"
#include "staticproppagemanager.h"

class CChordPropPageMgr : public  CStaticPropPageManager
{
	friend class CChordScalePropPage;
	friend class CChordInversionPropPage;
public:
	CChordPropPageMgr(IDMUSProdFramework* pIFramework );
	~CChordPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
//	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet( void );

	// Additional methods

	CChordScalePropPage*		m_pChordScalePropPage;
	CChordInversionPropPage*	m_pChordInversionPropPage;
	IDMUSProdFramework*			m_pIFramework;

	static short				sm_nActiveTab;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\RiffStructs.h ===
#ifndef __RIFFSTRUCTS_H__
#define __RIFFSTRUCTS_H__

#pragma pack(2)


/*
typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;
*/

/*
typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;
*/

/*
typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;
*/

/*
typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;
*/

/*
typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;
*/

/*
typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;
*/


typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;



typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;


// this should match enums in iochord.h
enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80, // this chord is selected
	CSF_SIGNPOST = 0x40, // this chord is from a signpost
	CSF_SHIFTED = 0x20	// this chord has been altered from an illegal chord
						// used to make chord unique so that Load subchord database code works correctly
						// (see use in ChordDatabase.cpp)

};



typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;


#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

/*
typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;
*/

/*
typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;
*/

/*
typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;
*/

/*
typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;
*/

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

/*
typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;
*/

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif // __RIFFSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PersonalityDesigner.rc
//
#define IDS_PERSONALITY                 1
#define IDD_ABOUTBOX_PERSONALITY        2
#define IDS_PROPPAGE_CHORD              2
#define IDB_PERSONALITY                 3
#define IDI_ABOUTDLL                    4
#define IDS_SHORTEN_LENGTH              4
#define IDS_PERSONALITY_PPG             5
#define IDD_TAB_CHORDPALETTE            102
#define IDS_UNDO_LOCK_SCALES            114
#define IDS_UNDO_SYNC_LEVELS            115
#define IDD_TAB_PERSONALITY             139
#define IDS_PERSONALITY_PPG_CAPTION     200
#define IDD_PROPPAGE_PERSONALITY        201
#define IDS_CHORDMAP_OBJECT_TEXT        201
#define IDS_PERSONALITY_COMPONENT_NAME  202
#define IDM_PERSONALITY_NODE_RMENU      203
#define IDS_ERR_ADD_IMAGELIST           204
#define IDM_PERSONALITYS_NODE_RMENU     205
#define IDS_PERSONALITY_TEXT            206
#define IDR_PERSONALITY_EDITOR          207
#define IDR_PERSONALITY_OPTIONS         207
#define IDS_ERR_INVALIDARG              208
#define IDI_PERSONALITY_DOCTYPE_SEL     209
#define IDS_ERR_MISSING_CONDUCTOR       210
#define IDI_CHORDTRUCK                  210
#define IDI_FOLDER                      211
#define IDR_PERSONALITY_DOCTYPE         212
#define IDI_FOLDER_SEL                  213
#define IDS_PERSONALITY_COMP_FOLDER_NAME 214
#define IDI_PERSONALITY_DOCTYPE         215
#define IDS_ERR_MEMORY                  216
#define IDS_ERR_ADD_DOCTYPE             217
#define IDS_NO_PERSONALITY              218
#define IDC_GRID                        218
#define IDS_PERSONALITY_CHORDLIST_FOLDER_NAME 219
#define IDC_REF_NAME                    219
#define IDR_CHORD_RMENU                 219
#define IDD_DLG_PERSONALITY             220
#define IDS_PERSONALITY_SIGNPOST_FOLDER_NAME 220
#define IDC_NAME                        220
#define IDS_PERSONALITY_CHORDPALETTE_FOLDER_NAME 221
#define IDC_COMBO_STYLE                 221
#define IDD_CHORDSCALE_PROPPAGE         221
#define IDS_MAJOR                       222
#define IDC_COMBO_BEAT                  222
#define IDD_CHORDINVERSION_PROPPAGE     222
#define IDS_DORIAN                      223
#define IDC_SPIN_BPM                    223
#define IDC_BUTTON_MIDICHORD4           223
#define IDI_ICON1                       224
#define IDS_PHRYGIAN                    224
#define IDC_BPM                         224
#define IDC_EDIT_ROOT                   224
#define IDS_LYDIAN                      225
#define IDC_TIME_SIGNATURE              225
#define IDC_EDIT_NAME                   225
#define IDC_AUTHOR                      225
#define IDC_STATICTIMESIG               225
#define IDM_PERSONALITY_CHORDLIST_NODE_RMENU 226
#define IDS_MIXOLYDIAN                  226
#define IDC_USE_TIME_SIGNATURE          226
#define IDC_COPYRIGHT                   226
#define IDS_AEOLIAN                     227
#define IDC_KEYS_SCALE4                 227
#define IDC_VERSION_1                   227
#define IDS_MINOR                       228
#define IDC_COMBO_GROOVE                228
#define IDC_KEYS_BASECHORD4             228
#define IDC_VERSION_2                   228
#define IDI_SIGNPOST_SEL                229
#define IDS_HMINOR                      229
#define IDC_KEYS_BASECHORD3             229
#define IDC_VERSION_3                   229
#define IDS_WHOLE                       230
#define IDI_SIGNPOST                    230
#define IDC_KEYS_BASECHORD2             230
#define IDC_VERSION_4                   230
#define IDD_TAB_PERSONALITY_INFO        230
#define IDS_LOCRIAN                     231
#define IDI_ICON2                       231
#define IDC_FILE_VERSION                231
#define IDC_KEYS_SCALE3                 231
#define IDC_SUBJECT                     231
#define IDS_PERSONALITY_VERSION_TEXT    232
#define IDI_ICON3                       232
#define IDC_CHANGELENGTH                232
#define IDC_KEYS_BASECHORD1             232
#define IDI_ICON4                       233
#define IDC_EDITLENGTH                  233
#define IDS_ERR_ADD_CLIPFORMAT          233
#define IDC_KEYS_SCALE1                 233
#define IDS_ERR_REGISTER_CF             234
#define IDI_ICON5                       234
#define IDC_SPIN1                       234
#define IDC_KEYS_SCALE2                 234
#define IDC_MAJOR                       235
#define IDC_KEYS_CHORD4                 235
#define IDC_KEYS_INVERSIONS4            235
#define IDC_KEYS_CHORD3                 236
#define IDC_KEYS_INVERSIONS3            236
#define IDI_PERSONALITYREF              237
#define IDC_SHIFTDOWN                   237
#define IDC_KEYS_CHORD1                 237
#define IDC_KEYS_INVERSIONS2            237
#define IDI_PERSONALITYREF_SEL          238
#define IDC_EXTENDOCTAVE                238
#define IDC_KEYS_CHORD2                 238
#define IDC_KEYS_INVERSIONS1            238
#define IDD_FRAMEWND                    239
#define IDC_BUTTON_INVERT4              239
#define IDS_UNKNOWN                     240
#define IDC_HARMONICMINOR               240
#define IDC_BUTTON_SHIFTL4              240
#define IDC_BUTTON_IPLAY4               240
#define IDS_COMBO_GROOVE_A              241
#define IDC_BUTTON_IPLAY3               241
#define IDS_COMBO_GROOVE_B              242
#define IDC_CLEAR                       242
#define IDC_BUTTON_IPLAY2               242
#define IDC_SPLITTER                    243
#define IDS_COMBO_GROOVE_C              243
#define IDM_DRAG_RMENU                  243
#define IDC_SHIFTUP                     243
#define IDC_BUTTON_IPLAY1               243
#define IDD_CHORD_DIALOG                244
#define IDS_COMBO_GROOVE_D              244
#define IDC_MELODICMINOR                244
#define IDC_EDIT_IROOT                  244
#define IDD_SIGNPOST_DIALOG             245
#define IDS_ERR_BPM_VALUE               245
#define IDC_EDIT_INAME                  245
#define IDC_TIMELINECTL                 246
#define IDD_TAB_AUDITION                246
#define IDS_ERR_PERSONALITYNOTFOUND     246
#define IDC_CHECK_LEGAL4                246
#define IDC_USESHARPS                   247
#define IDC_CHECK_LEGAL3                247
#define IDR_SIGNPOST_RMENU              248
#define IDC_SCALEKEYS                   248
#define IDC_USEFLATS                    248
#define IDC_CHECK_LEGAL2                248
#define IDC_CHECK_LEGAL1                249
#define IDC_SPIN_ROOT                   250
#define IDC_CHORD_MIDI_IN               251
#define IDC_EDITKEY                     251
#define IDC_CHORD_NAME                  252
#define IDC_SPINKEY                     252
#define IDC_CHORD_MIDI_IN2              253
#define IDC_BUTTON_MIDICHORD3           253
#define IDC_ROOT_SPIN                   254
#define IDC_RADIOFIX                    254
#define IDC_ROOT_TEXT                   255
#define IDC_RADIOVAR                    255
#define IDC_CHORD_INVERT                256
#define IDC_DONTWARN                    256
#define IDC_CHORD_DROPOCTAVE            257
#define IDC_BUTTON_MIDICHORD1           257
#define IDC_ILLEGALCHORD                257
#define IDC_CHORD_FOURNOTES             258
#define IDC_EDIT_GROOVE                 258
#define IDC_CHORD_FLAT                  259
#define IDC_BUTTON_MIDISCALE4           259
#define IDC_SPIN_GROOVE                 259
#define IDC_TEST                        260
#define IDC_BUTTON_INVERT3              260
#define IDC_CHORD_KEYS                  261
#define IDC_BUTTON_MIDISCALE3           261
#define IDC_BUTTON_INVERT2              261
#define IDC_SCALE_KEYS                  262
#define IDC_BUTTON_INVERT1              262
#define IDD_CHORD_PROPPAGE              263
#define IDC_BUTTON_MIDISCALE2           263
#define IDC_BUTTON_MIDISCALE1           265
#define IDD_ChangeLength                266
#define IDC_BUTTON_SHIFTL3              267
#define IDC_BUTTON_SHIFTL2              268
#define IDC_BUTTON_SHIFTL1              269
#define IDC_BUTTON_SHIFTR1              270
#define IDC_BUTTON_SHIFTR2              271
#define IDR_ACCELERATOR1                271
#define IDC_BUTTON_SHIFTR3              272
#define IDR_CHORDPROP                   272
#define IDC_BUTTON_SHIFTR4              273
#define IDD_ILLEGALCHORD                273
#define IDC_BUTTON_PLAY4                274
#define IDD_DLG_GUID                    274
#define IDC_BUTTON_PLAY3                275
#define IDC_BUTTON_PLAY2                276
#define IDC_BUTTON_PLAY1                277
#define IDC_BUTTON_PLAYALL              279
#define IDS_HELP_FILE_EXT               300
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDM_KILLPROPS                   666
#define IDM_CLEARSELECT                 667
#define IDC_DESCRIPTION                 1017
#define IDC_INFO                        1017
#define IDC_BUTTON_MIDICHORD2           2544
#define IDM_PROPERTIES                  32769
#define IDM_CHORD_DELETE                32770
#define IDM_SAVEAS                      32771
#define IDM_CHORD_INSERT                32772
#define IDM_SAVE                        32773
#define IDM_BEGSIGNPOST                 32773
#define ID_TEST                         32774
#define IDM_ENDSIGNPOST                 32774
#define IDM_LOCK_ALL_SCALES             32774
#define IDM_SIGNPOST_INSERT_CHORD       32775
#define IDM_SYNC_ALL_LEVELS             32775
#define IDM_SIGNPOST_ADD_CHORD          32776
#define ID_HELP_CONTENTS                32777
#define IDM_SIGNPOST_DELETE             32780
#define ID_EDIT_PROPERTIES              32783
#define ID_DIATONIC                     32785
#define ID_MAJOR7THS                    32786
#define ID_MINOR7THS                    32787
#define ID_DOM7THS                      32788
#define ID_ALLMAJOR                     32789
#define ID_ALLMINOR                     32790
#define ID_DIATONICTRIAD                32791
#define IDM_RENAME                      32792
#define IDM_DELETE                      32793
#define IDM_HELP_FINDER                 32794
#define ID_COPYCHORD                    32795
#define ID_COPYSCALE                    32796
#define ID_COPYSCALECHORD               32797
#define ID_CLEARCHORDSCALE              32798
#define ID_COPY_CHORD1                  32799
#define ID_COPY_CHORD2                  32800
#define ID_COPY_CHORD3                  32801
#define ID_COPY_CHORDALL                32802
#define ID_COPY_SCALE1                  32803
#define ID_INSERT                       32804
#define ID_COPY_SCALE2                  32804
#define ID_COPY_SCALE3                  32805
#define IDM_DRAG_MOVE                   32806
#define ID_COPY_CHORDSCALE1             32806
#define IDM_DRAG_CANCEL                 32807
#define ID_COPY_CHORDSCALE2             32807
#define IDM_DRAG_COPY                   32808
#define ID_COPY_CHORDSCALE3             32808
#define ID_COPY_CHORDSCALEALL           32809
#define ID_CLEAR_CHORDSCALE2            32811
#define ID_CLEAR_CHORDSCALE3            32812
#define ID_CLEAR_CHORDSCALE4            32813
#define ID_CLEAR_CHORDSCALEALL          32814
#define ID_COPY_SCALEALL                32815
#define ID_CLEAR_CHORDSCALE1            32816
#define ID_COPY_CHORD4                  32817
#define ID_COPY_SCALE4                  32818
#define ID_COPY_CHORDSCALE4             32819
#define ID_UNDO                         42784
#define ID_REDO                         42785
#define ID_CUT                          42786
#define ID_PASTE                        42788
#define ID_SELECTALL                    42790
#define ID_DELETE                       42795
#define ID_PROPERTIES                   42796
#define IDS_COPYSIGNPOST                57345
#define IDS_LENGTHTOOSMALL              57346
#define IDS_LENGTHTOOLARGE              57347
#define IDS_NOSTYLE                     57348
#define IDS_NOCHORD                     57349
#define IDS_REDO                        57662
#define IDS_UNDO                        57663
#define IDS_REDOACCEL                   57664
#define IDS_UNDOACCEL                   57665
#define IDS_UNDO_CHORDMAPLENGTH         57666
#define IDS_UNDO_NAMECHANGE             57667
#define IDS_UNDO_REFNAME                57668
#define IDS_UNDO_DESCR                  57669
#define IDS_UNDO_EDITMODE               57670
#define IDS_UNDO_TIMESIG                57671
#define IDS_UNDO_SCALEPAT               57672
#define IDS_UNDO_AUDSTYLE               57673
#define IDS_UNDO_GROOVE                 57674
#define IDS_UNDO_KEY                    57675
#define IDS_UNDO_SignpostNameChange     57676
#define IDS_UNDO_InsertSignpostChord    57677
#define IDS_UNDO_SignpostRemoveFromGroup 57678
#define IDS_UNDO_SignpostAddToGroup     57679
#define IDS_UNDO_ChordNameChange        57680
#define IDS_UNDO_ChordPatternChange     57681
#define IDS_UNDO_ScalePatternChange     57682
#define IDS_UNDO_InvertPatternChange    57683
#define IDS_UNDO_ChordRootChange        57684
#define IDS_UNDO_ScaleRootChange        57685
#define IDS_UNDO_UseFlat                57686
#define IDS_UNDO_SignpostAddCadenceChord 57687
#define IDS_UNDO_PasteSignpostChord     57689
#define IDS_UNDO_DeleteSignpostChord    57690
#define IDS_UNDO_CHORDEDIT              57691
#define IDS_UNDO_DeleteCadenceChord     57692
#define IDS_UNDO_Personality_AUTHOR     57693
#define IDS_UNDO_Personality_COPYRIGHT  57694
#define IDS_UNDO_Personality_INFO       57695
#define IDS_UNDO_Personality_SUBJECT    57696
#define IDS_UNDO_Personality_VERSION    57697
#define IDS_PERSONALITYUNDO_HEADER      57698
#define IDS_CHORDMAPUNDO_HEADER         57699
#define IDS_SIGNPOSTUNDO_HEADER         57700
#define IDS_DELETE_UNDO                 57701
#define IDS_INSERT_UNDO                 57702
#define IDS_PASTE_UNDO                  57703
#define IDS_CUT_UNDO                    57704
#define IDS_ERR_IMARUNTIME              57705
#define IDS_LEVEL                       57706
#define IDS_UNDO_SWITCHTOFIXED          57707
#define IDS_UNDO_SWITCHTOVAR            57708
#define IDS_ILLEGALCHORD                57709
#define IDS_ILLEGALCHORD2               57710
#define IDS_DONTWARN                    57711
#define IDS_UNDO_GUID                   57712
#define IDS_ILLEGALCHORD3               57715

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        274
#define _APS_NEXT_COMMAND_VALUE         32820
#define _APS_NEXT_CONTROL_VALUE         260
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\PropPageMgr.cpp ===
// CChordPropPageMgr : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr property page

short CChordPropPageMgr::sm_nActiveTab = 0;

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


CChordPropPageMgr::CChordPropPageMgr( IDMUSProdFramework* pIFramework )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( pIFramework != NULL );
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pChordScalePropPage = NULL;
	m_pChordInversionPropPage = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CChordPropPageMgr::~CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordScalePropPage )
	{
		m_pChordScalePropPage->Release();
		m_pChordScalePropPage = 0;
	}
	if(m_pChordInversionPropPage)
	{
		m_pChordInversionPropPage->Release();
		m_pChordInversionPropPage = 0;
	}
	if ( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CChordPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_PROPPAGE_CHORD );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CChordPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;


	// Add Chord/Scale tab
	if(m_pChordScalePropPage == NULL)
	{
		m_pChordScalePropPage = new CChordScalePropPage( );
	}
	ASSERT(m_pChordScalePropPage);
	if( m_pChordScalePropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pChordScalePropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		// fill in proppagemgr member
		m_pChordScalePropPage->m_pPropPageMgr = this;
		// fill in proppage's conductor member
		if(!m_pChordScalePropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordScalePropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Add ChordInversion tab
	if(m_pChordInversionPropPage == NULL)
	{
		m_pChordInversionPropPage = new CChordInversionPropPage( );
	}
	ASSERT(m_pChordInversionPropPage);
	if( m_pChordInversionPropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pChordInversionPropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
		// fill in proppagemgr member
		m_pChordInversionPropPage->m_pPropPageMgr = this;
		if(!m_pChordInversionPropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordInversionPropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}

/*
/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CChordPropPageMgr::OnRemoveFromPropertySheet( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CChordPropPageMgr::sm_nActiveTab );

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

//	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CChordPropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropPageObject ) 
	{
		CChordScalePropPageData chordscalePropPageData;
		CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;

		if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
		{
			m_pChordScalePropPage->SetChordData( pChordScalePropPageData );
			m_pChordInversionPropPage->SetChordData( pChordScalePropPageData );
			return S_OK;
		}
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\rowcursor.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "rowcursor.h"


/////////////////////////////////////////////////////////////////////////////
// CRowCursor properties

/////////////////////////////////////////////////////////////////////////////
// CRowCursor operations
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\rowcursor.h ===
#if !defined(AFX_ROWCURSOR1_H__29387B4D_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
#define AFX_ROWCURSOR1_H__29387B4D_948E_11D2_BC93_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CRowCursor wrapper class

class CRowCursor : public COleDispatchDriver
{
public:
	CRowCursor() {}		// Calls COleDispatchDriver default constructor
	CRowCursor(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	CRowCursor(const CRowCursor& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ROWCURSOR1_H__29387B4D_948E_11D2_BC93_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Splitter.h ===
#ifndef __SPLITTER_H__
#define __SPLITTER_H__

// Splitter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSplitter class

class CSplitter : public CWnd
{
protected:
   CRect	m_rcFirstPane;
   CRect	m_rcSecondPane;

   CWnd		*m_pFirstPane;
   CWnd		*m_pSecondPane;

   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   CWnd		*m_pParent;
   int		m_nWidth;

public:
   CSplitter();
   BOOL Create(CWnd *pParent, RECT *rect = NULL);
   RECT	GetFirstPaneRect();
   RECT	GetSecondPaneRect();
   void SetFirstPane( CWnd *pPane );
   void SetSecondPane( CWnd *pPane );
   void SetTracker(RECT& rect)
   {
	   m_rcTrack = rect;
   }

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CSplitter();

protected:
   //{{AFX_MSG(CSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __SPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\SignPostDialog.cpp ===
// SignPostDialog.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "SignPostDialog.h"
#include "PersonalityCtl.h"
#include "font.h"
#include "chordio.h"
#pragma warning(default:4201)

#include "DMPPrivate.h"
#include "chorddatabase.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static const int gnHDir = 1;
static const int gnVDir = 0;

int ConvertTwipsToPixels(int nTwips, int dir)
{
	const int nTwipsPerInch = 1440;
	int nPixelsPerInch;
	HDC hDC = ::GetDC(0);
	if(dir == gnHDir) // horiz
	{
		nPixelsPerInch = ::GetDeviceCaps(hDC, LOGPIXELSX);	
	}
	else		// vert
	{
		nPixelsPerInch = ::GetDeviceCaps(hDC, LOGPIXELSY);
	}
	int result =  (nTwips * nPixelsPerInch) / nTwipsPerInch;
	// round up, just like the telcos
	if( (result * nTwipsPerInch) < (nTwips * nPixelsPerInch) )
	{
		result++;
	}
	return result;
}



/////////////////////////////////////////////////////////////////////////////
// CSignPostDialog dialog


CSignPostDialog::CSignPostDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CSignPostDialog::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	EnableAutomation();

	m_bInitialized = false;
	
	m_pChordDialog = NULL;
	m_ptLastMouse.x = m_ptLastMouse.y = 1;

	m_ptXLastMousePixels = 0;
	m_ptYLastMousePixels = 0;

	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pIFramework = NULL;

	m_pIPersonality = NULL;
	m_pPersonalityCtrl = NULL;


	m_nLastEdit = 0;
	m_fDragging = FALSE;


	m_pITargetDataObject = 0;
	m_pISourceDataObject = 0;
	m_bInternalDrop = false;
	m_pDragImage = 0;

	m_bIgnoreClick = false;
	m_pDragChord = 0;
	
	
	m_pCopyDataObject = 0;

	m_cfChordList = 0;
	m_cfChordMapList = 0;

	m_startDragPosition.x = 0;
	m_startDragPosition.y = 0;
	
	AddRef();

	//{{AFX_DATA_INIT(CSignPostDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

void CSignPostDialog::OnFinalRelease()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.
	
	CDialog::OnFinalRelease();
}

void CSignPostDialog::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSignPostDialog)
	DDX_Control(pDX, IDC_GRID, m_Grid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSignPostDialog, CDialog)
	//{{AFX_MSG_MAP(CSignPostDialog)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSignPostDialog, CDialog)
	//{{AFX_DISPATCH_MAP(CSignPostDialog)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISignPostDialog to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {2B651785-E908-11D0-9EDC-00AA00A21BA9}
static const IID IID_ISignPostDialog =
{ 0x2b651785, 0xe908, 0x11d0, { 0x9e, 0xdc, 0x0, 0xaa, 0x0, 0xa2, 0x1b, 0xa9 } };

BEGIN_INTERFACE_MAP(CSignPostDialog, CDialog)
	INTERFACE_PART(CSignPostDialog, IID_ISignPostDialog, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSignPostDialog message handlers

BOOL CSignPostDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
	m_cfChordMapList = RegisterClipboardFormat (CF_CHORDMAP_LIST);

	m_Grid.SetCols( MAX_COLUMNS );
	m_Grid.SetRow( 0 );
//	m_Grid.SetHighLight(2);	// highlight selected only when grid has focus

	for( int nCol = 0; nCol < MAX_COLUMNS; nCol++ )
	{
		m_Grid.SetColWidth(	nCol,
									( (nCol > COL_SELECT) && (nCol < COL_1) )? 600 : 250 );

		// Set Column headers
		CString	csHeader;
		m_Grid.SetCol( nCol );

		m_Grid.SetCellTextStyle( 1 ); // Raised
		
		if( nCol == COL_SELECT )
		{
			m_Grid.SetCellFontName( "Symbol" );
			csHeader.Format( "" );
		}
		else if ( nCol == COL_C1 ) csHeader = "C1";
		else if ( nCol == COL_C2 ) csHeader = "C2";
		else if ( nCol == COL_SP ) csHeader = "SP";
		else if ( nCol == COL_1 ) csHeader = "1";
		else if ( nCol == COL_2 ) csHeader = "2";
		else if ( nCol == COL_3 ) csHeader = "3";
		else if ( nCol == COL_4 ) csHeader = "4";
		else if ( nCol == COL_5 ) csHeader = "5";
		else if ( nCol == COL_6 ) csHeader = "6";
		else if ( nCol == COL_7 ) csHeader = "7";
		else if ( nCol == COL_A ) csHeader = "A";
		else if ( nCol == COL_B ) csHeader = "B";
		else if ( nCol == COL_C ) csHeader = "C";
		else if ( nCol == COL_D ) csHeader = "D";
		else if ( nCol == COL_E ) csHeader = "E";
		else if ( nCol == COL_F ) csHeader = "F";

		m_Grid.SetText( csHeader );
		m_Grid.SetCellAlignment( 4 );	// Centered Horiz.
	}

	m_bInitialized = true;

// Insert all the SignPosts from the SignPost list into the Grid Control
	for(	SignPost *pSignPost = m_pSignPostList->GetHead();
			pSignPost != NULL;
			pSignPost = pSignPost->GetNext() )
	{
		AddSignPostToGrid( pSignPost );
	}

	m_Grid.SetCol(COL_SP);
	m_Grid.SetRow(m_Grid.GetRows()-1);
//	m_Grid.SetCellFontBold(TRUE);
	m_Grid.SetCellFontItalic(TRUE);

	m_Grid.SetTextMatrix(m_Grid.GetRows()-1, COL_SP, "<new>");
	m_Grid.SetCol( 1 );
	m_Grid.SetRow( 1 );

	m_Grid.SetAllowBigSelection(FALSE);

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSignPostDialog::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDialog::OnSize(nType, cx, cy);
	
	ResizeGrid();
}

void CSignPostDialog::SetSignPostListPtr( DWORD pSignPostList )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pSignPostList != NULL );

	// Save a local reference to the CPersonality SignPostList
	m_pSignPostList = (SignPostList *)pSignPostList;
}

BEGIN_EVENTSINK_MAP(CSignPostDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CSignPostDialog)
	ON_EVENT(CSignPostDialog, IDC_GRID, -604 /* KeyUp */, OnKeyUpGrid, VTS_PI2 VTS_I2)
	ON_EVENT(CSignPostDialog, IDC_GRID, -607 /* MouseUp */, OnMouseUpGrid, VTS_I2 VTS_I2 VTS_I4 VTS_I4)
	ON_EVENT(CSignPostDialog, IDC_GRID, -605 /* MouseDown */, OnMouseDownGrid, VTS_I2 VTS_I2 VTS_I4 VTS_I4)
	ON_EVENT(CSignPostDialog, IDC_GRID, 1554 /* OLEDragOver */, OnOLEDragOverGrid, VTS_PDISPATCH VTS_PI4 VTS_PI2 VTS_PI2 VTS_PR4 VTS_PR4 VTS_PI2)
	ON_EVENT(CSignPostDialog, IDC_GRID, 1555 /* OLEDragDrop */, OnOLEDragDropGrid, VTS_PDISPATCH VTS_PI4 VTS_PI2 VTS_PI2 VTS_PR4 VTS_PR4)
	ON_EVENT(CSignPostDialog, IDC_GRID, -600 /* Click */, OnClickCMSFlexGrid, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CSignPostDialog::OnClickGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CRect rc;
	long lLastRow = m_Grid.GetRows()-1;  // Minus 1 because the first row is the header.
	CString csCellText;
	SignPost *pSignPost=0;

	bool addSignpost = false;

	SetFocus();
	m_pPersonalityCtrl->SetLastFocus(CPersonalityCtrl::SignPost);

	// if user clicks on row 0, deselect and return
//	TRACE("row: %d, col: %d, mouserow: %d, mousecol: %d\n",
//			m_Grid.GetRow(), m_Grid.GetCol(), m_Grid.GetMouseRow(), m_Grid.GetMouseCol());
	if(m_Grid.GetMouseRow() == 0)
	{
		m_Grid.SetRedraw(FALSE);
//		m_Grid.SetCol(COL_SP);
//		m_Grid.SetColSel(COL_SP);
		short	top = static_cast<short>(m_Grid.GetTopRow());
		short	col = static_cast<short>(m_Grid.GetCol());
		m_Grid.SetColSel(col);
		m_Grid.SetRow(top);
		m_Grid.SetRowSel(top);
		m_ptLastMouse.x = col;
		m_ptLastMouse.y = top;
		m_Grid.SetRedraw(TRUE);
		return;
	}

	// if user clicks to right of grid, ignore
	if(m_Grid.GetMouseCol() == m_Grid.GetCols() - 1)
	{
		// verify that this is actually in a col
		int x = ConvertTwipsToPixels(ComputeRowWidth(), gnHDir);
		if(m_ptXLastMousePixels > x)
		{
			m_Grid.SetCol(m_ptLastMouse.x);
			m_Grid.SetColSel(m_ptLastMouse.x);
			m_Grid.SetRow(m_ptLastMouse.y);
			m_Grid.SetRowSel(m_ptLastMouse.y);
			return;
		}
	}

	// if user clicks below the grid, ignore
	if(m_Grid.GetMouseRow() == m_Grid.GetRows() - 1)
	{
		// verify that this is actually in a col
		int y = ConvertTwipsToPixels(ComputeColHeight(), gnVDir);
		if(m_ptYLastMousePixels > y)
		{
			m_Grid.SetCol(m_ptLastMouse.x);
			m_Grid.SetColSel(m_ptLastMouse.x);
			m_Grid.SetRow(m_ptLastMouse.y);
			m_Grid.SetRowSel(m_ptLastMouse.y);
			return;
		}
	}


	// user has selected a multi-cell region,  If first cell is a signpost group box, then toggle
	// its state and set all signpost group boxes in region to toggled state.
	if( (m_Grid.GetRow() != m_Grid.GetRowSel()) || m_Grid.GetCol() != m_Grid.GetColSel())
	{
		if(	ToggleSignpostGroupBoxes() )
			goto SyncWithEngine;
		else
			return;
	}


//	TRACE( "OnClickGrid\n" );

	m_Grid.GetClientRect(rc);
	TRACE("(%d,%d),(%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);

	//NormalizeRowCol();

	// Add new SignPost to Grid
	if( m_ptLastMouse.y == lLastRow )
	{
		if( FAILED(AddSignPostToList()) )
		{
			MessageBox( "Unable to add new SignPost.", "ChordMap Designer", MB_ICONEXCLAMATION );
			goto ShowProps;
		}
		else
		{
			addSignpost = true;
		}
		// make sure that signpost chord is selected for SetSelected
		m_ptLastMouse.x = COL_SP;
		m_Grid.SetCol(COL_SP);
		m_Grid.SetColSel(COL_SP);
		pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));

		// add a new signpost, do orphan check
		m_pIPersonality->Link2CM(pSignPost);
		m_pIPersonality->Link2SP(pSignPost);
		m_pIPersonality->RefreshChordMap();
		UpdateOrphanStatus(true);

		goto ShowProps;
	}

	// If user selected 1 through F then select/unselect the cell state and update the chord
	if( (m_ptLastMouse.x >= COL_1) && (m_ptLastMouse.x <= COL_F) && (m_ptLastMouse.y != m_Grid.GetRows()-1) )
	{
		csCellText = m_Grid.GetText();

		if( csCellText == "X" )
		{
			SendEditNotification(IDS_UNDO_SignpostRemoveFromGroup);
			m_Grid.SetText( " " );
			SetAcceptChords( m_ptLastMouse.y, m_ptLastMouse.x, FALSE );
		}
		else
		{
			SendEditNotification(IDS_UNDO_SignpostAddToGroup);
			m_Grid.SetText( "X" );
			SetAcceptChords( m_ptLastMouse.y, m_ptLastMouse.x );
		}

		goto SyncWithEngine;
	}


	// If user is selecting a row then return
	if( m_ptLastMouse.x == COL_SELECT ) return;

	pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));

	if( m_ptLastMouse.x == COL_C1 || m_ptLastMouse.x == COL_C2)
	{
		ASSERT(pSignPost);
//		pSignPost->m_dwflags |= m_ptLastMouse.x == COL_C1 ? SPOST_CADENCE1 : SPOST_CADENCE2;
		UpdateCadenceChord(m_ptLastMouse.y, m_ptLastMouse.x, true);
	}
ShowProps:
	// Add this Chord to the template Property Chord.
	ASSERT( pSignPost != NULL );
	SetSelectedChord( pSignPost, m_ptLastMouse.x );
	DMusicSync(CPersonality::syncAudition);
	PreparePropChord( pSignPost );

//	RELEASE(m_pPropPageMgr);
//	m_pPropPageMgr = NULL;

	if(addSignpost || IsPropPageShowing())
	{
		if( SUCCEEDED(OnShowProperties()) )
		{
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
		}
	}
	m_pIPersonality->Modified() = TRUE;

	SetFocus();
return;

SyncWithEngine:
	if( m_pIPersonality )
	{
		m_pIPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
		m_pIPersonality->Modified() = TRUE;
	}
}

HRESULT CSignPostDialog::SetSelectedChord( SignPost* pSignPost, int nCol )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ChordSelection* pSelectedChord = NULL;

	ASSERT( pSignPost != NULL );
	ASSERT( m_pSignPostList != NULL );

	for( SignPost *pSPTemp = m_pSignPostList->GetHead(); pSPTemp != NULL; pSPTemp = pSPTemp->GetNext() )
	{
		pSPTemp->m_cadence[0].KeyDown() = false;
		pSPTemp->m_cadence[1].KeyDown() = false;
		pSPTemp->m_chord.KeyDown() = false;
	}

	if( nCol == COL_C1 )
	{
		pSignPost->m_cadence[0].KeyDown() = true;
		pSelectedChord = &(pSignPost->m_cadence[0]);
	}
	else if( nCol == COL_C2 )
	{
		pSignPost->m_cadence[1].KeyDown() = true;
		pSelectedChord = &(pSignPost->m_cadence[1]);
	}
	else if( nCol == COL_SP )
	{
		pSignPost->m_chord.KeyDown() = true;
		pSelectedChord = &(pSignPost->m_chord);
	}

	if(pSelectedChord)
	{
		m_pIPersonality->SetChordChanges(*dynamic_cast<DMPolyChord*>(pSelectedChord));
	}

	return S_OK;
}

HRESULT CSignPostDialog::AddSignPostToList()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSignPostList != NULL );	// The SignPost list has to have already been initialized by a call to
										// CSignPostDialog::SetSignPostListPtr().

	// Add new SignPost to internal list.
	SignPost *pSignPost = new SignPost;
	pSignPost->m_chord = m_pIPersonality->GetKeyChord();
	if( pSignPost == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Default with Cadence Chords turned off.
	pSignPost->m_dwflags ^= (SPOST_CADENCE1 | SPOST_CADENCE2);

	SendEditNotification(IDS_UNDO_InsertSignpostChord);


	// Insert the new SignPost into the list
	m_pSignPostList->AddTail( pSignPost );

	// Insert the new SignPost into the Grid.
	AddSignPostToGrid( pSignPost );

	// Download new Personality to the Engine.
	if( m_pIPersonality != NULL )
	{
		m_pIPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
		m_pIPersonality->Modified() = TRUE;
	}

	ResizeGrid();

	return S_OK;
}

HRESULT CSignPostDialog::SetAcceptChords( long lRow, long lCol, BOOL bSet )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( lRow != 0 ); // The header row does not contain SignPost information!

	SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( lRow ));
	ASSERT( pSignPost != NULL );

	DWORD lFlag = 0;

	if( lCol == COL_1 )	lFlag = SP_1;
	else if ( lCol == COL_A ) lFlag = SP_A;
	else if ( lCol == COL_B ) lFlag = SP_B;
	else if ( lCol == COL_C ) lFlag = SP_C;
	else if ( lCol == COL_D ) lFlag = SP_D;
	else if ( lCol == COL_E ) lFlag = SP_E;
	else if ( lCol == COL_F ) lFlag = SP_F;
	else if ( lCol == COL_1 ) lFlag = SP_1;
	else if ( lCol == COL_2 ) lFlag = SP_2;
	else if ( lCol == COL_3) lFlag = SP_3;
	else if ( lCol == COL_4) lFlag = SP_4;
	else if ( lCol == COL_5) lFlag = SP_5;
	else if ( lCol == COL_6) lFlag = SP_6;
	else if ( lCol == COL_7) lFlag = SP_7;


	if( bSet == FALSE )
	{
		pSignPost->m_chords &= ~lFlag;
	}
	else
	{
		pSignPost->m_chords |= lFlag;
	}

	if( m_pIPersonality != NULL )
	{
		m_pIPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
		m_pIPersonality->Modified() = TRUE;
	}

	return S_OK;
}

HRESULT CSignPostDialog::UpdateSignPostChord( int row )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	SignPost *pSignPost = (SignPost*)(m_Grid.GetRowData(row));

	m_Grid.SetRow( row );
	m_Grid.SetCol(COL_SP);

	// Add new fields to the Grid
	CString csBuffer,
			csWrkBuffer;
	char	szRootName[30];

// Store SignPost names.
	csBuffer = "";
	pSignPost->m_chord.RootToString(szRootName);
	csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_chord.Name() );
	csBuffer += csWrkBuffer;

	//UpdateSignPostChord is currently only called from paste: however if we are overwriting an existing
	// signpost then we may be orphaning chords, so we need to relink EVERYTHING!
	m_pIPersonality->LinkAll(false);
	

	m_Grid.SetTextMatrix(row, COL_SP, csBuffer);
	// set current sp font depending on whether its an orphan
	UpdateOrphanStatus(true, pSignPost);


	return S_OK;
}


HRESULT CSignPostDialog::AddSignPostToGrid( SignPost* pSignPost, int nRow)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pSignPost != NULL );

	if( pSignPost == NULL )
	{
		return E_INVALIDARG;
	}

	int nIndex = m_Grid.GetRows() - 1;
//	m_Grid.SetRow( 1 );	// Always add to the first Row of the Grid so long lists can be maintained easier.
	m_Grid.SetRow( nIndex );

	// Add new fields to the Grid
	CString csBuffer,
			csWrkBuffer;
	char	szRootName[30];

// Store Cadence and SignPost names.
	csBuffer = "\t";
	if( pSignPost->m_dwflags & SPOST_CADENCE1 )
	{
		pSignPost->m_cadence[0].RootToString(szRootName);
		csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[0].Name() );
		csBuffer += csWrkBuffer;
	}
	csBuffer += "\t";
	if( pSignPost->m_dwflags & SPOST_CADENCE2 )
	{
		pSignPost->m_cadence[1].RootToString(szRootName);
		csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[1].Name() );
		csBuffer += csWrkBuffer;
	}

	pSignPost->m_chord.RootToString(szRootName);
	csWrkBuffer.Format( "\t%s %s", szRootName, pSignPost->m_chord.Name() );
	csBuffer += csWrkBuffer;

	csBuffer += "\t"; if( pSignPost->m_chords & SP_1 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_2 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_3 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_4 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_5 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_6 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_7 ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_A ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_B ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_C ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_D ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_E ) csBuffer += "X";
	csBuffer += "\t"; if( pSignPost->m_chords & SP_F ) csBuffer += "X";

	// Add a new Row to the Grid.
	VARIANT	vt;
	vt.vt = VT_I4;
	V_I4(&vt) = nIndex;
	m_Grid.AddItem( csBuffer, vt );

	// This is how we retrieve the correct SignPost from the Grid (we store it's pointer).
	m_Grid.SetRowData( nIndex, (long)pSignPost ); 

	// Horiz Center columns 1 - F
	for( int x = COL_1; x <= COL_F; x++ )
	{
		m_Grid.SetCol( x );
		m_Grid.SetCellAlignment( 4 );	// Centered Horiz.
	}
	
	if(nRow != -1)
	{
		m_ptLastMouse.x = COL_SP;
		m_ptLastMouse.y = static_cast<short>(nRow);
	}

	// set font according to orphan state
	m_Grid.SetCol(COL_SP);
	m_Grid.SetRow(nIndex);
	UpdateOrphanStatus(false, pSignPost);

	// added from mouse
	m_Grid.SetCol( m_ptLastMouse.x );
	m_Grid.SetColSel( m_ptLastMouse.x );

	nIndex = m_Grid.GetRows() - 2;
	if( m_ptLastMouse.y < nIndex )
	{
		nIndex = m_ptLastMouse.y;
	}
	m_Grid.SetRow( nIndex );
	m_Grid.SetRowSel( nIndex );

	int top = m_Grid.GetTopRow();
	m_Grid.SetTopRow(top+1);
	return S_OK;
}


void CSignPostDialog::OnKeyUpGrid(short FAR* KeyCode, short /*Shift*/) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

//	TRACE( "OnKeyUpGrid\n" );

	long nRowCount = m_Grid.GetRows();
	long lMouseCol = m_Grid.GetColSel();
	long lMouseRow = m_Grid.GetRowSel();
	bool bMove = false;

	switch( *KeyCode )
	{
		case VK_UP:
			bMove = true;
			if(lMouseRow > 1)
			{
				m_ptLastMouse.y--;
			}
			else
			{
				m_ptLastMouse.y = static_cast<short>(nRowCount-1);
			}
			break;
		case VK_DOWN:
			bMove = true;
			if(lMouseRow < nRowCount - 1)
			{
				m_ptLastMouse.y++;
			}
			else
			{
				m_ptLastMouse.y = 1;
			}
			break;
		case VK_LEFT:
			bMove = true;
			if(lMouseCol > 1)
			{
				m_ptLastMouse.x--;
			}
			else
			{
				m_ptLastMouse.x = MAX_COLUMNS - 1;
			}
			break;
		case VK_RIGHT:
			bMove = true;
			if(lMouseCol < MAX_COLUMNS - 1)
			{
				m_ptLastMouse.x++;
			}
			else
			{
				m_ptLastMouse.x = 1;
			}
			break;
		case VK_INSERT:
			m_ptLastMouse.y = static_cast<short>(lMouseRow);
//			m_ptLastMouse.x = COL_SP;
			OnClickGrid();
			break;
		case VK_DELETE:
			
			SignPost *pSignPost = (SignPost*)(m_Grid.GetRowData(m_ptLastMouse.y));

			// This is the last Entry in the Grid (ie, the Add row)
			if( pSignPost == NULL ) return;
 
			// Delete entire row if the entire row is selected
			if( m_ptLastMouse.x == COL_SELECT || m_ptLastMouse.x == COL_SP )
			{
				SendEditNotification(IDS_UNDO_DeleteSignpostChord);
				// Remove the SignPost from the list.
				m_Grid.RemoveItem( m_ptLastMouse.y );

				// Delete SignPost from the SignPost list.
				m_pSignPostList->Remove( pSignPost );
				delete pSignPost;
				m_pIPersonality->LinkAll(true);
				ResizeGrid();
				ShowPropPage(FALSE);
			}
			// or.. Remove (Inactivate) Cadence Chord 1 if it is selected
			else if( m_ptLastMouse.x == COL_C1 )
			{
				SendEditNotification(IDS_UNDO_DeleteCadenceChord);
				pSignPost->m_dwflags ^= SPOST_CADENCE1;
				m_Grid.SetText( "" );
				ShowPropPage(FALSE);
			}
			// or.. Remove (Inactivate) Cadence Chord 2 if it is selected
			else if( m_ptLastMouse.x == COL_C2 )
			{
				SendEditNotification(IDS_UNDO_DeleteCadenceChord);
				pSignPost->m_dwflags ^= SPOST_CADENCE2;
				m_Grid.SetText( "" );
				ShowPropPage(FALSE);
			}
			else break;

			if( m_pIPersonality != NULL )
			{
				m_pIPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
				m_pIPersonality->Modified() = TRUE;
			}
			break;
	}
	
	m_Grid.SetCol( m_ptLastMouse.x );
	m_Grid.SetColSel( m_ptLastMouse.x );
	m_Grid.SetRow( m_ptLastMouse.y );
	m_Grid.SetRowSel( m_ptLastMouse.y );

	if(bMove)
	{
		SignPost* pSignPost = NULL;
		if(m_ptLastMouse.x >= COL_C1 && m_ptLastMouse.x <= COL_SP)
		{
			pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));
		}
		if(pSignPost)
		{
			bool bShow = false;
			switch(m_ptLastMouse.x)
			{
			case COL_C1:
				if(pSignPost->m_dwflags & SPOST_CADENCE1)
					bShow = true;
				break;
			case COL_C2:
				if(pSignPost->m_dwflags & SPOST_CADENCE2)
					bShow = true;
				break;
			case COL_SP:
				bShow = true;
				break;
			}
			
			if(bShow)
			{
				// Add this Chord to the template Property Chord.
				ASSERT( pSignPost != NULL );
				SetSelectedChord( pSignPost, m_ptLastMouse.x );
				DMusicSync(CPersonality::syncAudition);
				PreparePropChord( pSignPost );

				if( IsPropPageShowing() )
				{
					if(SUCCEEDED(OnShowProperties()) )
					{
						if( m_pPropPageMgr )
						{
							m_pPropPageMgr->RefreshData();
						}
					}
				}
			}
			else
			{
				ShowPropPage(FALSE);
			}
		}
		else
		{
			ShowPropPage(FALSE);
		}
		SetFocus();
	}
	
}



void CSignPostDialog::NormalizeRowCol() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long lMouseCol = m_Grid.GetMouseCol();
	long lMouseRow = m_Grid.GetMouseRow();
	long lBeginRow = m_Grid.GetRow();
	long lEndRow = m_Grid.GetRowSel();


	// Only allow one row to be selected.
	if( lBeginRow != lEndRow )
	{
		m_Grid.SetRow( lEndRow );
		m_Grid.SetRowSel( lBeginRow );
	}

	// If 'Select' column is selected then highlight entire row
	if( lMouseCol == COL_SELECT )
	{
		m_Grid.SetCol( COL_C1 );
		m_Grid.SetColSel( COL_F );
	}
	// Otherwise force single selection to where the user lifed the mouse button.
	else
	{
		m_Grid.SetCol( lMouseCol );
		m_Grid.SetColSel( lMouseCol );
		m_Grid.SetRow( lMouseRow );
		m_Grid.SetRowSel( lMouseRow );
	}

	// Don't process Row zero (Header) messages.  Instead make it easier for the user
	// to add SignPost Chords by setting the selection to the last row (scrolling as needed).
	if( m_Grid.GetRow() == 0 )
	{
		if( m_Grid.GetRowIsVisible( m_Grid.GetRows()-1 ) == FALSE )
		{
			m_Grid.SetTopRow( m_Grid.GetRows()-1 );
		}
		m_Grid.SetRow( m_Grid.GetRows()-1 );
		m_Grid.SetRowSel( m_Grid.GetRows()-1 );
		m_Grid.SetCol( COL_C1 );
		return;
	}

	//m_ptLastMouse.x = (short)(m_Grid.GetCol());
	//m_ptLastMouse.y = (short)(m_Grid.GetRow());
	m_ptLastMouse.x = (short)lMouseCol;
	m_ptLastMouse.y = (short)lMouseRow;

}

void CSignPostDialog::OnMouseUpGrid(short Button, short /*Shift*/, long x, long y) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_bIgnoreClick)
	{
		m_ptLastMouse.x = static_cast<short>(m_Grid.GetCol());
		m_ptLastMouse.y = static_cast<short>(m_Grid.GetRow());
		m_Grid.SetRowSel(m_ptLastMouse.y);
		m_Grid.SetColSel(m_ptLastMouse.x);
		return;
	}

	long row, col, rowsel, colsel;
	rowsel = m_Grid.GetRowSel();
	colsel = m_Grid.GetColSel();
	row = m_Grid.GetRow();
	col = m_Grid.GetCol();

//	TRACE( "*** OnMouseUpGrid\n" );
	RECT rtGridRect;
	GetClientRect( &rtGridRect );

	int width = rtGridRect.right - rtGridRect.left;
	int height = rtGridRect.bottom - rtGridRect.top;

	TRACE("width = %d, height = %d, x = %d, y = %d\n\n", width, height, x, y);

//	NormalizeRowCol();

	// Dispatch left mouse clicks to OnClickGrid.
	if( Button != 2 )
	{
		OnClickGrid();
		return;
	}
/*
	// Right mouse clicks on the last row are illegal Except for signpost (can paste in a signpost to create a
	// new entry in grid)
	if( m_ptLastMouse.y == m_Grid.GetRows()-1 && 
		!(m_ptLastMouse.x == COL_SP || m_ptLastMouse.x == COL_C1 || m_ptLastMouse.x == COL_C2))
	{
		return;
	}
*/


	SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));

	if(pSignPost)
	{
		SetSelectedChord(pSignPost,  m_ptLastMouse.x);
		PreparePropChord( pSignPost);
	}

	m_Grid.SetCol(m_ptLastMouse.x);
	m_Grid.SetColSel(m_ptLastMouse.x);
	m_Grid.SetRow(m_ptLastMouse.y);
	m_Grid.SetRowSel(m_ptLastMouse.y);



//	TRACE( "Before: x:%ld,y:%ld\n", m_ptLastMouse.x, m_ptLastMouse.y );

	CMenu cMenu;
	col = m_Grid.GetCol();
	row = m_Grid.GetRow();
	// Load the SignPost RMB menu.
	if( cMenu.LoadMenu( MAKEINTRESOURCE(IDR_SIGNPOST_RMENU) ) != 0 )
	{
		CMenu *pSubMenu = cMenu.GetSubMenu(0);
		if(!pSignPost || col != COL_SP)
		{
			pSubMenu->EnableMenuItem(IDM_SIGNPOST_INSERT_CHORD, MF_GRAYED);
		}
		if(pSignPost)
		{
			switch(col)
			{
			case COL_SP:
				break;
			case COL_C1:
				if(!(pSignPost->m_dwflags & SPOST_CADENCE1))
				{
					pSubMenu->EnableMenuItem(IDM_SIGNPOST_DELETE, MF_GRAYED);
					pSubMenu->EnableMenuItem (ID_EDIT_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND));
				}
				break;
			case COL_C2:
				if(!(pSignPost->m_dwflags & SPOST_CADENCE2))
				{
					pSubMenu->EnableMenuItem(IDM_SIGNPOST_DELETE, MF_GRAYED);
					pSubMenu->EnableMenuItem (ID_EDIT_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND));
				}
				break;
			default:
					pSubMenu->EnableMenuItem(IDM_SIGNPOST_DELETE, MF_GRAYED);
					pSubMenu->EnableMenuItem (ID_EDIT_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND));
				break;
			}
		}
		else
		{
			if(col != COL_SP)
			{
				pSubMenu->EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );
			}
			// no signpost
			pSubMenu->EnableMenuItem(IDM_SIGNPOST_DELETE, MF_GRAYED);
			pSubMenu->EnableMenuItem (ID_EDIT_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND));
		}
		if( CanPaste() != S_OK || col > COL_SP)
		{
			pSubMenu->EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );
		}
		if( CanCopy() != S_OK || col > COL_SP)
		{
			pSubMenu->EnableMenuItem (ID_EDIT_COPY, (MF_GRAYED | MF_BYCOMMAND));
		}
		if( CanInsert() != S_OK || col > COL_SP)
		{
			pSubMenu->EnableMenuItem (IDM_SIGNPOST_INSERT_CHORD, (MF_GRAYED | MF_BYCOMMAND));
		}

		if( m_ptLastMouse.y == m_Grid.GetRows()-1 || col > COL_SP)
		{
			pSubMenu->EnableMenuItem (ID_EDIT_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND));
		}
		if( pSubMenu != NULL )
		{
			POINT ptMouse = {x, y};
			ClientToScreen( &ptMouse );

			MSG	msg;
			if( pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON, (int)(ptMouse.x), (int)(ptMouse.y),
										  this ) != 0 )
			{
				m_bIgnoreClick = true;
				::PeekMessage( &msg, m_Grid.GetSafeHwnd(), 0, 0, PM_REMOVE ); // Remove the last mouse click msg from the queue.
			}
		}
	}
}

#include "ChordDialog.h"
BOOL CSignPostDialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( (WORD)wParam )
	{
		case IDM_SIGNPOST_INSERT_CHORD:
			TRACE( "Sending WM_INSERT_CHORD\n" );
			if( (m_pChordDialog != NULL) && (m_ptLastMouse.y != m_Grid.GetRows()-1) )
			{				
				SignPost		*pSignPost = NULL;
				ChordSelection	*pChord = NULL;
				DWORD			dwFlags = 0;
				
				ASSERT( m_pChordDialog->m_pChordMapStrip != NULL );

				pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));
				ASSERT( pSignPost != NULL );

				switch( m_ptLastMouse.x )
				{
					// todo: replace these direct calls into chordmapstrip with window messages
					case COL_C1:
						if( pSignPost->m_dwflags & SPOST_CADENCE1 )
						{
							pChord = &(pSignPost->m_cadence[0]);
							m_pChordDialog->m_pChordMapStrip->OnWMMessage(	WM_INSERT_CHORD, CE_END,
																			(LPARAM)pChord, 0, 0 );
						}
						break;
					case COL_C2:
						if( pSignPost->m_dwflags & SPOST_CADENCE2 )
						{
							pChord = &(pSignPost->m_cadence[1]);
							m_pChordDialog->m_pChordMapStrip->OnWMMessage(	WM_INSERT_CHORD, CE_END,
																			(LPARAM)pChord, 0, 0 );
						}
						break;
					case COL_SP:
						pChord = &(pSignPost->m_chord);
						m_pChordDialog->m_pChordMapStrip->OnWMMessage(	WM_INSERT_CHORD, CE_START,
																		(LPARAM)pChord, 0, 0 );

						m_pChordDialog->m_pChordMapStrip->OnWMMessage(	WM_INSERT_CHORD, CE_END,
																		(LPARAM)pChord, 0, 0 );
						dwFlags = CE_START | CE_END;
						break;
					default:
						TRACE( "Invalid attempt to insert Chord into ChordMap.\n" );
						return FALSE;
				}


				// since we just inserted a signpost chord in chordmap, we know they're matched!
				// but use Link functions so that other matching chords are set
				m_pIPersonality->Link2CM(pSignPost);
				m_pIPersonality->Link2SP(pSignPost);
				m_pIPersonality->RefreshChordMap();
				UpdateOrphanStatus(true, pSignPost);
//				m_Grid.Refresh();	// don't need: done by UpdateOrphanStatus

				if( m_pIPersonality != NULL )
				{
					DMusicSync(CPersonality::syncPersonality + CPersonality::syncAudition);
					m_pIPersonality->Modified() = TRUE;
					SetSelectedChord( pSignPost, m_ptLastMouse.x );
					HRESULT hr = PreparePropChord( pSignPost );
					
					if(hr == S_OK && IsPropPageShowing() )
					{
						if(SUCCEEDED(OnShowProperties()) )
						{
							if( m_pPropPageMgr )
							{
								m_pPropPageMgr->RefreshData();
							}
						}
					}
					else
					{
						ShowPropPage(FALSE);
					}
					SetFocus();
				}
				return TRUE;
			}
			return FALSE;
		case IDM_SIGNPOST_ADD_CHORD:
			AddSignPostToList();
			return TRUE;
		case IDM_SIGNPOST_DELETE:
			{
				short x = VK_DELETE;
				OnKeyUpGrid(&x, 0);
				return TRUE;
			}
		case ID_EDIT_COPY:
			{
				HRESULT hr = Copy();
				return SUCCEEDED(hr) ? TRUE : FALSE;
			}
		case ID_EDIT_PASTE:
			{
				return SUCCEEDED(Paste()) ? TRUE : FALSE;
			}
		case ID_EDIT_PROPERTIES:
			if(m_ptLastMouse.y < static_cast<short>(m_Grid.GetRows() - 1)
				&& m_ptLastMouse.y > 0)
			{
				long row = m_ptLastMouse.y;
				long col = m_ptLastMouse.x;
				bool bShow = false;
				SignPost* pSignPost = 0;
				if(col > COL_SP)
					col = COL_SP;	// make sure that we select a chord rather than a group checkbox
				// make sure that chord is selected
				for(	pSignPost = m_pSignPostList->GetHead();
						pSignPost != NULL && !bShow;
						pSignPost = pSignPost->GetNext() )
				{
					long testrow = GetRowFromRowData(reinterpret_cast<DWORD>(pSignPost));
					if(testrow == row)
					{
						ASSERT( pSignPost != NULL );
						SetSelectedChord( pSignPost, col );
						PreparePropChord( pSignPost );
						bShow = true;
						break;
					}
				}

				if(bShow)
				{
					if( SUCCEEDED(OnShowProperties()) )
					{
						if( m_pPropPageMgr )
						{
							m_pPropPageMgr->RefreshData();
						}
					}
				}

				SetFocus();
				return TRUE;
			}
			return FALSE;
			break;
		default:
			ASSERT( FALSE ); // A new menu item has been added to the popup menu but no handler defined.
	}

	return CDialog::OnCommand(wParam, lParam);
}

 
void CSignPostDialog::InitializeDialog( CChordDialog* pChordDialog, CPersonality* pPersonality, CPersonalityCtrl* const pCtl )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pChordDialog = pChordDialog;
	m_pPersonalityCtrl = pCtl;

// set m_pJazzFramework to the jazz framework pointer for Property Page
	if( (m_pIFramework = m_pChordDialog->m_pPersonality->m_pComponent->m_pIFramework) != NULL )
	{
		m_pIFramework->AddRef();
	}

	m_pIPersonality = pPersonality;
	m_pIPersonality->m_pSignPostDlg = this;
	m_pIPersonality->AddRef();
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CSignPostDialog::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)*ppData;

	pChordScalePropPageData->m_pPropChord = &m_SelectedChord;

	if( m_pChordDialog
	&&  m_pChordDialog->m_pPersonality )
	{
		pChordScalePropPageData->m_fLockAllScales = m_pChordDialog->m_pPersonality->m_fLockAllScales;
		pChordScalePropPageData->m_fSyncLevelOneToAll = m_pChordDialog->m_pPersonality->m_fSyncLevelOneToAll;
	}
	else
	{
		pChordScalePropPageData->m_fLockAllScales = true;
		pChordScalePropPageData->m_fSyncLevelOneToAll = true;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostDialog::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)pData;
	CPropChord* pNewChord = pChordScalePropPageData->m_pPropChord;

	BOOL fRefresh = FALSE;

	if( m_pChordDialog
	&&  m_pChordDialog->m_pPersonality )
	{
		if( pChordScalePropPageData->m_fLockAllScales != m_pChordDialog->m_pPersonality->m_fLockAllScales )
		{
			fRefresh = TRUE;
			SendEditNotification( IDS_UNDO_LOCK_SCALES );	
			m_pChordDialog->m_pPersonality->m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		}
		else if( pChordScalePropPageData->m_fSyncLevelOneToAll != m_pChordDialog->m_pPersonality->m_fSyncLevelOneToAll )
		{
			fRefresh = TRUE;
			SendEditNotification( IDS_UNDO_SYNC_LEVELS );	
			m_pChordDialog->m_pPersonality->m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
		}
		else
		{
			SendEditNotification(IDS_UNDO_CHORDEDIT);
			ChordSelection *pSelectedChord = NULL; // the found chord.
			int	nCol = COL_SELECT;

			for(	SignPost *pSignPost = m_pSignPostList->GetHead();
					pSignPost != NULL;
					pSignPost = pSignPost->GetNext() )
			{
				// Check to see if we found the SignPost, or one of it's cadence
				// chords, that is selected.
				if( pSignPost->m_chord.KeyDown() == 1 )
				{
					nCol = COL_SP;
					pSelectedChord = &(pSignPost->m_chord);
					break;
				}
				
				if( pSignPost->m_cadence[0].KeyDown() == 1 )
				{
					if( !(pSignPost->m_dwflags & SPOST_CADENCE1) ) return E_FAIL;
					nCol = COL_C1;
					pSelectedChord = &(pSignPost->m_cadence[0]);
					break;
				}
				
				if( pSignPost->m_cadence[1].KeyDown() == 1 )
				{
					if( !(pSignPost->m_dwflags & SPOST_CADENCE2) ) return E_FAIL;
					nCol = COL_C2;
					pSelectedChord = &(pSignPost->m_cadence[1]);
					break;
				}
			}

			// Didn't find the Selected chord in the list.  This is an internal selection
			// or list management error.
			if( pSignPost == NULL )
			{
				ASSERT( 0 );
				return E_FAIL;
			}


			// Only refresh if UI elements have changed.
			// this will need to be updated when chord props can edit polychords
			int iRoot = pSelectedChord->RootIndex();


			// Only refresh if UI elements have changed.
			fRefresh = (pSelectedChord->SubChord(iRoot)->ChordRoot() != pNewChord->Base()->ChordRoot() 
									|| strcmp(pSelectedChord->Name(), pNewChord->Name() )
									|| pSelectedChord->SubChord(iRoot)->UseFlat() != pNewChord->Base()->UseFlat());

			DWORD dwChangedFlags[DMPolyChord::MAX_POLY];
			DWORD dwEditFlags = 0;	// used to determine what notifications (for undo) to send
			bool bStructureChange = false;

			for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
			{
				DMChord* pDMFrom = pNewChord->SubChord(i);
				DMChord* pDMTo = pSelectedChord->SubChord(i);

				if(i == iRoot)
				{
					bStructureChange = (pDMFrom->ChordRoot() != pDMTo->ChordRoot());
				}

				bStructureChange = bStructureChange || (pDMFrom->ChordPattern() != pDMTo->ChordPattern());

				dwChangedFlags[i] = ~pNewChord->GetUndetermined(i);
				if (dwChangedFlags[i] & UD_NAME)
				{
					dwEditFlags |= UD_NAME;
					strcpy(pSelectedChord->Name(), pNewChord->Name());
				}
				if (dwChangedFlags[i] & UD_CHORDPATTERN)
				{
					dwEditFlags |= UD_CHORDPATTERN;
					pDMTo->ChordPattern() = pDMFrom->ChordPattern();
				}
				if (dwChangedFlags[i] & UD_SCALEPATTERN)
				{
					dwEditFlags |= UD_SCALEPATTERN;
					pDMTo->ScalePattern() = pDMFrom->ScalePattern();
				}
				if(dwChangedFlags[i] & UD_INVERTPATTERN)
				{
					dwEditFlags |= UD_INVERTPATTERN;
					pDMTo->InvertPattern() = pDMFrom->InvertPattern();
				}
				if (dwChangedFlags[i] & UD_CHORDROOT)
				{
					dwEditFlags |= UD_CHORDROOT;
					pDMTo->ChordRoot() = pDMFrom->ChordRoot();
				}
				if(dwChangedFlags[i] & UD_SCALEROOT)
				{
					dwEditFlags |= UD_SCALEROOT;
					pDMTo->ScaleRoot() = pDMFrom->ScaleRoot();
				}
				if (dwChangedFlags[i] & UD_FLAT)
				{
					dwEditFlags |= UD_FLAT;
					pDMTo->UseFlat() = pDMFrom->UseFlat();
				}
				if (dwChangedFlags[i] & UD_LEVELS)
				{
					dwEditFlags |= UD_LEVELS;
					pDMTo->Levels() = pDMFrom->Levels();
				}
				if (dwChangedFlags[i] & UD_INVERT)
				{
					dwEditFlags |= UD_INVERT;
					pDMTo->Bits() &= ~CHORD_INVERT;
					pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_INVERT);
				}
				if (dwChangedFlags[i] & UD_FOUR)
				{
					dwEditFlags |= UD_FOUR;
					pDMTo->Bits() &= ~CHORD_FOUR;
					pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_FOUR);
				}
				if (dwChangedFlags[i] & UD_UPPER)
				{
					dwEditFlags |= UD_UPPER;
					pDMTo->Bits() &= ~CHORD_UPPER;
					pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_UPPER);
				}
			}

			/* TBD: catches too many spurious edits, need to tighten undeterimate flags stuff
			if(dwEditFlags & UD_NAME)
				SendEditNotification(IDS_UNDO_ChordNameChange);
			if(dwEditFlags & UD_CHORDPATTERN)
				SendEditNotification(IDS_UNDO_ChordPatternChange);
			if(dwEditFlags & UD_SCALEPATTERN)
				SendEditNotification(IDS_UNDO_ScalePatternChange);
			if(dwEditFlags & UD_INVERTPATTERN)
				SendEditNotification(IDS_UNDO_InvertPatternChange);
			if(dwEditFlags & UD_CHORDROOT)
				SendEditNotification(IDS_UNDO_ChordRootChange);
			if(dwEditFlags & UD_SCALEROOT)
				SendEditNotification(IDS_UNDO_ScaleRootChange);
			if(dwEditFlags & UD_FLAT)
				SendEditNotification(IDS_UNDO_UseFlat);
				*/

			// if edit of structual components, then relink
			if(nCol == COL_SP && bStructureChange)
			{
				m_pIPersonality->LinkAll(false);
				fRefresh = TRUE;
			}

			m_SelectedChord = *pNewChord;


			m_pIPersonality->SetChordChanges(*dynamic_cast<DMPolyChord*>(pSelectedChord));

			if( fRefresh == TRUE )
			{
				long lRow;
				
				if( (lRow = GetRowFromRowData( (DWORD)pSignPost )) != 0 )
				{
					char szRootName[30];
					CString csBuffer;
					pSelectedChord->RootToString(szRootName);
					csBuffer.Format( "%s %s", szRootName, pSelectedChord->Name() );
					m_Grid.SetCol(nCol);
					m_Grid.SetRow(lRow);
					m_Grid.SetText( csBuffer );
					// set drawing state
					if(nCol == COL_SP)
					{
						if(pSignPost->m_dwflags & SPOST_MATCHED)
						{
							m_Grid.SetCellFontBold(TRUE);
							m_Grid.SetCellFontItalic(FALSE);
						}
						else
						{
							m_Grid.SetCellFontBold(FALSE);
							m_Grid.SetCellFontItalic(TRUE);
						}
					}
				}
			}

			// Refresh the engine with the Personality.
			ASSERT( m_pIPersonality != NULL );
			if( FAILED(m_pIPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality 
																	| CPersonality::syncAudition)) )
			{
				return E_FAIL;
			}
		}
	}

	m_pIPersonality->Modified() = TRUE;

	return S_OK;
}

///////////////////////////////////////////
// GetRowFromRowData( DWORD dwRowData )
//
// Retrieves the row that represents the SignPost given a ptr to the SignPost.
//
// Return:
// lRow == 0 on error.  Row 0 is the header and is not a valid return value.
//
#pragma warning( disable : 4018 )
long CSignPostDialog::GetRowFromRowData( DWORD dwRowData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	long lMaxRows = m_Grid.GetRows();

	for( long lRow = 1; lRow < lMaxRows; lRow++ )
	{
		if( m_Grid.GetRowData( lRow ) == dwRowData ) break;
	}

	// Error, user probably deleted the selected row while in the PropertyPage.
	if( lRow == lMaxRows )
	{
		return 0;
	}

	return lRow;
}
#pragma warning( default : 4018 )
HRESULT STDMETHODCALLTYPE CSignPostDialog::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	ASSERT(m_pIFramework);
	if(m_pIFramework == NULL)
	{
		return E_FAIL;
	}
	if( m_pPropPageMgr == NULL )
	{
		CChordPropPageMgr* pPPM = new CChordPropPageMgr(m_pIFramework);
		if( NULL == pPPM ) return E_OUTOFMEMORY;
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
			return hr;
	}
	//hr = m_pITimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	if( FAILED(hr) )
		return hr;
	hr = E_FAIL;

	// SetPropertyPage
	if( m_pIFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			if( SUCCEEDED(pJPS->SetPageManager( m_pPropPageMgr )))
			{
				m_pPropPageMgr->SetObject((IDMUSProdPropPageObject*)this);
			}
			pJPS->Show(TRUE);
			pJPS->Release();
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSignPostDialog::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostDialog::PreparePropChord( SignPost *pSignPost )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pSignPost != NULL );
	if( pSignPost == NULL ) return E_INVALIDARG;

	ChordSelection *pChord;

	ZeroMemory( &m_SelectedChord, sizeof(m_SelectedChord) );

	if( pSignPost->m_chord.KeyDown() == 1 ) pChord = &(pSignPost->m_chord);
	else if( pSignPost->m_cadence[0].KeyDown() == 1 )
	{
		if( !(pSignPost->m_dwflags & SPOST_CADENCE1) ) return E_FAIL;
		pChord = &(pSignPost->m_cadence[0]);
	}
	else if( pSignPost->m_cadence[1].KeyDown() == 1 )
	{
		if( !(pSignPost->m_dwflags & SPOST_CADENCE2) ) return E_FAIL;
		pChord = &(pSignPost->m_cadence[1]);
	}
	else return E_FAIL; // One Chord from this SignPost must have been selected.

//		ChordToPropChord( &tempChord, pChord );
	dynamic_cast<DMPolyChord&>(m_SelectedChord) = *pChord;


	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostDialog IUnknown implementation for IDMUSProdPropPageObject support

HRESULT CSignPostDialog::QueryInterface( REFIID riid, void** ppv)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppv = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }
	else if (IsEqualIID(riid, IID_IDropSource))
	{
		AddRef();
		*ppv = (IDropSource *) this;
		return S_OK;
	}
/*
	else if (IsEqualIID(riid, IID_IDropTarget))
	{
		AddRef();
		*ppv = (IDropTarget *) this;
		return S_OK;
	}
*/
    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CSignPostDialog::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CSignPostDialog::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

	TRACE( "CSignPostDialog: %ld\n", m_dwRef );

    if( m_dwRef == 0 )
    {
		TRACE( "CSignPostDialog: CSignPostDialog destroyed!\n" );
        delete this;
        return 0;
    }

    return m_dwRef;
}

void CSignPostDialog::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			pJPS->RemovePageManagerByObject( (IDMUSProdPropPageObject*)this );
			pJPS->Release();
		}
	}

	m_pIPersonality->m_pSignPostDlg = 0;	// so personality doesn't call me

	RELEASE( m_pIPersonality );
	m_pIPersonality = NULL;
	RELEASE( m_pPropPageMgr );
	m_pPropPageMgr = NULL;

	RELEASE( m_pIFramework );
	m_pIFramework = NULL;

	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}

	CDialog::OnDestroy();
}



void CSignPostDialog::ResizeGrid()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CWnd* pGrid = GetDlgItem( IDC_GRID );
	if(pGrid)
	{
		RECT sprect;
		GetClientRect(&sprect);
		MapWindowPoints(pGrid, &sprect);
		pGrid->MoveWindow(&sprect);
	}
}


void CSignPostDialog::TwipsToPixels(POINT& pt)
{
	CDC* pdc = m_Grid.GetDC();
//	pdc->CreateCompatibleDC(NULL);
	pdc->SetMapMode( MM_TWIPS );
	pdc->LPtoDP(&pt);
	m_Grid.ReleaseDC(pdc);

}

void CSignPostDialog::PixelsToTwips(POINT& pt)
{
	CDC* pdc = m_Grid.GetDC();
	pdc->SetMapMode( MM_TWIPS );
	pdc->DPtoLP(&pt);
	m_Grid.ReleaseDC(pdc);
}

void CSignPostDialog::RowColFromPoint(POINT& pt, int& row, int& col)
{
	// since positive y is up (normal coordinates), but top is origin
	// make sure y is negative (all offsets into control should be negative)
	pt.y = -abs(pt.y);
	PixelsToTwips(pt);
//	long linewidth = m_Grid.GetGridLineWidth();
//	POINT q;
//	q.x = linewidth;
//	PixelsToTwips(q);

//	long xfudge = 12;
//	long yfudge = 30;
	long xfudge = 0;
	long yfudge = 0;

	long x,y;
	// find col
	int lb,ub;
	for(col = 0; col < m_Grid.GetCols(); col++)
	{
		x = pt.x + xfudge*col;
		lb = m_Grid.GetColPos(col);
		ub = lb + m_Grid.GetColWidth(col);
		if(lb <= x && x < ub)
			break;
	}
	if( col == m_Grid.GetCols())
		col--;
//	pos = 0;
	for(row = 0; row < m_Grid.GetRows(); row++)
	{
		y = pt.y + yfudge*row;
		lb = m_Grid.GetRowPos(row);
		ub = lb + m_Grid.GetRowHeight(row);
		if(lb <= y && y < ub)
			break;
	}
	if( row == m_Grid.GetRows())
		row--;
}

void CSignPostDialog::RowColFromTwips(POINT& pt, int& row, int& col)
{
	pt.y = -pt.y;
	long x,y;
	// find col
	int lb,ub;
	for(col = 0; col < m_Grid.GetCols(); col++)
	{
		x = pt.x;
		lb = m_Grid.GetColPos(col);
		ub = lb + m_Grid.GetColWidth(col);
		if(lb <= x && x < ub)
			break;
	}
	if( col == m_Grid.GetCols())
		col--;
//	pos = 0;
	for(row = 0; row < m_Grid.GetRows(); row++)
	{
		y = pt.y;
		lb = m_Grid.GetRowPos(row);
		ub = lb + m_Grid.GetRowHeight(row);
		if(lb <= y && y < ub)
			break;
	}
	if( row == m_Grid.GetRows())
		row--;
}

void CSignPostDialog::OnMouseDownGrid(short Button, short Shift, long x, long y) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(Shift);
//	UNREFERENCED_PARAMETER(x);
	UNREFERENCED_PARAMETER(y);

	m_ptXLastMousePixels = x;
	m_ptYLastMousePixels = y;

	m_bIgnoreClick = false;

	ASSERT(m_pChordDialog);
	m_pChordDialog->m_pPersonalityCtrl->SetLastFocus(CPersonalityCtrl::SignPost);
	long row, col;
//	row = m_Grid.GetRow();
//	col = m_Grid.GetCol();
	row = m_Grid.GetMouseRow();
	col = m_Grid.GetMouseCol();
	if(row == 0 || col == 0)
	{
		m_bIgnoreClick = true;
		return;
	}
	m_ptLastMouse.x = static_cast<short>(col);
	m_ptLastMouse.y = static_cast<short>(row);
	if(row < m_Grid.GetRows() - 1)
	{
		bool bDrag = false;
		bool bDrop = false;

		// determine if chord mouse is on is selected
		SignPost *pSignPost = (SignPost*)(m_Grid.GetRowData(row));
		switch(col)
		{
		case COL_C1:
			if(pSignPost->m_dwflags & SPOST_CADENCE1)
			{
				bDrag |= pSignPost->m_cadence[0].KeyDown();
			}
			break;
		case COL_C2:
			if(pSignPost->m_dwflags & SPOST_CADENCE2)
			{
				bDrag |= pSignPost->m_cadence[1].KeyDown();
			}
			break;
		case COL_SP:
			bDrag |= pSignPost->m_chord.KeyDown();
			break;
		}

		// anything selected, yes->start drag
		if((Button & MK_LBUTTON) && bDrag)
		{
			m_fDragging = TRUE;
			bDrop = true;
			IDropSource* pIDropSource;
			DWORD dwEffect = DROPEFFECT_NONE;
			if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
			{
				// create data object and image
				POINTS pt;
				pt.x = static_cast<short>(col);
				pt.y = static_cast<short>(row);
				HRESULT hr = CreateDataObject(&m_pISourceDataObject, pt);
				if(SUCCEEDED(hr))
				{
					m_pDragImage = CreateDragImage();
					if(m_pDragImage)
					{
						m_pDragImage->BeginDrag(0, CPoint(8,12));
					}
					// start drag, drop. NB: Only DragCopy allowed
					DWORD dwOKDragEffects = DROPEFFECT_COPY;
					m_dwStartDragButton = Button;
					m_startDragPosition.x = col;
					m_startDragPosition.y = row;
					m_bInternalDrop = false;
					hr = ::DoDragDrop(m_pISourceDataObject,
										pIDropSource,
										dwOKDragEffects,
										&dwEffect);
					// drag drop completed -- cleanup
					m_startDragPosition.x = 0;
					m_startDragPosition.y = 0;
					m_dwStartDragButton = 0;
					if(m_pDragImage)
					{
						m_pDragImage->EndDrag();
						delete m_pDragImage;
						m_pDragImage = NULL;
					}
					switch(hr)
					{
					case DRAGDROP_S_DROP:
						if(m_bInternalDrop)
						{
							m_bInternalDrop = false;
							m_nLastEdit = IDS_COPYSIGNPOST;
							InternalCopy(m_ptDrop);
						}
						else if(dwEffect == DROPEFFECT_NONE)
						{
							bDrop = false;
						}
						break;
					default:
						bDrop = false;
						break;
					}
					hr = S_OK;
					m_pISourceDataObject->Release();
					m_pISourceDataObject = NULL;
				}
				pIDropSource->Release();
			}
		}
		if( !bDrop && IsPropPageShowing())
		{
			SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));
			int col = m_ptLastMouse.x;
			bool bShow = false;
			if(m_ptLastMouse.x != COL_SP)
			{
				// check to see if mouse on a valid prop page object
				if(m_ptLastMouse.x == COL_C1)
				{
					if(pSignPost->m_dwflags & SPOST_CADENCE1)
					{
						bShow = true;
					}
				}
				else if (m_ptLastMouse.x == COL_C2)
				{
					if(pSignPost->m_dwflags & SPOST_CADENCE2)
					{
						bShow = true;
					}
				}
			}
			else
			{
				bShow = true;
			}
			if(bShow)
			{

				SetSelectedChord(pSignPost,  col);
				PreparePropChord( pSignPost);
				
				if(SUCCEEDED(OnShowProperties()) )
				{
					if( m_pPropPageMgr )
					{
						m_pPropPageMgr->RefreshData();
					}
				}
			}
			else
			{
				ShowPropPage(FALSE);
			}

		}
//		if(m_ptLastMouse.x == COL_SP ||m_ptLastMouse.x == COL_C1 || m_ptLastMouse.x == COL_C2)
//		{
//			OnClickGrid();
//		}
	}
}

HRESULT CSignPostDialog::UpdateCadenceChord(int nRow, int nCol, bool bVal)
{
	// Add new fields to the Grid
	CString csBuffer;
	char	szRootName[30];

	csBuffer = "";
	SignPost *pSignPost = (SignPost*)(m_Grid.GetRowData(nRow));

	if(nCol == COL_C1)
	{
		if(bVal)
		{
			if(!(pSignPost->m_dwflags & SPOST_CADENCE1))
			{
				SendEditNotification(IDS_UNDO_SignpostAddCadenceChord);
				pSignPost->m_dwflags |= SPOST_CADENCE1;
				pSignPost->m_cadence[0] = m_pIPersonality->GetKeyChord();
				pSignPost->m_cadence[0].RootToString(szRootName);
				csBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[0].Name() );
			}
			else
			{
				SendEditNotification(IDS_UNDO_SignpostAddCadenceChord);
				pSignPost->m_cadence[0].RootToString(szRootName);
				csBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[0].Name() );
			}
		}
		else
		{
			SendEditNotification(IDS_UNDO_DeleteCadenceChord);
			pSignPost->m_dwflags &= ~SPOST_CADENCE1;
		}
	}
	else if(nCol == COL_C2)
	{
		if(bVal)
		{
			if(!(pSignPost->m_dwflags & SPOST_CADENCE2))
			{
				SendEditNotification(IDS_UNDO_SignpostAddCadenceChord);
				pSignPost->m_cadence[1] = m_pIPersonality->GetKeyChord();
				pSignPost->m_cadence[1].RootToString(szRootName);
				csBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[1].Name() );
				pSignPost->m_dwflags |= SPOST_CADENCE2;
			}
			else
			{
				SendEditNotification(IDS_UNDO_SignpostAddCadenceChord);
				pSignPost->m_cadence[1].RootToString(szRootName);
				csBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[1].Name() );
			}
		}
		else
		{
			SendEditNotification(IDS_UNDO_DeleteCadenceChord);
			pSignPost->m_dwflags &= ~SPOST_CADENCE2;
		}
	}
	else
	{
		E_FAIL;
	}

	m_Grid.SetTextMatrix(nRow, nCol, csBuffer);

	return S_OK;
}


/////////////// IDropSource Methods
// IDropSource Methods
HRESULT CSignPostDialog::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}

HRESULT CSignPostDialog::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	UNREFERENCED_PARAMETER(dwEffect);

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

CImageList* CSignPostDialog::CreateDragImage()
{
	CImageList* pimage = new CImageList;
	ASSERT(pimage);
	if(!pimage)
	{
		return 0;
	}
	pimage->Create(::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON),
					ILC_COLOR4 | ILC_MASK, 1,1);
	pimage->SetBkColor(CLR_NONE);
	HICON hIcon = ::LoadIcon( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_CHORDTRUCK));
	pimage->Add(hIcon);
	return pimage;
}

HRESULT	CSignPostDialog::CreateDataObject(IDataObject** ppIDataObject, POINTS where)
{
	// where.x = col.  where.y = row
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Chords into stream
	HRESULT hr = S_OK;
	if( SUCCEEDED (m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		ChordSelection* pChordAtDragPoint;
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( where.y ));
		switch(where.x)
		{
		case COL_C1:
			ASSERT(pSignPost->m_dwflags & SPOST_CADENCE1);
			pChordAtDragPoint = &(pSignPost->m_cadence[0]);
			break;
		case COL_C2:
			pChordAtDragPoint = &(pSignPost->m_cadence[1]);
			break;
		case COL_SP:
			pChordAtDragPoint = &(pSignPost->m_chord);
			break;
		default:
			ASSERT(FALSE);	// drag must start from one of above cols
			pChordAtDragPoint = 0;
			hr = E_FAIL;
			break;
		}
		m_pDragChord = pChordAtDragPoint;
		TRACE("drag chord created, addr = %p\n");
		if(!SUCCEEDED(hr))
		{
			ASSERT(FALSE);
			pIStream->Release();
			return hr;
		}
		if( SUCCEEDED ( SaveSelectedChords( pIStream, pChordAtDragPoint, TRUE ) ) )
		{
			// Place CF_CHORDLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfChordList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}



	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}

/*
void CSignPostDialog::MarkSelectedChords(DWORD flags)
{
	for(int i = 0; i < m_Grid.GetRows() - 2; i++)
	{
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( i ));
		ASSERT( pSignPost != NULL );
		ChordSelection* pChord;
		for(int j = 0; j < SignPost::MAX_CADENCE; j++)
		{
			pChord = &(pSignPost->m_cadence[j]);
			if(pChord->KeyDown())
			{
				pChord->m_dwflags |= flags;
			}
		}
		pChord = pSignPost->m_chord;
		if(pChord->m_chordsel.KeyDown())
		{
			pChord->m_dwflags |= flags;
		}		
	}
}
*/

HRESULT CSignPostDialog::SaveSelectedChords(LPSTREAM pStream, ChordSelection* pChordAtDragPoint, BOOL bNormalize)
{
	// commmented out lines implement mechanism for drop/pasting signpost chords at beginning and
	// end of chord map
	ASSERT(pStream);
	ASSERT(pChordAtDragPoint);
	CChordList list;
	ChordSelection* pChord;
	CChordItem* pItem;
	// copy selected chords to list
	for(int i = 1; i < m_Grid.GetRows() - 1; i++)
	{
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData(i));
		ASSERT( pSignPost != NULL);
		for(int j = 0; j < SignPost::MAX_CADENCE; j++)
		{

			DWORD mask = 0;
			switch(j)
			{
			case 0:
				 mask = SPOST_CADENCE1;
				 break;
			case 1:
				 mask = SPOST_CADENCE2;	// is there really a signpost there
				 break;
			default:
				ASSERT( 0 );
				break;
			}
			pChord = &(pSignPost->m_cadence[j]);
			if( (pSignPost->m_dwflags & mask)  && pChord->KeyDown())
			{
				// make sure that only the chord at the mouse drag point is selected
				pChord->KeyDown() = (pChord == pChordAtDragPoint) ? TRUE : FALSE;
				pItem = new CChordItem(*pChord);
//				pItem->m_dwUndetermined != CE_END;
				list.AddTail(pItem);
				// re-select chord
				pChord->KeyDown() = TRUE;
				// mark as ending chord
			}
		}
		pChord = &(pSignPost->m_chord);
		if(pChord->KeyDown())
		{
			// make sure that only the chord at the mouse drag point is selected
			pChord->KeyDown() = (pChord == pChordAtDragPoint) ? TRUE : FALSE;
			// add beginning signpost
			pItem = new CChordItem(*pChord);
//			pItem->m_dwUndetermined |= CE_START;
			list.AddTail(pItem);
/*			
			// add end signpost
			pItem = new CChordItem(*pChord);
			pItem->m_dwUndetermined |= CE_END;
			list.AddTail(pItem);
*/
			// reselect chord
			pChord->KeyDown() = TRUE;
		}
	}
	// check that anything is selected
	if(!list.GetHead())
		return E_FAIL;
	// normalize chords so that first chord is at offset 0
	if(bNormalize)
	{
		// here normalize means all CE_START at measure 0 beat 0
		// all CE_END at last measure of chord map
		for(pItem = list.GetHead(); pItem; pItem = pItem->GetNext())
		{
//			pItem->SetSignPost(TRUE);
			pItem->SetSignPost(FALSE);
			pItem->Beat() = 0;
			pItem->Measure() = 0;
//			if(pItem->m_dwUndetermined & CE_START)
//			{
//				pItem->m_nMeasure = 0;
//			}
//			else
//			{
//				pItem->m_nMeasure = lastmeasure;
//			}
		}

	}
	HRESULT hr = list.Save(pStream, FALSE);
	list.ClearList();
	return hr;
}

ChordSelection* CSignPostDialog::InternalCopy(POINTS ptDrop)
{
	ChordSelection *pChord = 0;
	UNREFERENCED_PARAMETER(ptDrop);
/*
	if( FAILED(m_pChordMapMgr->CreateBlankChord( &pChord )) )
	{
		return 0;
	}

	// copy contents of dragged chord
	OldChordEntry oce;
	m_pDragChord->SaveSmall(oce);
	pChord->LoadSmall(oce);

	// Set new Chord (UI Box) where the user clicked the mouse.
	if( FAILED(SetChordXY( pChord, ptDrop )) ) // If user clicks end of timeline then method should fail (it currently does not).
	{
		delete pChord;
		pChord = 0;
	}

	m_pChordMapMgr->m_pChordMapList->AddTail( pChord );
	ClearSelectedChords();
	pChord->m_chordsel.KeyDown() = TRUE;	// new inserted chord is selected
*/
	return pChord;
}


DWORD VBtoWIN32MouseState(short button, short shift)
{
	DWORD state = 0;
	if(button & 1)
		state |= MK_LBUTTON;
	if(button & 2)
		state |= MK_RBUTTON;
	if(button & 4)
		state |= MK_MBUTTON;
	if(shift & 1)
		state |= MK_SHIFT;
	if(shift & 2)
		state |= MK_CONTROL;
	if(shift & 4)
		state |= MK_ALT;

	return state;
}

/////////////////////////////////////////////////// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostDialog::DragEnter

HRESULT CSignPostDialog::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	TRACE("CSignPostDialog Drag Enter!");
	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetDesktopWindow (), point );
	}
/*
	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}
*/
	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostDialog::DragOver

HRESULT CSignPostDialog::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int row, col;


	POINT q;
	q.x = pt.x;
	q.y = pt.y;

	TRACE("DragOver pt = (%d, %d)\n", q.x, q.y);
//	ScreenToClient(&q);

	RowColFromPoint(q, row, col);
	TRACE("DragOver pt = (%d, %d), row, col = (%d, %d)\n", q.x,q.y, row, col);

	int lastrow = m_Grid.GetRows() - 1;
	bool chordcol = (col == COL_C1) || (col == COL_C2) || (col == COL_SP);
	bool chordrow = row < lastrow && row > 0;

	if(row == lastrow && col == COL_SP)
	{
		chordrow = true;
	}


	TRACE("CSignPostDialog Drag OVER!");
	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	
	if(chordcol && chordrow && CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
//		TRACE("EFFECT = %d\n", dwEffect);
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostDialog::DragLeave

HRESULT CSignPostDialog::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	TRACE("CSignPostDialog Drag Leave!");

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostDialog::Drop

HRESULT CSignPostDialog::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = dynamic_cast<CWnd*>(this);
			if(pWnd)
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		hr = PasteAt( pIDataObject, pt, true );
		if( SUCCEEDED ( hr ) )
		{
			*pdwEffect = m_dwOverDragEffect;
		}
	}
/*
	else
	{
		hr = S_FALSE;
	}
	if(hr != S_OK)
	{
		POINT p;
		p.x = pt.x;
		p.y = pt.y;
		int row;
		int col;
		RowColFromPoint(p, row, col);
		m_Grid.SetCol( row );
		m_Grid.SetRow( col );
	
		short Button = static_cast<short>(m_dwOverDragButton & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));
		short Shift = static_cast<short>(m_dwOverDragButton & (MK_CONTROL | MK_SHIFT));

		OnMouseUpGrid(Button, Shift, pt.x, pt.y);

	}
*/

	// Cleanup
	DragLeave();


	return hr;
}





HRESULT CSignPostDialog::CanPasteFromData(IDataObject* pIDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
/*	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList ) ))
	{
		// check to see that its a single chord
		hr = S_OK;
	}
*/
	hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList );
	if(hr != S_OK)
	{
		hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordMapList );
	}

	pDataObject->Release();
	return hr;
}


HRESULT CSignPostDialog::PasteAt( IDataObject* pIDataObject, POINTL pt, bool bDropNotEditPaste)
{
	UNREFERENCED_PARAMETER(bDropNotEditPaste);

	if( pIDataObject == NULL )
	{
		return E_NOTIMPL;
	}
/*
	// check that we're not dragging and dropping to same place
	if( m_pCopyDataObject && S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
	{
		// paste via copy op, use grid coords
		if(pt.y == m_startDragPosition.y && pt.x == m_startDragPosition.x)
		{
			return E_FAIL;
		}
	}
	else
	{
		int row, col;
		POINT q;
		q.x = pt.x;
		q.y = pt.y;
		RowColFromPoint(q, row, col);
		if(col == m_startDragPosition.x && row == m_startDragPosition.y)
		{
			return E_FAIL;
		}
	}
*/
	if(bDropNotEditPaste)
	{
		int row, col;
		POINT q;
		q.x = pt.x;
		q.y = pt.y;
		RowColFromPoint(q, row, col);
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	bool bChordNotChordMap = true;
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList );
	if(hr != S_OK)
	{
		bChordNotChordMap = false;
		hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordMapList );
	}

//	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList ) ) )

	if(hr == S_OK)
	{
		IStream* pIStream;

		if(bChordNotChordMap)
			hr = pDataObject->AttemptRead( pIDataObject, m_cfChordList, &pIStream);
		else
			hr = pDataObject->AttemptRead( pIDataObject, m_cfChordMapList, &pIStream);

		if(SUCCEEDED (hr))
		{
			hr = S_OK;
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);
			// declare a temp list and write chords into it
			CChordList list;
			if(bChordNotChordMap)
			{
				list.Load(pIStream);
			}
			else
			{
				ChordEntryList chordEntryList;
				ChordEntry* pEntry = 0;
				hr = DMLoadChordData(chordEntryList, pIStream);
				if(FAILED(hr))
				{
					for(pEntry = chordEntryList.RemoveHead(); pEntry ; pEntry = chordEntryList.RemoveHead())
					{
						delete pEntry;
					}
					goto Leave;
				}
				// convert to CChordList
				for(pEntry = chordEntryList.RemoveHead(); pEntry; )
				{
					CChordItem* pItem = new CChordItem(*pEntry);
					delete pEntry;
					list.AddTail(pItem);
					pEntry = chordEntryList.RemoveHead();
				}
			}
			pIStream->Release();
			if(list.GetHead() == NULL)
			{
				// don't drop an empty list
				hr = E_FAIL;
				goto Leave;
			}
			int row, col;
			SendEditNotification(IDS_UNDO_PasteSignpostChord);
//			if( m_pCopyDataObject && S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
			if(!bDropNotEditPaste)
			{
				// paste via copy, don't convert coords
				row = pt.y;
				col = pt.x;
			}
			else
			{
				POINT q;
				q.x = pt.x;
				q.y = pt.y;
				RowColFromPoint(q, row, col);
			}
/*
			row = pt.y;
			col = pt.x;
*/
			int lastrow = m_Grid.GetRows() - 1;
			bool chordcol = (col == COL_C1) || (col == COL_C2) || (col == COL_SP);
			bool chordrow = row <= lastrow && row > 0;
			if(chordcol && chordrow)
			{
				m_ptLastMouse.x = static_cast<short>(col);
				m_ptLastMouse.y = static_cast<short>(row);
				// use only the first chord
				CChordItem* pItem = list.GetHead();
				ChordEntry chord;
				chord.LoadFromChordItem(*pItem);
				SignPost* pSignPost;
				if(row == lastrow)
				{
					// insert new signpost equal to passed in chord
					pSignPost = new SignPost;
					DMPolyChord* pPoly = dynamic_cast<DMPolyChord*>(&(pSignPost->m_chord));
					*pPoly = chord.m_chordsel;
					if( pSignPost == NULL )
					{
						hr =  E_OUTOFMEMORY;
						goto Leave;
					}
					// Default with Cadence Chords turned off.
					pSignPost->m_dwflags ^= (SPOST_CADENCE1 | SPOST_CADENCE2);
					// Insert the new SignPost into the list
					m_pSignPostList->AddTail( pSignPost );
					AddSignPostToGrid(pSignPost);
					// add a new signpost, do orphan check
					m_pIPersonality->Link2CM(pSignPost);
					m_pIPersonality->Link2SP(pSignPost);
					m_pIPersonality->RefreshChordMap();
					UpdateOrphanStatus(true);
				}
				else
				{
					pSignPost = (SignPost*)(m_Grid.GetRowData( row ));
					DMPolyChord* pPoly;
					ASSERT(pSignPost);
					switch(col)
					{
					case COL_C1:
						pPoly = dynamic_cast<DMPolyChord*>(&(pSignPost->m_cadence[0]));
						*pPoly = chord.m_chordsel;
						pSignPost->m_dwflags |= SPOST_CADENCE1;
						UpdateCadenceChord(row, col, TRUE);
						break;
					case COL_C2:
						pPoly = dynamic_cast<DMPolyChord*>(&(pSignPost->m_cadence[1]));
						*pPoly = chord.m_chordsel;
						pSignPost->m_dwflags |= SPOST_CADENCE2;
						UpdateCadenceChord(row, col, TRUE);
						break;
					case COL_SP:
						pPoly = dynamic_cast<DMPolyChord*>(&(pSignPost->m_chord));
						*pPoly = chord.m_chordsel;
						hr = UpdateSignPostChord(row);
						break;
					default:
						hr = E_FAIL;
						break;
					}
				}
				if(hr == S_OK)
				{
					m_Grid.SetCol( m_ptLastMouse.x );
					m_Grid.SetColSel( m_ptLastMouse.x );
					m_Grid.SetRow( m_ptLastMouse.y );
					m_Grid.SetRowSel( m_ptLastMouse.y );
					// Add this Chord to the template Property Chord.
					ASSERT( pSignPost != NULL );
					SetSelectedChord( pSignPost, m_ptLastMouse.x );
					PreparePropChord( pSignPost );


					if( IsPropPageShowing())
					{
						if(SUCCEEDED(OnShowProperties()) )
						{
							if( m_pPropPageMgr )
							{
								m_pPropPageMgr->RefreshData();
							}
						}
					}

					SetFocus();
					if( m_pIPersonality != NULL )
					{
						DMusicSync(CPersonality::syncPersonality + CPersonality::syncAudition);
						m_pIPersonality->Modified() = TRUE;
					}
				}
			}
			else
			{
				hr = E_FAIL;
			}
			list.ClearList();
		}
	}
Leave:	
	pDataObject->Release();
	return hr;
}

namespace SignPostDragDrop
{
	const short Enter = 0;
	const short Leave = 1;
	const short Over = 2;
}

void CSignPostDialog::OnOLEDragOverGrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y, short FAR* State) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	POINTL pt;
	pt.x = static_cast<long>(*x);
	pt.y = static_cast<long>(*y);

	DWORD grfState = VBtoWIN32MouseState(*Button, *Shift);

	IDataObject* pIDataObject;

	if(SUCCEEDED((*Data)->QueryInterface(IID_IDataObject, (void**)&pIDataObject)))
	{
		switch(*State)
		{
		case SignPostDragDrop::Enter:
			DragEnter(pIDataObject, 
					  grfState, 
					  pt, 
					  reinterpret_cast<DWORD*>(Effect));
			break;
		case SignPostDragDrop::Leave:
			DragLeave();
			break;
		case SignPostDragDrop::Over:
			DragOver(grfState, pt, reinterpret_cast<DWORD*>(Effect));
			break;
		}
		pIDataObject->Release();
	}
}

void CSignPostDialog::OnOLEDragDropGrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	POINTL pt;
	pt.x = static_cast<long>(*x);
	pt.y = static_cast<long>(*y);

	DWORD grfState = VBtoWIN32MouseState(*Button, *Shift);

	IDataObject* pIDataObject;

	if(SUCCEEDED((*Data)->QueryInterface(IID_IDataObject, (void**)&pIDataObject)))
	{
		Drop(pIDataObject, 
			 grfState, 
			 pt, 
			 reinterpret_cast<DWORD*>(Effect));
		pIDataObject->Release();
	}

}

///////////////////////////// Edit Methods
//
HRESULT CSignPostDialog::Cut (IDataObject** )
{
	return E_NOTIMPL;
}

HRESULT CSignPostDialog::Copy( IDataObject **ppIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;
	CDllJazzDataObject*	pDataObject;
	IDataObject*		pIDataObjectOrig;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}


	if(ppIDataObject == NULL)
	{
		pIDataObjectOrig = NULL;
	}
	else
	{
		pIDataObjectOrig = *ppIDataObject;
	}

	if(pIDataObjectOrig != NULL)
	{
		// If there is an existing data object, copy it to our new one
		IStream		*pIStream;
		IEnumFORMATETC	*pIEnumFORMATETC;
		FORMATETC formatEtc;
		ULONG ulElem;
		pDataObject = new CDllJazzDataObject;

		ASSERT( pDataObject != NULL );
		if (pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pIDataObjectOrig->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pDataObject->Release();
			return E_FAIL;
		}

		while ( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK)
		{
			hr = pDataObject->AttemptRead( pIDataObjectOrig, formatEtc.cfFormat, &pIStream);
			ASSERT( hr == S_OK );
			if ( hr != S_OK )
			{
				pIEnumFORMATETC->Release();
				pDataObject->Release();
				return E_FAIL;
			}
			hr = pDataObject->AddClipFormat( formatEtc.cfFormat, pIStream );
			pIStream->Release();
			ASSERT( hr == S_OK );
			if ( hr != S_OK )
			{
				pIEnumFORMATETC->Release();
				pDataObject->Release();
				return E_FAIL;
			}
		}
		pIEnumFORMATETC->Release();
	}
	else // pIDataObjectOrig == NULL
	{
		// There is no existing data object, so just create a new one
		pDataObject = new CDllJazzDataObject;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			pDataObject->Release();
			return E_FAIL;
		}
	}


	if( SUCCEEDED (m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pStreamCopy) ) )
	{
		ChordSelection* pChordAtDragPoint;
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));
		switch(m_ptLastMouse.x)
		{
		case COL_C1:
			ASSERT(pSignPost->m_dwflags & SPOST_CADENCE1);
			pChordAtDragPoint = &(pSignPost->m_cadence[0]);
			break;
		case COL_C2:
			pChordAtDragPoint = &(pSignPost->m_cadence[1]);
			break;
		case COL_SP:
			pChordAtDragPoint = &(pSignPost->m_chord);
			break;
		default:
			ASSERT(FALSE);	// drag must start from one of above cols
			pChordAtDragPoint = 0;
			hr = E_FAIL;
			break;
		}

		if(!SUCCEEDED(hr))
		{
			ASSERT(FALSE);
			pStreamCopy->Release();
			return hr;
		}

		if( SUCCEEDED ( SaveSelectedChords( pStreamCopy, pChordAtDragPoint, TRUE ) ) )
		{
			// Place CF_CHORDLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfChordList, pStreamCopy ) ) )
			{
				hr = S_OK;
			}
		}
	}



	// add the stream to the passed IDataObject
	hr = pDataObject->AddClipFormat( m_cfChordList, pStreamCopy );
	pStreamCopy->Release();
	ASSERT( hr == S_OK );
	if ( hr != S_OK )
	{
		pDataObject->Release();
		return E_FAIL;
	}

	if (pIDataObjectOrig != NULL)
	{
		pIDataObjectOrig->Release();
	}
	// get the new IDataObject
	hr = pDataObject->QueryInterface(IID_IDataObject, (void**) &pIDataObjectOrig);
	if(FAILED(hr))
	{
		pDataObject->Release();
		return E_UNEXPECTED;
	}


	// Release the old object, and set the pointer to the new one.
	if( m_pCopyDataObject != NULL )
	{
		m_pCopyDataObject->Release();
	}
	m_pCopyDataObject = pDataObject;
	pDataObject->Release();
	if (ppIDataObject != NULL)
	{
		*ppIDataObject = pIDataObjectOrig;
		pIDataObjectOrig->AddRef();
	}
	else
	{
		if( S_OK != OleSetClipboard( pIDataObjectOrig ))
		{
			return E_FAIL;
		}
	}
	
	
	return hr;
}



HRESULT CSignPostDialog::Paste( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr = S_FALSE;
	
	hr = CanPaste();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}


	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfChordMapList == 0 )
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pIDataObject == NULL)
	{
		// Get the IDataObject
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}
	}
	else
	{
		pIDataObject->AddRef();
	}



	// Paste
	POINTL pt;
	pt.x = m_ptLastMouse.x;
	pt.y = m_ptLastMouse.y;
	hr = PasteAt(pIDataObject, pt, false);
	pIDataObject->Release();
	return hr;
}

HRESULT CSignPostDialog::Insert( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pIDataObject);
	OnCommand(IDM_SIGNPOST_ADD_CHORD, 0);
	return S_OK;
}

HRESULT CSignPostDialog::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = CanDelete();
	if(hr == S_OK)
	{
		hr = S_FALSE;
		SignPost *pSignPost = (SignPost*)(m_Grid.GetRowData(m_ptLastMouse.y));
		// Delete entire row if the entire row is selected
		if( m_ptLastMouse.x == COL_SELECT || m_ptLastMouse.x == COL_SP )
		{
			SendEditNotification(IDS_UNDO_DeleteSignpostChord);
			// Remove the SignPost from the list.
			m_Grid.RemoveItem( m_ptLastMouse.y );

			// Delete SignPost from the SignPost list.
			m_pSignPostList->Remove( pSignPost );
			delete pSignPost;
			m_pIPersonality->LinkAll(true);

			ResizeGrid();
			hr = S_OK;
		}
		// or.. Remove (Inactivate) Cadence Chord 1 if it is selected
		else if( m_ptLastMouse.x == COL_C1 )
		{
			SendEditNotification(IDS_UNDO_DeleteCadenceChord);
			pSignPost->m_dwflags ^= SPOST_CADENCE1;
			m_Grid.SetText( "" );
			hr = S_OK;
		}
		// or.. Remove (Inactivate) Cadence Chord 2 if it is selected
		else if( m_ptLastMouse.x == COL_C2 )
		{
			SendEditNotification(IDS_UNDO_DeleteCadenceChord);
			pSignPost->m_dwflags ^= SPOST_CADENCE2;
			m_Grid.SetText( "" );
			hr = S_OK;
		}
		if(hr == S_OK)
		{
			m_Grid.SetCol( m_ptLastMouse.x );
			m_Grid.SetColSel( m_ptLastMouse.x );
			m_Grid.SetRow( m_ptLastMouse.y );
			m_Grid.SetRowSel( m_ptLastMouse.y );
		}
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT CSignPostDialog::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_Grid.SetColSel(0);
	m_Grid.SetRowSel(0);
	m_ptLastMouse.x = 0;
	m_ptLastMouse.y = 0;
	return S_OK;
}

HRESULT CSignPostDialog::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_FALSE;
}

HRESULT CSignPostDialog::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_FALSE;

	if(m_ptLastMouse.y > 0 && m_ptLastMouse.y < m_Grid.GetRows() - 1)
	{
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));
		if(pSignPost == 0)
		{
			hr =  S_FALSE;
		}
		else
		{
			switch(m_ptLastMouse.x)
			{
				case COL_C1:
					if( pSignPost->m_dwflags & SPOST_CADENCE1 )
					{
						hr = S_OK;
					}
					break;
				case COL_C2:
					if( pSignPost->m_dwflags & SPOST_CADENCE2 )
					{
						hr = S_OK;
					}
					break;
				case COL_SP:
					hr = S_OK;
					break;
				default:
					hr = S_FALSE;
					break;
			}
		}
	}

	return hr;
}

HRESULT CSignPostDialog::CanPaste( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IDataObject*		pIDataObject;
	CDllJazzDataObject*	pDataObject;

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}
	if(m_cfChordMapList == 0)
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}

	// Get the IDataObject
	hr = OleGetClipboard( &pIDataObject );
	if( FAILED( hr ))
	{
		return E_FAIL;
	}

	// Create a new Jazz data object and see if it can read the data object's format.
	pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		pIDataObject->Release();
		return E_OUTOFMEMORY;
	}

	hr = pDataObject->IsClipFormatAvailable(pIDataObject, m_cfChordList);
	if(hr != S_OK)
	{
		hr = pDataObject->IsClipFormatAvailable(pIDataObject, m_cfChordMapList);
	}
	pDataObject->Release();
	pIDataObject->Release();
	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CSignPostDialog::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//	HRESULT hr = GetClickedChord( m_ptLastMouse, NULL );
//	return hr == S_OK ? S_OK : S_FALSE;
	return S_OK;
}

HRESULT CSignPostDialog::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long rowsel = m_Grid.GetRowSel();
	long colsel = m_Grid.GetColSel();
	HRESULT hr = S_FALSE;
	if( rowsel > -1 && rowsel < m_Grid.GetRows() - 1)
	{
		if(colsel == COL_SELECT
			|| colsel == COL_C1
			|| colsel == COL_SP)
		{
			hr = S_OK;
		}
	}
	return hr;
}



void CSignPostDialog::Refresh(bool isStructualChange)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(!m_bInitialized)
		return;
	int maxrows = m_Grid.GetRows();
	int i = 1;

	m_Grid.SetRedraw(FALSE);

	if(isStructualChange)
	{
		for(i = 1; i < maxrows -1; i++)
		{
			m_Grid.RemoveItem(1);
		}
//		SetRowText(0, 0);
//		m_Grid.SetRowData(0, 0);
	}

	bool bNotEmpty = false;
	i = 1;
	for(	SignPost *pSignPost = m_pSignPostList->GetHead();
			pSignPost != NULL;
			pSignPost = pSignPost->GetNext() )
	{
		bNotEmpty = true;
		if(isStructualChange)
			AddSignPostToGrid( pSignPost , i++);
		else
		{
			SetRowText(pSignPost, i);
			m_Grid.SetRowData( i++, (long)pSignPost ); 
		}
	}


//	if(bNotEmpty  && IsMyPropPageShowing())
	if(bNotEmpty)
	{
//		m_ptLastMouse.x = COL_SP;
//		m_ptLastMouse.y = 1;
		if(m_ptLastMouse.x > COL_SP)
		{
			// don't want focus on non-chord cell if proppage is up
			m_ptLastMouse.x = COL_SP;
		}
		m_Grid.SetCol( m_ptLastMouse.x );
		m_Grid.SetColSel( m_ptLastMouse.x );
		m_Grid.SetRow( m_ptLastMouse.y );
		m_Grid.SetRowSel( m_ptLastMouse.y );
		if(m_ptLastMouse.x == COL_C1 || m_ptLastMouse.x == COL_C2)
		{
			// check to see if anythings here
			CString str = m_Grid.GetText();
			if(str.GetLength() == 0 || str == " ")
			{
				ShowPropPage(FALSE);
				goto End;
			}
		}
		SignPost* pSignPost = (SignPost*)(m_Grid.GetRowData( m_ptLastMouse.y ));

		SetSelectedChord(pSignPost,  m_ptLastMouse.x);
		DMusicSync(CPersonality::syncAudition);
		PreparePropChord( pSignPost);

		if( IsMyPropPageShowing() )
		{
			if( SUCCEEDED(OnShowProperties()) )
			{
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->RefreshData();
				}
			}
		}
	}
End:
	m_Grid.SetRedraw(TRUE);
	m_Grid.Refresh();
}

void CSignPostDialog::SendEditNotification(UINT type)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HINSTANCE hInst = AfxGetInstanceHandle( );

	if(m_pIPersonality->m_pUndoMgr)
		m_pIPersonality->m_pUndoMgr->SaveState(m_pIPersonality, hInst, type);

}

bool CSignPostDialog::IsPropPageShowing()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pIFramework);
	if(m_pIFramework == NULL)
	{
		return false;
	}
	/*
	if( m_pPropPageMgr == NULL )
	{
		return false;
	}
	*/

	// check PropertyPage
	IDMUSProdPropSheet* pJPS;
	bool rc = false;
	if( SUCCEEDED(m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet,
		(void**)&pJPS )))
	{
		if(pJPS->IsShowing() == S_OK)
			rc = true;
		else
			rc = false;
		pJPS->Release();
	}

	return rc;
}

bool CSignPostDialog::IsMyPropPageShowing()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pIFramework);
	if(m_pIFramework == NULL)
	{
		return false;
	}
	/*
	if( m_pPropPageMgr == NULL )
	{
		return false;
	}
	*/

	// check PropertyPage
	IDMUSProdPropSheet* pJPS;
	bool rc = false;
	if( SUCCEEDED(m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet,
		(void**)&pJPS )))
	{
//		if(pJPS->IsShowing() == S_OK && pJPS->IsEqualPageManagerObject(this) == S_OK)
		if(pJPS->IsShowing() == S_OK && pJPS->IsEqualPageManagerObject((IDMUSProdPropPageObject*)this) == S_OK)
			rc = true;
		else
			rc = false;
		pJPS->Release();
	}

	return rc;
}

HRESULT CSignPostDialog::ShowPropPage(BOOL fShow)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	ASSERT(m_pIFramework);
	if(m_pIFramework == NULL)
	{
		return E_FAIL;
	}
	if( m_pPropPageMgr == NULL )
	{
			return S_FALSE;
	}
	hr = E_FAIL;

	// SetPropertyPage
	if( m_pIFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			if(fShow == TRUE)
			{
				pJPS->Show(fShow);
			}
			else
			{
				pJPS->RemovePageManager(m_pPropPageMgr);
			}
			pJPS->Release();
		}
	}

	return hr;

}

static int Index(int row, int col)
{
	return row*MAX_COLUMNS + col;
}

void CSignPostDialog::SetRowText(SignPost * pSignPost, int row)
{
	if(pSignPost == 0)
	{
		// blank out grid
		for(int i = 0; i < MAX_COLUMNS; i++)
		{
			m_Grid.SetTextArray(Index(row, i), "");
		}
		return;
	}

	// Add new fields to the Grid
	CString csWrkBuffer;
	char	szRootName[30];
	// save row,col, cause we'll need to change it to set orphan status
	int irow = m_Grid.GetRow();
	int icol = m_Grid.GetCol();

// Store Cadence and SignPost names.
	if( pSignPost->m_dwflags & SPOST_CADENCE1 )
	{
		pSignPost->m_cadence[0].RootToString(szRootName);
		csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[0].Name() );
		m_Grid.SetTextArray(Index(row, COL_C1), csWrkBuffer);
	}
	else
	{
		m_Grid.SetTextArray(Index(row, COL_C1), "");
	}
	if( pSignPost->m_dwflags & SPOST_CADENCE2 )
	{
		pSignPost->m_cadence[1].RootToString(szRootName);
		csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_cadence[1].Name() );
		m_Grid.SetTextArray(Index(row, COL_C2), csWrkBuffer);
	}
	else
	{
		m_Grid.SetTextArray(Index(row, COL_C2), "");
	}

	pSignPost->m_chord.RootToString(szRootName);
	csWrkBuffer.Format( "%s %s", szRootName, pSignPost->m_chord.Name() );
	//set up
	m_Grid.SetRow(row);
	m_Grid.SetCol(COL_SP);
	if(pSignPost->m_dwflags & SPOST_MATCHED)
	{
		m_Grid.SetCellFontBold(TRUE);
		m_Grid.SetCellFontItalic(FALSE);
	}
	else
	{
		m_Grid.SetCellFontBold(FALSE);
		m_Grid.SetCellFontItalic(TRUE);
	}

	m_Grid.SetTextArray(Index(row, COL_SP), csWrkBuffer);

	int col = COL_1;

	if( pSignPost->m_chords & SP_1 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_2 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_3 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_4 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_5 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_6 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_7 )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_A )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_B )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_C)
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_D )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_E )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}
	if( pSignPost->m_chords & SP_F )
	{
		m_Grid.SetTextArray(Index(row, col++), "X");
	}
	else
	{
		m_Grid.SetTextArray(Index(row, col++), " ");
	}


	m_Grid.SetRow(irow);
	m_Grid.SetCol(icol);
}

void CSignPostDialog::DMusicSync(int type)
{
	if(m_pIPersonality)
		m_pIPersonality->SyncPersonalityWithEngine(type);
}

int CSignPostDialog::ComputeRowWidth()
{
	int ncols = m_Grid.GetCols();
	int sum = 0;
	for(int i = 0; i < ncols; i++)
	{
		sum += m_Grid.GetColWidth(i);
	}
	return sum;
}

int CSignPostDialog::ComputeColHeight()
{
	int nRows = m_Grid.GetRows();
	int sum = 0;
	for(int i = 0; i < nRows; i++)
	{
		sum += m_Grid.GetRowHeight(i);
	}
	return sum;
}


void CSignPostDialog::OnClickCMSFlexGrid() 
{
	// TODO: Add your control notification handler code here
//	OnClickGrid();	
}

bool CSignPostDialog::ToggleSignpostGroupBoxes()
{
	// set sel to anchor cell
	int rowsel = m_Grid.GetRowSel();
	int colsel = m_Grid.GetColSel();
	int col = m_Grid.GetCol();
	int row = m_Grid.GetRow();
	int nrows = m_Grid.GetRows() - 1;
	m_Grid.SetRowSel(row);
	m_Grid.SetColSel(col);

	// If user selected 1 through F then select/unselect the cell state and update the chord
	if( (col >= COL_1) && (col <= COL_F) )
	{

		CString csCellText;
		csCellText = m_Grid.GetText();

		m_Grid.SetRedraw(FALSE);	// too slow for this to be effective

		if(csCellText == "X")
		{
			SendEditNotification(IDS_UNDO_SignpostRemoveFromGroup);
			for(int i = row; (i <= rowsel) && (i < nrows); i++)
			{
				for(int j = col; j <= colsel; j++)
				{
//					m_Grid.SetTextMatrix(i,j, " ");
					m_Grid.SetCol(j);
					m_Grid.SetRow(i);
					m_Grid.SetText(" ");
					SetAcceptChords( i, j, FALSE );
				}
			}
		}
		else
		{
			SendEditNotification(IDS_UNDO_SignpostAddToGroup);
			for(int i = row; (i <= rowsel) && (i < nrows); i++)
			{
				for(int j = col; j <= colsel; j++)
				{
					m_Grid.SetCol(j);
					m_Grid.SetRow(i);
					m_Grid.SetText("X");
					SetAcceptChords( i, j );
				}
			}
		}
		m_Grid.SetRowSel(row);
		m_Grid.SetColSel(col);
		m_Grid.SetCol(col);
		m_Grid.SetRow(row);
		m_Grid.SetRedraw(TRUE);
		return true;
	}
	return false;	// nothing done
}



void CSignPostDialog::SetDrawingState(SignPost *pSignPost)
{
	if(pSignPost)
	{
		int row = -1;

		// find row
		for(int i = 0; i < (m_Grid.GetRows() - 1); i++)
		{
			if(pSignPost == (SignPost*)(m_Grid.GetRowData( i )))
			{
				row = i;
				break;
			}
		}
		if(row == -1)
		{
			// signpost doesn't exist in grid so nothing to do
			return;
		}
		m_Grid.SetCol(COL_SP);
		m_Grid.SetColSel(COL_SP);
		m_Grid.SetRowSel(i);
		m_Grid.SetRow(i);

		// set drawing state
		if(pSignPost->m_dwflags & SPOST_MATCHED)
		{
			m_Grid.SetCellFontBold(TRUE);
			m_Grid.SetCellFontItalic(FALSE);
		}
		else
		{
			m_Grid.SetCellFontBold(FALSE);
			m_Grid.SetCellFontItalic(TRUE);
		}
	}
	else
	{
		m_Grid.SetCol(COL_SP);
		m_Grid.SetColSel(COL_SP);
		for(int i= 1; i < (m_Grid.GetRows() - 1); i++)
		{
			m_Grid.SetRowSel(i);
			m_Grid.SetRow(i);
			pSignPost = (SignPost*)(m_Grid.GetRowData( i ));
			// set drawing state
			if(pSignPost->m_dwflags & SPOST_MATCHED)
			{
				m_Grid.SetCellFontBold(TRUE);
				m_Grid.SetCellFontItalic(FALSE);
			}
			else
			{
				m_Grid.SetCellFontBold(FALSE);
				m_Grid.SetCellFontItalic(TRUE);
			}			
		}
	}
}

void CSignPostDialog::UpdateOrphanStatus(bool bRefreshDisplay, SignPost *pSignPost)
{
	if(bRefreshDisplay)
	{
		m_Grid.SetRedraw(FALSE);	// turn off redraw until done
		SetDrawingState(pSignPost);
		m_Grid.SetRedraw(TRUE);
	}
	else
	{
		SetDrawingState(pSignPost);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\SignPostDialog.h ===
//{{AFX_INCLUDES()
#include "msflexgrid.h"
//}}AFX_INCLUDES
#if !defined(AFX_SIGNPOSTDIALOG_H__2B651786_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_SIGNPOSTDIALOG_H__2B651786_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SignPostDialog.h : header file
//

#ifndef	__SIGNPOSTDIALOG_H__
#define __SIGNPOSTDIALOG_H__

#include "personalitydesigner.h"
#include "msflexgrid.h"
#include "Chord.h"

#include "PropChord.h"
#include "PropPageMgr.h"

#include "ChordDialog.h"

#define CHORDNAME_MAX 12
#define WM_INSERT_CHORD (WM_USER + 51)

// Special SignPost List Column values
const int MAX_COLUMNS	= 17;
const int COL_SELECT	= 0;
const int COL_C1		= 1;
const int COL_C2		= 2;
const int COL_SP		= 3;
const int COL_1			= 4;
const int COL_2			= 5;
const int COL_3			= 6;
const int COL_4			= 7;
const int COL_5			= 8;
const int COL_6			= 9;
const int COL_7			= 10;
const int COL_A			= 11;
const int COL_B			= 12;
const int COL_C			= 13;
const int COL_D			= 14;
const int COL_E			= 15;
const int COL_F			= 16;

class CPersonality;

/////////////////////////////////////////////////////////////////////////////
// CSignPostDialog dialog

class CChordDialog;
class CPersonalityCtrl;

class CSignPostDialog : public CDialog, public IDMUSProdPropPageObject, 
						public IDropSource , public IDropTarget
{
	friend CPersonalityCtrl;
private:
	bool	m_bInitialized;
	bool	m_bIgnoreClick;
	SignPostList	*m_pSignPostList;
	CChordDialog	*m_pChordDialog;
	POINTS			m_ptLastMouse;
	long			m_ptXLastMousePixels;
	long			m_ptYLastMousePixels;
	IDMUSProdFramework* m_pIFramework;
	CPersonality	*m_pIPersonality;

	// Supports Chord Property Page.
	CPropChord				m_SelectedChord;
	CPropertyPage*			m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	CPersonalityCtrl	*m_pPersonalityCtrl;

	// drag drop state
	IDataObject*	m_pISourceDataObject;			// Object being dragged	
	IDataObject*	m_pITargetDataObject;
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	UINT			m_cfChordList;			// clipboard format for signpost chords
	UINT			m_cfChordMapList;		// clipboard format for chordmap chords
	POINTL			m_startDragPosition;	// pos where drag was started

	ChordSelection*	m_pDragChord;			// intra-chordmap chord being dragged
	POINTS			m_ptDrop;				// where a drag move or drag copy is completed
	bool			m_bInternalDrop;		// false at beg of drag and set to true if source == target
	BOOL			m_fDragging;
	CDllJazzDataObject*		m_pCopyDataObject;
	UINT			m_nLastEdit;			// resource id of last edit

// Construction
public:
	enum {All = 0};
	void SetDrawingState(SignPost* pSignPost = 0);
	bool ToggleSignpostGroupBoxes();
	int ComputeColHeight();
	int ComputeRowWidth();
	void DMusicSync(int type);
	void SetRowText(SignPost* pSignPost, int row);
	HRESULT ShowPropPage(BOOL fShow);
	bool IsPropPageShowing(void);
	bool IsMyPropPageShowing(void);
	void SendEditNotification(UINT type);
	void Refresh(bool isStructualChange);
	CSignPostDialog(CWnd* pParent = NULL);   // standard constructor

	int GetHorizTwips(); 
	void TwipsToPixels(POINT& pt);
	void PixelsToTwips(POINT& pt);
	void RowColFromPoint(POINT& pt, int& row, int& col);
	void RowColFromTwips(POINT& pt, int& row, int& col);
	
	void SetSignPostListPtr( DWORD pSignPostList );
	HRESULT	SetAcceptChords( long lRow, long lCol, BOOL bSet = TRUE );
	HRESULT	AddSignPostToList();
	HRESULT AddSignPostToGrid( SignPost* pSignPost, int nRow = -1);
	HRESULT AddSignPostToList( SignPost* pSignPost, int nCol );
	HRESULT SetSelectedChord( SignPost* pSignPost, int nCol );
	void NormalizeRowCol();
	void InitializeDialog( CChordDialog* pChordDialog, CPersonality* pPersonality, CPersonalityCtrl* const pCtrl );
	void OnClickGrid();

	long GetRowFromRowData( DWORD dwRowData );
	void ResizeGrid();
	HRESULT UpdateCadenceChord(int nRow, int nCol, bool bVal);
	HRESULT UpdateSignPostChord( int row );
	void UpdateOrphanStatus(bool bRefreshDisplay, SignPost *pSignPost=0);
	HRESULT STDMETHODCALLTYPE PreparePropChord( SignPost *pSignPost );

	// Edit Methods (not IDMUSProdTimelineEdit)
	HRESULT STDMETHODCALLTYPE Cut (IDataObject** );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ /* out */ IDataObject **ppIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDataObject* pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( /* in */ IDataObject* pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( void );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );

	// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);
	// IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );
	
	// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT		CreateDataObject(IDataObject**, POINTS where);
	HRESULT SaveSelectedChords(LPSTREAM, ChordSelection* pChordAtDragPoint, BOOL bNormalize = FALSE);
	ChordSelection* InternalCopy(POINTS ptDrop);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteAt( IDataObject* pIDataObject, POINTL pt, bool bDropNotEditPaste);

// Dialog Data
	//{{AFX_DATA(CSignPostDialog)
	enum { IDD = IDD_SIGNPOST_DIALOG };
	CMSFlexGrid	m_Grid;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSignPostDialog)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSignPostDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyUpGrid(short FAR* KeyCode, short Shift);
	afx_msg void OnMouseUpGrid(short Button, short Shift, long x, long y);
	afx_msg void OnDestroy();
	afx_msg void OnMouseDownGrid(short Button, short Shift, long x, long y);
	afx_msg void OnOLEDragOverGrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y, short FAR* State);
	afx_msg void OnOLEDragDropGrid(LPDISPATCH FAR* Data, long FAR* Effect, short FAR* Button, short FAR* Shift, float FAR* x, float FAR* y);
	afx_msg void OnClickCMSFlexGrid();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSignPostDialog)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};
#endif
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGNPOSTDIALOG_H__2B651786_E908_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabAudition.cpp ===
// TabAudition.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "DMUSProd.h"
#include "StyleDesigner.h"
#include "PersonalityDesigner.h"
#include "TabAudition.h"
#include "Chord.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabAudition property page

CTabAudition::CTabAudition( CPersonalityPageManager* pPageManager, IDMUSProdFramework* pIFramework ) : CPropertyPage(CTabAudition::IDD)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CTabAudition)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );
	ASSERT( pIFramework != NULL );

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pPageManager = pPageManager;
//	m_pPageManager->AddRef();		intentionally missing

	m_fHaveData = FALSE;
	m_fInOnSetActive = FALSE;
	m_fNeedToDetach = FALSE;

	m_pIStyleDocRootNode = NULL;
	m_dwGroove = 1;
	memset( &m_guidProject, 0, sizeof( m_guidProject ) );
}

CTabAudition::~CTabAudition()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	StyleListInfo* pStyleListInfo;

	while( !m_lstStyleListInfo.IsEmpty() )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
		delete pStyleListInfo;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}

	if( m_pIStyleDocRootNode )
	{
		m_pIStyleDocRootNode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::CopyDataToTab

void CTabAudition::CopyDataToTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIStyleDocRootNode )
	{
		m_pIStyleDocRootNode->Release();
		m_pIStyleDocRootNode = NULL;
	}

	if( pTabData )
	{
		m_fHaveData = TRUE;
		m_dwGroove = pTabData->dwGroove;
		memcpy( &m_guidProject, &pTabData->guidProject, sizeof( m_guidProject ) );

		m_pIStyleDocRootNode = pTabData->pIStyleDocRootNode;
		if( m_pIStyleDocRootNode )
		{
			m_pIStyleDocRootNode->AddRef();
		}

		m_pPersonality = pTabData->pPersonality;
	}
	else
	{
		m_fHaveData = FALSE;
		m_dwGroove = 0;
		memset( &m_guidProject, 0, sizeof( m_guidProject ) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::GetDataFromTab

void CTabAudition::GetDataFromTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	pTabData->pIStyleDocRootNode = m_pIStyleDocRootNode;
	pTabData->dwGroove = m_dwGroove;
	memcpy( &pTabData->guidProject, &m_guidProject, sizeof( pTabData->guidProject ) );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::EnableControls

void CTabAudition::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_comboStyle.EnableWindow( fEnable );
	m_spinGroove.EnableWindow(fEnable);
	m_editGroove.EnableWindow(fEnable);
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::SetGroove

void CTabAudition::SetGroove( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strGroove;
	strGroove.Format( "%d", m_dwGroove );
	m_editGroove.SetWindowText( strGroove );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::SetStyle

void CTabAudition::SetStyle( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	if( m_pIStyleDocRootNode == NULL )
	{
		SetStyleDocRootNode();
	}

	// Create a StyleListInfo struct for the current Style
	DMUSProdListInfo ListInfo;
	StyleListInfo* pStyleListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pStyleListInfo = new StyleListInfo;
	if( pStyleListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pIFramework->GetNodeFileGUID(	m_pIStyleDocRootNode, &pStyleListInfo->guidFile );

	if( m_pIStyleDocRootNode != NULL && SUCCEEDED ( m_pIStyleDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pStyleListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pStyleListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pIFramework->FindProject( m_pIStyleDocRootNode, &pIProject ) ) )
		{
			delete pStyleListInfo;
			goto LEAVE;
		}

		pStyleListInfo->pIProject = pIProject;
//		pStyleListInfo->pIProject->AddRef();	intentionally missing

		GUID guidProject;
		if( FAILED ( pIProject->GetGUID( &guidProject ) ) )
		{
			delete pStyleListInfo;
			goto LEAVE;
		}

		if( !IsEqualGUID( guidProject, m_guidProject ) )
		{
			BSTR bstrProjectName;

			if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				delete pStyleListInfo;
				goto LEAVE;
			}

			pStyleListInfo->strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}
	}
	else
	{
		delete pStyleListInfo;
		goto LEAVE;
	}

	// List is only built in OnDropDownComboStyle
	// If list is empty and we have a Style,
	//	just put the one item in the list
	if( m_lstStyleListInfo.IsEmpty() )
	{
		nPos = 0;
		m_lstStyleListInfo.AddTail( pStyleListInfo );
		InsertStyleInfoListInComboBox();
		goto LEAVE;
	}

	// Select the Style in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboStyle.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		StyleListInfo* pCurStyleListInfo = (StyleListInfo *)m_comboStyle.GetItemDataPtr( nCurPos );
		if( pCurStyleListInfo )
		{
			if( pCurStyleListInfo != (StyleListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurStyleListInfo->guidFile, pStyleListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}

	delete pStyleListInfo;
	pStyleListInfo = NULL;

	if( nMatch != CB_ERR )
	{
		nPos = nMatch;
	}


LEAVE:
	m_comboStyle.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


void CTabAudition::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabAudition)
	DDX_Control(pDX, IDC_SPIN_GROOVE, m_spinGroove);
	DDX_Control(pDX, IDC_EDIT_GROOVE, m_editGroove);
	DDX_Control(pDX, IDC_COMBO_STYLE, m_comboStyle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabAudition, CPropertyPage)
	//{{AFX_MSG_MAP(CTabAudition)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_STYLE, OnSelChangeComboStyle)
	ON_CBN_DROPDOWN(IDC_COMBO_STYLE, OnDropDownComboStyle)
	ON_EN_UPDATE(IDC_EDIT_GROOVE, OnUpdateEditGroove)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_GROOVE, OnDeltaposSpinGroove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabAudition message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabAudition:OnSetActive

BOOL CTabAudition::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set enable state of controls
	BOOL fEnable;

	if( m_fHaveData )
	{
		fEnable = TRUE;
	}
	else
	{
		fEnable = FALSE;
	}
	EnableControls( fEnable );

	// Place values in controls
	m_fInOnSetActive = TRUE;
	SetStyle();
	SetGroove();
	m_fInOnSetActive = FALSE;
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::OnInitDialog

BOOL CTabAudition::OnInitDialog( void ) 
{
	// Need this AFX_MANAGE_STATE so that resource defined
	// combo box strings can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();


	m_editGroove.LimitText(3);
	m_spinGroove.SetRange( 1,100 );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::OnCreate

int CTabAudition::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::OnDestroy

void CTabAudition::OnDestroy( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}




/////////////////////////////////////////////////////////////////////////////
// CTabAudition::OnSelChangeComboStyle

void CTabAudition::OnSelChangeComboStyle( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework != NULL );

	if( m_fInOnSetActive )
	{
		return;
	}

	int nItem = m_comboStyle.GetCurSel();
	if( nItem != CB_ERR )
	{
		StyleListInfo* pStyleListInfo = (StyleListInfo *)m_comboStyle.GetItemDataPtr( nItem );
		if( pStyleListInfo != (StyleListInfo *)-1 )
		{
			IDMUSProdNode* pIStyleDocRootNode;
			if(SUCCEEDED(m_pIFramework->FindDocRootNodeByFileGUID(pStyleListInfo->guidFile, &pIStyleDocRootNode)))
			{
				if( m_pIStyleDocRootNode )
				{
					m_pIStyleDocRootNode->Release();
					m_pIStyleDocRootNode = NULL;
				}
				m_pIStyleDocRootNode = pIStyleDocRootNode;
				m_pPageManager->UpdateObjectWithTabData();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::GetComboBoxText

void CTabAudition::GetComboBoxText( StyleListInfo* pStyleListInfo, CString& strText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pStyleListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pStyleListInfo->strName, pStyleListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pStyleListInfo->strProjectName, pStyleListInfo->strName, pStyleListInfo->strDescriptor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::InsertStyleInfo

void CTabAudition::InsertStyleInfo( StyleListInfo* pStyleListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	StyleListInfo* pListInfo;
	CString strListText;
	CString strStyleText;
	POSITION posList;

	GetComboBoxText( pStyleListInfo, strStyleText );

	POSITION pos = m_lstStyleListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pStyleListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pStyleListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstStyleListInfo.InsertBefore( pos, pStyleListInfo );
				}
				else
				{
					m_lstStyleListInfo.AddTail( pStyleListInfo );
				}
				return;
			}

			GetComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strStyleText ) > 0 )
			{
				m_lstStyleListInfo.InsertBefore( posList, pStyleListInfo );
				return;
			}
		}
	}

	m_lstStyleListInfo.AddTail( pStyleListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::BuildStyleInfoList

void CTabAudition::BuildStyleInfoList( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	StyleListInfo* pStyleListInfo;

	if( FAILED ( m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pStyleListInfo = new StyleListInfo;

				pStyleListInfo->pIProject = pIProject;
//				pStyleListInfo->pIProject->AddRef();	intentionally missing

				m_pIFramework->GetNodeFileGUID( pIFileNode, &pStyleListInfo->guidFile );

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
					if( !IsEqualGUID( guidProject, m_guidProject ) )
					{
						if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
						{
							pStyleListInfo->strProjectName = bstrProjectName;
							::SysFreeString( bstrProjectName );
						}
					}

				}

				if( ListInfo.bstrName )
				{
					pStyleListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pStyleListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				InsertStyleInfo( pStyleListInfo );

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::InsertStyleInfoListInComboBox

void CTabAudition::InsertStyleInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	StyleListInfo* pStyleListInfo;
	int nPos;

	POSITION pos = m_lstStyleListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.GetNext(pos) );
		if( pStyleListInfo )
		{
			GetComboBoxText( pStyleListInfo, strText );
			nPos = m_comboStyle.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboStyle.SetItemDataPtr( nPos, pStyleListInfo );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabAudition::OnDropDownComboStyle

void CTabAudition::OnDropDownComboStyle( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	StyleListInfo* pStyleListInfo;

	// Delete old StyleInfo list
	while( !m_lstStyleListInfo.IsEmpty() )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
		delete pStyleListInfo;
	}

	// Remove old list from combo box
	m_comboStyle.ResetContent();

	// Rebuild the StyleInfo list
	BuildStyleInfoList();
	InsertStyleInfoListInComboBox();

	// Select the current Style
	SetStyle();
}

void CTabAudition::SetStyleDocRootNode()
//
// Similar to BuildStyleInfoList, but extracts first style and sets doc root node.
//
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIFramework);

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdNode* pIFileNode;

	if( FAILED ( m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pIFramework->FindProject(m_pPersonality, &pIProject);

	hr = pIProject->GetFirstFileByDocType( pIDocType, &pIFileNode );

	if(SUCCEEDED(hr))
	{
		if(m_pIStyleDocRootNode)
		{
			m_pIStyleDocRootNode->Release();
		}
		m_pIStyleDocRootNode = pIFileNode;
		pIProject->Release();
	}

	pIDocType->Release();

}

void CTabAudition::OnUpdateEditGroove() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);


	if( m_fInOnSetActive )
	{
		return;
	}

	CString strGroove;

	if( ::IsWindow(m_editGroove.m_hWnd) == FALSE )
	{
		return;
	}

	m_editGroove.GetWindowText( strGroove );

	DWORD nGroove = (short)atoi( strGroove );
	if(nGroove < 1)
	{
		m_dwGroove = 100;
	}
	else if(nGroove >100)
	{
		m_dwGroove = 1;
	}
	else
	{
		m_dwGroove = nGroove;
	}

	if(nGroove != m_dwGroove)
	{
		m_fInOnSetActive = true;
		m_editGroove.SetWindowText( strGroove );
		m_fInOnSetActive = false;
	}

	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabAudition::OnDeltaposSpinGroove(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pNMHDR);

/*  Removed: causes control to be set twice, first time (from here) in the wrong direction (down instead of up and vice versa)
	if( m_fInOnSetActive )
	{
		return;
	}

	CString strGroove;

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	DWORD dwGroove = m_dwGroove - pNMUpDown->iDelta;

	if(dwGroove < 1)
	{
		m_dwGroove = 100;
	}
	else if(dwGroove >100)
	{
		m_dwGroove = 1;
	}
	else
	{
		m_dwGroove = dwGroove;
	}

	SetGroove();
*/
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabAudition.h ===
#if !defined(AFX_TABAUDITION_H__2B10A302_F7BB_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABAUDITION_H__2B10A302_F7BB_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabAudition.h : header file
//

#include "Personality.h"
#include "TabPersonality.h"


/////////////////////////////////////////////////////////////////////////////
// CTabAudition structures

#pragma pack(2)

typedef struct StyleListInfo
{
	IDMUSProdProject*	pIProject;
	CString			strProjectName;
	CString			strName;
	CString			strDescriptor;
	GUID			guidFile;
} StyleListInfo;

#pragma pack()


class CPersonalityPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabAudition dialog

class CTabAudition : public CPropertyPage
{
// Construction
public:
	CTabAudition( CPersonalityPageManager* pPageManager, IDMUSProdFramework* pIFramework );
	~CTabAudition();

// Dialog Data
	//{{AFX_DATA(CTabAudition)
	enum { IDD = IDD_TAB_AUDITION };
	CSpinButtonCtrl	m_spinGroove;
	CEdit	m_editGroove;
	CComboBox	m_comboStyle;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabAudition)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member variables
protected:
	IDMUSProdFramework*			 m_pIFramework;
	CPersonalityPageManager* m_pPageManager;

	BOOL		m_fNeedToDetach;
	BOOL		m_fHaveData;
	BOOL		m_fInOnSetActive;
	IDMUSProdNode*	m_pIStyleDocRootNode;
	DWORD		m_dwGroove;
	GUID		m_guidProject;
	CPersonality* m_pPersonality;

    CTypedPtrList<CPtrList, StyleListInfo*> m_lstStyleListInfo;

// Implementation
protected:
	void GetComboBoxText( StyleListInfo* pStyleListInfo, CString& strText );
	void InsertStyleInfo( StyleListInfo* pStyleListInfo );
	void BuildStyleInfoList();
	void InsertStyleInfoListInComboBox();
	void SetGroove();
	void SetStyle();

public:
	void SetStyleDocRootNode( void );
	void CopyDataToTab( tabPersonality* pTabData );
	void GetDataFromTab( tabPersonality* pTabData );

protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabAudition)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeComboStyle();
	afx_msg void OnDropDownComboStyle();
	afx_msg void OnUpdateEditGroove();
	afx_msg void OnDeltaposSpinGroove(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABAUDITION_H__2B10A302_F7BB_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D433F962_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_STDAFX_H__D433F962_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <Afxdisp.h>
#include <htmlhelp.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

#include <afxcmn.h>			// MFC ImageList Support

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D433F962_B588_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabChordPalette.cpp ===
// TabChordPalette.cpp : implementation file
//


#include "stdafx.h"
#pragma warning(disable:4201)
#include "personalitydesigner.h"
#include "TabChordPalette.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////// Callback for CKeyboard Events
//
void PaletteKeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CTabChordPalette* pdlg = (CTabChordPalette*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}



/////////////////////////////////////////////////////////////////////////////
// CTabChordPalette property page


CTabChordPalette::CTabChordPalette(CPersonalityPageManager* pPageManager, IDMUSProdFramework* pIFramework ) 
		: CPropertyPage(CTabChordPalette::IDD)
{
		AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CTabChordPalette)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );
	ASSERT( pIFramework != NULL );

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pPageManager = pPageManager;
//	m_pPageManager->AddRef();		intentionally missing

	m_fHaveData = FALSE;
	m_fInOnSetActive = FALSE;
	m_fNeedToDetach = FALSE;
}

CTabChordPalette::~CTabChordPalette()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
}

void CTabChordPalette::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabChordPalette)
	DDX_Control(pDX, IDC_SCALEKEYS, m_scalekeys);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabChordPalette, CPropertyPage)
	//{{AFX_MSG_MAP(CTabChordPalette)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_EXTENDOCTAVE, OnExtendoctave)
	ON_BN_CLICKED(IDC_HARMONICMINOR, OnHarmonicminor)
	ON_BN_CLICKED(IDC_MAJOR, OnMajor)
	ON_BN_CLICKED(IDC_MELODICMINOR, OnMelodicminor)
	ON_BN_CLICKED(IDC_SHIFTDOWN, OnShiftdown)
	ON_BN_CLICKED(IDC_SHIFTUP, OnShiftup)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabChordPalette message handlers

BEGIN_EVENTSINK_MAP(CTabChordPalette, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(CTabChordPalette)
	ON_EVENT(CTabChordPalette, IDC_SCALE_KEYS, 1 /* NoteDown */, OnNoteDownScaleKeys, VTS_I2)
	ON_EVENT(CTabChordPalette, IDC_SCALE_KEYS, 2 /* NoteUp */, OnNoteUpScaleKeys, VTS_I2)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

/*
	short nOtherKey = (nKey + 12) % 24;
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_Chord.m_dwUndetermined & UD_SCALEPATTERN)
	{
		m_Chord.m_dwUndetermined &= ~UD_SCALEPATTERN;
//		m_Chord.m_dwScalePattern ^= (1 << nKey);
		for (nKey = 0; nKey < 24; nKey++)
		{
			DrawScaleNote(&m_Chord,nKey);
		}
	}
	else
	{
		m_Chord.m_dwScalePattern ^= (1 << nKey);
		m_Chord.m_dwScalePattern ^= (1 << nOtherKey);
		DrawScaleNote(&m_Chord,nKey);
		DrawScaleNote(&m_Chord,nOtherKey);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
*/

void CTabChordPalette::OnNoteDownScaleKeys(short nKey) 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	long mask = m_lScalePattern & (1 << nKey);
	// set to opposite state
	int state = mask ? 0 : 2;
	m_scalekeys.SetNoteState(nKey, "", static_cast<short>(state));
	if(state == 0)
		m_lScalePattern ^= mask;
	else
		m_lScalePattern |= (1 << nKey);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnNoteUpScaleKeys(short nKey) 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(nKey);
	return;
//	m_scalekeys.AttachControlSite(this);
//	m_pPageManager->UpdateObjectWithTabData();
}

void CTabChordPalette::SetScale(long pattern)
{
	m_lScalePattern = pattern;
	for(short i = 0; i < 24; i++)
	{
		int state = m_lScalePattern & (1 << i) ? 2 : 0;
		m_scalekeys.SetNoteState(i, "", static_cast<short>(state));
	}
}

void CTabChordPalette::OnClear() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	SetScale(0);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnExtendoctave() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long l = m_lScalePattern & 0xfff;
	l |= (l << 12);
	SetScale(l);

	m_pPageManager->UpdateObjectWithTabData();
}

void CTabChordPalette::OnHarmonicminor() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long scale = 0x9AD9AD;
	scale = Rotate24(scale,  m_lKey);
	SetScale(scale);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnMajor() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long scale = 0xAB5AB5;
	scale = Rotate24(scale,  m_lKey);
	SetScale(scale);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnMelodicminor() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long scale = 0xAADAAD;
	scale = Rotate24(scale,  m_lKey);
	SetScale(scale);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnShiftdown() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long scale = Rotate24(m_lScalePattern, -1);
	SetScale(scale);
	m_pPageManager->UpdateObjectWithTabData();
	
}

void CTabChordPalette::OnShiftup() 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	long scale = Rotate24(m_lScalePattern, 1);
	SetScale(scale);

	m_pPageManager->UpdateObjectWithTabData();
	
}

BOOL CTabChordPalette::OnInitDialog() 
{
	// Need this AFX_MANAGE_STATE so that resource defined
	// combo box strings can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_scalekeys.SetLButtonUpCallback(PaletteKeyboardChangeCallback, this);

	CPropertyPage::OnInitDialog();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CTabChordPalette::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}

void CTabChordPalette::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CTabChordPalette::EnableControls(BOOL bEnable)
{
	UNREFERENCED_PARAMETER(bEnable);
}


BOOL CTabChordPalette::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnSetActive)
		return FALSE;

	// Set enable state of controls
	BOOL fEnable;

	if( m_fHaveData )
	{
		fEnable = TRUE;
	}
	else
	{
		fEnable = FALSE;
	}
	EnableControls( fEnable );

	// Place values in controls
	m_fInOnSetActive = TRUE;
	long x = m_lScalePattern;
//	m_scalekeys.Transpose(m_lKey, true);
	for(short i = 0; i < 24; i++)
	{
		if(x & 1)
			m_scalekeys.SetNoteState(i, "", 2);
		else
			m_scalekeys.SetNoteState(i, "", 0);
		x = x >> 1;
	}
	m_fInOnSetActive = FALSE;
	
	return CPropertyPage::OnSetActive();
	
}

/////////////////////////////////////////////////////////////////////////////
// CTabChordPalette::CopyDataToTab

void CTabChordPalette::CopyDataToTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pTabData)
	{
		m_lScalePattern = pTabData->lScalePattern;
		m_lKey = pTabData->dwKey;
		m_bUseFlats = CPersonality::GetFlatsFlag(m_lKey);
		DWORD key = m_lKey;
		CPersonality::SetFlatsFlag(false, key);
		m_lKey = key;
		m_lKey -= 12;	// transpose factor
//		m_lScalePattern = Rotate24(m_lScalePattern,  m_lKey);
		m_fHaveData = TRUE;
	}
	else
	{
		m_fHaveData = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabChordPalette::GetDataFromTab

void CTabChordPalette::GetDataFromTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pTabData)
	{
		pTabData->lScalePattern = m_lScalePattern;
		// comment is intentional: m_lKey is read only, DO NOT PASS BACK TO PERSONALITY !
//		pTabData->dwKey = m_lKey;
	}	
}

void CTabChordPalette::PreProcessPSP(PROPSHEETPAGE & psp, BOOL bWizard)
{
	UNREFERENCED_PARAMETER(bWizard);
	PreProcessPageTemplate(psp, FALSE);
}

LRESULT CTabChordPalette::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{	
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return CPropertyPage::WindowProc(message, wParam, lParam);
}

BOOL CTabChordPalette::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CTabChordPalette::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	if(pKeyboard == &m_scalekeys)
	{
		OnNoteDownScaleKeys(nKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\Splitter.cpp ===
// Splitter.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "Splitter.h"
#include "PersonalityDesigner.h"
#include "PersonalityCtl.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CPersonalityDesignerApp theApp;

//*****************************************************************************
//***** CSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CSplitter, CWnd)
	//{{AFX_MSG_MAP(CSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CSplitter::CSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_pParent(NULL),
	m_nWidth(0),
	m_rcFirstPane(0, 0, 0, 0),
	m_rcSecondPane(0, 0, 0, 0),
	m_pFirstPane(NULL),
	m_pSecondPane(NULL)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
}

//*****************************************************************************
CSplitter::~CSplitter()
{
}

//*****************************************************************************
BOOL CSplitter::Create( CWnd *pParent, RECT *rect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Save our parent
	m_pParent = pParent;

	if( rect )
	{
		RECT tempRect;
		m_pParent->GetWindowRect( &tempRect );
				
		m_rcTrack = *rect;
		m_rcSecondPane = m_rcFirstPane = m_rcTrack;

		m_rcFirstPane.left = 0;
		m_rcFirstPane.right = m_rcTrack.left-1;
		m_rcSecondPane.left = m_rcTrack.right+1;
		m_rcSecondPane.right = tempRect.right;

		m_nWidth = rect->right-rect->left;
		ASSERT( m_nWidth > 0 );
	}

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "DittoSplitterClass";
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = AfxGetInstanceHandle();
	wc.hCursor       = theApp.LoadCursor( MAKEINTRESOURCE(IDC_SPLITTER) );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 m_rcTrack, pParent, IDC_SPLITTER );
}

//*****************************************************************************
void CSplitter::OnPaint()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RECT rc;

	// Make sure Splitter bar and panes are updated when
	// the parent resizes.
	m_pParent->GetClientRect( &rc );
	m_rcTrack.bottom = rc.bottom;

	MoveWindow( &m_rcTrack, FALSE );

	// Resize First Pane
	m_rcFirstPane.right = m_rcTrack.left;
	m_rcFirstPane.bottom = m_rcTrack.bottom;

	// Resize Second Pane
	m_rcSecondPane.left = m_rcTrack.right;
	m_rcSecondPane.bottom = m_rcTrack.bottom;
	m_rcSecondPane.right = rc.right;

	// Resize First Pane
	m_pFirstPane->MoveWindow( &m_rcFirstPane );

	// Resize First Pane Window
	m_pSecondPane->MoveWindow( &m_rcSecondPane );

	// Paint Scroll Bar
	CPaintDC dc( this );
	GetClientRect( &rc );
	dc.Draw3dRect( &rc, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));
}

//*****************************************************************************
void CSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our main frame's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );
	//m_rcTrack.top++; m_rcTrack.bottom--; m_rcTrack.right--;

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent != NULL );
	BOOL fWasTracking = m_fTracking;

	OnEndCapture();
	
	if(fWasTracking)
	{
		RECT rect;
		m_pParent->GetClientRect( &rect );
		static_cast<CPersonalityCtrl*>(m_pParent)->EndTrack( m_rcTrack.left );

		MoveWindow(	&m_rcTrack );
		OnPaint();
	}
}

//*****************************************************************************
void CSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fTracking )
	{
		// Convert out point to client coordinates of our frame
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our frame
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		if( (point.x + 34) > rcClient.right )
		{
			point.x = rcClient.right - 34;
		}
		if( (point.x - 31) < rcClient.left )
		{
			point.x = rcClient.left + 31;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.left != (point.x - 1) )
		{
			InvertTracker();
//			if(point.x < CPersonalityCtrl::MinSplitterXPos)
//			{
//				point.x = CPersonalityCtrl::MinSplitterXPos;
//			}
			m_rcTrack.left  = point.x - (m_nWidth>>1);
			m_rcTrack.right = point.x + (m_nWidth>>1);
			m_rcTrack.bottom = rcClient.bottom;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CSplitter::OnCancelMode()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CSplitter::OnCaptureChanged( CWnd *pWnd )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CSplitter::OnEndCapture()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CSplitter::InvertTracker()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pParent );

	// Get the DC of our main frame
	CDC *pDC = m_pParent->GetDC();

	ASSERT( pDC );

	// Create our inverted brush pattern (looks just like frame window sizing)
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, m_rcTrack.top, m_rcTrack.Width(), m_rcTrack.Height(), PATINVERT );

	// Free our brush and DC
	if (hBrushStock != NULL)
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}
	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;
}

BOOL CSplitter::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (pWnd == this)?CWnd::OnSetCursor(pWnd, nHitTest, message):FALSE;
}

RECT CSplitter::GetFirstPaneRect()
{	
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_rcFirstPane;
}

RECT CSplitter::GetSecondPaneRect()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_rcSecondPane;
}

void CSplitter::SetFirstPane( CWnd *pPane )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pFirstPane = pPane;
}

void CSplitter::SetSecondPane( CWnd *pPane )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pSecondPane = pPane;
}



void CSplitter::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	// TODO: Add your message handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabPersonality.h ===
#if !defined(AFX_TABPERSONALITY_H__1E9289E2_F7AC_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABPERSONALITY_H__1E9289E2_F7AC_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabPersonality.h : header file
//

#include "Personality.h"

/////////////////////////////////////////////////////////////////////////////
// tabPersonality struct

#pragma pack(2)

typedef struct tabPersonality		// Used to pass data from Personality to page
{									// Used to pass data from page to Personality
	GUID		guidProject;
	CString		strName;
//	CString		strRefName;			// removed: reference name is now fixed.
	CString		strDescription;
	BOOL		fUseTimeSignature;
	BOOL		fVariableNotFixed;
	short		nBPM;
	short		nBeat;
	DWORD	dwKey;
	IDMUSProdNode*	pIStyleDocRootNode;
	DWORD		dwGroove;
	short		nChordMapLength;			// length of chord map
	long		lScalePattern;
	CPersonality*	pPersonality;
} tabPersonality;

#pragma pack()


class CPersonalityPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabPersonality dialog

class CTabPersonality : public CPropertyPage
{
// Construction
public:
	CTabPersonality( CPersonalityPageManager* pPageManager );
	~CTabPersonality();

// Dialog Data
	//{{AFX_DATA(CTabPersonality)
	enum { IDD = IDD_TAB_PERSONALITY };
	CStatic	m_staticTimeSig;
	CSpinButtonCtrl	m_spinkey;
	CSpinButtonCtrl	m_spinBPM;
	CEdit	m_editName;
	CEdit	m_editDescription;
	CComboBox	m_comboBeat;
	CEdit	m_editBPM;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabPersonality)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member variables
protected:
	CPersonalityPageManager* m_pPageManager;

	BOOL		m_fNeedToDetach;
	BOOL		m_fHaveData;
	BOOL		m_fInOnSetActive;
	CString		m_strName;
//	CString		m_strRefName;
	CString		m_strDescription;
	BOOL		m_fUseTimeSignature;
	BOOL		m_fVariableNotFixed;
	short		m_nBPM;
	short		m_nBeat;
	short		m_nChordMapLength;
	DWORD	m_dwKey;
	long		m_lScalePattern;
// Implementation
protected:
	void SetTimeSignature();

public:
	void OnChangeRoot();
	void CopyDataToTab( tabPersonality* pTabData );
	void GetDataFromTab( tabPersonality* pTabData );

protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabPersonality)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeName();
	afx_msg void OnChangeRefName();
	afx_msg void OnChangeDescription();
	afx_msg void OnSelchangeComboBeat();
	afx_msg void OnChangeBPM();
	afx_msg void OnChangeLength();
	afx_msg void OnKillfocusName();
	afx_msg void OnDeltaposSpinkey(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUseflats();
	afx_msg void OnUsesharps();
	afx_msg void OnRadiofix();
	afx_msg void OnRadiovar();
	afx_msg void OnKillfocusRefName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABPERSONALITY_H__1E9289E2_F7AC_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabPersonality.cpp ===
// TabPersonality.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "PersonalityDesigner.h"
#include "Personality.h"
#include "TabPersonality.h"
#include "DlgChangeLength.h"
#include "LockoutNotification.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabPersonality property page

CTabPersonality::CTabPersonality( CPersonalityPageManager* pPageManager ) : CPropertyPage(CTabPersonality::IDD)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CTabPersonality)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pPageManager = pPageManager;
//	m_pPageManager->AddRef();		intentionally missing

	m_fHaveData = FALSE;
	m_fInOnSetActive = FALSE;
	m_fNeedToDetach = FALSE;

	m_fUseTimeSignature = FALSE;
	m_nBPM = 0;
	m_nBeat = 0;
	m_nChordMapLength = 0;
	m_dwKey = 12;
	m_lScalePattern = 0xab5ab5;
	m_fVariableNotFixed = FALSE;
}

CTabPersonality::~CTabPersonality()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::CopyDataToTab

void CTabPersonality::CopyDataToTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pTabData )
	{
		m_fHaveData = TRUE;

		m_strName = pTabData->strName;
//		m_strRefName = pTabData->strRefName;
		m_strDescription = pTabData->strDescription;

		m_fUseTimeSignature = pTabData->fUseTimeSignature;
		m_fVariableNotFixed = pTabData->fVariableNotFixed;
		m_nBPM = pTabData->nBPM;
		m_nBeat = pTabData->nBeat;
		m_dwKey = pTabData->dwKey;
		m_lScalePattern = pTabData->lScalePattern;
		m_nChordMapLength = pTabData->nChordMapLength;
	}
	else
	{
		m_fHaveData = FALSE;

		m_strName.Empty();
//		m_strRefName.Empty();
		m_strDescription.Empty();

		m_fUseTimeSignature = FALSE;
		m_fVariableNotFixed = FALSE;
		m_nBPM = 0;
		m_nBeat = 0;
		m_nChordMapLength = 0;

		m_dwKey = 12;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::GetDataFromTab

void CTabPersonality::GetDataFromTab( tabPersonality* pTabData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	pTabData->strName = m_strName;
//	pTabData->strRefName = m_strRefName;
	pTabData->strDescription = m_strDescription;

	pTabData->fUseTimeSignature = m_fUseTimeSignature;
	pTabData->fVariableNotFixed = m_fVariableNotFixed;
	pTabData->nBPM = m_nBPM;
	pTabData->nBeat = m_nBeat;
	pTabData->dwKey = m_dwKey;
	pTabData->lScalePattern = m_lScalePattern;
	pTabData->nChordMapLength = m_nChordMapLength;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::EnableControls

void CTabPersonality::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_editName.EnableWindow( fEnable );
//	m_editRefName.EnableWindow( fEnable );
	m_editDescription.EnableWindow( fEnable );

//	m_checkUseTimeSig.EnableWindow( FALSE );	// TEMP - FALSE until free form editing supported
//	m_checkUseTimeSig.EnableWindow( fEnable );
/*
	if( m_fUseTimeSignature == FALSE )
	{
		fEnable = FALSE;
	}
*/
	m_staticTimeSig.EnableWindow( fEnable );
	m_editBPM.EnableWindow( fEnable );
	m_spinBPM.EnableWindow( fEnable );
	m_comboBeat.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::SetTimeSignature

void CTabPersonality::SetTimeSignature( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fUseTimeSignature == FALSE )
	{
		m_staticTimeSig.SetWindowText( _T("") );
		m_editBPM.SetWindowText( _T("") );
		m_comboBeat.SetCurSel( -1 );
		m_spinBPM.SetPos( 1 );
		return;
	}

	CString strText;

	strText.Format( "%d/%d", m_nBPM, m_nBeat );
	m_staticTimeSig.SetWindowText( strText );

	strText.Format( "%d", m_nBPM );
	m_editBPM.SetWindowText( strText );
	m_spinBPM.SetPos( m_nBPM  );

    int i;
	for( i = 0 ;  i < 5 ;  i++ )
	{
        if( (1 << i) == m_nBeat )
            break ;
    }
	m_comboBeat.SetCurSel( i );
}


void CTabPersonality::DoDataExchange( CDataExchange* pDX )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabPersonality)
	DDX_Control(pDX, IDC_STATICTIMESIG, m_staticTimeSig);
	DDX_Control(pDX, IDC_SPINKEY, m_spinkey);
	DDX_Control(pDX, IDC_SPIN_BPM, m_spinBPM);
	DDX_Control(pDX, IDC_NAME, m_editName);
	DDX_Control(pDX, IDC_DESCRIPTION, m_editDescription);
	DDX_Control(pDX, IDC_COMBO_BEAT, m_comboBeat);
	DDX_Control(pDX, IDC_BPM, m_editBPM);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabPersonality, CPropertyPage)
	//{{AFX_MSG_MAP(CTabPersonality)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	ON_EN_CHANGE(IDC_REF_NAME, OnChangeRefName)
	ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
	ON_CBN_SELCHANGE(IDC_COMBO_BEAT, OnSelchangeComboBeat)
	ON_EN_CHANGE(IDC_BPM, OnChangeBPM)
	ON_BN_CLICKED(IDC_CHANGELENGTH, OnChangeLength)
	ON_EN_KILLFOCUS(IDC_NAME, OnKillfocusName)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPINKEY, OnDeltaposSpinkey)
	ON_BN_CLICKED(IDC_USEFLATS, OnUseflats)
	ON_BN_CLICKED(IDC_USESHARPS, OnUsesharps)
	ON_BN_CLICKED(IDC_RADIOFIX, OnRadiofix)
	ON_BN_CLICKED(IDC_RADIOVAR, OnRadiovar)
	ON_EN_KILLFOCUS(IDC_REF_NAME, OnKillfocusRefName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabPersonality message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnSetActive

BOOL CTabPersonality::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPageManager && m_pPageManager->m_pIPropPageObject )
	{
		CLockoutNotification lock(m_hWnd);	// keep notifications out while we are here!
		// Set enable state of controls
		BOOL fEnable;

		if( m_fHaveData )
		{
			fEnable = TRUE;
		}
		else
		{
			fEnable = FALSE;
		}
		EnableControls( fEnable );

		m_pPageManager->RefreshData();

		// Place values in controls
		m_fInOnSetActive = TRUE;
		m_editName.SetWindowText( m_strName );
	//	m_editRefName.SetWindowText( m_strRefName );
		m_editDescription.SetWindowText( m_strDescription );
	//	m_checkUseTimeSig.SetCheck( m_fUseTimeSignature );
		SetTimeSignature();

		char str[30];
		CPersonality::RootToString(str, m_dwKey);
		SetDlgItemText(IDC_EDITKEY, str);

		if(CPersonality::GetFlatsFlag(m_dwKey))
		{
			CheckRadioButton(IDC_USESHARPS, IDC_USEFLATS , IDC_USEFLATS);
		}
		else
		{
			CheckRadioButton(IDC_USESHARPS, IDC_USEFLATS, IDC_USESHARPS);
		}
		
		if(m_fVariableNotFixed)
		{
			CheckRadioButton( IDC_RADIOFIX, IDC_RADIOVAR, IDC_RADIOVAR );
		}
		else
		{
			CheckRadioButton( IDC_RADIOFIX, IDC_RADIOVAR, IDC_RADIOFIX );
		}
		
		m_fInOnSetActive = FALSE;
	}
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnInitDialog

BOOL CTabPersonality::OnInitDialog( void ) 
{
	// Need this AFX_MANAGE_STATE so that resource defined
	// combo box strings can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	m_editName.LimitText( 20 );
//	m_editRefName.LimitText( 20 );
	m_editDescription.LimitText( 80 );
	m_editBPM.LimitText( 2 );
	m_spinBPM.SetRange( 1,99 );
//	m_spinkey.SetRange(0,23);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnCreate

int CTabPersonality::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnDestroy

void CTabPersonality::OnDestroy( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnChangeName

void CTabPersonality::OnChangeName( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
/*
	if( m_fInOnSetActive )
	{
		return;
	}

	// Save the current caret position because UpdateObjectWithTabData changes
	// it.
	DWORD dwSel = m_editName.GetSel();

	m_editName.GetWindowText( m_strName );
	m_pPageManager->UpdateObjectWithTabData();

	
	// Restore current caret position.
	m_editName.SetFocus();
	m_editName.SetSel( dwSel, TRUE );
*/
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnChangeRefName

void CTabPersonality::OnChangeRefName( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
/*
	if( m_fInOnSetActive )
	{
		return;
	}

	m_editRefName.GetWindowText( m_strRefName );
	m_pPageManager->UpdateObjectWithTabData();
*/
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnChangeDescription

void CTabPersonality::OnChangeDescription( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fInOnSetActive )
	{
		return;
	}

	m_editDescription.GetWindowText( m_strDescription );
	m_pPageManager->UpdateObjectWithTabData();
}




/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnChangeBPM

void CTabPersonality::OnChangeBPM( void ) 
{
	// Need this AFX_MANAGE_STATE so that error
	// message string resource can be found
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (m_fInOnSetActive == TRUE)
	||  (m_fUseTimeSignature == FALSE) )
	{
		return;
	}

	CString strBPM;

	m_editBPM.GetWindowText( strBPM );

	short nBPM = (short)atoi( strBPM );
	if( (nBPM < 0)
	||  (nBPM > 100) )
	{
		AfxMessageBox( IDS_ERR_BPM_VALUE );
		strBPM.Format( "%d", m_nBPM );
		m_editBPM.SetWindowText( strBPM );
		m_editBPM.SetFocus();
		m_editBPM.SetSel( 0, -1 );
		return;
	}

	CString strText;

	m_nBPM = nBPM;
	strText.Format( "%d/%d", m_nBPM, m_nBeat );
	m_staticTimeSig.SetWindowText( strText );
	m_pPageManager->UpdateObjectWithTabData();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonality::OnSelchangeComboBeat

void CTabPersonality::OnSelchangeComboBeat( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fInOnSetActive )
	{
		return;
	}

	int nCursel = m_comboBeat.GetCurSel();
	if( nCursel != CB_ERR )
	{
		CString strText;

		m_nBeat = (short)(1 << nCursel) ;
		strText.Format( "%d/%d", m_nBPM, m_nBeat );
		m_staticTimeSig.SetWindowText( strText );
		m_pPageManager->UpdateObjectWithTabData();
	}
}

void CTabPersonality::OnChangeLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fInOnSetActive )
	{
		return;
	}
	CDlgChangeLength dlg(this);
	dlg.SetChordMapLength(m_nChordMapLength);
	int retval = dlg.DoModal();
	if(retval == IDOK)
	{
		CString s;
		bool bMakeChange = true;
		short n = (short)atoi((LPCSTR)dlg.m_strLength);
		if(n < 1)
		{
			s.LoadString(IDS_LENGTHTOOSMALL);
			AfxMessageBox(s);
			n = 1;
		}
		else if(n > 100)
		{
			s.LoadString(IDS_LENGTHTOOLARGE);
			AfxMessageBox(s);
			n = 100;
		}
		if(n < m_nChordMapLength)
		{
			if(m_pPageManager->GetPersonality()->CheckForData(n))
			{
				s.LoadString(IDS_SHORTEN_LENGTH);
				retval = AfxMessageBox(s, MB_YESNO);
				if(retval != IDYES)
				{
					bMakeChange = false;
				}
			}
		}
		if(bMakeChange)
		{
			m_nChordMapLength = n;
			m_pPageManager->UpdateObjectWithTabData();
		}
	}
}

void CTabPersonality::OnKillfocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;

	if( m_fInOnSetActive )
	{
		return;
	}
	m_editName.GetWindowText(strName);

	// strip leading and trailing ws
	strName.TrimRight();
	strName.TrimLeft();

	if(strName.IsEmpty())
	{
		m_editName.SetWindowText(m_strName);
	}
	else
	{
		if(strName.Compare(m_strName) != 0)
		{
		/* ref name no longer editable by user
			if(m_strName.Compare(m_strRefName) == 0)
			{
				// keep in sync
				m_strRefName = strName;
			}
		*/
			m_strName = strName;
			m_pPageManager->UpdateObjectWithTabData();
		}
	}
}

void CTabPersonality::OnDeltaposSpinkey(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	if( m_fInOnSetActive )
	{
		return;
	}
	bool useflats = CPersonality::GetFlatsFlag(m_dwKey);
	CPersonality::SetFlatsFlag(false, m_dwKey);

	DWORD oldkey = m_dwKey & ~CPersonality::UseFlats;

	m_dwKey -= pNMUpDown->iDelta;

	if(m_dwKey < 0 || m_dwKey >= 0x80000000)
		m_dwKey = 0;
	if(m_dwKey > 23)
		m_dwKey = 23;

	CPersonality::SetFlatsFlag(useflats, m_dwKey);

	DWORD keydiff = (m_dwKey & ~CPersonality::UseFlats) - oldkey;
	if(keydiff != 0)
	{
		// adjust scale;
//		m_lScalePattern = Rotate24(m_lScalePattern, keydiff);
		// update
		OnChangeRoot();
	}
	
	*pResult = 0;
}

void CTabPersonality::OnChangeRoot()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];

	if( m_fInOnSetActive )
	{
		return;
	}
	CPersonality::RootToString(str, m_dwKey);
	SetDlgItemText(IDC_EDITKEY, str);

	m_pPageManager->UpdateObjectWithTabData();
}

void CTabPersonality::OnUseflats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_fInOnSetActive )
	{
		return;
	}
	if(!CPersonality::GetFlatsFlag(m_dwKey))
	{
		CPersonality::SetFlatsFlag(true, m_dwKey);
		OnChangeRoot();
	}
}

void CTabPersonality::OnUsesharps() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_fInOnSetActive )
	{
		return;
	}
	if(CPersonality::GetFlatsFlag(m_dwKey))
	{
		CPersonality::SetFlatsFlag(false, m_dwKey);
		OnChangeRoot();
	}	
}

void CTabPersonality::OnRadiofix() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_fInOnSetActive )
	{
		return;
	}
	m_fVariableNotFixed = FALSE;
	CheckRadioButton( IDC_RADIOFIX, IDC_RADIOVAR, IDC_RADIOFIX );
	m_pPageManager->UpdateObjectWithTabData();	
}

void CTabPersonality::OnRadiovar() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_fInOnSetActive )
	{
		return;
	}
	m_fVariableNotFixed = TRUE;
	CheckRadioButton( IDC_RADIOFIX, IDC_RADIOVAR, IDC_RADIOVAR );
	m_pPageManager->UpdateObjectWithTabData();
}

void CTabPersonality::OnKillfocusRefName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
/* ref name no longer editable by user
	CString strName;

	m_editRefName.GetWindowText(strName);

	// strip leading and trailing ws
	strName.TrimRight();
	strName.TrimLeft();

	if(strName.IsEmpty())
	{
		m_editRefName.SetWindowText(m_strRefName);
	}
	else
	{
		if(strName.Compare(m_strRefName) != 0)
		{
			m_strRefName = strName;
			m_pPageManager->UpdateObjectWithTabData();
		}
	}
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabChordPalette.h ===
#include "..\shared\Keyboard.h"

#if !defined(AFX_TABCHORDPALETTE_H__1DF95105_798A_11D1_984C_00805FA67D16__INCLUDED_)
#define AFX_TABCHORDPALETTE_H__1DF95105_798A_11D1_984C_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabChordPalette.h : header file
//

#include "Personality.h"
#include "TabPersonality.h"


/////////////////////////////////////////////////////////////////////////////
// CTabChordPalette dialog

class CTabChordPalette : public CPropertyPage
{

// Construction
public:
	CTabChordPalette(CPersonalityPageManager* pPageManager, IDMUSProdFramework* pIFramework );
	~CTabChordPalette();

public:
	void PreProcessPSP(PROPSHEETPAGE& psp, BOOL bWizard);
	void CopyDataToTab( tabPersonality* pTabData );
	void GetDataFromTab( tabPersonality* pTabData );
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(CTabChordPalette)
	enum { IDD = IDD_TAB_CHORDPALETTE };
	CKeyboard	m_scalekeys;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabChordPalette)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnableControls(BOOL bEnable);
	void SetScale(long pattern);
	IDMUSProdFramework*			 m_pIFramework;
	CPersonalityPageManager* m_pPageManager;
	BOOL		m_fHaveData;
	BOOL		m_fInOnSetActive;
	long		m_lKey;	// read only! Used to set scales correctly
	bool			m_bUseFlats;	// so that m_dwKey is absolute key
	DWORD		m_lScalePattern;
	BOOL		m_fNeedToDetach;

	// Generated message map functions
	//{{AFX_MSG(CTabChordPalette)
	afx_msg void OnNoteDownScaleKeys(short nKey);
	afx_msg void OnNoteUpScaleKeys(short nKey);
	afx_msg void OnClear();
	afx_msg void OnExtendoctave();
	afx_msg void OnHarmonicminor();
	afx_msg void OnMajor();
	afx_msg void OnMelodicminor();
	afx_msg void OnShiftdown();
	afx_msg void OnShiftup();
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABCHORDPALETTE_H__1DF95105_798A_11D1_984C_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefIO.cpp ===
#include "stdafx.h"
#include "PersRefIO.h"
#include "ChordMapRefStripMgr.h"
#include "PersRefMgr.h"


CPersRefItem::CPersRefItem( CPersRefMgr* pPersRefMgr )
{
	ASSERT( pPersRefMgr != NULL );
	m_pPersRefMgr = pPersRefMgr;

	m_fSelected = FALSE;
	m_fRemoveNotify = FALSE;
}

CPersRefItem::~CPersRefItem()
{
	// Turn off notifications for this node
	if( m_pIPersDocRootNode )
	{
		if( m_fRemoveNotify )
		{
			if( m_pPersRefMgr
			&&  m_pPersRefMgr->m_pISegmentNode 
			&&  m_pPersRefMgr->m_pDMProdFramework )
			{
				m_pPersRefMgr->m_pDMProdFramework->RemoveFromNotifyList( m_pIPersDocRootNode,
																		 m_pPersRefMgr->m_pISegmentNode );
			}
		}
	}
}

BOOL CPersRefItem::After(const CPersRefItem& PersRef)
{
	if( m_dwMeasure > PersRef.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == PersRef.m_dwMeasure )
	{
		if( m_bBeat > PersRef.m_bBeat )
		{
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CPersRefItem::Before(const CPersRefItem& PersRef)
{
	if( m_dwMeasure < PersRef.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == PersRef.m_dwMeasure )
	{
		if( m_bBeat < PersRef.m_bBeat )
		{
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabPersonalityInfo.cpp ===
// TabPersonalityInfo.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(push)
#pragma warning(disable:4201)
#include "personalitydesigner.h"
#include "Personality.h"
#pragma warning(push)
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo property page


CTabPersonalityInfo::CTabPersonalityInfo(CPersonalityPageManager* pPageManager) : CPropertyPage(CTabPersonalityInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabPersonalityInfo)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pPersonality = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;

}

CTabPersonalityInfo::~CTabPersonalityInfo()
{
}

/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::SetPersonality

void CTabPersonalityInfo::SetPersonality( CPersonality* pPersonality )
{
	m_pPersonality = pPersonality;

	UpdateControls();
}

void CTabPersonalityInfo::SetModifiedFlag()
{
	ASSERT(m_pPersonality != NULL);
	m_pPersonality->Modified() = TRUE;;
}

/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::EnableControls

void CTabPersonalityInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::UpdateControls

void CTabPersonalityInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pPersonality )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pPersonality->m_strAuthor );
		m_editCopyright.SetWindowText( m_pPersonality->m_strCopyright );
		m_editInfo.SetWindowText( m_pPersonality->m_strInfo );
		m_editSubject.SetWindowText( m_pPersonality->m_strSubject );
		
		strText.Format( "%u", ((m_pPersonality->m_dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pPersonality->m_dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pPersonality->m_dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pPersonality->m_dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editInfo.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}



void CTabPersonalityInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabPersonalityInfo)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabPersonalityInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabPersonalityInfo)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo message handlers
/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusAuthor

void CTabPersonalityInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pPersonality->m_strAuthor ) != 0 )
		{
			m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_AUTHOR );
			m_pPersonality->m_strAuthor = strAuthor;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusCopyright

void CTabPersonalityInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pPersonality->m_strCopyright ) != 0 )
		{
			m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_COPYRIGHT );
			m_pPersonality->m_strCopyright = strCopyright;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusInfo

void CTabPersonalityInfo::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pPersonality->m_strInfo ) != 0 )
		{
			m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_INFO );
			m_pPersonality->m_strInfo = strInfo;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusSubject

void CTabPersonalityInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pPersonality->m_strSubject ) != 0 )
		{
			m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_SUBJECT );
			m_pPersonality->m_strSubject = strSubject;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusVersion_1

void CTabPersonalityInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strVersion_1;
		CString strPersonalityVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pPersonality->m_dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strPersonalityVersion_1.Format( "%u", ((m_pPersonality->m_dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strPersonalityVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_VERSION );
				m_pPersonality->m_dwVersionMS &= 0x0000FFFF;
				m_pPersonality->m_dwVersionMS |= dwVersion_1;
				SetModifiedFlag();

				// Sync personality (with new version) to engine
				m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusVersion_2

void CTabPersonalityInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strVersion_2;
		CString strPersonalityVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pPersonality->m_dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strPersonalityVersion_2.Format( "%u", (m_pPersonality->m_dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strPersonalityVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_VERSION );
				m_pPersonality->m_dwVersionMS &= 0xFFFF0000;
				m_pPersonality->m_dwVersionMS |= dwVersion_2;
				SetModifiedFlag();

				// Sync personality (with new version) to engine
				m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusVersion_3

void CTabPersonalityInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strVersion_3;
		CString strPersonalityVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pPersonality->m_dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strPersonalityVersion_3.Format( "%u", ((m_pPersonality->m_dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strPersonalityVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_VERSION );
				m_pPersonality->m_dwVersionLS &= 0x0000FFFF;
				m_pPersonality->m_dwVersionLS |= dwVersion_3;
				SetModifiedFlag();

				// Sync personality (with new version) to engine
				m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo::OnKillFocusVersion_4

void CTabPersonalityInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CString strVersion_4;
		CString strPersonalityVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pPersonality->m_dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strPersonalityVersion_4.Format( "%u", (m_pPersonality->m_dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strPersonalityVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_Personality_VERSION );
				m_pPersonality->m_dwVersionLS &= 0xFFFF0000;
				m_pPersonality->m_dwVersionLS |= dwVersion_4;
				SetModifiedFlag();

				// Sync personality (with new version) to engine
				m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);
			}
		}
	}
}


int CTabPersonalityInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}

BOOL CTabPersonalityInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CPersonalityPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}

void CTabPersonalityInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CTabPersonalityInfo::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality == NULL )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_AUTHOR: 
								m_editAuthor.SetWindowText( m_pPersonality->m_strAuthor );
								break;

							case IDC_COPYRIGHT: 
								m_editCopyright.SetWindowText( m_pPersonality->m_strCopyright );
								break;

							case IDC_INFO: 
								m_editInfo.SetWindowText( m_pPersonality->m_strInfo );
								break;

							case IDC_SUBJECT: 
								m_editSubject.SetWindowText( m_pPersonality->m_strSubject );
								break;

							case IDC_VERSION_1:
							{
								CString strText;

								strText.Format( "%u", ((m_pPersonality->m_dwVersionMS & 0xFFFF0000) >> 16) );
								m_editVersion_1.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_2: 
							{
								CString strText;
	
								strText.Format( "%u", (m_pPersonality->m_dwVersionMS & 0x0000FFFF) );
								m_editVersion_2.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_3: 
							{
								CString strText;
	
								strText.Format( "%u", ((m_pPersonality->m_dwVersionLS & 0xFFFF0000) >> 16) );
								m_editVersion_3.SetWindowText( strText );
								break;
							}

							case IDC_VERSION_4: 
							{
								CString strText;
	
								strText.Format( "%u", (m_pPersonality->m_dwVersionLS & 0x0000FFFF) );
								m_editVersion_4.SetWindowText( strText );
								break;
							}
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void CTabPersonalityInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPersonality )
	{
		CGuidDlg dlg;
		memcpy( &dlg.m_guid, &m_pPersonality->m_guidPersonality, sizeof(GUID) );
		if( dlg.DoModal() == IDOK )
		{
			m_pPersonality->m_pUndoMgr->SaveState( m_pPersonality, theApp.m_hInstance, IDS_UNDO_GUID );
			memcpy( &m_pPersonality->m_guidPersonality, &dlg.m_guid, sizeof(GUID) );
			SetModifiedFlag();

			// Sync personality (with new GUID) to engine
			m_pPersonality->SyncPersonalityWithEngine(CPersonality::syncPersonality);

			// Notify connected nodes that Personality GUID has changed
			m_pPersonality->m_pComponent->m_pIFramework->NotifyNodes( m_pPersonality, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersonalityDesigner\TabPersonalityInfo.h ===
#if !defined(AFX_TABPERSONALITYINFO_H__9A049C9D_E48E_11D1_988C_00805FA67D16__INCLUDED_)
#define AFX_TABPERSONALITYINFO_H__9A049C9D_E48E_11D1_988C_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabPersonalityInfo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabPersonalityInfo dialog

class CTabPersonalityInfo : public CPropertyPage
{

// Construction
public:
	CTabPersonalityInfo(CPersonalityPageManager* pPageManager);
	~CTabPersonalityInfo();
	void SetPersonality( CPersonality* pPersonality );

// Dialog Data
	//{{AFX_DATA(CTabPersonalityInfo)
	enum { IDD = IDD_TAB_PERSONALITY_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editInfo;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabPersonalityInfo)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CPersonality*		m_pPersonality;
	CPersonalityPageManager*	m_pPageManager;
	BOOL		m_fNeedToDetach;


// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	
	// Generated message map functions
	//{{AFX_MSG(CTabPersonalityInfo)
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusInfo();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusAuthor();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABPERSONALITYINFO_H__9A049C9D_E48E_11D1_988C_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefMgr.cpp ===
// PersRefMgr.cpp : implementation file
//

/*--------------
@doc PERS_REFSAMPLE
--------------*/

#include "stdafx.h"
#include "PersRefIO.h"
#include "ChordMapRefStripMgr.h"
#include "PersRefMgr.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <RiffStrm.h>
#include <mmreg.h>
#include <ChordMapDesigner.h>
#include <SegmentDesigner.h>
#include <initguid.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// GetFirstValidPersRef 

POSITION GetFirstValidPersRef( POSITION pos, const CTypedPtrList<CPtrList, CPersRefItem*> &lstPersRefs )
{
	CPersRefItem* pItem;
	POSITION posToReturn;
	while( pos )
	{
		posToReturn = pos;
		pItem = lstPersRefs.GetNext( pos );
		if( pItem->m_pIPersDocRootNode )
		{
			return posToReturn;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr constructor/destructor 

CPersRefMgr::CPersRefMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pPersRefStrip = NULL;
	m_pIDMTrack = NULL;
	m_pISegmentNode = NULL;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1
	m_dwGroupBits = 1;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// Create a strip and add it to the timeline
	m_pPersRefStrip = new CPersRefStrip(this);
	ASSERT( m_pPersRefStrip );
}

CPersRefMgr::~CPersRefMgr()
{
	// Delete all the personality references in m_lstPersRefs
	EmptyPersRefList();

	// Clean up our references
	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}

	if( m_pPersRefStrip )
	{
		m_pPersRefStrip->Release();
		m_pPersRefStrip = NULL;
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr IPersRefMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::IsMeasureBeatOpen

HRESULT STDMETHODCALLTYPE CPersRefMgr::IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat )
{
	HRESULT hr = S_FALSE;
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		if( pPersRefItem->m_dwMeasure > dwMeasure )
		{
			pos = NULL;
		}
		else if( pPersRefItem->m_dwMeasure == dwMeasure )
		{
			hr = S_OK;
			pos = NULL;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetParam

HRESULT STDMETHODCALLTYPE CPersRefMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID(guidType, GUID_PersonalityNode) )
	{
		*(IDMUSProdNode**) pData = NULL;

		// Initialize pmtNext
		if( pmtNext )
		{
			*pmtNext = 0;
		}

		// Search through PersRef list for first valid ChordMap
		POSITION pos = m_lstPersRefs.GetHeadPosition();
		pos = GetFirstValidPersRef( pos, m_lstPersRefs );

		if( !pos )
		{
			// No valid PersRefs in this track.
			return DMUS_E_NOT_FOUND;
		}

		// Initialize Previous PersRef Item
		CPersRefItem* pPrevious = m_lstPersRefs.GetAt( pos );

		// Search through PersRef list for valid PersRefs
		MUSIC_TIME mtSRTime = 0;
		while( pos )
		{
			CPersRefItem* pItem = m_lstPersRefs.GetNext( pos );
			ASSERT( pItem->m_pIPersDocRootNode );

			m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, pItem->m_dwMeasure, 0, &mtSRTime );
			if( mtTime < mtSRTime )
			{
				// Set next	
				if( pmtNext )
				{
					m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, pItem->m_dwMeasure, 0, pmtNext );
					*pmtNext -= mtTime;
				}
				break;
			}

			pPrevious = pItem;

			// Get the next valid PersRef
			pos = GetFirstValidPersRef( pos, m_lstPersRefs );
		}

		// We should have found a valid ChordMap
		ASSERT( pPrevious );
		if( ::IsEqualGUID( guidType, GUID_PersonalityNode) )
		{
			IDMUSProdNode *pIPersNode = pPrevious->m_pIPersDocRootNode;
			pIPersNode->AddRef();

			*(IDMUSProdNode**) pData = pIPersNode;
		}
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pISegmentNode;
		if( m_pISegmentNode )
		{
			m_pISegmentNode->AddRef();
		}
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pPersRefStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

		// Search through PersRef list for first valid time signature
		POSITION pos = m_lstPersRefs.GetHeadPosition();
		pos = GetFirstValidPersRef( pos, m_lstPersRefs );

		if( !pos )
		{
			// No valid PersRefs in this track.
			pDMUSProdReferencedNodes->dwArraySize = 0;
			return S_OK;
		}

		DWORD dwIndex = 0;

		// Search through PersRef list for valid PersRefs
		while( pos )
		{
			CPersRefItem* pItem = m_lstPersRefs.GetNext( pos );
			ASSERT( pItem->m_pIPersDocRootNode );

			if( pDMUSProdReferencedNodes->apIDMUSProdNode
			&&	pDMUSProdReferencedNodes->dwArraySize > dwIndex )
			{
				pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex] = pItem->m_pIPersDocRootNode;
				pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex]->AddRef();
			}

			// Get the next valid PersRef
			pos = GetFirstValidPersRef( pos, m_lstPersRefs );
			dwIndex++;
		}

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SetParam

HRESULT STDMETHODCALLTYPE CPersRefMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pISegmentNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::IsParamSupported

// support GUID_DocRootNode for maintaining pointer to DocRoot node
HRESULT STDMETHODCALLTYPE CPersRefMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) 
	||  ::IsEqualGUID( guidType, GUID_PersonalityNode ) 
	||  ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes )
	||  ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CPersRefMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPersRefStrip != NULL );

	if( (m_pPersRefStrip == NULL) 
	|| !(dwGroupBits & m_dwGroupBits) )
	{
		return E_FAIL;
	}

	HRESULT hr = E_INVALIDARG;

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose ChordMap from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}
		return S_OK;
	}

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which ChordMap changed
				POSITION pos = m_lstPersRefs.GetHeadPosition();
				while( pos )
				{
					CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

					if( pPersRefItem->m_pIPersDocRootNode == pINode )
					{
						// This ChordMap was removed from the Project Tree
						SetPersReference( NULL, pPersRefItem );

						// Set undo text resource id
						if( ::IsEqualGUID(rguidType, FRAMEWORK_FileDeleted) )
						{
							m_pPersRefStrip->m_nLastEdit = IDS_DELETE;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which ChordMap changed
				POSITION pos = m_lstPersRefs.GetHeadPosition();
				while( pos )
				{
					CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

					if( pPersRefItem->m_pIPersDocRootNode == pINode )
					{
						// This ChordMap was replaced in the Project Tree, set to new ChordMap pointer
						SetPersReference( (IDMUSProdNode *)pFrameworkMsg->pData, pPersRefItem );

						m_pPersRefStrip->m_nLastEdit = IDS_REPLACE;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which ChordMap changed
				POSITION pos = m_lstPersRefs.GetHeadPosition();
				while( pos )
				{
					CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

					if( pPersRefItem->m_pIPersDocRootNode == pINode )
					{
						// Set undo text resource id
						m_pPersRefStrip->m_nLastEdit = IDS_CHANGE_LINK;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, PERSONALITY_NameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which ChordMap changed
				POSITION pos = m_lstPersRefs.GetHeadPosition();
				while( pos )
				{
					CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

					if( pPersRefItem->m_pIPersDocRootNode == pINode )
					{
						// This ChordMap was renamed
						DMUSProdListInfo ListInfo;
						ZeroMemory( &ListInfo, sizeof(ListInfo) );
						ListInfo.wSize = sizeof(ListInfo);

						if( SUCCEEDED ( pPersRefItem->m_pIPersDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
						{
							IDMUSProdProject* pIProject;

							if( ListInfo.bstrName )
							{
								pPersRefItem->m_PersListInfo.strName = ListInfo.bstrName;
								::SysFreeString( ListInfo.bstrName );
							}
							if( ListInfo.bstrDescriptor )
							{
								pPersRefItem->m_PersListInfo.strDescriptor = ListInfo.bstrDescriptor;
								::SysFreeString( ListInfo.bstrDescriptor );
							}
							m_pDMProdFramework->GetNodeFileGUID ( pPersRefItem->m_pIPersDocRootNode, &pPersRefItem->m_PersListInfo.guidFile );
							if( SUCCEEDED ( m_pDMProdFramework->FindProject( pPersRefItem->m_pIPersDocRootNode, &pIProject ) ) )
							{
								BSTR bstrProjectName;

								pPersRefItem->m_PersListInfo.pIProject = pIProject;
	//							pPersRefItem->m_PersListInfo.pIProject->AddRef();		intentionally missing

								if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
								{
									pPersRefItem->m_PersListInfo.strProjectName = bstrProjectName;
									::SysFreeString( bstrProjectName );
								}

								pIProject->Release();
							}
						}

						// Set undo text resource id
						m_pPersRefStrip->m_nLastEdit = IDS_CHANGE_NAME;
						hr = S_OK;
					}
				}
			}
		}

		if( pINode )
		{
			pINode->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Let our hosting editor know about the changes
		if( hr == S_OK )
		{
			OnDataChanged();
		}

		if( m_pTimeline )
		{
			m_pTimeline->StripInvalidateRect( m_pPersRefStrip, NULL, TRUE );
		}

		// Update the property page
		if( m_pPropPageMgr != NULL )
		{
			m_pPropPageMgr->RefreshData();
		}

		SyncWithDirectMusic();
		m_fDirty = TRUE;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CPersRefMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicChordMapTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_PERS_TRACK_LIST;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CPersRefMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if ( m_pPersRefStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pPersRefStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pPersRefStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pPersRefStrip, CLSID_DirectMusicChordMapTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits);

				// Fix measure/beat info for all current personalities
				long lMeasure;
				long lBeat;
				POSITION pos = m_lstPersRefs.GetHeadPosition();
				while( pos )
				{
					CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

					m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, pPersRefItem->m_mtTime, &lMeasure, &lBeat );
					pPersRefItem->m_dwMeasure = lMeasure;
					pPersRefItem->m_bBeat = (BYTE) lBeat;
				}
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetClassID

HRESULT CPersRefMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_PersRefMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::IsDirty

HRESULT CPersRefMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::Load

HRESULT CPersRefMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing personality references
	EmptyPersRefList();

	m_strLastPersName.Empty();

	// Load the Track
	MMCKINFO ck;
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_PERS_TRACK_LIST: // PersRef List
						BOOL fChanged;
						LoadPersRefList(pIRiffStream, &ck, false, 0, fChanged);
						pIRiffStream->Ascend( &ck, 0 );
						hr = S_OK;
						break;
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	m_strLastPersName.Empty();

	pIRiffStream->Release();

	SyncWithDirectMusic();
	return hr;
}


HRESULT CPersRefMgr::LoadPersRefList( IDMUSProdRIFFStream* pIRiffStream, 
										MMCKINFO* pckParent,
										bool fPaste,
										MUSIC_TIME mtTime,
										BOOL &fChanged )
{
	MMCKINFO ck;
	HRESULT hr = S_OK;

	if( pIRiffStream == NULL )
	{
		return E_INVALIDARG;
	}

	while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
	{
		if( ck.ckid == FOURCC_LIST
		&&  ck.fccType == DMUS_FOURCC_PERS_REF_LIST )
		{
			if( SUCCEEDED( LoadPersRef(pIRiffStream, &ck, fPaste, mtTime) ) )
			{
				fChanged = TRUE;
			}
			pIRiffStream->Ascend( &ck, 0 );
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	return hr;
}

HRESULT CPersRefMgr::LoadPersRef( IDMUSProdRIFFStream* pIRiffStream, 
									MMCKINFO* pckParent,
									bool fPaste,
									MUSIC_TIME mtTime )
{
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwCurrentFilePos;
	IDMUSProdNode* pIDocRoot = NULL;
	CString strPersName;

	if( pIRiffStream == NULL
	||  pckParent == NULL )
	{
		return E_INVALIDARG;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	CPersRefItem* pItem = new CPersRefItem( this );
	if( pItem == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto ON_END;
	}

	dwCurrentFilePos = StreamTell( pIStream );

	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch (ck.ckid)
		{
		case DMUS_FOURCC_TIME_STAMP_CHUNK:
			{
				DWORD dwTime;
				DWORD cb;
				hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
				if (FAILED(hr) || cb != sizeof( dwTime ) ) 
				{
					if (SUCCEEDED(hr)) hr = E_FAIL;
					goto ON_END;
				}

				// Bypass if the time is not zero
				if( dwTime != 0 )
				{
					hr = E_FAIL;
					goto ON_END;
				}

				pItem->m_mtTime = dwTime;
				pItem->m_dwMeasure = 0;
				pItem->m_bBeat = 0;
//				if (m_pTimeline)
//				{
//					m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, dwTime, (long*)&pItem->m_dwMeasure, (long*)&pItem->m_bBeat );
//					if (fPaste)
//					{
//						long lMeasure;
//						long lBeat;
//						m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, nXPos, &lMeasure, &lBeat );
//						m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &pItem->m_mtTime );
//						pItem->m_dwMeasure = (DWORD) lMeasure;
//						pItem->m_bBeat = (BYTE) lBeat;
//					}
//				}

			}
			break;

		case FOURCC_DMUSPROD_FILEREF:
		{
			IDMUSProdFileRefChunk* pIFileRef;

			hr = m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
			if( FAILED ( hr ) )
			{
				goto ON_END;
			}
			StreamSeek( pIStream, dwCurrentFilePos, 0 );
			pIFileRef->LoadRefChunk( pIStream, &pIDocRoot );
			pIFileRef->Release();
			break;
		}

		case FOURCC_LIST:
			if( ck.fccType == DMUS_FOURCC_REF_LIST )
			{
				MMCKINFO ckName;

				ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
				if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
				{
					// Store Personality name
					ReadMBSfromWCS( pIStream, ckName.cksize, &strPersName );
				}
			}
			break;
		}

		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRoot == NULL )
	{
		// Do we have a Personality name?
		if( !strPersName.IsEmpty() )
		{
			// Framework could not resolve Personality file reference
			// so we will ask user to help
			pIDocRoot = FindPersonality( strPersName, pIStream );
		}
	}

	if( pIDocRoot )
	{
		hr = SetPersReference( pIDocRoot, pItem );
		pIDocRoot->Release();

		if( FAILED ( hr ) )
		{
			goto ON_END;
		}
	}

ON_END:
	if( FAILED (hr) )
	{
		if( pItem )
		{
			delete pItem;
		}
	}
	else
	{
		InsertByAscendingTime( pItem, fPaste );
		if( fPaste )
		{
			pItem->m_fSelected = TRUE;
		}
	}

    pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::FindPersonality

IDMUSProdNode* CPersRefMgr::FindPersonality( CString strPersName, IStream* pIStream )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pDMProdFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = m_pDMProdFramework->FindDocTypeByNodeId( GUID_PersonalityNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// See if there is a FindPersonality named 'strPersName' in this Project
	if( !strPersName.IsEmpty() )
	{
		BSTR bstrPersName = strPersName.AllocSysString();

		if( FAILED ( m_pDMProdFramework->GetBestGuessDocRootNode( pIDocType,
										 						  bstrPersName,
																  pITargetDirectoryNode,
																  &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Cannot find the FindPersonality
		// If user cancelled previous search for this FindPersonality, no need to ask again
		if( strPersName.CompareNoCase( m_strLastPersName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		m_strLastPersName = strPersName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strPersName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_PERS );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_PERS, strPersName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		if( m_pDMProdFramework->OpenFile(pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode) != S_OK )
		{
			// Did not open a file, or opened file other than Personality file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		m_fDirty = TRUE;
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	return pIDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SaveDMRef

HRESULT CPersRefMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
								 IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pDMProdFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectMusicChordMap,
																  NULL,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SaveProducerRef

HRESULT CPersRefMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::Save

HRESULT CPersRefMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;		// Added JHD 4/27/98
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain;

	// If the PersRef list isn't empty, save it
	if ( !m_lstPersRefs.IsEmpty() )
	{
		// Create a LIST chunk to store the PersRef data
		ckMain.fccType = DMUS_FOURCC_PERS_TRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstPersRefs.GetHeadPosition();
		while( pos )
		{
			CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

			// Store each PersRef in its own chunk.
			SavePersReference( pIStream, pIRiffStream, pPersRefItem );
		}
		// Ascend out of the PersRef LIST chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


HRESULT CPersRefMgr::SavePersReference(
			IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream, CPersRefItem* pPersRefItem)
{
	HRESULT hr = E_FAIL;

	ASSERT( pPersRefItem != NULL );

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pIPersistInfo->Release();
	}
	if( !(::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
	&&  !(::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )) )
	{
		// Should not happen!
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Write DMUS_FOURCC_PERS_REF_LIST header
	MMCKINFO ckPersList;
	ckPersList.fccType = DMUS_FOURCC_PERS_REF_LIST;
	if( FAILED( pIRiffStream->CreateChunk( &ckPersList, MMIO_CREATELIST ) ) )
	{
		return E_FAIL;
	}

	// Write 'stmp-ck'
	{
		MMCKINFO ck;
		DWORD dwByteCount;

		ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
		if( FAILED( pIRiffStream->CreateChunk( &ck, 0 ) ) )
		{
			return E_FAIL;
		}

		long lTime = pPersRefItem->m_mtTime;
		DWORD dwTime = lTime;
		hr = pIStream->Write( &dwTime, sizeof(dwTime), &dwByteCount );
		if( FAILED ( hr )
		||  dwByteCount != sizeof(dwTime) )
		{
			return E_FAIL;
		}

		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
			return E_FAIL;
		}
	}

	// Write Reference chunk(s)
	if( pPersRefItem->m_pIPersDocRootNode )
	{
		if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, pPersRefItem->m_pIPersDocRootNode, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, pPersRefItem->m_pIPersDocRootNode, WL_DIRECTMUSIC );
			if( ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, pPersRefItem->m_pIPersDocRootNode );
			}
		}
	}
	
	if( pIRiffStream->Ascend( &ckPersList, 0 ) != 0 )
	{
		return E_FAIL;
	}
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SyncWithDirectMusic

HRESULT CPersRefMgr::SyncWithDirectMusic(  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CPersRefItem* pPersRefItem = NULL;

	// 1. persist the strip to a stream
	IStream* pIMemStream = NULL;
	IPersistStream* pIPersistStream = NULL;
	hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
		hr = Save(pIMemStream, FALSE);
		if (SUCCEEDED(hr))
		{
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if (SUCCEEDED(hr))
			{
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				// 2. Load the stream into the track.
				hr = pIPersistStream->Load(pIMemStream);
				pIPersistStream->Release();
			}
		}
		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetSizeMax

HRESULT CPersRefMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetData

// This method is called by CPersRefPropPageMgr to get data to send to the
// PersRef property page.
// The CPersRefStrip::GetData() method is called by CPersRefStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CPersRefMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected Personality reference.
	BOOL fMultipleSelect = FALSE;
	CPersRefItem* pFirstPersRefItem = NULL;

	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		if( pPersRefItem->m_fSelected )
		{
			pFirstPersRefItem = pPersRefItem;
			while( pos )
			{
				pPersRefItem = m_lstPersRefs.GetNext( pos );
				if( pPersRefItem->m_fSelected )
				{
					fMultipleSelect = TRUE;
					pos = NULL;
					break;
				}
			}
			break;
		}
	}

	if( !fMultipleSelect && pFirstPersRefItem )
	{
		CPropPersRef* pPropPersRef = new CPropPersRef( pFirstPersRefItem );
		if( pPropPersRef )
		{
			*ppData = pPropPersRef;
			return S_OK;
		}
	}

	// Nothing selected or multiple items selected.
	*ppData = NULL;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SetData

// This method is called by CPersRefPropPageMgr in response to user actions
// in the PersRef Property page.  It changes the currenly selected PersRef. 
HRESULT STDMETHODCALLTYPE CPersRefMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected personality reference.
	CPersRefItem* pPersRefItem;
	pPersRefItem = FirstSelectedPersRef();

	if( pPersRefItem )
	{
		CPropPersRef* pPropPersRef = new CPropPersRef( pPersRefItem );
		if ( pPropPersRef )
		{
			// Only update if the data has changed
			if( memcmp( pData, pPropPersRef, sizeof(CPropPersRef) ) )
			{
				CPropPersRef* pPersRef = (CPropPersRef*)pData;
				HRESULT hr;

				// personality has changed, NB, this catches newly created ref node as doc root will be null
				if( pPersRefItem->m_pIPersDocRootNode == NULL
				||  pPersRefItem->m_pIPersDocRootNode != pPersRef->m_pIPersDocRootNode )
				{
					m_pPersRefStrip->m_nLastEdit = IDS_CHANGE;
					hr = SetPersReference( pPersRef->m_pIPersDocRootNode, pPersRefItem );
				}

				// Update the first selected personality reference
				pPersRef->ApplyToPersRefItem( pPersRefItem );

				// Re-insert the pers reference into the list, in case its measure/beat info 
				// changed and it's now out of order w.r.t. the other elements.
				if( RemoveItem( pPersRefItem ) )
				{
					InsertByAscendingTime( pPersRefItem, FALSE );
				}

				// Redraw the personality reference strip
				// BUGBUG: Should be smarter and only redraw the personality reference that changed
				m_pTimeline->StripInvalidateRect( m_pPersRefStrip, NULL, TRUE );

				// Let our hosting editor know about the changes
				m_pTimeline->OnDataChanged( (IPersRefMgr*)this );
			}

			delete pPropPersRef;
			SyncWithDirectMusic();
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		return S_FALSE;
	}
}


HRESULT CPersRefMgr::SetPersReference( IDMUSProdNode* pINewPersDocRootNode, CPersRefItem* pItem )
{
	MUSIC_TIME mtTime = pItem->m_mtTime;
	HRESULT hr;

	// Clean up old DocRoot
	if( pItem->m_pIPersDocRootNode )
	{
		// Turn off notifications for this node
		if( pItem->m_fRemoveNotify )
		{
			if( m_pISegmentNode )
			{
				hr = m_pDMProdFramework->RemoveFromNotifyList( pItem->m_pIPersDocRootNode, m_pISegmentNode );
			}
			pItem->m_fRemoveNotify = FALSE;
		}

		// Initialize DocRoot list info
		pItem->m_PersListInfo.pIProject = NULL;
		pItem->m_PersListInfo.strProjectName = "Empty";
		pItem->m_PersListInfo.strName = "Empty";
		pItem->m_PersListInfo.strDescriptor = "Empty";
		pItem->m_dwBits = 0;
		memset( &pItem->m_guidProject, 0, sizeof( pItem->m_guidProject ) );

		// Release DocRoot
		pItem->m_pIPersDocRootNode->Release();
		pItem->m_pIPersDocRootNode = NULL;
	}

	// Set new DocRoot
	if( pINewPersDocRootNode )
	{
		// Turn on notifications
		ASSERT( pItem->m_fRemoveNotify == FALSE );
		if( m_pISegmentNode )
		{
			hr = m_pDMProdFramework->AddToNotifyList( pINewPersDocRootNode, m_pISegmentNode );
			if( SUCCEEDED ( hr ) )
			{
				pItem->m_fRemoveNotify = TRUE;
			}
		}

		// Update DocRoot member variable
		pItem->m_pIPersDocRootNode = pINewPersDocRootNode;
		pItem->m_pIPersDocRootNode->AddRef();

		// Update DocRoot list info
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		if( SUCCEEDED ( pItem->m_pIPersDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				pItem->m_PersListInfo.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				pItem->m_PersListInfo.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			m_pDMProdFramework->GetNodeFileGUID ( pItem->m_pIPersDocRootNode, &pItem->m_PersListInfo.guidFile );
			if( SUCCEEDED ( m_pDMProdFramework->FindProject( pItem->m_pIPersDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				pItem->m_PersListInfo.pIProject = pIProject;
//				pItem->m_PersListInfo.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					pItem->m_PersListInfo.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CPersRefMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CPersRefPropPageMgr* pPPM = new CPersRefPropPageMgr(m_pDMProdFramework);
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		m_pPropPageMgr->SetObject( this );

		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CPersRefMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CPersRefMgr::OnDataChanged( void)
{
	if ( m_pTimeline == NULL )
	{
		// Will be NULL if editor is closed and Framework 
		// sends notification that a referenced file has changed
		return E_FAIL;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IPersRefMgr*)this );

	return S_OK;
}


HRESULT CPersRefMgr::GetDirectMusicPersonality( IDMUSProdNode* pIPersDocRoot, IDirectMusicChordMap** ppIPers )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( pIPersDocRoot )
	{
		hr = pIPersDocRoot->GetObject(CLSID_DirectMusicChordMap, IID_IDirectMusicChordMap, (void**)ppIPers);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::DeleteSelectedPersRefs

HRESULT CPersRefMgr::DeleteSelectedPersRefs()
{
	POSITION pos2, pos1 = m_lstPersRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos1 );
		if ( pPersRefItem->m_fSelected )
		{
			m_lstPersRefs.RemoveAt( pos2 );
			delete pPersRefItem;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SaveSelectedPersRefs

HRESULT CPersRefMgr::SaveSelectedPersRefs(LPSTREAM pIStream, CPersRefItem* pPersRefAtDragPoint, BOOL fNormalize)
{
	// if fNormalize is TRUE and pPersRefAtDragPoint is valid, set mtOffset and dwMeasureOffset so that the time pPersRefAtDragPoint is 0.
	// if fNormalize is TRUE and pPersRefAtDragPoint is NULL, set mtOffset and dwMeasureOffset so that the time of the first PersRef is 0.
	// if fNormalize is FALSE, don't change the times at all.
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the PersRef list has anything in it, look for selected PersRefs
	if ( !m_lstPersRefs.IsEmpty() )
	{
		long lMeasureOffset = -1;
		
		POSITION pos;
		if ( fNormalize )
		{
			pos = m_lstPersRefs.GetHeadPosition();
			while( pos )
			{
				CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
				if ( pPersRefItem->m_fSelected && lMeasureOffset == -1)
				{
					if ( (pPersRefItem == pPersRefAtDragPoint) || (pPersRefAtDragPoint == NULL) )
					{
						lMeasureOffset = pPersRefItem->m_dwMeasure;
					}
				}
			}
			if ( lMeasureOffset == -1 )
			{
				hr = S_FALSE;
				goto ON_ERROR;
			}
		}
		else
		{
			lMeasureOffset = 0;
		}

		MMCKINFO ckMain;

		pos = m_lstPersRefs.GetHeadPosition();
		while( pos )
		{
			CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

			if ( pPersRefItem->m_fSelected )
			{
				// Store each PersRef in its own chunk.
				SavePersReference(pIStream, pIRiffStream, pPersRefItem);
			}

		}
		pIRiffStream->Ascend( &ckMain, 0 );
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::MarkSelectedPersRefs

// marks m_dwUndermined field CPersRefItems in list
void CPersRefMgr::MarkSelectedPersRefs( DWORD dwFlags )
{
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		if ( pPersRefItem->m_fSelected )
		{
			pPersRefItem->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::DeleteMarked

// deletes personality references marked by given flag
void CPersRefMgr::DeleteMarked( DWORD dwFlags )
{
	POSITION pos2, pos1 = m_lstPersRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos1 );
		if ( pPersRefItem->m_dwBits & dwFlags )
		{
			m_lstPersRefs.RemoveAt( pos2 );
			delete pPersRefItem;
		}
	}

	// Update the property page
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::UnMarkPersRefs

// unmarks flag m_dwUndermined field CPersRefItems in list
void CPersRefMgr::UnMarkPersRefs( DWORD dwFlags )
{
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		pPersRefItem->m_dwBits &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::UnselectAll

bool CPersRefMgr::UnselectAll()
{
	bool fChange = false;

	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		if ( pPersRefItem->m_fSelected )
		{
			pPersRefItem->m_fSelected = FALSE;
			fChange = true;
		}
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SelectAll

void CPersRefMgr::SelectAll()
{
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		m_lstPersRefs.GetNext( pos )->m_fSelected = TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::IsSelected

BOOL CPersRefMgr::IsSelected()
{
	// If anything is selected, return TRUE.
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		if ( m_lstPersRefs.GetNext( pos )->m_fSelected )
		{
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::FirstSelectedPersRef

CPersRefItem* CPersRefMgr::FirstSelectedPersRef()
{
	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
		if ( pPersRefItem->m_fSelected )
		{
			return pPersRefItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::SelectSegment

BOOL CPersRefMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lEndMeas;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, NULL );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, NULL );

	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );

		pPersRefItem->m_fSelected = FALSE;
		if( ((DWORD)lBeginMeas < pPersRefItem->m_dwMeasure) && (pPersRefItem->m_dwMeasure < (DWORD)lEndMeas) )
		{
			pPersRefItem->m_fSelected = TRUE;
			result = TRUE;
		}
		else if( (DWORD)lBeginMeas == pPersRefItem->m_dwMeasure )
		{
			pPersRefItem->m_fSelected = TRUE;
			result = TRUE;
		}
		else if( (DWORD)lEndMeas == pPersRefItem->m_dwMeasure )
		{
			pPersRefItem->m_fSelected = TRUE;
			result = TRUE;
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::FixPersRefListMeasureBeat

void CPersRefMgr::FixPersRefListMeasureBeat()
{
	if (m_pTimeline)
	{
		long lMeasure;
		long lBeat;
		POSITION pos = m_lstPersRefs.GetHeadPosition();
		while( pos )
		{
			CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos );
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, pPersRefItem->m_mtTime, &lMeasure, &lBeat );
			pPersRefItem->m_dwMeasure = (DWORD) lMeasure;
			pPersRefItem->m_bBeat = (BYTE) lBeat;
		}
	}
	IStream* pIMemStream = NULL;
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream );
	if (SUCCEEDED(hr))
	{
		Save(pIMemStream, FALSE);
		StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
		Load(pIMemStream);
		pIMemStream->Release();
	}
}
	
/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::EmptyPersRefList

void CPersRefMgr::EmptyPersRefList(void)
{
	if( !m_lstPersRefs.IsEmpty() )
	{
		CPersRefItem *pPersRefItem;
		while ( !m_lstPersRefs.IsEmpty() )
		{
			pPersRefItem = m_lstPersRefs.RemoveHead();
			delete pPersRefItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::InsertByAscendingTime

void CPersRefMgr::InsertByAscendingTime( CPersRefItem *pPersRef, BOOL fPaste )
{
	ASSERT( pPersRef );
	if ( pPersRef == NULL )
	{
		return;
	}

	;
	POSITION pos2, pos1 = m_lstPersRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CPersRefItem* pPersRefItem = m_lstPersRefs.GetNext( pos1 );

		if( pPersRefItem->m_dwMeasure == pPersRef->m_dwMeasure )
		{
			if( fPaste )
			{
				if( pPersRefItem->m_bBeat == pPersRef->m_bBeat )
				{
					// replace item
					m_lstPersRefs.InsertBefore( pos2, pPersRef );
					m_lstPersRefs.RemoveAt( pos2 );
					delete pPersRefItem;
					return;
				}
			}
			if( pPersRefItem->m_bBeat >= pPersRef->m_bBeat )
			{
				// insert before pos2 (current position of pPersRefItem)
				m_lstPersRefs.InsertBefore( pos2, pPersRef );
				return;
			}
		}
		if( pPersRefItem->m_dwMeasure > pPersRef->m_dwMeasure )
		{
			// insert before pos2 (current position of pPersRefItem)
			m_lstPersRefs.InsertBefore( pos2, pPersRef );
			return;
		}
	}
	// insert at end of list
	m_lstPersRefs.AddTail( pPersRef );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::RemoveItem

BOOL CPersRefMgr::RemoveItem( CPersRefItem* pItem )
{
	POSITION pos2;
	POSITION pos1 = m_lstPersRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstPersRefs.GetNext( pos1 ) == pItem )
		{
			m_lstPersRefs.RemoveAt( pos2 );
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::GetBoundariesOfSelectedPersRefs

void CPersRefMgr::GetBoundariesOfSelectedPersRefs( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	long lEnd = -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pItem = m_lstPersRefs.GetNext( pos );

		if( pItem->m_fSelected )
		{
			if( lEnd < pItem->m_mtTime )
			{
				lEnd = pItem->m_mtTime;
			}
			if( !fSetStart )
			{
				fSetStart = TRUE;
				*plStart = pItem->m_mtTime;
			}
		}
	}

	if( lEnd >= 0 )
	{
		if( lEnd <= *plStart )
		{
			lEnd = *plStart + 1;
		}
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr::DeleteBetweenTimes

BOOL CPersRefMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	BOOL fChanged = FALSE;

	// Iterate through the list
	POSITION pos2, pos = m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		CPersRefItem* pItem = m_lstPersRefs.GetNext( pos );

		// If the tempo occurs between lStart and lEnd, delete it
		if( (pItem->m_mtTime >= lStart) && (pItem->m_mtTime <= lEnd) ) 
		{
			m_lstPersRefs.RemoveAt( pos2 );
			delete pItem;
			fChanged = TRUE;
		}
	}

	return fChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefIO.h ===
#ifndef __PERS_REFIO_H_
#define __PERS_REFIO_H_

#include "PropPersRef.h"
#include <dmusici.h>

class CPersRefMgr;

typedef struct _DMUS_IO_PERS_REF
{
	MUSIC_TIME	mtTime;		// Time of personality reference event
	DWORD		dwMeasure;	// Measure event occurs in
	BYTE		bBeat;		// Beat event occurs in
	BYTE		bPad[3];	// Padding
	DWORD		dwProjLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
	DWORD		dwNameLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
	DWORD		dwDescLength;	// Length of text of WCHARS (in # of bytes) that follows the structure
} DMUS_IO_PERS_REF;

class CPersRefItem : public CPropPersRef
{
public:
	CPersRefItem( CPersRefMgr* pPersRefMgr );
	~CPersRefItem();

	BOOL After(const CPersRefItem& PersRef);
	BOOL Before(const CPersRefItem& PersRef);

	CPersRefMgr* m_pPersRefMgr;

//	Used to track the selection of the personality reference in display.
	BOOL		 m_fSelected;		// This personality reference is currently selected.
	BOOL		 m_fRemoveNotify;
};

#endif // __PERS_REFIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefMgr.h ===
// PersRefMgr.h : Declaration of the CPersRefMgr

#ifndef __PERS_REFMGR_H_
#define __PERS_REFMGR_H_

#include "resource.h"		// main symbols
#include "ChordMapRefStripMgr.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include "proppagemgr.h"
#include <mmsystem.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CPersRefStrip;
class CPersRefItem;
interface IDirectMusicTrack;
interface IDirectMusicChordMap;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CPersRefMgr
class ATL_NO_VTABLE CPersRefMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPersRefMgr, &CLSID_PersRefMgr>,
	public IPersRefMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CPersRefStrip;
friend CPersRefItem;

public:
	CPersRefMgr();
	~CPersRefMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_PERS_REFMGR)

BEGIN_COM_MAP(CPersRefMgr)
	COM_INTERFACE_ENTRY_IID(IID_IPersRefMgr,IPersRefMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersRefMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat);

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

protected:
	HRESULT STDMETHODCALLTYPE OnDataChanged();
	void	FixPersRefListMeasureBeat();	
	void	EmptyPersRefList();
	void	InsertByAscendingTime( CPersRefItem *pPersRef, BOOL fPaste );
	void	GetBoundariesOfSelectedPersRefs( long *plStart, long *plEnd );
	BOOL	DeleteBetweenTimes( long lStart, long lEnd );

	BOOL	SelectSegment(long begintime, long endtime);

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CPersRefItem*> m_lstPersRefs;
	IDMUSProdFramework* 		m_pDMProdFramework;
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	IDMUSProdNode*				m_pISegmentNode; // DocRoot node of Segment
	BOOL						m_fDirty;

	CPersRefStrip*				m_pPersRefStrip;
	CString 					m_strLastPersName;
protected:
	HRESULT SyncWithDirectMusic();
	HRESULT GetDirectMusicPersonality(IDMUSProdNode* pIPersDocRoot, IDirectMusicChordMap** ppIPers);
	HRESULT LoadPersRefList( IDMUSProdRIFFStream* pIRiffStream, 
								MMCKINFO* pckParent,
								bool fPaste,
								MUSIC_TIME mtTime,
								BOOL &fChanged );
	HRESULT LoadPersRef( IDMUSProdRIFFStream* pIRiffStream, 
								MMCKINFO* pckParent,
								bool fPaste,
								MUSIC_TIME mtTime );
	IDMUSProdNode* FindPersonality( CString strStyleName, IStream* pIStream );
	HRESULT SavePersReference(
		IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream, CPersRefItem* pPersRefItem);
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SetPersReference( IDMUSProdNode* pINewPersDocRootNode, CPersRefItem* pItem );
	HRESULT DeleteSelectedPersRefs();
	HRESULT SaveSelectedPersRefs(LPSTREAM, CPersRefItem* pPersRefAtDragPoint, BOOL bNormalize = FALSE);

// general helpers
	void MarkSelectedPersRefs(DWORD flags);
	void UnMarkPersRefs(DWORD flags);
	void DeleteMarked(DWORD flags);
	bool UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CPersRefItem* pItem );

// Misc
	BOOL		IsSelected();	// returns if one or more personality references are selected.
	CPersRefItem* FirstSelectedPersRef();
};


class CPersRefStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CPersRefMgr;

public:
	CPersRefStrip( CPersRefMgr* pPersRefMgr );
	~CPersRefStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT 	CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL bDropNotEditPaste, BOOL &fChanged);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

private:
	HRESULT	ShowPropertySheet( IDMUSProdTimeline* );
	void UnselectGutterRange( void );

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);

	long				m_cRef;
	CPersRefMgr*		m_pPersRefMgr;
	IDMUSProdStripMgr*	m_pStripMgr;

	LONG			m_lGutterBeginSelect;
	LONG			m_lGutterEndSelect;
	BOOL			m_bGutterSelected;	// whether the gutter select is selected, use
									// CPersRefMgr::m_bSelected for whether personality reference is selected
	BOOL			m_bSelecting;
	HCURSOR 		m_hCursor;

private:
	CPersRefItem* GetPersRefFromPoint( long lPos );
	CPersRefItem* GetPersRefFromMeasure( DWORD dwMeasure );
	LONG			m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*	m_pISourceDataObject;	// Object being dragged 
	IDataObject*	m_pITargetDataObject;
	short			m_nStripIsDragDropSource;	
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	UINT			m_cfPersRefList;			// CF_PERSREFLIST Clipboard format
	UINT			m_cfPersonality;			// CF_PERSONALITY Clipboard format
	LONG			m_lStartDragPosition;	// xpos where drag was started
	UINT			m_nLastEdit;			// resource id of last edit
	BOOL			m_fShowPersRefProps;		// if TRUE, show PersRef property page, else show group property page
	BOOL			m_fPropPageActive;		// TRUE if our property page is active
	BOOL			m_fInRightClickMenu;
	IDMUSProdPropPageManager*	m_pPropPageMgr;

};
#endif //__PERS_REFMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefStrip.cpp ===
// PersRefStrip.cpp : Implementation of CPersRefStrip
#include "stdafx.h"
#include "PersRefIO.h"
#include "ChordMapRefStripMgr.h"
#include "PersRefMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "ChordMapDesigner.h"
#include <RiffStrm.h>
#include "MusicTimeConverter.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip constructor/destructor

CPersRefStrip::CPersRefStrip( CPersRefMgr* pPersRefMgr )
{
	ASSERT( pPersRefMgr );
	if ( pPersRefMgr == NULL )
	{
		return;
	}

	m_pPersRefMgr = pPersRefMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pPersRefMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;
	m_bGutterSelected = FALSE;

	m_cfPersRefList = 0;
	m_cfPersonality = 0;

	m_bSelecting = FALSE;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_nStripIsDragDropSource = 0;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowPersRefProps = FALSE;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;
	m_fInRightClickMenu = FALSE;
}

CPersRefStrip::~CPersRefStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pPersRefMgr = NULL;
	}

	RELEASE( m_pISourceDataObject );
	RELEASE( m_pITargetDataObject );
	RELEASE( m_pPropPageMgr );
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::QueryInterface

STDMETHODIMP CPersRefStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::AddRef

STDMETHODIMP_(ULONG) CPersRefStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Release

STDMETHODIMP_(ULONG) CPersRefStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Draw

HRESULT	STDMETHODCALLTYPE CPersRefStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDC	dc;

	BOOL fUseGutterSelectRange = FALSE;
	if( m_bGutterSelected
	&&  m_lGutterBeginSelect != m_lGutterEndSelect )
	{
		fUseGutterSelectRange = TRUE;
	}

	// Get a pointer to the Timeline
	if( m_pPersRefMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pPersRefMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pPersRefMgr->m_dwGroupBits, 0, lXOffset );
		// Attach to our device context
		if( dc.Attach(hDC) )
		{
			CRect	rectClip, rectHighlight;
			long	lStartTime, lPosition = 0;
			CSize	csize;

			// locals for ghosting
			long lFirstVisibleMeasure, lPartialVisibleMeasure;
			long lClocks;
			RECT rectGhost;
			CPersRefItem* pGhostPerson = 0;

			dc.GetClipBox( &rectClip );
			//rectHighlight = rectClip;
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;
			rectGhost.top = rectGhost.left = rectGhost.right = 0;
			rectGhost.bottom = STRIP_HEIGHT;
			bool bGhostPersonCovered = false;

			// find first visible measure for ghosting personalities
			m_pPersRefMgr->m_pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasure(lPartialVisibleMeasure, m_pPersRefMgr->m_pTimeline, m_pPersRefMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasure(lPartialVisibleMeasure, 0, m_pPersRefMgr->m_pTimeline, m_pPersRefMgr->m_dwGroupBits);
			if(cmtNearestMeasure.Time() < cmtFirstVisible.Time())
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure + 1;
			}
			else
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure;
			}

			// find latest personality before first visible measure
			POSITION pos = m_pPersRefMgr->m_lstPersRefs.GetHeadPosition();
			while(pos)
			{
				CPersRefItem* pPersRefItem = m_pPersRefMgr->m_lstPersRefs.GetNext( pos );
				if(pPersRefItem->m_dwMeasure < (unsigned)lFirstVisibleMeasure
					&& !pPersRefItem->m_PersListInfo.strName.IsEmpty())
				{
					pGhostPerson = pPersRefItem;
				}
				else
				{
					break;
				}
			}
			if(pGhostPerson)
			{
				// get rect of pers ref, will have to truncate if it covers part of real pers ref
				m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition(m_pPersRefMgr->m_dwGroupBits, 0, lFirstVisibleMeasure,
													0, &lPosition);
				lPosition++;
				CSize csize;
				csize = dc.GetTextExtent(pGhostPerson->m_PersListInfo.strName);
				rectGhost.left = lPosition - lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
			}

			// we'll draw ghost pers ref after checking whether real pers ref covers it


			m_pPersRefMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

			pos = m_pPersRefMgr->m_lstPersRefs.GetHeadPosition();
			while( pos )
			{
				CPersRefItem* pPersRefItem = m_pPersRefMgr->m_lstPersRefs.GetNext( pos );

				if(pPersRefItem->m_dwMeasure == (unsigned)lFirstVisibleMeasure)
				{
					// real pers ref covers ghost
					bGhostPersonCovered = true;
				}

				m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0, pPersRefItem->m_dwMeasure, pPersRefItem->m_bBeat, &lPosition );
				csize = dc.GetTextExtent( pPersRefItem->m_PersListInfo.strName );

				rectHighlight.left = lPosition - lXOffset;

				if(pGhostPerson)
				{
					// truncate ghost person's text so it doesn't cover up real style's text
					long lTruePos = lPosition - lXOffset;
					if(lTruePos > rectGhost.left && lTruePos < rectGhost.right)
					{
						rectGhost.right = lTruePos;
					}
				}

				if (pos) 
				{
					CPersRefItem* pTempPersRef = m_pPersRefMgr->m_lstPersRefs.GetAt( pos );
					m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0, pTempPersRef->m_dwMeasure, pTempPersRef->m_bBeat, &(rectHighlight.right) );
					CSize csize;
					csize = dc.GetTextExtent(pPersRefItem->m_PersListInfo.strName);
					if( (rectHighlight.left + csize.cx) > rectHighlight.right)
					{
						dc.DrawText(pPersRefItem->m_PersListInfo.strName, rectHighlight, (DT_LEFT | DT_NOPREFIX));
					}
					else
					{
						dc.TextOut( lPosition - lXOffset + 1, 0, pPersRefItem->m_PersListInfo.strName, strlen(pPersRefItem->m_PersListInfo.strName) );
					}
				}
				else
				{
					dc.TextOut( lPosition - lXOffset + 1, 0, pPersRefItem->m_PersListInfo.strName, strlen(pPersRefItem->m_PersListInfo.strName) );
				}

				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}
			}

			// make sure the first selected PersRef is shown in its entirety
			CPersRefItem* pPersRefItem = m_pPersRefMgr->FirstSelectedPersRef();
			if( pPersRefItem )
			{
				pos = m_pPersRefMgr->m_lstPersRefs.Find( pPersRefItem, NULL );
				// Leave rectHighlight alone
				//rectHighlight = rectClip;
				while( pos )
				{
					if (pPersRefItem->m_fSelected)
					{
						long lMeasureBeginPosition = 0;
						long lMeasureEndPosition = 0;
						m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0,
														  pPersRefItem->m_dwMeasure, 0, &lMeasureBeginPosition );
						m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0,
														 (pPersRefItem->m_dwMeasure + 1), 0, &lMeasureEndPosition );
						long lMeasureLength = lMeasureEndPosition - lMeasureBeginPosition;
						lPosition = lMeasureBeginPosition;

						// find extent of text
						csize = dc.GetTextExtent( pPersRefItem->m_PersListInfo.strName );
						if( csize.cx < lMeasureLength )
						{
							csize.cx = lMeasureLength;
						}
						long lExtent = lPosition + csize.cx;

						// truncate if a selected PersRef covers part of text
						POSITION pos2 = pos;
						CPersRefItem* pTempPersRef;
						bool fDone = false;
						while( pos2 && !fDone)
						{
							m_pPersRefMgr->m_lstPersRefs.GetNext( pos2 );
							if (!pos2) break;
							pTempPersRef = m_pPersRefMgr->m_lstPersRefs.GetAt( pos2 );
							if( pTempPersRef->m_fSelected )
							{	
								long lRPos;
								m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0, pTempPersRef->m_dwMeasure, pTempPersRef->m_bBeat, &lRPos );
								if( lRPos <= lExtent )
								{
									lExtent = lRPos;
								}
								fDone = true;
							}
						}

						if( fUseGutterSelectRange == FALSE )
						{
							rectHighlight.left = lPosition - lXOffset;
							rectHighlight.right = lExtent - lXOffset;
							dc.DrawText( pPersRefItem->m_PersListInfo.strName, rectHighlight, (DT_LEFT | DT_NOPREFIX) );
							GrayOutRect( dc.m_hDC, rectHighlight );
						}
					}
					m_pPersRefMgr->m_lstPersRefs.GetNext( pos );
					if (pos) pPersRefItem = m_pPersRefMgr->m_lstPersRefs.GetAt( pos );
				}
			}

			// DRAW HATCH MARKS OVER MEASURES 2 THRU END
			{
				CBrush brushHatch;
				RECT rectHatch;
				long lStartClock;

				// Determine rectangle
				rectHatch.top = rectClip.top;
				rectHatch.bottom = rectClip.bottom;
				rectHatch.right = rectClip.right;
				m_pPersRefMgr->m_pTimeline->MeasureBeatToClocks( m_pPersRefMgr->m_dwGroupBits, 0, 1, 0, &lStartClock );
				m_pPersRefMgr->m_pTimeline->ClocksToPosition( lStartClock, &rectHatch.left );
				rectHatch.left = max( rectHatch.left - lXOffset, rectClip.left );
/*
				// truncate hatch rect so that it doesn't cover ghosted pers ref
				if(!bGhostPersonCovered && pGhostPerson)
				{
					// get rect of pers ref, will have to truncate if it covers part of real pers ref
					m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition(m_pPersRefMgr->m_dwGroupBits, 0, lFirstVisibleMeasure,
														0, &lPosition);
					lPosition++;
					CSize csize;
					csize = dc.GetTextExtent(pGhostPerson->m_PersListInfo.strName);
					rectGhost.left = lPosition - lXOffset;
					rectGhost.right = rectGhost.left + csize.cx;

					if(rectHatch.left < rectGhost.right)
					{
						rectHatch.left = rectGhost.right;
					}
				}
*/				
				// Draw it
				if( brushHatch.CreateHatchBrush( HS_DIAGCROSS, dc.GetNearestColor(RGB(50,50,50)) ) )
				{
					int nOldBackgroundMode = dc.SetBkMode( TRANSPARENT );
					CBrush* pOldBrush = dc.SelectObject( &brushHatch );
					COLORREF cr = dc.SetBkColor( 0 );
					dc.PatBlt( rectHatch.left, rectHatch.top, rectHatch.right - rectHatch.left, rectHatch.bottom - rectHatch.top, PATINVERT );
					dc.SetBkMode( nOldBackgroundMode );
					dc.SelectObject( pOldBrush );
					brushHatch.DeleteObject();
					dc.SetBkColor(cr);
				}
			}

			// now draw ghost pers ref
			if(!bGhostPersonCovered && pGhostPerson)
			{
				// further truncate ghost rect by its real rect if close enough
				m_pPersRefMgr->m_pTimeline->MeasureBeatToPosition( m_pPersRefMgr->m_dwGroupBits, 0,
												  pGhostPerson->m_dwMeasure, 0, &lPosition );

				rectHighlight.left = lPosition-lXOffset;
				CSize csize = dc.GetTextExtent(pGhostPerson->m_PersListInfo.strName);
				rectHighlight.right = rectHighlight.left + csize.cx;
				m_pPersRefMgr->m_pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
				m_pPersRefMgr->m_pTimeline->ClocksToPosition(lClocks, &lPosition);
				if(!(rectHighlight.right > (lPosition-lXOffset)))
				{
					int nOldBackgroundMode = dc.SetBkMode(OPAQUE);	
					COLORREF cr = dc.SetTextColor(RGB(168,168,168));
					dc.DrawText(pGhostPerson->m_PersListInfo.strName, &rectGhost, (DT_LEFT | DT_NOPREFIX));
					dc.SetTextColor(cr);
					dc.SetBkMode( nOldBackgroundMode );
				}
			}

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				long lBeginSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect;
				long lEndSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect;

				long lMeasure;
				long lBeat;
				long lClocks;

				m_pPersRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pPersRefMgr->m_dwGroupBits, 0, lBeginSelect, &lMeasure, &lBeat );
				m_pPersRefMgr->m_pTimeline->MeasureBeatToClocks( m_pPersRefMgr->m_dwGroupBits, 0, lMeasure, 0, &lClocks );
				m_pPersRefMgr->m_pTimeline->ClocksToPosition( lClocks, &(rectHighlight.left));

				m_pPersRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pPersRefMgr->m_dwGroupBits, 0, lEndSelect, &lMeasure, &lBeat );
				m_pPersRefMgr->m_pTimeline->MeasureBeatToClocks( m_pPersRefMgr->m_dwGroupBits, 0, (lMeasure + 1), 0, &lClocks );
				m_pPersRefMgr->m_pTimeline->ClocksToPosition( (lClocks - 1), &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it.
				GrayOutRect( dc.m_hDC, rectHighlight );
			}

			dc.Detach();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CPersRefStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_CURSOR_HANDLE:
		pvar->vt = VT_I4;
		V_I4(pvar) = (int)m_hCursor;
		break;

	case SP_NAME:
		{
			BSTR bstr;

			CString strName;
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( _Module.GetModuleInstance() );
			strName.LoadString( IDS_STRIP_FBAR_NAME );
			AfxSetResourceHandle( hInstance );

			CString str = GetName(m_pPersRefMgr->m_dwGroupBits, strName);

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pPersRefMgr )
		{
			m_pPersRefMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CPersRefStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			if( m_pPersRefMgr->UnselectAll() )
			{
				m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}
		if( m_bGutterSelected )
		{
			m_pPersRefMgr->UnselectAll();
			m_pPersRefMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}
		else
		{
			if( m_pPersRefMgr->UnselectAll() )
			{
				m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
		}

		// Update the property page
		if( m_pPersRefMgr->m_pPropPageMgr != NULL )
		{
			m_pPersRefMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pPersRefMgr->UnselectAll();
			m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pPersRefMgr->UnselectAll();
			m_pPersRefMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pPersRefMgr->UnselectAll();
		}
		m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pPersRefMgr->m_pPropPageMgr != NULL )
		{
			m_pPersRefMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GetPersRefFromMeasure

CPersRefItem *CPersRefStrip::GetPersRefFromMeasure( DWORD dwMeasure )
{
	POSITION pos = m_pPersRefMgr->m_lstPersRefs.GetHeadPosition();
	while( pos )
	{
		CPersRefItem* pPersRefItem = m_pPersRefMgr->m_lstPersRefs.GetNext( pos );
		if ( pPersRefItem->m_dwMeasure == dwMeasure )
		{
			return pPersRefItem;
		}
		else if ( pPersRefItem->m_dwMeasure > dwMeasure )
		{
			break;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GetPersRefFromPoint

CPersRefItem *CPersRefStrip::GetPersRefFromPoint( long lPos )
{
	CPersRefItem*		pPersRefReturn = NULL;

	if( m_pPersRefMgr->m_pTimeline )
	{
		CPersRefItem* pPersRefItem = NULL;
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->PositionToMeasureBeat( m_pPersRefMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pPersRefReturn = GetPersRefFromMeasure( lMeasure );
		}
	}
	return pPersRefReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CPersRefStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CPersRefItem* pPersRef = NULL;

	// Process the window message
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	// Compute max position (end of measure 1)
	long lMaxClock;
	long lMaxPos;
	m_pPersRefMgr->m_pTimeline->MeasureBeatToClocks( m_pPersRefMgr->m_dwGroupBits, 0, 1, 0, &lMaxClock );
	m_pPersRefMgr->m_pTimeline->ClocksToPosition( lMaxClock, &lMaxPos );

	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		if( lXPos < lMaxPos )
		{
			m_fShowPersRefProps = TRUE;
			hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		}
		break;

	case WM_RBUTTONDOWN:
		if( lXPos < lMaxPos )
		{
			m_fShowPersRefProps = TRUE;
			hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		}
		break;

	case WM_RBUTTONUP:
		if( lXPos < lMaxPos )
		{
			// Display a right-click context menu.
			POINT pt;
			BOOL	bResult;
			// Get the cursor position (To put the menu there)
			bResult = GetCursorPos( &pt );
			ASSERT( bResult );
			if( !bResult )
			{
				hr = E_UNEXPECTED;
				break;
			}

			// Save the position of the click so we know where to insert a PersRef. if Insert is selected.
			m_lXPos = lXPos;
			m_fInRightClickMenu = TRUE;
			m_pPersRefMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
			m_fInRightClickMenu = FALSE;
		}
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet(m_pPersRefMgr->m_pTimeline);
			if (m_fShowPersRefProps)
			{
				// Change to the personality reference property page
				m_pPersRefMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			hr = Paste();
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		if( lXPos < lMaxPos )
		{
			m_lXPos = lXPos;
			UnselectGutterRange();
		}
		break;

	case WM_SETCURSOR:
		if( lXPos < lMaxPos )
		{
			m_hCursor = ::LoadCursor( NULL, IDC_ARROW );
		}
		else
		{
			m_hCursor = ::LoadCursor( NULL, IDC_NO );
		}
		break;

	case WM_CREATE:
		m_cfPersRefList = RegisterClipboardFormat( CF_PERSREFLIST );
		m_cfPersonality = RegisterClipboardFormat( CF_PERSONALITY );

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

		// Fix measure/beat info for any personalities already in the strip
		m_pPersRefMgr->FixPersRefListMeasureBeat();
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::FBDraw

HRESULT CPersRefStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::FBOnWMMessage

HRESULT CPersRefStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fShowPersRefProps = FALSE;
		OnShowProperties();
		break;
	case WM_RBUTTONUP:
		m_fShowPersRefProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pPersRefMgr->m_pTimeline )
		{
			m_fInRightClickMenu = TRUE;
			m_pPersRefMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
			m_fInRightClickMenu = FALSE;
		}
		break;
	case WM_SETCURSOR:
		m_hCursor = ::LoadCursor( NULL, IDC_ARROW );
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Cut

HRESULT CPersRefStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Copy

HRESULT CPersRefStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfPersRefList == 0 )
	{
		m_cfPersRefList = RegisterClipboardFormat( CF_PERSREFLIST );
		if( m_cfPersRefList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the commands into the stream.
	m_pPersRefMgr->MarkSelectedPersRefs(UD_DRAGSELECT);
	CPersRefItem* pPersRefAtDragPoint = m_pPersRefMgr->FirstSelectedPersRef();
	hr = m_pPersRefMgr->SaveSelectedPersRefs( pStreamCopy, pPersRefAtDragPoint, TRUE );
	if( FAILED( hr ))
	{
		RELEASE( pStreamCopy );
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfPersRefList, pStreamCopy );
		RELEASE( pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pPersRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pPersRefMgr->GetBoundariesOfSelectedPersRefs( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfPersRefList, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the ITimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pPersRefMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pPersRefMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		//m_pPersRefMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::PasteAt

HRESULT CPersRefStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL fDropNotEditPaste, BOOL &fChanged)
{
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure everything in other strip is deselected first.
	UnselectGutterRange();

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfPersRefList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfPersRefList, &pIStream)))
		{
			// Check for RIFF format
			if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				goto Leave;
			}

			hr = m_pPersRefMgr->LoadPersRefList( pIRiffStream, NULL, true, mtTime, fChanged );
		}
	}
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfPersonality ) == S_OK )
	{
		IDMUSProdNode* pIDocRootNode;
		IDataObject* pIDataObject;

		hr = pITimelineDataObject->Export( &pIDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = m_pPersRefMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				CPersRefItem* pItem = new CPersRefItem( m_pPersRefMgr );
				if( pItem )
				{
					hr = m_pPersRefMgr->SetPersReference( pIDocRootNode, pItem );
					if( SUCCEEDED ( hr ) )
					{
						m_pPersRefMgr->InsertByAscendingTime( pItem, TRUE );
						pItem->m_fSelected = TRUE;
						fChanged = TRUE;
					}
					else
					{
						delete pItem;
					}
				}

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}

Leave:
	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Paste

HRESULT CPersRefStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste(pITimelineDataObject);
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfPersRefList == 0 )
	{
		m_cfPersRefList = RegisterClipboardFormat( CF_PERSREFLIST );
		if( m_cfPersRefList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfPersonality == 0 )
	{
		m_cfPersonality = RegisterClipboardFormat( CF_PERSONALITY );
		if( m_cfPersonality == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pPersRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pPersRefMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		RELEASE( pITimelineDataObject );
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			fChanged = m_pPersRefMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}

	// Get the time to paste at
	MUSIC_TIME mtTime;
	if( FAILED( m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
	{
		RELEASE( pITimelineDataObject );
		return E_FAIL;
	}

	// Now, do the paste operation
	hr = PasteAt(pITimelineDataObject, mtTime, FALSE, fChanged);
	RELEASE( pITimelineDataObject );

	// If successful and something changed, redraw our strip
	if( SUCCEEDED(hr) && fChanged )
	{
		// Set the last edit type
		m_nLastEdit = IDS_PASTE;

		// Update our hosting editor.
		m_pPersRefMgr->OnDataChanged();

		// Redraw our strip
		m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pPersRefMgr->SyncWithDirectMusic();

		m_pPersRefMgr->OnShowProperties();
		if( m_pPersRefMgr->m_pPropPageMgr )
		{
			m_pPersRefMgr->m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Insert

HRESULT CPersRefStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Unselect all items in this strip 
	m_pPersRefMgr->UnselectAll();
	
	// Unselect items in other strips
	UnselectGutterRange();

	// BUGBUG: Need to fix this.  Should use m_lXPos if it's valid, otherwise use the time cursor.
	HRESULT hr = S_OK;
	long	lMeasure, lBeat;
	CPersRefItem* pPersRef = NULL;
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	hr = m_pPersRefMgr->m_pTimeline->PositionToMeasureBeat( m_pPersRefMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED( hr ) );

	// Align on measure boundary
	lBeat = 0;

	pPersRef = new CPersRefItem( m_pPersRefMgr );
	if(pPersRef == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pPersRef->m_PersListInfo.strProjectName = "Empty";
		pPersRef->m_PersListInfo.strName = "Empty";
		pPersRef->m_PersListInfo.strDescriptor = "Empty";
		pPersRef->m_dwMeasure = lMeasure;
		pPersRef->m_bBeat = (BYTE)lBeat;
		m_pPersRefMgr->m_pTimeline->MeasureBeatToClocks( m_pPersRefMgr->m_dwGroupBits, 0, lMeasure, lBeat, &pPersRef->m_mtTime );
		pPersRef->m_fSelected = TRUE;
		m_pPersRefMgr->InsertByAscendingTime(pPersRef, FALSE);
		m_pPersRefMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
		ShowPropertySheet(m_pPersRefMgr->m_pTimeline);
		m_pPersRefMgr->OnShowProperties();
			
		if( m_pPersRefMgr->m_pPropPageMgr )
		{
			m_pPersRefMgr->m_pPropPageMgr->RefreshData();
		}
		m_nLastEdit = IDS_INSERT;
		m_pPersRefMgr->OnDataChanged();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Delete

HRESULT CPersRefStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* This may be part of a cut operation.  You can cut empty space, but you can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pPersRefMgr->DeleteSelectedPersRefs();

	m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pPersRefMgr->m_pPropPageMgr )
	{
		m_pPersRefMgr->m_pPropPageMgr->RefreshData();
	}
	m_pPersRefMgr->SyncWithDirectMusic();

	m_nLastEdit = IDS_DELETE;
	m_pPersRefMgr->OnDataChanged();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::SelectAll

HRESULT CPersRefStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pPersRefMgr->SelectAll();

	m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanCut

HRESULT CPersRefStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanCopy

HRESULT CPersRefStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pPersRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pPersRefMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanPaste

HRESULT CPersRefStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPersRefMgr != NULL );
	if( m_pPersRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfPersRefList == 0 )
	{
		m_cfPersRefList = RegisterClipboardFormat( CF_PERSREFLIST );
		if( m_cfPersRefList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfPersonality == 0 )
	{
		m_cfPersonality = RegisterClipboardFormat( CF_PERSONALITY );
		if( m_cfPersonality == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	HRESULT	hr = E_FAIL;
	if( pITimelineDataObject != NULL )
	{
		if( (pITimelineDataObject->IsClipFormatAvailable( m_cfPersRefList ) == S_OK)
		||  (pITimelineDataObject->IsClipFormatAvailable( m_cfPersonality ) == S_OK) )
		{
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					if( (pITimelineDataObject->IsClipFormatAvailable( m_cfPersRefList ) == S_OK)
					||  (pITimelineDataObject->IsClipFormatAvailable( m_cfPersonality ) == S_OK) )
					{
						hr = S_OK;
					}
					else
					{
						hr = S_FALSE;
					}
				}
				RELEASE( pITimelineDataObject );
			}
			RELEASE( pIDataObject );
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanInsert

HRESULT CPersRefStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPersRefMgr != NULL );
	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pPersRefMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Get clock at XPos
	long lClock;
	m_pPersRefMgr->m_pTimeline->PositionToClocks( m_lXPos, &lClock );


	// Make sure XPos is within strip
	if( lClock > 0 
	&&  lClock < lTimelineLength )
	{
		// User clicked within boundaries of strip
		long lMeasure;
		long lBeat;

		if( SUCCEEDED ( m_pPersRefMgr->m_pTimeline->PositionToMeasureBeat( m_pPersRefMgr->m_dwGroupBits,
																		   0,
																		   m_lXPos,
																		   &lMeasure,
																		   &lBeat ) ) )
		{
			CPropPersRef* pPersRef = GetPersRefFromPoint( m_lXPos );
			if( pPersRef == NULL )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanDelete

HRESULT CPersRefStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pPersRefMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanSelectAll

HRESULT CPersRefStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	if( m_pPersRefMgr->m_lstPersRefs.IsEmpty() == FALSE )
	{
		return S_OK;
	}

	return S_FALSE;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::QueryContinueDrag

HRESULT CPersRefStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GiveFeedback

HRESULT CPersRefStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CreateDragImage

CImageList* CPersRefStrip::CreateDragImage()
{
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CreateDataObject

HRESULT	CPersRefStrip::CreateDataObject(IDataObject** ppIDataObject, long position)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected PersRefs into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pPersRefMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		CPersRefItem* pPersRefAtDragPoint = GetPersRefFromPoint( position );

		// mark the personality references as being dragged: this used later for deleting personality references in drag move
		m_pPersRefMgr->MarkSelectedPersRefs(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pPersRefMgr->SaveSelectedPersRefs( pIStream, pPersRefAtDragPoint, TRUE ) ) )
		{
			// Place CF_PERS_REFLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfPersRefList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::DragEnter

HRESULT CPersRefStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Show the feedback image
			m_pDragImage->DragEnter( pWnd->GetDesktopWindow(), point );
		}
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::DragOver

HRESULT CPersRefStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		BOOL fCF_PERSONALITY = FALSE;

		// Does m_pITargetDataObject contain format CF_BAND?
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject )
		{
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfPersonality ) ) )
			{
				fCF_PERSONALITY = TRUE;
			}
			pDataObject->Release();
		}

		// Can only copy CF_PERSONALITY data!
		if( fCF_PERSONALITY )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else
		{
			if( grfKeyState & MK_RBUTTON )
			{
				dwEffect = *pdwEffect;
			}
			else
			{
				if( grfKeyState & MK_CONTROL )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					if( *pdwEffect & DROPEFFECT_COPY
					&&  *pdwEffect & DROPEFFECT_MOVE )
					{
						dwEffect = DROPEFFECT_MOVE;
					}
					else
					{
						dwEffect = *pdwEffect;
					}
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::DragLeave

HRESULT CPersRefStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	RELEASE( m_pITargetDataObject );

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::Drop

HRESULT CPersRefStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// BUGBUG: Error messages?
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED( m_pPersRefMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
				{
					BOOL fChanged = FALSE;
					hr = PasteAt( pITimelineDataObject, mtTime, true, fChanged );
					if( SUCCEEDED ( hr ) )
					{
						*pdwEffect = m_dwOverDragEffect;

						// If we pasted anything
						if( fChanged )
						{
							if( m_nStripIsDragDropSource )
							{
								// Drag/drop Target and Source are the same PersRef strip
								m_nStripIsDragDropSource = 2;
							}
							else
							{
								// Set the last edit type
								m_nLastEdit = IDS_PASTE;

								// Update our hosting editor.
								m_pPersRefMgr->OnDataChanged();

								// Redraw our strip
								m_pPersRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

								// Update the property page
								if( m_pPersRefMgr->m_pPropPageMgr != NULL )
								{
									m_pPersRefMgr->m_pPropPageMgr->RefreshData();
								}

								m_pPersRefMgr->SyncWithDirectMusic();
							}
						}
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GetTimelineCWnd

CWnd* CPersRefStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pPersRefMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pPersRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::CanPasteFromData

HRESULT CPersRefStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfPersRefList ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfPersonality ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::GetData

HRESULT CPersRefStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pPersRefMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pPersRefMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pPersRefMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::SetData

HRESULT CPersRefStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pPersRefMgr->m_dwGroupBits )
		{
			m_pPersRefMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_TRACK_GROUP;
			m_pPersRefMgr->m_pTimeline->OnDataChanged( (IPersRefMgr*)m_pPersRefMgr );
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pPersRefMgr->m_dwTrackExtrasFlags )
		{
			m_pPersRefMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pPersRefMgr->m_pTimeline->OnDataChanged( (IPersRefMgr*)m_pPersRefMgr );
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pPersRefMgr->m_dwProducerOnlyFlags )
		{
			m_pPersRefMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pPersRefMgr->m_pTimeline->OnDataChanged( (IPersRefMgr*)m_pPersRefMgr );
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::OnShowProperties

HRESULT CPersRefStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pPersRefMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE( pIFramework );
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Group bits property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pPersRefMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::OnRemoveFromPageManager

HRESULT CPersRefStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::ShowPropertySheet

HRESULT CPersRefStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				RELEASE( pIPropSheet );
			}
			RELEASE( punk );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::OnLButtonDown

HRESULT CPersRefStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	// If we're already dragging, just return
	if( m_pDragImage )
	{
		return S_OK;
	}

	// Get a reference to the timeline
	if( m_pPersRefMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pPersRefMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// See if there is a personality reference under the cursor.
	CPersRefItem* pPersRef = GetPersRefFromPoint( lXPos );
	if( pPersRef )
	{
		BOOL fDrop = FALSE; // TRUE if we're doing a drop

		// If it's already selected, start a Drag/Drop operation
		if(pPersRef->m_fSelected)
		{
			// Start drag/drop
			m_nStripIsDragDropSource = 1;
			fDrop = TRUE;

			// drag drop will capture mouse, so release it from timeline
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pPersRefMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

			IDropSource*	pIDropSource;
			DWORD			dwEffect = DROPEFFECT_NONE;
			// Query ourself for our IDropSource interface
			if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
			{
				// Create a data object from the selected personality references
				hr = CreateDataObject( &m_pISourceDataObject, lXPos );
				if(SUCCEEDED(hr))
				{
					// Create an image to use when dragging personality references
					m_pDragImage = CreateDragImage();
					if(m_pDragImage)
					{
						m_pDragImage->BeginDrag(0, CPoint(8,12));
					}

					// We can always copy personality references.
					DWORD dwOKDragEffects = DROPEFFECT_COPY;
					if(CanCut() == S_OK)
					{
						// If we can Cut(), allow the user to move the personality references as well.
						dwOKDragEffects |= DROPEFFECT_MOVE;
					}

					// Do the Drag/Drop.
					m_dwStartDragButton = (unsigned long)wParam;
					m_lStartDragPosition = lXPos;
					hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

					// Drag/Drop completed, clean up
					m_dwStartDragButton = 0;

					if(m_pDragImage)
					{
						m_pDragImage->EndDrag();
						delete m_pDragImage;
						m_pDragImage = NULL;
					}

					switch(hr)
					{
					case DRAGDROP_S_DROP:
						if(dwEffect & DROPEFFECT_MOVE)
						{
							m_pPersRefMgr->DeleteMarked(UD_DRAGSELECT);
							m_nLastEdit = IDS_DELETE;
						}
						if(dwEffect == DROPEFFECT_NONE)
						{
							fDrop = FALSE;
						}
						break;
					default:
						fDrop = FALSE;
						break;
					}
					hr = S_OK;
					RELEASE( m_pISourceDataObject );
				}
				RELEASE( pIDropSource );
				m_pPersRefMgr->UnMarkPersRefs(UD_DRAGSELECT);
				m_pPersRefMgr->SyncWithDirectMusic();
			}
			else
			{
				hr = E_FAIL;
				goto ON_ERR;
			}

			if(!fDrop)
			{
//				m_pPersRefMgr->m_lstPersRefs.UnselectAll();
				if(wParam & MK_CONTROL)
				{
					// unselect the personality reference
					if(pPersRef->m_fSelected)
						pPersRef->m_fSelected = FALSE;
				}

			}
			if( dwEffect != DROPEFFECT_NONE )
			{
				if( m_nStripIsDragDropSource == 2 )
				{
					// Drag/drop target and source are the same PersRef strip
					if( dwEffect == DROPEFFECT_MOVE )
					{
						m_nLastEdit = IDS_UNDO_MOVE;
						m_pPersRefMgr->OnDataChanged();
					}
					else
					{
						m_nLastEdit = IDS_PASTE;
						m_pPersRefMgr->OnDataChanged();
					}
				}
				else
				{
					if( dwEffect == DROPEFFECT_MOVE )
					{
						m_nLastEdit = IDS_DELETE;
						m_pPersRefMgr->OnDataChanged();
					}
					else
					{
						m_pPersRefMgr->UnselectAll();
					}
				}
			}

			// Done with drag/drop
			m_nStripIsDragDropSource = 0;
		}
		else						// other ops
		{
			// Since there's only one item and it's unselected, select it no matter what
			// combination of SHIFT and CTRL the user has pressed
			pPersRef->m_fSelected = TRUE;

		}

	}
	else if(wParam & MK_CONTROL)
	{
		// user wants to insert a personality reference
	}
	else
	{
		// click on empty space deselects all
		// first clear selections
		m_pPersRefMgr->UnselectAll();
	}

	// TODO: replace NULL by actual area invalidated (in strip coordinates)
	m_pPersRefMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
	m_pPersRefMgr->OnShowProperties();
	if( m_pPersRefMgr->m_pPropPageMgr )
	{
		m_pPersRefMgr->m_pPropPageMgr->RefreshData();
	}

ON_ERR:
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::OnRButtonDown

HRESULT CPersRefStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );

	UnselectGutterRange();

	// Get the item at the mouse click.
	CPersRefItem* pPersRef = GetPersRefFromPoint( lXPos );

	if( !(wParam & MK_CONTROL)
	&&  !(wParam & MK_SHIFT) )
	{
		if( pPersRef )
		{
			if( pPersRef->m_fSelected == FALSE )
			{
				// Doesn't make sense, there can only be one item
				//m_pPersRefMgr->UnselectAll();
				pPersRef->m_fSelected = TRUE;
			}
		}
	}

	m_pPersRefMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );

	m_pPersRefMgr->OnShowProperties(); 
	if( pPersRef && m_pPersRefMgr->m_pPropPageMgr )
	{
		m_pPersRefMgr->m_pPropPageMgr->RefreshData();
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefStrip::UnselectGutterRange

void CPersRefStrip::UnselectGutterRange( void )
{
	ASSERT( m_pPersRefMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pPersRefMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pPersRefMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PersRefStripMgr.cpp ===
// PersRefStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f PersRefStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "ChordMapRefStripMgr.h"
#include <AFXCTL.H>
#include <initguid.h>
#include "PersRefMgr.h"
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_PersRefMgr, CPersRefMgr)
END_OBJECT_MAP()

class CPersRefStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CPersRefStripMgrApp theApp;

BOOL CPersRefStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CPersRefStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_PersRefMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicChordMapTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicChordMapTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_PERSREFSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

//#include <staticproppagemanager.h>
#include <StaticPropPageManager.h>

class PropPagePersRef;

class CPersRefPropPageMgr : CStaticPropPageManager
{
	friend PropPagePersRef;
public:
	CPersRefPropPageMgr(IDMUSProdFramework* pIFramework);
	~CPersRefPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
 
	// IDMUSProdPropPageManager methods
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithPersRefData();

private:
	IDMUSProdFramework*		m_pIFramework;
	PropPagePersRef*			m_pPropPagePersRef;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PropPagePersRef.h ===
#if !defined(AFX_PROPPAGEPERS_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGEPERS_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>


class CPersRefPropPageMgr;

// PropPagePersRef.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef dialog
class CPersRefPropPageMgr;

class PropPagePersRef : public CPropertyPage
{
	friend CPersRefPropPageMgr;
	DECLARE_DYNCREATE(PropPagePersRef)

// Construction
public:
	PropPagePersRef();
	PropPagePersRef(CPersRefPropPageMgr *pMgr, IDMUSProdFramework* pIFramework);
	~PropPagePersRef();

// Dialog Data
	//{{AFX_DATA(PropPagePersRef)
	enum { IDD = IDD_PERS_REF_PROPPAGE };
	CComboBox	m_comboPers;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPagePersRef)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPagePersRef)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeComboPerss();
	afx_msg void OnDropDownComboPers();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToPersRef( CPropPersRef* pPersRef );
	void GetDataFromPersRef( CPropPersRef* pPersRef );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetPersComboBoxSelection();
	void GetComboBoxText( PersListInfo* pPersListInfo, CString& strText );
	void InsertPersInfoListInComboBox();
	void InsertPersInfo( PersListInfo* pPersListInfo );
	void BuildPersInfoList();


private:
	CPropPersRef*			m_pPersRef;
	CPersRefPropPageMgr *	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fNeedToDetach;
	BOOL					m_fIgnoreSelChange;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleStylesSelected;
    CTypedPtrList<CPtrList, PersListInfo*> m_lstPersListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEPERS_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PropPagePersRef.cpp ===
// PropPagePersRef.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropPersRef.h"
#include "PropPageMgr.h"
#include "PropPagePersRef.h"
#include <initguid.h>
#include <ChordMapDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr constructor/destructor

CPersRefPropPageMgr::CPersRefPropPageMgr(IDMUSProdFramework* pIFramework) : CStaticPropPageManager()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();
	m_pPropPagePersRef = NULL;
//	CStaticPropPageManager::CStaticPropPageManager();
}

CPersRefPropPageMgr::~CPersRefPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	if( m_pPropPagePersRef )
	{
		delete m_pPropPagePersRef;
		m_pPropPagePersRef = NULL;
	}
//	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CPersRefPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	//return CStaticPropPageManager::QueryInterface( riid, ppv );
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CPersRefPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_PERS_REF );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CPersRefPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add PersRef tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPagePersRef)
	{
		m_pPropPagePersRef = new PropPagePersRef;
		m_pPropPagePersRef->m_pIFramework = m_pIFramework;
		m_pPropPagePersRef->m_pIFramework->AddRef();

		m_pPropPagePersRef->m_pPropPageMgr = this;
	}


	if( m_pPropPagePersRef )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPagePersRef->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPagePersRef->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CPersRefPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CPersRefPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropPersRef* pPersRef = NULL;
	HRESULT hr = S_OK;

	if( m_pIPropPageObject == NULL )
	{
		pPersRef = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pPersRef ) ) )
	{
		pPersRef = NULL;
		hr = E_FAIL;
	}

	if( m_pPropPagePersRef )
	{
		m_pPropPagePersRef->m_fHaveData = FALSE;

		if( pPersRef )
		{
			m_pPropPagePersRef->m_fHaveData = TRUE;
			m_pPropPagePersRef->CopyDataToPersRef( pPersRef );
		}
		else
		{
			CPropPersRef PersRef;
			m_pPropPagePersRef->CopyDataToPersRef( &PersRef );
		}

		m_pPropPagePersRef->UpdateControls();
	}

	if( pPersRef )
	{
		delete pPersRef;
	}

	return hr;
};

void CPersRefPropPageMgr::UpdateObjectWithPersRefData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropPersRef PersRef;

	// Populate the PersRef structure
	m_pPropPagePersRef->GetDataFromPersRef( &PersRef );
	
	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&PersRef );
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef property page

IMPLEMENT_DYNCREATE(PropPagePersRef, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef constructor/destructor

PropPagePersRef::PropPagePersRef() : CPropertyPage(PropPagePersRef::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_PERS_REF_PROPPAGE);
	//{{AFX_DATA_INIT(PropPagePersRef)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fIgnoreSelChange = FALSE;
	m_fNeedToDetach = FALSE;
	m_fHaveData = FALSE;

	m_pPersRef = new CPropPersRef;
}

PropPagePersRef::~PropPagePersRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PersListInfo* pPersListInfo;

	while( !m_lstPersListInfo.IsEmpty() )
	{
		pPersListInfo = static_cast<PersListInfo*>( m_lstPersListInfo.RemoveHead() );
		delete pPersListInfo;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}

	if( m_pPersRef )
	{
		delete m_pPersRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef::DoDataExchange

void PropPagePersRef::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPagePersRef)
	DDX_Control(pDX, IDC_COMBO_PERSS, m_comboPers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPagePersRef, CPropertyPage)
	//{{AFX_MSG_MAP(PropPagePersRef)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_KILLFOCUS()
	ON_CBN_SELCHANGE(IDC_COMBO_PERSS, OnSelchangeComboPerss)
	ON_CBN_DROPDOWN(IDC_COMBO_PERSS, OnDropDownComboPers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef::UpdateControls

void PropPagePersRef::UpdateControls( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pPersRef );
	if( m_pPersRef == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Personality combo box
	m_fIgnoreSelChange = TRUE;
	SetPersComboBoxSelection();
	m_fIgnoreSelChange = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef::OnCreate

int PropPagePersRef::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	// JHD 8/26/98: Only need to do this if the window handle isn't in the
	// permament map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef::OnDestroy

void PropPagePersRef::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	// JHD 8/26/98: Only need to do this if we called 'Attach' in OnCreate
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
		m_fNeedToDetach = FALSE;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPagePersRef::OnInitDialog

BOOL PropPagePersRef::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	// Update the dialog
	UpdateControls();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPagePersRef, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPagePersRef)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void PropPagePersRef::OnSelchangeComboPerss() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIFramework != NULL );
	ASSERT( m_pPersRef != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	int nItem = m_comboPers.GetCurSel();
	if( nItem != CB_ERR )
	{
		PersListInfo* pPersListInfo = (PersListInfo *)m_comboPers.GetItemDataPtr( nItem );
		if( pPersListInfo != (PersListInfo *)-1 )
		{
			// fill in appropriate fields
			m_pPersRef->m_PersListInfo = *pPersListInfo;

			IDMUSProdNode* pIPersDocRootNode = NULL;
					
			// NOTE: personalities must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pIFramework->FindDocRootNodeByFileGUID( pPersListInfo->guidFile, &pIPersDocRootNode ) ) )
			{
				if( m_pPersRef->m_pIPersDocRootNode )
				{
					m_pPersRef->m_pIPersDocRootNode->Release();
					m_pPersRef->m_pIPersDocRootNode = NULL;
				}

				m_pPersRef->m_pIPersDocRootNode = pIPersDocRootNode;
				if( m_pPersRef->m_pIPersDocRootNode )
				{
					m_pPersRef->m_pIPersDocRootNode->AddRef();
				}

				m_pPropPageMgr->UpdateObjectWithPersRefData();

				pIPersDocRootNode->Release();
			}
		}
	}
	
}


BOOL PropPagePersRef::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}

void PropPagePersRef::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_comboPers.GetSafeHwnd() == NULL )
	{
		return;
	}

	m_comboPers.EnableWindow( fEnable );

	if( !fEnable )
	{
		m_comboPers.SetCurSel( -1 );
	}
}


void PropPagePersRef::SetPersComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	// Nothing to select
	if( m_pPersRef->m_pIPersDocRootNode == NULL )
	{
		goto LEAVE;
	}

	// Create a PersListInfo struct for the current Pers
	DMUSProdListInfo ListInfo;
	PersListInfo* pPersListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pPersListInfo = new PersListInfo;
	if( pPersListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pIFramework->GetNodeFileGUID ( m_pPersRef->m_pIPersDocRootNode, &pPersListInfo->guidFile );

	if( SUCCEEDED ( m_pPersRef->m_pIPersDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pPersListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pPersListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pIFramework->FindProject( m_pPersRef->m_pIPersDocRootNode, &pIProject ) ) )
		{
			delete pPersListInfo;
			goto LEAVE;
		}

		pPersListInfo->pIProject = pIProject;
//		pPersListInfo->pIProject->AddRef();	intentionally missing

		GUID guidProject;
		if( FAILED ( pIProject->GetGUID( &guidProject ) ) )
		{
			delete pPersListInfo;
			goto LEAVE;
		}

//		if( !IsEqualGUID( guidProject, m_guidProject ) )
		{
			BSTR bstrProjectName;

			if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				delete pPersListInfo;
				goto LEAVE;
			}

			pPersListInfo->strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}
	}
	else
	{
		delete pPersListInfo;
		goto LEAVE;
	}

	// Select the Personality in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboPers.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		PersListInfo* pCurPersListInfo = (PersListInfo *)m_comboPers.GetItemDataPtr( nCurPos );
		if( pCurPersListInfo )
		{
			if( pCurPersListInfo != (PersListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurPersListInfo->guidFile, pPersListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}
	
	if( nMatch == CB_ERR )
	{
		PersListInfo* pPLI;

		// Delete old PersInfo list
		while( !m_lstPersListInfo.IsEmpty() )
		{
			pPLI = static_cast<PersListInfo*>( m_lstPersListInfo.RemoveHead() );
			delete pPLI;
		}

		// Remove old list from combo box
		m_comboPers.ResetContent();

		// Add this Personality to the combo box list
		nPos = 0;
		m_lstPersListInfo.AddTail( pPersListInfo );
		InsertPersInfoListInComboBox();
	}
	else
	{
		nPos = nMatch;
		delete pPersListInfo;
		pPersListInfo = NULL;
	}

LEAVE:
	m_comboPers.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


void PropPagePersRef::GetComboBoxText( PersListInfo* pPersListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pPersListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pPersListInfo->strName, pPersListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pPersListInfo->strProjectName, pPersListInfo->strName, pPersListInfo->strDescriptor );
	}
}

void PropPagePersRef::InsertPersInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	PersListInfo* pPersListInfo;
	int nPos;

	POSITION pos = m_lstPersListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pPersListInfo = static_cast<PersListInfo*>( m_lstPersListInfo.GetNext(pos) );
		if( pPersListInfo )
		{
			GetComboBoxText( pPersListInfo, strText );
			nPos = m_comboPers.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboPers.SetItemDataPtr( nPos, pPersListInfo );
			}
		}
	}
}

void PropPagePersRef::InsertPersInfo( PersListInfo* pPersListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PersListInfo* pListInfo;
	CString strListText;
	CString strPersText;
	POSITION posList;

	GetComboBoxText( pPersListInfo, strPersText );

	POSITION pos = m_lstPersListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<PersListInfo*>( m_lstPersListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pPersListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pPersListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstPersListInfo.InsertBefore( pos, pPersListInfo );
				}
				else
				{
					m_lstPersListInfo.AddTail( pPersListInfo );
				}
				return;
			}

			GetComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strPersText ) > 0 )
			{
				m_lstPersListInfo.InsertBefore( posList, pPersListInfo );
				return;
			}
		}
	}

	m_lstPersListInfo.AddTail( pPersListInfo );
}


void PropPagePersRef::BuildPersInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	PersListInfo* pPersListInfo;

	if( FAILED ( m_pIFramework->FindDocTypeByNodeId( GUID_PersonalityNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pPersListInfo = new PersListInfo;

				pPersListInfo->pIProject = pIProject;
//				pPersListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
//					if( !IsEqualGUID( guidProject, m_guidProject ) )
					{
						if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
						{
							pPersListInfo->strProjectName = bstrProjectName;
							::SysFreeString( bstrProjectName );
						}
					}

				}

				if( ListInfo.bstrName )
				{
					pPersListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pPersListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}
				// Update DocRoot file GUID
				m_pIFramework->GetNodeFileGUID ( pIFileNode, &pPersListInfo->guidFile );

				InsertPersInfo( pPersListInfo );

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}

void PropPagePersRef::CopyDataToPersRef( CPropPersRef* pPersRef )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPersRef != NULL );

	m_pPersRef->m_mtTime		= pPersRef->m_mtTime;
	m_pPersRef->m_dwMeasure		= pPersRef->m_dwMeasure;
	m_pPersRef->m_bBeat			= pPersRef->m_bBeat;
	m_pPersRef->m_dwBits		= pPersRef->m_dwBits;
	m_pPersRef->m_PersListInfo  = pPersRef->m_PersListInfo;

	if( m_pPersRef->m_pIPersDocRootNode )
	{
		m_pPersRef->m_pIPersDocRootNode->Release();
		m_pPersRef->m_pIPersDocRootNode = NULL;
	}
	m_pPersRef->m_pIPersDocRootNode = pPersRef->m_pIPersDocRootNode;
	if( m_pPersRef->m_pIPersDocRootNode )
	{
		m_pPersRef->m_pIPersDocRootNode->AddRef();
	}

	memcpy( &m_pPersRef->m_guidProject, &pPersRef->m_guidProject, sizeof( m_pPersRef->m_guidProject ) );
}


void PropPagePersRef::GetDataFromPersRef( CPropPersRef* pPersRef )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pPersRef != NULL );

	pPersRef->m_mtTime			= m_pPersRef->m_mtTime;
	pPersRef->m_dwMeasure		= m_pPersRef->m_dwMeasure;
	pPersRef->m_bBeat			= m_pPersRef->m_bBeat;
	pPersRef->m_dwBits			= m_pPersRef->m_dwBits;
	pPersRef->m_PersListInfo	= m_pPersRef->m_PersListInfo;

	if( pPersRef->m_pIPersDocRootNode )
	{
		pPersRef->m_pIPersDocRootNode->Release();
		pPersRef->m_pIPersDocRootNode = NULL;
	}
	pPersRef->m_pIPersDocRootNode = m_pPersRef->m_pIPersDocRootNode;
	if( pPersRef->m_pIPersDocRootNode )
	{
		pPersRef->m_pIPersDocRootNode->AddRef();
	}

	memcpy( &pPersRef->m_guidProject, &m_pPersRef->m_guidProject, sizeof( pPersRef->m_guidProject ) );
}

void PropPagePersRef::OnDropDownComboPers( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PersListInfo* pPersListInfo;

	// Delete old PersInfo list
	while( !m_lstPersListInfo.IsEmpty() )
	{
		pPersListInfo = static_cast<PersListInfo*>( m_lstPersListInfo.RemoveHead() );
		delete pPersListInfo;
	}

	// Remove old list from combo box
	m_comboPers.ResetContent();

	// Rebuild the PersInfo list
	BuildPersInfoList();
	InsertPersInfoListInComboBox();

	// Select the current Pers
	SetPersComboBoxSelection();
}

BOOL PropPagePersRef::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
		default:
			break;

	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PropPersRef.cpp ===
#include "stdafx.h"
#include "PropPersRef.h"
#include "PersRefIO.h"

CPropPersRef::CPropPersRef()
{
	m_mtTime = 0;
	m_dwMeasure = 0;
	m_bBeat = 0;
	m_dwBits = 0;

	m_PersListInfo.pIProject = NULL;
	m_PersListInfo.strProjectName = "Empty";
	m_PersListInfo.strName = "Empty";
	m_PersListInfo.strDescriptor = "Empty";
	
	m_pIPersDocRootNode = NULL;
	memset( &m_guidProject, 0, sizeof( m_guidProject ) );
}

CPropPersRef::CPropPersRef( const CPersRefItem *pPersRefItem )
{
	ASSERT( pPersRefItem != NULL );

	m_mtTime = pPersRefItem->m_mtTime;
	m_dwMeasure = pPersRefItem->m_dwMeasure;
	m_bBeat = pPersRefItem->m_bBeat;
	m_dwBits = 0;

	m_PersListInfo.pIProject = pPersRefItem->m_PersListInfo.pIProject;
	m_PersListInfo.strProjectName = pPersRefItem->m_PersListInfo.strProjectName;
	m_PersListInfo.strName = pPersRefItem->m_PersListInfo.strName;
	m_PersListInfo.strDescriptor = pPersRefItem->m_PersListInfo.strDescriptor;

	m_pIPersDocRootNode = pPersRefItem->m_pIPersDocRootNode;
	if( m_pIPersDocRootNode )
	{
		m_pIPersDocRootNode->AddRef();
	}

	m_guidProject = pPersRefItem->m_guidProject;
}

CPropPersRef::~CPropPersRef() 
{
	if( m_pIPersDocRootNode )
	{
		m_pIPersDocRootNode->Release();
		m_pIPersDocRootNode = NULL;
	}
}

void CPropPersRef::ApplyToPersRefItem( CPersRefItem *pPersRefItem )
{
	ASSERT( pPersRefItem != NULL );
	if( pPersRefItem == NULL )
	{
		return;
	}

	pPersRefItem->m_mtTime = m_mtTime;
	pPersRefItem->m_dwMeasure = m_dwMeasure;
	pPersRefItem->m_bBeat = m_bBeat;

	pPersRefItem->m_PersListInfo.pIProject = m_PersListInfo.pIProject;
	pPersRefItem->m_PersListInfo.strProjectName = m_PersListInfo.strProjectName;
	pPersRefItem->m_PersListInfo.strName = m_PersListInfo.strName;
	pPersRefItem->m_PersListInfo.strDescriptor = m_PersListInfo.strDescriptor;
	
	if( pPersRefItem->m_pIPersDocRootNode )
	{
		pPersRefItem->m_pIPersDocRootNode->Release();
	}
	pPersRefItem->m_pIPersDocRootNode = m_pIPersDocRootNode;
	if( pPersRefItem->m_pIPersDocRootNode )
	{
		pPersRefItem->m_pIPersDocRootNode->AddRef();
	}

	pPersRefItem->m_guidProject = m_guidProject;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\PropPersRef.h ===
#ifndef __PROPPERS_REF_H_
#define __PROPPERS_REF_H_

#include <DMUSProd.h>

#pragma pack(2)

typedef struct PersListInfo
{
	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} PersListInfo;

#pragma pack()

class CPersRefItem;

class CPropPersRef 
{
public:
	CPropPersRef();
	CPropPersRef( const CPersRefItem *pPersRefItem );
	~CPropPersRef(); 
	void ApplyToPersRefItem( CPersRefItem *pPersRefItem );

	long			m_mtTime;			// What time this personality reference falls on
    DWORD			m_dwMeasure;		// What measure this personality reference falls on
    BYTE			m_bBeat;			// What beat this personality reference falls on
	DWORD			m_dwBits;			// Various bits
	PersListInfo	m_PersListInfo;
	GUID			m_guidProject;
	IDMUSProdNode*	m_pIPersDocRootNode;
};

#define UD_DRAGSELECT 0x0001

#endif // __PROPPERS_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\PersRefStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PersRefStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_PERS_REF           101
#define IDR_PERS_REFMGR                 102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_PERS_REF_PROPPAGE           105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_STRIP_FBAR_NAME             108
#define IDS_FILE_OPEN_PERS              109
#define IDS_FILE_OPEN_ANY_PERS          110
#define IDS_CHANGE                      111
#define IDS_TRACK_GROUP                 112
#define IDS_UNDO_MOVE                   113
#define IDS_CHANGE_NAME                 114
#define IDS_CHANGE_LINK                 115
#define IDS_CHANGE_FILENAME             116
#define IDS_REPLACE                     116
#define IDC_EDIT_PERS_REF               223
#define IDC_EDIT_TIME                   228
#define IDC_COMBO_GROUP_LIST            231
#define IDC_COMBO_PERSS                 232
#define IDM_DRAG_RMENU                  243
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         233
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboard.cpp ===
// RegionKeyboard.cpp : Implementation of CRegionKeyboardApp and DLL registration.

#include "stdafx.h"
#include "RegionKeyboard.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CRegionKeyboardApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x36cd3184, 0xee61, 0x11d0, { 0x87, 0x6a, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardApp::InitInstance - DLL initialization

BOOL CRegionKeyboardApp::InitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardApp::ExitInstance - DLL termination

int CRegionKeyboardApp::ExitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\Region.cpp ===
#include "stdafx.h"
#include "RegionKeyboardCtl.h"
#include "Region.h"


int CRegion::m_arrKeyboardMap[12] = {0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0};	// 0 is for a White key; 1 for the black key
int CRegion::m_arrKeySizes[2] = {WHITE_KEY_WIDTH, BLACK_KEY_WIDTH};			// White key is 5 pixels; Black is 4 pixels wide


CRegion::CRegion(int nLayer, 
				 int nStartNote, int nEndNote,
				 int nStartVelocity, int nEndVelocity, 
				 int nRootNote, const CString& strWaveName) :
				 				  m_nLayer(nLayer), m_nStartNote(nStartNote), m_nEndNote(nEndNote), 
								  m_nStartVelocity(nStartVelocity), m_nEndVelocity(nEndVelocity),
								  m_nRootNote(nRootNote), m_bSelected(FALSE), m_pKeyboard(NULL), 
								  m_bPlaying(FALSE), m_bEnabled(TRUE), m_strWaveName(strWaveName)
{
	ASSERT(m_nEndNote >= m_nStartNote);
	ASSERT(m_nEndVelocity >= m_nStartVelocity);
	m_DrawColor = PALETTERGB(255, 0, 0);
	//m_Layer0DrawColor = PALETTERGB(7, 39, 141);
	m_Layer0DrawColor = m_DrawColor;
	m_NoteOnColor = PALETTERGB(0, 128, 255);
	m_BkColor = PALETTERGB(255, 255, 255);
}

void CRegion::SetParentControl(CRegionKeyboardCtrl* pParent)
{
	ASSERT(pParent);
	m_pKeyboard = pParent;
}

void CRegion::SetLayer(int nLayer)
{
	m_nLayer = nLayer;
}

int CRegion::GetLayer()
{
	return m_nLayer;
}

int CRegion::GetStartNote()
{
	return m_nStartNote;
}

int	CRegion::GetEndNote()
{
	return m_nEndNote;
}

void CRegion::GetNoteRange(int& nStartNote, int& nEndNote)
{
	nStartNote = m_nStartNote;
	nEndNote = m_nEndNote;
}

void CRegion::SetNoteRange(int nStartNote, int nEndNote)
{
	m_nStartNote = nStartNote;
	m_nEndNote = nEndNote;

	ValidateAndSetRanges();
}


void CRegion::GetVelocityRange(int& nStartVelocity, int& nEndVelocity)
{
	nStartVelocity = m_nStartVelocity;
	nEndVelocity = m_nEndVelocity;
}

void CRegion::SetVelocityRange(int nStartVelocity, int nEndVelocity)
{
	m_nStartVelocity = nStartVelocity;
	m_nEndVelocity = nEndVelocity;

	ValidateAndSetRanges();
}

void CRegion::SetWaveName(LPCTSTR pszWaveName)
{
	m_strWaveName = pszWaveName;
}

void CRegion::SetRegionColor(COLORREF clrRegion)
{
	m_DrawColor = clrRegion;
}

void CRegion::SetBackgroundColor(COLORREF clrBkgnd)
{
	m_BkColor = clrBkgnd;
}

void CRegion::Draw(CDC* pDC, int nLayerAreaHeight, int nFirstVisibleLayer)
{
	ASSERT(m_pKeyboard);
	ASSERT(pDC);

	if(m_nLayer < nFirstVisibleLayer || m_nLayer > nFirstVisibleLayer + (NUMBER_OF_VISIBLE_LAYERS - 1))
		return;

	int nStartX = GetPointFromNote(true, m_nStartNote);
	int nEndX = GetPointFromNote(false, m_nEndNote);

	int nStartY = nLayerAreaHeight - (((m_nLayer - nFirstVisibleLayer) + 1) * REGION_LAYER_HEIGHT);
	
	if(nStartY < 0)
		nStartY = 0;

	int nEndY = nStartY + REGION_LAYER_HEIGHT;
	CRect rectRegion(nStartX, nStartY, nEndX, nEndY);

	m_RegionRect = rectRegion;
	CRect rcInner = m_RegionRect;
	rcInner.InflateRect(-1, -1);

	// figure out the inner color
	COLORREF clrDraw;
	if(m_bSelected && m_pKeyboard->GetFocus() == m_pKeyboard || m_bPlaying)
	{
		clrDraw = m_DrawColor;
		if(m_nLayer == 0)
		{
			clrDraw = m_Layer0DrawColor;
		}

		if(m_bPlaying && m_bEnabled)
		{
			clrDraw = m_NoteOnColor;
		}
	}
	else if(m_bSelected && m_pKeyboard->GetFocus() != m_pKeyboard)
	{
		clrDraw = ::GetSysColor(COLOR_INACTIVECAPTION);
	}
	else
	{
		clrDraw = COLOR_LAYER_CANVAS;
	}

	// font is expected to be set & restored, and background restored, by caller (CRegionKeyboardCtrl::DrawRegionRects)
	pDC->SetBkColor(clrDraw);

	// draw
	pDC->Rectangle(&m_RegionRect);
	CString strWaveName = m_strWaveName;
	strWaveName.MakeUpper();
	pDC->ExtTextOut(rcInner.left+1, m_RegionRect.top, ETO_OPAQUE | ETO_CLIPPED, rcInner, strWaveName, strWaveName.GetLength(), NULL);
}


BOOL CRegion::IsPointInRegion(CPoint point)
{
	return m_RegionRect.PtInRect(point);
}

BOOL CRegion::IsPointInRegion(CPoint point, bool bCheckForKeyboard)
{
	if(bCheckForKeyboard)
	{
		CPoint ptTopLeft = m_RegionRect.TopLeft();
		CPoint ptBottomRight = m_RegionRect.BottomRight();

		return (ptTopLeft.x <= point.x && ptBottomRight.x >= point.x);
	}
	else
		return IsPointInRegion(point);
}

BOOL CRegion::IsNoteInRegion(int nNote)
{
	if(nNote >= m_nStartNote && nNote <= m_nEndNote)
	{
		return TRUE;
	}

	return FALSE;
}

BOOL CRegion::IsNoteInRegion(int nLayer, int nNote)
{
	if(m_nLayer == nLayer && nNote >= m_nStartNote && nNote <= m_nEndNote)
	{
		return TRUE;
	}

	return FALSE;
}


BOOL CRegion::IsNoteInRegion(int nLayer, int nNote, int nVelocity, bool bIgnoreLayer)
{
	if(!bIgnoreLayer)
	{
		if(m_nLayer == nLayer && nNote >= m_nStartNote && nNote <= m_nEndNote &&
			nVelocity >= m_nStartVelocity && nVelocity <= m_nEndVelocity)
		{
			return TRUE;
		}
	}
	else
	{
		if(nNote >= m_nStartNote && nNote <= m_nEndNote &&
			nVelocity >= m_nStartVelocity && nVelocity <= m_nEndVelocity)
		{
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CRegion::IsOverlappingRegion(int nLayer, int nStartNote, int nEndNote)
{
	if(nLayer != m_nLayer)
		return FALSE;

	if(nStartNote >= m_nStartNote && nStartNote <= m_nEndNote)
		return TRUE;

	if(nEndNote >= m_nStartNote && nEndNote <= m_nEndNote)
		return TRUE;

	if(m_nStartNote >= nStartNote && m_nStartNote <= nEndNote)
		return TRUE;

	if(m_nEndNote >= nStartNote && m_nEndNote <= nEndNote)
		return TRUE;

	return FALSE;
}


int CRegion::GetPointFromNote(bool bStartPoint, int nNote)
{

	int nOctaves = 0;
	int nNoteInOctave = nNote;
	
	if(nNote > 0)
	{
		nOctaves = nNote / 12;					// Number of octaves up
		nNoteInOctave = nNote - nOctaves * 12;	// The note in the octave
	}

	if(nNoteInOctave < 0)
		nNoteInOctave = 0;

	int nPixelsOffsetInOctave = 0;

	for(int nNoteIndex = 0; nNoteIndex <= nNoteInOctave; nNoteIndex++)
	{
		if(m_arrKeyboardMap[nNoteIndex] == 0)
			nPixelsOffsetInOctave += WHITE_KEY_WIDTH;
	}

	if(m_arrKeyboardMap[nNoteInOctave] == 1)				// Black key
	{
		if(bStartPoint)
			nPixelsOffsetInOctave -= BLACK_KEY_WIDTH / 2;
		else
			nPixelsOffsetInOctave += BLACK_KEY_WIDTH / 2;
	}
	else if(m_arrKeyboardMap[nNoteInOctave] == 0)			// White key
	{
		if(bStartPoint)
		{
			if(nNoteInOctave == 0 || (nNoteInOctave > 0 && m_arrKeyboardMap[nNoteInOctave - 1] == 0)) // Previous key is white
				nPixelsOffsetInOctave -= WHITE_KEY_WIDTH;
			else
				nPixelsOffsetInOctave -= WHITE_KEY_WIDTH - BLACK_KEY_WIDTH/2 ;
		}
		else if(nNote < 126 && m_arrKeyboardMap[nNoteInOctave + 1] == 1) // The next key is a black key
			nPixelsOffsetInOctave -= WHITE_KEY_WIDTH - BLACK_KEY_WIDTH - 2;

	}
	
	return (nOctaves * OCTAVE_WIDTH) + nPixelsOffsetInOctave;
}


BOOL CRegion::IsSelected()
{
	return m_bSelected;
}

void CRegion::SetSelected(BOOL bSelected)
{
	m_bSelected = bSelected;
}

void CRegion::SetStartNote(int nNote)
{
	if(nNote < 0)
		nNote = 0;
	
	if(nNote <= m_nEndNote)
		m_nStartNote = nNote;
}

void CRegion::SetEndNote(int nNote)
{
	if(nNote < 0)
		nNote = 0;
	
	if(nNote >= m_nStartNote)
		m_nEndNote = nNote;
}

void CRegion::ValidateAndSetRanges()
{
	// Check if notes are in range
	if(m_nStartNote < 0)
		m_nStartNote = 0;
	if(m_nStartNote > 127)
		m_nStartNote = 127;
	if(m_nEndNote <	0)
		m_nEndNote = 0;
	if(m_nEndNote > 127)
		m_nEndNote = 127;

	// Swap the notes if required
	int nTemp = m_nStartNote;
	if(m_nStartNote > m_nEndNote)
	{
		m_nStartNote = m_nEndNote;
		m_nEndNote = nTemp;
	}

	// Check if the velocities are in range
	if(m_nStartVelocity < 0)
		m_nStartVelocity = 0;
	if(m_nStartVelocity > 127)
		m_nStartVelocity = 127;
	if(m_nEndVelocity < 0)
		m_nEndVelocity = 0;
	if(m_nEndVelocity > 127)
		m_nEndVelocity = 127;

	// Swap the velocities if required
	nTemp = m_nStartVelocity;
	if(m_nStartVelocity > m_nEndVelocity)
	{
		m_nStartVelocity = m_nEndVelocity;
		m_nEndVelocity = nTemp;
	}
}


BOOL CRegion::IsPointOnStartBoundary(CPoint point)
{
	int nDragZoneWidth = DRAG_ZONE_WIDTH;
	if(abs(m_nStartNote - m_nEndNote) < 4)
		nDragZoneWidth = 1;

	CPoint ptTopLeft = m_RegionRect.TopLeft();
	if(point.x - ptTopLeft.x  >= 0 &&  abs(ptTopLeft.x - point.x) <= nDragZoneWidth)
		return TRUE;

	return FALSE;
}

BOOL CRegion::IsPointOnEndBoundary(CPoint point)
{
	int nDragZoneWidth = DRAG_ZONE_WIDTH;
	if(abs(m_nStartNote - m_nEndNote) < 4)
		nDragZoneWidth = 1;

	CPoint ptBottomRight = m_RegionRect.BottomRight();
	if(ptBottomRight.x - point.x >= 0 && abs(ptBottomRight.x - point.x) <= nDragZoneWidth)
		return TRUE;

	return FALSE;

}

void CRegion::SetRootNote(int nNote)
{
	ASSERT(nNote >= 0 && nNote <= 127);
	
	if(nNote >= 0 && nNote <= 127)
		m_nRootNote = nNote;
}

int CRegion::GetRootNote()
{
	return m_nRootNote;
}

void CRegion::SetPlayState(BOOL bOn)
{
	m_bPlaying = bOn;
}

void CRegion::Enable(BOOL bEnable)
{
	m_bEnabled = bEnable;
}

CRect CRegion::GetRect()
{
	return m_RegionRect;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboard.h ===
#if !defined(AFX_REGIONKEYBOARD_H__36CD318D_EE61_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONKEYBOARD_H__36CD318D_EE61_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// RegionKeyboard.h : main header file for REGIONKEYBOARD.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardApp : See RegionKeyboard.cpp for implementation.

class CRegionKeyboardApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONKEYBOARD_H__36CD318D_EE61_11D0_876A_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\Region.h ===
#ifndef __REGION_H__
#define __REGION_H__


#define KEYBOARD_SIZE		127		// Assuming a 128 key keyboard
#define WHITE_KEY_WIDTH		8		// Width of the white key in pixels
#define BLACK_KEY_WIDTH		4		// Width of a black key in pixels
#define REGION_LAYER_HEIGHT	10		// Height of a region layer
#define DRAG_ZONE_WIDTH		3		// Drag zone for region boundaries

#define OCTAVE_WIDTH		WHITE_KEY_WIDTH * 7 // Seven white keys make up an octave

// Forward declaration 
class CRegionKeyboardCtrl;

class CRegion
{

public:
	CRegion(int nLayer = 0, 
			int nStartNote = 0, int nEndnote = KEYBOARD_SIZE,	// Spans the whole keyboard range by default
			int nStartVelocity = 0, int nEndVelocity = 127,		// Spans the entire velocity range by default
			int nRootnote = 60,									// Root note is C5 by default
			const CString& strWaveName = "");

// Implementation
public:
	
	void SetParentControl(CRegionKeyboardCtrl* pParent);

	void SetLayer(int nLayer);
	int GetLayer();
	
	void SetRootNote(int nNote);
	int	 GetRootNote();

	int GetStartNote();
	int	GetEndNote();

	void SetStartNote(int nNote);
	void SetEndNote(int nNote);

	void GetNoteRange(int& nStartNote, int& nEndNote);
	void SetNoteRange(int nStartnote = 0, int nEndNote = KEYBOARD_SIZE);

	void GetVelocityRange(int& nStartVelocity, int& nEndVelocity);
	void SetVelocityRange(int nStartVelocity = 0, int nEndVelocity = 127);

	void SetWaveName(LPCTSTR pszWaveName);
	
	void Draw(CDC* pDC, int nLayerAreaHeight, int nFirstVisibleLayer);
	void SetBackgroundColor(COLORREF colorBkgnd = RGB(255, 255, 255,)); // Default background is white
	void SetRegionColor(COLORREF colorRegion = RGB(0, 0, 0,));			// Default region is painted black

	BOOL IsPointInRegion(CPoint point);					// Returns TRUE if the point lies in a region
	BOOL IsPointInRegion(CPoint point, bool bIgnoreY);	// Returns TRUE if the point lies in a region; considers only the X-Co-ordinates if bIgnoreY is TRUE
	BOOL IsPointOnStartBoundary(CPoint point);			// Returns TRUE if the point lies around the start boundary of this region
	BOOL IsPointOnEndBoundary(CPoint point);			// Returns TRUE if the point lies around the end boundary of this region 
	
	BOOL IsNoteInRegion(int nNote);						// Returns TRUE if it finds region that has this note; does not check for the layer
	BOOL IsNoteInRegion(int nLayer, int nNote);			// Retruns TRUE if it finds a region in the passed layer that contains this note
	BOOL IsNoteInRegion(int nLayer, int nNote,				// Retruns TRUE if it finds a region in the passed layer that contains this note
						int nVelocity, bool bIgnoreLayer); // and is within the velocity range
	
	BOOL IsOverlappingRegion(int nLayer, int nStartnote, int nEndNote); // Returns TRUE if it's overlapping the region between the start and end notes

	BOOL IsSelected();
	void SetSelected(BOOL bSelected);

	void Enable(BOOL bEnable);
	void SetPlayState(BOOL bOn);

	CRect GetRect();
	
// Implementation
private: 
	int GetPointFromNote(bool bStartPoint, int nNote);
	void ValidateAndSetRanges();

private:
	
	CRegionKeyboardCtrl* m_pKeyboard;	

	int		m_nStartNote;
	int		m_nEndNote;
	int		m_nStartVelocity;
	int		m_nEndVelocity;
	int		m_nRootNote;
	int		m_nLayer;

	BOOL	m_bSelected;
	BOOL	m_bEnabled;
	BOOL	m_bPlaying;

	CRect	m_RegionRect;

	COLORREF	m_DrawColor;
	COLORREF	m_Layer0DrawColor;
	COLORREF	m_NoteOnColor;
	COLORREF	m_BkColor;


	static int m_arrKeyboardMap[12];	// Map of the keys for an Octave
	static int m_arrKeySizes[2];		// sizes for the black and white keys

	CString m_strWaveName;				// wave name

};



#endif //__REGION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboardPpg.cpp ===
// RegionKeyboardPpg.cpp : Implementation of the CRegionKeyboardPropPage property page class.

#include "stdafx.h"
#include "RegionKeyboard.h"
#include "RegionKeyboardPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRegionKeyboardPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRegionKeyboardPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CRegionKeyboardPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRegionKeyboardPropPage, "REGIONKEYBOARD.RegionKeyboardPropPage.1",
	0x36cd3188, 0xee61, 0x11d0, 0x87, 0x6a, 0, 0xaa, 0, 0xc0, 0x81, 0x46)


/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardPropPage::CRegionKeyboardPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CRegionKeyboardPropPage

BOOL CRegionKeyboardPropPage::CRegionKeyboardPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_REGIONKEYBOARD_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardPropPage::CRegionKeyboardPropPage - Constructor

CRegionKeyboardPropPage::CRegionKeyboardPropPage() :
	COlePropertyPage(IDD, IDS_REGIONKEYBOARD_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CRegionKeyboardPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardPropPage::DoDataExchange - Moves data between page and properties

void CRegionKeyboardPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	//{{AFX_DATA_MAP(CRegionKeyboardPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboardCtl.h ===
#if !defined(AFX_REGIONKEYBOARDCTL_H__36CD3195_EE61_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONKEYBOARDCTL_H__36CD3195_EE61_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RegionNote.h"
#include "AfxTempl.h"


#define NUMBER_OF_VISIBLE_LAYERS	4	// Number of layers visible by default


#define COLOR_ACTIVE_LAYER	PALETTERGB(244, 243, 152)
#define COLOR_LAYER_CANVAS	PALETTERGB(255, 255, 255)
#define COLOR_LAYER_SELECT	PALETTERGB(255, 0, 0)

#define RK_NULL		0
#define RK_START	(1 << 0)
#define RK_END		(1 << 1)
#define	RK_MOVE		(1 << 2)
#define	RK_COPY		(1 << 3)

#define	AUDITION_SOLO		0
#define AUDITION_MULTIPLE	1


	
class CRegion;

// RegionKeyboardCtl.h : Declaration of the CRegionKeyboardCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl : See RegionKeyboardCtl.cpp for implementation.

class CRegionKeyboardCtrl : public COleControl
{
	DECLARE_DYNCREATE(CRegionKeyboardCtrl)

// Constructor
public:
	CRegionKeyboardCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegionKeyboardCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CRegionKeyboardCtrl();

	DECLARE_OLECREATE_EX(CRegionKeyboardCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CRegionKeyboardCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CRegionKeyboardCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CRegionKeyboardCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CRegionKeyboardCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CRegionKeyboardCtrl)
	afx_msg void InitializeKeyBoard(LPUNKNOWN RegionMap);
	afx_msg void SetCurrentRegion(short nLayer, short nStartNote);
	afx_msg void MidiEvent(short nMidiNote, short nNoteFlag, short nVelocity);
	afx_msg void SetRootNote(short nNote);
	afx_msg short InsertNewRegion(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity);
	afx_msg short InsertRegion(short nLayer, short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity, LPCTSTR pszWaveName);
	afx_msg BOOL SetRange(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity);
	afx_msg void DeleteRegion(short nLayer, short nStartNote);
	afx_msg void DeleteAllRegions();
	afx_msg void ReleaseMouseCapture();
	afx_msg void TurnOffMidiNotes();
	afx_msg short SetCurrentLayer(short nLayer);
	afx_msg short SetFirstVisibleLayer(short nLayer);
	afx_msg short ScrollLayers(short nSBCode, short nCurPos);
	afx_msg short GetNumberOfLayers();
	afx_msg short GetFirstVisibleLayer();
	afx_msg short AddNewLayer();
	afx_msg short DeleteActiveLayer();
	afx_msg void SetAuditionMode(BOOL bAuditionMode);
	afx_msg void EnableRegion(short nLayer, short nStartNote, BOOL bEnable);
	afx_msg void SetNumberOfLayers(short nLayers);
	afx_msg void SetWaveName(short nLayer, short nStartNote, LPCTSTR pszWaveName);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CRegionKeyboardCtrl)
	void FireRegionSelectedChanged(short nLayer, short nStartNote)
		{FireEvent(eventidRegionSelectedChanged,EVENT_PARAM(VTS_I2  VTS_I2), nLayer, nStartNote);}
	void FireNewRegion(short nLayer, long lower, long upper)
		{FireEvent(eventidNewRegion,EVENT_PARAM(VTS_I2  VTS_I4  VTS_I4), nLayer, lower, upper);}
	void FireRangeChanged(short nLayer, long lower, long upper)
		{FireEvent(eventidRangeChanged,EVENT_PARAM(VTS_I2  VTS_I4  VTS_I4), nLayer, lower, upper);}
	void FireNotePlayed(long nNote, BOOL bType)
		{FireEvent(eventidNotePlayed,EVENT_PARAM(VTS_I4  VTS_BOOL), nNote, bType);}
	void FireRegionMoved(short nOldLayer, short nOldStartNote, short nMovedLayer, short nMovedStartNote, short nMovedEndNote)
		{FireEvent(eventidRegionMoved,EVENT_PARAM(VTS_I2  VTS_I2  VTS_I2  VTS_I2  VTS_I2), nOldLayer, nOldStartNote, nMovedLayer, nMovedStartNote, nMovedEndNote);}
	void FireRegionDeleted(short nLayer, short nStartNote)
		{FireEvent(eventidRegionDeleted,EVENT_PARAM(VTS_I2  VTS_I2), nLayer, nStartNote);}
	void FireActiveLayerChanged(short nLayer)
		{FireEvent(eventidActiveLayerChanged,EVENT_PARAM(VTS_I2), nLayer);}
	void FireCopyRegion(short nSourceLayer, short nSourceStartNote, short nCopyLayer, short nCopyStartNote)
		{FireEvent(eventidCopyRegion,EVENT_PARAM(VTS_I2  VTS_I2  VTS_I2  VTS_I2), nSourceLayer, nSourceStartNote, nCopyLayer, nCopyStartNote);}
	void FireScrollLayers(BOOL bUp)
		{FireEvent(eventidScrollLayers,EVENT_PARAM(VTS_BOOL), bUp);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CRegionKeyboardCtrl)
	dispidInitializeKeyBoard = 1L,
	dispidSetCurrentRegion = 2L,
	dispidMidiEvent = 3L,
	dispidSetRootNote = 4L,
	dispidInsertNewRegion = 5L,
	dispidInsertRegion = 6L,
	dispidSetRange = 7L,
	dispidDeleteRegion = 8L,
	dispidDeleteAllRegions = 9L,
	dispidReleaseMouseCapture = 10L,
	dispidTurnOffMidiNotes = 11L,
	dispidSetCurrentLayer = 12L,
	dispidSetFirstVisibleLayer = 13L,
	dispidScrollLayers = 14L,
	dispidGetNumberOfLayers = 15L,
	dispidGetFirstVisibleLayer = 16L,
	dispidAddNewLayer = 17L,
	dispidDeleteActiveLayer = 18L,
	dispidSetAuditionMode = 19L,
	dispidEnableRegion = 20L,
	dispidSetNumberOfLayers = 21L,
	dispidSetWaveName = 22L,
	eventidRegionSelectedChanged = 1L,
	eventidNewRegion = 2L,
	eventidRangeChanged = 3L,
	eventidNotePlayed = 4L,
	eventidRegionMoved = 5L,
	eventidRegionDeleted = 6L,
	eventidActiveLayerChanged = 7L,
	eventidCopyRegion = 8L,
	eventidScrollLayers = 9L,
	//}}AFX_DISP_ID
	};


public:
	int GetActiveLayer();

private:
	void DrawKeyboard(CDC* pDC, const CRect& rcBounds);
	void DrawLayersOnRegionBitmap(CDC* pDC, CRect& regionRect);
	void DrawRegionRects(CDC* pDC);
	void SetNormalCursor();		
	void SetNoDoCursor(bool bOn); //  A slashed circle
	void SetSizeCursor(bool bOn, bool bResizeStart);
	void SetMoveCursor(bool bOn);
	void SetCopyCursor(bool bOn);
    void DrawRootNote(CDC * pdc);
	void MarkPlayingRegions(short nNote, short nNoteFlag, short nVelocity, CPtrList* plstPlayingRegions);
	
	int			GetNotePlayed(CPoint point);
	void		PlayNote(int nNote, bool bType);
	int			GetKeyIndexFromPoint(CPoint point);
	CRegion*	IsMemberOfRegion(int nKey);				// Returns the region containing this note; else returns NULL
	int			GetGoodLayer(CPoint point);
	void		SelectAllRegions(int nNote);
	void		SelectRegion(CPoint point);
	void		SelectRegion(int nLayer, int nStartNote);
	CRegion*	GetRegionForPoint(CPoint point, bool bIgnoreY);
	int			GetLayerFromPoint(CPoint point);
	int			GetAbsoluteLayerFromPoint(CPoint point);
	int			GetRootNoteFromActiveRegion();
	void		SetActiveLayer(CPoint point);
	int			_InsertNewRegion(int nLayer, int nStartNote, int nEndNote, LPCTSTR pszWaveName);
	int			_InsertNewRegion(int nStartNote, int nEndNote);
	void		UpdateRegionRect();
	CRegion*	CheckForCollision(CRegion* pCheckedRegion, int nLayer, int nStartNote,int nEndNote, bool bCheckSelfCollision = false);
	void		CopySelectedRegionAtPoint(CPoint point);
	CRegion*	GetRegionBeforeStartNote(CRegion* pRegion);
	CRegion*	GetRegionAfterEndNote(CRegion* pRegion);

	void		DrawGhostRect(CRegion* pRegion, CPoint ptPeg, CPoint ptDrag);

private:
	
	enum 
	{
		MIN_POS = 0, REGION_LAYER_HEIGHT = 10, 
		REGION_LAYER_AREA_HEIGHT = NUMBER_OF_VISIBLE_LAYERS * REGION_LAYER_HEIGHT, 
		PAGE_SIZE = 12, PAGE_SIZE_PIXELS = 56
	};

    int m_nMaxScrollPos;   
	//TODO: page_size is pagesize in notes. 
	static const int m_nKeyPos[12];
	static const int m_nKeySize[12];
    static const int m_nKeyCenter[12];  // center of key at whoch the circle is drawn
    static const int m_nRadius[12]; // radius of the circle that shows key is a root note.
	static const int m_nRegionKeyboardSize;

	int			m_nLastMidiNoteOn[128];

	bool		m_bNoteIsOn;
	CPoint		m_ptLastNote;

	RegionNote m_nRegionMap[128];

	CRect		m_RegionsRect;
	int			m_nNumberOfLayers;
	int			m_nFirstVisibleLayer;				// keeps track of the first layer to handle scrolling
	int			m_nActiveLayer;						// The active layer
	int			m_nDraggedKey;
	CRegion*	m_pDraggedRegion;					// Used to keep track of the dragged region
	CRegion*	m_pCurrentRegion;
	CTypedPtrList<CPtrList, CRegion*> m_lstRegions; // List of regions
	CFont		m_fnRegion;						// cached font for region labels
	bool		m_bRegionFontCreated;			// whether m_fnRegion has been created

	int m_nCurKeyPos;

	static	int			m_nKeyboards;				// Keeps track of instances 
	static	HANDLE		m_hKeyBoard128;			
	static	CBitmap		m_bmKeyBoard128;
	static	HANDLE		m_hBlank128;
	static	CBitmap		m_bmBlank128;

	int			m_nKeyboardOffset;
	int			m_nCurRegion;
	int			m_nRegionMapIndex;
	
	bool		m_bHasCapture;
	CPoint		m_ptLButtonDown;
	static	HCURSOR		m_hArrowCursor;
	static	HCURSOR		m_hStartEditCursor;
	static	HCURSOR		m_hEndEditCursor;
	static	HCURSOR		m_hSIZEWECursor;
	static	HCURSOR		m_hMOVECursor;
	static	HCURSOR		m_hCOPYCursor;
	static	HCURSOR		m_hNODOCursor;
	bool		m_bStartCursorSet;
	bool		m_bEndCursorSet;
	bool		m_bMoveCursorSet;
	bool		m_bCopyCursorSet;
	bool		m_bNoDoCursorSet;
	
	int 		m_nStartEnd;
	int			m_nMaxEndPixel;
	int			m_nMinEndPixel;

	BOOL		m_bAuditionMode;	// MULTIPLE_LAYER == 1 ; SOLO_LAYER == 0
	CRect		m_lastGhostRect;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONKEYBOARDCTL_H__36CD3195_EE61_11D0_876A_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboardCtl.cpp ===
// RegionKeyboardCtl.cpp : Implementation of the CRegionKeyboardCtrl ActiveX Control class.

#include "stdafx.h"
#include "KeyBoardMap.h"
#include "RegionKeyboard.h"
#include "RegionKeyboardCtl.h"
#include "RegionKeyboardPpg.h"
#include "Region.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CRegionKeyboardApp theApp;

IMPLEMENT_DYNCREATE(CRegionKeyboardCtrl, COleControl)

#define MIDI_NOTEON     0x90
#define MIDI_NOTEOFF    0x80

// These contant variables are determined by the bitmap used for keyboard. If it is changed
// they must be updated as well as enum PAGE_SIZE_PIXEL and REGION_LAYER_HEIGHT
// It is assume that the keyboard bitmap has 128 keys
const int CRegionKeyboardCtrl::m_nRegionKeyboardSize = 600;
const int CRegionKeyboardCtrl::m_nKeyPos[12] = {0, 5, 10, 13, 18, 24, 29, 34, 37, 42, 45, 50};
const int CRegionKeyboardCtrl::m_nKeySize[12] = {5, 5, 4, 5, 5, 5, 5, 4, 4, 4, 5, 5};
//old values for m_nKeyPos[12] = {0, 5, 10, 14, 19, 24, 29, 34, 38, 42, 46, 51};
// These 2 arrays are used to draw the circle for the rootnote.
const int CRegionKeyboardCtrl::m_nKeyCenter[12] = {4, 7, 12, 15, 20, 28, 31, 36, 39, 44, 47, 52};
// white keys have a radius of 2 - black keys have a radius 1. 
const int CRegionKeyboardCtrl::m_nRadius[12] = {2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2};

const int NUMKEYS = 127;

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRegionKeyboardCtrl, COleControl)
	//{{AFX_MSG_MAP(CRegionKeyboardCtrl)
	ON_WM_CREATE()
	ON_WM_HSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_KILLFOCUS()
	ON_WM_VSCROLL()
	ON_WM_KEYDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CRegionKeyboardCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CRegionKeyboardCtrl)
	DISP_FUNCTION(CRegionKeyboardCtrl, "InitializeKeyBoard", InitializeKeyBoard, VT_EMPTY, VTS_UNKNOWN)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetCurrentRegion", SetCurrentRegion, VT_EMPTY, VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "MidiEvent", MidiEvent, VT_EMPTY, VTS_I2 VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetRootNote", SetRootNote, VT_EMPTY, VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "InsertNewRegion", InsertNewRegion, VT_I2, VTS_I2 VTS_I2 VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "InsertRegion", InsertRegion, VT_I2, VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_BSTR)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetRange", SetRange, VT_BOOL, VTS_I2 VTS_I2 VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "DeleteRegion", DeleteRegion, VT_EMPTY, VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "DeleteAllRegions", DeleteAllRegions, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "ReleaseMouseCapture", ReleaseMouseCapture, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "TurnOffMidiNotes", TurnOffMidiNotes, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetCurrentLayer", SetCurrentLayer, VT_I2, VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetFirstVisibleLayer", SetFirstVisibleLayer, VT_I2, VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "ScrollLayers", ScrollLayers, VT_I2, VTS_I2 VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "GetNumberOfLayers", GetNumberOfLayers, VT_I2, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "GetFirstVisibleLayer", GetFirstVisibleLayer, VT_I2, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "AddNewLayer", AddNewLayer, VT_I2, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "DeleteActiveLayer", DeleteActiveLayer, VT_I2, VTS_NONE)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetAuditionMode", SetAuditionMode, VT_EMPTY, VTS_BOOL)
	DISP_FUNCTION(CRegionKeyboardCtrl, "EnableRegion", EnableRegion, VT_EMPTY, VTS_I2 VTS_I2 VTS_BOOL)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetNumberOfLayers", SetNumberOfLayers, VT_EMPTY, VTS_I2)
	DISP_FUNCTION(CRegionKeyboardCtrl, "SetWaveName", SetWaveName, VT_EMPTY, VTS_I2 VTS_I2 VTS_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CRegionKeyboardCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()

/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CRegionKeyboardCtrl, COleControl)
	//{{AFX_EVENT_MAP(CRegionKeyboardCtrl)
	EVENT_CUSTOM("RegionSelectedChanged", FireRegionSelectedChanged, VTS_I2 VTS_I2)
	EVENT_CUSTOM("NewRegion", FireNewRegion, VTS_I2 VTS_I4  VTS_I4)
	EVENT_CUSTOM("RangeChanged", FireRangeChanged, VTS_I2 VTS_I4  VTS_I4)
	EVENT_CUSTOM("NotePlayed", FireNotePlayed, VTS_I4  VTS_BOOL)
	EVENT_CUSTOM("RegionMoved", FireRegionMoved, VTS_I2  VTS_I2  VTS_I2  VTS_I2  VTS_I2)
	EVENT_CUSTOM("RegionDeleted", FireRegionDeleted, VTS_I2  VTS_I2)
	EVENT_CUSTOM("ActiveLayerChanged", FireActiveLayerChanged, VTS_I2)
	EVENT_CUSTOM("CopyRegion", FireCopyRegion, VTS_I2  VTS_I2  VTS_I2  VTS_I2)
	EVENT_CUSTOM("ScrollLayers", FireScrollLayers, VTS_BOOL)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CRegionKeyboardCtrl, 1)
	PROPPAGEID(CRegionKeyboardPropPage::guid)
END_PROPPAGEIDS(CRegionKeyboardCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRegionKeyboardCtrl, "REGIONKEYBOARD.RegionKeyboardCtrl.1",
	0x36cd3187, 0xee61, 0x11d0, 0x87, 0x6a, 0, 0xaa, 0, 0xc0, 0x81, 0x46)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CRegionKeyboardCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DRegionKeyboard =
		{ 0x36cd3185, 0xee61, 0x11d0, { 0x87, 0x6a, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };
const IID BASED_CODE IID_DRegionKeyboardEvents =
		{ 0x36cd3186, 0xee61, 0x11d0, { 0x87, 0x6a, 0, 0xaa, 0, 0xc0, 0x81, 0x46 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwRegionKeyboardOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CRegionKeyboardCtrl, IDS_REGIONKEYBOARD, _dwRegionKeyboardOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::CRegionKeyboardCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CRegionKeyboardCtrl

BOOL CRegionKeyboardCtrl::CRegionKeyboardCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_REGIONKEYBOARD,
			IDB_REGIONKEYBOARD,
			afxRegInsertable | afxRegApartmentThreading,
			_dwRegionKeyboardOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::CRegionKeyboardCtrl - Constructor

int CRegionKeyboardCtrl::m_nKeyboards = 0;

HANDLE CRegionKeyboardCtrl::m_hKeyBoard128 = NULL;
HANDLE CRegionKeyboardCtrl::m_hBlank128 = NULL;
CBitmap CRegionKeyboardCtrl::m_bmKeyBoard128;
CBitmap CRegionKeyboardCtrl::m_bmBlank128;

HCURSOR	CRegionKeyboardCtrl::m_hArrowCursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hStartEditCursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hEndEditCursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hSIZEWECursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hMOVECursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hCOPYCursor = NULL;
HCURSOR	CRegionKeyboardCtrl::m_hNODOCursor = NULL;


CRegionKeyboardCtrl::CRegionKeyboardCtrl() : m_nCurKeyPos(0), m_nKeyboardOffset(0), m_nCurRegion(0),	
											 m_nRegionMapIndex(0), m_bHasCapture(false), m_ptLButtonDown(-1,-1),
											 m_bStartCursorSet(false), m_bEndCursorSet(false), 
											 m_nStartEnd(RK_NULL), m_nMaxEndPixel(CRegionKeyboardCtrl::m_nRegionKeyboardSize),
											 m_nMinEndPixel(0), m_bNoteIsOn(false), m_ptLastNote(NULL), m_pDraggedRegion(NULL), 
											 m_nActiveLayer(1), m_nNumberOfLayers(NUMBER_OF_VISIBLE_LAYERS),
											 m_nFirstVisibleLayer(0), m_pCurrentRegion(NULL), m_nDraggedKey(0), m_bAuditionMode(TRUE),
											 m_bRegionFontCreated(false)
{
	InitializeIIDs(&IID_DRegionKeyboard, &IID_DRegionKeyboardEvents);

	m_nKeyboards++;
	
	if(m_hKeyBoard128 == NULL)
	{
		m_hKeyBoard128 = LoadImage(theApp.m_hInstance,
							   MAKEINTRESOURCE(IDB_KEYBOARD_128),
							   IMAGE_BITMAP,
							   0,
							   0,
							   LR_CREATEDIBSECTION);

		ASSERT(m_hKeyBoard128);
		
		if(m_hKeyBoard128)
		{
			m_bmKeyBoard128.Attach(m_hKeyBoard128);
		}
	}

	
	if(m_hBlank128 == NULL)
	{
		m_hBlank128 = LoadImage(theApp.m_hInstance,
							MAKEINTRESOURCE(IDB_BLANK_128),
							IMAGE_BITMAP,
							0,
							0,
							LR_CREATEDIBSECTION);

		ASSERT(m_hBlank128);
		
		if(m_hBlank128)
		{
			m_bmBlank128.Attach(m_hBlank128);
		}

		memset(m_nLastMidiNoteOn, 0, sizeof(m_nLastMidiNoteOn));
	}

	// Load cursors
	if(m_hNODOCursor == NULL)
		m_hNODOCursor = theApp.LoadStandardCursor(MAKEINTRESOURCE(IDC_NO));

	if(m_hStartEditCursor == NULL)
		m_hStartEditCursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_CURSOR_STARTEDIT));

	if(m_hEndEditCursor == NULL)
		m_hEndEditCursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_CURSOR_ENDEDIT));
	
	if(m_hMOVECursor == NULL)
		m_hMOVECursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_CURSOR_MOVE));

	if(m_hCOPYCursor == NULL)
		m_hCOPYCursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_CURSOR_COPY));

	if(m_hArrowCursor == NULL)
		m_hArrowCursor = theApp.LoadStandardCursor(MAKEINTRESOURCE(IDC_ARROW));

	m_lastGhostRect.SetRectEmpty();
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::~CRegionKeyboardCtrl - Destructor

CRegionKeyboardCtrl::~CRegionKeyboardCtrl()
{
	DeleteAllRegions();

	m_nKeyboards--;

	if(m_nKeyboards <= 0)
	{
		m_bmKeyBoard128.Detach();
		m_bmBlank128.Detach();

		DeleteObject(m_hKeyBoard128);
		m_hKeyBoard128 = NULL;
		DeleteObject(m_hBlank128);
		m_hBlank128 = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::OnDraw - Drawing function

void CRegionKeyboardCtrl::OnDraw(CDC* pdc, 
								const CRect& rcBounds, 
								const CRect& rcInvalid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	// MFC based containers call OnDraw multiple times with different DC's.
	// We only want to paint once and when DC is client area of control.
	// This should happen when both rcBounds.top = 0 and rcBounds.left = 0
	if(rcBounds.top != 0 && rcBounds.left != 0)
	{
		TRACE0("Returning from RegionKeyboard control's OnDraw call without drawing\n");
		return;
	}
	
	DrawKeyboard(pdc, rcBounds);
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::DoPropExchange - Persistence support

void CRegionKeyboardCtrl::DoPropExchange(CPropExchange* pPX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::OnResetState - Reset control to default state

void CRegionKeyboardCtrl::OnResetState()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	// Resets defaults found in DoPropExchange
	COleControl::OnResetState();  
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl::AboutBox - Display an "About" box to the user

void CRegionKeyboardCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	CDialog dlgAbout(IDD_ABOUTBOX_REGIONKEYBOARD);
	dlgAbout.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardCtrl message handlers

int CRegionKeyboardCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

    // Find out how many keys are initially visible?
    CRect rcClient;
    GetClientRect(rcClient);
    int nWidth = rcClient.Width();
    // on creation we display starting with key 0. 56 = size of octave in pixels
    int nOctaves = nWidth/56; // how many octaves are visible.
    int nVisible = nOctaves * 56;    //at least
    for (int key = 0; nWidth >= nVisible; key++)
    {
        nVisible += m_nKeySize[key];
    }
    
    //NOTE: The array above (m_nKeySize) is 0-based but we are interested in the 
    // number of keys which is 1-based. So we don't decrement the value of key.
    // If the value of key is 12 it means we are showing the full octave.
    
    //EnableScrollBarCtrl(SB_VERT, TRUE);


    int nVisibleKeys = (nOctaves*12) + key;  // number of keys is not 0-based. It's 128.

    m_nMaxScrollPos = NUMKEYS - nVisibleKeys; // This goes into 0-based again. numkeys = 127.

	SetScrollRange(SB_HORZ, 0, m_nMaxScrollPos, FALSE);	
	//ShowScrollBar(SB_VERT, TRUE);
 
	return 0;
}

void CRegionKeyboardCtrl::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	static int nCurrPos = 0;

	BITMAP bmInfo;
	int nStatus =  m_bmKeyBoard128.GetBitmap(&bmInfo);

	CClientDC clientDC(this);	
	CRect rcClientRect;
	GetClientRect(rcClientRect);

	int nMaxKeyboardOffset = bmInfo.bmWidth - rcClientRect.Width();
	nMaxKeyboardOffset = nMaxKeyboardOffset < 0 ? 0 : nMaxKeyboardOffset;
	
	switch(nSBCode)
	{
		case SB_LEFT:
			break;

		case SB_RIGHT:
			break;

		case SB_LINELEFT:
			nCurrPos -= 1;
			m_nKeyboardOffset -= m_nKeySize[m_nCurKeyPos];
			m_nCurKeyPos--;
			m_nCurKeyPos = m_nCurKeyPos < 0 ? 0 : m_nCurKeyPos;
			break;

		case SB_LINERIGHT:
			nCurrPos += 1;
			m_nCurKeyPos++;
			m_nCurKeyPos = m_nCurKeyPos > 11 ? 11 : m_nCurKeyPos;
			m_nKeyboardOffset += m_nKeySize[m_nCurKeyPos];
			break;

		case SB_PAGELEFT:
			nCurrPos -= PAGE_SIZE;
			m_nKeyboardOffset -= PAGE_SIZE_PIXELS;
			break;

		case SB_PAGERIGHT:
			nCurrPos += PAGE_SIZE;
			m_nKeyboardOffset += PAGE_SIZE_PIXELS;
			break;

		case SB_THUMBPOSITION:
			nCurrPos = nPos;
			int nNumOctaves = nPos / 12;
			m_nCurKeyPos = nPos % 12;
			if(nNumOctaves == 0 && m_nCurKeyPos == 0)
			{
				m_nKeyboardOffset = 0;
			}
			else
			{
				m_nKeyboardOffset = nNumOctaves * PAGE_SIZE_PIXELS;
                for (int i = 0; i <= m_nCurKeyPos; i++)
                    m_nKeyboardOffset += m_nKeySize[i];
			}
			break;
	}


	nCurrPos = max(0, min(nCurrPos, m_nMaxScrollPos));

	SetScrollPos(SB_HORZ, nCurrPos, TRUE);

	m_nKeyboardOffset = max(0, min(m_nKeyboardOffset, bmInfo.bmWidth));
	
	m_nKeyboardOffset = m_nKeyboardOffset < nMaxKeyboardOffset ? m_nKeyboardOffset : nMaxKeyboardOffset;

	DrawKeyboard(&clientDC, rcClientRect);
}

void CRegionKeyboardCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	SetFocus();
	SetActiveLayer(point);
 
	// Index of the key hit on the keyboard
	int nIndex = GetKeyIndexFromPoint(point);
	nIndex = nIndex < 0 ? 0 : nIndex;
	nIndex = nIndex > 127 ? 127 : nIndex;

	// This takes care of the condition when the user clicks on the keyboard but NOT on the region strip
	int nPlayedNote = GetNotePlayed(point);
	CRegion* pRegion = IsMemberOfRegion(nPlayedNote);
	if(pRegion && pRegion->IsSelected() == FALSE)
	{
		pRegion->SetSelected(true);
		if(m_pCurrentRegion)
		{
			m_pCurrentRegion->SetSelected(false);
		}

		m_pCurrentRegion = pRegion;
		FireRegionSelectedChanged(m_pCurrentRegion->GetLayer(), m_pCurrentRegion->GetStartNote());
		SetFocus();
		CClientDC clientDC(this);
		DrawRegionRects(&clientDC);
	}

	// Play the note...
	// turn off the last note
	int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
	if(m_bNoteIsOn == true)
	{
		PlayNote(nLastNotePlayed, false); 
	}

	m_bNoteIsOn = true;
	SetCapture();
	PlayNote(nPlayedNote, TRUE); // Turn this note On
	/*if(m_bAuditionMode == AUDITION_MULTIPLE)
	{
		// Change the color for all the regions that will play for this note
		SetPlayColorForNote(nPlayedNote);
	}*/
	m_ptLastNote = point;

	// Now we start dealing with the actual region which was clicked
	pRegion = GetRegionForPoint(point, false);

	if(pRegion && !(nFlags & MK_CONTROL))
	{
		m_pDraggedRegion = pRegion;
		if(m_pDraggedRegion == NULL)
			return;

		SetCapture();
		m_bHasCapture = true;
		m_ptLButtonDown = point;
	
		if(m_pDraggedRegion->IsPointOnStartBoundary(point)) 
		{
			m_nStartEnd = RK_START;
			SetSizeCursor(true, true);
		}
		else if(m_pDraggedRegion->IsPointOnEndBoundary(point))
		{
			m_nStartEnd = RK_END;
			SetSizeCursor(true, false);
		}
		else
		{
			m_nStartEnd = RK_MOVE;
			m_nDraggedKey = GetKeyIndexFromPoint(point) - m_pDraggedRegion->GetStartNote();
			SetMoveCursor(true);
		}

		if(m_pCurrentRegion)
		{
			FireRegionSelectedChanged(m_pCurrentRegion->GetLayer(), m_pCurrentRegion->GetStartNote());
			SetFocus();
		}

		if ( m_bStartCursorSet || m_bEndCursorSet ||m_bMoveCursorSet )
			return;
	} 
	else if(pRegion && (nFlags & MK_CONTROL))
	{
		SetCapture();
		m_bHasCapture = true;
		m_ptLButtonDown = point;
		m_nDraggedKey = GetKeyIndexFromPoint(point) - pRegion->GetStartNote();

		m_nStartEnd |= RK_COPY;
		SetCopyCursor(true);

		SetCurrentRegion(m_nActiveLayer, pRegion->GetStartNote());
		m_pDraggedRegion = pRegion;
		
		return;
	}
		
	int nNumOctaves = (point.x + m_nKeyboardOffset) / 56; //TODO: replace 56 with PAGE_SIZE_PIXELS
	int nNearestOctaveOffset = (point.x + m_nKeyboardOffset) % 56;
	int key = 0;

	// Find key within Octave which contains nNearestOctaveOffset
	for(; key < 12 && nNearestOctaveOffset >= m_nKeyPos[key]; key++);

	BITMAP bmInfoR;
	int nStatus =  m_bmKeyBoard128.GetBitmap(&bmInfoR);

	// If clicked on the black key else play the white key
	// The black keys extend for 4 pixels more than half the height of the keyboard rect
	if((point.y - REGION_LAYER_AREA_HEIGHT) > (bmInfoR.bmHeight/2) + 4 && m_nRadius[key - 1] == 1)
	{
		if((point.x - nNearestOctaveOffset*56) > 2)
			key++;
		else
			key--;
	}
	
	// Index of the key hit on the keyboard
	int nLayer = GetGoodLayer(point);

	if(IsMemberOfRegion(nIndex) == NULL && nIndex <= 127)
	{
		// Don't want to insert regions in wrong layers
		if(nFlags & MK_CONTROL && m_nActiveLayer <= m_nNumberOfLayers)
		{	
			CRegion* pNewRegion = new CRegion(m_nActiveLayer, nIndex, nIndex); 
			pNewRegion->SetParentControl(this);
			m_lstRegions.AddTail(pNewRegion);

			m_pDraggedRegion = pNewRegion;

			FireNewRegion(m_nActiveLayer, pNewRegion->GetStartNote(), pNewRegion->GetEndNote());			
		
			CClientDC clientDC(this);
			DrawRegionRects(&clientDC);
			
			SetCapture();
			m_bHasCapture = true;
			m_ptLButtonDown = point;
			m_nStartEnd = RK_END;
			SetSizeCursor(true, false);
			
			InvalidateControl();
			return;
		}
	}

	if(m_pCurrentRegion)
		FireRegionSelectedChanged(m_pCurrentRegion->GetLayer(), m_pCurrentRegion->GetStartNote());
	
	SetFocus();
	InvalidateControl();
}

int CRegionKeyboardCtrl::GetNotePlayed(CPoint point)
{
	int nNumOctaves = (point.x + m_nKeyboardOffset) / 56; 
	int nNearestOctaveOffset = (point.x + m_nKeyboardOffset) % 56;
	int key = 0;

	// Find key within Octave which contains nNearestOctaveOffset
	for(; key < 12 && nNearestOctaveOffset >= m_nKeyPos[key]; key++);

	BITMAP bmInfoR;
	int nStatus =  m_bmKeyBoard128.GetBitmap(&bmInfoR);

	// If clicked on the black key else play the white key
	// The black keys extend for 4 pixels more than half the height of the keyboard rect
	if((point.y - REGION_LAYER_AREA_HEIGHT) > (bmInfoR.bmHeight/2) + 4 && m_nRadius[key - 1] == 1)
	{
		if((point.x - nNearestOctaveOffset*56) > 2)
			key++;
		else
			key--;
	}

	int nNote = nNumOctaves * 12 + (key - 1); // This is the note Played

	return nNote;
}


void CRegionKeyboardCtrl::PlayNote(int nNote, bool bType)
{
	FireNotePlayed(nNote, bType);
	SetFocus();
}


void CRegionKeyboardCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	m_lastGhostRect.SetRectEmpty();

	if(m_bHasCapture)
	{
		ReleaseCapture();
		m_bHasCapture = false;

		int x = m_ptLButtonDown.x;
		int y = m_ptLButtonDown.y;

		m_ptLButtonDown.x = -1;
		m_ptLButtonDown.y = -1;

		// User simply clicked over selected region
		// No need to change anything so return
		if(point.x == x && point.y == y)
		{
			m_nStartEnd = RK_NULL;
			m_nMaxEndPixel = CRegionKeyboardCtrl::m_nRegionKeyboardSize;
			m_nMinEndPixel = 0; 
			if(m_bNoteIsOn == true)
			{
				int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
				PlayNote(nLastNotePlayed, FALSE); // Note Off
				m_bNoteIsOn = false;
			}
			return;
		}

		// Clamp point
		point.x = point.x > m_nMaxEndPixel ? m_nMaxEndPixel : point.x;
		point.x = point.x < m_nMinEndPixel ? m_nMinEndPixel : point.x;

		if(m_nStartEnd == RK_END)
		{
			int nIndex = GetKeyIndexFromPoint(point); 
			nIndex = nIndex < 0 ? 0 : nIndex;
			nIndex = nIndex > 127 ? 127 : nIndex;

			// We don't want to let the user overlap regions in the same layer
			if(m_pDraggedRegion && CheckForCollision(m_pDraggedRegion, m_pDraggedRegion->GetLayer(), m_pDraggedRegion->GetStartNote(), nIndex))
			{
				ReleaseCapture();
				m_bHasCapture = false;
				SetNormalCursor();
				if(m_bNoteIsOn == true)
				{
					int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
					PlayNote(nLastNotePlayed, FALSE); // Note Off
					m_bNoteIsOn = false;
				}
				return;
			}

			if(m_pDraggedRegion)
				m_pDraggedRegion->SetEndNote(nIndex);

			InvalidateControl();			
		}
		
		if(m_nStartEnd & RK_START)
		{
			int nIndex = GetKeyIndexFromPoint(point);
			nIndex = nIndex < 0 ? 0 : nIndex;

			// We don't want to let the user overlap regions in the same layer
			if(m_pDraggedRegion &&  CheckForCollision(m_pDraggedRegion, m_pDraggedRegion->GetLayer(), nIndex, m_pDraggedRegion->GetEndNote()))
			{
				ReleaseCapture();
				m_bHasCapture = false;
				SetNormalCursor();
				if(m_bNoteIsOn == true)
				{
					int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
					PlayNote(nLastNotePlayed, FALSE); // Note Off
					m_bNoteIsOn = false;
				}

				return;
			}

			if(m_pDraggedRegion)
				m_pDraggedRegion->SetStartNote(nIndex);

			InvalidateControl();			
		}

		if(m_nStartEnd & RK_MOVE)
		{
			m_bHasCapture = false;
			SetMoveCursor(false);
		}

		if(m_nStartEnd & RK_COPY)
		{
			 CopySelectedRegionAtPoint(point);
			 InvalidateControl();
		}

		m_nStartEnd = RK_NULL;
		m_nMaxEndPixel = CRegionKeyboardCtrl::m_nRegionKeyboardSize;
		m_nMinEndPixel = 0; 
	} 

	if(m_bNoteIsOn == true)
	{
		int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
		PlayNote(nLastNotePlayed, FALSE); // Note Off
		ReleaseCapture();
	}
	m_bNoteIsOn = false;
}

void CRegionKeyboardCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	// If we don't have the capture then just show the required cursors when the mouse moves
	if(m_bHasCapture == false)
	{
		CRegion* pRegion = GetRegionForPoint(point, false);
		if(pRegion == NULL)
		{
			SetNormalCursor();
		}
		else if(pRegion->IsPointOnStartBoundary(point)) 
		{
			SetSizeCursor(true, true);
		}
		else if(pRegion->IsPointOnEndBoundary(point)) 
		{
			SetSizeCursor(true, false);
		}
		else
		{
			SetMoveCursor(true);
		}
	} 

	if(m_bHasCapture)
	{
		// If we don't have a region to drag then how the hell did we get the capture??
		// Anyway let's make it right then....
		if(m_pDraggedRegion == NULL)
		{
			ReleaseCapture();
			m_bHasCapture = false;
			return;
		}

		// Index of the key hit on the keyboard
		int nIndex = GetKeyIndexFromPoint(point);
		nIndex = nIndex < 0 ? 0 : nIndex;
		nIndex = nIndex > 127 ? 127 : nIndex;

		 // It's the closest region in the direction you're trying to resize the region
		CRegion* pClosestRegion = NULL;
		
		// If we're moving the start note AND the index for moving is on the left side AND 
		// there IS a colliding region (maybe NULL) BUT it's not the dragged region * WHEW *
		// MUST be a better way of doing this but at this hour I like this a lot!!
		if((m_nStartEnd & RK_START) && nIndex <= m_pDraggedRegion->GetStartNote() && IsMemberOfRegion(nIndex) != m_pDraggedRegion)
		{
			// Get the region before the dragged region
			pClosestRegion = GetRegionBeforeStartNote(m_pDraggedRegion);

			// If there's a closest region then get a possible valid index  
			if(pClosestRegion)
			{
				int nPossibleValidIndex = pClosestRegion->GetEndNote() + 1;

				// If there wasn't a colliding region the see which index is better for us
				if(IsMemberOfRegion(nIndex) || (IsMemberOfRegion(nIndex) == NULL && nIndex < nPossibleValidIndex))
				{
					nIndex =  nPossibleValidIndex;
				}
			}
			else if(nIndex < 0)
			{
				nIndex = 0;
			}
		}
		// See if we're past the end note and if yes the do the needful
		if((m_nStartEnd & RK_START) && nIndex > m_pDraggedRegion->GetEndNote())
		{
			m_nStartEnd = RK_END;
			SetSizeCursor(true, false);
		}

		if((m_nStartEnd & RK_END) && nIndex >= m_pDraggedRegion->GetEndNote() && IsMemberOfRegion(nIndex) != m_pDraggedRegion)
		{
			pClosestRegion = GetRegionAfterEndNote(m_pDraggedRegion);
			if(pClosestRegion)
			{
				int nPossibleValidIndex = pClosestRegion->GetStartNote() - 1;
				if(IsMemberOfRegion(nIndex) || (IsMemberOfRegion(nIndex) == NULL && nIndex > nPossibleValidIndex))
				{
					nIndex =  nPossibleValidIndex;
				}
			}
			else if(nIndex > 127)
			{
				nIndex = 127;
			}
		}
		
		if((m_nStartEnd & RK_END) && nIndex < m_pDraggedRegion->GetStartNote())
		{
			m_nStartEnd = RK_START;
			SetSizeCursor(true, true);
		}


		// Now do the actual resizing if 
		if((m_nStartEnd & RK_END) && m_bEndCursorSet
			&& !CheckForCollision(m_pDraggedRegion, m_pDraggedRegion->GetLayer(), m_pDraggedRegion->GetStartNote(), nIndex) 
			&& nIndex != m_pDraggedRegion->GetEndNote())
		{
			// Turn off any notes 
			if(m_bNoteIsOn == true)
			{
				int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
				PlayNote(nLastNotePlayed, FALSE); // Note Off
				m_bNoteIsOn = false;
			}

			m_pDraggedRegion->SetEndNote(nIndex);
			FireRangeChanged(m_pDraggedRegion->GetLayer(), m_pDraggedRegion->GetStartNote(), m_pDraggedRegion->GetEndNote());
			SetFocus();
			m_nStartEnd = RK_END;
		}

		if((m_nStartEnd & RK_START) && m_bStartCursorSet
			&& !CheckForCollision(m_pDraggedRegion, m_pDraggedRegion->GetLayer(), nIndex, m_pDraggedRegion->GetEndNote())
			&& nIndex != m_pDraggedRegion->GetStartNote())
		{
			// Turn off any notes 
			if(m_bNoteIsOn == true)
			{
				int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
				PlayNote(nLastNotePlayed, FALSE); // Note Off
				m_bNoteIsOn = false;
			}

			m_pDraggedRegion->SetStartNote(nIndex);
			FireRangeChanged(m_pDraggedRegion->GetLayer(), m_pDraggedRegion->GetStartNote(), m_pDraggedRegion->GetEndNote());
			SetFocus();
			m_nStartEnd = RK_START;
		}

		if((m_nStartEnd & RK_MOVE))
		{
			int nMovedStartNote = nIndex - m_nDraggedKey;
			nMovedStartNote = (nMovedStartNote < 0) ? 0 : nMovedStartNote;
			
			int nMovedEndNote = nMovedStartNote + (m_pDraggedRegion->GetEndNote() - m_pDraggedRegion->GetStartNote());
			nMovedEndNote = (nMovedEndNote > 127) ? 127 : nMovedEndNote;
			
			nMovedStartNote = nMovedEndNote - (m_pDraggedRegion->GetEndNote() - m_pDraggedRegion->GetStartNote());
			
			int nMovedLayer = GetAbsoluteLayerFromPoint(point);
			int nOldLayer = m_pDraggedRegion->GetLayer();
			int nOldStartNote = m_pDraggedRegion->GetStartNote();
			
			if(nMovedLayer > m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS - 1)
			{
				FireScrollLayers(TRUE);
				return;
			}
			else if(nMovedLayer < m_nFirstVisibleLayer)
			{
				FireScrollLayers(FALSE);
				return;
			}
	
			if(nOldLayer != nMovedLayer || nOldStartNote != nMovedStartNote)
			{
				if(nMovedLayer < m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS 
					&& nMovedLayer >= m_nFirstVisibleLayer 
					&& nMovedStartNote >= 0 && nMovedEndNote <= 127
					&& !CheckForCollision(m_pDraggedRegion, nMovedLayer, nMovedStartNote, nMovedEndNote))
				{
					// Turn off any notes 
					if(m_bNoteIsOn == true)
					{
						int nLastNotePlayed = GetNotePlayed(m_ptLastNote);
						PlayNote(nLastNotePlayed, FALSE); // Note Off
						m_bNoteIsOn = false;
					}

					FireRegionMoved(nOldLayer, nOldStartNote, nMovedLayer, nMovedStartNote, nMovedEndNote);
					SetFocus();

					m_pDraggedRegion->SetNoteRange(nMovedStartNote, nMovedEndNote);
					m_pDraggedRegion->SetLayer(nMovedLayer);
					m_nActiveLayer = nMovedLayer;
				}
			}

			SelectRegion(m_pDraggedRegion->GetLayer(), m_pDraggedRegion->GetStartNote());
			UpdateRegionRect();
		}
		if(m_nStartEnd & RK_COPY)
		{
			int nStartIndex = nIndex - m_nDraggedKey;
			//nStartIndex = (nStartIndex < 0) ? 0 : nStartIndex;

			int nEndIndex = nStartIndex + (m_pDraggedRegion->GetEndNote() - m_pDraggedRegion->GetStartNote());
			//nEndIndex = nEndIndex > 127 ? 127 : nEndIndex;

			nStartIndex = nEndIndex - (m_pDraggedRegion->GetEndNote() - m_pDraggedRegion->GetStartNote());

			int nCopyLayer = GetLayerFromPoint(point);
			if(nStartIndex >= 0 && nEndIndex <= 127 && !CheckForCollision(m_pDraggedRegion, nCopyLayer, nStartIndex, nEndIndex, true) && nEndIndex <= 127)
			{
				SetCopyCursor(true);
			}
			else
			{
				SetNoDoCursor(true);
			}

			DrawGhostRect(m_pDraggedRegion, m_ptLButtonDown, point);
		}
	}
}


int CRegionKeyboardCtrl::GetKeyIndexFromPoint(CPoint point)
{
	//TODO: replace 56 with PAGE_SIZE_PIXELS
	int nNumOctaves = (point.x + m_nKeyboardOffset) / 56; 
	int nNearestOctaveOffset = (point.x + m_nKeyboardOffset) % 56;
	int key = 0;
	// Find key within Octave which contains nNearestOctaveOffset
	for(; key < 12 && nNearestOctaveOffset >= m_nKeyPos[key]; key++);
	
	// Index of the key hit on the keyboard
	return nNumOctaves * 12 + (key - 1); 
}

void CRegionKeyboardCtrl::DrawKeyboard(CDC* pDC, const CRect& rcBounds)
{
	ASSERT(pDC);

	CRect windowRect;
	CRect clientRect;

	BOOL bDCStatus;
	CDC bitmapDC;
	CDC regionsDC;

	bDCStatus = regionsDC.CreateCompatibleDC(pDC);		
	CBitmap* pOldRDCBM = regionsDC.SelectObject(&m_bmBlank128);

	BITMAP bmInfoR;
	int nStatus =  m_bmBlank128.GetBitmap(&bmInfoR);
	CRect rect(0, 0, bmInfoR.bmWidth, bmInfoR.bmHeight);
	m_RegionsRect = rect;
	
	regionsDC.FillSolidRect(&rect, ::GetSysColor(COLOR_WINDOW));
	DrawLayersOnRegionBitmap(&regionsDC, rect);
	
	DrawRegionRects(&regionsDC);
		
	bDCStatus = bitmapDC.CreateCompatibleDC(pDC);
	CBitmap* pOldBDCBM = bitmapDC.SelectObject(&m_bmKeyBoard128);
	BITMAP bmInfoKB;
	nStatus =  m_bmKeyBoard128.GetBitmap(&bmInfoKB);

	// color the background not covered by regions and keyboard
	CRect rcDiff;
	rect.SetRect(0, 0, bmInfoR.bmWidth, REGION_LAYER_AREA_HEIGHT+bmInfoKB.bmHeight);
	rcDiff.SubtractRect(rcBounds, rect);
	pDC->FillSolidRect(&rcDiff, ::GetSysColor(COLOR_BTNFACE));
	
	BOOL bStatus = pDC->BitBlt(0, REGION_LAYER_AREA_HEIGHT, bmInfoKB.bmWidth, bmInfoKB.bmHeight, &bitmapDC, m_nKeyboardOffset, 0, SRCCOPY);

    // Draw the circle denoting rootnote on the memory dc.
    DrawRootNote(pDC);
	
	bStatus = pDC->BitBlt(0,0, bmInfoR.bmWidth, REGION_LAYER_AREA_HEIGHT, &regionsDC, m_nKeyboardOffset, 0, SRCCOPY);

	if((m_nStartEnd & RK_COPY) && m_bHasCapture == true)
	{
		CPoint pt1, pt2;
		DrawGhostRect(NULL, pt1, pt2);
	}
	
	regionsDC.SelectObject(pOldRDCBM); 
	bitmapDC.SelectObject(pOldBDCBM); 
	
	bDCStatus = regionsDC.DeleteDC();
	bDCStatus = bitmapDC.DeleteDC();
}

// This draws the default number of layers in gray
void CRegionKeyboardCtrl::DrawLayersOnRegionBitmap(CDC* pDC, CRect& regionRect)
{
	ASSERT(pDC);

	regionRect.NormalizeRect();

	// Create and select the gray pen into the device context
	DWORD dwGrayColor = ::GetSysColor(COLOR_HIGHLIGHT);
	CPen grayPen(PS_DOT, 1, dwGrayColor);  
	CPen* pOldPen = pDC->SelectObject(&grayPen);
	
	int nLayerIndex = 0;
	
	while(nLayerIndex < NUMBER_OF_VISIBLE_LAYERS)
	{
		pDC->MoveTo(0, (nLayerIndex + 1) * REGION_LAYER_HEIGHT);
		pDC->LineTo(regionRect.Width(), (nLayerIndex + 1) * REGION_LAYER_HEIGHT);

		nLayerIndex++;
	}

	// Highlight the selected layer
	if(m_nActiveLayer != -1 && (m_nActiveLayer < m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS && m_nActiveLayer >= m_nFirstVisibleLayer))
	{
		pDC->FillSolidRect(0, (REGION_LAYER_AREA_HEIGHT - ((m_nActiveLayer - m_nFirstVisibleLayer + 1) * REGION_LAYER_HEIGHT - 1)), regionRect.Width(), REGION_LAYER_HEIGHT - 1, COLOR_ACTIVE_LAYER);
	}

	// Select the old pen back into the device context
	if(pOldPen)
		pDC->SelectObject(pOldPen);
}

void CRegionKeyboardCtrl::DrawRegionRects(CDC* pDC)
{
	int nCount = 0;
	int nStartPos = 0;
	int nEndPos = 0;
	
	ASSERT(pDC);

	// create label font if not already cached
	if (!m_bRegionFontCreated)
		{
		LOGFONT lf;
		memset(&lf, 0, sizeof(LOGFONT));
		lf.lfHeight = -(REGION_LAYER_HEIGHT-2);
		strcpy(lf.lfFaceName, "Arial");
		VERIFY(m_fnRegion.CreateFontIndirect(&lf));
 		m_bRegionFontCreated = true;
		}

	// set up for all Regions to draw
	CFont* pfnSav = pDC->SelectObject(&m_fnRegion);
	COLORREF crSav = pDC->GetBkColor();

	// loop over regions
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		pRegion->Draw(pDC, REGION_LAYER_AREA_HEIGHT, m_nFirstVisibleLayer);
	}

	// cleanup
	pDC->SetBkColor(crSav);
	if (pfnSav)
		pDC->SelectObject(pfnSav);
}

void CRegionKeyboardCtrl::SetNormalCursor()
{
	if(m_bStartCursorSet || m_bEndCursorSet)
		SetSizeCursor(false, false);
	if(m_bMoveCursorSet)
		SetMoveCursor(false);
	if(m_bCopyCursorSet)
		SetCopyCursor(false);
	if(m_bNoDoCursorSet)
		SetNoDoCursor(false);
}

void CRegionKeyboardCtrl::SetNoDoCursor(bool bOn)
{
	if(bOn)
	{
		if(m_hNODOCursor)
		{
			m_bNoDoCursorSet = true;
			SetCursor(m_hNODOCursor);
		}
	}
	else
	{
		m_bNoDoCursorSet = false;
		SetCursor(m_hArrowCursor);
	}
}


		

void CRegionKeyboardCtrl::SetSizeCursor(bool bOn, bool bStart)
{
	if(bOn)
	{
		if(bStart)
		{
			m_bStartCursorSet = true;
			m_hSIZEWECursor = m_hStartEditCursor;
		}
		else
		{
			m_bEndCursorSet = true;
			m_hSIZEWECursor = m_hEndEditCursor;
		}


		SetCursor(m_hSIZEWECursor);
	}
	else
	{
		m_bStartCursorSet = false;
		m_bEndCursorSet = false;
		
		SetCursor(m_hArrowCursor);
	}
}

void CRegionKeyboardCtrl::SetMoveCursor(bool bOn)
{
	if(bOn)
	{
		if(m_hMOVECursor)
		{
			m_bMoveCursorSet = true;
			SetCursor(m_hMOVECursor);
		}
	}
	else
	{
		m_bMoveCursorSet = false;
		SetCursor(m_hArrowCursor);
	}
}

void CRegionKeyboardCtrl::SetCopyCursor(bool bOn)
{
	if(bOn)
	{
		if(m_hCOPYCursor)
		{
			m_bCopyCursorSet = true;
			SetCursor(m_hCOPYCursor);
		}
	}
	else
	{
		m_bCopyCursorSet = false;
		SetCursor(m_hArrowCursor);
	}
}



void CRegionKeyboardCtrl::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	InvalidateControl();

	COleControl::OnKillFocus(pNewWnd);
}

void CRegionKeyboardCtrl::InitializeKeyBoard(LPUNKNOWN RegionMap)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	ASSERT(RegionMap);

	InvalidateControl();
}


void CRegionKeyboardCtrl::DeleteAllRegions()
{
	CRegion* pRegion;
	while(m_lstRegions.IsEmpty() == FALSE)
	{
		pRegion = m_lstRegions.RemoveHead();
		delete pRegion;
	}
}

void CRegionKeyboardCtrl::SetCurrentRegion(short nLayer, short nStartNote) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	SelectRegion(nLayer, nStartNote);

	InvalidateControl();
}


// ===========================================================================
// DrawRootNote
//  Draws a circle on the dc passed in to denote that this key is a rootnote.
// ===========================================================================
void CRegionKeyboardCtrl::DrawRootNote(CDC* pdc)
{
    ASSERT(pdc);
    int nKey;

	nKey = GetRootNoteFromActiveRegion();

    if (nKey == 128)
    {
        //ASSERT(false);  // The rootnote has not been set! This is an error.
        return;			// Actually for a new collection without a wave it should be OK
    }					// We will have to be alert for other problems associated
						// with no wave/root note.

    // Get which octave this is in.
    int nOctave = nKey/12;
    nKey = nKey % 12;   // which key in the octave.

    int nXOffset = nOctave * 56;

    // draw the circle.
    int x1, y1;
    if (m_nRadius[nKey] == 1)   // it's a black key. Draw a white circle.
    {
        CBrush * pOldBrush = pdc->SelectObject(CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));      
        if (pOldBrush)
        {
            x1 = nXOffset + m_nKeyPos[nKey] - m_nKeyboardOffset; 
            y1 = REGION_LAYER_AREA_HEIGHT + 12; // 12 is about 4 lower than center of black keys
            pdc->Ellipse(x1+1, y1,
                        x1 + 5, // Width of 5 works better to draw a white circle.
                        y1 + 5  // Use 5 so that ht = width.
                        );
            pdc->SelectObject(pOldBrush);
        }
    }
    else    //it's a white key. Draw a black circle.
    {
        CBrush * pOldBrush = pdc->SelectObject(CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));        
        if (pOldBrush)
        {
            x1 = nXOffset + m_nKeyCenter[nKey] - 2 - m_nKeyboardOffset; // 2 is arbitrary - for aesthetic reasons.
            y1 = REGION_LAYER_AREA_HEIGHT + 24, //y1 24 is the height at which we draw for white keys

            pdc->Ellipse(x1, y1, 
                         x1 + 4, // we want a dia of 4 for the circle.
                         y1 + 4  //since radius is 2. Dia = 4
                         );

            pdc->SelectObject(pOldBrush);
        }
    }

	// Redraw the MIDI note that was on before the invalidate came in...if it's still on that is...
	for(int nIndex = 0; nIndex < 128; nIndex++)
	{
		if(m_nLastMidiNoteOn[nIndex] == 1)
		{
			MidiEvent(nIndex, MIDI_NOTEON, 0);
		}
	}
}

void CRegionKeyboardCtrl::MidiEvent(short nMidiNote, short nNoteFlag, short nVelocity) 
{
	CClientDC		dcClient(this);
    int				nKey;
	CBrush*			pOldBrush = NULL;
	CBrush			cRedBrush;
	CPen			cRedWhitePen;
	CPen*			pOldPen = NULL;

	if(nNoteFlag == MIDI_NOTEON)
	{
		m_nLastMidiNoteOn[nMidiNote] = 1;
	}
	else
	{
		m_nLastMidiNoteOn[nMidiNote] = 0;
	}


    // Get which octave this is in.
    int nOctave = nMidiNote/12;
    nKey = nMidiNote % 12;   // which key in the octave.

    int nXOffset = nOctave * 56;

    // draw the circle.
    int x1, y1;
    if (m_nRadius[nKey] == 1)   // it's a black key. Draw a red circle.
    {
		if (nNoteFlag == MIDI_NOTEON)
		{
			cRedBrush.CreateSolidBrush(COLOR_LAYER_SELECT);
			pOldBrush = dcClient.SelectObject(&cRedBrush);
		}
		else if (nNoteFlag == MIDI_NOTEOFF)
		{
			int nRootKey = GetRootNoteFromActiveRegion();
			if((nOctave*12 + nKey) != nRootKey)
				pOldBrush = dcClient.SelectObject(CBrush::FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)));
			else
				pOldBrush = dcClient.SelectObject(CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));

		}
        if (pOldBrush)
        {
            x1 = nXOffset + m_nKeyPos[nKey] - m_nKeyboardOffset; 
            y1 = REGION_LAYER_AREA_HEIGHT + 12; // 12 is about 4 lower than center of black keys
            dcClient.Ellipse(x1+1, y1,
                        x1 + 5, // Width of 5 works better to draw a white circle.
                        y1 + 5  // Use 5 so that ht = width.
                        );
            dcClient.SelectObject(pOldBrush);
        }
    }
    else    //it's a white key. Draw a red circle.
    {
		if (nNoteFlag == MIDI_NOTEON)
		{
			cRedBrush.CreateSolidBrush(COLOR_LAYER_SELECT);
			cRedWhitePen.CreatePen(PS_SOLID, 0, COLOR_LAYER_SELECT);
			pOldBrush = dcClient.SelectObject(&cRedBrush);
			pOldPen = dcClient.SelectObject(&cRedWhitePen);
			if (pOldBrush)
			{
				x1 = nXOffset + m_nKeyCenter[nKey] - 2 - m_nKeyboardOffset; // 2 is arbitrary - for aesthetic reasons.
				y1 = REGION_LAYER_AREA_HEIGHT + 24, //y1 24 is the height at which we draw for white keys

				dcClient.Ellipse(x1, y1, 
							 x1 + 4, // we want a dia of 4 for the circle.
							 y1 + 4  //since radius is 2. Dia = 4
							 );

				dcClient.SelectObject(pOldBrush);
				dcClient.SelectObject(pOldPen);
			}
		}
		else if (nNoteFlag == MIDI_NOTEOFF)
		{
			CRgn			crClipRgn;
			CRect			rcBounds;
			GetClientRect(&rcBounds);

			x1 = nXOffset + m_nKeyPos[nKey] - m_nKeyboardOffset;

			crClipRgn.CreateRectRgn(x1, 22, x1 + 6, REGION_LAYER_AREA_HEIGHT + 35);
			dcClient.SelectClipRgn(&crClipRgn);
			DrawKeyboard(&dcClient, rcBounds);
		}
    }

	CPtrList lstPlayingRegions;
	MarkPlayingRegions(nMidiNote, nNoteFlag, nVelocity, &lstPlayingRegions);
}


CRegion* CRegionKeyboardCtrl::IsMemberOfRegion(int nKey)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsNoteInRegion(m_nActiveLayer, nKey) == TRUE)
			return pRegion;
	}
	return NULL;
}

CRegion* CRegionKeyboardCtrl::GetRegionForPoint(CPoint point, bool bIgnoreY)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsPointInRegion(point, bIgnoreY) == TRUE)
		{
			// Check for the layer now
			int nLayer = pRegion->GetLayer();
			if(nLayer >= m_nFirstVisibleLayer && nLayer <= (m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS))
			{
				return pRegion;
			}
		}
	}
	return NULL;
}


// Gets a good layer to draw this region
int CRegionKeyboardCtrl::GetGoodLayer(CPoint point)
{
	return 0;
}

// Selects all regions containing this note
void CRegionKeyboardCtrl::SelectAllRegions(int nNote)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsNoteInRegion(nNote) == TRUE)
			pRegion->SetSelected(TRUE);
		else
			pRegion->SetSelected(FALSE);
	}
}

// Selects the region containing this point; Deselcts all other regions
void CRegionKeyboardCtrl::SelectRegion(CPoint point)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsPointInRegion(point) == TRUE)
		{
			pRegion->SetSelected(TRUE);
			m_pCurrentRegion = pRegion;
		}
		else
		{
			pRegion->SetSelected(FALSE);
		}
	}
}

// Layer and StartNote uniquely identify a region since there can be no overlap of regions in the same layer
void CRegionKeyboardCtrl::SelectRegion(int nLayer, int nStartNote)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsNoteInRegion(nLayer, nStartNote) == TRUE)
		{
			pRegion->SetSelected(TRUE);
			m_pCurrentRegion = pRegion;

			// Scroll to the layer if it's not visible
			m_nFirstVisibleLayer = nLayer < m_nFirstVisibleLayer ? nLayer : m_nFirstVisibleLayer;
			m_nFirstVisibleLayer = nLayer > (m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS) ? 1 + (nLayer - NUMBER_OF_VISIBLE_LAYERS) : m_nFirstVisibleLayer;
			
			m_nActiveLayer = nLayer;
		}
		else
		{
			pRegion->SetSelected(FALSE);
		}
	}
}

int CRegionKeyboardCtrl::GetRootNoteFromActiveRegion()
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsSelected())
			return pRegion->GetRootNote();
	}

	return 128;
}

void CRegionKeyboardCtrl::SetActiveLayer(CPoint point)
{
	int nActiveLayer = m_nFirstVisibleLayer + (REGION_LAYER_AREA_HEIGHT - point.y)/ REGION_LAYER_HEIGHT;

	if(nActiveLayer < 0)
	{
		//m_nActiveLayer = 0;
		return;
	}
	
	m_nActiveLayer = nActiveLayer;

	if(m_nActiveLayer >= m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS)
	{
		m_nActiveLayer = m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS - 1;
		return;
	}

	InvalidateRect(NULL);
	//UpdateRegionRect();

	FireActiveLayerChanged(m_nActiveLayer);
}

void CRegionKeyboardCtrl::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	ScrollLayers(nSBCode, nPos);
}


void CRegionKeyboardCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	switch(nChar)
	{
		/*case VK_INSERT:
		{
			m_nNumberOfLayers++;
			UpdateRegionRect();
			InvalidateControl();

			break;
		}*/
		case VK_DELETE:
		{
			if(m_pCurrentRegion)
			{
				FireRegionDeleted(m_pCurrentRegion->GetLayer(), m_pCurrentRegion->GetStartNote());
			}

			SetFocus();
			UpdateRegionRect();
			InvalidateControl();
			break;
		}
	}

}

// Adds a region, creates a new layer if necessary (if there's already a region containing some notes)
// Returns the layer in which this region was added...
int CRegionKeyboardCtrl::_InsertNewRegion(int nStartNote, int nEndNote)
{
	return _InsertNewRegion(m_nActiveLayer, nStartNote, nEndNote, "");
}

int CRegionKeyboardCtrl::_InsertNewRegion(int nLayer, int nStartNote, int nEndNote, LPCTSTR pszWaveName)
{
	if(nLayer < 0)
		nLayer = 0;

	int nInsertionLayer = nLayer;
	
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsOverlappingRegion(nInsertionLayer, nStartNote, nEndNote))
		{
			// We found a region in this layer that overlaps the region between the start and end notes
			// So try a different layer...
			// Start from the first region again...
			nInsertionLayer++;
			position = m_lstRegions.GetHeadPosition();
		}
	}

	// Add a new layer if need be...
	if(nInsertionLayer >= m_nNumberOfLayers)
		m_nNumberOfLayers = nInsertionLayer + 1;

	// Add the region to this layer
	CRegion* pNewRegion = new CRegion(nInsertionLayer, nStartNote, nEndNote); 
	pNewRegion->SetParentControl(this);
	pNewRegion->SetWaveName(pszWaveName);
	m_lstRegions.AddTail(pNewRegion);

	// Set the inserted layer as the currently active layer and visible layer 
	// redraw the regions too...
	if(nInsertionLayer > m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS || nInsertionLayer < m_nFirstVisibleLayer)
		m_nFirstVisibleLayer = nInsertionLayer;

	m_nActiveLayer = nInsertionLayer;
	m_pCurrentRegion = pNewRegion;
	
	UpdateRegionRect();

	return nInsertionLayer;
}


void CRegionKeyboardCtrl::UpdateRegionRect()
{
	CClientDC clientDC(this);
	DrawLayersOnRegionBitmap(&clientDC, m_RegionsRect);
	DrawRegionRects(&clientDC);
}

// Sets the root note for the current region
void CRegionKeyboardCtrl::SetRootNote(short nNote)
{
	ASSERT(m_pCurrentRegion);

	m_pCurrentRegion->SetRootNote(nNote);
	InvalidateControl();
}

BOOL CRegionKeyboardCtrl::SetRange(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity)
{
	ASSERT(m_pCurrentRegion);
	if(m_pCurrentRegion == NULL)
		return FALSE;

	if(nStartNote > nEndNote)
		return FALSE;
	if(nStartVelocity > nEndVelocity)
		return FALSE;

	if(CheckForCollision(m_pCurrentRegion, m_pCurrentRegion->GetLayer(), nStartNote, nEndNote))
		return FALSE;

	m_pCurrentRegion->SetNoteRange(nStartNote, nEndNote);
	m_pCurrentRegion->SetVelocityRange(nStartVelocity, nEndVelocity);

	UpdateRegionRect();

	return TRUE;
}


// Returns the colliding region for this layer and range 
// bCheckSelfCollision = false allows you to look for a colliding region that is NOT the current layer
// If bCheckSelfCollision == true; then it'll return a valid pointer for self collision 
// This is used in the region CTRL+Drag->Copy functionality where you shouldn't be able to copy regions over itself!
CRegion* CRegionKeyboardCtrl::CheckForCollision(CRegion* pCheckedRegion, int nLayer, int nStartNote,int nEndNote, bool bCheckSelfCollision)
{
	ASSERT(pCheckedRegion);
	if(m_pCurrentRegion == NULL)
	{
		return NULL;
	}

	CRegion* pRegion  = NULL;
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsOverlappingRegion(nLayer, nStartNote, nEndNote))
		{
			if(bCheckSelfCollision) 
				return pRegion;
			else if(pRegion != pCheckedRegion)
				return pRegion;
		}
			
	}

	return NULL;
}


short CRegionKeyboardCtrl::InsertNewRegion(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity) 
{
	return _InsertNewRegion(nStartNote, nEndNote);
}


short CRegionKeyboardCtrl::InsertRegion(short nLayer, short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity, LPCTSTR pszWaveName)
{
	return _InsertNewRegion(nLayer, nStartNote, nEndNote, pszWaveName);
}

void CRegionKeyboardCtrl::DeleteRegion(short nLayer, short nStartNote) 
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		POSITION deletePosition = position; 
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->GetLayer() == nLayer && nStartNote == pRegion->GetStartNote())
		{
			pRegion = m_lstRegions.GetAt(deletePosition);
			m_lstRegions.RemoveAt(deletePosition);
			delete pRegion;
			pRegion = NULL;
			break;
		}
	}
	
	UpdateRegionRect();
}


int CRegionKeyboardCtrl::GetLayerFromPoint(CPoint point)
{
	int nLayer = m_nFirstVisibleLayer + (REGION_LAYER_AREA_HEIGHT - point.y)/ REGION_LAYER_HEIGHT;
	if(nLayer > 0 && nLayer < m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS)
	{
		return nLayer;
	}
	else if(nLayer >= m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS)
	{
		return m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS - 1;
	}
	else
	{
		return 0; // Can't have negative layers
	}
}

int CRegionKeyboardCtrl::GetAbsoluteLayerFromPoint(CPoint point)
{
	// Doen't massage the data
	int nLayer = m_nFirstVisibleLayer + (REGION_LAYER_AREA_HEIGHT - point.y)/ REGION_LAYER_HEIGHT;
	return nLayer;
}


int CRegionKeyboardCtrl::GetActiveLayer()
{
	return m_nActiveLayer;
}

// Assumption is that we're copying the m_pCurrentRegion...
// Used by the Ctrl + Drag -> Copy functionality
void CRegionKeyboardCtrl::CopySelectedRegionAtPoint(CPoint point)
{
	ASSERT(m_pCurrentRegion);
	if(m_pCurrentRegion == NULL)
	{
		return;
	}

	int nCopyLayer = GetLayerFromPoint(point);
	int nStartIndex = GetKeyIndexFromPoint(point) - m_nDraggedKey;
	nStartIndex = nStartIndex < 0 ? 0 : nStartIndex;
	int nEndIndex = nStartIndex;

	m_bHasCapture = false;
	SetCopyCursor(false);

	if(m_pCurrentRegion)
	{
		nEndIndex = nStartIndex + (m_pCurrentRegion->GetEndNote() - m_pCurrentRegion->GetStartNote());
		nEndIndex = nEndIndex > 127 ? 127 : nEndIndex;
	}

	if(!CheckForCollision(m_pCurrentRegion, nCopyLayer, nStartIndex, nEndIndex, true) && nEndIndex <= 127)
	{
		CRegion* pNewRegion = new CRegion(nCopyLayer, nStartIndex, nEndIndex); 
		if(pNewRegion == NULL)
		{
			return;
		}

		pNewRegion->SetParentControl(this);
		m_lstRegions.AddTail(pNewRegion);

		int nSourceLayer = m_pCurrentRegion->GetLayer();
		int nSourceStartNote = m_pCurrentRegion->GetStartNote();

		FireCopyRegion(nSourceLayer, nSourceStartNote, nCopyLayer, pNewRegion->GetStartNote());

		// Set the new Region as currently selected
		//SetCurrentRegion(nCopyLayer, pNewRegion->GetStartNote());
	
		CClientDC clientDC(this);
		DrawRegionRects(&clientDC);
	}
}


CRegion* CRegionKeyboardCtrl::GetRegionBeforeStartNote(CRegion* pRegion)
{
	int nStartNote = pRegion->GetStartNote();
	int nIndex = nStartNote;
	CRegion* pCollidingRegion = NULL;
	
	while(nIndex >= 0)
	{
		pCollidingRegion = IsMemberOfRegion(nIndex);
		if(pCollidingRegion && pCollidingRegion != pRegion)
			break;
		nIndex--;
	}

	if(nIndex <= 0)
		return NULL;
	else
		return pCollidingRegion;
}

CRegion* CRegionKeyboardCtrl::GetRegionAfterEndNote(CRegion* pRegion)
{
	int nEndNote = pRegion->GetEndNote();
	int nIndex = nEndNote;
	CRegion* pCollidingRegion = NULL;
	
	while(nIndex <= 127)
	{
		pCollidingRegion = IsMemberOfRegion(nIndex);
		if(pCollidingRegion && pCollidingRegion != pRegion)
			break;
		nIndex++;
	}

	if(nIndex >= 127)
		return NULL;
	else
		return pCollidingRegion;
}

void CRegionKeyboardCtrl::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	SetActiveLayer(point);

	// Index of the key hit on the keyboard
	int nIndex = GetKeyIndexFromPoint(point);
	nIndex = nIndex < 0 ? 0 : nIndex;
	nIndex = nIndex > 127 ? 127 : nIndex;

	CRegion* pRegion = GetRegionForPoint(point, false);
	if(pRegion && pRegion->IsSelected() == FALSE)
	{
		pRegion->SetSelected(true);
		m_pCurrentRegion = pRegion;
		FireRegionSelectedChanged(m_pCurrentRegion->GetLayer(), m_pCurrentRegion->GetStartNote());
		SetFocus();
		CClientDC clientDC(this);
		DrawRegionRects(&clientDC);
	}
	
	COleControl::OnRButtonDown(nFlags, point);
}

void CRegionKeyboardCtrl::ReleaseMouseCapture() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	ReleaseCapture();
	m_bHasCapture = false;
	SetNormalCursor();
}

void CRegionKeyboardCtrl::TurnOffMidiNotes()
{
	bool bInvalidate = false;
	// Redraw the keyboard with all notes marked as off
	for(int nIndex = 0; nIndex < 128; nIndex++)
	{
		if(m_nLastMidiNoteOn[nIndex] == 1)
		{
			bInvalidate = true;
			m_nLastMidiNoteOn[nIndex] = 0;
		}
	}

	if(bInvalidate)
		InvalidateControl();
}


void CRegionKeyboardCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	COleControl::OnSetFocus(pOldWnd);
	
	InvalidateControl();
}

short CRegionKeyboardCtrl::SetCurrentLayer(short nLayer) 
{
	m_nActiveLayer = SetFirstVisibleLayer(nLayer);
	return m_nActiveLayer;
}

short CRegionKeyboardCtrl::SetFirstVisibleLayer(short nLayer) 
{
	if(nLayer == -1)
	{
		return m_nFirstVisibleLayer++;
	}

	if(nLayer >= m_nNumberOfLayers)
	{
		nLayer = m_nNumberOfLayers - 1;
	}

	if((nLayer + 4) < m_nNumberOfLayers)
	{
		m_nFirstVisibleLayer = nLayer;
	}
	else
	{
		m_nFirstVisibleLayer = m_nNumberOfLayers - abs(m_nNumberOfLayers - nLayer);
	}

	return m_nFirstVisibleLayer;
}

short CRegionKeyboardCtrl::ScrollLayers(short nSBCode, short nCurPos) 
{
	switch(nSBCode)
	{
		case SB_LINEDOWN:
		{
			if(m_nFirstVisibleLayer > 0)
			{
				m_nFirstVisibleLayer--;
			}
			break;
		}

		case SB_LINEUP:
		{
			if((m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS) < m_nNumberOfLayers)
			{
				m_nFirstVisibleLayer++;
			}
			break;
		}

		case SB_PAGEDOWN:
		{
			m_nFirstVisibleLayer = (m_nFirstVisibleLayer - NUMBER_OF_VISIBLE_LAYERS);
			m_nFirstVisibleLayer = m_nFirstVisibleLayer < 0 ? 0 : m_nFirstVisibleLayer;
			break;
		}

		case SB_PAGEUP:
		{
			m_nFirstVisibleLayer = (m_nFirstVisibleLayer + NUMBER_OF_VISIBLE_LAYERS);
			m_nFirstVisibleLayer = m_nFirstVisibleLayer > (m_nNumberOfLayers - NUMBER_OF_VISIBLE_LAYERS) ? (m_nNumberOfLayers - NUMBER_OF_VISIBLE_LAYERS) - 1 : m_nFirstVisibleLayer;
			break;
		}

		case SB_TOP:
		{
			m_nFirstVisibleLayer = m_nNumberOfLayers - NUMBER_OF_VISIBLE_LAYERS;
			break;
		}

		case SB_BOTTOM:
		{
			m_nFirstVisibleLayer = 0;
			break;
		}

		case SB_THUMBTRACK:
		{
			if(nCurPos < m_nNumberOfLayers && nCurPos >= 0)
			{
				m_nFirstVisibleLayer = (m_nNumberOfLayers - (nCurPos + 3));
			}
			break;
		}
	}
	
	m_nFirstVisibleLayer = m_nFirstVisibleLayer < 0 ? 0 : m_nFirstVisibleLayer;
	InvalidateRect(NULL);

	return m_nFirstVisibleLayer;
}

short CRegionKeyboardCtrl::GetNumberOfLayers() 
{
	return m_nNumberOfLayers;
}

short CRegionKeyboardCtrl::GetFirstVisibleLayer() 
{
	return m_nFirstVisibleLayer;
}

short CRegionKeyboardCtrl::AddNewLayer() 
{
	m_nNumberOfLayers++;
	
	// Bump up the regions
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		ASSERT(pRegion);
		if(pRegion)
		{
			USHORT usLayer = pRegion->GetLayer();
			if(usLayer >= m_nActiveLayer)
			{
				pRegion->SetLayer(usLayer + 1);
			}
		}
	}

	UpdateRegionRect();
	InvalidateControl();

	return m_nNumberOfLayers;
}

short CRegionKeyboardCtrl::DeleteActiveLayer() 
{
	if(m_nNumberOfLayers > NUMBER_OF_VISIBLE_LAYERS)
	{
		m_nNumberOfLayers--;
	}

	// Bump up the regions
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		ASSERT(pRegion);
		if(pRegion)
		{
			USHORT usLayer = pRegion->GetLayer();
			if(usLayer >= m_nActiveLayer)
			{
				pRegion->SetLayer(usLayer -  1);
			}
		}
	}


	SetFocus();
	UpdateRegionRect();
	InvalidateControl();

	return m_nNumberOfLayers;
}

void CRegionKeyboardCtrl::SetAuditionMode(BOOL bAuditionMode) 
{
	m_bAuditionMode = bAuditionMode;
}

void CRegionKeyboardCtrl::MarkPlayingRegions(short nNote, short nNoteFlag, short nVelocity, CPtrList* plstPlayingRegions)
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		ASSERT(pRegion);
		BOOL bRegionIsPlaying = FALSE;
		if(m_bAuditionMode == AUDITION_MULTIPLE)
		{
			bRegionIsPlaying = pRegion->IsNoteInRegion(m_nActiveLayer, nNote, nVelocity, true);
		}
		else if(m_bAuditionMode == AUDITION_SOLO)
		{
			bRegionIsPlaying = pRegion->IsNoteInRegion(m_nActiveLayer, nNote, nVelocity, false);
		}

		if(bRegionIsPlaying == TRUE)
		{
			if(nNoteFlag == MIDI_NOTEON)
			{
				pRegion->SetPlayState(TRUE);
				if(plstPlayingRegions)
				{
					plstPlayingRegions->AddTail(pRegion);
				}
			}
			else
			{
				pRegion->SetPlayState(FALSE);
			}
		}
	}

	CClientDC clientDC(this);
	DrawLayersOnRegionBitmap(&clientDC, m_RegionsRect);
	DrawRegionRects(&clientDC);
}

void CRegionKeyboardCtrl::EnableRegion(short nLayer, short nStartNote, BOOL bEnable) 
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsNoteInRegion(nLayer, nStartNote) == TRUE)
		{
			pRegion->Enable(bEnable);
		}
	}
}

void CRegionKeyboardCtrl::SetNumberOfLayers(short nLayers) 
{
	ASSERT(nLayers >= NUMBER_OF_VISIBLE_LAYERS);
	if(nLayers < NUMBER_OF_VISIBLE_LAYERS)
	{
		nLayers = NUMBER_OF_VISIBLE_LAYERS;
	}

	m_nNumberOfLayers = nLayers;
}

void CRegionKeyboardCtrl::DrawGhostRect(CRegion* pRegion, CPoint ptPeg, CPoint ptDrag)
{
	CRect ghostRect;
	if(pRegion == NULL)
	{
		ghostRect = m_lastGhostRect;
	}
	else
	{
		InvalidateRect(&m_lastGhostRect);

		CRect regionRect = pRegion->GetRect();
		int regionWidth = regionRect.Width();
		int regionHeight = regionRect.Height();
		int nXOffset = ptPeg.x - regionRect.left;
		int nGhostLeft = ptDrag.x - nXOffset;
		int nGhostTop = ptDrag.y - (regionHeight / 2);
		ghostRect.SetRect(nGhostLeft, nGhostTop, nGhostLeft + regionWidth, nGhostTop + regionHeight);
	}

	
	CPen dotPen(PS_DOT, 1, RGB(0, 0, 0));
	CClientDC clientDC(this);
	CPen* pOldPen = clientDC.SelectObject(&dotPen);
	clientDC.Rectangle(&ghostRect);
	if(pOldPen)
	{
		clientDC.SelectObject(pOldPen);
	} 
	
	CBrush hatchBrush(HS_BDIAGONAL, RGB(64, 64, 64));
	CRect hatchRect = ghostRect;
	hatchRect.DeflateRect(1, 1, 1, 1);
	clientDC.FillRect(&hatchRect, &hatchBrush);
	m_lastGhostRect = ghostRect;
}

void CRegionKeyboardCtrl::SetWaveName(short nLayer, short nStartNote, LPCTSTR pszWaveName) 
{
	POSITION position = m_lstRegions.GetHeadPosition();
	while(position)
	{
		CRegion* pRegion = m_lstRegions.GetNext(position);
		if(pRegion->IsNoteInRegion(nLayer, nStartNote) == TRUE)
		{
			pRegion->SetWaveName(pszWaveName);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionKeyboardPpg.h ===
#if !defined(AFX_REGIONKEYBOARDPPG_H__36CD3197_EE61_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONKEYBOARDPPG_H__36CD3197_EE61_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// RegionKeyboardPpg.h : Declaration of the CRegionKeyboardPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CRegionKeyboardPropPage : See RegionKeyboardPpg.cpp.cpp for implementation.

class CRegionKeyboardPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CRegionKeyboardPropPage)
	DECLARE_OLECREATE_EX(CRegionKeyboardPropPage)

// Constructor
public:
	CRegionKeyboardPropPage();

// Dialog Data
	//{{AFX_DATA(CRegionKeyboardPropPage)
	enum { IDD = IDD_PROPPAGE_REGIONKEYBOARD };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CRegionKeyboardPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONKEYBOARDPPG_H__36CD3197_EE61_11D0_876A_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RegionKeyboard.rc
//
#define IDS_REGIONKEYBOARD              1
#define IDD_ABOUTBOX_REGIONKEYBOARD     1
#define IDB_REGIONKEYBOARD              1
#define IDI_ABOUTDLL                    1
#define IDS_REGIONKEYBOARD_PPG          2
#define IDS_REGIONKEYBOARD_PPG_CAPTION  200
#define IDD_PROPPAGE_REGIONKEYBOARD     200
#define IDS_CONFIRM_REGION_DELETE       201
#define IDB_KEYBOARD_128                204
#define IDC_CURSOR_STARTEDIT            204
#define IDC_CURSOR_ENDEDIT              206
#define IDB_BLANK_128                   207
#define IDC_CURSOR_MOVE                 208
#define IDC_CURSOR_COPY                 209

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\RegionNote.h ===
//////////////////////////////////////////////////////////////////////
// RegionNote.h 
//

#ifndef REGIONOTE_H
#define REGIONOTE_H

// If any new members are add to this class make sure they are initialize 
// CRegionKeyboardCtrl's constructor
class RegionNote
{
	public:
		bool m_bMemberOfRegion;		// Indicates if note is a member of a region
		bool m_bStartOfRegion;		// Indicates if note is the first note of a region
		int m_nFirstNote;			// First note of region that contains note
		int m_nLastNote;			// Last note of region that contains note
		int m_nStartPixel;			// Start pixel for region that contains note	
		int m_nEndPixel;			// End pixel for region that contains note
		int m_nStartOfNextRegion;	// Note which starts next region 
		int m_nEndOfPrevRegion;     // Note which ends previous region
		int m_nIDRegion;			// ID which indicates which region in instrument note belongs to
        bool m_bIsRootNote;         // indicates if this note is a root note
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\RegionKeyboard\StdAfx.h ===
#if !defined(AFX_STDAFX_H__36CD318B_EE61_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_STDAFX_H__36CD318B_EE61_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__36CD318B_EE61_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\EditSource.cpp ===
// EditSource.cpp : implementation file
//

#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "Script.h"
#include "ScriptCtl.h"
#include "ScriptDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditSource

CEditSource::CEditSource()
{
	m_pScriptDlg = NULL;
	m_dwLastSelection = 0;
	m_fInOnLButtonDown = false;
	m_fSourceChanged = false;
	m_fNeedUndoEntry = false;
}

CEditSource::~CEditSource()
{
}


BEGIN_MESSAGE_MAP(CEditSource, CEdit)
	//{{AFX_MSG_MAP(CEditSource)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillFocus)
	ON_WM_LBUTTONDOWN()
	ON_WM_MBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_MBUTTONUP()
	ON_WM_RBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_CONTROL_REFLECT(EN_SETFOCUS, OnSetFocus)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditSource message handlers

/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnChange

void CEditSource::OnChange( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScriptDlg != NULL );
	ASSERT( m_pScriptDlg->m_pScript != NULL );

	m_pScriptDlg->m_pScript->SetModified( TRUE );
	m_fSourceChanged = true;
	m_fNeedUndoEntry = true;
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnKillFocus

void CEditSource::OnKillFocus( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScriptDlg != NULL );
	ASSERT( m_pScriptDlg->m_pScript != NULL );

	// Sync source
	if( m_fSourceChanged )
	{
		m_fSourceChanged = false;
		m_fNeedUndoEntry = false;

		m_pScriptDlg->m_pScript->m_strSource = m_strSourceForUndo; 
		m_pScriptDlg->m_pScript->m_pUndoMgr->SaveState( m_pScriptDlg->m_pScript,
														theApp.m_hInstance,
														IDS_UNDO_SCRIPT_SOURCE );
		
		GetWindowText( m_pScriptDlg->m_pScript->m_strSource );
		m_strSourceForUndo = m_pScriptDlg->m_pScript->m_strSource;

		HWND hwndFocus = ::GetFocus();
		if( hwndFocus
		&&  hwndFocus == m_pScriptDlg->m_btnRefresh.GetSafeHwnd() )
		{
			// Sync will be handled by Refresh button
			return;
		}

		m_pScriptDlg->m_pScript->SyncScriptWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::SaveUndoState

void CEditSource::SaveUndoState( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScriptDlg != NULL );
	ASSERT( m_pScriptDlg->m_pScript != NULL );

	if(	m_fNeedUndoEntry )
	{
		m_fNeedUndoEntry = false;

		CString strCurrentSource = m_pScriptDlg->m_pScript->m_strSource;
		m_pScriptDlg->m_pScript->m_strSource = m_strSourceForUndo; 
		m_pScriptDlg->m_pScript->m_pUndoMgr->SaveState( m_pScriptDlg->m_pScript,
														theApp.m_hInstance,
														IDS_UNDO_SCRIPT_SOURCE );
		m_pScriptDlg->m_pScript->m_strSource = strCurrentSource;

		GetWindowText( m_strSourceForUndo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnSetFocus

void CEditSource::OnSetFocus() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Store source for undo
	GetWindowText( m_strSourceForUndo );

	// Set selection state if not processing WM_LBUTTONDOWN message
	if( m_fInOnLButtonDown == false )
	{
		SetSel( m_dwLastSelection, FALSE );
	}

	// Save undo state
	SaveUndoState();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnKeyDown

void CEditSource::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnKeyDown( nChar, nRepCnt, nFlags );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();

	switch( nChar )
	{
		case VK_RETURN:
			SaveUndoState();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnKeyUp

void CEditSource::OnKeyUp( UINT nChar, UINT nRepCnt, UINT nFlags ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnKeyUp( nChar, nRepCnt, nFlags );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnLButtonDown

void CEditSource::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fInOnLButtonDown = true;
	CEdit::OnLButtonDown( nFlags, point );
	m_fInOnLButtonDown = false;

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnMButtonDown

void CEditSource::OnMButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnMButtonDown( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnRButtonDown

void CEditSource::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnRButtonDown( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnMouseMove

void CEditSource::OnMouseMove( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnMouseMove( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnLButtonUp

void CEditSource::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnLButtonUp( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnMButtonUp

void CEditSource::OnMButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnMButtonUp( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnRButtonUp

void CEditSource::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CEdit::OnRButtonUp( nFlags, point );

	m_dwLastSelection = GetSel();
	m_pScriptDlg->UpdateStatusBar();
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::OnContextMenu

void CEditSource::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	// Do nothing
	// Need to prevent CEdit context menu from appearing
}


/////////////////////////////////////////////////////////////////////////////
// CEditSource::WindowProc

LRESULT CEditSource::WindowProc( UINT message, WPARAM wParam, LPARAM lParam ) 
{
	switch( message )
	{
		case WM_SETTEXT:
		{
			// Set text and top line
			int nFirstLine = GetFirstVisibleLine();
			LRESULT lResult = CEdit::WindowProc( message, wParam, lParam );
			LineScroll( nFirstLine, 0 );

			// Set cursor
			int nLine = LineFromChar( LOWORD(m_dwLastSelection) );
			int nChar = LineIndex( nLine );
			m_dwLastSelection = MAKELONG( nChar, nChar );
			SetSel( m_dwLastSelection, FALSE );
			m_dwLastSelection = GetSel();
			m_pScriptDlg->UpdateStatusBar();
			return lResult;
		}
	}
	
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\DebugDlg.cpp ===
// DebugDlg.cpp : implementation file
//

#include "stdafx.h"
#include "scriptdesignerdll.h"
#include "ScriptComponent.h"
#include "DebugDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDebugListBox

CDebugListBox::CDebugListBox()
{
}

CDebugListBox::~CDebugListBox()
{
}

BEGIN_MESSAGE_MAP(CDebugListBox, CListBox)
	//{{AFX_MSG_MAP(CDebugListBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg

CDebugDlg::CDebugDlg()
{
	m_nNextLineNbr = 0;
}

CDebugDlg::~CDebugDlg()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::GetNextLineNbr

int CDebugDlg::GetNextLineNbr( void ) 
{
	return ++m_nNextLineNbr;
}


BEGIN_MESSAGE_MAP(CDebugDlg, CWnd)
	//{{AFX_MSG_MAP(CDebugDlg)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_COMMAND(IDM_CLEAR, OnClear)
	//}}AFX_MSG_MAP

	ON_MESSAGE(WM_DISPLAY_MESSAGE_TEXT, OnDisplayMessageText)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::OnCreate

int CDebugDlg::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( CWnd::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	// Create the listbox
	CRect rect;
	GetClientRect( rect );
	m_lstbxDebugSpew.Create( (WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | LBS_HASSTRINGS | LBS_NOINTEGRALHEIGHT),
							 rect,
							 this,
							 IDC_LSTBX_DEBUG_SPEW );

	// Attach the menu 
	HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_MESSAGE_WINDOW) );
	::SetMenu( GetSafeHwnd(), hMenu );

	// Start displaying MessageText
	theApp.m_pScriptComponent->m_fDisplayMessageText = TRUE;

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::OnDestroy

void CDebugDlg::OnDestroy( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Stop displaying MessageText
	::EnterCriticalSection( &theApp.m_pScriptComponent->m_CrSecDebugDlg );
	theApp.m_pScriptComponent->m_fDisplayMessageText = FALSE;
	::LeaveCriticalSection( &theApp.m_pScriptComponent->m_CrSecDebugDlg );

	// Need to cleanup WM_DISPLAY_MESSAGE_TEXT messages
	MSG msg;
	while( ::PeekMessage( &msg, GetSafeHwnd(), WM_DISPLAY_MESSAGE_TEXT, WM_DISPLAY_MESSAGE_TEXT, PM_REMOVE) )
	{
		OnDisplayMessageText( msg.wParam, msg.lParam );
	}

	// Save window placement
	ASSERT( theApp.m_pScriptComponent->m_pDebugDlg != NULL );
	if( theApp.m_pScriptComponent->m_pDebugDlgWP == NULL )
	{
		theApp.m_pScriptComponent->m_pDebugDlgWP = new WINDOWPLACEMENT;
	}
	if( theApp.m_pScriptComponent->m_pDebugDlgWP )
	{
		theApp.m_pScriptComponent->m_pDebugDlgWP->length = sizeof(WINDOWPLACEMENT);
		if( GetWindowPlacement( theApp.m_pScriptComponent->m_pDebugDlgWP ) == 0 )
		{
			delete theApp.m_pScriptComponent->m_pDebugDlgWP;
			theApp.m_pScriptComponent->m_pDebugDlgWP = NULL;
		}
	}

	// Destroy the menu
	HMENU hMenu = ::GetMenu( GetSafeHwnd() );
	::SetMenu( GetSafeHwnd(), NULL );
	if( hMenu )
	{
		::DestroyMenu( hMenu );
	}

	// Destroy the icon
	HICON hIcon = GetIcon( TRUE );
	SetIcon( NULL, TRUE );
	if( hIcon )
	{
		::DestroyIcon( hIcon );
	}

	CWnd::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::OnSize

void CDebugDlg::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd::OnSize( nType, cx, cy );

	// Resize listbox
	if( ::IsWindow(m_lstbxDebugSpew) )
	{
		m_lstbxDebugSpew.MoveWindow( 0, 0, cx, cy, TRUE );
		m_lstbxDebugSpew.Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::PostNcDestroy

void CDebugDlg::PostNcDestroy( void ) 
{
	// Free resources
	ASSERT( theApp.m_pScriptComponent->m_pDebugDlg != NULL );
	if( theApp.m_pScriptComponent->m_pDebugDlg )
	{
		delete theApp.m_pScriptComponent->m_pDebugDlg;
		theApp.m_pScriptComponent->m_pDebugDlg = NULL;
	}
	
	CWnd::PostNcDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::OnClear

void CDebugDlg::OnClear( void ) 
{
	m_lstbxDebugSpew.ResetContent();
	m_nNextLineNbr = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg::OnDisplayMessageText

LRESULT CDebugDlg::OnDisplayMessageText( WPARAM wParam, LPARAM lParam )
{
	ASSERT( lParam != NULL );

	CSize sizeText; 

	m_lstbxDebugSpew.SetRedraw( FALSE );

	CDC* pDC = m_lstbxDebugSpew.GetDC();
	if( pDC )
	{
		CTypedPtrList<CPtrList, CString*>* plstText = (CTypedPtrList<CPtrList, CString*> *)lParam;

		while( !plstText->IsEmpty() )
		{
			CString* pstrMessageText = static_cast<CString*>( plstText->RemoveHead() );

			if( theApp.m_pScriptComponent->m_fDisplayMessageText )
			{
				// Add string to listbox
				int nPos = m_lstbxDebugSpew.AddString( *pstrMessageText );
				m_lstbxDebugSpew.SetCurSel( nPos );

				// Set horizontal extent
				sizeText = pDC->GetTextExtent( *pstrMessageText );
				if( sizeText.cx > m_lstbxDebugSpew.GetHorizontalExtent() )
				{
					m_lstbxDebugSpew.SetHorizontalExtent( sizeText.cx );
				}
			}

			delete pstrMessageText;
		}

		m_lstbxDebugSpew.ReleaseDC( pDC );
	}

	m_lstbxDebugSpew.SetRedraw( TRUE );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\EditSource.h ===
#if !defined(AFX_EDITSOURCE_H__0242CEE0_98A1_43AB_81B4_293E60BD6ACA__INCLUDED_)
#define AFX_EDITSOURCE_H__0242CEE0_98A1_43AB_81B4_293E60BD6ACA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EditSource.h : header file
//


class CScriptDlg;

/////////////////////////////////////////////////////////////////////////////
// CEditSource window

class CEditSource : public CEdit
{
friend class CScriptDlg;

// Construction
public:
	CEditSource();

// Attributes
public:
	CScriptDlg*		m_pScriptDlg;

protected:
	bool			m_fSourceChanged;
	bool			m_fNeedUndoEntry;
	bool			m_fInOnLButtonDown;
	DWORD			m_dwLastSelection;
	CString			m_strSourceForUndo;

// Operations
protected:
	void SaveUndoState();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditSource)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditSource();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditSource)
	afx_msg void OnChange();
	afx_msg void OnKillFocus();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITSOURCE_H__0242CEE0_98A1_43AB_81B4_293E60BD6ACA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\DebugDlg.h ===
#if !defined(AFX_DEBUGDLG_H__5FD7B909_08C4_49C5_9F4A_CA45857C3D44__INCLUDED_)
#define AFX_DEBUGDLG_H__5FD7B909_08C4_49C5_9F4A_CA45857C3D44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DebugDlg.h : header file
//

class CDebugDlg;

/////////////////////////////////////////////////////////////////////////////
// CDebugListBox window

class CDebugListBox : public CListBox
{
// Construction
public:
	CDebugListBox();
	virtual ~CDebugListBox();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDebugListBox)
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CDebugListBox)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDebugDlg window

class CDebugDlg : public CWnd
{
// Construction
public:
	CDebugDlg();
	virtual ~CDebugDlg();

// Attributes
protected:
	CDebugListBox	m_lstbxDebugSpew;
	int				m_nNextLineNbr;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDebugDlg)
	protected:
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
public:
	int GetNextLineNbr();

	// Generated message map functions
protected:
	LRESULT OnDisplayMessageText( WPARAM wParam, LPARAM lParam );

	//{{AFX_MSG(CDebugDlg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnClear();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEBUGDLG_H__5FD7B909_08C4_49C5_9F4A_CA45857C3D44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\EditValue.cpp ===
// EditValue.cpp : implementation file
//

#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "Script.h"
#include "ScriptCtl.h"
#include "ScriptDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditValue

CEditValue::CEditValue()
{
	m_pScriptDlg = NULL;
}

CEditValue::~CEditValue()
{
}


BEGIN_MESSAGE_MAP(CEditValue, CEdit)
	//{{AFX_MSG_MAP(CEditValue)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillFocus)
	ON_WM_KEYDOWN()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditValue message handlers

/////////////////////////////////////////////////////////////////////////////
// CEditValue::OnKillFocus

void CEditValue::OnKillFocus() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScriptDlg != NULL );
	if( m_pScriptDlg )
	{
		m_pScriptDlg->PostMessage( WM_END_EDIT_VALUE, (WPARAM)GetSafeHwnd() );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEditValue::OnKeyDown

void CEditValue::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScriptDlg != NULL );

	switch( nChar )
	{
		case VK_RETURN :
			if( nRepCnt == 1 )
			{
				if( m_pScriptDlg )
				{
					m_pScriptDlg->PostMessage( WM_END_EDIT_VALUE, (WPARAM)GetSafeHwnd() );
				}
			}
			return;

		case VK_ESCAPE :
			if( nRepCnt == 1 )
			{
				if( m_pScriptDlg )
				{
					m_pScriptDlg->PostMessage( WM_CANCEL_EDIT_VALUE, (WPARAM)GetSafeHwnd() );
				}
			}
			return;
	}
	
	CEdit::OnKeyDown( nChar, nRepCnt, nFlags );
}


/////////////////////////////////////////////////////////////////////////////
// CEditValue::OnChar

void CEditValue::OnChar( UINT nChar, UINT nRepCnt, UINT nFlags ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nChar )
	{
		case VK_RETURN:
		case VK_ESCAPE:
			return;
	}
	
	CEdit::OnChar( nChar, nRepCnt, nFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\EditValue.h ===
#if !defined(AFX_EDITVALUE_H__25634E66_BE46_47F0_B33E_07BAD7B8C5CF__INCLUDED_)
#define AFX_EDITVALUE_H__25634E66_BE46_47F0_B33E_07BAD7B8C5CF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EditValue.h : header file
//


class CScriptDlg;

/////////////////////////////////////////////////////////////////////////////
// CEditValue window

class CEditValue : public CEdit
{
friend class CScriptDlg;

// Construction
public:
	CEditValue();

// Attributes
public:
	CScriptDlg*		m_pScriptDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditValue)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditValue();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditValue)
	afx_msg void OnKillFocus();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITVALUE_H__25634E66_BE46_47F0_B33E_07BAD7B8C5CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\LogTool.cpp ===
#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "LogTool.h"
#include <dmusicp.h>

CLogTool::CLogTool( IDMUSProdDebugScript* pIDebugScript, bool fLogToStdOut)
  : m_cRef(1),
	m_pIDebugScript(pIDebugScript),
	m_fLogToStdOut(fLogToStdOut)
{
}

CLogTool::~CLogTool()
{
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CLogTool::QueryInterface( REFIID riid, LPVOID FAR *ppv )
{
	if( riid == IID_IUnknown
	||  riid == IID_IDirectMusicTool )
	{
		*ppv = static_cast<IDirectMusicTool*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CLogTool::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CLogTool::Release()
{
    if( !InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
//  IDirectMusicTool

STDMETHODIMP
CLogTool::Init( IDirectMusicGraph* pGraph )
{
	return S_OK;
}

STDMETHODIMP
CLogTool::GetMsgDeliveryType( DWORD* pdwDeliveryType )
{
	*pdwDeliveryType = DMUS_PMSGF_TOOL_QUEUE;
	return S_OK;
}


#define NBR_ELEMENTS	3
DWORD aMediaTypes[NBR_ELEMENTS] = { DMUS_PMSGT_SCRIPTLYRIC,
									DMUS_PMSGT_SCRIPTTRACKERROR,
									DMUS_PMSGT_LYRIC };

STDMETHODIMP
CLogTool::GetMediaTypeArraySize( DWORD* pdwNumElements )
{
	*pdwNumElements = NBR_ELEMENTS;
	return S_OK;
}

STDMETHODIMP
CLogTool::GetMediaTypes( DWORD** padwMediaTypes, DWORD dwNumElements )
{
	for( DWORD i = 0;  i < dwNumElements;  ++i )
	{
		if( i < NBR_ELEMENTS )
		{
			(*padwMediaTypes)[i] = aMediaTypes[i];
		}
		else
		{
			// Array is too large
			(*padwMediaTypes)[i] = 0;
		}
	}

	if( dwNumElements < NBR_ELEMENTS )
	{
		// Array is too small
		return S_FALSE;
	}

	return S_OK;
}

STDMETHODIMP
CLogTool::ProcessPMsg( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG )
{
	switch( pPMSG->dwType )
	{
		case DMUS_PMSGT_SCRIPTLYRIC:
		case DMUS_PMSGT_LYRIC:
		{
			DMUS_LYRIC_PMSG *pLyric = reinterpret_cast<DMUS_LYRIC_PMSG*>(pPMSG);
			
			m_pIDebugScript->DisplayText( pLyric->wszString );

			if( pPMSG->pGraph == NULL
			||  FAILED( pPMSG->pGraph->StampPMsg(pPMSG) ) )
			{
				return DMUS_S_FREE;
			}
			return DMUS_S_REQUEUE;
		}

		case DMUS_PMSGT_SCRIPTTRACKERROR:
		{
			DMUS_SCRIPT_TRACK_ERROR_PMSG *pScriptError = reinterpret_cast<DMUS_SCRIPT_TRACK_ERROR_PMSG*>(pPMSG);
			
			m_pIDebugScript->DisplayScriptError( &pScriptError->ErrorInfo );

			if( pPMSG->pGraph == NULL
			||  FAILED( pPMSG->pGraph->StampPMsg(pPMSG) ) )
			{
				return DMUS_S_FREE;
			}
			return DMUS_S_REQUEUE;
		}
	}

	return E_UNEXPECTED;
}

STDMETHODIMP
CLogTool::Flush( IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime )
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\LogTool.h ===
#ifndef __LOGTOOL_H__
#define __LOGTOOL_H__

// LogTool.h : header file
//

#include <dmusici.h>

class CLogTool : public IDirectMusicTool
{
public:
	CLogTool( IDMUSProdDebugScript* pIDebugScript, bool fLogToStdOut = false );
	~CLogTool();

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDirectMusicTool
	STDMETHOD(Init)(IDirectMusicGraph* pGraph);
	STDMETHOD(GetMsgDeliveryType)(DWORD* pdwDeliveryType );
	STDMETHOD(GetMediaTypeArraySize)(DWORD* pdwNumElements );
	STDMETHOD(GetMediaTypes)(DWORD** padwMediaTypes, DWORD dwNumElements);
	STDMETHOD(ProcessPMsg)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG);
	STDMETHOD(Flush)(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime);

private:
	long m_cRef;
	IDMUSProdDebugScript* m_pIDebugScript;
	bool m_fLogToStdOut;
};

#endif // __SCRIPTCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScriptDesignerDLL.rc
//
#define IDI_ABOUTDLL                    1
#define IDS_SCRIPT                      2
#define IDD_ABOUTBOX_SCRIPT             2
#define IDB_SCRIPT                      2
#define IDS_SCRIPT_PPG                  3
#define IDD_DLG_SCRIPT                  101
#define IDS_SCRIPT_PPG_CAPTION          200
#define IDD_PROPPAGE_SCRIPT             200
#define IDS_SCRIPT_COMPONENT_NAME       201
#define IDC_SOURCE                      201
#define IDS_HELP_FILE_EXT               202
#define IDS_ERR_INVALIDARG              203
#define IDR_SCRIPT_DOCTYPE              204
#define IDI_SCRIPT_DOCTYPE_SEL          205
#define IDS_ERR_REGISTER_CF             205
#define IDM_SCRIPT_NODE_RMENU           205
#define IDI_SCRIPTREF                   206
#define IDS_ERR_ADD_CLIPFORMAT          206
#define IDI_SCRIPTREF_SEL               207
#define IDS_ERR_ADD_IMAGELIST           207
#define IDS_ERR_MEMORY                  208
#define IDS_ERR_ADD_DOCTYPE             209
#define IDS_ERR_MISSING_CONDUCTOR       210
#define IDS_SCRIPT_TEXT                 211
#define IDS_SCRIPT_VERSION_TEXT         212
#define IDS_NO_SCRIPT                   213
#define IDS_UNDO_SCRIPT_NAME            214
#define IDS_UNDO_SCRIPT_GUID            215
#define IDS_UNDO_SCRIPT_LANGUAGE        216
#define IDS_UNDO                        217
#define IDS_UNDO_ACCEL                  218
#define IDS_REDO                        219
#define IDS_REDO_ACCEL                  220
#define IDS_REDO_ACCEL2                 221
#define IDS_UNDO_SCRIPT_DOWNLOAD_ALL    221
#define IDC_FILE_VERSION                222
#define IDS_UNDO_SCRIPT_AUTHOR          222
#define IDS_UNDO_SCRIPT_COPYRIGHT       223
#define IDS_UNDO_SCRIPT_SUBJECT         224
#define IDC_LANGUAGE                    225
#define IDC_AUTHOR                      225
#define IDS_UNDO_SCRIPT_VERSION         225
#define IDC_COPYRIGHT                   226
#define IDS_SCRIPT_OBJECT_TEXT          226
#define IDC_VERSION_1                   227
#define IDS_DEBUG_WINDOW_MENU_TEXT      227
#define IDC_VERSION_2                   228
#define IDS_DEBUG_WINDOW_MENU_HELP_TEXT 228
#define IDC_VERSION_3                   229
#define IDS_ERR_ADD_MENUITEM            229
#define IDC_VERSION_4                   230
#define IDD_TAB_SCRIPT_SCRIPT           230
#define IDS_ERR_ADD_LOGTOOL             230
#define IDC_NAME                        231
#define IDC_SUBJECT                     231
#define IDS_CONTAINER_NODE_NAME         231
#define IDC_DM_VERSION_1                232
#define IDS_UNDO_SCRIPT_LOAD_ALL        232
#define IDC_DM_VERSION_2                233
#define IDS_ERR_MISSING_CONTAINER_DESIGNER 233
#define IDC_DM_VERSION_3                234
#define IDS_UNDO_SOURCE                 234
#define IDC_DM_VERSION_4                235
#define IDS_ERR_MESSAGE_WINDOW_THREAD   236
#define IDR_SCRIPT_EDITOR               237
#define IDS_LINE_TEXT                   237
#define IDS_COLUMN_TEXT                 238
#define IDR_SCRIPT_ACCELS               239
#define IDS_NAME_TEXT                   239
#define IDS_VALUE_TEXT                  240
#define IDS_EMPTY_TEXT                  241
#define IDM_SCRIPTREF_NODE_RMENU        242
#define IDS_UNKNOWN_TEXT                242
#define IDD_DLG_DEBUG                   243
#define IDS_OBJECT_TEXT                 243
#define IDD_DLG_GUID                    244
#define IDS_ERROR_TEXT                  244
#define IDD_TAB_SCRIPT_INFO             245
#define IDC_LSTBX_DEBUG_SPEW            246
#define IDM_CLEAR                       247
#define IDS_UNDO_REPLACE_CONTAINER      247
#define IDM_MESSAGE_WINDOW              248
#define IDS_UNDO_UPDATE_CONTAINER       248
#define IDM_ROUTINE_LIST                249
#define IDS_UNDO_SCRIPT_SOURCE          249
#define IDM_VARIABLE_LIST               250
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDC_CHECK_LOAD_ALL              500
#define IDC_CHECK_DOWNLOAD_ALL          501
#define IDC_ROUTINE_LIST                503
#define IDC_ROUTINE_PROMPT              504
#define IDC_VARIABLE_PROMPT             505
#define IDC_REFRESH                     506
#define IDC_SOURCE_PROMPT               507
#define IDC_VARIABLE_LIST               508
#define IDC_EDIT_VALUE                  509
#define IDC_INIT_VARIABLES              509
#define IDS_SCRIPT_LANGUAGE_DEFAULT     1000
#define IDS_SCRIPT_LANGUAGE2            1001
#define IDM_PROPERTIES                  32768
#define IDM_RENAME                      32769
#define IDM_CALL_ROUTINE                32771
#define IDM_SET_VARIABLE                32772
#define IDM_HELP_SCRIPT_API             32774
#define IDM_HELP_SCRIPT_LANGUAGE        32775
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_INSERT                  32796
#define IDM_HELP_FINDER                 32815

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        301
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         510
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\Script.cpp ===
// Script.cpp : implementation file
//

#include "stdafx.h"
#include "ScriptDesignerDLL.h"

#include "RiffStrm.h"
#include "Script.h"
#include <mmreg.h>
#include <math.h>
#include "TabScriptScript.h"
#include "TabScriptInfo.h"
#include "ScriptCtl.h"
#include <ContainerDesigner.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {D5C2F18E-D180-4246-BB25-58154A64F122}
static const GUID GUID_ScriptUndo = 
{ 0xd5c2f18e, 0xd180, 0x4246, { 0xbb, 0x25, 0x58, 0x15, 0x4a, 0x64, 0xf1, 0x22 } };

// {F078ACC0-67AA-11d3-B45D-00105A2796DE}
static const GUID GUID_ScriptPropPageManager = 
{ 0xf078acc0, 0x67aa, 0x11d3, { 0xb4, 0x5d, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

short CScriptPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CScriptPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CScriptPropPageManager::CScriptPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabScript = NULL;
	m_pTabInfo = NULL;
}

CScriptPropPageManager::~CScriptPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabScript )
	{
		delete m_pTabScript;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager::RemoveCurrentObject

void CScriptPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IUnknown implementation

HRESULT CScriptPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CScriptPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CScriptPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CScriptPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_SCRIPT_TEXT );

	CDirectMusicScript *pScript;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pScript))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pScript->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CScriptPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Script tab
	m_pTabScript = new CTabScriptScript( this );
	if( m_pTabScript )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabScript->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	m_pTabInfo = new CTabScriptInfo( this );
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CScriptPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CScriptPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CScriptPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CScriptPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CScriptPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CScriptPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicScript* pScript;
	
	if( m_pIPropPageObject == NULL )
	{
		pScript = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pScript ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Script are processed in OnKillFocus
	// messages before setting the new Script
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabScript->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Script
	m_pTabScript->SetScript( pScript);
	m_pTabInfo->SetScript( pScript);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CScriptPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_ScriptPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript constructor/destructor

CDirectMusicScript::CDirectMusicScript()
{
	ASSERT( theApp.m_pScriptComponent != NULL );

	// Script needs Script Component
	theApp.m_pScriptComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pIContainerNode = NULL;
	m_pIDMScript = NULL;

	m_hWndEditor = NULL;
	m_pScriptCtrl = NULL;
	m_pINodeBeingDeleted = NULL;
	m_pIProject = NULL;
	m_fDeletingContainer = false;
	m_fInitializingVariables = false;

	m_dwFlagsDM = (DMUS_SCRIPTIOF_LOAD_ALL_CONTENT | DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS);

// Script info block
	TCHAR achName[SMALL_BUFFER];
	::LoadString( theApp.m_hInstance, IDS_SCRIPT_TEXT, achName, SMALL_BUFFER );
    m_strName.Format( "%s%d", achName, ++theApp.m_pScriptComponent->m_nNextScript );

	m_strLanguage.LoadString( IDS_SCRIPT_LANGUAGE_DEFAULT );

	CoCreateGuid( &m_guidScript ); 
	m_vVersion.dwVersionMS = 0x00010000;
	m_vVersion.dwVersionLS = 0x00000000;
	m_vDirectMusicVersion.dwVersionMS = 0x00080000;
	m_vDirectMusicVersion.dwVersionLS = 0x00000000;
}

CDirectMusicScript::~CDirectMusicScript()
{
	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Remove Script from clipboard
	theApp.FlushClipboard( this );

	// Remove Script from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
		m_pUndoMgr = NULL;
	}

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		// Messing with m_dwRef to prevent destructor from being called twice
		ASSERT( m_dwRef == 0 );
		m_dwRef = 1;
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
		ASSERT( m_dwRef == 1 );
		m_dwRef = 0;
	}

	// Cleanup references
	if( m_pIDMScript )
	{
		IDirectMusicObjectP* pIDMObjectP;
		if( SUCCEEDED ( m_pIDMScript->QueryInterface( IID_IDirectMusicObjectP, (void**)&pIDMObjectP ) ) )
		{
			pIDMObjectP->Zombie();
			RELEASE( pIDMObjectP );
		}
	}
	RELEASE( m_pIDMScript );
	RELEASE( m_pIContainerNode );

	// Cleanup VariableState list
 	VariableState* pVariableState;
	while( !m_lstLastKnownVariableStates.IsEmpty() )
	{
		pVariableState = static_cast<VariableState*>( m_lstLastKnownVariableStates.RemoveHead() );
		delete pVariableState;
	}

	// Script no longer needs Script Component
	theApp.m_pScriptComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::CreateEmptyContainer

HRESULT CDirectMusicScript::CreateEmptyContainer( void )
{
	IDMUSProdNode* pINode;
	IDMUSProdDocType* pIDocType;

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Do not call if Script already has a container!
	ASSERT( m_pIContainerNode == NULL );
	if( m_pIContainerNode )
	{
		return S_OK;
	}

	// Create the Container
	HRESULT hr = theApp.m_pScriptComponent->m_pIFramework->FindDocTypeByNodeId( GUID_ContainerNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_ContainerNode, &pINode );
		if( SUCCEEDED ( hr ) )
		{
			m_pIContainerNode = pINode;

			// Set parent
			m_pIContainerNode->SetParentNode( (IDMUSProdNode *)this );

			// Set name
			CString strName;
			strName.LoadString( IDS_CONTAINER_NODE_NAME );
			BSTR bstrName = strName.AllocSysString();
			m_pIContainerNode->SetNodeName( bstrName );
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::CreateUndoMgr

BOOL CDirectMusicScript::CreateUndoMgr()
{
	// Should only be called once - after Script first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pScriptComponent != NULL ); 
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pScriptComponent->m_pIFramework );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_ScriptUndo );
		m_pUndoMgr->SetUndoLevel( 16 );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::SyncScriptEditor

void CDirectMusicScript::SyncScriptEditor( DWORD dwFlags  )
{
	if( m_pScriptCtrl
	&&  m_pScriptCtrl->m_pScriptDlg )
	{
		m_pScriptCtrl->m_pScriptDlg->RefreshControls( dwFlags );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::SyncScriptWithDirectMusic

HRESULT CDirectMusicScript::SyncScriptWithDirectMusic( void )
{
	CWaitCursor wait;
	IStream* pIMemStream;
	IPersistStream* pIPersistStream;
	HRESULT hr;

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Make sure the parent of m_pIContainerNode has been set to the script
	if( m_pIContainerNode )
	{
		m_pIContainerNode->SetParentNode( (IDMUSProdNode *)this );
	}

	// Make sure we have a DirectMusic Engine Script
	if( m_pIDMScript == NULL )
	{
		if( FAILED ( ::CoCreateInstance( CLSID_DirectMusicScript, NULL, CLSCTX_INPROC_SERVER,
										 IID_IDirectMusicScript, (void**)&m_pIDMScript ) ) )
		{
			RELEASE( m_pIDMScript );
		}
	}

	if( m_pIDMScript == NULL )
	{
		// Nothing to do
		return S_OK;
	}

	// Must be FT_DESIGN so that objects aren't embedded in the container
	hr = theApp.m_pScriptComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_DirectMusicObject, &pIMemStream );

	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			m_pIDMScript->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( pIPersistStream )
			{
				// If m_lstLastKnownVariableStates is not empty,
				// the last call to m_pIDMScript->Init must have failed
				// and we need to use the existing list
				if( m_lstLastKnownVariableStates.IsEmpty() )
				{
					// Get current state of variables
					GetVariableState( m_lstLastKnownVariableStates );
				}

				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );
				if( SUCCEEDED ( hr ) )
				{
					// Set DirectMusic object's filename
					BSTR bstrFileName;
					if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->GetNodeFileName( this, &bstrFileName ) ) )
					{
						CString strFileName = bstrFileName;
						::SysFreeString( bstrFileName );

						int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
						if( nFindPos != -1 )
						{
							strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
						}

						IDirectMusicObject* pIDMObject;
						if( SUCCEEDED ( m_pIDMScript->QueryInterface( IID_IDirectMusicObject, (void **)&pIDMObject ) ) )
						{
							DMUS_OBJECTDESC dmusObjectDesc;
							ZeroMemory( &dmusObjectDesc, sizeof(DMUS_OBJECTDESC) );
							dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
							dmusObjectDesc.dwValidData = DMUS_OBJ_FILENAME;
							MultiByteToWideChar( CP_ACP, 0, strFileName, -1, dmusObjectDesc.wszFileName, MAX_PATH );

							pIDMObject->SetDescriptor( &dmusObjectDesc );

							RELEASE( pIDMObject );
						}
					}

					// Initialize DirectMusic Script
					DMUS_SCRIPT_ERRORINFO ErrorInfo;
					memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
					ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

					hr = m_pIDMScript->Init( theApp.m_pScriptComponent->m_pIDMPerformance, &ErrorInfo );
					if( SUCCEEDED ( hr ) )
					{
						// Assign values to variables 
						if( m_fInitializingVariables == false )
						{
							SetVariableState( m_lstLastKnownVariableStates );
						}

						// Cleanup VariableState list
 						VariableState* pVariableState;
						while( !m_lstLastKnownVariableStates.IsEmpty() )
						{
							pVariableState = static_cast<VariableState*>( m_lstLastKnownVariableStates.RemoveHead() );
							delete pVariableState;
						}
					}
					else 
					{
						DisplayScriptError( &ErrorInfo, hr );
					}

					// Rebuild Script editor (when open)
					SyncScriptEditor( SSE_ROUTINES | SSE_VARIABLES );
				}

				RELEASE( pIPersistStream );
			}
		}

		RELEASE( pIMemStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::SetModified

void CDirectMusicScript::SetModified( BOOL fModified )
{
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IUnknown implementation

HRESULT CDirectMusicScript::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
	{
		*ppvObj = (IDMUSProdNotifySink*) this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicScript::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicScript::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicScript::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );

	return( theApp.m_pScriptComponent->GetScriptImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicScript::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	if( m_pIContainerNode )
	{
		m_pIContainerNode->AddRef();
		*ppIFirstChildNode = m_pIContainerNode;
	}
	else
	{
		*ppIFirstChildNode = NULL;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNextChild

HRESULT CDirectMusicScript::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}
	
	*ppINextChildNode = NULL;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetComponent

HRESULT CDirectMusicScript::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );

	return theApp.m_pScriptComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicScript::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicScript::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetParentNode

HRESULT CDirectMusicScript::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::SetParentNode

HRESULT CDirectMusicScript::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNodeId

HRESULT CDirectMusicScript::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ScriptNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNodeName

HRESULT CDirectMusicScript::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicScript::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicScript::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::SetNodeName

HRESULT CDirectMusicScript::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_SCRIPT_NAME );
	m_strName = strName;

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}
	
	SetModified( TRUE );
	SyncScriptWithDirectMusic();

	// Notify connected nodes that Script name has changed
	theApp.m_pScriptComponent->m_pIFramework->NotifyNodes( this, SCRIPT_NameChange, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicScript::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

    pListInfo->bstrName = m_strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidScript, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicScript::GetEditorClsId( CLSID* pClsId )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_ScriptEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicScript::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_SCRIPT_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicScript::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicScript::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicScript::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicScript::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SCRIPT_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicScript::OnRightClickMenuInit( HMENU hMenu )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicScript::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_RENAME:
			hr = theApp.m_pScriptComponent->m_pIFramework->EditNodeLabel( this );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicScript::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( m_fDeletingContainer )
	{
		// Nothing to do
		return S_OK;
	}

	CWaitCursor wait;

	if( pIChildNode == NULL 
	||  pIChildNode != m_pIContainerNode )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pScriptComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	// Remove from Script
	RELEASE( m_pIContainerNode );

	SetModified( TRUE );

	// TODO - Remove this code!!
	// Update the DirectMusic Style object
//	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
//	ASSERT( SUCCEEDED ( hr ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicScript::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	pIChildNode->AddRef();

	// Scripts can only have one Container
	if( m_pIContainerNode )
	{
		DeleteChildNode( m_pIContainerNode, FALSE );
	}

	// Set the Script's Container
	ASSERT( m_pIContainerNode == NULL );
	m_pIContainerNode = pIChildNode;

	// Set root and parent node of ALL children
	theApp.SetNodePointers( m_pIContainerNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->AddNode(m_pIContainerNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( m_pIContainerNode, FALSE );
		return E_FAIL;
	}

	SetModified( TRUE );

	// TODO - Remove this code!!
	// Update the DirectMusic Style object
//	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
//	ASSERT( SUCCEEDED ( hr ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::DeleteNode

HRESULT CDirectMusicScript::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	// No parent so we will delete ourself
	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( theApp.m_pScriptComponent->m_pIFramework->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	// Remove from Script
	RELEASE( m_pIContainerNode );

	// Remove from Component Script list
	theApp.m_pScriptComponent->RemoveFromScriptFileList( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicScript::OnNodeSelChanged( BOOL fSelected )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicScript::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Script into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_SCRIPT into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pScriptComponent->m_cfScript, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->SaveClipFormat( theApp.m_pScriptComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Script nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pScriptComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanCut

HRESULT CDirectMusicScript::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanCopy

HRESULT CDirectMusicScript::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanDelete

HRESULT CDirectMusicScript::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicScript::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Cannot delete Containers in a script
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicScript::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}
	
	return S_FALSE;		// Can't paste anything on a Script node
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::PasteFromData

HRESULT CDirectMusicScript::PasteFromData( IDataObject* pIDataObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);

	ASSERT( 0 );
	
	return E_NOTIMPL;	// Can't paste anything on a Script node
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicScript::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicScript::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNode::GetObject

HRESULT CDirectMusicScript::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMScript object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicScript ) )
	{
		if( m_pIDMScript )
		{
			return m_pIDMScript->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicScript::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicScript::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicScript::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Get the Script page manager
	CScriptPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_ScriptPropPageManager ) == S_OK )
	{
		pPageManager = (CScriptPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CScriptPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Script properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CScriptPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicScript::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersist::GetClassID

HRESULT CDirectMusicScript::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream::IsDirty

HRESULT CDirectMusicScript::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

// AMC - Will want to change way data syncs are handled!
	if( m_pScriptCtrl
	&&  m_pScriptCtrl->m_pScriptDlg )
	{
		m_pScriptCtrl->m_pScriptDlg->m_editSource.GetWindowText( m_strSource );
	}

	if( m_fModified )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::LoadScript

HRESULT CDirectMusicScript::LoadScript( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pScriptComponent != NULL );

	// Following strings only saved when they have values
	// So make sure they are initialized!!
	m_strAuthor.Empty();
	m_strCopyright.Empty();
	m_strSubject.Empty();

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_SCRIPT_CHUNK:
			{
			    DMUS_IO_SCRIPT_HEADER dmusScriptIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_SCRIPT_HEADER ) );
				hr = pIStream->Read( &dmusScriptIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwFlagsDM = dmusScriptIO.dwFlags;
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidScript, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_vVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}

			case DMUS_FOURCC_SCRIPTVERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_vDirectMusicVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vDirectMusicVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}

			case DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strLanguage);
				break;

			case DMUS_FOURCC_SCRIPTSOURCE_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strSource);
				break;

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINER_FORM: 
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = theApp.m_pScriptComponent->m_pIContainerComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						if( m_pIContainerNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIContainerNode = pINode;
						}
						break;
					}
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
									if( strName.CompareNoCase( m_strName ) != 0 )
									{
										m_strName = strName;
										theApp.m_pScriptComponent->m_pIFramework->RefreshNode( this );

										// Notify connected nodes that the Script name has changed
										theApp.m_pScriptComponent->m_pIFramework->NotifyNodes( this, SCRIPT_NameChange, NULL );
									}
									break;
								}

								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream::Load

HRESULT CDirectMusicScript::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SCRIPT_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;
			hr = LoadScript( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	if( fFoundFormat == FALSE )
	{
		// Check for legacy ascii text file format
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
		hr = ReadSourceFromStream( pIStream );
		if( FAILED( hr ) )
		{
			return hr;
		}
	}

	if( m_pIDocRootNode )
	{
		// Sync change with property sheet
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RefreshTitle();
			pIPropSheet->RefreshActivePage();
			RELEASE( pIPropSheet );
		}
	}

	//	Persist Script to the DirectMusic DLLs.
	if( SUCCEEDED( hr ) )
	{
		if( m_pIContainerNode == NULL )
		{
			CreateEmptyContainer();
		}

		SyncScriptWithDirectMusic();
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveSource
    
HRESULT CDirectMusicScript::SaveSource( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Script source
	ck.ckid = DMUS_FOURCC_SCRIPTSOURCE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = SaveMBStoWCS( pIStream, &m_strSource );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveLanguage
    
HRESULT CDirectMusicScript::SaveLanguage( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Script laguage
	ck.ckid = DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = SaveMBStoWCS( pIStream, &m_strLanguage );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveDirectMusicVersion
    
HRESULT CDirectMusicScript::SaveDirectMusicVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DirectMusic Version chunk header
	ck.ckid = DMUS_FOURCC_SCRIPTVERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vDirectMusicVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vDirectMusicVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveInfoList
    
HRESULT CDirectMusicScript::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Script name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write script author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Script copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write script subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveVersion
    
HRESULT CDirectMusicScript::SaveVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Version chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveGUID
    
HRESULT CDirectMusicScript::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Script GUID
	hr = pIStream->Write( &m_guidScript, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveHeader
    
HRESULT CDirectMusicScript::SaveHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_SCRIPT_HEADER dmusScriptIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Script chunk header
	ck.ckid = DMUS_FOURCC_SCRIPT_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SCRIPT_HEADER structure
	memset( &dmusScriptIO, 0, sizeof(DMUS_IO_SCRIPT_HEADER) );

	dmusScriptIO.dwFlags = m_dwFlagsDM;

	// Write Script chunk data
	hr = pIStream->Write( &dmusScriptIO, sizeof(DMUS_IO_SCRIPT_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_SCRIPT_HEADER) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript SaveScript
    
HRESULT CDirectMusicScript::SaveScript( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

// Save Script header chunk
	hr = SaveHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script version
	hr = SaveVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script info
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script DirectMusic version
	hr = SaveDirectMusicVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script's Container
	if( m_pIContainerNode )
	{
		// Don't save container contents in undo stream
		if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_ScriptUndo ) == FALSE )
		{
			IPersistStream* pIPersistStream;

			hr = m_pIContainerNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			hr = pIPersistStream->Save( pIStream, fClearDirty );
			RELEASE( pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

// Save Script Language
	hr = SaveLanguage( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Script's Source Code
	hr = SaveSource( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream::Save

HRESULT CDirectMusicScript::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_ScriptUndo ) == FALSE )
	{
		// Make sure we have the latest text
		// Necessary because sync takes place in KillFocus 
		// and save may have been initiated by Ctrl+S
		if( m_pScriptCtrl
		&&  m_pScriptCtrl->m_pScriptDlg )
		{
			m_pScriptCtrl->m_pScriptDlg->SyncSource();
		}
	}

	// Validate requested data format
	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) 
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_ScriptUndo ) )
	{
		// DirectMusic format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_SCRIPT_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveScript( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}

				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream::GetSizeMax

HRESULT CDirectMusicScript::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IDMUSProdNotifySink implementation

///////////////////////////////////////////////////////////////////////////
// CDirectMusicScript  IDMUSProdNotifySink::OnUpdate

HRESULT CDirectMusicScript::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode == m_pIContainerNode )
	{
		// CONTAINER_ChangeNotification
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_ChangeNotification ) )
		{
			SetModified( TRUE );
			SyncScriptWithDirectMusic();
			return S_OK;
		}

		// CONTAINER_FileLoadFinished
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_FileLoadFinished ) )
		{
			SyncScriptWithDirectMusic();
			return S_OK;
		}
	}

	if( pIDocRootNode == this )
	{
		if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileNameChange)  )
		{
			SyncScriptWithDirectMusic();
			return S_OK;
		}
		if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_AfterFileOpen)  )
		{
			if( m_pIDMScript )
			{
				WCHAR* pwszFileName = (WCHAR*)pData;
				CString strFileName = pwszFileName;

				// Set DirectMusic object's filename
				int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
				}

				IDirectMusicObject* pIDMObject;
				if( SUCCEEDED ( m_pIDMScript->QueryInterface( IID_IDirectMusicObject, (void **)&pIDMObject ) ) )
				{
					DMUS_OBJECTDESC dmusObjectDesc;
					ZeroMemory( &dmusObjectDesc, sizeof(DMUS_OBJECTDESC) );
					dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
					dmusObjectDesc.dwValidData = DMUS_OBJ_FILENAME;
					MultiByteToWideChar( CP_ACP, 0, strFileName, -1, dmusObjectDesc.wszFileName, MAX_PATH );

					pIDMObject->SetDescriptor( &dmusObjectDesc );

					RELEASE( pIDMObject );
				}
			}
			return S_OK;
		}
	}

	// GUID_DMCollectionResync 
	if( ::IsEqualGUID(guidUpdateType, GUID_DMCollectionResync ) )
	{
		SyncScriptWithDirectMusic();
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript Additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript IPersistStream::SaveScriptSource

HRESULT CDirectMusicScript::SaveScriptSource( IStream* pIStream )
{
	DWORD dwBytesWritten;
	HRESULT hr;

	// Source
	hr = pIStream->Write( m_strSource, m_strSource.GetLength(), &dwBytesWritten );
	if( FAILED( hr ) 
	||  dwBytesWritten != (DWORD)m_strSource.GetLength() )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Functions for parsing the script header block

void ParseSkipWhitespace( const WCHAR** ppwsz )
{
	ASSERT( !iswspace(L'\0') );
	
	while( iswspace(**ppwsz) )
	{
		++*ppwsz;
	}
}

UINT ParseContinuousString( const WCHAR* pwsz )
{
	const WCHAR *pwszEnd = pwsz;

	while( !iswspace(*pwszEnd) && *pwszEnd != L'>' && *pwszEnd != L'=' && *pwszEnd )
	{
		++pwszEnd;
	}

	return pwszEnd - pwsz;
}

UINT ParseQuotedString( const WCHAR* pwsz )
{
	const WCHAR *pwszEnd = pwsz;

	while( *++pwszEnd )
	{
		if( *pwszEnd == L'"' )
		{
			if( *++pwszEnd != L'"' )
			{
				break;
			}
		}
		else if( *pwszEnd == L'>'
			 ||  *pwszEnd == L'=' )
		{
			break;
		}
	}

	return pwszEnd - pwsz;
}

HRESULT ReformatQuotedString( const WCHAR* pwsz, WCHAR* pwszTarget )
{
	const WCHAR *pwszSource = pwsz;
	
	if( *pwszSource++ != L'"' )
	{
		return E_FAIL;
	}

	while( *pwszSource )	// note: successful exit is via return statement inside loop
	{
		if( *pwszSource == L'"' )
		{
			if( *++pwszSource == L'"' )
			{
				// Two quotes is an escape sequence that is replaced with a single quote.
				// All other characters are directly appended.
				*pwszTarget++ = *pwszSource++;
			}
			else
			{
				// A single quote completes the string.
				*pwszTarget = L'\0'; 
				return S_OK;
			}
		}
		else
		{
			*pwszTarget++ = *pwszSource++;
		}
	}

	// Must have hit end of string without closing quote.
	return E_FAIL;
}

HRESULT ParseNumericWord( const WCHAR** ppwsz, WORD* pw )
{
	const WCHAR *pwsz = *ppwsz;

	// Read the word
	int i = _wtoi( pwsz );
	if( i < 0
	||  i > MAXWORD )
	{
		return E_FAIL;
	}

	// Skip one digit
	if( !iswdigit(*pwsz++) )
	{
		return E_FAIL;
	}

	// Skip any other contiguous digits
	while( iswdigit(*pwsz) )
	{
		++pwsz;
	}

	*pw = i;
	*ppwsz = pwsz;
	return S_OK;
}

HRESULT ParseVersion( const WCHAR *pwszVersionField, DMUS_VERSION *pvVersion )
{
	const WCHAR *pwsz = pwszVersionField;

	// Read in four words separated by periods.
	WORD wVals[4];
	for( int i = 0; i < 4; ++i )
	{
		if( FAILED ( ::ParseNumericWord(&pwsz, &wVals[i]) )
		||  ( i < 3  &&  *pwsz++ != L'.' ) )
		{
			return E_FAIL;
		}
	}

	// Pack the word values into the version structure
	pvVersion->dwVersionMS = MAKELONG( wVals[1], wVals[0] );
	pvVersion->dwVersionLS = MAKELONG( wVals[3], wVals[2] );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::FoundField

HRESULT CDirectMusicScript::FoundField( const WCHAR* pwszName, const WCHAR* pwszValue, DMUSProdListInfo* pListInfo )
{
	if( 0 == _wcsicmp(pwszName, L"NAME") )
	{
		m_strName = pwszValue;
		if( m_strName.IsEmpty() == TRUE )
		{
			return E_OUTOFMEMORY;
		}
		if( pListInfo )
		{
			pListInfo->bstrName = m_strName.AllocSysString();
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"GUID") )
	{
		if( FAILED ( ::CLSIDFromString(const_cast<WCHAR *>(pwszValue), &m_guidScript) ) )
		{
			return E_FAIL;
		}
		if( pListInfo )
		{
			memcpy( &pListInfo->guidObject, &m_guidScript, sizeof(GUID) );
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"VERSION") )
	{
		if( FAILED ( ::ParseVersion (pwszValue, &m_vVersion) ) )
		{
			return E_FAIL;
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"DIRECTMUSICVERSION") )
	{
		if( FAILED ( ::ParseVersion(pwszValue, &m_vDirectMusicVersion) ) )
		{
			return E_FAIL;
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"LANGUAGE") )
	{
		m_strLanguage = pwszValue;
		if( m_strLanguage.IsEmpty() == TRUE )
		{
			return E_OUTOFMEMORY;
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"AUTHOR") )
	{
		m_strAuthor = pwszValue;
		if( m_strAuthor.IsEmpty() == TRUE )
		{
			return E_OUTOFMEMORY;
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"COPYRIGHT") )
	{
		m_strCopyright = pwszValue;
		if( m_strCopyright.IsEmpty() == TRUE )
		{
			return E_OUTOFMEMORY;
		}
	}
	else if( 0 == _wcsicmp(pwszName, L"SUBJECT") )
	{
		m_strSubject = pwszValue;
		if( m_strSubject.IsEmpty() == TRUE )
		{
			return E_OUTOFMEMORY;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::ParseField

HRESULT CDirectMusicScript::ParseField( const WCHAR** ppwsz, DMUSProdListInfo* pListInfo )
{
	const WCHAR *pwsz = *ppwsz;
	::ParseSkipWhitespace( &pwsz );

	// Read name
	UINT cwch = ::ParseContinuousString( pwsz );
	if( !cwch )
	{
		*ppwsz = pwsz;
		return S_FALSE;
	}

	WCHAR* wstrName = new wchar_t[cwch + 1];
	if( !wstrName )
	{
		return E_OUTOFMEMORY;
	}
	wcsncpy( wstrName, pwsz, cwch );
	wstrName[cwch] = L'\0';
	pwsz += cwch;

	// Skip =
	::ParseSkipWhitespace( &pwsz );
	if( *pwsz++ != L'=' )
	{
		return E_FAIL;
	}
	::ParseSkipWhitespace( &pwsz );

	// Read value
	HRESULT hr = S_OK;
	if( *pwsz == L'"' )
	{
		cwch = ::ParseQuotedString( pwsz );
		if( !cwch )
		{
			return E_FAIL;
		}
		WCHAR* wstrValue = new wchar_t[cwch + 1];
		if( !wstrValue )
		{
			return E_OUTOFMEMORY;
		}
		hr = ::ReformatQuotedString( pwsz, wstrValue );
		if( SUCCEEDED ( hr ) )
		{
			wstrValue[cwch] = L'\0';
			pwsz += cwch;

			hr = FoundField( wstrName, wstrValue, pListInfo );
		}
		delete[] wstrValue;
	}
	else
	{
		cwch = ::ParseContinuousString( pwsz );
		if( !cwch )
		{
			return E_FAIL;
		}
		WCHAR* wstrValue = new wchar_t[cwch + 1];
		if( !wstrValue )
		{
			return E_OUTOFMEMORY;
		}
		wcsncpy( wstrValue, pwsz, cwch );
		wstrValue[cwch] = L'\0';
		pwsz += cwch;
		hr = FoundField( wstrName, wstrValue, pListInfo );
		delete[] wstrValue;
	}

	delete[] wstrName;

	if( SUCCEEDED ( hr ) )
	{
		*ppwsz = pwsz;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::ParseHeaderBlock

HRESULT CDirectMusicScript::ParseHeaderBlock( const WCHAR** ppwszSource, DMUSProdListInfo* pListInfo )
{
	if( !ppwszSource )
	{
		ASSERT( 0 );
		return E_FAIL;
	}
	const WCHAR *pwsz = *ppwszSource;

	::ParseSkipWhitespace( &pwsz );

	// Find opening tag
	static const WCHAR wszOpenBlock[] = L"<SCRIPT";
	static const UINT cwchOpenBlock = wcslen( wszOpenBlock );
	if( 0 != _wcsnicmp( pwsz, wszOpenBlock, cwchOpenBlock ) )
	{
		return E_FAIL;
	}
	pwsz += cwchOpenBlock;

	// Read fields
	HRESULT hr = S_OK;
	do
	{
		hr = ParseField( &pwsz, pListInfo );
	} while( hr == S_OK );

	if( FAILED( hr ) )
	{
		return hr;
	}

	// Find closing brace
	if( *pwsz++ != L'>' )
	{
		return E_FAIL;
	}

	*ppwszSource = pwsz;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::ReadSourceFromStream

HRESULT CDirectMusicScript::ReadSourceFromStream( IStream* pIStream )
{
	WCHAR* wstrSource;
	const WCHAR* wstrSourceAfterHeader;

	// Record the stream's current position
	LARGE_INTEGER li;
	ULARGE_INTEGER ulStart;
	ULARGE_INTEGER ulEnd;
	li.HighPart = 0;
	li.LowPart = 0;

	HRESULT hr = pIStream->Seek( li, STREAM_SEEK_CUR, &ulStart );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	ASSERT( ulStart.HighPart == 0 );	// We don't expect streams that big.
	DWORD dwSavedPos = ulStart.LowPart;

	// Get the stream's end and record the total size
	hr = pIStream->Seek( li, STREAM_SEEK_END, &ulEnd );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	ASSERT( ulEnd.HighPart == 0 );
	ASSERT( ulEnd.LowPart > dwSavedPos );
	DWORD cch = ulEnd.LowPart - dwSavedPos;

	// Go back to the start and copy the characters
	li.HighPart = 0;
	li.LowPart = dwSavedPos;
	hr = pIStream->Seek( li, STREAM_SEEK_SET, &ulStart );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	ASSERT( ulStart.LowPart == dwSavedPos );

	CHAR *paszSource = new CHAR[cch + 1];
	if( !paszSource )
	{
		return E_OUTOFMEMORY;
	}

	DWORD cbRead;
	hr = pIStream->Read( paszSource, cch, &cbRead );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return hr;
	}

	paszSource[cch] = '\0';

	// Convert the script source to wide characters
	wstrSource = new wchar_t[cch + 1];
	if( !wstrSource )
	{
		delete[] paszSource;
		return E_OUTOFMEMORY;
	}
	MultiByteToWideChar( CP_ACP, 0, paszSource, -1, wstrSource, cch + 1 );
	delete[] paszSource;

	// Store original name
	CString strOrigName = m_strName;

	// Initialize some fields
	m_strName.Empty();
	m_strAuthor.Empty();
	m_strSubject.Empty();
	m_strCopyright.Empty();

	// Parse the script header block
	wstrSourceAfterHeader = wstrSource;
	hr = ParseHeaderBlock( &wstrSourceAfterHeader, NULL );
	if( m_vDirectMusicVersion.dwVersionMS < 0x00080000 )
	{
		return E_FAIL;
	}

	if( m_strName.IsEmpty() )
	{
		// Script file does not contain name so use script's filename
		IDMUSProdPersistInfo* pIPersistInfo;

		if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
		{
			BSTR bstrFileName;

			if( SUCCEEDED ( pIPersistInfo->GetFileName( &bstrFileName ) ) )
			{
				TCHAR achFName[_MAX_FNAME];

				CString strFileName = bstrFileName;
				::SysFreeString( bstrFileName );

				_tsplitpath( strFileName, NULL, NULL, achFName, NULL );
				m_strName = achFName;
			}
			RELEASE( pIPersistInfo );
		}

		if( m_strName.IsEmpty() )
		{
			// Can't get filename so put back orig name
			m_strName = strOrigName;
		}
	}

	if( strOrigName.CompareNoCase( m_strName ) != 0 )
	{
		theApp.m_pScriptComponent->m_pIFramework->RefreshNode( this );

		// Notify connected nodes that Script name has changed
		theApp.m_pScriptComponent->m_pIFramework->NotifyNodes( this, SCRIPT_NameChange, NULL );
	}

	while( (*wstrSourceAfterHeader == L'\r')  || (*wstrSourceAfterHeader == L'\n') )
	{
		wstrSourceAfterHeader++;
	}
	
	m_strSource = wstrSourceAfterHeader;
	delete[] wstrSource;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::ReadListInfoFromStream

HRESULT CDirectMusicScript::ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidContainer;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidContainer, 0, sizeof(GUID) );

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SCRIPT_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;

			// Get Script GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidContainer, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidContainer, 0, sizeof(GUID) );
				}
			}

			// Get Script name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( fFoundFormat == FALSE )
	{
		// Check for legacy ascii text file format
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
		return ReadListInfoFromLegacyStream( pIStream, pListInfo );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidContainer, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::ReadListInfoFromLegacyStream

HRESULT CDirectMusicScript::ReadListInfoFromLegacyStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	// Initialize pListInfo fields
	pListInfo->bstrName = NULL;
	pListInfo->bstrDescriptor = NULL;
	memset( &pListInfo->guidObject, 0, sizeof(GUID) );

	WCHAR* wstrSource;
	const WCHAR* wstrSourceAfterHeader;

	// Record the stream's current position
	LARGE_INTEGER li;
	ULARGE_INTEGER ulStart;
	ULARGE_INTEGER ulEnd;
	li.HighPart = 0;
	li.LowPart = 0;

	HRESULT hr = pIStream->Seek( li, STREAM_SEEK_CUR, &ulStart );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	ASSERT( ulStart.HighPart == 0 );	// We don't expect streams that big.
	DWORD dwSavedPos = ulStart.LowPart;

	// Get the stream's end and record the total size
	hr = pIStream->Seek( li, STREAM_SEEK_END, &ulEnd );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	ASSERT( ulEnd.HighPart == 0 );
	ASSERT( ulEnd.LowPart > dwSavedPos );
	DWORD cch = ulEnd.LowPart - dwSavedPos;

	// Go back to the start and copy the characters
	li.HighPart = 0;
	li.LowPart = dwSavedPos;
	hr = pIStream->Seek( li, STREAM_SEEK_SET, &ulStart );
	if( FAILED ( hr ) )
	{
		return hr;
	}
	ASSERT( ulStart.LowPart == dwSavedPos );

	CHAR *paszSource = new CHAR[cch + 1];
	if( !paszSource )
	{
		return E_OUTOFMEMORY;
	}

	DWORD cbRead;
	hr = pIStream->Read( paszSource, cch, &cbRead );
	if( FAILED ( hr ) )
	{
		ASSERT( 0 );
		return hr;
	}

	paszSource[cch] = '\0';

	// Convert the script source to wide characters
	wstrSource = new wchar_t[cch + 1];
	if( !wstrSource )
	{
		delete[] paszSource;
		return E_OUTOFMEMORY;
	}
	MultiByteToWideChar( CP_ACP, 0, paszSource, -1, wstrSource, cch + 1 );
	delete[] paszSource;

	// Initialize name
	m_strName.Empty();

	// Parse the script header block
	wstrSourceAfterHeader = wstrSource;
	hr = ParseHeaderBlock( &wstrSourceAfterHeader, pListInfo );
	if( m_vDirectMusicVersion.dwVersionMS < 0x00080000 )
	{
		return E_FAIL;
	}

	if( m_strName.IsEmpty() )
	{
		// Script file does not contain name so use script's filename
		IDMUSProdPersistInfo* pIPersistInfo;

		if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
		{
			BSTR bstrFileName;

			if( SUCCEEDED ( pIPersistInfo->GetFileName( &bstrFileName ) ) )
			{
				TCHAR achFName[_MAX_FNAME];

				CString strFileName = bstrFileName;
				::SysFreeString( bstrFileName );

				_tsplitpath( strFileName, NULL, NULL, achFName, NULL );
				m_strName = achFName;
				pListInfo->bstrName = m_strName.AllocSysString();
			}

			RELEASE( pIPersistInfo );
		}
	}

	// Can't get a name!
	if( m_strName.IsEmpty() )
	{
		ASSERT( 0 );	// Should not happen
		hr = E_FAIL;
	}

	delete[] wstrSource;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::GetObjectDescriptor

HRESULT CDirectMusicScript::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidScript, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicScript, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::GetGUID

void CDirectMusicScript::GetGUID( GUID* pguidScript )
{
	if( pguidScript )
	{
		*pguidScript = m_guidScript;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::SetGUID

void CDirectMusicScript::SetGUID( GUID guidScript )
{
	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_SCRIPT_GUID );
	m_guidScript = guidScript;

	// Sync Script with DirectMusic
	SetModified( TRUE );
	SyncScriptWithDirectMusic();

	// Notify connected nodes that Script GUID has changed
	theApp.m_pScriptComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::GetVariableState

void CDirectMusicScript::GetVariableState( CTypedPtrList<CPtrList, VariableState*>& list )
{
	if( m_pIDMScript == NULL )
	{
		// Nothing to do
		return;
	}

	// Make sure the list is empty
	ASSERT( list.IsEmpty() );	// Should be empty!
	while( !list.IsEmpty() )
	{
		VariableState* pVariableState = static_cast<VariableState*>( list.RemoveHead() );
		delete pVariableState;
	}

	WCHAR awchVariableName[MAX_PATH];
	DMUS_SCRIPT_ERRORINFO ErrorInfo;

	int i = 0;
	CString strVariableName;
	BSTR bstrVariableName;
	bool fBypassVariable;

	while( m_pIDMScript->EnumVariable( i++, awchVariableName ) == S_OK )
	{
		// Bypass variables that are actually items in the Script's Container
		fBypassVariable = false;
		if( m_pIContainerNode )
		{
			IDMUSProdContainerInfo* pIContainerInfo;
			if( SUCCEEDED ( m_pIContainerNode->QueryInterface( IID_IDMUSProdContainerInfo, (void**)&pIContainerInfo ) ) )
			{
				strVariableName = awchVariableName;
				bstrVariableName = strVariableName.AllocSysString();

				IUnknown* pIDocRootNode;
				if( pIContainerInfo->FindDocRootFromScriptAlias(bstrVariableName, &pIDocRootNode) == S_OK )
				{
					fBypassVariable = true;
					RELEASE( pIDocRootNode );
				}

				RELEASE( pIContainerInfo );
			}
		}
		if( fBypassVariable )
		{
			continue;
		}

		VariableState* pVariableState = new VariableState;
		if( pVariableState )
		{
			// Store variable name
			pVariableState->m_strName = awchVariableName;

			// Initialize ErrorInfo struct
			memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
			ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

			// Get current value
			HRESULT hr = m_pIDMScript->GetVariableVariant( awchVariableName, &pVariableState->m_Variant, &ErrorInfo );
			if( SUCCEEDED ( hr ) )
			{
				list.AddTail( pVariableState );
			}
			else 
			{
				DisplayScriptError( &ErrorInfo, hr );
				delete pVariableState;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::SetVariableState

void CDirectMusicScript::SetVariableState( CTypedPtrList<CPtrList, VariableState*>& list )
{
	if( m_pIDMScript == NULL )
	{
		// Nothing to do
		return;
	}

	HRESULT hr;

	WCHAR awchVariableName[MAX_PATH];
	DMUS_SCRIPT_ERRORINFO ErrorInfo;

	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		VariableState* pVariableState = list.GetNext( pos );

		// Convert the variable name to wide characters
		MultiByteToWideChar( CP_ACP, 0, pVariableState->m_strName, -1, awchVariableName, MAX_PATH );

		// Initialize ErrorInfo struct
		memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
		ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

		BOOL fSetRef = FALSE;
		if( pVariableState->m_Variant.vt == VT_UNKNOWN
		||  pVariableState->m_Variant.vt == VT_DISPATCH )
		{
			fSetRef = TRUE;
		}

		hr = m_pIDMScript->SetVariableVariant( awchVariableName, pVariableState->m_Variant, fSetRef, &ErrorInfo );
		if( hr == DMUS_E_SCRIPT_ERROR_IN_SCRIPT )
		{
			// At this time only report DMUS_E_SCRIPT_ERROR_IN_SCRIPT errors
			DisplayScriptError( &ErrorInfo, hr );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicScript::DisplayScriptError

void CDirectMusicScript::DisplayScriptError( DMUS_SCRIPT_ERRORINFO* pErrorInfo, HRESULT hrFromScript )
{
	ASSERT( pErrorInfo != NULL );

	if( hrFromScript != DMUS_E_SCRIPT_ERROR_IN_SCRIPT )
	{
		// Set FileName
		BSTR bstrFileName;
		if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->GetNodeFileName( this, &bstrFileName ) ) )
		{
			CString strFileName = bstrFileName;
			::SysFreeString( bstrFileName );
			int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
			}
			MultiByteToWideChar( CP_ACP, 0, strFileName, -1, pErrorInfo->wszSourceFile, DMUS_MAX_FILENAME );
		}

		// Set HRESULT
		pErrorInfo->hr = hrFromScript;
	}

	IDMUSProdComponent* pIComponent;
	if( SUCCEEDED ( theApp.m_pScriptComponent->m_pIFramework->FindComponent( CLSID_ScriptComponent,  &pIComponent ) ) )
	{
		IDMUSProdDebugScript* pIDebugScript;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdDebugScript, (void**)&pIDebugScript ) ) )
		{
			pIDebugScript->DisplayScriptError( pErrorInfo );

			RELEASE( pIDebugScript );
		}
	
		RELEASE( pIComponent );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptComponent.cpp ===
// ScriptComponent.cpp : implementation file
//

#include "stdafx.h"

#include "ScriptDesignerDLL.h"
#include "Script.h"
#include "ScriptRef.h"
#include <ContainerDesigner.h>
#include <dmusici.h>


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent constructor/destructor 

CScriptComponent::CScriptComponent()
{
    m_dwRef = 0;
	
	m_pIFramework = NULL;
	m_pIDMPerformance = NULL;

	m_pIScriptDocType8 = NULL;
	m_pIConductor = NULL;
	m_pIContainerComponent = NULL;
	m_nFirstImage = 0;
	
	m_fMenuWasAdded = FALSE;
	m_pDebugDlg = NULL;
	m_pDebugDlgWP = NULL;
	m_pLogTool = NULL;

	m_nNextScript = 0;

	m_cfProducerFile = 0;
	m_cfScript = 0;
	m_cfScriptList = 0;

	m_fDisplayMessageText = FALSE;
	m_fEndMessageTextThread = FALSE;
	m_hEvent_WakeUpMessageTextThread = NULL;
	m_hEvent_ExitMessageTextThread = NULL;
	m_hMessageTextThread = NULL;

	// Initialize critical sections
	::InitializeCriticalSection( &m_CrSecMessageText );
	::InitializeCriticalSection( &m_CrSecDebugDlg );
}

CScriptComponent::~CScriptComponent()
{
	if( m_pDebugDlgWP )
	{
		delete m_pDebugDlgWP;
		m_pDebugDlgWP = NULL;
	}

	// Make sure MessageText thread is shut down properly
	// Should have happened in CleanUp()
	ASSERT( m_hEvent_WakeUpMessageTextThread == NULL );
	ASSERT( m_hEvent_ExitMessageTextThread == NULL );
	ASSERT( m_hMessageTextThread == NULL );
	ASSERT( m_lstMessageText.IsEmpty() );

	ReleaseAll();

	// Clean up the critical sections
	::DeleteCriticalSection( &m_CrSecMessageText );
	::DeleteCriticalSection( &m_CrSecDebugDlg );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::ReleaseAll

void CScriptComponent::ReleaseAll( void )
{
 	CDirectMusicScript* pScript;
	while( !m_lstScripts.IsEmpty() )
	{
		pScript = static_cast<CDirectMusicScript*>( m_lstScripts.RemoveHead() );
		RELEASE( pScript );
	}

	RELEASE( m_pIFramework );
	RELEASE( m_pIScriptDocType8 );
	RELEASE( m_pLogTool );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
	RELEASE( m_pIContainerComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IUnknown implementation

HRESULT CScriptComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdMenu) )
    {
        AddRef();
        *ppvObj = (IDMUSProdMenu *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdDebugScript) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDebugScript *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdPortNotify))
	{
        AddRef();
		*ppvObj = (IDMUSProdPortNotify *)this;
        return S_OK;
	}
	
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CScriptComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CScriptComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdComponent::Initialize

HRESULT CScriptComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	theApp.m_pScriptComponent = this;
//	theApp.m_pScriptComponent->AddRef();	intentionally missing

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			RELEASE( pIComponent );
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// Get IDMUSProdComponent for Container Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_ContainerComponent, &m_pIContainerComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONTAINER_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Create log tool
	m_pLogTool = new CLogTool( (IDMUSProdDebugScript *)this );
	if( m_pLogTool == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add log tool to performance tool graph
	IDirectMusicGraph* pIDMGraph = NULL;
	if( FAILED ( m_pIDMPerformance->GetGraph( &pIDMGraph ) ) )
	{
		// No tool graph in the performance - we need to add one
		if( SUCCEEDED(CoCreateInstance(
				CLSID_DirectMusicGraph,
				NULL,
				CLSCTX_INPROC, 
				IID_IDirectMusicGraph,
				(void**)&pIDMGraph
			)))
		{
			if( FAILED( m_pIDMPerformance->SetGraph( pIDMGraph ) ) )
			{
				RELEASE( pIDMGraph );
			}
		}
	}

	// Check if we were unable to find or create a tool graph
	if( pIDMGraph == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_LOGTOOL, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if( FAILED ( pIDMGraph->InsertTool( m_pLogTool, NULL, 0, 9999 ) ) )
	{
		pIDMGraph->Release();
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_LOGTOOL, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIDMGraph );

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .spp file 
	CString strExt = _T(".spp");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfScript, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add "Message Window" item to Add-Ins menu 
	if( FAILED ( pIFramework->AddMenuItem( (IDMUSProdMenu *)this ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_MENUITEM, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	else
	{
		m_fMenuWasAdded = TRUE;
	}

	// Create MessageText thread
	if( StartMessageTextThread() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MESSAGE_WINDOW_THREAD, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIScriptDocType8 = new CScriptDocType;
    if( m_pIScriptDocType8 == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_OUTOFMEMORY;
	}

	m_pIScriptDocType8->AddRef();

	if( FAILED ( pIFramework->AddDocType(m_pIScriptDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdComponent::CleanUp

HRESULT CScriptComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fDisplayMessageText = FALSE;
	
	// Remove log tool from performance tool graph
	if( m_pLogTool )
	{
		IDirectMusicGraph* pIDMGraph;
		if( SUCCEEDED ( m_pIDMPerformance->GetGraph( &pIDMGraph ) ) )
		{
			pIDMGraph->RemoveTool( m_pLogTool );
			RELEASE( pIDMGraph );
		}
	}

	// Make sure MessageText thread is shut down properly
	EndMessageTextThread();

	// Cleanup m_lstMessageText
	::EnterCriticalSection( &m_CrSecMessageText );
	CString* pstrMessageText;
	while( !m_lstMessageText.IsEmpty() )
	{
		pstrMessageText = static_cast<CString*>( m_lstMessageText.RemoveHead() );
		delete pstrMessageText;
	}
	::LeaveCriticalSection( &m_CrSecMessageText );

	// Close "Message Window"
	if( m_pDebugDlg )
	{
		m_pDebugDlg->DestroyWindow();
		delete m_pDebugDlg;
		m_pDebugDlg = NULL;
	}

	// Remove "Message Window" menu item
	if( m_fMenuWasAdded )
	{
		m_pIFramework->RemoveMenuItem( (IDMUSProdMenu *)this );
		m_fMenuWasAdded = FALSE;
	}

	// Release references to scripts
	CDirectMusicScript *pScript;
	while( !m_lstScripts.IsEmpty() )
	{
		pScript = static_cast<CDirectMusicScript*>( m_lstScripts.RemoveHead() );
		RELEASE( pScript );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdComponent::GetName

HRESULT CScriptComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_SCRIPT_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CScriptComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_ScriptRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create ScriptRefNode
	CScriptRef* pScriptRef = new CScriptRef;
	if( pScriptRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pScriptRef;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdComponent::OnActivateApp

HRESULT CScriptComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CScriptComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicScript* pScript;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Script 
	pScript = new CDirectMusicScript;
	if( pScript == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Create the Undo Manager
	if( pScript->CreateUndoMgr() == FALSE )
	{
		pScript->Release();
		return E_OUTOFMEMORY;
	}

	// Load Script file
	hr = pScript->Load( pIStream );
	if( FAILED ( hr ) )
	{
		pScript->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pScript;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdMenu implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdMenu::GetMenuText

HRESULT CScriptComponent::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strText;
	strText.LoadString( IDS_DEBUG_WINDOW_MENU_TEXT );

	*pbstrText = strText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdMenu::GetMenuHelpText

HRESULT CScriptComponent::GetMenuHelpText( BSTR* pbstrHelpText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strHelpText;
	strHelpText.LoadString( IDS_DEBUG_WINDOW_MENU_HELP_TEXT );

	*pbstrHelpText = strHelpText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdMenu::OnMenuInit

HRESULT CScriptComponent::OnMenuInit( HMENU hMenu, UINT nMenuID )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::EnableMenuItem( hMenu, nMenuID, MF_ENABLED );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdMenu::OnMenuSelect

HRESULT CScriptComponent::OnMenuSelect()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pDebugDlg )
	{
		// Window is already open
		if( m_pDebugDlg->IsIconic() ) 
		{
			m_pDebugDlg->ShowWindow( SW_RESTORE );     // If iconic, restore the main window
		}
		m_pDebugDlg->SetForegroundWindow();
		return S_OK;
	}

	// Create "Message Window"
	m_pDebugDlg = new CDebugDlg;
	if( m_pDebugDlg == NULL )
	{
		return E_OUTOFMEMORY;
	}

	if( m_pDebugDlg->CreateEx( WS_EX_TOPMOST, AfxRegisterWndClass(0), "Message Window",
							   (WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN),
							   0, 0,
							   400, 200,
							   NULL	/*pParentWnd*/,
							   NULL,
							   NULL ) )
	{
		HICON hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SCRIPT_DOCTYPE) );
		if( hIcon )
		{
			m_pDebugDlg->SetIcon( hIcon, TRUE );
		}
		if( m_pDebugDlgWP )
		{
			m_pDebugDlg->SetWindowPlacement( m_pDebugDlgWP );
		}
		return S_OK;
	}

	delete m_pDebugDlg;
	m_pDebugDlg = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdDebugScript implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdDebugScript::DisplayScriptError

HRESULT CScriptComponent::DisplayScriptError( void* pErrorInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pErrorInfo == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_fDisplayMessageText == FALSE
	||  m_pDebugDlg == NULL
	||  m_pDebugDlg->GetSafeHwnd() == NULL )
	{
		return E_ACCESSDENIED;
	}

	DMUS_SCRIPT_ERRORINFO* pScriptErrorInfo = (DMUS_SCRIPT_ERRORINFO *)pErrorInfo;

	CString strText;
	CString strTemp;
	CString strLineNbr;

	strLineNbr.Format( "<%04i> ", m_pDebugDlg->GetNextLineNbr() );

	strText = _T( "Script error in " );
	strText += pScriptErrorInfo->wszSourceFile;
	if( pScriptErrorInfo->wszSourceLineText[0] )
	{
		strTemp.Format( ", line %u, column %i.", pScriptErrorInfo->ulLineNumber, pScriptErrorInfo->ichCharPosition );
	}
	else
	{
		strTemp.Format( ", line %u.", pScriptErrorInfo->ulLineNumber );
	}
	CString* pstrText1 = new CString( strLineNbr + strText + strTemp );

	CString* pstrText2 = NULL;
	if( pScriptErrorInfo->wszSourceLineText[0] )
	{
		strText = _T( "Near: " );
		strText += pScriptErrorInfo->wszSourceLineText;
		pstrText2 = new CString( strLineNbr + strText );
	}

	CString* pstrText3 = NULL;
	if( pScriptErrorInfo->wszSourceComponent[0] 
	||  pScriptErrorInfo->wszDescription[0] )
	{
		strText = pScriptErrorInfo->wszSourceComponent;
		strText += _T( ": " );
		strText += pScriptErrorInfo->wszDescription;
		pstrText3 = new CString( strLineNbr + strText );
	}

	strText.Format( "Error Code: 0x%08X", pScriptErrorInfo->hr );
	CString* pstrText4 = new CString( strLineNbr + strText );

	// Place text in m_lstMessageText
	// Will be displayed by MessageTextThreadProc()
	::EnterCriticalSection( &m_CrSecMessageText );
	if( pstrText1 )
	{
		m_lstMessageText.AddTail( pstrText1 );
	}
	if( pstrText2 )
	{
		m_lstMessageText.AddTail( pstrText2 );
	}
	if( pstrText3 )
	{
		m_lstMessageText.AddTail( pstrText3 );
	}
	if( pstrText4 )
	{
		m_lstMessageText.AddTail( pstrText4 );
	}
	::LeaveCriticalSection( &m_CrSecMessageText );

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdDebugScript::DisplayText

HRESULT CScriptComponent::DisplayText( WCHAR* pwszText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fDisplayMessageText == FALSE
	||  m_pDebugDlg == NULL
	||  m_pDebugDlg->GetSafeHwnd() == NULL )
	{
		return E_ACCESSDENIED;
	}

	CString* pstrText = new CString;
	
	if( pstrText )
	{
		pstrText->Format( "<%04i> ", m_pDebugDlg->GetNextLineNbr() );
		*pstrText += pwszText;
		
		// Place text in m_lstMessageText
		// Will be displayed by MessageTextThreadProc()
		::EnterCriticalSection( &m_CrSecMessageText );
		m_lstMessageText.AddTail( pstrText );
		::LeaveCriticalSection( &m_CrSecMessageText );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdPortNotify implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdPortNotify::OnOutputPortsChanged

HRESULT CScriptComponent::OnOutputPortsChanged( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	// Add log tool to performance tool graph
	if( m_pIDMPerformance
	&&  m_pLogTool )
	{
		IDirectMusicGraph* pIDMGraph = NULL;

		if( FAILED ( m_pIDMPerformance->GetGraph( &pIDMGraph ) ) )
		{
			// No tool graph in the performance - we need to add one
			if( SUCCEEDED ( CoCreateInstance( CLSID_DirectMusicGraph, NULL, CLSCTX_INPROC, 
											  IID_IDirectMusicGraph, (void**)&pIDMGraph ) ) )
			{
				if( FAILED( m_pIDMPerformance->SetGraph( pIDMGraph ) ) )
				{
					RELEASE( pIDMGraph );
				}
			}
		}

		// Do we have a toolgraph?
		if( pIDMGraph )
		{
			// If yes, insert the log tool
			hr = pIDMGraph->InsertTool( m_pLogTool, NULL, 0, 9999 );
			
			RELEASE( pIDMGraph );
		}

	}

    // Re-synchronize the scripts with the new audiopath
	POSITION pos = m_lstScripts.GetHeadPosition();
	while( pos )
	{
		m_lstScripts.GetNext( pos )->SyncScriptWithDirectMusic();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent IDMUSProdPortNotify::OnOutputPortsRemoved

HRESULT CScriptComponent::OnOutputPortsRemoved( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// MessageTextThread routines

/////////////////////////////////////////////////////////////////////////////
// MessageTextThreadProc

UINT AFX_CDECL MessageTextThreadProc( LPVOID pParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pParam);

	if ( theApp.m_pScriptComponent == NULL )
	{
		ASSERT( 0 );
		return UINT_MAX;    // illegal parameter
	}

	CString* pstrMessageText;

	BOOL fInCritSeq = FALSE;

	try {
	while( 1 )
	{
		DWORD dwRes;
		dwRes = WaitForSingleObject( theApp.m_pScriptComponent->m_hEvent_WakeUpMessageTextThread, 300 );

		// Time to exit?
		if( theApp.m_pScriptComponent->m_fEndMessageTextThread )
		{
			//TRACE( "MessageTextThreadProc: m_fEndMessageTextThread is TRUE.\n" );
			break;
		}

		// Display text in Message Window
		if( (dwRes == WAIT_OBJECT_0)
		||  (dwRes == WAIT_TIMEOUT) )
		{
			// See if m_lstMessageText contains text to be displayed
			if( !theApp.m_pScriptComponent->m_lstMessageText.IsEmpty() )
			{
				int i = 1;
				int iMax = theApp.m_pScriptComponent->m_fDisplayMessageText ? 100 : 250;

				// Create the "list"
				CTypedPtrList<CPtrList, CString*>* plstText = new CTypedPtrList<CPtrList, CString*>;

				// Transfer text from m_lstMessageText to "plstText"
				::EnterCriticalSection( &theApp.m_pScriptComponent->m_CrSecMessageText );
				fInCritSeq = TRUE;
				while( !theApp.m_pScriptComponent->m_lstMessageText.IsEmpty() )
				{
					pstrMessageText = static_cast<CString*>( theApp.m_pScriptComponent->m_lstMessageText.RemoveHead() );
					
					if( theApp.m_pScriptComponent->m_fDisplayMessageText )
					{
						plstText->AddTail( pstrMessageText );
					}
					else
					{
						delete pstrMessageText;
					}

					if( ++i >= iMax )
					{
						break;
					}
				}
				::LeaveCriticalSection( &theApp.m_pScriptComponent->m_CrSecMessageText );
				fInCritSeq = FALSE;

				::EnterCriticalSection( &theApp.m_pScriptComponent->m_CrSecDebugDlg );
				if( !plstText->IsEmpty() )
				{
					// Display text in "list"
					::PostMessage( theApp.m_pScriptComponent->m_pDebugDlg->GetSafeHwnd(), WM_DISPLAY_MESSAGE_TEXT, 0, (LPARAM)plstText );
				}
				else
				{
					delete plstText;
				}
				::LeaveCriticalSection( &theApp.m_pScriptComponent->m_CrSecDebugDlg );
			}
		}
		else
		{
			//TRACE( "MessageTextThreadProc: break out early.\n" );
			break;
		}
		// Go back and WaitForSingleObject again.
	}
	}
	catch( ... )
	{
		TRACE("MessageTextThreadProc: caught exception. exiting.\n");
	}

	if( fInCritSeq )
	{
		::LeaveCriticalSection( &theApp.m_pScriptComponent->m_CrSecMessageText );
	}

	if( theApp.m_pScriptComponent->m_hEvent_ExitMessageTextThread )
	{
		//TRACE( "MessageTextThreadProc: setting exit event.\n" );
		::SetEvent( theApp.m_pScriptComponent->m_hEvent_ExitMessageTextThread );
	}

	//TRACE( "MessageTextThreadProc exiting.\n" );
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::StartMessageTextThread

BOOL CScriptComponent::StartMessageTextThread( void )
{
	// Make sure MessageText thread is shut down properly
	EndMessageTextThread();

	// Make sure MessageText list is empty
	::EnterCriticalSection( &m_CrSecMessageText );
	while( !m_lstMessageText.IsEmpty() )
	{
		CString* pstrMessageText = static_cast<CString*>( m_lstMessageText.RemoveHead() );
		delete pstrMessageText;
	}
	::LeaveCriticalSection( &m_CrSecMessageText );

	// Create m_hEvent_WakeUpMessageTextThread event
	if( m_hEvent_WakeUpMessageTextThread == NULL )
	{
		m_hEvent_WakeUpMessageTextThread = ::CreateEvent( NULL, FALSE, FALSE, NULL );
		if( m_hEvent_WakeUpMessageTextThread == NULL )
		{
			return FALSE;
		}
	}

	// Create m_hEvent_ExitMessageTextThread event
	if( m_hEvent_ExitMessageTextThread == NULL )
	{
		m_hEvent_ExitMessageTextThread = ::CreateEvent( NULL, FALSE, FALSE, NULL );
		if( m_hEvent_ExitMessageTextThread == NULL )
		{
			return FALSE;
		}
	}

	// Start Message Window thread
	ASSERT( m_hMessageTextThread == NULL );
	m_fEndMessageTextThread = FALSE;
	CWinThread* pThread = ::AfxBeginThread( MessageTextThreadProc, this, THREAD_PRIORITY_LOWEST );
	if( pThread == NULL )
	{
		return FALSE;
	}
	m_hMessageTextThread = pThread->m_hThread;

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::EndMessageTextThread

BOOL CScriptComponent::EndMessageTextThread( void )
{
	if( m_hMessageTextThread )
	{
		DWORD dwExitCode;
		if( GetExitCodeThread( m_hMessageTextThread, &dwExitCode ) )
		{
			if( dwExitCode == STILL_ACTIVE )
			{
				ASSERT( m_hEvent_WakeUpMessageTextThread != NULL );
				ASSERT( m_hEvent_ExitMessageTextThread != NULL );

				// Signal the MessageText thread so it can exit
				m_fEndMessageTextThread = TRUE;
				::SetEvent( m_hEvent_WakeUpMessageTextThread );

				// Wait for the MessageText thread to exit
				::WaitForSingleObject( m_hEvent_ExitMessageTextThread, 5000 );
			}
		}

		m_hMessageTextThread = NULL;
	}

	// Close m_hEvent_WakeUpMessageTextThread
	if( m_hEvent_WakeUpMessageTextThread )
	{
		::CloseHandle( m_hEvent_WakeUpMessageTextThread );
		m_hEvent_WakeUpMessageTextThread = NULL;
	}

	// Close m_hEvent_ExitMessageTextThread
	if( m_hEvent_ExitMessageTextThread )
	{
		::CloseHandle( m_hEvent_ExitMessageTextThread );
		m_hEvent_ExitMessageTextThread = NULL;
	}

	// Reinitialize to FALSE
	m_fEndMessageTextThread = FALSE;

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::AddNodeImageLists

HRESULT CScriptComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 4, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SCRIPT_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SCRIPT_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SCRIPTREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SCRIPTREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::RegisterClipboardFormats

BOOL CScriptComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfScript = ::RegisterClipboardFormat( CF_SCRIPT );
	m_cfScriptList = ::RegisterClipboardFormat( CF_SCRIPTLIST );

	if( m_cfProducerFile == 0
	||  m_cfScript == 0
	||  m_cfScriptList == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::GetScriptImageIndex

HRESULT CScriptComponent::GetScriptImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_SCRIPT_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::GetScriptRefImageIndex

HRESULT CScriptComponent::GetScriptRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_SCRIPTREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::AddToScriptFileList

void CScriptComponent::AddToScriptFileList( CDirectMusicScript* pScript )
{
	if( pScript )
	{
		GUID guidScript;
		pScript->GetGUID( &guidScript );

		// Prevent duplicate object GUIDs
		GUID guidScriptList;
		POSITION pos = m_lstScripts.GetHeadPosition();
		while( pos )
		{
			CDirectMusicScript* pScriptList = m_lstScripts.GetNext( pos );

			pScriptList->GetGUID( &guidScriptList );
			if( ::IsEqualGUID( guidScriptList, guidScript ) )
			{
				::CoCreateGuid( &guidScript );
				pScript->SetGUID( guidScript );
				break;
			}
		}

		// Add to list
		pScript->AddRef();
		m_lstScripts.AddTail( pScript );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptComponent::RemoveFromScriptFileList

void CScriptComponent::RemoveFromScriptFileList( CDirectMusicScript* pScript )
{
	if( pScript )
	{
		// Remove from list
		POSITION pos = m_lstScripts.Find( pScript );
		if( pos )
		{
			m_lstScripts.RemoveAt( pos );
			pScript->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\Script.h ===
#ifndef __SCRIPT_H__
#define __SCRIPT_H__

// Script.h : header file
//

#include "ScriptComponent.h"
#include "ScriptDocType.h"
#include <RiffStrm.h>


struct VariableState
{
	VariableState()
	{
		VariantInit( &m_Variant );
	}

	~VariableState()
	{
		VariantClear( &m_Variant );
	}

	CString		m_strName;		// Name of variable
	VARIANT		m_Variant;		// Value of variable
};


class CDirectMusicScript;

//////////////////////////////////////////////////////////////////////
//  CScriptPropPageManager

class CScriptPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabScriptScript;
friend class CTabScriptInfo;

public:
	CScriptPropPageManager();
	virtual ~CScriptPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabScriptScript*			m_pTabScript;
	CTabScriptInfo*				m_pTabInfo;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicScript

class CDirectMusicScript : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject,
						   public IDMUSProdNotifySink
{
friend class CScriptCtrl;
friend class CScriptDlg;
friend class CEditSource;
friend class CTabScriptScript;
friend class CTabScriptInfo;

public:
    CDirectMusicScript();
	~CDirectMusicScript();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData );

	//Additional functions
protected:
	HRESULT LoadScript( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT SaveScript( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT SaveHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveLanguage( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveVersion( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveDirectMusicVersion( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveSource( IDMUSProdRIFFStream* pIRiffStream );

	HRESULT ReadSourceFromStream( IStream* pIStream );
	HRESULT ParseHeaderBlock( const WCHAR **ppwszSource, DMUSProdListInfo* pListInfo );
	HRESULT ParseField( const WCHAR **ppwsz, DMUSProdListInfo* pListInfo );
	HRESULT FoundField( const WCHAR *pwszName, const WCHAR *pwszValue, DMUSProdListInfo* pListInfo );

    HRESULT SaveScriptSource( IStream* pIStream );

	void GetVariableState( CTypedPtrList<CPtrList, VariableState*>& list );
	void SetVariableState( CTypedPtrList<CPtrList, VariableState*>& list );

public:
	HRESULT ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
	HRESULT ReadListInfoFromLegacyStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
    HRESULT GetObjectDescriptor( void* pObjectDesc );

public:
	HRESULT CreateEmptyContainer();
	BOOL CreateUndoMgr();
	void SetModified( BOOL fModified );
	void SyncScriptEditor( DWORD dwFlags );
	HRESULT SyncScriptWithDirectMusic();
	void DisplayScriptError( DMUS_SCRIPT_ERRORINFO* pErrorinfo, HRESULT hrFromScript );
	void GetGUID( GUID* pguidScript );
	void SetGUID( GUID guidScript );

private:
    DWORD				m_dwRef;
	BOOL				m_fModified;

	CJazzUndoMan*		m_pUndoMgr;

	IDirectMusicScript*	m_pIDMScript;

	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;
	IDMUSProdNode*		m_pIContainerNode;

	HWND				m_hWndEditor;
	bool				m_fDeletingContainer;
	bool				m_fInitializingVariables;

	CTypedPtrList<CPtrList, VariableState*> m_lstLastKnownVariableStates;

public:
	CString				m_strOrigFileName;
	CScriptCtrl*		m_pScriptCtrl;
	IDMUSProdNode*		m_pINodeBeingDeleted;
	IDMUSProdProject*	m_pIProject;

private:
	// Persisted for DirectMusic
	DWORD				m_dwFlagsDM;
	GUID				m_guidScript;
	DMUS_VERSION        m_vVersion;
	DMUS_VERSION		m_vDirectMusicVersion;
    CString				m_strName;
    CString				m_strAuthor;
    CString				m_strCopyright;
    CString				m_strSubject;
	CString				m_strLanguage;
    CString				m_strSource;
};

#endif // __SCRIPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptCtl.cpp ===
// ScriptCtl.cpp : Implementation of the CScriptCtrl ActiveX Control class.

#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "Script.h"
#include "ScriptCtl.h"
#include "ScriptRef.h"
#include "ScriptPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CScriptCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CScriptCtrl, COleControl)
	//{{AFX_MSG_MAP(CScriptCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_COMMAND(IDM_CALL_ROUTINE, OnCallRoutine)
	ON_UPDATE_COMMAND_UI(IDM_CALL_ROUTINE, OnUpdateCallRoutine)
	ON_UPDATE_COMMAND_UI(IDM_SET_VARIABLE, OnUpdateSetVariable)
	ON_COMMAND(IDM_SET_VARIABLE, OnSetVariable)
	ON_COMMAND(IDM_HELP_SCRIPT_API, OnHelpScriptAPI)
	ON_COMMAND(IDM_HELP_SCRIPT_LANGUAGE, OnHelpScriptLanguage)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CScriptCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CScriptCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CScriptCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CScriptCtrl, COleControl)
	//{{AFX_EVENT_MAP(CScriptCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl Interface map

BEGIN_INTERFACE_MAP(CScriptCtrl, COleControl)
    INTERFACE_PART(CScriptCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CScriptCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CScriptCtrl, 1)
	PROPPAGEID(CScriptPropPage::guid)
END_PROPPAGEIDS(CScriptCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CScriptCtrl, "SCRIPTDESIGNER.ScriptCtrl.1",
	0xd135db58, 0x66ed, 0x11d3, 0xb4, 0x5d, 0, 0x10, 0x5a, 0x27, 0x96, 0xde)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CScriptCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DScript =
		{ 0xd135db56, 0x66ed, 0x11d3, { 0xb4, 0x5d, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };
const IID BASED_CODE IID_DScriptEvents =
		{ 0xd135db57, 0x66ed, 0x11d3, { 0xb4, 0x5d, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwScriptOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CScriptCtrl, IDS_SCRIPT, _dwScriptOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::CScriptCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CScriptCtrl

BOOL CScriptCtrl::CScriptCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SCRIPT,
			IDB_SCRIPT,
			afxRegApartmentThreading,
			_dwScriptOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::CScriptCtrl - Constructor

CScriptCtrl::CScriptCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DScript, &IID_DScriptEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DScript;
	m_piidEvents = &IID_DScriptEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pScriptDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_hAcceleratorTable	= NULL;
	m_hKeyStatusBar = NULL;
	m_pScript = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::~CScriptCtrl - Destructor

CScriptCtrl::~CScriptCtrl()
{
	RELEASE( m_pScript );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CScriptCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CScriptCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CScriptCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CScriptCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::QueryInterface

STDMETHODIMP CScriptCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CScriptCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::AttachObjects implementation

HRESULT CScriptCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_ScriptRefNode ) )
	{
		CScriptRef* pScriptRef = (CScriptRef *)pINode;
		ASSERT( pScriptRef->m_pScript != NULL );
		pThis->m_pScript = pScriptRef->m_pScript;
	}
	else
	{
		pThis->m_pScript = (CDirectMusicScript *)pINode;
	}

	ASSERT( pThis->m_pScript != NULL );
	pThis->m_pScript->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnInitMenuFilePrint

HRESULT CScriptCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnFilePrint

HRESULT CScriptCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CScriptCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnFilePrintPreview

HRESULT CScriptCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnViewProperties

HRESULT CScriptCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pScriptDlg )
	{
		if( pThis->m_pScriptDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XEditor::OnF1Help

HRESULT CScriptCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CScriptCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/ScriptDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CScriptCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CScriptCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_pScriptDlg )
	{
		// VK_R (Call Routine)
		// VK_E (Set Variable)
		if( (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x52)  
		||  (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x45) 
		||  (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x59) 
		||  (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x5A) )  
		{
			// Translate CTRL + R when any control in the editor has focus
			// Translate CTRL + E when any control in the editor has focus
			// Translate CTRL + Y when any control in the editor has focus
			// Translate CTRL + Z when any control in the editor has focus
			CWnd* pWnd = pThis->GetFocus();
			if( pThis == pWnd
			||  pThis->IsChild(pWnd) ) 
			{
				if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
				{
					return S_OK;
				}
			}
		}

		// Everything else
		else
		{
			// Translate everything else only when the source edit control has focus
			if( ::IsWindow(pThis->m_pScriptDlg->m_editSource.m_hWnd) )
			{
				HWND hwndFocus = ::GetFocus();
				if( pThis->m_pScriptDlg->m_editSource.m_hWnd == hwndFocus )
				{
					if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
					{
						return S_OK;
					}
				}
			}
		}
	}

//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CScriptCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CScriptCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnDraw - Drawing function

void CScriptCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::DoPropExchange - Persistence support

void CScriptCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnResetState - Reset control to default state

void CScriptCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CScriptAbout dialog used for Script Editor About Box

class CScriptAbout : public CDialog
{
public:
	CScriptAbout();

// Dialog Data
	//{{AFX_DATA(CScriptAbout)
	enum { IDD = IDD_ABOUTBOX_SCRIPT };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScriptAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CScriptAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CScriptAbout::CScriptAbout() : CDialog(CScriptAbout::IDD)
{
	//{{AFX_DATA_INIT(CScriptAbout)
	//}}AFX_DATA_INIT
}

void CScriptAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScriptAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CScriptAbout, CDialog)
	//{{AFX_MSG_MAP(CScriptAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CScriptAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_SCRIPT_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::AboutBox - Display an "About" box to the user

void CScriptCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CScriptAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnHideToolBars

void CScriptCtrl::OnHideToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	theApp.m_pScriptComponent->m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );
	m_hKeyStatusBar = NULL;

	COleControl::OnHideToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnShowToolBars

void CScriptCtrl::OnShowToolBars() 
{
	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Create status bar panes if they don't already exist
	if( m_hKeyStatusBar == NULL )
	{
		theApp.m_pScriptComponent->m_pIFramework->SetNbrStatusBarPanes( 1, SBLS_EDITOR, &m_hKeyStatusBar );
		theApp.m_pScriptComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 18 );
	}

	COleControl::OnShowToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnGetInPlaceMenu

HMENU CScriptCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnCreate

int CScriptCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Cut down on flicker when redrawing Script editor
	ModifyStyle( 0, WS_CLIPCHILDREN, 0 );
	CWnd* pWndParent = GetParent();
	if( pWndParent )
	{
		pWndParent->ModifyStyle( 0, WS_CLIPCHILDREN, 0 );
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SCRIPT_EDITOR) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SCRIPT_ACCELS) );

	// Create control's dialog
	m_pScriptDlg = new CScriptDlg;
	if( m_pScriptDlg == NULL )
	{
		return -1;
	}

	m_pScript->m_pScriptCtrl = this;

	m_pScriptDlg->m_pScript = m_pScript;
	m_pScriptDlg->m_pScriptCtrl = this;
	m_pScriptDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL );
	m_pScriptDlg->OnInitialUpdate();
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnDestroy

void CScriptCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}

	ASSERT( m_pScript != NULL );

	m_pScript->m_pScriptCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnSize

void CScriptCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSize( nType, cx, cy );

	m_pScriptDlg->MoveWindow( 0, 0, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditUndo

void CScriptCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	// Make sure we have the latest text
	// Necessary because sync takes place in KillFocus 
	// and undo may have been initiated by Alt+E/Alt+U or Ctrl+Z
	if( m_pScriptDlg )
	{
		m_pScriptDlg->SyncSource();
	}

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pScript )
	{
		TCHAR achText[256];

		ASSERT( m_pScript->m_pUndoMgr != NULL );

		if( m_pScript->m_pUndoMgr )
		{
			if( m_pScript->m_pUndoMgr->GetUndo(achText, 256) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditUndo

void CScriptCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( m_pScript )
	{
		ASSERT( m_pScript->m_pUndoMgr != NULL);
		
		if( m_pScript->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pScript->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pScript->m_pUndoMgr->Undo( m_pScript );
				m_pScript->SetModified( TRUE );
				m_pScript->SyncScriptEditor( SSE_SOURCE );

				// Following will sync routines and variables
				m_pScript->SyncScriptWithDirectMusic();	
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditRedo

void CScriptCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	// Make sure we have the latest text
	// Necessary because sync takes place in KillFocus 
	// and redo may have been initiated by Alt+E/Alt+R or Ctrl+Y
	if( m_pScriptDlg )
	{
		m_pScriptDlg->SyncSource();
	}

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pScript )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pScript->m_pUndoMgr != NULL );

		if( m_pScript->m_pUndoMgr )
		{
			if( m_pScript->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditRedo

void CScriptCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( m_pScript )
	{
		ASSERT( m_pScript->m_pUndoMgr != NULL );
		
		if( m_pScript->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pScript->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pScript->m_pUndoMgr->Redo( m_pScript );
				m_pScript->SetModified( TRUE );
				m_pScript->SyncScriptEditor( SSE_SOURCE );

				// Following will sync routines and variables
				m_pScript->SyncScriptWithDirectMusic();	
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditCut

void CScriptCtrl::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnUpdateEditCut( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditCut

void CScriptCtrl::OnEditCut() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditCut();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditCopy

void CScriptCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnUpdateEditCopy( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditCopy

void CScriptCtrl::OnEditCopy() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditCopy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditPaste

void CScriptCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnUpdateEditPaste( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditPaste

void CScriptCtrl::OnEditPaste() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditInsert

void CScriptCtrl::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnUpdateEditInsert( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditInsert

void CScriptCtrl::OnEditInsert() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditInsert();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditSelectAll

void CScriptCtrl::OnEditSelectAll() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditSelectAll();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateEditDelete

void CScriptCtrl::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnUpdateEditDelete( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnEditDelete

void CScriptCtrl::OnEditDelete() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->OnEditDelete();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateCallRoutine

void CScriptCtrl::OnUpdateCallRoutine( CCmdUI* pCmdUI ) 
{
	pCmdUI->Enable( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnCallRoutine

void CScriptCtrl::OnCallRoutine() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->CallSelectedRoutines();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnUpdateSetVariable

void CScriptCtrl::OnUpdateSetVariable( CCmdUI* pCmdUI ) 
{
	pCmdUI->Enable( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnSetVariable

void CScriptCtrl::OnSetVariable() 
{
	if( m_pScriptDlg )
	{
		m_pScriptDlg->SetSelectedVariable();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::PreTranslateMessage

BOOL CScriptCtrl::PreTranslateMessage( MSG* pMsg ) 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScriptDlg 
	&&  ::IsWindow(m_pScriptDlg->m_editSource.m_hWnd) )
	{
		switch( pMsg->message )
		{
			case WM_KEYDOWN:
			{
				if( pMsg->lParam & 0x40000000 )
				{
					break;
				}

				switch( pMsg->wParam )
				{
					case VK_TAB:
					{
						CWnd* pWndFocus = GetFocus();
						if( pWndFocus )
						{
							if( &m_pScriptDlg->m_editSource != pWndFocus )
							{
								CWnd* pWndNext;
								if( GetAsyncKeyState(VK_SHIFT) & 0x8000 )
								{
									pWndNext = GetNextDlgTabItem( pWndFocus, TRUE );
								}
								else
								{
									pWndNext = GetNextDlgTabItem( pWndFocus, FALSE );
								}
								if( pWndNext )
								{
									pWndNext->SetFocus();
								}
								return TRUE;
							}
						}
						break;
					}
				}
				break;
			}

			case WM_SYSKEYDOWN:
			{
				if( pMsg->lParam & 0x40000000 )
				{
					break;
				}

				switch( pMsg->wParam )
				{
					case 0x42:  // VK_B		(Variable listbox)
					case 0x62:  // VK_B		(Variable listbox)
						if( GetAsyncKeyState(VK_MENU) & 0x8000 )
						{
							m_pScriptDlg->m_lstbxVariables.SetFocus();
							return TRUE;
						}
						break;

					case 0x49:	// VK_I		(Reinitialize button)
					case 0x69:	// VK_I		(Reinitialize button)
						if( GetAsyncKeyState(VK_MENU) & 0x8000 )
						{
							m_pScriptDlg->SyncSource();  // To pick up latest changes
							m_pScriptDlg->OnInitVariables();
							return TRUE;
						}
						break;

					case 0x4f:	// VK_O		(Routine listbox)
					case 0x6f:	// VK_O		(Routine listbox)
						if( GetAsyncKeyState(VK_MENU) & 0x8000 )
						{
							m_pScriptDlg->m_lstbxRoutines.SetFocus();
							return TRUE;
						}
						break;

					case 0x52:	// VK_R		(Refresh button)
					case 0x72:	// VK_R		(Refresh button)
						if( GetAsyncKeyState(VK_MENU) & 0x8000 )
						{
							m_pScriptDlg->SyncSource();  // To pick up latest changes
							m_pScriptDlg->OnRefresh();
							return TRUE;
						}
						break;

					case 0x53:	// VK_S		(Source edit control)
					case 0x73:	// VK_S		(Source edit control)
						if( GetAsyncKeyState(VK_MENU) & 0x8000 )
						{
							m_pScriptDlg->m_editSource.SetFocus();
							return TRUE;
						}
						break;
				}
				break;
			}
		}
	}
	
	return COleControl::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnHelpFinder

void CScriptCtrl::OnHelpFinder() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnHelpScriptAPI

void CScriptCtrl::OnHelpScriptAPI() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/DirectMusicScriptingReference.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl::OnHelpScriptLanguage

void CScriptCtrl::OnHelpScriptLanguage() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/AudioVBScriptLanguage.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDesignerDLL.h ===
#if !defined(AFX_SCRIPTDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_SCRIPTDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ScriptDesigner.h : main header file for SCRIPTDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#include <dmusicp.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "ScriptDesigner.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"
#include <DLSDesigner.h>


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define CF_SCRIPT "DMUSProd v.1 Script"
#define CF_SCRIPTLIST "DMUSProd v.1 Script List"

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

#define FIRST_SCRIPT_IMAGE		0
#define FIRST_SCRIPTREF_IMAGE	2

#define WM_DISPLAY_MESSAGE_TEXT		(WM_USER + 0xF5)
#define WM_END_EDIT_VALUE			(WM_USER + 0xF6)
#define WM_CANCEL_EDIT_VALUE		(WM_USER + 0xF7)


class CScriptComponent;


/////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp : See ScriptDesigner.cpp for implementation.

class CScriptDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	CScriptComponent*			m_pScriptComponent;
};

extern CScriptDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptComponent.h ===
#ifndef __SCRIPTCOMPONENT_H__
#define __SCRIPTCOMPONENT_H__

// ScriptComponent.h : header file
//

#include <afxtempl.h>
#include <Conductor.h>
#include "DebugDlg.h"
#include "LogTool.h"

class CDirectMusicScript;


////////////////////////////////////////////////////////////////////////////////
class CScriptComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt,
						 public IDMUSProdMenu, public IDMUSProdDebugScript,
						 public IDMUSProdPortNotify
{
friend UINT AFX_CDECL MessageTextThreadProc( LPVOID pParam );

public:
    CScriptComponent();
	~CScriptComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

    // IDMUSProdMenu functions
    HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
    HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
    HRESULT STDMETHODCALLTYPE OnMenuInit( HMENU hMenu, UINT nMenuID );
    HRESULT STDMETHODCALLTYPE OnMenuSelect();

	// IDMUSProdDebugScript functions
    HRESULT STDMETHODCALLTYPE DisplayScriptError( void* pErrorInfo );
    HRESULT STDMETHODCALLTYPE DisplayText( WCHAR* pwszText  );

	// IDMUSProdPortNotify functions
	HRESULT STDMETHODCALLTYPE OnOutputPortsChanged( void );
	HRESULT STDMETHODCALLTYPE OnOutputPortsRemoved( void );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetScriptImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetScriptRefImageIndex( short* pnNbrFirstImage );
	void AddToScriptFileList( CDirectMusicScript* pScript );
	void RemoveFromScriptFileList( CDirectMusicScript* pScript );
	BOOL StartMessageTextThread();
	BOOL EndMessageTextThread();

public:
	IDMUSProdFramework*			m_pIFramework;
	IDirectMusicPerformance*	m_pIDMPerformance;
	IDMUSProdConductor*			m_pIConductor;
	IDMUSProdComponent*			m_pIContainerComponent;

	CDebugDlg*					m_pDebugDlg;		// Message Window
	WINDOWPLACEMENT*			m_pDebugDlgWP;		// Message Window placement
	CLogTool*					m_pLogTool;			// Captures script trace commands

	short						m_nNextScript;		// appended to name of new Script
	UINT						m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format
	UINT						m_cfScript;			// CF_SCRIPT clipboard format
	UINT						m_cfScriptList;		// CF_SCRIPTLIST clipboard format

	BOOL						m_fDisplayMessageText;
	BOOL						m_fEndMessageTextThread;
	HANDLE						m_hEvent_WakeUpMessageTextThread;
	HANDLE						m_hEvent_ExitMessageTextThread;
	HANDLE						m_hMessageTextThread;
	CRITICAL_SECTION			m_CrSecMessageText;	        
	CRITICAL_SECTION			m_CrSecDebugDlg;	        
	CTypedPtrList<CPtrList, CString*> m_lstMessageText;

private:
    DWORD						m_dwRef;
	IDMUSProdDocType8*			m_pIScriptDocType8;
	short						m_nFirstImage;
	BOOL						m_fMenuWasAdded;

	CTypedPtrList<CPtrList, CDirectMusicScript*> m_lstScripts;
};

#endif // __SCRIPTCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptCtl.h ===
#if !defined(AFX_SCRIPTCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_SCRIPTCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ScriptCtl.h : Declaration of the CScriptCtrl ActiveX Control class.

#include "ScriptDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CScriptCtrl : See ScriptCtl.cpp for implementation.

class CScriptCtrl : public COleControl
{
	DECLARE_DYNCREATE(CScriptCtrl)

// Constructor
public:
	CScriptCtrl();

// Attributes
public:
	CScriptDlg*			m_pScriptDlg;
	HANDLE				m_hKeyStatusBar;

private:
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	HACCEL				m_hAcceleratorTable;
	CDirectMusicScript*	m_pScript;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScriptCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual HMENU OnGetInPlaceMenu();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CScriptCtrl();

	DECLARE_OLECREATE_EX(CScriptCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CScriptCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CScriptCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CScriptCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CScriptCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditInsert();
	afx_msg void OnEditSelectAll();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	afx_msg void OnCallRoutine();
	afx_msg void OnUpdateCallRoutine(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSetVariable(CCmdUI* pCmdUI);
	afx_msg void OnSetVariable();
	afx_msg void OnHelpScriptAPI();
	afx_msg void OnHelpScriptLanguage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CScriptCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CScriptCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CScriptCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDesignerDLL.cpp ===
// ScriptDesigner.cpp : Implementation of CScriptDesignerApp and DLL registration.

#include "stdafx.h"
#include <initguid.h>
#include "ScriptDesignerDLL.h"
#include "ScriptComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CScriptDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd135db55, 0x66ed, 0x11d3, { 0xb4, 0x5d, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::InitInstance - DLL initialization

BOOL CScriptDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pIPageManager = NULL;
	m_pScriptComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::ExitInstance - DLL termination

int CScriptDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::GetHelpFileName

BOOL CScriptDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::SetNodePointers  (used by all components)

void CScriptDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::PutDataInClipboard

BOOL CScriptDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::FlushClipboard

void CScriptDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CScriptDesignerApp::GetFileVersion  (used by all components)

BOOL CScriptDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register Script Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_ScriptEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SCRIPT_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_ScriptComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SCRIPT_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ScriptNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_ScriptRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_ScriptComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicScript, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_SCRIPT_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Script Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_ScriptEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_ScriptComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ScriptNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CScriptComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_ScriptComponent) )
	{
        pfunc = CScriptComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_ScriptEditor) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDlg.cpp ===
// ScriptDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ScriptDesignerDLL.h"
#include "Script.h"
#include "ScriptCtl.h"
#include "ScriptDlg.h"
#include <ContainerDesigner.h>
#include <windowsx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg

//IMPLEMENT_DYNCREATE(CScriptDlg, CFormView)

CScriptDlg::CScriptDlg()
	: CFormView(CScriptDlg::IDD)
{
	//{{AFX_DATA_INIT(CScriptDlg)
	//}}AFX_DATA_INIT

	m_pScriptCtrl = NULL;
	m_pScript = NULL;

	m_nLastStartChar = 0;
	m_nLastEndChar = 0;
	m_nLastPos = 0;

	VariantInit( &m_EditVariant );
	m_pEditValueCtrl = NULL;
}

CScriptDlg::~CScriptDlg()
{
	VariantClear( &m_EditVariant );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::SyncSource

void CScriptDlg::SyncSource( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsWindow(m_editSource) )
	{
		m_editSource.OnKillFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::RefreshControls

void CScriptDlg::RefreshControls( DWORD dwFlags )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( dwFlags & SSE_SOURCE )
	{
		// Handle source
		m_editSource.SetWindowText( m_pScript->m_strSource );

		// Handle status bar
		m_nLastStartChar = 0;
		m_nLastEndChar = 0;
		m_nLastPos = 0;
		UpdateStatusBar();
	}

	if( dwFlags & SSE_ROUTINES )
	{
		// Handle routine list box
		FillRoutineListBox();
	}

	if( dwFlags & SSE_VARIABLES )
	{
		// Handle variables list box
		FillVariableListBox();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::FillRoutineListBox

void CScriptDlg::FillRoutineListBox( void )
{
	ASSERT( m_pScript != NULL );

	m_lstbxRoutines.SetRedraw( FALSE );

	// Store selected routines
	CTypedPtrList<CPtrList, CString*> listSelectedRoutines;
	int nNbrSelItems = m_lstbxRoutines.GetSelCount();
	if( nNbrSelItems > 0 )
	{
		int* pnSelItems = new int[nNbrSelItems];
		if( pnSelItems )
		{
			m_lstbxRoutines.GetSelItems( nNbrSelItems, pnSelItems );

			for( int i = 0;  i < nNbrSelItems ;  i++ )
			{
				CString* pstrRoutine = new CString;
				if( pstrRoutine )
				{
					m_lstbxRoutines.GetText( pnSelItems[i], *pstrRoutine );
					listSelectedRoutines.AddTail( pstrRoutine ); 
				}
			}

			delete [] pnSelItems;
		}
	}

	// Initialize content
	m_lstbxRoutines.ResetContent();
	m_lstbxRoutines.SetHorizontalExtent( 0 );
	
	// Fill the list box
	CDC* pDC = m_lstbxRoutines.GetDC();
	if( pDC )
	{
		CSize sizeText;
		int nCurExtent = m_lstbxRoutines.GetHorizontalExtent();

		CString strRoutineName;
		WCHAR awchRoutineName[MAX_PATH];
		int i = 0;
		if( m_pScript->m_pIDMScript )
		{
			while( m_pScript->m_pIDMScript->EnumRoutine( i++, awchRoutineName ) == S_OK )
			{
				strRoutineName = awchRoutineName;
				m_lstbxRoutines.AddString( strRoutineName );

				sizeText = pDC->GetTextExtent( strRoutineName );
				if( sizeText.cx > nCurExtent )
				{
					nCurExtent = sizeText.cx;
					m_lstbxRoutines.SetHorizontalExtent( nCurExtent );
				}
			}
		}

		m_lstbxRoutines.ReleaseDC( pDC );
	}

	// Process selected routine list
	while( !listSelectedRoutines.IsEmpty() )
	{
		CString* pstrText = static_cast<CString*>( listSelectedRoutines.RemoveHead() );

		// Re-establish selection state
		int nPos = m_lstbxRoutines.FindStringExact( -1, *pstrText );
		if( nPos != LB_ERR )
		{
			m_lstbxRoutines.SetSel( nPos, TRUE ); 
			m_lstbxRoutines.SetCaretIndex( nPos, 0 ); 
		}

		delete pstrText;
	}

	m_lstbxRoutines.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::FillVariableListBox

void CScriptDlg::FillVariableListBox( void )
{
	ASSERT( m_pScript != NULL );

	m_lstbxVariables.SetRedraw( FALSE );

	// Store selected variable
	CString strSelectedVariable;
	int nCurSelection = m_lstbxVariables.GetNextItem( -1, LVNI_SELECTED );
	if( nCurSelection >= 0 )
	{
		strSelectedVariable = m_lstbxVariables.GetItemText( nCurSelection, 0 );
	}

	// Initialize content
	m_lstbxVariables.DeleteAllItems();
	
	// Fill the list box
	CDC* pDC = m_lstbxVariables.GetDC();
	if( pDC )
	{
		CString strVariableName;
		WCHAR awchVariableName[MAX_PATH];

		int i = 0;
		BSTR bstrVariableName;
		bool fBypassVariable;
		
		if( m_pScript->m_pIDMScript )
		{
			while( m_pScript->m_pIDMScript->EnumVariable( i++, awchVariableName ) == S_OK )
			{
				// Bypass variables that are actually items in the Script's Container
				fBypassVariable = false;
				if( m_pScript->m_pIContainerNode )
				{
					IDMUSProdContainerInfo* pIContainerInfo;
					if( SUCCEEDED ( m_pScript->m_pIContainerNode->QueryInterface( IID_IDMUSProdContainerInfo, (void**)&pIContainerInfo ) ) )
					{
						strVariableName = awchVariableName;
						bstrVariableName = strVariableName.AllocSysString();

						IUnknown* pIDocRootNode;
						if( pIContainerInfo->FindDocRootFromScriptAlias(bstrVariableName, &pIDocRootNode) == S_OK )
						{
							fBypassVariable = true;
							RELEASE( pIDocRootNode );
						}

						RELEASE( pIContainerInfo );
					}
				}
				if( fBypassVariable )
				{
					continue;
				}

				// COLUMN 1 (Name)
				strVariableName = awchVariableName;
				int nPos = m_lstbxVariables.InsertItem( i, strVariableName );

				// COLUMN 2 (Value)
				CString strValue;
				FormatValueText( awchVariableName, strValue );
				m_lstbxVariables.SetItemText( nPos, 1, strValue );
			}
		}

		m_lstbxVariables.ReleaseDC( pDC );
	}

	// Reselect variable
	if( strSelectedVariable.IsEmpty() == FALSE )
	{
		LV_FINDINFO fi;
		fi.flags = LVFI_STRING;
		fi.psz = strSelectedVariable;
		fi.lParam = NULL;
		nCurSelection = m_lstbxVariables.FindItem( &fi );
		if( nCurSelection >= 0 )
		{
			m_lstbxVariables.SetItemState( nCurSelection, (LVIS_SELECTED|LVIS_FOCUSED), (LVIS_SELECTED|LVIS_FOCUSED) );
		}
	}

	m_lstbxVariables.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::FormatValueText

void CScriptDlg::FormatValueText( WCHAR* awchVariableName, CString& strValue )
{
	if( m_pScript == NULL
	||  m_pScript->m_pIDMScript == NULL )
	{
		// Can't do anything
		return;
	}

	// Initialize ErrorInfo struct
	DMUS_SCRIPT_ERRORINFO ErrorInfo;
	memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
	ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

	VARIANT var;
	VariantInit( &var );

	// Get current value
	HRESULT hr = m_pScript->m_pIDMScript->GetVariableVariant( awchVariableName, &var, &ErrorInfo );
	if( FAILED ( hr ) )
	{
		// Value = (Error)
		strValue.LoadString( IDS_ERROR_TEXT );
		m_pScript->DisplayScriptError( &ErrorInfo, hr );
		return;
	}

	switch( var.vt )
	{
		case VT_I2:			// Number
			strValue.Format( "%d", V_I2(&var) );
			break;

		case VT_I4:			// Number
			strValue.Format( "%d", V_I4(&var) );
			break;

		case VT_BOOL:		// BOOL
			strValue.Format( "%d", V_BOOL(&var) );
			break;

		case VT_BSTR:		// String (Unicode)
			strValue = V_BSTR( &var );
			break;

		case VT_EMPTY:		// <Empty>
			strValue.LoadString( IDS_EMPTY_TEXT );
			break;

		case VT_UNKNOWN:	// (Object)
		case VT_DISPATCH:	
			strValue.LoadString( IDS_OBJECT_TEXT );
			break;

		default:			// <Unknown>
			strValue.LoadString( IDS_UNKNOWN_TEXT );
			break;
	}

	VariantClear( &var );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::UpdateStatusBar

void CScriptDlg::UpdateStatusBar( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( ::IsWindow(m_editSource) )
	{
		CString strLine;
		strLine.LoadString( IDS_LINE_TEXT );
		
		CString strColumn;
		strColumn.LoadString( IDS_COLUMN_TEXT );

		int nStartChar, nEndChar;
		m_editSource.GetSel( nStartChar, nEndChar );

		int nPos;
		if( nEndChar != m_nLastEndChar  )
		{
			nPos = nEndChar;
		}
		else if( nStartChar != m_nLastStartChar  )
		{
			nPos = nStartChar;
		}
		else
		{
			nPos = m_nLastPos;
		}
		m_nLastStartChar = nStartChar;
		m_nLastEndChar = nEndChar;
		m_nLastPos = nPos;

		int nLine, nColumn;
		nLine = m_editSource.LineFromChar( nPos );
		nColumn = nPos - m_editSource.LineIndex( nLine );

		CString strText;
		strText.Format( "%s %d, %s %d",
						strLine, (nLine + 1), 
						strColumn, (nColumn + 1) ); 
		BSTR bstrText = strText.AllocSysString();

		theApp.m_pScriptComponent->m_pIFramework->SetStatusBarPaneText( m_pScriptCtrl->m_hKeyStatusBar, 0, bstrText, TRUE );
	}
}


void CScriptDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScriptDlg)
	DDX_Control(pDX, IDC_INIT_VARIABLES, m_btnInitialize);
	DDX_Control(pDX, IDC_VARIABLE_LIST, m_lstbxVariables);
	DDX_Control(pDX, IDC_SOURCE_PROMPT, m_staticSourcePrompt);
	DDX_Control(pDX, IDC_REFRESH, m_btnRefresh);
	DDX_Control(pDX, IDC_VARIABLE_PROMPT, m_staticVariablePrompt);
	DDX_Control(pDX, IDC_ROUTINE_PROMPT, m_staticRoutinePrompt);
	DDX_Control(pDX, IDC_ROUTINE_LIST, m_lstbxRoutines);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScriptDlg, CFormView)
	//{{AFX_MSG_MAP(CScriptDlg)
	ON_WM_DESTROY()
	ON_WM_MOUSEACTIVATE()
	ON_WM_SIZE()
	ON_LBN_DBLCLK(IDC_ROUTINE_LIST, OnDblClkRoutineList)
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_NOTIFY(NM_DBLCLK, IDC_VARIABLE_LIST, OnDblClkVariableList)
	ON_NOTIFY(NM_CLICK, IDC_VARIABLE_LIST, OnClickVariableList)
	ON_BN_CLICKED(IDC_INIT_VARIABLES, OnInitVariables)
	ON_NOTIFY(LVN_KEYDOWN, IDC_VARIABLE_LIST, OnKeyDownVariableList)
	ON_NOTIFY(NM_RETURN, IDC_VARIABLE_LIST, OnReturnVariableList)
	ON_WM_PARENTNOTIFY()
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_NOTIFY(NM_SETFOCUS, IDC_VARIABLE_LIST, OnSetFocusVariableList)
	//}}AFX_MSG_MAP

	ON_MESSAGE(WM_END_EDIT_VALUE, OnEndEditValue)
	ON_MESSAGE(WM_CANCEL_EDIT_VALUE, OnCancelEditValue)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg diagnostics

#ifdef _DEBUG
void CScriptDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CScriptDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::Create

BOOL CScriptDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext ) )
	{
		return FALSE;
	}
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnInitialUpdate

void CScriptDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	CFormView::OnInitialUpdate();

	// Subclass controls
	m_editSource.SubclassDlgItem( IDC_SOURCE, this );
	m_editSource.m_pScriptDlg = this;

	// Get client rect of variable list box
	CRect rect;
	m_lstbxVariables.GetClientRect( &rect );

	// Add columns to variable list box
	CString strText;
	strText.LoadString( IDS_NAME_TEXT );
	m_lstbxVariables.InsertColumn( 0, strText, LVCFMT_LEFT, (rect.right >> 1), 1 );
	strText.LoadString( IDS_VALUE_TEXT );
	m_lstbxVariables.InsertColumn( 1, strText, LVCFMT_LEFT, (rect.right >> 1), 0 );

	RefreshControls( SSE_ALL );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnDestroy

void CScriptDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

// AMC - Will want to change way data syncs are handled!
	ASSERT( m_pScript != NULL );
	m_editSource.GetWindowText( m_pScript->m_strSource );

	CFormView::OnDestroy();
}

#define CONTROL_BORDER	5

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnSize

void CScriptDlg::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::OnSize( nType, cx, cy );

    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow(m_editSource) )
	{
		return;
	}

	ASSERT( m_pScript != NULL );

	// Set scroll positions to zero
	SetScrollPos( SB_HORZ, 0, FALSE );
	SetScrollPos( SB_VERT, 0, FALSE );

	CRect rect;
	CRect rectTemp;

	// Get size of dialog
	CRect rectDlg;
	GetClientRect( &rectDlg );

	// Enforce minimum size of dialog
	HRSRC hRes = ::FindResource( theApp.m_hInstance, MAKEINTRESOURCE(IDD_DLG_SCRIPT), RT_DIALOG );
	if( hRes )
	{
		HGLOBAL hTemplate = ::LoadResource( theApp.m_hInstance, hRes );
		if( hTemplate )
		{
			DLGTEMPLATE* pTemplate = (DLGTEMPLATE *)::LockResource( hTemplate );
			if( pTemplate )
			{
				CRect rect( 0, 0, pTemplate->cx, pTemplate->cy );

				if( MapDialogRect(GetSafeHwnd(), &rect) )
				{
					rectDlg.right = max( rectDlg.right, rect.right );
					rectDlg.bottom = max( rectDlg.bottom, rect.bottom );
				}

				UnlockResource( hTemplate );
			}

			::FreeResource( hTemplate );
		}
	}

	// Get size of IDC_ROUTINE_LIST
	CRect rectRoutineListBox;
	m_lstbxRoutines.GetWindowRect( &rectRoutineListBox );

	// Determine position of Refresh button
	m_btnRefresh.GetClientRect( &rectTemp );
	rect.right = rectDlg.right - CONTROL_BORDER;
	rect.left = rect.right - rectTemp.Width();
	rect.top = CONTROL_BORDER;
	rect.bottom = rect.top + rectTemp.Height();
	m_btnRefresh.MoveWindow( &rect, TRUE );

	// Determine position of Routine listbox prompt
	m_staticRoutinePrompt.GetClientRect( &rectTemp );
	rect.right = rect.left - CONTROL_BORDER;
	rect.left = rectDlg.right - CONTROL_BORDER - rectRoutineListBox.Width();
	rect.top = (CONTROL_BORDER << 1) + 3;
	rect.bottom = rect.top + rectTemp.Height();
	m_staticRoutinePrompt.MoveWindow( &rect, TRUE );

	// Determine position of Routine listbox
	rect.right = rectDlg.right - CONTROL_BORDER;
	rect.left = rect.right - rectRoutineListBox.Width();
	rect.top = rect.bottom + 4;
	rect.bottom = rect.top +  rectRoutineListBox.Height();
	rectRoutineListBox = rect;
	m_lstbxRoutines.MoveWindow( &rectRoutineListBox, TRUE );

	// Determine position of Initialize button
	m_btnInitialize.GetClientRect( &rectTemp );
	rect.left = rect.right - rectTemp.Width();
	rect.top = rect.bottom + 8;
	rect.bottom = rect.top + rectTemp.Height();
	m_btnInitialize.MoveWindow( &rect, TRUE );

	// Determine position of Variable listbox prompt
	m_staticVariablePrompt.GetClientRect( &rectTemp );
	rect.right = rect.left - CONTROL_BORDER;
	rect.left = rectDlg.right - CONTROL_BORDER - rectRoutineListBox.Width();
	rect.top += 8;
	rect.bottom = rect.top +  rectTemp.Height();
	m_staticVariablePrompt.MoveWindow( &rect, TRUE );

	// Determine position of Variable listbox
	rect.right = rectDlg.right - CONTROL_BORDER;
	rect.left = rect.right - rectRoutineListBox.Width();
	rect.top = rect.bottom + 4;
	rect.bottom = rectDlg.bottom - CONTROL_BORDER;
	m_lstbxVariables.MoveWindow( &rect, TRUE );

	// Determine position of IDC_SOURCE
	rect.right = rect.left - CONTROL_BORDER;
	rect.left = CONTROL_BORDER;
	rect.top = rectRoutineListBox.top;
	rect.bottom = rectDlg.bottom - CONTROL_BORDER;
	m_editSource.MoveWindow( &rect, TRUE );

	// Determine position of Source listbox prompt
	m_staticSourcePrompt.GetClientRect( &rectTemp );
	rect.left = CONTROL_BORDER;
	rect.right = rect.left + rectTemp.Width();
	rect.top = (CONTROL_BORDER << 1) + 3;
	rect.bottom = rect.top + rectTemp.Height();
	m_staticSourcePrompt.MoveWindow( &rect, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnUpdateEditCut

void CScriptDlg::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		int nStartChar;
		int nEndChar;
		m_editSource.GetSel( nStartChar, nEndChar );
		if( nStartChar >= 0 
		&&  nEndChar >= 0 
		&& (nStartChar != nEndChar) )
		{
			pCmdUI->Enable( TRUE );
			return;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditCut

void CScriptDlg::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		m_editSource.Cut();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnUpdateEditCopy

void CScriptDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		int nStartChar;
		int nEndChar;
		m_editSource.GetSel( nStartChar, nEndChar );
		if( nStartChar >= 0 
		&&  nEndChar >= 0 
		&& (nStartChar != nEndChar) )
		{
			pCmdUI->Enable( TRUE );
			return;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditCopy

void CScriptDlg::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		m_editSource.Copy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnUpdateEditPaste

void CScriptDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	BOOL fEnablePaste = FALSE;

	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		// Get the IDataObject
		IDataObject* pIDataObject;
		if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
		{
			// Create a new CDllJazzDataObject and see if it can read the data object's format.
			CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
			if( pDataObject )
			{
				// Determine if it contains CF_TEXT
				if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, CF_TEXT ) ) )
				{
					fEnablePaste = TRUE;
				}

				delete pDataObject;
			}

			RELEASE( pIDataObject );
		}
	}
	
	pCmdUI->Enable( fEnablePaste );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditPaste

void CScriptDlg::OnEditPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		m_editSource.Paste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnUpdateEditInsert

void CScriptDlg::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditInsert

void CScriptDlg::OnEditInsert() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	ASSERT( 0 );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnUpdateEditDelete

void CScriptDlg::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );

	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		int nStartChar;
		int nEndChar;
		m_editSource.GetSel( nStartChar, nEndChar );
		if( nStartChar >= 0 
		&&  nEndChar >= 0 
		&& (nStartChar != nEndChar) )
		{
			pCmdUI->Enable( TRUE );
			return;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditDelete

void CScriptDlg::OnEditDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		m_editSource.Clear();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEditSelectAll

void CScriptDlg::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pScript != NULL );
	
	if( ::IsWindow(m_editSource.m_hWnd) )
	{
		m_editSource.SetSel( 0, -1, FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnViewProperties

BOOL CScriptDlg::OnViewProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pScript != NULL );
	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( FAILED ( theApp.m_pScriptComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;
	if( SUCCEEDED ( m_pScript->OnShowProperties() ) )
	{
		fSuccess = TRUE;
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnMouseActivate

int CScriptDlg::OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message )  
{
	switch( nHitTest )
	{
		case HTHSCROLL:
		case HTVSCROLL:
			if( m_pEditValueCtrl )
			{
				// Finish editing this variable
				OnEndEditValue( (WPARAM)m_pEditValueCtrl->GetSafeHwnd(), 0 );
			}
			break;
	}
	
	return CFormView::OnMouseActivate( pDesktopWnd, nHitTest, message );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnCommand

BOOL CScriptDlg::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( HIWORD(wParam) == 0 )	// menu command
	{
		switch( LOWORD(wParam) )
		{
			case IDM_CALL_ROUTINE:
				CallSelectedRoutines();
				return TRUE;

			case IDM_SET_VARIABLE:
				SetSelectedVariable();
				return TRUE;
		}
	}
	
	return CFormView::OnCommand( wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnContextMenu

void CScriptDlg::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pWnd != NULL );
	ASSERT( m_pScript != NULL );

	switch( pWnd->GetDlgCtrlID() )
	{
		case IDC_ROUTINE_LIST:
		{
			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_ROUTINE_LIST) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			::EnableMenuItem( hMenuPopup, IDM_CALL_ROUTINE, ( m_lstbxRoutines.GetSelCount() > 0 )
								? MF_ENABLED : MF_GRAYED );

			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}

		case IDC_VARIABLE_LIST:
		{
			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_VARIABLE_LIST) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			::EnableMenuItem( hMenuPopup, IDM_SET_VARIABLE, ( m_lstbxVariables.GetSelectedCount() > 0 )
								? MF_ENABLED : MF_GRAYED );

			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnDblClkRoutineList

void CScriptDlg::OnDblClkRoutineList() 
{
	CallSelectedRoutines();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnKeyDownVariableList

void CScriptDlg::OnKeyDownVariableList( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

	switch( pLVKeyDow->wVKey )
	{
		case VK_RIGHT:
			SetSelectedVariable();
			break;
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnReturnVariableList

void CScriptDlg::OnReturnVariableList( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	SetSelectedVariable();
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnClickVariableList

void CScriptDlg::OnClickVariableList( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// Select the variable
	int nItem = FindVariableAtYPos( pNMListView->ptAction.y );
	if( nItem >= 0 )
	{
		m_lstbxVariables.SetItemState( nItem, (LVIS_SELECTED|LVIS_FOCUSED), (LVIS_SELECTED|LVIS_FOCUSED) );

		RECT rect;
		m_lstbxVariables.GetItemRect( nItem, &rect, LVIR_BOUNDS );
		rect.right = rect.left + m_lstbxVariables.GetColumnWidth( 0 );
		if( pNMListView->ptAction.x >= rect.right )
		{
			SetSelectedVariable();
		}
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnDblClkVariableList

void CScriptDlg::OnDblClkVariableList( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	// Select the variable
	int nItem = FindVariableAtYPos( pNMListView->ptAction.y );
	if( nItem >= 0 )
	{
		m_lstbxVariables.SetItemState( nItem, (LVIS_SELECTED|LVIS_FOCUSED), (LVIS_SELECTED|LVIS_FOCUSED) );

		RECT rect;
		m_lstbxVariables.GetItemRect( nItem, &rect, LVIR_BOUNDS );
		rect.right = rect.left + m_lstbxVariables.GetColumnWidth( 0 );
		if( pNMListView->ptAction.x < rect.right )
		{
			SetSelectedVariable();
		}
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnRefresh

void CScriptDlg::OnRefresh( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		m_pScript->SyncScriptWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnInitVariables

void CScriptDlg::OnInitVariables( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript )
	{
		m_pScript->m_fInitializingVariables = true;
		m_pScript->SyncScriptWithDirectMusic();
		m_pScript->m_fInitializingVariables = false;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::CallSelectedRoutines

void CScriptDlg::CallSelectedRoutines() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	if( m_pScript == NULL
	||  m_pScript->m_pIDMScript == NULL )
	{
		// Can't do anything
		return;
	}

	int nNbrSelItems = m_lstbxRoutines.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	CWaitCursor wait;

	CString strRoutine;
	WCHAR awchRoutineName[MAX_PATH];
	DMUS_SCRIPT_ERRORINFO ErrorInfo;
	HRESULT hr;

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxRoutines.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			m_lstbxRoutines.GetText( pnSelItems[i], strRoutine );
		
			// Convert the routine name to wide characters
			MultiByteToWideChar( CP_ACP, 0, strRoutine, -1, awchRoutineName, MAX_PATH );

			// Initialize ErrorInfo struct
			memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
			ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

			// Call the routine
			hr = m_pScript->m_pIDMScript->CallRoutine( awchRoutineName, &ErrorInfo );
			if( FAILED ( hr ) )
			{
				m_pScript->DisplayScriptError( &ErrorInfo, hr );
			}
		}

		delete [] pnSelItems;
	}

	// Update variable list box
	FillVariableListBox();
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnSetFocusVariableList

void CScriptDlg::OnSetFocusVariableList( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	if( m_lstbxVariables.GetSelectedCount() == 0 )
	{
		int nTopPos = m_lstbxVariables.GetTopIndex();
		if( nTopPos >= 0 )
		{
			m_lstbxVariables.SetItemState( nTopPos, LVIS_FOCUSED, LVIS_FOCUSED );
		}
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::SetSelectedVariable

void CScriptDlg::SetSelectedVariable() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pScriptComponent != NULL );
	ASSERT( theApp.m_pScriptComponent->m_pIFramework != NULL );

	// Finish editing this variable before we start editing another one
	if( m_pEditValueCtrl )
	{
		OnEndEditValue( (WPARAM)m_pEditValueCtrl->GetSafeHwnd(), 0 );
	}

	if( m_pScript == NULL
	||  m_pScript->m_pIDMScript == NULL )
	{
		// Can't do anything
		return;
	}

	// Get selected variable
	int nEditItem = m_lstbxVariables.GetNextItem( -1, LVNI_SELECTED );
	if( nEditItem < 0 )
	{
		// Nothing to do
		return;
	}

	// Convert the variable name to wide characters
	WCHAR awchVariableName[MAX_PATH];
	m_strEditVariableName = m_lstbxVariables.GetItemText( nEditItem, 0 );
	MultiByteToWideChar( CP_ACP, 0, m_strEditVariableName, -1, awchVariableName, MAX_PATH );

	// Initialize ErrorInfo struct
	DMUS_SCRIPT_ERRORINFO ErrorInfo;
	memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
	ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

	// Get current value
	VariantInit( &m_EditVariant );
	HRESULT hr = m_pScript->m_pIDMScript->GetVariableVariant( awchVariableName, &m_EditVariant, &ErrorInfo );
	if( FAILED ( hr ) )
	{
		m_pScript->DisplayScriptError( &ErrorInfo, hr );
		return;
	}

	// Translate value into string for edit control
	CString strValue;
	switch( m_EditVariant.vt )
	{
		case VT_I2:			// Number
			strValue.Format( "%d", V_I2(&m_EditVariant) );
			break;

		case VT_I4:			// Number
			strValue.Format( "%d", V_I4(&m_EditVariant) );
			break;

		case VT_BOOL:		// BOOL
			strValue.Format( "%d", V_BOOL(&m_EditVariant) );
			break;

		case VT_BSTR:		// String (Unicode)
			strValue = V_BSTR( &m_EditVariant );
			break;

		case VT_EMPTY:		// <Empty>
			strValue.Empty();
			break;

		case VT_UNKNOWN:	// (Object)
		case VT_DISPATCH:	
			return;			// Can't edit (Object)

		default:			// <Unknown>
			strValue.Empty();
			break;
	}

	// Determine coordinates for control
	RECT rect;
	m_lstbxVariables.GetItemRect( nEditItem, &rect, LVIR_BOUNDS );
	rect.left += m_lstbxVariables.GetColumnWidth( 0 );
	CDC* pDC = m_lstbxVariables.GetDC();
	if( pDC )
	{
		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		rect.left += tm.tmAveCharWidth - 3;
		ReleaseDC( pDC );
	}

	// Create an edit control
	ASSERT( m_pEditValueCtrl == NULL );
	m_pEditValueCtrl = new CEditValue;
	if( m_pEditValueCtrl )
	{
		m_pEditValueCtrl->m_pScriptDlg = this;
		if( m_pEditValueCtrl->Create( (WS_CHILD|WS_VISIBLE|WS_BORDER|ES_AUTOHSCROLL),
									   rect, &m_lstbxVariables, IDC_EDIT_VALUE ) )
		{
			CFont* pFont = m_lstbxVariables.GetFont();
			if( pFont )
			{
				m_pEditValueCtrl->SetFont( pFont, FALSE );
			}
			m_pEditValueCtrl->SetWindowText( strValue );
			m_pEditValueCtrl->SetSel( 0, -1, FALSE );
			m_pEditValueCtrl->SetFocus();
		}
		else
		{
			delete m_pEditValueCtrl;
			m_pEditValueCtrl = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnEndEditValue

LRESULT CScriptDlg::OnEndEditValue( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pScript == NULL 
	||  m_pScript->m_pIDMScript == NULL
	||  m_pEditValueCtrl == NULL
	||  m_strEditVariableName.IsEmpty() )
	{
		// Can't do anything
		OnCancelEditValue( wParam, lParam );
		return 0;
	}

	if( (WPARAM)m_pEditValueCtrl->GetSafeHwnd() != wParam )
	{
		// Wrong control - so don't do anything
		return 0;
	}

	// Get the current value from the edit control
	CString strValue;
	m_pEditValueCtrl->GetWindowText( strValue );
	strValue.TrimRight();
	strValue.TrimLeft();

	// Is new value numeric?
	BOOL fIsNumeric = TRUE;
	for( int i = 0 ;  i < strValue.GetLength() ;  i++ )
	{
		if( strValue[i] == '-' )
		{
			if( i == 0 )
			{
				continue;
			}
		}
		if( !(isdigit(strValue[i])) )
		{
			fIsNumeric = FALSE;
			break;
		}
	}

	// Determine new value
	COleVariant* pVar;

	// VT_EMPTY
	if( strValue.IsEmpty() )
	{
		pVar = new COleVariant();
	}

	// VT_I4
	// VT_BOOL
	else if( fIsNumeric )
	{
		long lValue;
		if( strValue[0] == '-' )
		{
			if( strValue.GetLength() > 11 )
			{
				lValue = INT_MIN;
			}
			else
			{
				lValue = _ttol( strValue );
				if( lValue > 0 )
				{
					lValue = INT_MIN;
				}
			}
		}
		else
		{
			if( strValue.GetLength() > 10 )
			{
				lValue = INT_MAX;
			}
			else
			{
				lValue = _ttol( strValue );
				if( lValue < 0 )
				{
					lValue = INT_MAX;
				}
			}
		}
		if( m_EditVariant.vt == VT_BOOL )
		{
			pVar = new COleVariant( (short)lValue, VT_BOOL );
		}
		else
		{
			pVar = new COleVariant( lValue, VT_I4 );
		}
	}

	// VT_BSTR
	else
	{
		pVar = new COleVariant( strValue );
	}

	// Set new value
	{
		HRESULT hr;
		WCHAR awchVariableName[MAX_PATH];
		DMUS_SCRIPT_ERRORINFO ErrorInfo;

		// Convert the variable name to wide characters
		MultiByteToWideChar( CP_ACP, 0, m_strEditVariableName, -1, awchVariableName, MAX_PATH );

		// Initialize ErrorInfo struct
		memset( &ErrorInfo, 0, sizeof(DMUS_SCRIPT_ERRORINFO) );
		ErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);

		hr = m_pScript->m_pIDMScript->SetVariableVariant( awchVariableName, *pVar, FALSE, &ErrorInfo );
		if( FAILED ( hr ) )
		{
			m_pScript->DisplayScriptError( &ErrorInfo, hr );
		}
	}

	// Cleanup
	m_pEditValueCtrl->DestroyWindow();
	delete m_pEditValueCtrl;
	m_pEditValueCtrl = NULL;
	m_strEditVariableName.Empty();
	VariantClear( &m_EditVariant );
	delete pVar;
	pVar = NULL;

	// Refresh variable list box
	FillVariableListBox();
	m_lstbxVariables.SetFocus();

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnCancelEditValue

LRESULT CScriptDlg::OnCancelEditValue( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pEditValueCtrl
	&&  (WPARAM)m_pEditValueCtrl->GetSafeHwnd() != wParam )
	{
		// Wrong control - Shoul not happen!
		ASSERT( 0 );
		return 0;
	}

	if( m_pEditValueCtrl )
	{
		m_pEditValueCtrl->DestroyWindow();
		delete m_pEditValueCtrl;
		m_pEditValueCtrl = NULL;
	}

	m_strEditVariableName.Empty();
	VariantClear( &m_EditVariant );

	// Refresh variable list box
	FillVariableListBox();
	m_lstbxVariables.SetFocus();

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::IsInEditVariable

BOOL CScriptDlg::IsInEditVariable( void )
{
	if( m_pEditValueCtrl )
	{
		return TRUE;
	}
	
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::FindVariableAtYPos

int CScriptDlg::FindVariableAtYPos( int nYPos )
{
	int nIndex = -1;

	RECT rect;

	int nCount = m_lstbxVariables.GetItemCount();
	for ( int i = 0 ;  i < nCount ;  i++ )
	{
		m_lstbxVariables.GetItemRect( i, &rect, LVIR_BOUNDS );
		
		if( nYPos >= rect.top
		&&  nYPos <= rect.bottom )
		{
			nIndex = i;
			break;
		}
	}

	return nIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDlg::OnParentNotify

void CScriptDlg::OnParentNotify( UINT message, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( message )
	{
		case WM_LBUTTONDOWN:
			if( m_pEditValueCtrl )
			{
				CPoint pt;
				pt.x = GET_X_LPARAM(lParam);
				pt.y = GET_Y_LPARAM(lParam);

				CRect rect;
				m_pEditValueCtrl->GetClientRect( &rect );
				m_pEditValueCtrl->ClientToScreen( &rect );
				ScreenToClient( &rect );

				if( rect.PtInRect(pt) == FALSE )
				{
					// Finish editing this variable
					OnEndEditValue( (WPARAM)m_pEditValueCtrl->GetSafeHwnd(), 0 );
				}
			}
			break;
	}

	CFormView::OnParentNotify( message, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDlg.h ===
#if !defined(AFX_SCRIPTDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_SCRIPTDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_

// ScriptDlg.h : header file
//

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EditSource.h"
#include "EditValue.h"


#define SSE_SOURCE		0x00000001
#define SSE_ROUTINES	0x00000002
#define SSE_VARIABLES	0x00000004
#define SSE_ALL			0xFFFFFFFF

/////////////////////////////////////////////////////////////////////////////
// CScriptDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CScriptDlg : public CFormView
{
friend class CScriptCtrl;
friend class CEditSource;
friend class CEditValue;

public:
	CScriptDlg();           // protected constructor used by dynamic creation
	virtual ~CScriptDlg();

private:
	void FillRoutineListBox();
	void FillVariableListBox();
	void FormatValueText( WCHAR* awchVariableName, CString& strValue );
	int FindVariableAtYPos( int nYPos );

	// Additional methods
public:
	void SyncSource();
	void RefreshControls( DWORD dwFlags );
	void UpdateStatusBar();
	void OnUpdateEditCut( CCmdUI* pCmdUI );
	void OnEditCut();
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	void OnUpdateEditInsert( CCmdUI* pCmdUI );
	void OnEditInsert();
	void OnUpdateEditDelete( CCmdUI* pCmdUI );
	void OnEditDelete();
	void OnEditSelectAll();
	BOOL OnViewProperties();
	void CallSelectedRoutines();
	void SetSelectedVariable();
	BOOL IsInEditVariable();

private:
	int					m_nLastStartChar;		// Used to display status bar text
	int					m_nLastEndChar;			// Used to display status bar text
	int					m_nLastPos;				// Used to display status bar text

	CString				m_strEditVariableName;	// Variable being edited
	VARIANT				m_EditVariant;			// VARIANT for variable being edited
	CEditValue*			m_pEditValueCtrl;		// Edit control used to edit variable		

public:
	CScriptCtrl*		m_pScriptCtrl;
	CDirectMusicScript*	m_pScript;
	CEditSource			m_editSource;		// Subclasses IDC_SOURCE

// Form Data
public:
	//{{AFX_DATA(CScriptDlg)
	enum { IDD = IDD_DLG_SCRIPT };
	CButton	m_btnInitialize;
	CListCtrl	m_lstbxVariables;
	CStatic	m_staticSourcePrompt;
	CButton	m_btnRefresh;
	CStatic	m_staticVariablePrompt;
	CStatic	m_staticRoutinePrompt;
	CListBox	m_lstbxRoutines;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScriptDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	LRESULT OnEndEditValue( WPARAM wParam, LPARAM lParam );
	LRESULT OnCancelEditValue( WPARAM wParam, LPARAM lParam );

	// Generated message map functions
	//{{AFX_MSG(CScriptDlg)
	afx_msg void OnDestroy();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDblClkRoutineList();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRefresh();
	afx_msg void OnDblClkVariableList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickVariableList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnInitVariables();
	afx_msg void OnKeyDownVariableList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnReturnVariableList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnSetFocusVariableList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ScriptDesigner\ScriptDocType.cpp ===
// ScriptDocType.cpp : implementation file
//

#include "stdafx.h"

#include "ScriptDesignerDLL.h"
#include "Script.h"
#include <dmusicf.h>
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType constructor/destructor

CScriptDocType::CScriptDocType()
{
    m_dwRef = 0;
}

CScriptDocType::~CScriptDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType IUnknown implementation

HRESULT CScriptDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CScriptDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CScriptDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::GetResourceId

HRESULT CScriptDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_SCRIPT_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CScriptDocType::DoesExtensionMatch

HRESULT CScriptDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_SCRIPT_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}