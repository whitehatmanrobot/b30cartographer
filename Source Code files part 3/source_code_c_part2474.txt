AL_H_

#include <macros.h>
#include <xdbg.h>

#endif // #ifndef _MLINTERNAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\medialoader.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	medialoader.cpp

Abstract:

	copies media files from a server to the xbox

Author:

	Jeff Sullivan (jeffsul) 24-Jul-2001

Revision History:

	24-Jul-2001 jeffsul
		Initial Version

--*/

#include "medialoader.h"
#include "FileList.h"
#include "MLInternal.h"

#include <xnetref.h>
//#include <xtestlib.h>
//#include <xlog.h>
//#include <macros.h>
//#include <XboxDbg.h>

//#include <d3d8perf.h>
//#include <d3d8types.h>

//#include <stdio.h>
#include "regexpr.h"
using namespace regex;
//#include <CHAR.H>

#define ML_APPNAME	"MEDIAFILES"

extern HANDLE g_hLog;

// 172.26.160.17 = xstress
#define	ML_SERVER_IP	"172.26.172.21"
#define ML_SERVER_PORT	80
#define ML_SERVER_ROOT	"/stresscontent/"

static SOCKET	sock			=	0;

//------------------------------------------------------------------------------
//	Pre-define functions
//------------------------------------------------------------------------------
HRESULT
InitNetwork();

HRESULT 
DestroyNetwork();

HRESULT
ReconnectSocket();

BOOL 
FindNextFileRemote( 
	IN CFileList* 	pFileList, 
	OUT LPWIN32_FIND_DATA lpFindFileData 
);

CFileList* 
FindFirstFileRemote( 
	IN LPCSTR	lpFileName, 
	OUT LPWIN32_FIND_DATA lpFindFileData  
);

HRESULT 
CopyFileRemote( 
	IN CONST PMEDIAFILEDESC		pMediaFileDesc, 
	IN CONST LPWIN32_FIND_DATA	lpFindFileData 
);

BOOL 
ProduceFullFileName( 
	IN LPCSTR	lpszDestinationPath, 
	IN LPCSTR	lpszRemoteFilePath, 
	OUT LPSTR	lpszReturnedPath 
);

HANDLE 
CreateFile( 
	IN LPCSTR	lpszFilePath, 
	IN DWORD	dwFlags 
);

BOOL 
GetConst(
	IN LPCSTR	lpszStr, 
	IN INT		cchStr, 
	OUT PDWORD	pval
);

static INT g_nErrorLevel = 5;
VOID _stdcall
MLSetErrorLevel( 
	IN INT nErrorLevel 
)
{
	g_nErrorLevel = nErrorLevel;
}

#define ML_OUTPUT( level, func )	\
	if ( level <= g_nErrorLevel )	\
	{								\
		func;						\
	}

HRESULT _stdcall
LoadMedia( 
	IN MEDIAFILEDESC MediaFileDesc[] 
)
{
	HRESULT		hr		=		S_OK;
	UINT		i		=		0;
    BOOL        bFoundSomething = FALSE;

	EXECUTE( InitNetwork() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	while ( NULL != MediaFileDesc[i].lpszFromPath )
	{	
        if (MediaFileDesc[i].dwFlags > MLCOPY_MAXVALUE)
        {
    		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: MediaFileDesc element %d in array has invalid dwFlags.\nAre you sure you terminated your array with a NULL structure?\n", i) );
            return E_FAIL;
        }

        if (NULL == MediaFileDesc[i].lpszFromPath[0])
        {
    		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: MediaFileDesc element %d in array has empty lpszFromPath.\n", i));
            return E_FAIL;
        }
        
        
        /*
        if (MediaFileDesc[i].lpszFromPath[strlen(MediaFileDesc[i].lpszFromPath) - 1] == '/')
        {
    		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: MediaFileDesc element %d in array ends in '/'",i) );
            return E_FAIL;
        }
        */

		//------------------------------------------------------------------------------
		//	parse out file search string and number of random files
		//------------------------------------------------------------------------------
		CHAR	szSearchString[MAX_PATH];
		LPSTR	lpszFromFile	= NULL;
		LPCSTR lpszNumFiles	= NULL;
		UINT	nNumFiles		= 1;
		BOOL	bGetAllFiles	= FALSE;

		strcpy( szSearchString, MediaFileDesc[i].lpszFromPath );
		lpszFromFile = strtok( szSearchString, "\t%" );
		ML_OUTPUT( 5, DbgPrint( "[MediaLoader] Info: Getting '%s'\n", MediaFileDesc[i].lpszFromPath ) );
		if ( NULL == lpszFromFile )
		{
			ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to parse media file request '%s'\n", MediaFileDesc[i].lpszFromPath ) );
			return E_FAIL;
		}

		lpszNumFiles = strtok( NULL, " %\t" );
		if ( NULL != lpszNumFiles )
		{
			nNumFiles = atoi( lpszNumFiles );
			if ( 0 == nNumFiles )
			{
				// some kind of error in atoi
				ML_OUTPUT( 2, DbgPrint( "[MediaLoader] Warning: Number of random files parsed incorrectly, setting to 1\n" ) );
				nNumFiles = 1;
			}
		}
		else if ( '/' == szSearchString[ strlen( szSearchString ) - 1 ] )
		{
			// get all the files in the directory
			bGetAllFiles = TRUE;
			// add *.*
			strcat( lpszFromFile, "(\\w*).(\\w*)" );
		}
		else
		{
			bGetAllFiles = TRUE;
		}

		//------------------------------------------------------------------------------
		//	get files that match the search string
		//------------------------------------------------------------------------------
		CFileList*				pFileList	=	NULL;
		WIN32_FIND_DATA			FindData;

		pFileList = FindFirstFileRemote( lpszFromFile, &FindData );
		if ( NULL == pFileList )
		{
			ML_OUTPUT( 2, DbgPrint( "[MediaLoader] Warning: No files found that match '%s'\n", lpszFromFile ) );
			i++;
			continue;
		}

		if ( TRUE == bGetAllFiles )
		{
			nNumFiles = pFileList->GetNumFiles();
		}

		//------------------------------------------------------------------------------
		//	copy up to nNumFiles that match the specified search
		//------------------------------------------------------------------------------
		for ( UINT j=0; j < nNumFiles; j++ )
		{
			BOOL	bSuccess;


            bFoundSomething = TRUE;

			// copy a matching file to the xbox with the specified flags
			hr =  CopyFileRemote( &MediaFileDesc[i], &FindData );
			if ( FAILED( hr ) )
			{
				ML_OUTPUT( 2, DbgPrint( "[MediaLoader] Warning: Unable to copy file '%s'\n", FindData.cFileName ) );
			}

			if ( TRUE == bGetAllFiles )
			{
                HRESULT hrLocal = pFileList->GetFirstUnusedFile( &FindData );
				if ( FAILED( hrLocal ) && j != nNumFiles-1 )
				{
					ML_OUTPUT( 3, DbgPrint( "[MediaLoader] Warning: Only copied %d of expected %d files that match '%s'\n", j+1, nNumFiles, lpszFromFile ) );
					break;
				}

			}
			else
			{
				bSuccess = FindNextFileRemote( pFileList, &FindData );
				if ( FALSE == bSuccess && j != nNumFiles-1 )
				{
					ML_OUTPUT( 3, DbgPrint( "[MediaLoader] Warning: Only copied %d of expected %d files that match '%s'\n", j+1, nNumFiles, lpszFromFile ) );
					break;
				}
			}
		}

		SAFEDELETE( pFileList );
		i++;
	}

	if ( 0 == i )
	{
		ML_OUTPUT( 2, DbgPrint( "[MediaLoader] Warning: No files copied\n" ) );
	}

    if (!bFoundSomething)
    {
		ML_OUTPUT( 1, DbgPrint( "[MediaLoader] Error: No files were found by any of the search patterns.\n" ) );
        hr = E_FAIL;
    }
	else
	{
		hr = S_OK;
	}

	DestroyNetwork();

	return hr;
}


#define CHECKTOKEN( p )																\
if ( NULL == (p) )																	\
{																					\
	DbgPrint( "[MediaLoader] Warning: FILE%d not loaded, bad .ini value\n", i );		\
	continue;																		\
}

#if 0
HRESULT _stdcall
LoadMediaFromIni( 
	IN LPCSTR lpszIniFile 
)
{
	HRESULT			hr				= S_OK;

	//------------------------------------------------------------------------------
	//	allocate space for structure
	//------------------------------------------------------------------------------

	UINT			nNumFiles		= 0;
	PMEDIAFILEDESC	pMediaFileDescs = NULL;
	CHAR	szKeyName[MAX_PATH];
	CHAR	szValue[MAX_PATH*3];

	// find out how many files are listed
	while ( TRUE )
	{
		sprintf( szKeyName, "FILE%d", nNumFiles );
		GetIniString( ML_APPNAME, szKeyName, "Default", szValue, MAX_PATH*3, lpszIniFile );
		if ( 0 == strcmp( szValue, "Default" ) )
		{
			// end of files
			break;
		}
		nNumFiles++;
	}

	if ( 0 == nNumFiles )
	{
		ML_OUTPUT( 2, DbgPrint( "[MediaLoader] Warning: '%s' contains no file list or does not exist.  No files copied.\n", lpszIniFile ) );
		return S_FALSE;
	}

	// allocate the memory, add one struct for NULL terminator
	pMediaFileDescs = new MEDIAFILEDESC[ nNumFiles + 1 ];
	CHECKALLOC( pMediaFileDescs );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	//------------------------------------------------------------------------------
	//	set up the media file descriptions from the ini file
	//------------------------------------------------------------------------------
	for ( UINT i=0; i < nNumFiles; i++ )
	{
		LPCSTR	lpszToken;

		// get line from ini
		sprintf( szKeyName, "FILE%d", i );
		GetIniString( ML_APPNAME, szKeyName, "Default", szValue, MAX_PATH*3, lpszIniFile );
		if ( 0 == strcmp( szValue, "Default" ) )
		{
			ML_OUTPUT( 3, DbgPrint( "[MediaLoader] Warning: FILE%d not found in .ini, skipping\n", i ) );
			break;
		}

		// allocate memory for strings
		pMediaFileDescs[i].lpszFromPath = new CHAR [MAX_PATH];
		if ( NULL == pMediaFileDescs[i].lpszFromPath )
		{
			return E_OUTOFMEMORY;
		}
		pMediaFileDescs[i].lpszToPath = new CHAR [MAX_PATH];
		if ( NULL == pMediaFileDescs[i].lpszFromPath )
		{
			return E_OUTOFMEMORY;
		}

		// get the path to search on the remote server
		lpszToken = strtok( szValue, " \t" );
		CHECKTOKEN( lpszToken );
		strcpy( pMediaFileDescs[i].lpszFromPath, lpszToken );

		// get the directory to place the files in on the xbox
		lpszToken = strtok( NULL, " \t" );
		CHECKTOKEN( lpszToken );
		if ( '%' == lpszToken[0] )
		{
			// there was a random number of files specified
			strcat( pMediaFileDescs[i].lpszFromPath, " " );
			strcat( pMediaFileDescs[i].lpszFromPath, lpszToken );
			lpszToken = strtok( NULL, " \t" );
			CHECKTOKEN( lpszToken );
		}
		strcpy( pMediaFileDescs[i].lpszToPath, lpszToken );

		// get the copy flags
		lpszToken = strtok( NULL, " \t" );
		if ( NULL == lpszToken )
		{
			// creation flag not specified, set it to the default and move on
			pMediaFileDescs[i].dwFlags = COPY_ALWAYS;
			continue;
		}
		BOOL bSuccess = FALSE;
		bSuccess = GetConst( lpszToken, MAX_PATH, &pMediaFileDescs[i].dwFlags );
		if ( FALSE == bSuccess )
		{
			// creation flag not specified properly, set it to the default and move on
			pMediaFileDescs[i].dwFlags = COPY_ALWAYS;
			continue;
		}
	}

	// fill in the last strcut with NULLs
	pMediaFileDescs[ nNumFiles ].lpszFromPath = NULL;
	pMediaFileDescs[ nNumFiles ].lpszToPath = NULL;
	pMediaFileDescs[ nNumFiles ].dwFlags = 0;

	//------------------------------------------------------------------------------
	//	call the media loader
	//------------------------------------------------------------------------------

	EXECUTE( LoadMedia( pMediaFileDescs ) );

	//------------------------------------------------------------------------------
	//	clean up
	//------------------------------------------------------------------------------
	for ( i=0; i < nNumFiles; i++ )
	{
		SAFEDELETEARRAY( pMediaFileDescs[i].lpszFromPath );
		SAFEDELETEARRAY( pMediaFileDescs[i].lpszToPath );
	}

	SAFEDELETEARRAY( pMediaFileDescs );

	return hr;
}
#endif 0


CFileList* 
FindFirstFileRemote( 
	IN LPCSTR lpFileName, 
	OUT LPWIN32_FIND_DATA lpFindFileData  
)
{
	LPBYTE	lpHTMLResponse	=	NULL;
	CHAR	szRequest[HTTP_MAX_HEADER_SIZE];
	CHAR	szFileName[MAX_PATH];

	// create the request
	UINT nRequestLength;
	
	CHAR	szDirectory[MAX_PATH];
	CHAR	szDirectoryNoSpaces[MAX_PATH];
	LPCSTR	lpszToken;	
	szDirectory[0] = 'a';
	strcpy( szDirectory, "/stresscontent/" );
	lpszToken = strrchr( lpFileName, '/' );
	if ( NULL == lpszToken )
	{
		lpszToken = lpFileName + strlen( lpFileName ) + 1;
	}
	strncat( szDirectory, lpFileName, lpszToken-lpFileName );
	strcat( szDirectory, "/" );
	strcpy( szFileName, lpszToken+1 );

	UINT	i, j;
	UINT	nLength = strlen( szDirectory );
	j = 0;
	for ( i=0; i <= nLength; i++ )
	{
		if ( ' ' == szDirectory[i] )
		{
			szDirectoryNoSpaces[j] = '%';
			szDirectoryNoSpaces[j+1] = '2';
			szDirectoryNoSpaces[j+2] = '0';
			j += 3;
		}
		else
		{
			szDirectoryNoSpaces[j] = szDirectory[i];
			j++;
		}

		if ( j >= MAX_PATH )
		{
			ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Too many characters in filename.\n") );
			return NULL;
		}
	}

	nRequestLength = sprintf(szRequest, 
		"GET %s HTTP/1.1\r\n"
		"Accept: */*\r\n"
		"User-Agent: SMC\r\n"
		"Connection: Keep-Alive\r\n"
		"Host: %s\r\n"
		"\r\n",
		szDirectoryNoSpaces,
		ML_SERVER_IP );
	
	// send the request over the socket
	INT nNumBytes;
	nNumBytes = HTTPSendRequest( sock, szRequest, nRequestLength );
	if ( SOCKET_ERROR == nNumBytes || nNumBytes != nRequestLength )
	{
		ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Unable to send request over socket (error %d)\n", WSAGetLastError()) );
		return NULL;
	}

	// receive the response
	lpHTMLResponse = new BYTE[HTTP_MAX_HTML_SIZE];
	if( NULL == lpHTMLResponse )
	{
		return NULL;
	}
	nNumBytes = HTTPGetReply( sock, lpHTMLResponse, HTTP_MAX_HTML_SIZE );
	if ( SOCKET_ERROR == nNumBytes )
	{
		ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Unable to receive response on socket (error %d)\n", WSAGetLastError()) );
		SAFEDELETEARRAY( lpHTMLResponse );
		return NULL;
	}
	else if ( 0 == nNumBytes )
	{
		// re-connect the socket
		HRESULT hr = ReconnectSocket();
		if ( FAILED( hr ) )
		{
			nNumBytes = SOCKET_ERROR;
		}
		SAFEDELETEARRAY( lpHTMLResponse );
		return NULL;
	}

	lpHTMLResponse[nNumBytes+1] = '\0';

#ifdef ML_OUTPUT_HTML

	static INT nNumHTMLFiles = 0;
	HANDLE	hHTMLFile = INVALID_HANDLE_VALUE;
	CHAR	szHTMLFileName[MAX_PATH];
	DWORD	dwNumHTMLBytes;
	sprintf( szHTMLFileName, "T:\\HTML\\%d.html", nNumHTMLFiles );
	nNumHTMLFiles++;
	hHTMLFile = CreateFile( szHTMLFileName, CREATE_ALWAYS );
	if( INVALID_HANDLE_VALUE == hHTMLFile )
	{
		DbgPrint( "[MediaLoader] Warning: Unable to open HTML file '%s' for writing\n", szHTMLFileName );
	}
	if ( !WriteFile( hHTMLFile, lpHTMLResponse, nNumBytes, &dwNumHTMLBytes, NULL ) )
	{
		DbgPrint( "[MediaLoader] Warning: Unable to write HTML file '%s' (error %d)\n", szHTMLFileName, GetLastError() );
	}
	CloseHandle( hHTMLFile );

#endif ML_OUTPUT_HTML

	// create the file list
	HRESULT hr = S_OK;
	CFileList*	pFileList = new CFileList;
	CHECKALLOC( pFileList );
	if ( FAILED( hr ) )
	{
		SAFEDELETEARRAY( lpHTMLResponse );
		return NULL;
	}

	hr = pFileList->ParseHTML( (LPCSTR)lpHTMLResponse, nNumBytes, szFileName );
	if ( FAILED( hr ) )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to parse HTML properly\n" ) );
		SAFEDELETE( pFileList );
		SAFEDELETEARRAY( lpHTMLResponse );
		return NULL;
	}
	
	// get the first file from the list
	hr =  pFileList->GetRandomUnusedFile( lpFindFileData );
	if ( FAILED( hr ) )
	{
		SAFEDELETE( pFileList );
		SAFEDELETEARRAY( lpHTMLResponse );
		return NULL;
	}
	
	// return a pointer to the find files structure
	SAFEDELETEARRAY( lpHTMLResponse );
	return pFileList;
}


BOOL 
FindNextFileRemote( 
	IN CFileList* pFileList, 
	OUT LPWIN32_FIND_DATA lpFindFileData 
)
{
	HRESULT hr;
	hr = pFileList->GetRandomUnusedFile( lpFindFileData );
	if ( FAILED( hr ) )
	{
		return FALSE;
	}

	return TRUE;
}


DWORD 
GetFileRemote( 
	IN LPCSTR lpszRemoteFile, 
	HANDLE		hFile,
	IN DWORD64 dwSize
)
{
	DWORD		dwNumBytes = 0;

	CHAR szRequest[HTTP_MAX_HEADER_SIZE] = {0};

	// create the request
	UINT nRequestLength;

	nRequestLength = sprintf(szRequest, 
		"GET %s HTTP/1.1\r\n"
		"Accept: */*\r\n"
		"User-Agent: SMC\r\n"
		"Connection: Keep-Alive\r\n"
		"Host: %s\r\n"
		"\r\n",
		lpszRemoteFile,
		ML_SERVER_IP );

	// send the request over the socket
	dwNumBytes = HTTPSendRequest( sock, szRequest, nRequestLength );
	if ( SOCKET_ERROR == dwNumBytes || dwNumBytes != nRequestLength )
	{
		ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Unable to send request over socket (error %d)\n", WSAGetLastError()) );
		return 0;
	}

	// receive the response
	dwNumBytes = HTTPGetReplyToFile( sock, hFile, (INT)dwSize );
	if ( SOCKET_ERROR == dwNumBytes || 0 == dwNumBytes )
	{
		// re-connect the socket
		HRESULT hr = ReconnectSocket();
		if ( FAILED( hr ) )
		{
			dwNumBytes = SOCKET_ERROR;
		}
	}

	return dwNumBytes;
}


HRESULT 
CopyFileRemote( 
	IN CONST PMEDIAFILEDESC pMediaFileDesc, 
	IN CONST LPWIN32_FIND_DATA lpFindFileData 
)
{
	HRESULT hr		=	S_OK;

	//------------------------------------------------------------------------------
	//	open the file for writing
	//------------------------------------------------------------------------------
	CHAR	szFullFileName[MAX_PATH];
	HANDLE	hFile			=	NULL;
	BOOL	bSuccess		=	FALSE;

	bSuccess = ProduceFullFileName( pMediaFileDesc->lpszToPath, lpFindFileData->cFileName, szFullFileName );
	if ( FALSE == bSuccess )
	{
		return E_FAIL;
	}

	// see if the file already exists and if it is older than the remote file
	HANDLE	hFindFiles;
	BOOL	bLocalFileExists		=	FALSE;
	BOOL	bRemoteFileIsNewer		=	FALSE;
	WIN32_FIND_DATA FindFileData;
	hFindFiles = FindFirstFile( szFullFileName, &FindFileData );
	if ( INVALID_HANDLE_VALUE != hFindFiles )
	{
		bLocalFileExists = TRUE;
		DWORD64	dwLocalFileTime, dwRemoteFileTime;

		memcpy( &dwLocalFileTime, &FindFileData.ftCreationTime, sizeof(DWORD64) );
		memcpy( &dwRemoteFileTime, &lpFindFileData->ftCreationTime, sizeof(DWORD64) );

		if ( dwLocalFileTime < dwRemoteFileTime )
		{
			bRemoteFileIsNewer = TRUE;
		}
	}
	FindClose( hFindFiles );

	// se if we need to even bother writing the file
	if ( MLCOPY_IFNOTEXIST & pMediaFileDesc->dwFlags && TRUE == bLocalFileExists )
	{
		ML_OUTPUT( 5, DbgPrint( "[MediaLoader] Info: '%s' already exists, skipping\n", szFullFileName ) );
		return S_OK;
	}
	else if ( MLCOPY_IFNEWER & pMediaFileDesc->dwFlags && TRUE == bLocalFileExists && FALSE == bRemoteFileIsNewer )
	{
		ML_OUTPUT( 5, DbgPrint( "[MediaLoader] Info: '%s' is up to date, skipping\n", szFullFileName ) );
		return S_OK;
	}

	hFile = CreateFile( szFullFileName, CREATE_ALWAYS );
	if ( INVALID_HANDLE_VALUE == hFile )
	{	
		DWORD dwError = GetLastError();
		ML_OUTPUT( 1, DbgPrint( "[MediaLoader] Error: CreateFile failed (error %d) on '%s'\n", dwError, szFullFileName ) );
		return E_FAIL;
	}

	//------------------------------------------------------------------------------
	//	allocate a buffer to store the file
	//------------------------------------------------------------------------------
	//LPBYTE	lpBuf			=	NULL;
	DWORD64	dwNumBytes		=	(lpFindFileData->nFileSizeHigh * ((UINT64)MAXDWORD+1)) + lpFindFileData->nFileSizeLow;
		
	//------------------------------------------------------------------------------
	//	fill in buffer from remote server
	//------------------------------------------------------------------------------
	INT nNumBytes;
	nNumBytes = GetFileRemote( lpFindFileData->cFileName, /*lpBuf*/hFile, dwNumBytes );
	if ( nNumBytes != dwNumBytes )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Incorrect number of bytes returned (got %d, expected %d)\n", nNumBytes, dwNumBytes ) );
		CloseHandle( hFile );
		//SAFEDELETEARRAY( lpBuf );
		return E_FAIL;
	}

	//------------------------------------------------------------------------------
	//	clean up
	//------------------------------------------------------------------------------
	CloseHandle( hFile );
	//SAFEDELETEARRAY( lpBuf );

	return hr;
}


VOID CopyFileName( IN LPSTR lpszDest, IN LPCSTR lpszSrc )
{
	TCHAR	szWideFileNameOnly[MAX_PATH];

	for ( UINT i=0; i < strlen(lpszSrc); i++ )
	{
		szWideFileNameOnly[i] = (TCHAR)lpszSrc[i];
	}
	szWideFileNameOnly[i] = (TCHAR)'\0';
	regexpr	str( szWideFileNameOnly );
	
	rpattern pat( _T("%20"), _T(" "), GLOBAL ); 

	size_t num = str.substitute( pat );

	for ( i=0; i < str.length(); i++ )
	{
		lpszDest[i] = (CHAR)str.at( i );
	}
	lpszDest[i] = '\0';
}


BOOL 
ProduceFullFileName( 
	IN LPCSTR lpszDestinationPath, 
	IN LPCSTR lpszRemoteFilePath, 
	OUT LPSTR lpszReturnedPath 
)
{
	BOOL bReturn		=	TRUE;
	LPCSTR lpszFileName =	NULL;

	//------------------------------------------------------------------------------
	//	grab only the file name (no dir info) from the remote file name
	//------------------------------------------------------------------------------

	lpszFileName = strrchr( lpszRemoteFilePath, '/' ) + 1;
	if ( NULL == lpszFileName )
	{
		ML_OUTPUT( 1, DbgPrint( "[MediaLoader] Error: Unable to parse file name from '%s'\n", lpszRemoteFilePath ) );
		return FALSE;
	}

	//------------------------------------------------------------------------------
	//	add the file name onto the end of the destination directory
	//------------------------------------------------------------------------------

	strcpy( lpszReturnedPath, lpszDestinationPath );

	UINT nLength = strlen( lpszReturnedPath ) - 1;
	if ( '\\' != lpszReturnedPath[ nLength ] )
	{
		// add the '\' to the end of the directory
		strcat( lpszReturnedPath, "\\" );
	}

	strcat( lpszReturnedPath, lpszFileName );

	// change any '%20's in the file name to spaces
	CopyFileName( lpszReturnedPath, lpszReturnedPath );

	return bReturn;
}


HANDLE 
CreateFile( 
	IN LPCSTR lpszFilePath, 
	IN DWORD dwFlags 
)
{
	CHAR	szCurrentDir[MAX_PATH];
	CHAR	szRemainingDir[MAX_PATH];
	LPSTR	lpszNextDirectory = NULL;
	BOOL	bSuccess = FALSE;

	if ( NULL == lpszFilePath || MAX_PATH < strlen( lpszFilePath ) + 1 )
	{
		ML_OUTPUT( 1, DbgPrint( "[MediaLoader] Error: Bad filepath parameter to CreateFile: '%x'\n", lpszFilePath ) );
		return INVALID_HANDLE_VALUE;
	}

	//------------------------------------------------------------------------------
	//	make sure the directory exists that we want to copy to
	//------------------------------------------------------------------------------
	strcpy( szRemainingDir, lpszFilePath );
	strcpy( szCurrentDir, strtok( szRemainingDir, "\\" ) );
	strcat( szCurrentDir, "\\" );

	// go through each subdirectory one at a time and make sure all exist
	lpszNextDirectory = strtok( NULL, "\\" );
	while( NULL != lpszNextDirectory && strcat( szCurrentDir, lpszNextDirectory ) && NULL == strchr( szCurrentDir, '.' ) )
	{
		bSuccess = CreateDirectory( szCurrentDir, NULL );
		if ( FALSE == bSuccess )
		{
			DWORD dwError = GetLastError();
			// if the function failed because the directory already exists, that is fine
			// otherwise, we have a legitimate error
			if ( ERROR_ALREADY_EXISTS != dwError)
			{
				ML_OUTPUT( 1, DbgPrint( "[MediaLoader] Error: CreateDirectory failed (error %d) on '%s'\n", dwError, szCurrentDir ) );
				return INVALID_HANDLE_VALUE;
			}
		}
		strcat( szCurrentDir, "\\" );
		lpszNextDirectory = strtok( NULL, "\\" );
	}

	//------------------------------------------------------------------------------
	//	create the file to copy to
	//------------------------------------------------------------------------------
	return CreateFile(  lpszFilePath, 
						GENERIC_READ | GENERIC_WRITE |GENERIC_ALL, 
						0, 
						NULL, 
						dwFlags, 
						FILE_ATTRIBUTE_NORMAL, 
						NULL );
}


HRESULT
InitNetwork()
{
	HRESULT	hr			=	S_OK;

	INT		nSuccess	=	0;

	// initialize the Xbox Secure Network Library (SNL).
	if ( 0 == XNetAddRef() )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to initialize Xbox SNL (error %d)\n", nSuccess ) );
		return E_FAIL;
	}

	//Sleep( 2000 );

	// initialize the Xbox Winsock layer 
	WORD wVersionRequested;
	WSADATA wsaData;
	
	wVersionRequested = MAKEWORD( 2, 2 );
	nSuccess = WSAStartup( wVersionRequested, &wsaData );
	if ( 0 != nSuccess )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to intialize Xbox winsock layer (error %d)\n", WSAGetLastError() ) );
		XNetRelease();
		return E_FAIL;
	}
	
	// open the socket
	XNADDR	xna;
	while ( XNET_GET_XNADDR_PENDING == XNetGetTitleXnAddr( &xna ) );
	sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
	if ( INVALID_SOCKET == sock )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to open socket (error %d)\n", WSAGetLastError() ) );
		WSACleanup();
		XNetRelease();
		return E_FAIL;
	}
	
	// connect the socket
	SOCKADDR_IN dest;
	dest.sin_family = AF_INET;
	dest.sin_port = htons( ML_SERVER_PORT );
	dest.sin_addr.s_addr = inet_addr( ML_SERVER_IP );
	
	nSuccess = connect( sock, (SOCKADDR*)&dest, sizeof(SOCKADDR) );
	if( SOCKET_ERROR == nSuccess )
	{
		ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Unable to connect socket (error %d)\n", WSAGetLastError() ) );
		closesocket( sock );
		WSACleanup();
		XNetRelease();
		return E_FAIL;
	}

	return hr;
}

HRESULT 
ReconnectSocket()
{
	HRESULT		hr	=	S_OK;

	shutdown( sock, SD_BOTH );
	closesocket( sock );

	// open the socket
	sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
	if ( INVALID_SOCKET == sock )
	{
		ML_OUTPUT( 0, DbgPrint( "[MediaLoader] Error: Unable to re-open socket (error %d)\n", WSAGetLastError() ) );
		return E_FAIL;
	}
	
	// connect the socket
	SOCKADDR_IN dest;
	dest.sin_family = AF_INET;
	dest.sin_port = htons( ML_SERVER_PORT );
	dest.sin_addr.s_addr = inet_addr( ML_SERVER_IP );
	
	INT nSuccess = connect( sock, (SOCKADDR*)&dest, sizeof(SOCKADDR) );
	if( SOCKET_ERROR == nSuccess )
	{
		ML_OUTPUT( 0, DbgPrint("[MediaLoader] Error: Unable to re-connect socket (error %d)\n", WSAGetLastError() ) );
		closesocket( sock );
		return E_FAIL;
	}

	return hr;
}


HRESULT 
DestroyNetwork()
{
	HRESULT		hr	=	S_OK;

	shutdown( sock, SD_BOTH );
	closesocket( sock );
	WSACleanup();
	XNetRelease();

	return hr;
}

#if 0
INT	_stdcall
GetIniInt( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN INT		nDefault,				// return value if key name not found
	IN LPCSTR	lpFileName				// initialization file name
)
{
	return GetPrivateProfileIntA( lpAppName, lpKeyName, nDefault, lpFileName );
}


FLOAT _stdcall
GetIniFloat( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN FLOAT	fDefault,				// return value if key name not found
	IN LPCSTR	lpFileName				// initialization file name
)
{
	CHAR szBuf[MAX_PATH];
	CHAR szDefault[MAX_PATH];

	FLOAT fVal = 0.0f;

	sprintf( szDefault, "%f", fDefault );

	GetPrivateProfileStringA( (LPCSTR)lpAppName, (LPCSTR)lpKeyName, szDefault, szBuf, MAX_PATH, (LPCSTR)lpFileName );

	fVal = (FLOAT)atof( szBuf );

	return fVal;
}

INT _stdcall
GetIniString( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN LPCSTR	lpDefault,				// return value if key name not found
	OUT LPSTR	lpReturnedString,
	IN DWORD	nSize,
	IN LPCSTR	lpFileName				// initialization file name
)
{
	INT nNumChars = 0;
	CHAR* pChar;

	nNumChars = GetPrivateProfileStringA( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName );
	if ( 0 == nNumChars )
	{
		strcpy( lpReturnedString, lpDefault );
		return nNumChars;
	}

	pChar = strtok( lpReturnedString, "\n;" );
	strcpy( lpReturnedString, pChar );
	nNumChars = strlen( lpReturnedString );
	return nNumChars;
}


DWORD _stdcall
GetIniConst( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN DWORD	dwDefault,				// return value if key name not found
	IN LPCSTR	lpFileName				// initialization file name
)
{
	CHAR szBuf[MAX_PATH];
	CHAR* pChar;

	DWORD dwVal = 0L;
	INT	nNumChars = 0;
	BOOL bFound = FALSE;

	nNumChars = GetPrivateProfileStringA( (LPCSTR)lpAppName, (LPCSTR)lpKeyName, "", szBuf, MAX_PATH, (LPCSTR)lpFileName );
	if ( 0 == nNumChars )
	{
		return dwDefault;
	}

	pChar = strtok( szBuf, " \t\n;" );

	bFound = GetConst( pChar, MAX_PATH, &dwVal );
	if ( FALSE == bFound )
	{
		return dwDefault;
	}

	return dwVal;
}

// macros to help us define the size of our texcoords in fillrate.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1(0);
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2(0);
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3(0);
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4(0);

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1(1);
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2(1);
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3(1);
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4(1);

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1(2);
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2(2);
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3(2);
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4(2);

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1(3);
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2(3);
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3(3);
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4(3);

enum { TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume, TEX_Max };
enum { TIME_Present = 0x1, TIME_Render = 0x2 };

//=========================================================================
// Callback from inifile.cpp to get int string value
//=========================================================================
//#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))
BOOL _stdcall
GetConst(
	IN CONST CHAR*	szStr, 
	IN INT		cchStr, 
	OUT PDWORD	pval
)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        INT Val;
        CONST CHAR *szStr;
    } rgszConsts[] =
    {
        // Pixel Shaders
        XTAG(PS_TEXTUREMODES_NONE), XTAG(PS_TEXTUREMODES_PROJECT2D), XTAG(PS_TEXTUREMODES_PROJECT3D),
        XTAG(PS_TEXTUREMODES_CUBEMAP), XTAG(PS_TEXTUREMODES_PASSTHRU), XTAG(PS_TEXTUREMODES_CLIPPLANE),
        XTAG(PS_TEXTUREMODES_BUMPENVMAP), XTAG(PS_TEXTUREMODES_BUMPENVMAP_LUM), XTAG(PS_TEXTUREMODES_BRDF),
        XTAG(PS_TEXTUREMODES_DOT_ST), XTAG(PS_TEXTUREMODES_DOT_ZW), XTAG(PS_TEXTUREMODES_DOT_RFLCT_DIFF),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC), XTAG(PS_TEXTUREMODES_DOT_STR_3D), XTAG(PS_TEXTUREMODES_DOT_STR_CUBE),
        XTAG(PS_TEXTUREMODES_DPNDNT_AR), XTAG(PS_TEXTUREMODES_DPNDNT_GB), XTAG(PS_TEXTUREMODES_DOTPRODUCT),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST), XTAG(PS_COMPAREMODE_S_LT), XTAG(PS_COMPAREMODE_S_GE),
        XTAG(PS_COMPAREMODE_T_LT), XTAG(PS_COMPAREMODE_T_GE), XTAG(PS_COMPAREMODE_R_LT),
        XTAG(PS_COMPAREMODE_R_GE), XTAG(PS_COMPAREMODE_Q_LT), XTAG(PS_COMPAREMODE_Q_GE),
        XTAG(PS_COMBINERCOUNT_MUX_LSB), XTAG(PS_COMBINERCOUNT_MUX_MSB), XTAG(PS_COMBINERCOUNT_SAME_C0),
        XTAG(PS_COMBINERCOUNT_UNIQUE_C0), XTAG(PS_COMBINERCOUNT_SAME_C1), XTAG(PS_COMBINERCOUNT_UNIQUE_C1),
        XTAG(PS_INPUTMAPPING_UNSIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_UNSIGNED_INVERT), XTAG(PS_INPUTMAPPING_EXPAND_NORMAL),
        XTAG(PS_INPUTMAPPING_EXPAND_NEGATE), XTAG(PS_INPUTMAPPING_HALFBIAS_NORMAL), XTAG(PS_INPUTMAPPING_HALFBIAS_NEGATE),
        XTAG(PS_INPUTMAPPING_SIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_SIGNED_NEGATE), XTAG(PS_REGISTER_ZERO),
        XTAG(PS_REGISTER_DISCARD), XTAG(PS_REGISTER_C0), XTAG(PS_REGISTER_C1),
        XTAG(PS_REGISTER_FOG), XTAG(PS_REGISTER_V0), XTAG(PS_REGISTER_V1),
        XTAG(PS_REGISTER_T0), XTAG(PS_REGISTER_T1), XTAG(PS_REGISTER_T2),
        XTAG(PS_REGISTER_T3), XTAG(PS_REGISTER_R0), XTAG(PS_REGISTER_R1),
        XTAG(PS_REGISTER_V1R0_SUM), XTAG(PS_REGISTER_EF_PROD), XTAG(PS_REGISTER_ONE),
        XTAG(PS_REGISTER_NEGATIVE_ONE), XTAG(PS_REGISTER_ONE_HALF), XTAG(PS_REGISTER_NEGATIVE_ONE_HALF),
        XTAG(PS_CHANNEL_RGB), XTAG(PS_CHANNEL_BLUE), XTAG(PS_CHANNEL_ALPHA),
        XTAG(PS_FINALCOMBINERSETTING_CLAMP_SUM), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_V1), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_R0),
        XTAG(PS_COMBINEROUTPUT_IDENTITY), XTAG(PS_COMBINEROUTPUT_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1),
        XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_2), XTAG(PS_COMBINEROUTPUT_SHIFTRIGHT_1),
        XTAG(PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_AB_MULTIPLY),
        XTAG(PS_COMBINEROUTPUT_AB_DOT_PRODUCT), XTAG(PS_COMBINEROUTPUT_CD_MULTIPLY), XTAG(PS_COMBINEROUTPUT_CD_DOT_PRODUCT),
        XTAG(PS_COMBINEROUTPUT_AB_CD_SUM), XTAG(PS_COMBINEROUTPUT_AB_CD_MUX),
        XTAG(PS_DOTMAPPING_ZERO_TO_ONE), XTAG(PS_DOTMAPPING_MINUS1_TO_1_D3D), XTAG(PS_DOTMAPPING_MINUS1_TO_1_GL),
        XTAG(PS_DOTMAPPING_MINUS1_TO_1), XTAG(PS_DOTMAPPING_HILO_1), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_D3D), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_GL),
        XTAG(PS_DOTMAPPING_HILO_HEMISPHERE),

        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

		// D3DSWAPEFFECT
		XTAG(D3DSWAPEFFECT_DISCARD), XTAG(D3DSWAPEFFECT_FLIP), XTAG( D3DSWAPEFFECT_COPY),

		// D3DPRESENTFLAGs
		XTAG(D3DPRESENTFLAG_LOCKABLE_BACKBUFFER), XTAG(D3DPRESENTFLAG_WIDESCREEN),
		XTAG(D3DPRESENTFLAG_INTERLACED), XTAG(D3DPRESENTFLAG_PROGRESSIVE),
		XTAG(D3DPRESENTFLAG_FIELD), XTAG(D3DPRESENTFLAG_10X11PIXELASPECTRATIO),

		// D3DMULTISAMPLE_TYPEs
        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

		// STENCILOPs
		XTAG(D3DSTENCILOP_KEEP),
		XTAG(D3DSTENCILOP_ZERO),
		XTAG(D3DSTENCILOP_REPLACE),
		XTAG(D3DSTENCILOP_INCRSAT),
		XTAG(D3DSTENCILOP_DECRSAT),
		XTAG(D3DSTENCILOP_INVERT),
		XTAG(D3DSTENCILOP_INCR),
		XTAG(D3DSTENCILOP_DECR),

		// D3DZBUFFERTYPE
		XTAG(D3DZB_TRUE), XTAG(D3DZB_USEW), XTAG(D3DZB_FALSE),

        XTAG(D3DTEXF_NONE), XTAG(D3DTEXF_POINT), XTAG(D3DTEXF_LINEAR), XTAG(D3DTEXF_ANISOTROPIC),
        XTAG(D3DTEXF_QUINCUNX), XTAG(D3DTEXF_GAUSSIANCUBIC),

        XTAG(TEX_None), XTAG(TEX_2d), XTAG(TEX_Cubemap), XTAG(TEX_Volume),

        XTAG(TIME_Present), XTAG(TIME_Render),

        // swaths
        XTAG(D3DSWATH_8), XTAG(D3DSWATH_16), XTAG(D3DSWATH_32),
        XTAG(D3DSWATH_64), XTAG(D3DSWATH_128), XTAG(D3DSWATH_OFF),

        XTAG(D3DCOLORWRITEENABLE_RED), XTAG(D3DCOLORWRITEENABLE_GREEN), XTAG(D3DCOLORWRITEENABLE_BLUE),
        XTAG(D3DCOLORWRITEENABLE_ALPHA), XTAG(D3DCOLORWRITEENABLE_ALL),

		// File Creation Flags
		XTAG(CREATE_NEW), XTAG(CREATE_ALWAYS), XTAG(OPEN_EXISTING), XTAG(OPEN_ALWAYS), XTAG(TRUNCATE_EXISTING),

		// File Copy Flags
		XTAG(COPY_IF_NOT_EXIST), XTAG(COPY_IF_NEWER), XTAG(COPY_ALWAYS),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = (DWORD)rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}
#endif 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\HTTPHeader.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	HTTPHeader.h

Abstract:

	Abstracts internals of client HTTP & TCP/IP send/recv calls
	to simply HTTPSendRequest and HTTPGetReply

Author:

	Jeff Sullivan (jeffsul) 02-Aug-2001

Revision History:

	02-Aug-2001 jeffsul
		Initial Version

--*/

#ifndef __HTTPHEADER_H__
#define __HTTPHEADER_H__

#include <xtl.h>

//------------------------------------------------------------------------------
//	Public:
//------------------------------------------------------------------------------

/*++

Routine Description:

	Sends an HTTP request over the specified socket

Arguments:

	see below

Return Value:

	the number of bytes sent if ok
	SOCKET_ERROR if failure

--*/
extern INT
HTTPSendRequest(
	SOCKET	socket,			//	the socket to send the request on   
	LPCSTR	lpBuf,			//	the actual request buffer
	INT		nLength			//	the length of the request buffer
);


/*++

Routine Description:

	Gets an HTTP reply from the specifed socket, in the process
	the function strips out all HTTP information and 
	gets only the actual data of the response

Arguments:

	see below

Return Value:

	the number of bytes in the actual data if ok
	SOCKET_ERROR if failure

--*/
extern INT
HTTPGetReply(
	SOCKET	socket,			//	the socket to receive the reply on
	LPVOID	lpBuf,			//	the buffer to store the actual reply
	INT		nLength			//	the max size of the reply buffer
);


extern INT
HTTPGetReplyToFile(
	SOCKET	socket,			//	the socket to receive the reply on
	HANDLE	hFile,			//	a handle to the file to save the reply
	INT		nLength			//	the max size of the file
);


//------------------------------------------------------------------------------
//	Internal:
//------------------------------------------------------------------------------

#define HTTP_MAX_HEADER_SIZE	1000
#define HTTP_MAX_BUFFER_SIZE	5000
#define	HTTP_MAX_HTML_SIZE		500000

// Transfer Encodings:
#define HTTP_TE_NORMAL		0x00000000
#define	HTTP_TE_CHUNKED		0x00000001

// Content Types:
#define HTTP_CT_TEXT_HTML	0x00000000
#define HTTP_CT_AUDIO_WAV	0x00000001
#define HTTP_CT_IMAGE		0x00000002
#define FTTP_CT_UNDEFINED	0xffffffff

typedef struct _HTTPHEADER				//	a structure to hold the information in an http transfer header
{
	FLOAT	fVersion;					//	http version number
	INT		nStatusCode;				//	http status code ( 200 = ok, 404 = not found )
	CHAR	szStatusMessage[MAX_PATH];	//	message relating to status code
	CHAR	szServer[MAX_PATH];			//	the name of the server sending the information
	CHAR	szDate[MAX_PATH];			//	date of the transfer
	DWORD	dwTransferEncoding;			//	transfer encoding ( HTTP_TE_NORMAL, HTTP_TE_CHUNKED, etc )
	DWORD	dwContentType;				//	text/html, audio/wav, etc
	DWORD	dwContentLength;			//	length of the transfer ( not including the header )
	DWORD	dwBytesLeft;				//	bytes left in the transmission
} HTTPHEADER, *PHTTPHEADER;

extern HRESULT							//	separates an http reply into the header and body
HTTPParseReply( 
	IN LPSTR		lpBuf,				//	the buffer received from the server
	IN DWORD		dwSize,				//	the size of the received buffer
	OUT PHTTPHEADER pHTTPHeader,		//	a pointer to a structure to fill in with http header info
	OUT LPVOID		lpBody,				//	a pointer to a buffer to hold the body of the transfer
	OUT	LPDWORD		lpdwSizeCopied		//	a pointer to a DWORD that will hold the number of bytes copied to lpBody
);

extern HRESULT							//	separates an http chunk into any info tags and the main body
HTTPParseChunk(
	IN LPBYTE		lpChunk,			//	the chunk received from the server
	IN DWORD		dwSize,				//	the size of the chunk received
	OUT	LPVOID		lpBody,				//	a pointer to a buffer to hold the body of the chunk
	OUT	LPDWORD		lpdwSizeCopied,		//	a pointer to a DWORD that will hold the number of bytes copied to lpBody
	OUT	PBOOL		pbIsLastChunk		//	a pointer to a BOOL that will be TRUE if this is the last chunk of a transfer
);

/*#define SAFEDELETEARRAY( p )			\
{										\
	if ( NULL != (p) )					\
	{									\
		delete [] (p);					\
		(p) = NULL;						\
	}									\
}*/
	
#endif // #ifndef __HTTPHEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\regexpr.cpp ===
//+---------------------------------------------------------------------------
//
//  File:         basic_regexpr.cxx
//
//  Contents:    
//
//  Classes:     
//
//  Functions:  
//
//  Coupling:    
//
//  Notes:        
//
//  History:     1-11-1999    ericne    Created
//
//----------------------------------------------------------------------------

// unlimited inline expansion (compile with /Ob1 or /Ob2)
#pragma inline_depth(255)

// warning C4355: 'this' : used in base member initializer list
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
// warning C4660: template-class specialization 'foo<bar>' is already instantiated
// warning C4706: assignment within conditional expression
// warning C4786: identifier was truncated to '255' characters in the debug information
// warning C4800: 'int' : forcing value to bool 'true' or 'false' (performance warning)
#pragma warning( disable : 4355 4511 4512 4660 4706 4786 4800 )

#include <assert.h>
#include <malloc.h> // for _alloca	
#include <algorithm>
#include <minmax.h>
#include "regexpr.h"

using namespace std;

namespace regex 
{

#ifdef _MT
// Global critical section used to synchronize the creation of static const patterns
CRegExCritSect g_objRegExCritSect;
#endif

// For use while doing uppercase/lowercase conversions:
// For use while doing uppercase/lowercase conversions:
inline  char    to_upper(  char    ch ) { return ( char  )toupper(ch); }
inline  char    to_lower(  char    ch ) { return ( char  )tolower(ch); }
inline wchar_t to_upper( wchar_t ch ) { return (wchar_t)towupper(ch); }
inline wchar_t to_lower( wchar_t ch ) { return (wchar_t)towlower(ch); }
template< typename II, typename CI > 
void to_upper( II ibegin, CI iend )
{
     for( ; static_cast<CI>(ibegin) != iend; ++ibegin )
          *ibegin = to_upper( *ibegin );
}
template< typename II, typename CI > 
void to_lower( II ibegin, CI iend )
{
     for( ; static_cast<CI>(ibegin) != iend; ++ibegin )
          *ibegin = to_lower( *ibegin );
}

template< typename II, typename CI >
unsigned parse_int( II & istr, CI iend, const unsigned m_max = unsigned(-1) )
{
     unsigned retval = 0;
     while( static_cast<CI>(istr) != iend && '0' <= *istr && '9' >= *istr && m_max > retval )
     {
          retval *= 10;
          retval += (unsigned)*istr - (unsigned)'0';
          ++istr;
     }
     if( m_max < retval )
     {
          retval /= 10;
          --istr;
     }
     return retval;
}

// The STL member function adapters don't handle const member functions,
// so explicitly handle that special case with const_mem_fun1()
template<class R, class Ty, class A>
class const_mem_fun1_t : public binary_function<const Ty *, A, R> 
{
     R (Ty::*m_p)(A) const throw();
public:
     explicit const_mem_fun1_t(R (Ty::*p)(A) const throw()) throw()
          : m_p(p) {}
     R operator()(const Ty * p, A arg) const throw()
          {return ((p->*m_p)(arg));}
};

template<class R, class Ty, class A>
inline const_mem_fun1_t<R,Ty,A> mem_fun1(R (Ty::*p)(A) const throw()) throw()
     {return const_mem_fun1_t<R,Ty,A>(p);}

// This class is used to speed up character set matching by providing
// a bitset that spans the ASCII range. std::bitset is not used because
// the range-checking slows it down.
// Note: The division and modulus operations are optimized by the compiler
// into bit-shift operations.
class ascii_bitvector
{
     typedef unsigned int elem_type;

     enum { CBELEM = 8 * sizeof elem_type,      // count of bytes per element
              CELEMS = (UCHAR_MAX+1) / CBELEM }; // number of element in array
     elem_type m_rg[ CELEMS ];

     // Used to inline operations like: bv1 |= ~bv2; without creating temp bit vectors.
     struct not_ascii_bitvector
     {
          const ascii_bitvector & m_ref;
          not_ascii_bitvector( const ascii_bitvector & ref ) throw()
                : m_ref(ref) {}
     };
public:
     ascii_bitvector() throw()
          { memset( m_rg, 0, CELEMS * sizeof elem_type ); }
     
     inline void set( unsigned char ch ) throw()
          { m_rg[ ( ch / CBELEM ) ] |= ( (elem_type)1U << ( ch % CBELEM ) ); }
     
     inline bool operator[]( unsigned char ch ) const throw()
          { return 0 != ( m_rg[ ( ch / CBELEM ) ] & ( (elem_type)1U << ( ch % CBELEM ) ) ); }
     
     inline not_ascii_bitvector operator~() const throw()
          { return not_ascii_bitvector(*this); }
     
     inline ascii_bitvector & operator|=( const ascii_bitvector & that ) throw()
          { for( int i=0; i<CELEMS; ++i )
                  m_rg[i] |= that.m_rg[i];
             return *this; }
     
     inline ascii_bitvector & operator|=( const not_ascii_bitvector & that ) throw()
          { for( int i=0; i<CELEMS; ++i )
                  m_rg[i] |= ~that.m_ref.m_rg[i];
             return *this; }
};

const ascii_bitvector & get_digit_vector(void)
{
     // 0-9
     class digit_vector : public ascii_bitvector
     {
     public:
          digit_vector()
          {
                unsigned char ich;
                for( ich ='0'; ich <= '9'; ++ich )
                     set(ich);
          }
     };

     static const digit_vector s_digit_vector;
     return s_digit_vector;
}

const ascii_bitvector & get_word_vector(void)
{
     // a-zA-Z_0-9
     class word_vector : public ascii_bitvector
     {
     public:
          word_vector()
          {
                unsigned char ich;
                for( ich = 'a'; ich <= 'z'; ++ich )
                     set(ich);
                for( ich = 'A'; ich <= 'Z'; ++ich )
                     set(ich);
                for( ich = '0'; ich <= '9'; ++ich )
                     set(ich);
                set('_');
          }
     };

     static const word_vector s_word_vector;
     return s_word_vector;
}

const ascii_bitvector & get_space_vector(void)
{
     // " \t\r\n\f"
     class space_vector : public ascii_bitvector
     {
     public:
          space_vector()
          {
                set(' ');
                set('\t');
                set('\r');
                set('\n');
                set('\f');
          }
     };

     static const space_vector s_space_vector;
     return s_space_vector;
}

//
// Operator implementations
//

// Base type used so that all derived operators share typedefs.
template< typename CI >
struct op_t : public binary_function<match_param<CI>,CI,bool>
{
     typedef CI const_iterator;
     typedef typename iterator_traits<CI>::value_type char_type;
};

// Evaluates the beginning-of-string condition
template< typename CI >
struct bos_t : public op_t<CI>
{
     inline bool operator()( const match_param<CI> & param, CI iter ) const
     {
          return param.ibegin == iter;
     }
};

// Find the beginning of a line, either beginning of a string, or the character
// immediately following a newline
template< typename CI >
struct bol_t : public bos_t<CI>
{
     inline bool operator()( const match_param<CI> & param, CI iter ) const
     {
          return bos_t<CI>::operator()(param,iter) || char_type('\n') == *--iter;
     }
};

// Evaluates end-of-string condition for string's
template< typename CI >
struct eos_t : public op_t<CI>
{
     inline bool operator()( const match_param<CI> & param, CI iter ) const
     {
          return param.istop == iter;
     }
};

// Evaluates end-of-string condidition for C-style string's when the length is unknown by
// looking for the null-terminator.
template< typename CI >
struct eocs_t : public op_t<CI>
{
     inline bool operator()( const match_param<CI> &, CI iter ) const
     {
          return char_type('\0') == *iter;
     }
};

// Evaluates end-of-line conditions, either the end of the string, or a
// return or newline character.
template< typename EOS >
struct eol_t_t : public EOS
{
     typedef typename EOS::const_iterator CI;
     typedef typename EOS::char_type char_type;
     inline bool operator()( const match_param<CI> & param, CI iter ) const
     {
          return EOS::operator()(param,iter) || char_type('\n') == *iter || char_type('\r') == *iter;
     }
};

template< typename CI > struct eol_t  : public eol_t_t<eos_t<CI> >  {};
template< typename CI > struct eocl_t : public eol_t_t<eocs_t<CI> > {};

// Evaluates perl's end-of-string conditions, either the end of the string, or a
// newline character followed by end of string. (Only used by $ and /Z assertions)
template< typename EOS >
struct peos_t_t : public EOS
{
     typedef typename EOS::const_iterator CI;
     typedef typename EOS::char_type char_type;
     inline bool operator()( const match_param<CI> & param, CI iter ) const
     {
          return EOS::operator()(param,iter) || ( ( char_type('\n') == *iter ) && EOS::operator()(param,++iter) );
     }
};

template< typename CI > struct peos_t  : public peos_t_t<eos_t<CI> >  {};
template< typename CI > struct peocs_t : public peos_t_t<eocs_t<CI> > {};

// compare two characters, case-sensitive
template< typename CH >
struct ch_neq_t : public binary_function<CH, CH, bool>
{
     typedef CH char_type;
     inline bool operator()( register CH ch1, register CH ch2 ) const
     {
          return ch1 != ch2;
     }
};

// Compare two characters, disregarding case
template< typename CH >
struct ch_neq_nocase_t : public binary_function<CH, CH, bool>
{
     typedef CH char_type;
     inline bool operator()( register CH ch1, register CH ch2 ) const
     {
          return to_upper(ch1) != to_upper(ch2);
     }
};

//
// Helper functions for match and substitute
//

template< typename CI >
size_t string_length( CI iter )
{
     size_t n = 0;
     while( 0 != *iter++ )
          ++n;
     return n;
}

template< typename CI >
backref_tag<CI> _do_match( const basic_rpattern_base<CI> & pat, match_param<CI> & param ) throw()
{
     typedef typename iterator_traits<CI>::value_type char_type;
     
     bool         floop  = pat.loops();
     unsigned    flags  = pat.flags();
     width_type nwidth = pat.get_width();

     const sub_expr<CI> * pfirst = pat.get_first_subexpression();

     try
     {
          vector<backref_tag<CI> > rgbackrefs; // dummy backref vector

          if( NULL == param.prgbackrefs )
                param.prgbackrefs = & rgbackrefs;

          param.prgbackrefs->resize( pat._cgroups_total() ); 
          fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );

          // If a pattern is optimized for CSTRINGS, it can save a call
          // to calculate the length of the string.
          if( CI(0) == param.istop && ( ( RIGHTMOST & flags ) || ( 0 == ( CSTRINGS & flags ) ) ) )
                param.istop = param.istart + string_length( param.istart );

          if( CI(0) != param.istop )
          {
                // If the minimum width of the pattern exceeds the width of the
                // string, a succesful match is impossible
                if( nwidth.m_min <= (size_t)distance( param.istart, param.istop ) )
                {
                     CI local_istop = param.istop;
                     advance( local_istop, -int( nwidth.m_min ) );

                     if( RIGHTMOST & flags )
                     {
                          // begin trying to match after the last character.
                          // Continue to the beginning
                          for( CI icur = local_istop; icur >= param.istart; --icur )
                                if( pfirst->domatch( param, icur ) ) 
                                     break; // m_floop not used for rightmost matches
                     }
                     else
                     {
                          // begin trying to match before the first character.
                          // Continue to the end
                          for( CI icur = param.istart; icur <= local_istop; ++icur )
                                if( pfirst->domatch( param, icur ) || ! floop )
                                     break;
                     }
                }
          }
          else
          {
                // begin trying to match before the first character.
                // Continue to the end
                for( CI icur = param.istart; ; ++icur )
                {
                     if( pfirst->domatch( param, icur ) || ! floop )
                          break;
                     if( char_type('\0') == *icur )
                          break;
                }
          }
     }
     catch(...) // bad alloc, stack overflow?
     {
          fill( param.prgbackrefs->begin(), param.prgbackrefs->end(), backref_tag<CI>() );
     }

     // Shrink the backref vector to chop off information about the "invisible" groups
     param.prgbackrefs->resize( pat.cgroups() );

     return (*param.prgbackrefs)[0];
}

template< typename CI, typename CH, typename TR, typename AL >
size_t _do_subst( basic_regexpr<CH,TR,AL> & str, const basic_rpattern_base<CI> & pat, size_t strpos, size_t strlen ) throw(bad_alloc)
{
     typedef iterator_traits<CI>::value_type char_type;
     typedef list<subst_node>::const_iterator LCI;
     enum { UPPER = -1, NIL, LOWER } next = NIL, rest = NIL;
     bool first = true;
     size_t old_strpos = strpos;
     const list<subst_node> & subst_list = pat.get_subst_list();
     basic_string<CH,TR,AL>::iterator itstrlen = str.begin();
     advance( itstrlen, strpos + strlen );
     const basic_string<char_type> & subst = pat.get_subst();
     push_new_handler pnh( &my_new_handler );
     
     for( LCI isubst = subst_list.begin(); isubst != subst_list.end(); ++isubst )
     {
          size_t sublen;
          basic_string<CH,TR,AL>::const_iterator  itsubpos1; // iter into str
          basic_string<CH,TR,AL>::const_iterator  itsublen1;
          basic_string<char_type>::const_iterator itsubpos2; // iter into subst string
          basic_string<char_type>::const_iterator itsublen2;
          basic_string<CH,TR,AL>::iterator itstrpos = str.begin();
          advance( itstrpos, strpos );

          switch( isubst->stype )
          {
                case subst_node::SUBST_STRING:
                     itsubpos2 = subst.begin();
                     advance( itsubpos2, isubst->subst_string.rstart );
                     itsublen2 = itsubpos2;
                     advance( itsublen2, isubst->subst_string.rlength );

                     first ? str.replace( itstrpos, itstrlen, itsubpos2, itsublen2 ) : 
                                str.insert( itstrpos, itsubpos2, itsublen2 );
                     sublen = distance( itsubpos2, itsublen2 );
                     break;

                case subst_node::SUBST_BACKREF:
                     switch( isubst->subst_backref )
                     {
                     case subst_node::PREMATCH:
                          itsubpos1 = str.backref_str().begin();
                          itsublen1 = itsubpos1;
                          advance( itsublen1, sublen = str.rstart() );
                          break;
                     case subst_node::POSTMATCH:
                          itsubpos1 = str.backref_str().begin();
                          advance( itsubpos1, str.rstart() + str.rlength() );
                          itsublen1 = str.backref_str().end();
                          break;
                     default:
                          itsubpos1 = str.backref_str().begin();
                          advance( itsubpos1, str.rstart( isubst->subst_backref ) );
                          itsublen1 = itsubpos1;
                          advance( itsublen1, str.rlength( isubst->subst_backref ) );
                          break;
                     }

                     first ? str.replace( itstrpos, itstrlen, itsubpos1, itsublen1 ) : 
                                str.insert( itstrpos, itsubpos1, itsublen1 );
                     sublen = distance( itsubpos1, itsublen1 );
                     break;

                case subst_node::SUBST_OP:
                     switch( isubst->op )
                     {
                     case subst_node::UPPER_ON:
                          rest = UPPER;
                          break;
                     case subst_node::UPPER_NEXT:
                          next = UPPER;
                          break;
                     case subst_node::LOWER_ON:
                          rest = LOWER;
                          break;
                     case subst_node::LOWER_NEXT:
                          next = LOWER;
                          break;
                     case subst_node::ALL_OFF:
                          rest = NIL;
                          break;
                     default:
                          __assume(0);
                     }
                     continue; // jump to the next item in the list

                default:
                     __assume(0);
          }

          first = false;

          // Are we upper- or lower-casing this string?
          if( rest )
          {
                basic_string<CH,TR,AL>::iterator istart = str.begin();
                advance( istart, strpos );
                basic_string<CH,TR,AL>::const_iterator istop = istart;
                advance( istop, sublen );
                switch( rest )
                {
                case UPPER:
                     to_upper( istart, istop );
                     break;
                case LOWER:
                     to_lower( istart, istop );
                     break;
                default:
                     __assume(0);
                }
          }

          // Are we upper- or lower-casing the next character?
          if( next )
          {
                switch( next )
                {
                case UPPER:
                     str[strpos] = to_upper(str[strpos]);
                     break;
                case LOWER:
                     str[strpos] = to_lower(str[strpos]);
                     break;
                default:
                     __assume(0);
                }
                next = NIL;
          }

          strpos += sublen;
     }

     // If *first* is still true, then we never called str.replace, and the substitution
     // string is empty. Erase the part of the string that the pattern matched.
     if( first )
          str.erase( strpos, strlen );

     // return length of the substitution
     return strpos - old_strpos;
}

//
// Implementation of basic_regexpr
//

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::substitute( 
     const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat, 
     size_type pos, 
     size_type len ) throw(bad_alloc)
{
     if( pat.flags() & CSTRINGS )
     {
          assert( ! "You can't use a pattern optimized for CSTRINGS with regexpr::substitute" );
          return 0;
     }

     backref_vector rgbackrefs; // dummy backref vector
     backref_vector * prgbackrefs = & rgbackrefs;
     const bool fsave_backrefs = ( pat.uses_backrefs() || !( pat.flags() & NOBACKREFS ) );

     if( fsave_backrefs )
     {
          prgbackrefs = & m_rgbackrefs;
          m_pbackref_str = & ( m_backref_str = *this );
     }
     else
     {
          m_backref_str.erase();
          m_pbackref_str = this;
          m_rgbackrefs.resize( 0 );
     }

     backref_type br;
     size_t csubst = 0;
     long stop_offset = ( len == npos ? 
                                 m_pbackref_str->size() : 
                                 min( pos + len, m_pbackref_str->size() ) );

     match_param<const_iterator> param( m_pbackref_str->begin(),
                                                    m_pbackref_str->begin(),
                                                    prgbackrefs );
     advance( param.istart, pos );
     advance( param.istop, stop_offset );
     param.ibegin = param.istart;

     if( GLOBAL & pat.flags() )
     {
          const bool fAll    = ( ALLBACKREFS    == ( ALLBACKREFS    & pat.flags() ) );
          const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );
          backref_vector rgtempbackrefs; // temporary vector used if fsave_backrefs

          long pos_offset = 0; // keep track of how much the backref_str and
                                      // the current string are out of sync

          while( br = _do_match( pat, param ) )
          {
                ++csubst;
                size_type match_length = distance( br.first, br.second );
                pos = distance( m_pbackref_str->begin(), br.first );
                size_type subst_length = _do_subst( *this, pat, pos + pos_offset, match_length );

                if( fsave_backrefs )
                {
                     pos += match_length;
                     pos_offset += ( subst_length - match_length );

                     // Handle specially the backref flags
                     if( fFirst )
                          rgtempbackrefs.push_back( br );
                     else if( fAll )
                          rgtempbackrefs.insert( rgtempbackrefs.end(),
                                                         param.prgbackrefs->begin(), 
                                                         param.prgbackrefs->end() );
                     else
                          rgtempbackrefs.swap( *param.prgbackrefs );
                }
                else
                {
                     pos += subst_length;
                     stop_offset += ( subst_length - match_length );

                     // we're not saving backref information, so we don't
                     // need to do any special backref maintenance here
                }
                
                // prevent a pattern that matches 0 characters from matching
                // again at the same point in the string
                if( 0 == match_length )
                {
                     if( br.first == param.istop ) // We're at the end, so we're done
                          break;
                     ++pos;
                }

                param.istart = m_pbackref_str->begin();
                advance( param.istart, pos ); // ineffecient for bidirectional iterators.

                param.istop = m_pbackref_str->begin();
                advance( param.istop, stop_offset ); // ineffecient for bidirectional iterators.
          }

          // If we did special backref handling, swap the backref vectors
          if( fsave_backrefs && ( !br || fFirst || fAll ) )
                param.prgbackrefs->swap( rgtempbackrefs );
          else if( ! (*param.prgbackrefs)[0] )
                param.prgbackrefs->clear();
     }
     else if( br = _do_match( pat, param ) )
     {
          ++csubst;
          _do_subst( *this, pat,
                         distance( m_pbackref_str->begin(), br.first ),
                         distance( br.first, br.second ) );
     }

     if( NOBACKREFS == ( pat.flags() & NOBACKREFS ) )
          param.prgbackrefs->clear();

     return csubst;
}

//
// Helper functions called from both basic_regexpr match methods
//

template< typename EOS >
backref_tag< typename EOS::const_iterator > _match_helper( 
     const basic_rpattern_base<typename EOS::const_iterator> & pat,
     match_param<typename EOS::const_iterator> & param,
     EOS eos )
{
     typedef typename EOS::const_iterator CI;

     if( GLOBAL & pat.flags() ) // do a global find
     {
          // The NOBACKREFS flag is ignored in the match method.
          const bool fAll    = ( ALLBACKREFS    == ( ALLBACKREFS    & pat.flags() ) );
          const bool fFirst = ( FIRSTBACKREFS == ( FIRSTBACKREFS & pat.flags() ) );

          backref_tag<CI>  br;
          vector<backref_tag<CI> > rgtempbackrefs;
          
          while( br = _do_match( pat, param ) )
          {
                // Handle specially the backref flags
                if( fFirst )
                     rgtempbackrefs.push_back( br );
                else if( fAll )
                     rgtempbackrefs.insert( rgtempbackrefs.end(),
                                                    param.prgbackrefs->begin(),
                                                    param.prgbackrefs->end() );
                else
                     rgtempbackrefs.swap( *param.prgbackrefs );

                if( br.first == ( param.istart = br.second ) )
                {
                     if( eos( param, param.istart ) )
                          break;
                     ++param.istart;
                }
          }

          // restore the backref vectors
          if( !br || fFirst || fAll )
                param.prgbackrefs->swap( rgtempbackrefs );
          else if( ! (*param.prgbackrefs)[0] )
                param.prgbackrefs->clear();

          return param.prgbackrefs->empty() ? backref_tag<CI>() : (*param.prgbackrefs)[0];
     }
     else 
          return _do_match( pat, param );
}

template< typename CH, typename TR, typename AL >
basic_regexpr<CH,TR,AL>::backref_type basic_regexpr<CH,TR,AL>::match( 
     const basic_rpattern_base<const_iterator> & pat,
     size_type pos, size_type len ) const throw()
{
     if( pat.flags() & CSTRINGS )
     {
          assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::match method" );
          return backref_type();
     }

     m_pbackref_str = this;
     m_backref_str.erase(); // free up unused memory

     const_iterator istart = begin();
     advance( istart, pos );

     const_iterator istop;
     if( len == npos || pos + len >= size() )
          istop = end();
     else
          advance( istop = begin(), pos + len );

     match_param<const_iterator> param( istart, istop, & m_rgbackrefs );
     return _match_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

backref_tag<const char *> _static_match_helper( 
     const char * szstr, 
     const basic_rpattern_base<const char *> & pat,
     vector< backref_tag< const char * > > * prgbackrefs ) throw()
{
     vector< backref_tag< const char * > > rgdummyvector;
     if( NULL == prgbackrefs )
          prgbackrefs = &rgdummyvector;

     match_param<const char *> param( szstr, NULL, prgbackrefs );
     return _match_helper<eocs_t<const char *> >( pat, param, eocs_t<const char *>() );
}

backref_tag<const wchar_t *> _static_match_helper( 
     const wchar_t * szstr, 
     const basic_rpattern_base<const wchar_t *> & pat,
     vector< backref_tag< const wchar_t * > > * prgbackrefs ) throw()
{
     vector< backref_tag< const wchar_t * > > rgdummyvector;
     if( NULL == prgbackrefs )
          prgbackrefs = &rgdummyvector;

     match_param<const wchar_t *> param( szstr, NULL, prgbackrefs );
     return _match_helper<eocs_t<const wchar_t *> >( pat, param, eocs_t<const wchar_t *>() );
}

//
// Helper function called from both basic_regexpr::count methods
//
template< typename EOS >
size_t _count_helper( 
     const basic_rpattern_base<typename EOS::const_iterator> & pat,
     match_param<typename EOS::const_iterator> & param,
     EOS eos )
{
     typedef typename EOS::const_iterator CI;

     size_t cmatches = 0;
     vector<backref_tag<CI> > rgbackrefs; // dummy backref vector
     backref_tag<CI>             br;
     param.prgbackrefs = &rgbackrefs;

     while( br = _do_match( pat, param ) )
     {
          ++cmatches;

          if( br.first == ( param.istart = br.second ) )
          {
                if( eos( param, param.istart ) )
                     break;
                ++param.istart;
          }
     }
     return cmatches;
}

template< typename CH, typename TR, typename AL >
size_t basic_regexpr<CH,TR,AL>::count( 
     const basic_rpattern_base<basic_regexpr<CH,TR,AL>::const_iterator> & pat,
     size_type pos, 
     size_type len ) const throw()
{
     if( pat.flags() & CSTRINGS )
     {
          assert( ! "A pattern optimized for CSTRINGS can only be used with the static regexpr::count method" );
          return backref_type();
     }

     m_pbackref_str = this;

     const_iterator istart = begin();
     advance( istart, pos );

     const_iterator istop;
     if( len == npos || pos + len >= size() )
          istop = end();
     else
          advance( istop = begin(), pos + len );

     match_param<const_iterator> param( istart, istop, NULL );
     return _count_helper<eos_t<const_iterator> >( pat, param, eos_t<const_iterator>() );
}

size_t _static_count_helper( 
     const char * szstr, 
     const basic_rpattern_base<const char *> & pat ) throw()
{
     match_param<const char *> param( szstr, NULL, NULL );
     return _count_helper<eocs_t<const char *> >( pat, param, eocs_t<const char *>() );
}

size_t _static_count_helper( 
     const wchar_t * szstr, 
     const basic_rpattern_base<const wchar_t *> & pat ) throw()
{
     match_param<const wchar_t *> param( szstr, NULL, NULL );
     return _count_helper<eocs_t<const wchar_t *> >( pat, param, eocs_t<const wchar_t *>() );
}

// Base class for sub-expressions which are zero-width 
// (i.e., assertions eat no characters during matching)
// Assertions cannot be quantified.
template< typename CI >
class assertion : public sub_expr<CI>
{
public:
     virtual bool is_assertion() const throw() { return true; }
protected:
     virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename OP >
class assert_op : public assertion<typename OP::const_iterator>
{
public:
     typedef OP op_type;
     typedef typename OP::const_iterator CI;
     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( assert_op::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          return m_op( param, icur );
     }
     op_type m_op;
};

template< typename CI >
assertion<CI> * create_bos( unsigned /*flags*/ )
{
     return new assert_op<bos_t<CI> >();
}

template< typename CI >
assertion<CI> * create_eos( unsigned flags )
{
     switch( CSTRINGS & flags )
     {
     case 0:
          return new assert_op<peos_t<CI> >();
     case CSTRINGS:
          return new assert_op<peocs_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
assertion<CI> * create_eoz( unsigned flags )
{
     switch( CSTRINGS & flags )
     {
     case 0:
          return new assert_op<eos_t<CI> >();
     case CSTRINGS:
          return new assert_op<eocs_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
assertion<CI> * create_bol( unsigned flags )
{
     switch( MULTILINE & flags )
     {
     case 0:
          return new assert_op<bos_t<CI> >();
     case MULTILINE:
          return new assert_op<bol_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
assertion<CI> * create_eol( unsigned flags )
{
     switch( ( MULTILINE | CSTRINGS ) & flags )
     {
     case 0:
          return new assert_op<peos_t<CI> >();
     case MULTILINE:
          return new assert_op<eol_t<CI> >();
     case CSTRINGS:
          return new assert_op<peocs_t<CI> >();
     case MULTILINE | CSTRINGS:
          return new assert_op<eocl_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
class match_atom : public sub_expr<CI>
{
public:
	typedef basic_string<sub_expr<CI>::char_type> string_type;
	typedef string_type::iterator iterator;
	typedef string_type::const_iterator const_iterator;

     match_atom( iterator istart, const_iterator istop ) 
          : m_istart( istart ), m_istop( istop ) {}

     const iterator m_istart;
     const const_iterator m_istop;
protected:
     virtual width_type _width_this() throw() 
     { 
          size_t width = distance<const_iterator>( m_istart, m_istop ); 
          return width_type( width, width );
     }
};

template< typename EOS >
class match_atom_t : public match_atom<typename EOS::const_iterator>
{
public:
     typedef EOS eos_type;
     typedef typename EOS::const_iterator CI;

     match_atom_t( iterator istart, const_iterator istop ) 
          : match_atom<CI>( istart, istop ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( match_atom_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI icur_tmp = icur;
          const_iterator ithis = m_istart;
          for( ; ithis != m_istop; ++icur_tmp, ++ithis )
          {
                if( m_eos( param, icur_tmp ) || *ithis != *icur_tmp )
                     return false;
          }
          icur = icur_tmp;
          return true;
     }
     eos_type  m_eos;
};

template< typename EOS >
class match_atom_nocase_t : public match_atom<typename EOS::const_iterator>
{
public:
     typedef EOS eos_type;
     typedef typename EOS::const_iterator CI;

     match_atom_nocase_t( iterator istart, const_iterator istop ) 
          : match_atom<CI>( istart, istop ), 
		  m_strlower( static_cast<const_iterator>(istart), istop ) 
     {
          // Store the uppercase version of the atom in [m_istart,m_istop).
          to_upper( m_istart, m_istop );
          // Store the lowercase version of the atom in m_strlower.
          to_lower( m_strlower.begin(), m_strlower.end() );
     }

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( match_atom_nocase_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI icur_tmp = icur;
          const_iterator ithisu    = m_istart;              // uppercase
          const_iterator ithisl    = m_strlower.begin(); // lowercase
          for( ; ithisu != m_istop; ++icur_tmp, ++ithisu, ++ithisl )
          {
                if( m_eos( param, icur_tmp ) || ( *ithisu != *icur_tmp && *ithisl != *icur_tmp ) )
                     return false;
          }
          icur = icur_tmp;
          return true;
     }
     eos_type     m_eos;
     string_type m_strlower;
};

template< typename CI >
match_atom<CI> * create_atom(
     basic_string<iterator_traits<CI>::value_type>::iterator istart,
     basic_string<iterator_traits<CI>::value_type>::const_iterator istop, 
     unsigned flags )
{
     switch( ( NOCASE | CSTRINGS ) & flags )
     {
     case 0:
          return new match_atom_t<eos_t<CI> >( istart, istop );
     case NOCASE:
          return new match_atom_nocase_t<eos_t<CI> >( istart, istop );
     case CSTRINGS:
          return new match_atom_t<eocs_t<CI> >( istart, istop );
     case NOCASE | CSTRINGS:
          return new match_atom_nocase_t<eocs_t<CI> >( istart, istop );
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
match_atom<CI> * create_atom( 
     basic_string<iterator_traits<CI>::value_type>::iterator istart, 
     unsigned flags )
{
     basic_string<iterator_traits<CI>::value_type>::const_iterator istop = istart;
     return create_atom<CI>( istart, ++istop, flags );
}

template< typename CI >
class match_any : public sub_expr<CI>
{
protected:
     virtual width_type _width_this() throw() { return width_type(1,1); }
};

template< typename EOS >
class match_any_t : public match_any<typename EOS::const_iterator>
{
public:
     typedef EOS eos_type;
     typedef typename EOS::const_iterator CI;

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( match_any_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          if( m_eos( param, icur ) )
                return false;
          ++icur;
          return true;
     }
     eos_type m_eos;
};

template< typename CI >
match_any<CI> * create_any( unsigned flags ) 
{
     switch( ( SINGLELINE | CSTRINGS ) & flags )
     {
     case 0:
          return new match_any_t<eol_t<CI> >();
     case SINGLELINE:
          return new match_any_t<eos_t<CI> >();
     case CSTRINGS:
          return new match_any_t<eocl_t<CI> >();
     case SINGLELINE | CSTRINGS:
          return new match_any_t<eocs_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

typedef pair<wchar_t,wchar_t> range_type;
const vector<range_type> g_rgranges; // empty
const vector<wctype_t>    g_rgwctype; // empty

template< typename CI >
class match_charset : public sub_expr<CI>
{
public:
     match_charset( bool fcomplement,
                         const ascii_bitvector & bvect )
          : m_fcomplement( fcomplement ),
             m_rgascii( bvect ),
             m_rgranges( g_rgranges ),
             m_ncharflags(0),
             m_rgcharflagsoff( g_rgwctype )
     {
     }

     // Note that only the references are copied here -- they are not ref counted.
     // Beware of variable lifetime issues.
     match_charset( const match_charset<CI> & that )
          : m_fcomplement( that.m_fcomplement ),
             m_rgascii( that.m_rgascii ),
             m_rgranges( that.m_rgranges ),
             m_ncharflags( that.m_ncharflags ),
             m_rgcharflagsoff( that.m_rgcharflagsoff )
     {
     }

     // this method should never be called. match_charset is only a base class
     // for match_charset_t
     virtual bool is_in_charset( char_type ch ) const throw()
     {
          assert(false);
          return true;
     }

     const bool                             m_fcomplement;
     const ascii_bitvector            & m_rgascii;  // bitmap for chars in range 0-255
     const vector<range_type>        & m_rgranges; // vector of included character ranges 256-65535
     wctype_t                                m_ncharflags; // Parameter to iswctype()
     const vector<wctype_t>          & m_rgcharflagsoff;
     vector<const match_charset *>    m_rgnestedcharsets;

     // The case-sensitivity of a character set is "compiled" into the ascii_bitvector
     // but not into the range vector because it is too computationally expensive. Instead,
     // when doing a unicode case-insensitive match on the ranges vector, two lookups
     // must be performed -- one lowercase and one uppercase. By contrast, only one lookup
     // is needed for the ascii_bitvector.

protected:

     match_charset( bool fcomplement, 
                         const ascii_bitvector & bvect,
                         const vector<range_type> & rgranges,
                         const vector<wctype_t> & rgcharflagsoff )
          : m_fcomplement( fcomplement ),
             m_rgascii( bvect ),
             m_rgranges( rgranges ),
             m_ncharflags(0),
             m_rgcharflagsoff( rgcharflagsoff )
     {
     }

     // this method should never be called. match_charset is only a base class
     // for match_charset_t
     virtual bool _match_this( match_param<CI> &, CI & ) const throw()
     {
          assert(false);
          return true;
     }

     template< typename SY >
     match_charset<CI> * get_altern_charset( char_type ch, unsigned flags, SY /*sy*/ ) const throw()
     {
          return basic_rpattern<CI,SY>::s_charset_map.get( ch, flags );
     }

     virtual width_type _width_this() throw() 
     { 
          return width_type(1,1);
     }
};

// Used as a template parameter to find a unicode character in an array of ranges.
class match_range : public unary_function<wchar_t,bool>
{
protected:
     const vector<range_type> & m_rgranges;

     // determines if one range is less then another.
     // used in binary search of range vector
     inline static bool _range_less( const range_type & rg1,
                                                const range_type & rg2 ) throw()
     {
          return rg1.second < rg2.first;
     }

     match_range( const vector<range_type> & rgranges )
          : m_rgranges( rgranges ) {}
};

class match_range_with_case : public match_range
{
public:
     match_range_with_case( const vector<range_type> & rgranges )
          : match_range( rgranges ) {}
     inline bool operator()( wchar_t ch ) const throw()
     {
          return binary_search( m_rgranges.begin(), m_rgranges.end(), 
                                        range_type(ch,ch), _range_less );
     }
};

class match_range_no_case : public match_range
{
public:
     match_range_no_case( const vector<range_type> & rgranges )
          : match_range( rgranges ) {}
     inline bool operator()( wchar_t ch ) const throw()
     {
          const wchar_t chup = towupper( ch );
          if( binary_search( m_rgranges.begin(), m_rgranges.end(), 
                                    range_type(chup,chup), _range_less ) )
                return true;

          const wchar_t chlo = towlower( ch );
          if( chup != chlo &&
                binary_search( m_rgranges.begin(), m_rgranges.end(), 
                                    range_type(chlo,chlo), _range_less ) )
                return true;

          return false;     
     }
};

template< typename EOS, typename RGM >
class match_charset_t : public match_charset<typename EOS::const_iterator>
{
public:
     typedef EOS eos_type;
     typedef RGM range_match_type;
     typedef typename EOS::const_iterator CI;

     match_charset_t( const match_charset<CI> & that )
          : match_charset<CI>( that ), m_rgm( m_rgranges ) 
     {
     }

     inline bool is_in_charset( char_type ch ) const throw()
     {
          return m_fcomplement != _is_in_charset( ch );
     }

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( match_charset_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     match_charset_t( bool fcomplement,
                            const ascii_bitvector & bvect,
                            const vector<range_type> & rgranges,
                            const vector<wctype_t> & rgcharflagsoff )
          : match_charset<CI>( fcomplement, bvect, rgranges, rgcharflagsoff ), 
             m_rgm( m_rgranges ) 
     {
     }

     // Note overloading based on parameter
     inline bool _is_in_charset( char ch ) const throw()
     {
          return     ( m_rgascii[ (unsigned char)(ch) ] )

                    || ( m_ncharflags && _isctype( ch, m_ncharflags ) )

                    || ( ! m_rgcharflagsoff.empty() && m_rgcharflagsoff.end() != 
                          find_if( m_rgcharflagsoff.begin(), m_rgcharflagsoff.end(), 
                                      not1( bind1st( ptr_fun(_isctype), ch ) ) ) )

                    || ( ! m_rgnestedcharsets.empty() && m_rgnestedcharsets.end() !=
                          find_if( m_rgnestedcharsets.begin(), m_rgnestedcharsets.end(),
                                      bind2nd( mem_fun1( &match_charset<CI>::is_in_charset ), ch ) ) );
     }

     // Note overloading based on parameter
     inline bool _is_in_charset( wchar_t ch ) const throw()
     {
          // use range_match_type to see if this character is within one of the
          // ranges stored in m_rgranges.
          return     ( ( UCHAR_MAX >= ch ) ? 
                          ( m_rgascii[ (unsigned char)(ch) ] ) :
                          ( ! m_rgranges.empty() && m_rgm( ch ) ) )

                    || ( m_ncharflags && iswctype( ch, m_ncharflags ) )

                    || ( ! m_rgcharflagsoff.empty() && m_rgcharflagsoff.end() != 
                          find_if( m_rgcharflagsoff.begin(), m_rgcharflagsoff.end(), 
                                      not1( bind1st( ptr_fun(iswctype), ch ) ) ) )

                    || ( ! m_rgnestedcharsets.empty() && m_rgnestedcharsets.end() !=
                          find_if( m_rgnestedcharsets.begin(), m_rgnestedcharsets.end(),
                                      bind2nd( mem_fun1( &match_charset<CI>::is_in_charset ), ch ) ) );
     }

     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          if( m_eos( param, icur ) || ! match_charset_t::is_in_charset( *icur ) )
                return false;
          ++icur;
          return true;
     }

     // range_match_type encapsulates the case-sensitivity
     // issues with doing a unicode lookup on the ranges vector.
     range_match_type m_rgm;
     eos_type            m_eos;
};

template< typename EOS, typename RGM >
class match_custom_charset_t : public match_charset_t<EOS,RGM>
{
public:
     template< typename SY >
     match_custom_charset_t( bool fcomplement,
                                     basic_string<char_type>::iterator & icur,
                                     basic_string<char_type>::const_iterator istop,
                                     unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
          : match_charset_t<EOS,RGM>( fcomplement, m_rgasciicustom, m_rgrangescustom, 
                                                m_rgcharflagsoffcustom )
     {
          _parse_charset( icur, istop, flags, SY() );
          _optimize();
     }

     // for including one character set in another
     match_custom_charset_t<EOS,RGM> & operator|=( const match_charset<CI> & that ) throw(bad_regexpr)
     {
          if( that.m_fcomplement )
          {
                // If no posix-style character sets are used, then we can merge this
                // nested character set directly into the enclosing character set.
                if( 0 == that.m_ncharflags &&
                     m_rgcharflagsoffcustom.empty() &&
                     m_rgnestedcharsets.empty() )
                {
                     m_rgasciicustom |= ~ that.m_rgascii;
                
                     // append the inverse of that.m_rgranges to this->m_rgrangescustom
                     wchar_t chlow = UCHAR_MAX;
                     typedef vector<range_type>::const_iterator VCI;
                     for( VCI prg = that.m_rgranges.begin(); prg != that.m_rgranges.end(); ++prg )
                     {
                          if( UCHAR_MAX + 1 != prg->first )
                                m_rgrangescustom.push_back( range_type( wchar_t(chlow+1), wchar_t(prg->first-1) ) );
                          chlow = prg->second;
                     }
                     if( WCHAR_MAX != chlow )
                          m_rgrangescustom.push_back( range_type( wchar_t(chlow+1), WCHAR_MAX ) );
                }
                else
                {
                     // There is no simple way to merge this nested character
                     // set into the enclosing character set, so we must save
                     // a pointer to the nested character set in a list.
                     // Note: the nested character set is user-defined. If the
                     // user purges the intrinsic character sets, this will point
                     // to garbage. Should I make a copy here instead?
                     m_rgnestedcharsets.push_back( &that );
                }
          }
          else
          {
                m_rgasciicustom |= that.m_rgascii;
                m_rgrangescustom.insert( m_rgrangescustom.end(),
                                                 that.m_rgranges.begin(), 
                                                 that.m_rgranges.end() );

                m_ncharflags |= that.m_ncharflags;
                m_rgcharflagsoffcustom.insert( m_rgcharflagsoffcustom.end(), 
                                                         that.m_rgcharflagsoff.begin(),
                                                         that.m_rgcharflagsoff.end() );

                m_rgnestedcharsets.insert( m_rgnestedcharsets.end(),
                                                    that.m_rgnestedcharsets.begin(),
                                                    that.m_rgnestedcharsets.end() );
          }
          return *this;
     }

protected:

     // If we reached the end of the string before finding the end of the
     // character set, then this is an ill-formed regex
     void _check_iter( basic_string<char_type>::const_iterator icur,
                             basic_string<char_type>::const_iterator istop ) throw(bad_regexpr)
     {
          if( icur == istop )
                throw bad_regexpr("expecting end of character set");
     }

     template< typename SY >
     void _parse_charset( basic_string<char_type>::iterator & icur,
                                 basic_string<char_type>::const_iterator istop,
                                 unsigned flags, SY /*sy*/ ) throw(bad_regexpr,bad_alloc)
     {
          TOKEN tok;
          char_type ch_prev = 0;
          match_charset<CI> * pcharset;
          basic_string<char_type>::iterator iprev = icur;
          const bool fnocase = ( NOCASE == ( NOCASE & flags ) );

          _check_iter( icur, istop );

          // remember the current position and grab the next token
          tok = SY::charset_token( icur, istop );
          do
          {
                _check_iter( icur, istop );

                if( CHARSET_RANGE == tok && ch_prev )
                {
                     // remember the current position
                     basic_string<char_type>::iterator iprev2 = icur;
                     char_type old_ch = ch_prev;
                     ch_prev = 0;

                     // old_ch is lower bound of a range
                     switch( SY::charset_token( icur, istop ) )
                     {
                     case CHARSET_RANGE:
                     case CHARSET_NEGATE:
                          icur = iprev2; // un-get these tokens and fall through
                     case NO_TOKEN:
                     case CHARSET_ESCAPE: // BUGBUG user-defined charset?
                          _set_bit_range( old_ch, *icur++, fnocase );
                          continue;
                     case CHARSET_BACKSPACE:
                          _set_bit_range( old_ch, char_type(8), fnocase ); // backspace
                          continue;
                     case CHARSET_END: // fall through
                     default:             // not a range.
                          icur = iprev; // backup to range token
                          _set_bit( old_ch, fnocase );
                          _set_bit( *icur++, fnocase );
                          continue;
                     }
                }

                if( ch_prev )
                     _set_bit( ch_prev, fnocase );
                ch_prev = 0;

                switch( tok )
                {
                // None of the intrinsic charsets are case-sensitive,
                // so no special handling must be done when the NOCASE 
                // flag is set.
                case CHARSET_RANGE:
                case CHARSET_NEGATE:
                case CHARSET_END:
                     icur = iprev; // un-get these tokens
                     ch_prev = *icur++;
                     continue;
                case CHARSET_BACKSPACE:
                     ch_prev = char_type(8); // backspace
                     continue;
                case ESC_DIGIT:
                     *this |= match_charset<CI>( false, get_digit_vector() );
                     continue;
                case ESC_NOT_DIGIT:
                     *this |= match_charset<CI>( true,  get_digit_vector() );
                     continue;
                case ESC_SPACE:
                     *this |= match_charset<CI>( false, get_space_vector() );
                     continue;
                case ESC_NOT_SPACE:
                     *this |= match_charset<CI>( true,  get_space_vector() );
                     continue;
                case ESC_WORD:
                     *this |= match_charset<CI>( false, get_word_vector() );
                     continue;
                case ESC_NOT_WORD:
                     *this |= match_charset<CI>( true,  get_word_vector() );
                     continue;
                case CHARSET_ALNUM:
                     m_ncharflags |= (_ALPHA|_DIGIT);
                     continue;
                case CHARSET_NOT_ALNUM:
                     m_rgcharflagsoffcustom.push_back(_ALPHA|_DIGIT);
                     continue;
                case CHARSET_ALPHA:
                     m_ncharflags |= (_ALPHA);
                     continue;
                case CHARSET_NOT_ALPHA:
                     m_rgcharflagsoffcustom.push_back(_ALPHA);
                     continue;
                case CHARSET_BLANK:
                     m_ncharflags |= (_BLANK);
                     continue;
                case CHARSET_NOT_BLANK:
                     m_rgcharflagsoffcustom.push_back(_BLANK);
                     continue;
                case CHARSET_CNTRL:
                     m_ncharflags |= (_CONTROL);
                     continue;
                case CHARSET_NOT_CNTRL:
                     m_rgcharflagsoffcustom.push_back(_CONTROL);
                     continue;
                case CHARSET_DIGIT:
                     m_ncharflags |= (_DIGIT);
                     continue;
                case CHARSET_NOT_DIGIT:
                     m_rgcharflagsoffcustom.push_back(_DIGIT);
                     continue;
                case CHARSET_GRAPH:
                     m_ncharflags |= (_PUNCT|_ALPHA|_DIGIT);
                     continue;
                case CHARSET_NOT_GRAPH:
                     m_rgcharflagsoffcustom.push_back(_PUNCT|_ALPHA|_DIGIT);
                     continue;
                case CHARSET_LOWER:
                     if( NOCASE == ( NOCASE & flags ) )
                          m_ncharflags |= (_LOWER|_UPPER);
                     else
                          m_ncharflags |= (_LOWER);
                     continue;
                case CHARSET_NOT_LOWER:
                     if( NOCASE == ( NOCASE & flags ) )
                          m_rgcharflagsoffcustom.push_back(_LOWER|_UPPER);
                     else
                          m_rgcharflagsoffcustom.push_back(_LOWER);
                     continue;
                case CHARSET_PRINT:
                     m_ncharflags |= (_BLANK|_PUNCT|_ALPHA|_DIGIT);
                     continue;
                case CHARSET_NOT_PRINT:
                     m_rgcharflagsoffcustom.push_back(_BLANK|_PUNCT|_ALPHA|_DIGIT);
                     continue;
                case CHARSET_PUNCT:
                     m_ncharflags |= (_PUNCT);
                     continue;
                case CHARSET_NOT_PUNCT:
                     m_rgcharflagsoffcustom.push_back(_PUNCT);
                     continue;
                case CHARSET_SPACE:
                     m_ncharflags |= (_SPACE);
                     continue;
                case CHARSET_NOT_SPACE:
                     m_rgcharflagsoffcustom.push_back(_SPACE);
                     continue;
                case CHARSET_UPPER:
                     if( NOCASE == ( NOCASE & flags ) )
                          m_ncharflags |= (_UPPER|_LOWER);
                     else
                          m_ncharflags |= (_UPPER);
                     continue;
                case CHARSET_NOT_UPPER:
                     if( NOCASE == ( NOCASE & flags ) )
                          m_rgcharflagsoffcustom.push_back(_UPPER|_LOWER);
                     else
                          m_rgcharflagsoffcustom.push_back(_UPPER);
                     continue;
                case CHARSET_XDIGIT:
                     m_ncharflags |= (_HEX);
                     continue;
                case CHARSET_NOT_XDIGIT:
                     m_rgcharflagsoffcustom.push_back(_HEX);
                     continue;
                case CHARSET_ESCAPE:
                     // Maybe this is a user-defined intrinsic charset
                     pcharset = get_altern_charset( *icur, flags, SY() );
                     if( NULL != pcharset )
                     {
                          *this |= *pcharset;
                          ++icur;
                          continue;
                     }
                     // else fall through
                default:
                     ch_prev = *icur++;
                     continue;
                }
          }
          while( _check_iter( iprev = icur, istop ), CHARSET_END != ( tok = SY::charset_token( icur, istop ) ) );

          if( ch_prev )
                _set_bit( ch_prev, fnocase );
     }

     void _optimize()
     {
          // this sorts on range_type.first (uses operator<() for pair templates)
          sort( m_rgrangescustom.begin(), m_rgrangescustom.end() ); 
          
          // This merges ranges that overlap
          for( size_t index = 1; index < m_rgrangescustom.size(); )
          {
                if( m_rgrangescustom[index].first <= m_rgrangescustom[index-1].second + 1 )
                {
                     m_rgrangescustom[index-1].second = max( 
                          m_rgrangescustom[index-1].second, m_rgrangescustom[index].second );
                     m_rgrangescustom.erase( m_rgrangescustom.begin() + index );
                }
                else
                     ++index;
          }
     }

     // Note overloading based on second parameter
     void _set_bit( char ch, const bool fnocase ) throw()
     { 
          if( fnocase )
          {
                m_rgasciicustom.set( (unsigned char)(tolower(ch)) );
                m_rgasciicustom.set( (unsigned char)(toupper(ch)) );
          }
          else
          {
                m_rgasciicustom.set( (unsigned char)(ch) ); 
          }
     }

     // Note overloading based on second parameter
     void _set_bit( wchar_t ch, const bool fnocase ) throw(bad_alloc)
     { 
          if( UCHAR_MAX >= ch )
                _set_bit( char(ch), fnocase );
          else
                m_rgrangescustom.push_back( range_type( ch, ch ) ); 
     }

     // Note overloading based on second parameter
     void _set_bit_range( char ch1, char ch2, const bool fnocase ) throw(bad_regexpr)
     {
          if( (unsigned char)(ch1) > (unsigned char)(ch2) )
                throw bad_regexpr("invalid range specified in character set");

          if( fnocase )
          {
                // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
                for( unsigned int i = (unsigned char)(ch1); i <= (unsigned char)(ch2); ++i )
                {
                     m_rgasciicustom.set( (unsigned char)( toupper(i) ) );
                     m_rgasciicustom.set( (unsigned char)( tolower(i) ) );
                }
          }
          else
          {
                // i is unsigned int to prevent overflow if ch2 is UCHAR_MAX
                for( unsigned int i = (unsigned char)(ch1); i <= (unsigned char)(ch2); ++i )
                     m_rgasciicustom.set( (unsigned char)(i) );
          }
     }

     // Note overloading based on second parameter
     void _set_bit_range( wchar_t ch1, wchar_t ch2, const bool fnocase ) throw(bad_regexpr,bad_alloc)
     {
          if( ch1 > ch2 )
                throw bad_regexpr("invalid range specified in character set");

          if( UCHAR_MAX >= ch1 )
                _set_bit_range( char(ch1), char( min(wchar_t(UCHAR_MAX),ch2) ), fnocase );

          if( UCHAR_MAX < ch2 )
                m_rgrangescustom.push_back( range_type( max(wchar_t(UCHAR_MAX+1),ch1), ch2 ) );
     }

     ascii_bitvector     m_rgasciicustom;
     vector<range_type> m_rgrangescustom;
     vector<wctype_t>    m_rgcharflagsoffcustom;
};


template< typename CI >
match_charset<CI> * create_charset( 
     const match_charset<CI> & that,
     unsigned flags )
{
     switch( ( NOCASE | CSTRINGS ) & flags )
     {
     case 0:
          return new match_charset_t<eos_t<CI>,match_range_with_case>( that );
     case NOCASE:
          return new match_charset_t<eos_t<CI>,match_range_no_case>( that );
     case CSTRINGS:
          return new match_charset_t<eocs_t<CI>,match_range_with_case>( that );
     case NOCASE | CSTRINGS:
          return new match_charset_t<eocs_t<CI>,match_range_no_case>( that );
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename EOS >
class word_assertion_t : public assertion<typename EOS::const_iterator>
{
public:
     typedef EOS eos_type;
     typedef typename EOS::const_iterator CI;
     word_assertion_t() 
          : m_isword( match_charset<CI>( false, get_word_vector() ) ) {}

protected:
     bos_t<CI>  m_bos;
     eos_type    m_eos;
     match_charset_t<eos_type,match_range_with_case> m_isword;
};

template< typename EOS >
class word_boundary_t : public word_assertion_t<EOS>
{
public:
     word_boundary_t( const bool fisboundary ) 
          : m_fisboundary( fisboundary ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( word_boundary_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI iprev = icur;
          --iprev;

          const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
          const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

          return ( m_fisboundary == ( fprevword != fthisword ) );
     }
     const bool m_fisboundary;
};

template< typename EOS >
class word_start_t : public word_assertion_t<EOS>
{
public:
     word_start_t() {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( word_start_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI iprev = icur;
          --iprev;

          const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
          const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

          return ! fprevword && fthisword;
     }
};

template< typename EOS >
class word_stop_t : public word_assertion_t<EOS>
{
public:
     word_stop_t() {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( word_stop_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI iprev = icur;
          --iprev;

          const bool fprevword = ! m_bos( param, icur ) && m_isword.is_in_charset( *iprev );
          const bool fthisword = ! m_eos( param, icur ) && m_isword.is_in_charset( *icur  );

          return fprevword && ! fthisword;
     }
};

template< typename CI >
assertion<CI> * create_word_boundary( const bool fisboundary, unsigned flags )
{
     switch( CSTRINGS & flags )
     {
     case 0:
          return new word_boundary_t<eos_t<CI> >( fisboundary );
     case CSTRINGS:
          return new word_boundary_t<eocs_t<CI> >( fisboundary );
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
assertion<CI> * create_word_start( unsigned flags )
{
     switch( CSTRINGS & flags )
     {
     case 0:
          return new word_start_t<eos_t<CI> >();
     case CSTRINGS:
          return new word_start_t<eocs_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI >
assertion<CI> * create_word_stop( unsigned flags )
{
     switch( CSTRINGS & flags )
     {
     case 0:
          return new word_stop_t<eos_t<CI> >();
     case CSTRINGS:
          return new word_stop_t<eocs_t<CI> >();
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

template< typename CI > class group_quantifier;

template< typename CI >
class match_group_base : public sub_expr<CI>
{
public:
     friend class group_quantifier<CI>;

     match_group_base( size_t cgroup )
          : m_rgalternates(), m_pptail(NULL),
             m_cgroup( cgroup ), m_nwidth(uninit_width) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          CI old_istart = CI();
          
          if( size_t(-1) != m_cgroup ) // could be -1 if this is a lookahead_assertion
          {
                old_istart = (*param.prgbackrefs)[ m_cgroup ].first;
                (*param.prgbackrefs)[ m_cgroup ].first = icur;
          }

          typedef vector<sub_expr<CI>*>::const_iterator VCI;
          for( VCI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
          {
                if( (*ialt)->domatch( param, icur ) )
                     return true;
          }

          if( size_t(-1) != m_cgroup )
                (*param.prgbackrefs)[ m_cgroup ].first = old_istart;

          return false;
     }
     
     virtual void _delete()
     {
          typedef vector<sub_expr<CI>*>::iterator VI;
          for( VI ialt = m_rgalternates.begin(); ialt != m_rgalternates.end(); ++ialt )
                delete_sub_expr( *ialt );
          sub_expr<CI>::_delete();
     }

     size_t group_number() const 
     { 
          return m_cgroup; 
     }

     void group_number( size_t cgroup ) 
     { 
          m_cgroup = cgroup; 
     }

     void add_item( sub_expr<CI> * pitem )
     {
          *m_pptail = pitem;
          m_pptail = & pitem->next();
     }

     void add_alternate()
     {
          m_rgalternates.push_back( NULL );
          m_pptail = & m_rgalternates.back();
     }

     void end_alternate()
     {
          *m_pptail = _get_end_group();
     }

     size_t calternates() const 
     {
          return m_rgalternates.size();
     }

     width_type group_width()
     {
          (void) match_group_base<CI>::_width_this();
          return m_nwidth;
     }

protected:

     virtual sub_expr<CI> * _get_end_group() = 0;

     virtual width_type _width_this() throw()
     {
          typedef vector<sub_expr<CI>*>::const_iterator VCI;
          if( uninit_width == m_nwidth )
          {
                m_nwidth = width_type(size_t(-1),0);
                for( VCI ialt = m_rgalternates.begin(); worst_width != m_nwidth && ialt != m_rgalternates.end(); ++ialt )
                {
                     width_type temp_width = (*ialt)->get_width();
                     m_nwidth.m_min = min( m_nwidth.m_min, temp_width.m_min );
                     m_nwidth.m_max = max( m_nwidth.m_max, temp_width.m_max );
                }
          }
          return m_nwidth;
     }

     vector<sub_expr<CI>*> m_rgalternates;
     sub_expr<CI>         ** m_pptail; // only used when adding elements
     size_t                     m_cgroup;
     width_type                m_nwidth;
};

template< typename CI >
class end_group_base : public sub_expr<CI>
{
     void * operator new( size_t );
public:
     virtual void _delete() {} // don't delete this, because it was never alloc'ed
protected:
     // since m_pnext is always NULL for end_groups, get_width() stops recursing here
     virtual width_type _width_this() throw() 
     {
          return width_type(0,0); 
     }
};

template< typename CI >
class match_group : public match_group_base<CI>
{
public:
     match_group( size_t cgroup )
          : match_group_base<CI>( cgroup ),
             m_end_group( this ) {}
protected:
     bool _call_back( match_param<CI> & param, CI icur ) const throw()
	{
          CI old_iend = CI();

          if( size_t(-1) != m_cgroup )
          {
                old_iend = (*param.prgbackrefs)[ m_cgroup ].second;
                (*param.prgbackrefs)[ m_cgroup ].second = icur;
          }

          if( match_next( param, icur ) )
                return true;

          if( size_t(-1) != m_cgroup )
                (*param.prgbackrefs)[ m_cgroup ].second = old_iend;

          return false;
	}

     class end_group;
     friend class end_group;
     class end_group : public end_group_base<CI>
     {
          match_group<CI> *const m_pgroup;
     public:
          end_group( match_group<CI> * pgroup )
                : m_pgroup( pgroup ) {}
          virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
          {
			return m_pgroup->_call_back( param, icur );
          }
     } m_end_group;

     virtual sub_expr<CI> * _get_end_group()
     {
          return & m_end_group;
     }
};

// Behaves like a lookahead assertion if m_cgroup is -1, or like
// an independent group otherwise.
template< typename CI >
class independent_group_base : public match_group_base<CI>
{
public:
     independent_group_base() 
          : match_group_base<CI>( size_t(-1) ), m_fexpected(true) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          // Copy the entire backref vector onto the stack
          backref_tag<CI> * prgbr =  (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
          copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
                  raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

          // Match until the end of this group and then return
          const bool fdomatch = match_group_base<CI>::domatch( param, icur );

          if( m_fexpected == fdomatch )
          {
                // If m_cgroup != 1, then this is not a zero-width assertion.
                if( size_t(-1) != m_cgroup )
                     icur = (*param.prgbackrefs)[ m_cgroup ].second;

                if( match_next( param, icur ) )
                     return true;
          }

          // if match_group::domatch returned true, the backrefs must be restored
          if( fdomatch )
                copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

          return false;
     }

protected:

     independent_group_base( const bool fexpected ) 
          : match_group_base<CI>( size_t(-1) ), m_fexpected(fexpected) {}

     const bool m_fexpected;
};

template< typename CI >
class independent_group : public independent_group_base<CI>
{
public:
     independent_group()
          : independent_group_base<CI>(),
             m_end_group( this ) {}

protected:
     independent_group( const bool fexpected ) 
          : independent_group_base<CI>( fexpected ),
             m_end_group( this ) {}
	
	bool _call_back( match_param<CI> & param, CI icur ) const throw()
	{
          if( size_t(-1) != m_cgroup )
                (*param.prgbackrefs)[ m_cgroup ].second = icur;
          return true;
	}

     class end_group;
     friend class end_group;
     class end_group : public end_group_base<CI>
     {
          independent_group<CI> *const m_pgroup;
     public:
          end_group( independent_group<CI> * pgroup )
                : m_pgroup( pgroup ) {}

          virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
          {
			return m_pgroup->_call_back( param, icur );
          }
     } m_end_group;

     virtual sub_expr<CI> * _get_end_group()
     {
          return & m_end_group;
     }
};

template< typename CI >
class lookahead_assertion : public independent_group<CI>
{
public:
     lookahead_assertion( const bool fexpected )
          : independent_group<CI>( fexpected ) {}
     virtual bool is_assertion() const throw() { return true; }
protected:
     virtual width_type _width_this() throw() { return width_type(0,0); }
};

template< typename CI >
class lookbehind_assertion : public independent_group_base<CI>
{
public:
     lookbehind_assertion( const bool fexpected )
          : independent_group_base<CI>( fexpected ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          // This is the room in the string from the start to the current position
          size_t room = distance( param.ibegin, icur );

          // If we don't have enough room to match the lookbehind, the match fails.
          // If we wanted the match to fail, try to match the rest of the pattern.
          if( m_nwidth.m_min > room )
                return m_fexpected ? false : match_next( param, icur );

          // Copy the entire backref vector onto the stack
          backref_tag<CI> * prgbr = (backref_tag<CI>*)_alloca( param.prgbackrefs->size() * sizeof backref_tag<CI> );
          copy( param.prgbackrefs->begin(), param.prgbackrefs->end(), 
                  raw_storage_iterator<backref_tag<CI>*,backref_tag<CI> >(prgbr) );

          CI local_istart  = icur;
          advance( local_istart, -int( min( m_nwidth.m_max, room ) ) );

          CI local_istop = icur;
          advance( local_istop, -int( m_nwidth.m_min ) );

          // Create a local param struct that has icur as param.iend
          match_param<CI> local_param(param.ibegin,param.istart,icur,param.prgbackrefs);

          // Find the rightmost match that ends at icur.
          for( CI local_icur = local_istart; local_icur <= local_istop; ++local_icur )
          {
                // Match until the end of this group and then return
                const bool fmatched = match_group_base<CI>::domatch( local_param, local_icur );

                // If the match results were what we were expecting, try to match the
                // rest of the pattern. If that succeeds, return true.
                if( m_fexpected == fmatched && match_next( param, icur ) )
                     return true;

                // if match_group::domatch returned true, the backrefs must be restored
                if( fmatched )
                {
                     copy( prgbr, prgbr + param.prgbackrefs->size(), param.prgbackrefs->begin() );

                     // Match succeeded. If this is a negative lookbehind, we didn't want it
                     // to succeed, so return false.
                     if( ! m_fexpected )
                          return false;
                }
          }

          // No variation of the lookbehind was satisfied in a way that permited
          // the rest of the pattern to match successfully, so return false.
          return false;
     }
     
     virtual bool is_assertion() const throw() 
     { 
          return true; 
     }

protected:

     class end_group;
     friend class end_group;
     class end_group : public end_group_base<CI>
     {
     public:
          virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
          {
                return param.istop == icur;
          }
     } m_end_group;

     virtual sub_expr<CI> * _get_end_group()
     {
          return & m_end_group;
     }

     virtual width_type _width_this() throw() 
     { 
          return width_type(0,0); 
     }
};

template< typename CI >
class match_wrapper : public sub_expr<CI>
{
public:
     match_wrapper( sub_expr<CI> * psub ) 
          : m_psub(psub) {}

     virtual void _delete()
     {
          delete_sub_expr( m_psub );
          sub_expr<CI>::_delete();
     }

protected:

     bool _wrapped_match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          return m_psub->_match_this( param, icur );
     }
     
     virtual width_type _width_this() throw()
     {
          return m_psub->_width_this();
     }

     sub_expr<CI> * m_psub;
};

template< typename CI >
class match_quantifier : public match_wrapper<CI>
{
public:     
     match_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
          : match_wrapper<CI>( psub ), m_lbound(lbound), m_ubound(ubound) {}

protected:

     virtual width_type _width_this() throw()
     {
          width_type this_width = match_wrapper<CI>::_width_this();

          return this_width * width_type( m_lbound, m_ubound );
     }

     const size_t m_lbound;
     const size_t m_ubound;
};

template< typename CI >
class max_atom_quantifier : public match_quantifier<CI>
{
public:
     max_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
          : match_quantifier<CI>( psub, lbound, ubound ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          size_t cmatches = 0;
          int     cdiff     = 0; // must be a signed quantity for advance() below

          if( cmatches < m_ubound )
          {
                CI istart = icur;
                if( _wrapped_match_this( param, icur ) )
                {
                     ++cmatches;
                     cdiff = distance( istart, icur );
                
                     if( 0 == cdiff )
                          return ( match_next( param, icur ) );

                     while( cmatches < m_ubound && 
                              _wrapped_match_this( param, icur ) )
                     {
                          ++cmatches;
                     }
                }
          }

          if( cmatches >= m_lbound )
          {
                if( ! next() )
                     return true;
     
                for(;;)
                {
                     if( next()->domatch( param, icur ) )
                          return true;
                     
                     if( cmatches-- <= m_lbound )
                          break;
                     
                     advance( icur, -cdiff );
                }
          }

          return false;
     }
};

template< typename CI >
class min_atom_quantifier : public match_quantifier<CI>
{
public:     
     min_atom_quantifier( sub_expr<CI> * psub, size_t lbound, size_t ubound ) 
          : match_quantifier<CI>( psub, lbound, ubound ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          size_t cmatches = 0;
          bool    fsuccess = true;
          CI icur_tmp = icur;

          if( _wrapped_match_this( param, icur_tmp ) )
          {
                if( icur_tmp == icur )
                     return ( match_next( param, icur ) );

                if( m_lbound )
                {
                     icur = icur_tmp;
                     ++cmatches;
                }
                
                while( ( cmatches < m_lbound ) &&
                         ( fsuccess = _wrapped_match_this( param, icur ) ) )
                {
                     ++cmatches;
                }
          }
          else
          {
                fsuccess = ! m_lbound;
          }

          if( fsuccess && next() )
          {
                do
                {
                     if( next()->domatch( param, icur ) )
                          break;
                } while( fsuccess = ( cmatches++ < m_ubound && 
                                             _wrapped_match_this( param, icur ) ) );
          }

          return fsuccess;
     }
};

template< typename CI >
class end_quantifier_base : public sub_expr<CI>
{
     void * operator new( size_t );
public:
     virtual void _delete() {} // don't delete this, since it wasn't alloc'ed
protected:
     virtual width_type _width_this() throw() { return width_type(0,0); }
};


template< typename CI >
class group_quantifier : public match_quantifier<CI>
{
public:
     
     group_quantifier( match_group_base<CI> * psub,
                       size_t lbound, size_t ubound,
                       end_quantifier_base<CI> * pend_quant ) 
          : match_quantifier<CI>( psub, lbound, ubound ),
	        m_group( *psub ) 
     {
          m_group.next() = pend_quant;
     }

protected:

     size_t group_number() const 
     { 
          return m_group.group_number(); 
     }

     size_t & cmatches( match_param<CI> & param ) const 
     { 
          return (*param.prgbackrefs)[ group_number() ].reserved; 
     }

	match_group_base<CI> & m_group;
};

template< typename CI >
class max_group_quantifier : public group_quantifier<CI>
{
public:
     max_group_quantifier( match_group_base<CI> * psub, size_t lbound, size_t ubound ) 
          : group_quantifier<CI>( psub, lbound, ubound, & m_end_quant ),
		    m_end_quant( this ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          backref_tag<CI> & br = (*param.prgbackrefs)[ group_number() ];
          backref_tag<CI> old_backref = br;
          br = backref_tag<CI>( icur, icur ); // sets cmatches (reserved) to 0

          if( _recurse( param, icur ) )
                return true;

          br = old_backref;
          return false;
     }

protected:

     bool _recurse( match_param<CI> & param, CI icur ) const throw()
     {
          if( m_ubound == cmatches( param ) )
                return match_next( param, icur );

          ++cmatches( param );
          if( m_psub->domatch( param, icur ) )
                return true;

          if( --cmatches( param ) < m_lbound )
                return false;

          return match_next( param, icur );
     }

     class end_quantifier;
     friend class end_quantifier;
     class end_quantifier : public end_quantifier_base<CI>
     {
          max_group_quantifier<CI> * m_pquant;
     public:
          end_quantifier( max_group_quantifier<CI> * pquant ) 
                : m_pquant( pquant ) {}

          virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
          {
                // handle special the case where a group matches 0 characters
                backref_tag<CI> & br = (*param.prgbackrefs)[ m_pquant->group_number() ];
                if( icur == br.first )
                {
                     size_t old_cmatches = br.reserved;
                     br.reserved = m_pquant->m_ubound;
                     if( m_pquant->_recurse( param, icur ) )
                          return true;
                     br.reserved = old_cmatches;
                     return false;
                }
                return m_pquant->_recurse( param, icur );
          }
     } m_end_quant;
};

template< typename CI >
class min_group_quantifier : public group_quantifier<CI>
{
public:
     min_group_quantifier( match_group_base<CI> * psub, size_t lbound, size_t ubound ) 
          : group_quantifier<CI>( psub, lbound, ubound, & m_end_quant ),
             m_end_quant( this ) {}

     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          backref_tag<CI> & br = (*param.prgbackrefs)[ group_number() ];
          backref_tag<CI> old_backref = br;
          br = backref_tag<CI>( icur, icur ); // sets cmatches (reserved) to 0

          if( _recurse( param, icur ) )
                return true;

          br = old_backref;
          return false;
     }

protected:

     bool _recurse( match_param<CI> & param, CI icur ) const throw()
     {
          if( m_lbound > cmatches( param ) )
          {
                ++cmatches( param );
                return m_psub->domatch( param, icur );
          }

          if( match_next( param, icur ) )
                return true;

          if( cmatches( param )++ == m_ubound )
                return false;
                
          return m_psub->domatch( param, icur );
     }

     class end_quantifier;
     friend class end_quantifier;
     class end_quantifier : public end_quantifier_base<CI>
     {
          min_group_quantifier<CI> * m_pquant;
     public:
          end_quantifier( min_group_quantifier<CI> * pquant ) 
                : m_pquant( pquant ) {}

          virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
          {
                // handle special the case where a group matches 0 characters
                backref_tag<CI> & br = (*param.prgbackrefs)[ m_pquant->group_number() ];
                if( icur == br.first )
                {
                     size_t old_cmatches = br.reserved;
                     br.reserved = m_pquant->m_ubound;
                     if( m_pquant->_recurse( param, icur ) )
                          return true;
                     br.reserved = old_cmatches;
                     return false;
                }
                return m_pquant->_recurse( param, icur );
          }
     } m_end_quant;
};

template< typename CI >
class match_backref : public sub_expr<CI>
{
public:
     match_backref( size_t cbackref, const width_type & group_width ) 
          : m_cbackref( cbackref ), m_nwidth(group_width) {}
protected:
     // Return the width specifications of the group to which this backref refers
     virtual width_type _width_this() throw() { return m_nwidth; }
     const size_t m_cbackref;
     const width_type m_nwidth;
};

template< typename CMP, typename EOS >
class match_backref_t : public match_backref<typename EOS::const_iterator>
{
public:
     typedef CMP cmp_type;
     typedef EOS eos_type;
     typedef typename EOS::const_iterator CI;
     match_backref_t( size_t cbackref, const width_type & group_width ) 
          : match_backref<CI>( cbackref, group_width ) {}
     virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
     {
          return ( match_backref_t::_match_this(param,icur) && match_next(param,icur) );
     }
protected:
     virtual bool _match_this( match_param<CI> & param, CI & icur ) const throw()
     {
          CI ithis      = (*param.prgbackrefs)[ m_cbackref ].first;
          CI istop      = (*param.prgbackrefs)[ m_cbackref ].second;
          CI icur_tmp  = icur;

          // Don't match a backref that hasn't match anything
          if( ! (*param.prgbackrefs)[ m_cbackref ] )
                return false;

          for( ; ithis != istop; ++icur_tmp, ++ithis )
          {
                if( m_eos( param, icur_tmp ) || m_cmp( *icur_tmp, *ithis ) )
                     return false;
          }
          icur = icur_tmp;
          return true;
     }
     cmp_type m_cmp;
     eos_type m_eos;
};

template< typename CI >
match_backref<CI> * create_backref( 
     size_t cbackref, 
     const width_type & group_width, 
     unsigned flags ) 
{
     typedef typename iterator_traits<CI>::value_type char_type;

     switch( ( NOCASE | CSTRINGS ) & flags )
     {
     case 0:
          return new match_backref_t<ch_neq_t<char_type>,eos_t<CI> >( cbackref, group_width );
     case NOCASE:
          return new match_backref_t<ch_neq_nocase_t<char_type>,eos_t<CI> >( cbackref, group_width );
     case CSTRINGS:
          return new match_backref_t<ch_neq_t<char_type>,eocs_t<CI> >( cbackref, group_width );
     case NOCASE | CSTRINGS:
          return new match_backref_t<ch_neq_nocase_t<char_type>,eocs_t<CI> >( cbackref, group_width );
     default:
          __assume(0); // tells the compiler that this is unreachable
     }
}

// Replace some escape sequences with the actual characters
// they represent
template< typename CI >
void basic_rpattern_base<CI>::_normalize_string( basic_string<basic_rpattern_base<CI>::char_type> & str )
{
     // Don't do pattern normalization if the user didn't ask for it.
     if( NORMALIZE != ( NORMALIZE & m_flags ) )
          return;

     process_escapes( str );
}

//
// Implementation of basic_rpattern:
//
template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern() throw()
     : basic_rpattern_base<CI>( 0 )
{
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
     const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
     unsigned flags ) throw(bad_regexpr,bad_alloc)
     : basic_rpattern_base<CI>( flags, pat )
{
     push_new_handler pnh( &my_new_handler );
     _normalize_string( m_pat );
     _common_init( flags );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::basic_rpattern( 
     const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
     const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
     unsigned flags ) throw(bad_regexpr,bad_alloc)
     : basic_rpattern_base<CI>( flags, pat, subst )
{
     push_new_handler pnh( &my_new_handler );
     _normalize_string( m_pat );
     _common_init( flags );
     _normalize_string( m_subst );     
     _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init( 
     const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
     unsigned flags ) throw(bad_regexpr,bad_alloc)
{
     push_new_handler pnh( &my_new_handler );
     _reset();
     m_flags = flags;
     m_pat    = pat;
     _normalize_string( m_pat );
     _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::init(
     const basic_string<basic_rpattern<CI,SY>::char_type> & pat, 
     const basic_string<basic_rpattern<CI,SY>::char_type> & subst, 
     unsigned flags ) throw(bad_regexpr,bad_alloc)
{
     push_new_handler pnh( &my_new_handler );
     _reset();
     m_flags = flags;
     m_pat    = pat;
     m_subst = subst;
     _normalize_string( m_pat );
     _common_init( m_flags );
     _normalize_string( m_subst );     
     _parse_subst(); // must come after _common_init
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_common_init( unsigned flags )
{
     m_cgroups = 0;
     vector<match_group_base<CI>*> rggroups;
     basic_string<char_type>::iterator ipat = m_pat.begin();
     match_group_base<CI> * pgroup = _find_next_group( ipat, flags, rggroups );

     m_pfirst = pgroup;
     m_nwidth = pgroup->group_width();

     // Number the invisible groups
     m_cgroups_visible = m_cgroups;
     while( ! m_invisible_groups.empty() )
     {
          m_invisible_groups.front()->group_number( _get_next_group_nbr() );
          m_invisible_groups.pop_front();
     }

     //
     // determine if we can get away with only calling m_pfirst->domatch only once
     //

     m_floop = true;

     // Optimization: if first character of pattern string is '^'
     // and we are not doing a multiline match, then we only 
     // need to try domatch once
     basic_string<char_type>::iterator icur = m_pat.begin();
     if( MULTILINE != ( MULTILINE & m_flags ) &&
          1 == pgroup->calternates() && 
          icur != m_pat.end() && 
          BEGIN_LINE == SY::reg_token( icur, m_pat.end() ) )
     {
          m_flags &= ~RIGHTMOST;
          m_floop = false;
     }

     // Optimization: if first 2 characters of pattern string are ".*" or ".+",
     // then we only need to try domatch once
     icur = m_pat.begin();
     if( RIGHTMOST != ( RIGHTMOST & m_flags ) &&
          SINGLELINE == ( SINGLELINE & m_flags ) &&
          1 == pgroup->calternates() &&
          icur != m_pat.end() && 
          MATCH_ANY == SY::reg_token( icur, m_pat.end() ) &&
          icur != m_pat.end() )
     {
          switch( SY::quant_token( icur, m_pat.end() ) )
          {
                case ONE_OR_MORE:
                case ZERO_OR_MORE:
                case ONE_OR_MORE_MIN:
                case ZERO_OR_MORE_MIN:
                     m_floop = false;
          }
     }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_reset() throw()
{
     basic_rpattern_base<CI>::_reset();

     m_cgroups = m_cgroups_visible = 0;
     m_floop    = true;

     m_subst.erase();
     m_pat.erase();

     m_pfirst.free_ptr();
     m_nwidth = uninit_width;
     m_subst_list.clear();
     m_invisible_groups.clear();
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_flags( unsigned flags ) throw(bad_regexpr,bad_alloc)
{
     push_new_handler pnh( &my_new_handler );
     m_pfirst.free_ptr();
     m_flags = flags;
     _common_init( m_flags );
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::set_substitution( const basic_string<basic_rpattern<CI,SY>::char_type> & subst ) throw(bad_regexpr,bad_alloc)
{
     push_new_handler pnh( &my_new_handler );
     m_subst_list.clear();
     m_subst = subst;
     _normalize_string( m_subst );
     _parse_subst();
}

template< typename CI, typename SY >
match_group_base<CI> * basic_rpattern<CI,SY>::_find_next_group( 
     basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat, 
     unsigned & flags,
     vector<match_group_base<CI>*> & rggroups )
{
     auto_sub_ptr<match_group_base<CI> > pgroup;
     basic_string<char_type>::iterator itemp = ipat;
     unsigned old_flags = flags;
     TOKEN tok;

     // Look for group extensions. (This could change the value of the flags variable.)
     if( ipat != m_pat.end() && NO_TOKEN != ( tok = SY::ext_token( ipat, m_pat.end(), flags ) ) )
     {
          if( itemp == m_pat.begin() || ipat == m_pat.end() )
                throw bad_regexpr("ill-formed regular expression");

          // Don't process empty groups
          if( END_GROUP != SY::reg_token( itemp = ipat, m_pat.end() ) )
          {
                switch( tok )
                {
                case EXT_NOBACKREF:
                     // invisible groups are numbered only after all
                     // visible groups have been numbererd
                     pgroup = new match_group<CI>( size_t(-1) );
                     m_invisible_groups.push_back( pgroup.get() );
                     break;

                case EXT_INDEPENDENT:
                     pgroup = new independent_group<CI>();
                     m_invisible_groups.push_back( pgroup.get() );
                     break;

                case EXT_POS_LOOKAHEAD:
                     pgroup = new lookahead_assertion<CI>( true );
                     break;
                
                case EXT_NEG_LOOKAHEAD:
                     pgroup = new lookahead_assertion<CI>( false );
                     break;
                
                case EXT_POS_LOOKBEHIND:
                     // For look-behind assertions, turn off the CSTRINGs optimization
                     flags &= ~CSTRINGS;
                     pgroup = new lookbehind_assertion<CI>( true );
                     break;
                
                case EXT_NEG_LOOKBEHIND:
                     // For look-behind assertions, turn off the CSTRINGs optimization
                     flags &= ~CSTRINGS;
                     pgroup = new lookbehind_assertion<CI>( false );
                     break;
                
                default:
                     throw bad_regexpr("bad extension sequence");
                }
          }
          else
          {
                // Skip over the END_GROUP token
                ipat = itemp;
          }
     }
     else
     {
          pgroup = new match_group<CI>( _get_next_group_nbr() );
     }

     if( NULL != pgroup.get() )
     {
          pgroup->add_alternate();
          while( _find_next( ipat, pgroup.get(), flags, rggroups ) );
          pgroup->end_alternate();

          // Add this group to the rggroups array
          if( size_t(-1) != pgroup->group_number() )
          {
                if( pgroup->group_number() >= rggroups.size() )
                     rggroups.resize( pgroup->group_number() + 1, NULL );
                rggroups[ pgroup->group_number() ] = pgroup.get();
          }

          // The group should calculate its own width now and 
          // save the result for later.
          pgroup->group_width();

          // If this is not a pattern modifier, restore the 
          // flags to their previous settings.  This causes 
          // pattern modifiers to have the scope of their 
          // enclosing group.
          flags = old_flags;
     }

     return pgroup.release();
}

//
// Read ahead through the pattern and treat sequential atoms
// as a single atom, making sure to handle quantification
// correctly. Warning: dense code ahead.
//
template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_find_atom( 
     basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
     match_group_base<CI> * pgroup, 
     unsigned flags )
{
     basic_string<char_type>::iterator itemp = ipat, istart = ipat;

     do
     {
          switch( SY::quant_token( itemp, m_pat.end() ) )
          {
          // if {,} can't be interpreted as quantifiers, treat them as regular chars
          case BEGIN_RANGE:
                if( istart != ipat ) // treat as a quantifier
                     goto quantify;
          case NO_TOKEN:
          case END_RANGE:
          case END_RANGE_MIN:
          case RANGE_SEPARATOR:
                break;

          default: 
                if( istart == ipat ) // must be able to quantify something.
                     throw bad_regexpr("quantifier not expected");
quantify:    if( istart != --ipat )
                     pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
                auto_sub_ptr<sub_expr<CI> > pnew( create_atom<CI>( ipat++, flags ) );
                _quantify( pnew, NULL, ipat );
                pgroup->add_item( pnew.release() );
                return;
          }
     } while( m_pat.end() != ++ipat && ! SY::reg_token( itemp = ipat, m_pat.end() ) );

     assert( ipat != istart );
     pgroup->add_item( create_atom<CI>( istart, ipat, flags ) );
}

template< typename CI, typename SY >
bool basic_rpattern<CI,SY>::_find_next( 
     basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat,
     match_group_base<CI> * pgroup, 
     unsigned & flags,
     vector<match_group_base<CI>*> & rggroups )
{
     match_group_base<CI> * pnew_group = NULL;
     auto_sub_ptr<sub_expr<CI> > pnew;
     basic_string<char_type>::iterator istart, itemp;
     bool fdone;

     if( ipat == m_pat.end() )
     {
          if( 0 != pgroup->group_number() )
                throw bad_regexpr( "mismatched parenthesis" );
          return false;
     }

     switch( SY::reg_token( ipat, m_pat.end() ) )
     {
     case NO_TOKEN: // not a token. Must be an atom
          _find_atom( ipat, pgroup, flags );
          return true;
     
     case END_GROUP:
          if( 0 == pgroup->group_number() )
                throw bad_regexpr( "mismatched parenthesis" );
          return false;

     case ALTERNATION:
          pgroup->end_alternate();
          pgroup->add_alternate();
          return true;
     
     case BEGIN_GROUP:
          // Find next group could return NULL if the group is really
          // a pattern modifier, like: (?s-i)
          pnew = pnew_group = _find_next_group( ipat, flags, rggroups );
          break;

     case BEGIN_LINE:
          pnew = create_bol<CI>( flags );
          break;

     case END_LINE:
          pnew = create_eol<CI>( flags );
          break;

     case BEGIN_CHARSET:
          pnew = create_charset_helper<CI,SY>::create_charset_aux( m_pat, ipat, flags );
          break;

     case MATCH_ANY:
          pnew = create_any<CI>( flags );
          break;

     case ESC_WORD_BOUNDARY:
          pnew = create_word_boundary<CI>( true, flags );
          break;
     
     case ESC_NOT_WORD_BOUNDARY:
          pnew = create_word_boundary<CI>( false, flags );
          break;
     
     case ESC_WORD_START:
          pnew = create_word_start<CI>( flags );
          break;
     
     case ESC_WORD_STOP:
          pnew = create_word_stop<CI>( flags );
          break;
     
     case ESC_DIGIT:
          pnew = create_charset<CI>( match_charset<CI>( false,
                                                                     get_digit_vector() ),
                                                                     flags );
          break;

     case ESC_NOT_DIGIT:
          pnew = create_charset<CI>( match_charset<CI>( true,
                                                                     get_digit_vector() ),
                                                                     flags );
          break;

     case ESC_WORD:
          pnew = create_charset<CI>( match_charset<CI>( false,
                                                                     get_word_vector() ),
                                                                     flags );
          break;

     case ESC_NOT_WORD:
          pnew = create_charset<CI>( match_charset<CI>( true,
                                                                     get_word_vector() ),
                                                                     flags );
          break;

     case ESC_SPACE:
          pnew = create_charset<CI>( match_charset<CI>( false,
                                                                     get_space_vector() ),
                                                                     flags );
          break;

     case ESC_NOT_SPACE:
          pnew = create_charset<CI>( match_charset<CI>( true,
                                                                     get_space_vector() ),
                                                                     flags );
          break;

     case ESC_BEGIN_STRING:
          pnew = create_bos<CI>( flags );
          break;

     case ESC_END_STRING:
          pnew = create_eos<CI>( flags );
          break;

     case ESC_END_STRING_z:
          pnew = create_eoz<CI>( flags );
          break;

     case ESCAPE:

          if( char_type('0') <= *ipat && char_type('9') >= *ipat )
          {
                // use _cgroups_total here since the invisible groups have not been numbered yet.
                unsigned nbackref = parse_int( ipat, m_pat.end(), _cgroups_total() - 1 );// always at least 1 group
                if( 0 == nbackref || rggroups.size() <= nbackref || NULL == rggroups[ nbackref ] )
                     throw bad_regexpr( "invalid backreference" );
                pnew = create_backref<CI>( nbackref, rggroups[nbackref]->group_width(), flags );
          }
          else
          {
                // Is this a user-defined intrinsic character set?
                match_charset<CI> * pcharset = s_charset_map.get( *ipat, flags );
                if( NULL != pcharset )
                     pnew = create_charset<CI>( *pcharset, flags );
                else
                     pnew = create_atom<CI>( ipat, flags );
                ++ipat;
          }
          break;

     // If quotemeta, loop until we find quotemeta off or end of string
     case ESC_QUOTE_META_ON:
          for( istart = itemp = ipat, fdone = false; !fdone && ipat != m_pat.end(); )
          {
                switch( SY::reg_token( ipat, m_pat.end() ) )
                {
                case ESC_QUOTE_META_OFF:
                     fdone = true;
                     break;
                case NO_TOKEN:
                     ++ipat; // fallthrough
                default:
                     itemp = ipat;
                     break;
                }
          }
          if( itemp != istart )
                pgroup->add_item( create_atom<CI>( istart, itemp, flags ) );

          // skip the quantification code below
          return true;

     // Should never get here for valid patterns
     case ESC_QUOTE_META_OFF:
          throw bad_regexpr("quotemeta turned off, but was never turned on");

     default:
          assert( ! "Unhandled token type" );
          break;
     }
     
     // If pnew is null, then the current subexpression is a no-op.
     if( pnew.get() )
     {
          // Look for quantifiers
          _quantify( pnew, pnew_group, ipat );

          // Add the item to the group
          pgroup->add_item( pnew.release() );
     }
     return true;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_quantify( 
     auto_sub_ptr<sub_expr<CI> > & pnew,
     match_group_base<CI> * pnew_group,
     basic_string<basic_rpattern<CI,SY>::char_type>::iterator & ipat )
{
     if( ipat != m_pat.end() && ! pnew->is_assertion() )
     {
          basic_string<char_type>::iterator itemp = ipat;
          bool fmin = false;
          
          // Since size_t is unsigned, -1 is really the largest size_t
          size_t lbound = (size_t)-1;
          size_t ubound = (size_t)-1;
          size_t ubound_tmp;

          switch( SY::quant_token( itemp, m_pat.end() ) )
          {
          case ZERO_OR_MORE_MIN:
                fmin = true;
          case ZERO_OR_MORE:
                lbound = 0;
                break;

          case ONE_OR_MORE_MIN:
                fmin = true;
          case ONE_OR_MORE:
                lbound = 1;
                break;

          case ZERO_OR_ONE_MIN:
                fmin = true;
          case ZERO_OR_ONE:
                lbound = 0;
                ubound = 1; 
                break;

          case BEGIN_RANGE:
                lbound = parse_int( itemp, m_pat.end() );
                if( itemp == m_pat.end() )
                     throw bad_regexpr( "expecting end of range" );

                switch( SY::quant_token( itemp, m_pat.end() ) )
                {
                case END_RANGE_MIN:
                     fmin = true;
                case END_RANGE:
                     ubound = lbound;
                     break;

                case RANGE_SEPARATOR:
                     ipat = itemp;
                     ubound_tmp = parse_int( itemp, m_pat.end() );
                     if( itemp != ipat )
                          ubound = ubound_tmp;
                     if( itemp == m_pat.end() )
                          throw bad_regexpr( "expecting end of range" );
                     switch( SY::quant_token( itemp, m_pat.end() ) )
                     {
                     case END_RANGE_MIN:
                          fmin = true;
                     case END_RANGE:
                          break;
                     default:
                          throw bad_regexpr( "expecting end of range" );
                     }
                     break;

                default:
                     throw bad_regexpr( "ill-formed quantifier" );
                }

                if( ubound < lbound  )
                     throw bad_regexpr( "ill-formed quantifier" );

                break;
          }

          if( (size_t)-1 != lbound )
          {
                auto_sub_ptr<match_quantifier<CI> > pquant;

                // a group quantifier is less efficient than an atom quantifier
                if( fmin )
                {
                     if( pnew_group )
                          pquant = new min_group_quantifier<CI>( pnew_group, 
                                                                                      lbound, ubound );
                     else
                          pquant = new min_atom_quantifier<CI>( pnew.get(), 
                                                                                     lbound, ubound );
                }
                else
                {
                     if( pnew_group )
                          pquant = new max_group_quantifier<CI>( pnew_group, 
                                                                                      lbound, ubound );
                     else
                          pquant = new max_atom_quantifier<CI>( pnew.get(),
                                                                                     lbound, ubound );
                }

                pnew.release();
                pnew = pquant.release();
                ipat = itemp;
          }
     }
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart )
{
     m_fuses_backrefs = true;
     assert( subst_node::SUBST_STRING == snode.stype );
     if( snode.subst_string.rlength )
          m_subst_list.push_back( snode );

     snode.stype = subst_node::SUBST_BACKREF;
     snode.subst_backref = nbackref;
     m_subst_list.push_back( snode );

     // re-initialize the subst_node
     snode.stype = subst_node::SUBST_STRING;
     snode.subst_string.rstart = rstart;
     snode.subst_string.rlength = 0;
}

template< typename CI, typename SY >
void basic_rpattern<CI,SY>::_parse_subst()
{
     TOKEN tok;
     subst_node snode;
     basic_string<char_type>::iterator icur = m_subst.begin();
     size_t nbackref;
     basic_string<char_type>::iterator itemp;
     bool fdone;

     m_fuses_backrefs = false;

     // Initialize the subst_node
     snode.stype = subst_node::SUBST_STRING;
     snode.subst_string.rstart = 0;
     snode.subst_string.rlength = 0;

     while( icur != m_subst.end() )
     {
          switch( tok = SY::subst_token( icur, m_subst.end() ) )
          {
          case SUBST_MATCH:
                _add_subst_backref( snode, 0, distance( m_subst.begin(), icur ) );
                break;

          case SUBST_PREMATCH:
                _add_subst_backref( snode, (size_t)subst_node::PREMATCH, distance( m_subst.begin(), icur ) );
                break;

          case SUBST_POSTMATCH:
                _add_subst_backref( snode, (size_t)subst_node::POSTMATCH, distance( m_subst.begin(), icur ) );
                break;

          case SUBST_BACKREF:
                nbackref = parse_int( icur, m_subst.end(), cgroups() - 1 ); // always at least 1 group
                if( 0 == nbackref )
                     throw bad_regexpr( "invalid backreference in substitution" );

                _add_subst_backref( snode, nbackref, distance( m_subst.begin(), icur ) );
                break;

          case SUBST_QUOTE_META_ON:
                assert( subst_node::SUBST_STRING == snode.stype );
                if( snode.subst_string.rlength )
                     m_subst_list.push_back( snode );

                snode.subst_string.rstart = distance( m_subst.begin(), icur );
                for( itemp = icur, fdone = false; !fdone && icur != m_subst.end(); )
                {
                     switch( tok = SY::subst_token( icur, m_subst.end() ) )
                     {
                     case SUBST_ALL_OFF:
                          fdone = true;
                          break;
                     case NO_TOKEN:
                          ++icur; // fall-through
                     default:
                          itemp = icur;
                          break;
                     }
                }
                snode.subst_string.rlength = distance( m_subst.begin(), itemp ) - snode.subst_string.rstart;
                if( snode.subst_string.rlength )
                     m_subst_list.push_back( snode );

                if( tok == SUBST_ALL_OFF )
                {
                     snode.stype = subst_node::SUBST_OP;
                     snode.op     = subst_node::ALL_OFF;
                     m_subst_list.push_back( snode );
                }

                // re-initialize the subst_node
                snode.stype = subst_node::SUBST_STRING;
                snode.subst_string.rstart = distance( m_subst.begin(), icur );
                snode.subst_string.rlength = 0;
                break;

          case SUBST_UPPER_ON:
          case SUBST_UPPER_NEXT:
          case SUBST_LOWER_ON:
          case SUBST_LOWER_NEXT:
          case SUBST_ALL_OFF:
                assert( subst_node::SUBST_STRING == snode.stype );
                if( snode.subst_string.rlength )
                     m_subst_list.push_back( snode );

                snode.stype = subst_node::SUBST_OP;
                snode.op     = (subst_node::op_type) tok;
                m_subst_list.push_back( snode );

                // re-initialize the subst_node
                snode.stype = subst_node::SUBST_STRING;
                snode.subst_string.rstart = distance( m_subst.begin(), icur );
                snode.subst_string.rlength = 0;
                break;
          
          case SUBST_ESCAPE:
                if( icur == m_subst.end() )
                     throw bad_regexpr("expecting escape sequence in substitution string");
                assert( subst_node::SUBST_STRING == snode.stype );
                if( snode.subst_string.rlength )
                     m_subst_list.push_back( snode );
                snode.subst_string.rstart = distance( m_subst.begin(), icur++ );
                snode.subst_string.rlength = 1;
                break;

          case NO_TOKEN:
          default:
                ++snode.subst_string.rlength;
                ++icur;
                break;
          }
     }
     assert( subst_node::SUBST_STRING == snode.stype );
     if( snode.subst_string.rlength )
          m_subst_list.push_back( snode );
}

template< typename CI, typename SY >
basic_rpattern<CI,SY>::charset_map basic_rpattern<CI,SY>::s_charset_map;

// Pass in an interator to one after the opening bracket of the character set.
// On return, icur points to one character after the closing bracket
template< typename CI, typename SY >
sub_expr<CI> * create_charset_helper<CI,SY>::create_charset_aux(
     basic_string<iterator_traits<CI>::value_type> & str,
     basic_string<iterator_traits<CI>::value_type>::iterator & icur,
     unsigned flags )
{
     bool fcomplement = false;
     match_charset<CI> * pnew = NULL;
     basic_string<iterator_traits<CI>::value_type>::iterator itemp = icur;

     if( itemp != str.end() && CHARSET_NEGATE == SY::charset_token( itemp, str.end() ) )
     {
          fcomplement = true;
          icur = itemp;
     }

     switch( ( NOCASE | CSTRINGS ) & flags )
     {
     case 0:
          pnew = new match_custom_charset_t<eos_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
          break;
     case NOCASE:
          pnew = new match_custom_charset_t<eos_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
          break;
     case CSTRINGS:
          pnew = new match_custom_charset_t<eocs_t<CI>,match_range_with_case>( fcomplement, icur, str.end(), flags, SY() );
          break;
     case NOCASE | CSTRINGS:
          pnew = new match_custom_charset_t<eocs_t<CI>,match_range_no_case>( fcomplement, icur, str.end(), flags, SY() );
          break;
     default:
          __assume(0); // tells the compiler that this is unreachable
     }

     return pnew;
}

#pragma warning( disable : 4660 )

// Explicit instantiation
#ifdef REGEX_FORCE_INSTANTIATION
 template class basic_regexpr<char>;
 template class basic_regexpr<wchar_t>;
#else
 template class basic_regexpr<TCHAR>;
#endif

#ifndef NO_PERL_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *>;
  template class basic_rpattern<const wchar_t *>;
  template class basic_rpattern<string::const_iterator>;
  template class basic_rpattern<wstring::const_iterator>;
 #else
  template class basic_rpattern<const TCHAR *>;
  template class basic_rpattern<tstring::const_iterator>;
 #endif
#endif

#ifdef POSIX_RE
 #ifdef REGEX_FORCE_INSTANTIATION
  template class basic_rpattern<const char *,posix_syntax<char> >;
  template class basic_rpattern<const wchar_t *,posix_syntax<wchar_t> >;
  template class basic_rpattern<string::const_iterator,posix_syntax<char> >;
  template class basic_rpattern<wstring::const_iterator,posix_syntax<wchar_t> >;
 #else
  template class basic_rpattern<const TCHAR *,posix_syntax<TCHAR> >;
  template class basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> >;
 #endif
#endif

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\regexpr.h ===
//+---------------------------------------------------------------------------
//
//  File:       basic_regexpr.hxx
//
//  Contents:   classes for regular expression pattern matching a-la perl
//
//  Classes:    basic_rpattern, basic_regexpr
//
//  Functions:  basic_regexpr::match
//              basic_regexpr::substitute
//              basic_regexpr::cbackrefs
//              basic_regexpr::backref
//              basic_regexpr::all_backrefs
//              basic_regexpr::backref_str
//
//  Coupling:   
//
//  History:    12-11-1998   ericne   Created
//              01-05-2001   ericne   Removed dependency on VC's choice
//                                    of STL iterator types.
//
//----------------------------------------------------------------------------

#pragma once
// warning C4290: C++ Exception Specification ignored
// warning C4786: identifier was truncated to '255' characters in the debug information
#pragma warning( disable : 4290 4786 )
#pragma warning( push )
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
#pragma warning( disable : 4511 4512 )

#ifdef _MT
#include <xtl.h> // for CRITICAL_SECTION
#endif

#include <string>
#include <stdexcept>
#include <vector>
#include <list>
#include <map>
#include <iosfwd>
#include <tchar.h>
#include <new.h> // for _set_new_handler
#include <crtdbg.h>
#include "syntax.h"

namespace regex
{

// Called when an allocation fails
inline int __cdecl my_new_handler( size_t )
{
    throw std::bad_alloc();
}

// For pushing and popping the new handler
class push_new_handler
{
   _PNH m_pnh;
public:
   push_new_handler( _PNH pnh )
   {
      m_pnh = _set_new_handler( pnh );
   }
   ~push_new_handler()
   {
      (void)_set_new_handler( m_pnh );
   }
};

class bad_regexpr : public std::runtime_error
{
public:
    explicit bad_regexpr(const std::string& _S)
        : std::runtime_error(_S) {}
    virtual ~bad_regexpr() {}
};

//
// Flags to control how matching occurs
//
enum REGEX_FLAGS
{      
    NOCASE        = 0x0001, // ignore case
    GLOBAL        = 0x0002, // match everywhere in the string
    MULTILINE     = 0x0004, // ^ and $ can match internal line breaks
    SINGLELINE    = 0x0008, // . can match newline character
    RIGHTMOST     = 0x0010, // start matching at the right of the string
    NOBACKREFS    = 0x0020, // only meaningful when used with GLOBAL and substitute
    FIRSTBACKREFS = 0x0040, // only meaningful when used with GLOBAL
    ALLBACKREFS   = 0x0080, // only meaningful when used with GLOBAL
    CSTRINGS      = 0x0100, // optimize pattern for use with null-terminated strings
    NORMALIZE     = 0x0200  // Preprocess patterns: "\\n" => "\n", etc.
};

// Forward declarations
template< typename CI > struct match_param;
template< typename CI > class  match_group_base;
template< typename CI > class  match_wrapper;
template< typename CI > class  match_charset;
template< typename CI > class  basic_rpattern_base;

// --------------------------------------------------------------------------
// 
// Class:       width_type
// 
// Description: represents the width of a sub-expression
// 
// Methods:     width_add  - add two widths
//              width_mult - multiply two widths
//              width_type - ctor
//              width_type - ctor
//              operator=  - assign a width
//              operator== - are widths equal
//              operator!= - are widths now equal
//              operator+  - add two widths
//              operator*  - multiply two widths
// 
// Members:     m_min      - smallest number of characters a sub-expr can span
//              m_max      - largest number of characters a sub-expr can span
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct width_type
{
    size_t m_min;
    size_t m_max;

    static size_t width_add( size_t a, size_t b )
    {
        return ( size_t(-1) == a || size_t(-1) == b ? size_t(-1) : a + b );
    }

    static size_t width_mult( size_t a, size_t b )
    {
        return ( size_t(-1) == a || size_t(-1) == b ? size_t(-1) : a * b );
    }

    width_type( size_t _min = 0, size_t _max = size_t(-1) ) 
        : m_min(_min), m_max(_max) 
    {
    }
    
    width_type( const width_type & that ) 
        : m_min(that.m_min), m_max(that.m_max) 
    {
    }
    
    width_type & operator=( const width_type & that )
    {
        m_min = that.m_min;
        m_max = that.m_max;
        return *this;
    }

    bool operator==( const width_type & that ) const
    {
        return ( m_min == that.m_min && m_max == that.m_max );
    }

    bool operator!=( const width_type & that ) const
    {
        return ( m_min != that.m_min || m_max != that.m_max );
    }

    width_type operator+( const width_type & that ) const
    {
        return width_type( width_add( m_min, that.m_min ), width_add( m_max, that.m_max ) );
    }

    width_type operator*( const width_type & that ) const
    {
        return width_type( width_mult( m_min, that.m_min ), width_mult( m_max, that.m_max ) );
    }
};

const width_type worst_width(0,size_t(-1));
const width_type uninit_width(size_t(-1),size_t(-1));

// --------------------------------------------------------------------------
// 
// Class:       sub_expr
// 
// Description: patterns are "compiled" into a directed graph of sub_expr
//              structs.  Matching is accomplished by traversing this graph.
// 
// Methods:     sub_expr     - construct a sub_expr
//              _match_this  - does this sub_expr match at the given location
//              _width_this  - what is the width of this sub_expr
//              ~sub_expr    - virt dtor so cleanup happens correctly
//              _delete      - delete this node in the graph and all nodes linked
//              next         - pointer to the next node in the graph
//              next         - pointer to the next node in the graph
//              match_next   - match the rest of the graph
//              domatch      - match_this and match_next
//              is_assertion - true if this sub_expr is a zero-width assertion
//              get_width    - find the width of the graph at this sub_expr
// 
// Members:     m_pnext      - pointer to the next node in the graph
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI > 
class sub_expr
{
    sub_expr * m_pnext;

protected:
    
    // Only derived classes and basic_rpattern can instantiate sub_expr's
    sub_expr( ) 
        : m_pnext(NULL) 
    {
    }
    
    // match this object only
    virtual bool _match_this( match_param<CI> &, CI & ) const throw()
    { 
        return true; 
    }

    virtual width_type _width_this() throw() = 0;

public:

    typedef typename std::iterator_traits<CI>::value_type char_type;

    friend class match_wrapper<CI>;  // wrappers can access _match_this method

    virtual ~sub_expr() {}
    
    virtual void _delete() 
    { 
        if( m_pnext )
            m_pnext->_delete();
        delete this;
    }

    inline const sub_expr *const   next() const { return m_pnext; }
    inline       sub_expr *      & next()       { return m_pnext; }

    // Match all subsequent objects
    inline bool match_next( match_param<CI> & param, CI icur ) const throw()
    {
        return NULL == m_pnext || m_pnext->domatch( param, icur );
    }

    // Match this object and all subsequent objects
    // If domatch returns false, it must not change any internal state
    virtual bool domatch( match_param<CI> & param, CI icur ) const throw()
    {
        return ( _match_this(param,icur) && match_next(param,icur) );
    }

    virtual bool is_assertion() const throw() 
    { 
        return false; 
    }

    width_type get_width() throw()
    {
        width_type this_width = _width_this();
        
        if( NULL == m_pnext )
            return this_width;
        
        width_type that_width = m_pnext->get_width();

        return ( this_width + that_width );
    }
};

template< typename CI >
void delete_sub_expr( sub_expr<CI> * psub )
{
    if( psub )
        psub->_delete();
}

template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class create_charset_helper
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    static sub_expr<CI> * create_charset_aux(
        std::basic_string<char_type> & str,
        std::basic_string<char_type>::iterator & icur,
        unsigned flags );
};


// --------------------------------------------------------------------------
// 
// Class:       auto_sub_ptr
// 
// Description: Class for automatically cleaning up the structure associated
//              with a parsed pattern
// 
// Methods:     auto_sub_ptr  - private copy ctor - not used
//              operator=     - private assign operator - not used
//              operator T*   - private implicit cast operator - not used
//              auto_sub_ptr  - ctor
//              ~auto_sub_ptr - dtor, frees ptr
//              free_ptr      - explicitly free pointer
//              release       - relinquish ownership of ptr
//              operator=     - take ownership of ptr
//              get           - return ptr
//              get           - return ptr
//              operator->    - method call through ptr
//              operator->    - method call through ptr
// 
// Members:     m_psub        - sub_expr pointer
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename T >
class auto_sub_ptr
{
    T * m_psub;

    // hide these methods
    auto_sub_ptr( const auto_sub_ptr<T> & ) {}
    auto_sub_ptr & operator=( const auto_sub_ptr<T> & ) { return *this; }
    operator T*() const { return m_psub; }

public:
    auto_sub_ptr( T * psub = NULL ) : m_psub( psub ) {}
    
    ~auto_sub_ptr() 
    { 
        free_ptr();
    }

    void free_ptr() // deallocate
    {
        delete_sub_expr( m_psub );
        m_psub = NULL;
    }

    T * release() // relinquish ownership, but don't deallocate
    { 
        T * psub = m_psub; 
        m_psub = NULL; 
        return psub; 
    }

    auto_sub_ptr<T> & operator=( T * psub ) 
    { 
        delete_sub_expr( m_psub );
        m_psub = psub;
        return *this;
    }

    inline const T*const   get()        const { return m_psub; }
    inline       T*      & get()              { return m_psub; }
    inline const T*const   operator->() const { return m_psub; }
    inline       T*        operator->()       { return m_psub; }
};

template< typename CI >
struct backref_tag : public std::pair<CI,CI>
{
    backref_tag( CI i1 = CI(0), CI i2 = CI(0) )
        : std::pair<CI,CI>(i1,i2), reserved(0) {}
    operator bool() const throw() { return first != CI(0) && second != CI(0); }
    bool operator!() const throw() { return ! operator bool(); }
    size_t reserved; // used for internal book-keeping
};

backref_tag< const char * > _static_match_helper(
    const char * szstr,
    const basic_rpattern_base< const char * > & pat,
    std::vector< backref_tag< const char * > > * prgbackrefs ) throw();

backref_tag< const wchar_t * > _static_match_helper(
    const wchar_t * szstr,
    const basic_rpattern_base< const wchar_t * > & pat,
    std::vector< backref_tag< const wchar_t * > > * prgbackrefs ) throw();

size_t _static_count_helper( 
    const char * szstr,
    const basic_rpattern_base< const char * > & pat ) throw();

size_t _static_count_helper( 
    const wchar_t * szstr,
    const basic_rpattern_base< const wchar_t * > & pat ) throw();

// --------------------------------------------------------------------------
// 
// Class:       basic_regexpr
// 
// Description: string class that allows regular expression pattern matching
// 
// Methods:     basic_regexpr  - ctor
//              match          - static method for matching C-style strings
//              match          - non-static method for matching C++-style strings
//              count          - static method for couting matches in C-style strings
//              count          - non-static method for counting matches in C++-style strin
//              substitute     - perform substitutions in C++-style strings
//              cbackrefs      - return the count of internally stored back-references
//              rstart         - offset to start of n-th backref
//              rlength        - lenght of n-th backref
//              backref        - return the n-th backref
//              all_backrefs   - return a vector of all saved backrefs
//              backref_str    - return the string to which the backreferences refer
// 
// Members:     m_rgbackrefs   - vector of backrefs
//              m_backref_str  - temp string buffer
//              m_pbackref_str - pointer to the string containing the string to which
//                               the backreferences refer (either *this or m_backref_str)
// 
// Typedefs:    backref_type   - 
//              backref_vector - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CH, typename TR = std::char_traits<CH>, typename AL = std::allocator<CH> >
class basic_regexpr : public std::basic_string<CH,TR,AL>
{
public:

    basic_regexpr( const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const CH * p, size_type n,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( p, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const std::basic_string<CH,TR,AL> & s, size_type pos = 0, size_type n = npos,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( s, pos, n, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( size_type n, CH ch,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( n, ch, a ), m_pbackref_str( & m_backref_str ) {}
    
    basic_regexpr( const_iterator begin, const_iterator end,
                   const allocator_type & a = allocator_type() )
        : std::basic_string<CH,TR,AL>( begin, end, a ), m_pbackref_str( & m_backref_str ) {}

    // actually stores iterators into *m_pbackref_str:
    typedef backref_tag<const_iterator> backref_type;
    typedef std::vector< backref_type > backref_vector;

    // stores pointers into the null-terminated C-stype string
    typedef backref_tag< const CH * >     backref_type_c;
    typedef std::vector< backref_type_c > backref_vector_c;

    // returns $0, the first backref
    static backref_type_c match( const CH * szstr,
                                 const basic_rpattern_base< const CH * > & pat,
                                 backref_vector_c * prgbackrefs = NULL ) throw()
    {
        return _static_match_helper( szstr, pat, prgbackrefs );
    }

    // returns $0, the first backref
    backref_type match( const basic_rpattern_base< const_iterator > & pat,
                        size_type pos = 0,
                        size_type len = npos ) const throw();

    static size_t count( const CH * szstr,
                         const basic_rpattern_base< const CH * > & pat ) throw()
    {
        return _static_count_helper( szstr, pat );
    }

    size_t count( const basic_rpattern_base< const_iterator > & pat,
                  size_type pos = 0,
                  size_type len = npos ) const throw();

    size_t substitute( const basic_rpattern_base< const_iterator > & pat,
                       size_type pos = 0,
                       size_type len = npos ) throw(std::bad_alloc);

    size_t cbackrefs() const throw()
    { 
        return m_rgbackrefs.size(); 
    }

    size_type rstart( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_pbackref_str->begin(), m_rgbackrefs.at( cbackref ).first );
    }

    size_type rlength( size_t cbackref = 0 ) const throw(std::out_of_range)
    {
        return std::distance( m_rgbackrefs.at( cbackref ).first, m_rgbackrefs.at( cbackref ).second );
    }

    backref_type backref( size_t cbackref ) const throw(std::out_of_range)
    {
        return m_rgbackrefs.at( cbackref );
    }

    const backref_vector & all_backrefs() const throw()
    {
        return m_rgbackrefs;
    }

    const std::basic_string<CH,TR,AL> & backref_str() const throw()
    {
        return *m_pbackref_str;
    }

protected:

    // save information about the backrefs
    // mutable because these can change in the "const" match() method.
    mutable backref_vector m_rgbackrefs;
    mutable std::basic_string<CH,TR,AL> m_backref_str;
    mutable const std::basic_string<CH,TR,AL> * m_pbackref_str;
};

// --------------------------------------------------------------------------
// 
// Class:       match_param
// 
// Description: Struct that contains the state of the matching operation.
//              Passed by reference to all domatch and _match_this routines.
// 
// Methods:     match_param - ctor
//              match_param - ctor
// 
// Members:     ibegin      - start of the string
//              istart      - start of this iteration
//              istop       - end of the string
//              prgbackrefs - pointer to backref array0
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
struct match_param
{
    CI ibegin;
    CI istart;
    CI istop;
    std::vector< backref_tag< CI > > * prgbackrefs;

    match_param( CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_istart),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
    match_param( CI _ibegin,
                 CI _istart,
                 CI _istop,
                 std::vector< backref_tag< CI > > * _prgbackrefs )
    : ibegin(_ibegin),
      istart(_istart),
      istop(_istop),
      prgbackrefs(_prgbackrefs)
    {
    }
};

// --------------------------------------------------------------------------
// 
// Class:       subst_node
// 
// Description: Substitution strings are parsed into an array of these
//              structures in order to speed up subst operations.
// 
// Members:     stype         - type of this struct
//              subst_string  - do a string substitution
//              subst_backref - do a bacref substitution
//              op            - execute an operation
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
struct subst_node
{
    enum subst_type { SUBST_STRING, SUBST_BACKREF, SUBST_OP };
    enum         { PREMATCH = -1, POSTMATCH = -2 };
    enum op_type { UPPER_ON   = SUBST_UPPER_ON,
                   UPPER_NEXT = SUBST_UPPER_NEXT, 
                   LOWER_ON   = SUBST_LOWER_ON, 
                   LOWER_NEXT = SUBST_LOWER_NEXT, 
                   ALL_OFF    = SUBST_ALL_OFF };
    subst_type stype;
    union
    {
        struct
        {
            size_t rstart;
            size_t rlength;
        } subst_string;
        size_t  subst_backref;
        op_type op;
    };
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern_base
// 
// Description: 
// 
// Methods:     basic_rpattern_base     - ctor
//              flags                   - get the state of the flags
//              uses_backrefs           - true if the backrefs are referenced
//              get_first_subexpression - return ptr to first sub_expr struct
//              get_width               - get min/max nbr chars this pattern can match
//              loops                   - if false, we only need to try to match at 1st position
//              cgroups                 - number of visible groups
//              _cgroups_total          - total number of groups, including hidden (?:) groups
//              get_pat                 - get string representing the pattern
//              get_subst               - get string representing the substitution string
//              get_subst_list          - get the list of subst nodes
//              _normalize_string       - perform character escaping
//              _reset                  - reinitialize the pattern
// 
// Members:     m_fuses_backrefs        - 
//              m_floop                 - 
//              m_cgroups               - 
//              m_cgroups_visible       - 
//              m_flags                 - 
//              m_nwidth                - 
//              m_pat                   - 
//              m_subst                 - 
//              m_subst_list            - 
//              m_pfirst                - 
// 
// Typedefs:    char_type               - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI >
class basic_rpattern_base
{
public:
    typedef std::iterator_traits<CI>::value_type char_type;

    basic_rpattern_base( unsigned flags = 0, 
                         const std::basic_string<char_type> & pat   = std::basic_string<char_type>(),
                         const std::basic_string<char_type> & subst = std::basic_string<char_type>() ) throw()
        : m_fuses_backrefs( false ),
          m_floop( true ),
          m_cgroups( 0 ),
          m_cgroups_visible( 0 ),
          m_flags( flags ),
          m_nwidth( uninit_width ),
          m_pat( pat ),
          m_subst( subst ),
          m_pfirst( NULL )
    {
    }

    unsigned flags() const throw() 
    { 
        return m_flags; 
    }

    bool uses_backrefs() const throw()
    {
        return m_fuses_backrefs;
    }

    const sub_expr<CI> * get_first_subexpression() const throw()
    {
        return m_pfirst.get();
    }

    width_type get_width() const throw()
    {
        return m_nwidth;
    }

    bool loops() const throw()
    {
        return m_floop;
    }

    size_t cgroups() const throw() 
    { 
        return m_cgroups_visible; 
    }
    
    size_t _cgroups_total() const throw() 
    { 
        return m_cgroups; 
    }

    const std::basic_string<char_type> & get_pat() const throw()
    {
        return m_pat;
    }

    const std::basic_string<char_type> & get_subst() const throw()
    {
        return m_subst;
    }

    const std::list<subst_node> & get_subst_list() const throw()
    {
        return m_subst_list;
    }

protected:
    
    void     _normalize_string( std::basic_string<char_type> & str );

    void     _reset() throw()
    {
        m_fuses_backrefs = false;
        m_flags          = 0;
    }

    bool        m_fuses_backrefs;  // true if the substitution uses backrefs
    bool        m_floop;           // false if m_pfirst->domatch only needs to be called once
    size_t      m_cgroups;         // number of groups (always at least one)
    size_t      m_cgroups_visible; // number of visible groups
    unsigned    m_flags;           // flags used to customize search/replace
    width_type  m_nwidth;          // width of the pattern

    std::basic_string<char_type>  m_pat;   // contains the unparsed pattern
    std::basic_string<char_type>  m_subst; // contains the unparsed substitution

    std::list<subst_node>         m_subst_list; // used to speed up substitution
    auto_sub_ptr<sub_expr<CI> >   m_pfirst;     // first subexpression in pattern
};

// --------------------------------------------------------------------------
// 
// Class:       basic_rpattern
// 
// Description: 
// 
// Methods:     basic_rpattern             - ctor
//              basic_rpattern             - 
//              basic_rpattern             - 
//              init                       - for (re)initializing a pattern
//              init                       - 
//              set_substitution           - set the substitution string
//              set_flags                  - set the flags
//              register_intrinsic_charset - bind an escape sequence to a user-def'd charset
//              purge_intrinsic_charsets   - delete all user-def'd charsets
//              _get_next_group_nbr        - return a monotomically increasing id
//              _find_next_group           - parse the next group of the pattern
//              _find_next                 - parse the next sub_expr of the pattern
//              _find_atom                 - parse the next atom of the pattern
//              _quantify                  - quantify the sub_expr
//              _common_init               - perform some common initialization tasks
//              _parse_subst               - parse the substitution string
//              _add_subst_backref         - add a backref node to the subst list
//              _reset                     - reinitialize the pattern
// 
// Members:     s_charset_map              - for maintaining user-defined charsets
//              m_invisible_groups         - list of hidden groups to be numbered last
// 
// Typedefs:    syntax_type                - 
// 
// History:     8/14/2000 - ericne - Created
// 
// --------------------------------------------------------------------------
template< typename CI, typename SY = perl_syntax<std::iterator_traits<CI>::value_type> >
class basic_rpattern : public basic_rpattern_base<CI>
{
public:

    friend class match_charset<CI>;

    typedef SY syntax_type;

    basic_rpattern() throw();

    basic_rpattern( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);
    
    basic_rpattern( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void init( const std::basic_string<char_type> & pat, const std::basic_string<char_type> & subst, unsigned flags=0 ) throw(bad_regexpr,std::bad_alloc);

    void set_substitution( const std::basic_string<char_type> & subst ) throw(bad_regexpr,std::bad_alloc);
    
    void set_flags( unsigned flags ) throw(bad_regexpr,std::bad_alloc);
    
    class charset_map
    {
        struct charsets
        {
            sub_expr<CI>                 * rgpcharsets[2];
            std::basic_string<char_type>   str_charset;

            charsets() throw()
            {
                memset( rgpcharsets, 0, sizeof( rgpcharsets ) ); 
            }
            ~charsets() throw()
            {
                clean();
            }
            void clean() throw()
            {
                for( int i=0; i < (sizeof(rgpcharsets)/sizeof(*rgpcharsets)); ++i )
                {
                    delete_sub_expr( rgpcharsets[i] );
                    rgpcharsets[i] = NULL;
                }
            }
            match_charset<CI> * get_charset( unsigned flags ) throw(bad_regexpr,std::bad_alloc)
            {
                push_new_handler pnh( &my_new_handler );
                // Since these charsets are only used while creating other charsets,
                // all flags besides NOCASE can safely be ignored here.
                bool index = ( NOCASE == ( NOCASE & flags ) );
                if( NULL == rgpcharsets[ index ] )
                {
                    std::basic_string<char_type>::iterator istart = str_charset.begin();
                    rgpcharsets[ index ] = create_charset_helper<CI,SY>::create_charset_aux( str_charset, ++istart, flags );
                }
                return (match_charset<CI>*) rgpcharsets[ index ];
            }
        };

        typedef std::map<char_type,charsets> map_type;
        std::auto_ptr<map_type> m_pmap;

    public:

        void put( char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
        {
            // These characters cannot be bound to a user-defined intrinsic character set
            static const char_type rgIllegal[] = 
            {
                '0','1','2','3','4','5','6','7','8','9',     // backrefs
                'A','Z','z','b','B','d','D','s','S','w','W', // assertions
                'Q','E'                                      // quote-meta
            };

            // So operator new throws bad_alloc on failure.
            push_new_handler pnh( &my_new_handler );

            if( std::char_traits<char_type>::find( rgIllegal, ARRAYSIZE( rgIllegal ), ch ) )
                throw bad_regexpr( "illegal character specified for intrinsic character set." );

            if( NULL == m_pmap.get() )
                m_pmap = std::auto_ptr<map_type>( new map_type );

            // creates an empty entry if one does not already exist
            charsets & chrsts = (*m_pmap)[ch];
            chrsts.clean();
            chrsts.str_charset = str;

            // Try compiling the character set once to make sure it is properly formed:
            (void) chrsts.get_charset( 0 );
        }

        match_charset<CI> * get( char_type ch, unsigned flags ) throw()
        {
            match_charset<CI> * pRet = NULL;
            if( NULL != m_pmap.get() )
            {
                try
                {
                    push_new_handler pnh( &my_new_handler );
                    map_type::iterator iter = m_pmap->find( ch );
                    if( iter != m_pmap->end() )
                        pRet = iter->second.get_charset( flags );
                }
                catch(...) {}
            }

            return pRet;
        }

        void purge() throw()
        {
            if( NULL != m_pmap.get() )
                delete m_pmap.release();
        }
    };

    static void register_intrinsic_charset( 
        char_type ch, const std::basic_string<char_type> & str ) throw(bad_regexpr,std::bad_alloc)
    {
        s_charset_map.put( ch, str );
    }

    static void purge_intrinsic_charsets() throw()
    {
        s_charset_map.purge();
    }

protected:
    
    static charset_map s_charset_map;

    size_t _get_next_group_nbr() 
    { 
        return m_cgroups++; 
    }

    match_group_base<CI> * _find_next_group( 
        std::basic_string<char_type>::iterator & ipat, 
        unsigned & flags,
        std::vector<match_group_base<CI>*> & rggroups );
    
    bool _find_next( 
        std::basic_string<char_type>::iterator & ipat,
        match_group_base<CI> * pgroup, unsigned & flags,
        std::vector<match_group_base<CI>*> & rggroups );
    
    void _find_atom( 
        std::basic_string<char_type>::iterator & ipat,
        match_group_base<CI> * pgroup, unsigned flags );
    
    void _quantify( 
        auto_sub_ptr<sub_expr<CI> > & pnew,
        match_group_base<CI> * pnew_group,
        std::basic_string<char_type>::iterator & ipat );

    void _common_init( unsigned flags );
    
    void _parse_subst();
    
    void _add_subst_backref( subst_node & snode, size_t nbackref, size_t rstart );

    void _reset() throw();

    std::list<match_group_base<CI>*>   m_invisible_groups; // groups w/o backrefs

};

template< typename CH, typename TR, typename AL >
void process_escapes( std::basic_string<CH,TR,AL> & str )
{
    size_t i = 0;

    while( basic_string<CH,TR,AL>::npos != ( i = str.find( CH('\\'), i ) ) )
    {
        if( str.size() - 1 == i )
            return;

        switch( str[i+1] )
        {
        case CH('f'):
            str.replace( i, 2, 1, CH('\f') );
            break;
        case CH('n'):
            str.replace( i, 2, 1, CH('\n') );
            break;
        case CH('r'):
            str.replace( i, 2, 1, CH('\r') );
            break;
        case CH('t'):
            str.replace( i, 2, 1, CH('\t') );
            break;
        case CH('v'):
            str.replace( i, 2, 1, CH('\v') );
            break;
        case CH('\\'):
            str.replace( i, 2, 1, CH('\\') );
            break;
        default:
            ++i;
            break;
        }
        ++i;
        if( str.size() <= i )
            return;
    }
}

inline std::ostream & operator<<( std::ostream & sout, 
                                  const basic_regexpr<char>::backref_type & br )
{
    for( std::string::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis );
    return sout;
}

inline std::wostream & operator<<( std::wostream & sout, 
                                   const basic_regexpr<wchar_t>::backref_type & br )
{
    for( std::wstring::const_iterator ithis = br.first; ithis != br.second; ++ithis )
        sout.put( *ithis > UCHAR_MAX ? L'?' : *ithis );
    return sout;
}

typedef basic_regexpr<TCHAR>     regexpr;
typedef std::basic_string<TCHAR> tstring;

typedef basic_rpattern<const TCHAR *,perl_syntax<TCHAR> >  perl_rpattern_c;
typedef basic_rpattern<const TCHAR *,posix_syntax<TCHAR> > posix_rpattern_c;
typedef basic_rpattern<tstring::const_iterator,perl_syntax<TCHAR> >  perl_rpattern;
typedef basic_rpattern<tstring::const_iterator,posix_syntax<TCHAR> > posix_rpattern;

typedef perl_rpattern            rpattern;   // matches against std::string
typedef perl_rpattern_c          rpattern_c; // matches against null-terminated, c-style strings

#ifdef _MT

//
// Define some classes and macros for creating function-local 
// static const rpatterns in a thread-safe way
//

template< typename PAT >
class rpattern_destroyer
{
    const PAT           & m_refPat;
    const volatile bool & m_fConstructed;
public:
    rpattern_destroyer( const volatile bool & fConstructed, const PAT & refPat )
        : m_fConstructed( fConstructed ), m_refPat( refPat )
    {
    }
    ~rpattern_destroyer()
    {
        if( m_fConstructed )
            (&m_refPat)->~PAT();
    }
};

class CRegExCritSect : private CRITICAL_SECTION
{
public:
    CRegExCritSect()  { InitializeCriticalSection(this); }
    ~CRegExCritSect() { DeleteCriticalSection(this); }
    void Enter()      { EnterCriticalSection(this); }
    void Leave()      { LeaveCriticalSection(this); }
};

extern CRegExCritSect g_objRegExCritSect;

class CRegExLock
{
public:
    CRegExLock()  { g_objRegExCritSect.Enter(); }
    ~CRegExLock() { g_objRegExCritSect.Leave(); }
};

#define STATIC_RPATTERN_EX( type, var, params ) \
    static unsigned char s_rgb_##var[ sizeof type ]; \
    static volatile bool s_f_##var = false; \
    static const type & var = *reinterpret_cast<type*>( s_rgb_##var ); \
    static const regex::rpattern_destroyer<type> s_des_##var( s_f_##var, var ); \
    if( ! s_f_##var ) \
    { \
        regex::CRegExLock objLock; \
        if( ! s_f_##var ) \
        { \
            new( s_rgb_##var ) type params; \
            s_f_##var = true; \
        } \
    }

#else

#define STATIC_RPATTERN_EX( type, var, params ) \
    static const type var params;

#endif

#define STATIC_RPATTERN( var, params ) \
    STATIC_RPATTERN_EX( regex::rpattern, var, params )

} // namespace regex

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\syntax.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.cpp
//
//  Contents:   data definitions for the syntax modules
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------

#include <memory.h>
#include "syntax.h"

namespace regex
{

// Initialize the perl syntax look-up tables
perl_syntax_base::init_perl_syntax::init_perl_syntax()
{
    memset( perl_syntax_base::s_rgreg, 0, sizeof( perl_syntax_base::s_rgreg ) );
    memset( perl_syntax_base::s_rgescape, 0, sizeof( perl_syntax_base::s_rgescape ) );

    // REGULAR TOKENS
    perl_syntax_base::s_rgreg[ (unsigned char)'(' ] = BEGIN_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)')' ] = END_GROUP;
    perl_syntax_base::s_rgreg[ (unsigned char)'|' ] = ALTERNATION;
    perl_syntax_base::s_rgreg[ (unsigned char)'^' ] = BEGIN_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'$' ] = END_LINE;
    perl_syntax_base::s_rgreg[ (unsigned char)'[' ] = BEGIN_CHARSET;
    perl_syntax_base::s_rgreg[ (unsigned char)'.' ] = MATCH_ANY;
    perl_syntax_base::s_rgreg[ (unsigned char)'\\' ] = ESCAPE;

    // ESCAPE TOKENS
    perl_syntax_base::s_rgescape[ (unsigned char)'d' ] = ESC_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'D' ] = ESC_NOT_DIGIT;
    perl_syntax_base::s_rgescape[ (unsigned char)'s' ] = ESC_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'S' ] = ESC_NOT_SPACE;
    perl_syntax_base::s_rgescape[ (unsigned char)'w' ] = ESC_WORD;
    perl_syntax_base::s_rgescape[ (unsigned char)'W' ] = ESC_NOT_WORD;

    perl_syntax_base::s_rgescape[ (unsigned char)'A' ] = ESC_BEGIN_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'Z' ] = ESC_END_STRING;
    perl_syntax_base::s_rgescape[ (unsigned char)'z' ] = ESC_END_STRING_z;
    perl_syntax_base::s_rgescape[ (unsigned char)'b' ] = ESC_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'B' ] = ESC_NOT_WORD_BOUNDARY;
    perl_syntax_base::s_rgescape[ (unsigned char)'Q' ] = ESC_QUOTE_META_ON;
    perl_syntax_base::s_rgescape[ (unsigned char)'E' ] = ESC_QUOTE_META_OFF;
}
TOKEN perl_syntax_base::s_rgreg[ UCHAR_MAX + 1 ];
TOKEN perl_syntax_base::s_rgescape[ UCHAR_MAX + 1 ];
perl_syntax_base::init_perl_syntax perl_syntax_base::s_init_perl_syntax;

extern const posix_charset_type g_rgposix_charsets[] = 
{
    posix_charset_type("[:alnum:]",9),
    posix_charset_type("[:^alnum:]",10),
    posix_charset_type("[:alpha:]",9),
    posix_charset_type("[:^alpha:]",10),
    posix_charset_type("[:blank:]",9),
    posix_charset_type("[:^blank:]",10),
    posix_charset_type("[:cntrl:]",9),
    posix_charset_type("[:^cntrl:]",10),
    posix_charset_type("[:digit:]",9),
    posix_charset_type("[:^digit:]",10),
    posix_charset_type("[:graph:]",9),
    posix_charset_type("[:^graph:]",10),
    posix_charset_type("[:lower:]",9),
    posix_charset_type("[:^lower:]",10),
    posix_charset_type("[:print:]",9),
    posix_charset_type("[:^print:]",10),
    posix_charset_type("[:punct:]",9),
    posix_charset_type("[:^punct:]",10),
    posix_charset_type("[:space:]",9),
    posix_charset_type("[:^space:]",10),
    posix_charset_type("[:upper:]",9),
    posix_charset_type("[:^upper:]",10),
    posix_charset_type("[:xdigit:]",10),
    posix_charset_type("[:^xdigit:]",11)
};

extern const size_t g_cposix_charsets = ARRAYSIZE(g_rgposix_charsets);

} // namespace regex
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\memprint.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    memprint.cpp

Abstract:

    Memory Foot Print

Notes:

*****************************************************************************/

#include "memprint.h"

#define SLEEPTIME   7000

HANDLE hDuke[XGetPortCount()];
HANDLE hSlot[XGetPortCount()*2];

#define LOOP_MAX    1024

bool warmBoot = false;

XDEVICE_PREALLOC_TYPE deviceTypes[] = { {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_MEMORY_UNIT, 1} };
XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
WSADATA wsaData;
unsigned short version = MAKEWORD(2, 2);
HANDLE hTemp[LOOP_MAX];
DWORD dataType = 0xCDCDCDCD;
LAUNCH_DATA launchInfo;
char alternateDrive;
unsigned i;
IDirectSound *      g_dsound    = NULL;
IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
D3DPRESENT_PARAMETERS d3dpp;

MM_STATISTICS mmStats[2];
char mmStatsIndex = 0;
void GetMemoryStats(void)
    {
    memset(&mmStats[mmStatsIndex], 0, sizeof(MM_STATISTICS));
    mmStats[mmStatsIndex].Length = sizeof(MM_STATISTICS);
    MmQueryStatistics(&mmStats[mmStatsIndex]);

    mmStatsIndex = !mmStatsIndex;
    }

void LogMemory(MM_STATISTICS &m, char *note)
    {
    DebugPrint("%s Memory Status: %s\n", (warmBoot?"WARMBOOT:":"COLDBOOT:"), note);
    DebugPrint("   Total:       %12lu B (%d pages)\n", m.TotalPhysicalPages*PAGE_SIZE, m.TotalPhysicalPages);
    DebugPrint("   Available:   %12lu B (%d pages)\n", m.AvailablePages*PAGE_SIZE, m.AvailablePages);
    DebugPrint("   Cache:       %12lu B (%d pages)\n", m.CachePagesCommitted*PAGE_SIZE, m.CachePagesCommitted);
    DebugPrint("   Pool:        %12lu B (%d pages)\n", m.PoolPagesCommitted*PAGE_SIZE, m.PoolPagesCommitted);
    DebugPrint("   Stack:       %12lu B (%d pages)\n", m.StackPagesCommitted*PAGE_SIZE, m.StackPagesCommitted);
    DebugPrint("   Image:       %12lu B (%d pages)\n", m.ImagePagesCommitted*PAGE_SIZE, m.ImagePagesCommitted);
    }

void LogMemoryDifference(char *note)
    {
    GetMemoryStats();

    DebugPrint("%s Memory Consumption: %s\n", (warmBoot?"WARMBOOT:":"COLDBOOT:"), note);
    DebugPrint("   Avail Delta: %12ld B (%d pages)\n", mmStats[!mmStatsIndex].AvailablePages*PAGE_SIZE - mmStats[mmStatsIndex].AvailablePages*PAGE_SIZE, mmStats[!mmStatsIndex].AvailablePages - mmStats[mmStatsIndex].AvailablePages);
    DebugPrint("   Pool Delta:  %12ld B (%d pages)\n", mmStats[!mmStatsIndex].PoolPagesCommitted*PAGE_SIZE - mmStats[mmStatsIndex].PoolPagesCommitted*PAGE_SIZE, mmStats[!mmStatsIndex].PoolPagesCommitted - mmStats[mmStatsIndex].PoolPagesCommitted);
    }

#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

void _cdecl main(void)
    {
    //
    // memory snapshot at beginning of main
    //
    Sleep(SLEEPTIME);
    GetMemoryStats();

    //
    // XGetLaunchInfo
    //
    memset(&launchInfo, 0, sizeof(LAUNCH_DATA));
    XGetLaunchInfo(&dataType, &launchInfo);

    Sleep(SLEEPTIME);
    if(dataType == LDT_FROM_DASHBOARD || dataType == 0xCDCDCDCD)
        warmBoot = false;
    else // dataType == LDT_TITLE || LDT_FROM_DEBUGGER_CMDLINE
        warmBoot = true;

    DebugPrint("\n\nMEMPRINT\nKernel Version: %u.%s\nXTL Version: %u.%s\n", XboxKrnlVersion->Build, (!!(0x8000 & XboxKrnlVersion->Qfe))?"checked":"free", XeImageHeader()->XapiLibraryVersion->BuildVersion, XeImageHeader()->XapiLibraryVersion->DebugBuild?"devkit":"retail");
    LogMemory(mmStats[!mmStatsIndex], "main"); // log main info first

    DebugPrint("Dump of the memory manager db:\n");
    HexDump((const unsigned char*)0x83FF0000, 64*1024);

    LogMemoryDifference("XGetLaunchInfo()");

    //
    // initializing usb with 1 duke and 1 mu
    //
    XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);
    Sleep(SLEEPTIME);
    LogMemoryDifference("XInitDevice(1 duke 1 mu)");

    //
    // initialize D3D
    //
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    Sleep(SLEEPTIME);
    LogMemoryDifference("Direct3DCreate8(D3D_SDK_VERSION)");

    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    Sleep(SLEEPTIME);
    LogMemoryDifference("CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, ...)");

    //
    // initialize DSound
    //
    DirectSoundCreate(NULL, &g_dsound, NULL);
    Sleep(SLEEPTIME);
    LogMemoryDifference("DirectSoundCreate()");

    //
    // initialize network
    //
    XNetStartup(&xnsp);
    Sleep(SLEEPTIME);
    LogMemoryDifference("XNetStartup(XNET_STARTUP_BYPASS_SECURITY)");

    //
    // initialize network
    //
    WSAStartup(version, &wsaData);
    Sleep(SLEEPTIME);
    LogMemoryDifference("WSAStartup(2.2)");

    //
    // XMountUtilityDrive
    //
    XMountUtilityDrive(true);
    Sleep(SLEEPTIME);
    LogMemoryDifference("XMountUtilityDrive(true)");

    //
    // XMountAlternateTitle
    //
    /*
    XMountAlternateTitle("T:\\", 0xAAAACCCC, &alternateDrive);
    Sleep(SLEEPTIME);
    LogMemoryDifference("XMountAlternateTitle(T:\\, 0xAAAACCCC)");

    XUnmountAlternateTitle(alternateDrive);
    Sleep(SLEEPTIME);
    LogMemoryDifference("XUnmountAlternateTitle()");\
    */


    //
    // done
    //
    GetMemoryStats();
    LogMemory(mmStats[!mmStatsIndex], "end of test");
    if(!warmBoot)
        {
        // run the test again from a warm boot
        DebugPrint("\n\n\n");
        XLaunchNewImage("D:\\default.xbe", &launchInfo);
        }

    XLaunchNewImage("D:\\DoneWithTest.xbe", &launchInfo); // this causes us to go into the dash w/ an eject disk message
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\memprint.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    memprint.h

Abstract:

    Memory Foot Print

Notes:

*****************************************************************************/

#ifndef _MEMPRINT_H_
#define _MEMPRINT_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
//#include <ntddcdrm.h>
#include <heap.h>
extern "C"
    {
    #include <ntos.h>
    #include <xbeimage.h>
    }


#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"

//#define PAGE_SIZE 4096

//
// utility functions
//
void DebugPrint(char* format, ...);



//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);
int ThumbStickScale(int stick, int max);
void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(bool interactive);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void HexDump(const unsigned char * buffer, DWORD length);
WCHAR* Ansi2UnicodeHack(char *str);


//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };


//
// graphics
//
extern IDirectSound *       g_dsound;
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;


//
// stats
//
extern bool warmBoot;



#endif //_MEMPRINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\medialoader\syntax.h ===
//+---------------------------------------------------------------------------
//
//  File:       syntax.h
//
//  Contents:   syntax modules for regexpr
//
//  Classes:    perl_syntax, posix_syntax
//
//  History:    3-29-00   ericne   Created
//
//----------------------------------------------------------------------------

#pragma once
#pragma warning(push)
// warning C4511: copy constructor could not be generated
// warning C4512: assignment operator could not be generated
#pragma warning( disable : 4511 4512 )

#include <string>
#include <cwchar>
#include <iterator>

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

#ifndef UCHAR_MAX
#define UCHAR_MAX 0xff
#endif

#ifndef WCHAR_MAX
#define WCHAR_MAX ((wchar_t)-1)
#endif

template<>
struct std::iterator_traits< const char * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef char value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef char * pointer;
	typedef char & reference;
};

template<>
struct std::iterator_traits< const wchar_t * >
{	// get traits from iterator _Iter
	typedef random_access_iterator_tag iterator_category;
	typedef wchar_t value_type;
	typedef ptrdiff_t difference_type;
	typedef difference_type distance_type;	// retained
	typedef wchar_t * pointer;
	typedef wchar_t & reference;
};

namespace regex
{

//
// The following are the tokens that can be emitted by the syntax module.
// Don't reorder this list!!!
//
enum TOKEN
{ 
    NO_TOKEN = 0,

    // REGULAR TOKENS
    BEGIN_GROUP,
    END_GROUP,
    ALTERNATION,
    BEGIN_LINE,
    END_LINE,
    BEGIN_CHARSET,
    MATCH_ANY,
    ESCAPE,

    // QUANTIFICATION TOKENS
    ONE_OR_MORE,
    ZERO_OR_MORE,
    ZERO_OR_ONE,
    ONE_OR_MORE_MIN,
    ZERO_OR_MORE_MIN,
    ZERO_OR_ONE_MIN,
    BEGIN_RANGE,
    RANGE_SEPARATOR,
    END_RANGE,
    END_RANGE_MIN,

    // ESCAPE SEQUENCES
    ESC_DIGIT,
    ESC_NOT_DIGIT,
    ESC_SPACE,
    ESC_NOT_SPACE,
    ESC_WORD,
    ESC_NOT_WORD,
    ESC_BEGIN_STRING,
    ESC_END_STRING,
    ESC_END_STRING_z,
    ESC_WORD_BOUNDARY,
    ESC_NOT_WORD_BOUNDARY,
    ESC_WORD_START,
    ESC_WORD_STOP,
    ESC_QUOTE_META_ON,
    ESC_QUOTE_META_OFF,

    // SUBSTITUTION TOKENS
    SUBST_BACKREF,
    SUBST_PREMATCH,
    SUBST_POSTMATCH,
    SUBST_MATCH,
    SUBST_ESCAPE,
    SUBST_QUOTE_META_ON,
    SUBST_UPPER_ON,
    SUBST_UPPER_NEXT,
    SUBST_LOWER_ON,
    SUBST_LOWER_NEXT,
    SUBST_ALL_OFF,

    // CHARSET TOKENS
    CHARSET_NEGATE,
    CHARSET_ESCAPE,
    CHARSET_RANGE,
    CHARSET_BACKSPACE,
    CHARSET_END,
    CHARSET_ALNUM,
    CHARSET_NOT_ALNUM,
    CHARSET_ALPHA,
    CHARSET_NOT_ALPHA,
    CHARSET_BLANK,
    CHARSET_NOT_BLANK,
    CHARSET_CNTRL,
    CHARSET_NOT_CNTRL,
    CHARSET_DIGIT,
    CHARSET_NOT_DIGIT,
    CHARSET_GRAPH,
    CHARSET_NOT_GRAPH,
    CHARSET_LOWER,
    CHARSET_NOT_LOWER,
    CHARSET_PRINT,
    CHARSET_NOT_PRINT,
    CHARSET_PUNCT,
    CHARSET_NOT_PUNCT,
    CHARSET_SPACE,
    CHARSET_NOT_SPACE,
    CHARSET_UPPER,
    CHARSET_NOT_UPPER,
    CHARSET_XDIGIT,
    CHARSET_NOT_XDIGIT,

    // EXTENSION TOKENS
    EXT_NOBACKREF,
    EXT_POS_LOOKAHEAD,
    EXT_NEG_LOOKAHEAD,
    EXT_POS_LOOKBEHIND,
    EXT_NEG_LOOKBEHIND,
    EXT_INDEPENDENT,
    EXT_UNKNOWN
};

struct posix_charset_type
{
    const char * const szcharset;
    const size_t       cchars;

    posix_charset_type( const char * const sz, const size_t c )
        : szcharset(sz), cchars(c) {}
};

extern const posix_charset_type g_rgposix_charsets[];
extern const size_t g_cposix_charsets;

template< typename const_iterator >
bool is_posix_charset( const_iterator icur, const_iterator iend, const char * szcharset )
{
    for( ; icur != iend && '\0' != *szcharset; ++icur, ++szcharset )
    {
        if( *icur != *szcharset )
            return false;
    }
    return '\0' == *szcharset;
}

//
// The perl_syntax class encapsulates the Perl 5 regular expression syntax. It is 
// used as a template parameter to basic_rpattern.  To customize regex syntax, create 
// your own syntax class and use it as a template parameter instead.
//

class perl_syntax_base
{
protected:
    static TOKEN s_rgreg[ UCHAR_MAX + 1 ];
    static TOKEN s_rgescape[ UCHAR_MAX + 1 ];

    struct init_perl_syntax;
    friend struct init_perl_syntax;
    static struct init_perl_syntax
    {
        init_perl_syntax();
    } s_init_perl_syntax;

    static inline TOKEN look_up( char ch, TOKEN rg[] ) { return rg[ (unsigned char)ch ]; }
    static inline TOKEN look_up( wchar_t ch, TOKEN rg[] ) { return UCHAR_MAX < ch ? NO_TOKEN : rg[ (unsigned char)ch ]; }
};

template< typename CH >
class perl_syntax : protected perl_syntax_base
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

private:
    static bool min_quant( iterator & icur, const_iterator iend )
    {
        return ( (const_iterator)++icur != iend && CH('?') == *icur ? (++icur,true) : false );
    }

public:
    static TOKEN reg_token( iterator & icur, const_iterator iend )
    { 
        assert( (const_iterator)icur != iend );
        TOKEN tok = look_up( *icur, s_rgreg );
        if( tok )
            ++icur;
        if( ESCAPE == tok && (const_iterator)icur != iend )
        {
            tok = look_up( *icur, s_rgescape );
            if( tok )
                ++icur;
            else
                tok = ESCAPE;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('*'):
            tok = min_quant( icur, iend ) ? ZERO_OR_MORE_MIN : ZERO_OR_MORE;
            break;
        case CH('+'):
            tok = min_quant( icur, iend ) ? ONE_OR_MORE_MIN : ONE_OR_MORE;
            break;
        case CH('?'):
            tok = min_quant( icur, iend ) ? ZERO_OR_ONE_MIN : ZERO_OR_ONE;
            break;
        case CH('}'):
            tok = min_quant( icur, iend ) ? END_RANGE_MIN : END_RANGE;
            break;
        case CH('{'):
            tok = BEGIN_RANGE;
            ++icur;
            break;
        case CH(','):
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('-'):
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case CH('^'):
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case CH(']'):
            tok = CHARSET_END;
            ++icur;
            break;
        case CH('\\'):
            tok = CHARSET_ESCAPE;
            if( (const_iterator)++icur == iend )
                break;
            switch( *icur )
            {
			case CH('b'):
			    tok = CHARSET_BACKSPACE;
				++icur;
				break;
            case CH('d'):
                tok = ESC_DIGIT;
                ++icur;
                break;
            case CH('D'):
                tok = ESC_NOT_DIGIT;
                ++icur;
                break;
            case CH('s'):
                tok = ESC_SPACE;
                ++icur;
                break;
            case CH('S'):
                tok = ESC_NOT_SPACE;
                ++icur;
                break;
            case CH('w'):
                tok = ESC_WORD;
                ++icur;
                break;
            case CH('W'):
                tok = ESC_NOT_WORD;
                ++icur;
                break;
            }
            break;
        case CH('['):
            if( CH(':') == *(++icur)-- )
            {
                for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
                {
                    if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                    {
                        tok = TOKEN(CHARSET_ALNUM + i);
                        std::advance( icur, g_rgposix_charsets[i].cchars );
                    }
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        assert( (const_iterator)icur != iend );
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case CH('\\'):
            tok = SUBST_ESCAPE;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('Q'):
                    tok = SUBST_QUOTE_META_ON;
                    ++icur;
                    break;
                case CH('U'):
                    tok = SUBST_UPPER_ON;
                    ++icur;
                    break;
                case CH('u'):
                    tok = SUBST_UPPER_NEXT;
                    ++icur;
                    break;
                case CH('L'):
                    tok = SUBST_LOWER_ON;
                    ++icur;
                    break;
                case CH('l'):
                    tok = SUBST_LOWER_NEXT;
                    ++icur;
                    break;
                case CH('E'):
                    tok = SUBST_ALL_OFF;
                    ++icur;
                    break;
                }
            break;
        case CH('$'):
            tok = SUBST_BACKREF;
            if( (const_iterator)++icur != iend )
                switch( *icur )
                {
                case CH('&'):
                    tok = SUBST_MATCH;
                    ++icur;
                    break;
                case CH('`'):
                    tok = SUBST_PREMATCH;
                    ++icur;
                    break;
                case CH('\''):
                    tok = SUBST_POSTMATCH;
                    ++icur;
                    break;
                }
            break;
        }
        return tok;
    }
    static TOKEN ext_token( iterator & icur, const_iterator iend, unsigned & flags )
    {
        assert( (const_iterator)icur != iend );
        bool finclude;
        TOKEN tok = NO_TOKEN;
        if( CH('?') == *icur )
        {
            tok = EXT_UNKNOWN;
            if( (const_iterator)++icur != iend )
            {
                switch( *icur )
                {
                case CH(':'):
                    tok = EXT_NOBACKREF;
                    ++icur;
                    break;
                case CH('='):
                    tok = EXT_POS_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('!'):
                    tok = EXT_NEG_LOOKAHEAD;
                    ++icur;
                    break;
                case CH('<'):
                    if( (const_iterator)++icur == iend )
                        break;
                    switch( *icur )
                    {
                    case CH('='):
                        tok = EXT_POS_LOOKBEHIND;
                        ++icur;
                        break;
                    case CH('!'):
                        tok = EXT_NEG_LOOKBEHIND;
                        ++icur;
                        break;
                    }
                    break;
                case CH('>'):
                    tok = EXT_INDEPENDENT;
                    ++icur;
                    break;
                default:
                    finclude = true;
                    do 
                    {
                        if( CH(':') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            ++icur;
                            break;
                        }
                        if( CH(')') == *icur )
                        {
                            tok = EXT_NOBACKREF;
                            break;
                        }
                        if( CH('-') == *icur && finclude )
                            finclude = false;
                        else if( CH('i') == *icur )
                            flags = finclude ? ( flags | NOCASE )     : ( flags & ~NOCASE );
                        else if( CH('m') == *icur )
                            flags = finclude ? ( flags | MULTILINE )  : ( flags & ~MULTILINE );
                        else if( CH('s') == *icur )
                            flags = finclude ? ( flags | SINGLELINE ) : ( flags & ~SINGLELINE );
                        else
                            break;
                    } while( (const_iterator)++icur != iend );
                    break;
                }
            }
        }
        return tok;
    }
};

//
// Implements the basic POSIX regular expression syntax
//
template< typename CH >
class posix_syntax
{
public:
    typedef std::basic_string<CH>::iterator iterator;
    typedef std::basic_string<CH>::const_iterator const_iterator;
    typedef CH char_type;

    static TOKEN reg_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '.':
            tok = MATCH_ANY;
            ++icur;
            break;
        case '^':
            tok = BEGIN_LINE;
            ++icur;
            break;
        case '$':
            tok = END_LINE;
            ++icur;
            break;
        case '[':
            tok = BEGIN_CHARSET;
            ++icur;
            break;
        case '\\':
            tok = ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '(':
                    tok = BEGIN_GROUP;
                    ++icur;
                    break;
                case ')':
                    tok = END_GROUP;
                    ++icur;
                    break;
                case '|':
                    tok = ALTERNATION;
                    ++icur;
                    break;
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN quant_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '*':
            tok = ZERO_OR_MORE;
            ++icur;
            break;
        case ',':
            tok = RANGE_SEPARATOR;
            ++icur;
            break;
        case '\\':
            ++icur;
            if( (const_iterator)icur != iend )
            {
                switch( *icur )
                {
                case '?':
                    tok = ZERO_OR_ONE;
                    ++icur;
                    break;
                case '+':
                    tok = ONE_OR_MORE;
                    ++icur;
                    break;
                case '{':
                    tok = BEGIN_RANGE;
                    ++icur;
                    break;
                case '}':
                    tok = END_RANGE;
                    ++icur;
                    break;
                default:
                    --icur;
                    break;
                }
            }
            else
            {
                --icur;
            }
        }
        return tok;
    }
    static TOKEN charset_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        switch( *icur )
        {
        case '^':
            tok = CHARSET_NEGATE;
            ++icur;
            break;
        case '-':
            tok = CHARSET_RANGE;
            ++icur;
            break;
        case ']':
            tok = CHARSET_END;
            ++icur;
            break;
        case '[':
            if( CH(':') == *(++icur)-- )
            {
                for( size_t i=0; !tok && i < g_cposix_charsets; ++i )
                {
                    if( is_posix_charset<const_iterator>( icur, iend, g_rgposix_charsets[i].szcharset ) )
                    {
                        tok = TOKEN(CHARSET_ALNUM + i);
                        std::advance( icur, g_rgposix_charsets[i].cchars );
                    }
                }
            }
            break;
        }
        return tok;
    }
    static TOKEN subst_token( iterator & icur, const_iterator iend )
    {
        TOKEN tok = NO_TOKEN;
        if( '\\' == *icur )
        {
            tok = SUBST_ESCAPE;
            ++icur;
            if( (const_iterator)icur != iend && '0' <= *icur && '9' >= *icur )
            {
                tok = SUBST_BACKREF;
            }
        }
        return tok;
    }
    static TOKEN ext_token( iterator &, const_iterator, unsigned & )
    {
        return NO_TOKEN;
    }
};

} // namespace regex
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    Low level disk test scanner.

Notes:

*****************************************************************************/
#include "memprint.h"

IDirectSound *      g_dsound    = NULL;
IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         150

int ThumbStickScale(int stick, int max)
    {
    if(stick > 0) stick -= STICK_DEAD_ZONE;
    else stick += STICK_DEAD_ZONE;

    return (stick*max)/(32768-STICK_DEAD_ZONE);
    }


void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale)
    {
    // UP
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
        {
        ++value;
        if(value > max) value = max;
        }
    if(input.Gamepad.sThumbLY > STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value > max) value = max;
        }

    // DOWN
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
        --value;
        if(value < min) value = min;
        if(value > max) value = min;
        }
    if(input.Gamepad.sThumbLY < -STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value < min) value = min;
        if(value > max) value = min;
        }
    }

/*
DWORD buttonXColor, buttonYColor, buttonAColor, buttonBColor, buttonBlkColor, buttonWhtColor;
DWORD currentSelection = 0;
void GUI(bool interactive)
    {
    bool exit = false;
    DWORD addDevice, removeDevice;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);

                if(interactive)
                    {
                    if(state.Gamepad.wButtons & XINPUT_GAMEPAD_START) exit = true;
                    }
                else
                    {
                    if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                    }

                if(!interactive) continue;

                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > BUTTON_PRESS_VALUE)
                    {
                    buttonXColor = 0xFFFFFF00;
                    AdjustValue(chunkSizeMin, 1, chunkSizeMax, state, 16);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > BUTTON_PRESS_VALUE)
                    {
                    buttonAColor = 0xFFFFFF00;
                    if(dvdUseReadFile)
                        AdjustValue(chunkSizeMax, chunkSizeMin, 10000, state, 16);
                    else
                        AdjustValue(chunkSizeMax, chunkSizeMin, 64, state, 16);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > BUTTON_PRESS_VALUE)
                    {
                    buttonYColor = 0xFFFFFF00;
                    AdjustValue(startLBA, 0, endLBA-1, state, 4096);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > BUTTON_PRESS_VALUE)
                    {
                    buttonBColor = 0xFFFFFF00;
                    AdjustValue(endLBA, startLBA+1, (DWORD)gDiskGeometry.Cylinders.QuadPart, state, 4096);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                    {
                    buttonBlkColor = 0xFFFFFF00;
                    AdjustValue(sequentialReads, 0, 1, state, 8);
                    }
                if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > BUTTON_PRESS_VALUE)
                    {
                    buttonWhtColor = 0xFFFFFF00;
                    AdjustValue(dvdUseReadFile, 0, 1, state, 8);
                    }
                }
            }

        UpdateGraphics(interactive ? DISPLAYMODE_CONFIG_INTERACTIVE : DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
    }
*/

void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);
/*
    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Firmware: %s", firmware);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, 0xFF4444FF, " Cylinders: %u", gDiskGeometry.Cylinders.QuadPart);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF4444FF, " Tracks/Cylinder: %u", gDiskGeometry.TracksPerCylinder);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, 0xFF4444FF, " Sectors/Track: %u", gDiskGeometry.SectorsPerTrack);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 4, 0xFF4444FF, " Bytes/Sector: %u", gDiskGeometry.BytesPerSector);

        unsigned line = 5;
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Blocks Read: %I64u", numBlocksRead);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " Run Time: %u sec", (GetTickCount() - time)/1000);

        if(sequentialReads)
            {
            if(stopAfter)
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u of %u", numTimesThrough, stopAfter);
            else
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u", numTimesThrough);
            }

        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Buffer Mismatches: %u", numBuffMisMatch);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Diff Failures: %u", numFailThenFail);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Pass then Fail:  %u", numPassThenFail);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Same Failures: %u", numFailThenFailSame);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Fail then Pass:  %u", numFailThenPass);

        if(mode == DISPLAYMODE_RUN_TIME)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
            }
        else if(mode == DISPLAYMODE_PAUSE)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue");
            }
        }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY || mode == DISPLAYMODE_CONFIG_INTERACTIVE)
        {
        DWORD color;
        if(mode == 2) color = 0xFF777777;
        else color = 0xFFFFFFFF;

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  1, buttonXColor & color,  "X: Read Size Min: %u", chunkSizeMin);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET , 2, buttonAColor & color,  "A: Read Size Max: %u", chunkSizeMax);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, buttonYColor & color,  " Y: Start LBA: %u", startLBA);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, buttonBColor & color,  " B: End LBA: %u", endLBA);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  3, buttonWhtColor & color,  "White: DVDUseReadFile: %u", dvdUseReadFile);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, buttonBlkColor & color,  " Black: SequentialReads: %u", sequentialReads);


        if(mode == DISPLAYMODE_CONFIG_INTERACTIVE) // interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Use the DPAD or Left Thumbstick UP/DOWN to change the values");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press START to continue");
            }
        else // non interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
            }
        }*/

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                DebugPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\dvdexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        DebugPrint("\r\n\r\nFound Exit File (dvdexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    DWORD addDevice, removeDevice;
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //DebugPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //DebugPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    //D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    //g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    /*
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
        */

    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\memprint\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "memprint.h"


/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((DWORD)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }



static char *logFilename = NULL;
static XGAME_FIND_DATA saveGameData;
void DebugPrint(char* format, ...)
    {
    char szBuffer[1024];
    DWORD err = GetLastError(); // we dont want DebugPrint to tromp on the last error

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    if(!logFilename)
        {
        HANDLE h = XFindFirstSaveGame("U:\\", &saveGameData);
        if(h == INVALID_HANDLE_VALUE)
            {
            logFilename = saveGameData.szSaveGameDirectory;
            XCreateSaveGame("U:\\", L"Test Results Log", OPEN_ALWAYS, 0, logFilename, MAX_PATH);
            strcat(logFilename, "\\memprint.txt");
            }
        else
            {
            logFilename = saveGameData.szSaveGameDirectory;
            strcat(logFilename, "\\memprint.txt");
            if(!warmBoot) DeleteFile(logFilename); // remove old copy of file
            XFindClose(h);
            }
        }

    FILE *f = fopen(logFilename, "a+");
    if(f)
        {
        fprintf(f, "%s", szBuffer);
        fclose(f);
        }

    va_end(args);

    SetLastError(err);
    }


void HexDump(const unsigned char * buffer, DWORD length)
    {
    DWORD i, count, index;
    char digits[]="0123456789ABCDEF";
    char line[100];
    unsigned cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        cbLine = sprintf(line, "%08X  ", index);

        for(i=0;i<count;i++)
            {
            line[cbLine++] = digits[buffer[i] >> 4];
            line[cbLine++] = digits[buffer[i] & 0x0f];
            if(i == 7)
                {
                line[cbLine++] = ' ';
                line[cbLine++] = '|';
                line[cbLine++] = ' ';
                }
            else
                {
                line[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            }

        line[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                line[cbLine++] = '.';
                }
            else
                {
                line[cbLine++] = buffer[i];
                }
            }

        line[cbLine++] = 0;
        DebugPrint("%s\n", line);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\mfgstates\utils.cpp ===
/*
State1: System Integration	
EEPROM	            No settings other than fixed mac addr & game region
HDD	                Unlocked, formatted, no dash.
VIDEO REGION	    None.
GAME REGION	        Manufacturing.
CLOCK/TZ/LANGUAGE	Not Set.
Behavior	
 Boot, No disk (or non game disc) in drive:	Box hangs at boot. 
 Boot, game disc in drive, non-mfg region	Box hangs at boot. 
 Boot, game disc in drive, mfg region.	Box runs disc.


State 2: System Test	
EEPROM	            All factory settings valid
HDD	                Unlocked, formatted, dash present
VIDEO REGION	    Correct per SKU.
GAME REGION	        Manufacturing + SKU Region
CLOCK/TZ/LANGUAGE	Not Set.
Behavior	
 Boot, No disk (or non game disc) in drive:	Displays Universal Error Message
 Boot, game disc in drive, non-mfg region	Displays Universal Error Message (even if region matches SKU region)
 Boot, game disc in drive, mfg region.	Box runs disc.


State 3: OOBE/Out Of Box Audit	
EEPROM	            All factory settings valid
HDD	                locked, formatted, dash present
VIDEO REGION	    Correct per SKU.
GAME REGION	        SKU region
CLOCK/TZ/LANGUAGE	Not Set.
Behavior	
 Boot, No disk (or non game disc) in drive:	Prompts for TZ/Clock/Language
 Boot, game disc in drive, non-mfg region	Prompts for TZ/Clock/Language
 Boot, game disc in drive, mfg region.	Prompts for TZ/Clock/Language


State 4: Post OOBE	
EEPROM	            All factory settings valid
HDD	                locked, formatted, dash present
VIDEO REGION	    Correct per SKU.
GAME REGION	        SKU region
CLOCK/TZ/LANGUAGE	Set.
Behavior	
 Boot, No disk (or non game disc) in drive:	Launch Xbox Dashboard
 Boot, game disc in drive, non-mfg region	Launch game (if region matches) or Dashboard w/error.
 Boot, game disc in drive, mfg region.	Launch Xbox Dashboard w/error
*/
//
// "winerror.h"
//
#include <ntos.h>
#include <init.h>
#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "PerBoxData.h"
#include "cryptkeys.h"
#include "xboxverp.h"

extern void DebugPrint(char* format, ...);

#define RC4_CONFOUNDER_LEN 8


//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

HRESULT SetRegion(DWORD regionFlags)
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    PXBOX_ENCRYPTED_EEPROM_DATA pEncryptedEEPROMData;
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

    eeprom = (EEPROM_LAYOUT*) buf;
    pEncryptedEEPROMData = (PXBOX_ENCRYPTED_EEPROM_DATA) &eeprom->EncryptedSection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        DebugPrint("   Error: %u\n", RtlNtStatusToDosError(status));
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
        if ( !bResult )
        {
            DebugPrint("   Error: rc4HmacDecrypt\n");
            return E_FAIL;
        }
    }

    //
    // Set the manufacturing region flag
    //
    pEncryptedEEPROMData->GameRegion = regionFlags;

    //
    // Compute Key to use to lock hard drive
    // This must be done before we encrypt the buffer back to the encrypted state
    //
    XcHMAC( pEncryptedEEPROMData->HardDriveKey, HARD_DRIVE_KEY_LEN,
            (BYTE*)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (BYTE*)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );

    //
    // Encrypt the encrypted part back again
    //
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) == 0)
    {
        //
        // Only Encrypt if it is not a dev kit
        //
        rc4HmacEncrypt(
            (LPBYTE)(&(pEncryptedEEPROMData->EncHeader) + XC_SERVICE_DIGEST_SIZE), // Use original confounder
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HardDriveKey, sizeof(pEncryptedEEPROMData->HardDriveKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->EncHeader) );
    }

    //
    // Save EEPROM Data into the EEPROM
    //
    status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, EEPROM_TOTAL_MEMORY_SIZE);
    if (!NT_SUCCESS(status))
    {
        DebugPrint("   Error: %u\n", RtlNtStatusToDosError(status));
        return E_FAIL;
    }


    //
    // Zero out the memory
    //
    RtlZeroMemory( FinalHardDriveKey, sizeof(FinalHardDriveKey) );
    RtlZeroMemory( buf, sizeof(buf) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\message.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  message.c

Abstract:

  This module handles the netsync message logic

Author:

  Steven Kehrli (steveke) 15-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace NetsyncNamespace;

namespace NetsyncNamespace {

DWORD
NetsyncSendMessageToPort(
    IN HANDLE   hNetsyncObject,
    IN u_long   ToAddr,
    IN u_short  ToPort,
    IN BOOL     bGuarantee,
    IN DWORD    dwMessageId,
    IN DWORD    dwMessageSize,
    IN char     *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a netsync message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  ToAddr - Destination address
  ToPort - Destination port
  bGuarantee - Specifies if the message is guaranteed
  dwMessageId - Specifies the id of the message
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT          pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;
    // toname is the destination address
    struct sockaddr_in       toname = { AF_INET, 0, 0, 0 };
    // pClient is a pointer to the client object
    PNETSYNC_CLIENT_OBJECT   pClient = NULL;
    // FileTime is the current file time
    FILETIME                 FileTime;
    // SendSN is the new send sequence number
    ULONGLONG                SendSN = 0;
    // hACKEvent is a handle to the ACK event
    HANDLE                   hACKEvent = NULL;
    // pSendMessage is a pointer to the send message buffer
    char                     *pSendMessage = NULL;
    // pNetsyncMessage is the pointer to the netsync message header in the send message buffer
    PNETSYNC_MESSAGE_HEADER  pNetsyncMessage = NULL;
    // dwSendMessageSize is the size of the send message
    DWORD                    dwSendMessageSize = 0;
    // dwBytes is the number of bytes sent on the socket
    DWORD                    dwBytes = 0;
    // dwAttempt is a counter to enumerate each attempt
    DWORD                    dwAttempt = 0;
    // dwNumAttempts is the number of attempts
    DWORD                    dwNumAttempts = 5;
    // dwTimeout specifies the timeout to wait for an ACK
    DWORD                    dwTimeout = 1000;
    // dwWaitResult is the result of the wait on the overlapped I/O event
    DWORD                    dwWaitResult = WAIT_FAILED;
    // iErrorCode is the last error code
    int                      iErrorCode = ERROR_SUCCESS;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    // Setup the destination address
    if (0 == ToAddr) {
        toname.sin_addr.s_addr = pNetsyncObject->ServerAddr;
    }
    else {
        toname.sin_addr.s_addr = ToAddr;
    }
    toname.sin_port = htons(ToPort);

    if (TRUE == bGuarantee) {
        // Find the client object
        pClient = FindClientObject(pNetsyncObject, toname.sin_addr.s_addr);
        if (NULL == pClient) {
            iErrorCode = GetLastError();

            goto ExitFunc;
        }

        // Create the ACK event
        hACKEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == hACKEvent) {
            iErrorCode = GetLastError();

            goto ExitFunc;
        }
    }

    // Get the message size
    dwSendMessageSize = sizeof(NETSYNC_MESSAGE_HEADER) + __min(dwMessageSize, NETSYNC_MESSAGE_SIZE);

    // Allocate the memory for the message
    pSendMessage = (char *) xMemAlloc(pNetsyncObject->hMemObject, dwSendMessageSize);
    if (NULL == pSendMessage) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    if (NULL != pClient) {
        // Wait for access to the send sequence number
        EnterCriticalSection(&pClient->csSendSN);

        // Get the new send sequence number
        ZeroMemory(&FileTime, sizeof(FileTime));
        GetSystemTimeAsFileTime(&FileTime);
        CopyMemory(&SendSN, &FileTime, sizeof(SendSN));

        if (SendSN <= pClient->LowSendSN) {
            pClient->HighSendSN++;
        }
        pClient->LowSendSN = SendSN;
    }

    // Set the netsync message header
    pNetsyncMessage = (PNETSYNC_MESSAGE_HEADER) pSendMessage;

    // Format the netsync message header
    pNetsyncMessage->dwMessageId = dwMessageId;
    pNetsyncMessage->dwMessageSize = dwMessageSize;
    CopyMemory(&pNetsyncMessage->FromXnAddr, &pNetsyncObject->XnAddr, sizeof(pNetsyncMessage->FromXnAddr));
    pNetsyncMessage->LowSN = (NULL == pClient) ? 0 : pClient->LowSendSN;
    pNetsyncMessage->HighSN = (NULL == pClient) ? 0 : pClient->HighSendSN;
    pNetsyncMessage->hACKEvent = hACKEvent;

    // Copy the message
    CopyMemory(pSendMessage + sizeof(NETSYNC_MESSAGE_HEADER), pMessage, __min(dwMessageSize, NETSYNC_MESSAGE_SIZE));

    // Wait for access to the critical section
    EnterCriticalSection(&pNetsyncObject->csSocket);

    for (dwAttempt = 0; dwAttempt < dwNumAttempts; dwAttempt++) {
        DebugMessage(NETSYNC_DEBUG_SEND, "NetsyncSendMessage(): Attempt %d - Send Message 0x%016I64x 0x%016I64x To 0x%08x On Port %u\n", (dwAttempt + 1), pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, toname.sin_addr, ToPort);

        // Send the message
        dwBytes = sendto(pNetsyncObject->sSocket, pSendMessage, dwSendMessageSize, 0, (SOCKADDR *) &toname, sizeof(SOCKADDR_IN));
        if (SOCKET_ERROR == dwBytes) {
            iErrorCode = WSAGetLastError();

            DebugMessage(NETSYNC_DEBUG_SEND, "NetsyncSendMessage(): Attempt %d - Failed Send Message 0x%016I64x 0x%016I64x To 0x%08x On Port %u - ec: 0x%08x\n", (dwAttempt + 1), pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, toname.sin_addr, ToPort, iErrorCode);

            break;
        }

        if (NULL == hACKEvent) {
            dwWaitResult = WAIT_OBJECT_0;

            break;
        }

        // Release access to the critical section
        LeaveCriticalSection(&pNetsyncObject->csSocket);

        // Wait for the ACK
        dwWaitResult = WaitForSingleObject(hACKEvent, dwTimeout);

        // Wait for access to the critical section
        EnterCriticalSection(&pNetsyncObject->csSocket);

        if (WAIT_OBJECT_0 == dwWaitResult) {
            DebugMessage(NETSYNC_DEBUG_SEND, "NetsyncSendMessage(): Attempt %d - Received ACK Send Message 0x%016I64x 0x%016I64x To 0x%08x On Port %u\n", (dwAttempt + 1), pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, toname.sin_addr, ToPort);

            break;
        }
        else if (WAIT_TIMEOUT == dwWaitResult) {
            iErrorCode = WAIT_TIMEOUT;

            DebugMessage(NETSYNC_DEBUG_SEND, "NetsyncSendMessage(): Attempt %d - Wait Timed Out Send Message 0x%016I64x 0x%016I64x To 0x%08x On Port %u\n", (dwAttempt + 1), pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, toname.sin_addr, ToPort);
        }
        else {
            iErrorCode = GetLastError();

            DebugMessage(NETSYNC_DEBUG_SEND, "NetsyncSendMessage(): Attempt %d - Wait Failed Send Message 0x%016I64x 0x%016I64x To 0x%08x On Port %u - ec: 0x%08x\n", (dwAttempt + 1), pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, toname.sin_addr, ToPort, iErrorCode);

            break;
        }

        // Increase timeout
        dwTimeout = dwTimeout * 2;
    }

    // Release access to the critical section
    LeaveCriticalSection(&pNetsyncObject->csSocket);

    if (NULL != pClient) {
        // Release access to the send sequence number
        LeaveCriticalSection(&pClient->csSendSN);
    }

ExitFunc:
    if (NULL != pSendMessage) {
        xMemFree(pNetsyncObject->hMemObject, pSendMessage);
    }

    if (NULL != hACKEvent) {
        CloseHandle(hACKEvent);
    }

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return dwWaitResult;
}



DWORD
NetsyncSendServerMessage(
    IN HANDLE   hNetsyncObject,
    IN u_long   ToAddr,
    IN u_short  ToPort,
    IN BOOL     bGuarantee,
    IN DWORD    dwMessageSize,
    IN char     *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a netsync message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  ToAddr - Destination address
  ToPort - Destination port
  bGuarantee - Specifies if the message is guaranteed
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT  pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    if (0 == ToPort) {
        ToPort = NETSYNC_PORT;
    }

    return NetsyncSendMessageToPort(hNetsyncObject, ToAddr, ToPort, bGuarantee, NETSYNC_MSGTYPE_SERVER, dwMessageSize, pMessage);
}



DWORD
NetsyncDequeueMessage(
    IN     HANDLE  hNetsyncObject,
    IN     DWORD   dwTimeout,
    IN OUT DWORD   *dwMessageType,
    OUT    u_long  *FromInAddr,
    OUT    XNADDR  *FromXnAddr,
    OUT    DWORD   *dwMessageSize,
    OUT    char *  *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Removes a message from a message queue

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  dwTimeout - Specifies the timeout interval, in milliseconds
  dwMessageType - Specifies the message type
  FromInAddr - Source ip address
  FromXnAddr - Source xnet address
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Address of the pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT         pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;

    // dwSemaphores is the count of semaphores
    DWORD                   dwSemaphores = 0;
    // hSemaphore is an array of semaphore
    HANDLE                  hSemaphore[2] = {NULL, NULL};
    // pcs is an array of critical sections
    CRITICAL_SECTION        *pcs[2] = {NULL, NULL};
    // pHeadQueue is an array of queue heads
    PNETSYNC_MESSAGE_QUEUE  *pHeadQueue[2] = {NULL, NULL};
    // pTailQueue is an array of queue tails
    PNETSYNC_MESSAGE_QUEUE  *pTailQueue[2] = {NULL, NULL};
    
    // pOldQueuedMessage is a pointer to the removed message
    PNETSYNC_MESSAGE_QUEUE  pOldQueuedMessage = NULL;
    // DebugAddr is the address for the debug message
    struct in_addr          DebugAddr;
    // dwWaitResult is the result of the wait on the overlapped I/O event
    DWORD                   dwWaitResult = WAIT_OBJECT_0;
    // iErrorCode is the last error code
    int                     iErrorCode = ERROR_SUCCESS;



    // Setup the arrays
    if (0 != (NETSYNC_MSGTYPE_SERVER & *dwMessageType)) {
        hSemaphore[dwSemaphores] = pNetsyncObject->hServerSemaphore;
        pcs[dwSemaphores] = &pNetsyncObject->csServerQueue;
        pHeadQueue[dwSemaphores] = &pNetsyncObject->pHeadServerQueue;
        pTailQueue[dwSemaphores] = &pNetsyncObject->pTailServerQueue;
        dwSemaphores++;
    }

    if (0 != (NETSYNC_MSGTYPE_CLIENT & *dwMessageType)) {
        hSemaphore[dwSemaphores] = pNetsyncObject->hClientSemaphore;
        pcs[dwSemaphores] = &pNetsyncObject->csClientQueue;
        pHeadQueue[dwSemaphores] = &pNetsyncObject->pHeadClientQueue;
        pTailQueue[dwSemaphores] = &pNetsyncObject->pTailClientQueue;
        dwSemaphores++;
    }

    // Wait for access to a semaphore
    dwWaitResult = WaitForMultipleObjects(dwSemaphores, hSemaphore, FALSE, dwTimeout);

    if (WAIT_TIMEOUT == dwWaitResult) {
        iErrorCode = WAIT_TIMEOUT;
    }
    else if (WAIT_FAILED == dwWaitResult) {
        iErrorCode = GetLastError();
    }
    else {
        // Get the message type
        if (0 == (dwWaitResult - WAIT_OBJECT_0)) {
            if (0 != (NETSYNC_MSGTYPE_SERVER & *dwMessageType)) {
                *dwMessageType = NETSYNC_MSGTYPE_SERVER;
            }
            else {
                *dwMessageType = NETSYNC_MSGTYPE_CLIENT;
            }
        }
        else {
            *dwMessageType = NETSYNC_MSGTYPE_CLIENT;
        }

        // Wait for access to the critical section
        EnterCriticalSection(pcs[dwWaitResult - WAIT_OBJECT_0]);

        // Get the message
        pOldQueuedMessage = *pHeadQueue[dwWaitResult - WAIT_OBJECT_0];

        DebugAddr.s_addr = pOldQueuedMessage->FromInAddr;
        DebugMessage(NETSYNC_DEBUG_QUEUE, "NetsyncDequeueMessage(): Dequeued Message 0x%016I64x 0x%016I64x From 0x%08x On Port %u\n", pOldQueuedMessage->HighSN, pOldQueuedMessage->LowSN, DebugAddr, pNetsyncObject->NetsyncPort);

        // Get the message information
        *dwMessageSize = pOldQueuedMessage->dwMessageSize;
        *FromInAddr = pOldQueuedMessage->FromInAddr;
        if (NULL != FromXnAddr) {
            CopyMemory(FromXnAddr, &pOldQueuedMessage->FromXnAddr, sizeof(*FromXnAddr));
        }
        *pMessage = (char *) ((UINT_PTR) pOldQueuedMessage->pReceivedMessage + sizeof(HANDLE));

        // Update the pointer to the head of the queue
        *pHeadQueue[dwWaitResult - WAIT_OBJECT_0] = pOldQueuedMessage->pNextQueuedMessage;

        if (NULL == *pHeadQueue[dwWaitResult - WAIT_OBJECT_0]) {
            *pTailQueue[dwWaitResult - WAIT_OBJECT_0] = NULL;
        }

        // Free the removed message
        xMemFree(pNetsyncObject->hMemObject, pOldQueuedMessage);

        // Release access to the critical section
        LeaveCriticalSection(pcs[dwWaitResult - WAIT_OBJECT_0]);
    }

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }
    else {
        dwWaitResult = WAIT_OBJECT_0;
    }

    return dwWaitResult;
}



VOID
NetsyncQueueMessage(
    IN     CRITICAL_SECTION        *pcs,
    IN     HANDLE                  hSemaphore,
    IN OUT PNETSYNC_MESSAGE_QUEUE  *pHeadQueue,
    IN OUT PNETSYNC_MESSAGE_QUEUE  *pTailQueue,
    IN     PNETSYNC_MESSAGE_QUEUE  pNewQueuedMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Adds a message from a message queue

Arguments:

  cs - Pointer to the object to synchronize access to the queue
  hSemaphore - Handle to the object to synchronize access to the queue
  pHeadQueue - Address of the pointer to the head of the queue
  pTailQueue - Address of the pointer to the tail of the queue
  pNewQueuedMessage - Pointer to the message buffer

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Wait for access to the critical section
    EnterCriticalSection(pcs);

    if (NULL != *pTailQueue) {
        (*pTailQueue)->pNextQueuedMessage = pNewQueuedMessage;
    }
    *pTailQueue = pNewQueuedMessage;

    if (NULL == *pHeadQueue) {
        *pHeadQueue = pNewQueuedMessage;
    }

    ReleaseSemaphore(hSemaphore, 1, NULL);

    // Release access to the critical section
    LeaveCriticalSection(pcs);
}



DWORD
ReceiveThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the receive logic

Arguments:

  lpv - Pointer to the NETSYNC_OBJECT

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT           pNetsyncObject = (PNETSYNC_OBJECT) lpv;

    // pClient is a pointer to the client object
    PNETSYNC_CLIENT_OBJECT    pClient;

    // ReceiveMessage is the receive message buffer
    char                      ReceiveMessage[sizeof(NETSYNC_MESSAGE_HEADER) + NETSYNC_MESSAGE_SIZE];
    // pGenericMessage is the pointer to the generic message
    PNETSYNC_GENERIC_MESSAGE  pGenericMessage = (PNETSYNC_GENERIC_MESSAGE) (ReceiveMessage + sizeof(NETSYNC_MESSAGE_HEADER));
    // pNetsyncMessage is the pointer to the netsync message header in the receive message buffer
    PNETSYNC_MESSAGE_HEADER   pNetsyncMessage = (PNETSYNC_MESSAGE_HEADER) ReceiveMessage;
    // pNewQueuedMessage is a pointer to the new queued message
    PNETSYNC_MESSAGE_QUEUE    pNewQueuedMessage;
    // dwMessageId is a copy of the message id
    DWORD                     dwMessageId;
    // DebugAddr is the address for the debug message
    struct in_addr            DebugAddr;

    // WSAOverlapped is the overlapped I/O structure
    WSAOVERLAPPED             WSAOverlapped;
    // WSABuffer is the WSABUF structures
    WSABUF                    WSABuffer;
    // fromname is the source address
    struct sockaddr_in        fromname;
    // fromnamelen is the size of the source address
    int                       fromnamelen;
    // dwBytes is the number of bytes received on the socket
    DWORD                     dwBytes;
    // dwFlags is a bitmask of MSG_ values
    DWORD                     dwFlags;
    // dwWaitResult is the result of the wait on the overlapped I/O event
    DWORD                     dwWaitResult;
    // iErrorCode is the last error code
    int                       iErrorCode;



    // Assert pNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != pNetsyncObject) && (NULL != pNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    do {
        // Setup the WSABUF structure
        ZeroMemory(ReceiveMessage, sizeof(ReceiveMessage));
        WSABuffer.len = sizeof(ReceiveMessage);
        WSABuffer.buf = ReceiveMessage;

        // Setup the flags
        dwFlags = 0;

        // Setup the address
        ZeroMemory(&fromname, sizeof(fromname));
        fromnamelen = sizeof(fromname);

        // Setup the overlapped I/O
        ZeroMemory(&WSAOverlapped, sizeof(WSAOverlapped));
        WSAOverlapped.hEvent = pNetsyncObject->hReceiveEvent;

        // Setup the result
        dwWaitResult = WAIT_FAILED;
        iErrorCode = ERROR_SUCCESS;

        // Wait for access to the critical section
        EnterCriticalSection(&pNetsyncObject->csSocket);

        // Post the WSARecv request
        if (SOCKET_ERROR == WSARecvFrom(pNetsyncObject->sSocket, &WSABuffer, 1, &dwBytes, &dwFlags, (SOCKADDR *) &fromname, &fromnamelen, &WSAOverlapped, NULL)) {
            if (WSA_IO_PENDING != WSAGetLastError()) {
                iErrorCode = WSAGetLastError();

                // Release access to the critical section
                LeaveCriticalSection(&pNetsyncObject->csSocket);

                continue;
            }

            // Release access to the critical section
            LeaveCriticalSection(&pNetsyncObject->csSocket);

            // Wait for the overlapped I/O request to complete
            dwWaitResult = WaitForSingleObject(pNetsyncObject->hReceiveEvent, INFINITE);

            // Wait for access to the critical section
            EnterCriticalSection(&pNetsyncObject->csSocket);

            if (WAIT_OBJECT_0 == dwWaitResult) {
                // Get the status of the overlapped I/O request
                if (FALSE == WSAGetOverlappedResult(pNetsyncObject->sSocket, &WSAOverlapped, &dwBytes, FALSE, &dwFlags)) {
                    iErrorCode = WSAGetLastError();

                    dwWaitResult = WAIT_FAILED;
                }
            }
            else {
                iErrorCode = GetLastError();
            }

            if (ERROR_SUCCESS != iErrorCode) {
                // Cancel the pending IO request
#ifdef _XBOX
                WSACancelOverlappedIO(pNetsyncObject->sSocket);
#else
                CancelIo((HANDLE) pNetsyncObject->sSocket);
#endif
            }
        }
        else {
            // WSARecv request completed immediately
            dwWaitResult = WAIT_OBJECT_0;

            // Reset the receive event
            ResetEvent(pNetsyncObject->hReceiveEvent);
        }

        // Release access to the critical section
        LeaveCriticalSection(&pNetsyncObject->csSocket);

        if (WAIT_FAILED == dwWaitResult) {
            DebugMessage(NETSYNC_DEBUG_RECEIVE, "ReceiveThread(): WAIT_FAILED - ec = 0x%08x\n", iErrorCode);
            continue;
        }

        // Find the client object
        pClient = FindClientObject(pNetsyncObject, fromname.sin_addr.s_addr);
        if (NULL == pClient) {
            continue;
        }

        // Set the address
        DebugAddr.s_addr = fromname.sin_addr.s_addr;

        if (NETSYNC_MSG_ACK != pNetsyncMessage->dwMessageId) {
            // Initialize the queued message
            pNewQueuedMessage = NULL;

            // Wait for access to the receive sequence number
            EnterCriticalSection(&pClient->csReceiveSN);

            if (((0 == pNetsyncMessage->LowSN) && (0 == pNetsyncMessage->HighSN)) || (pClient->LowReceiveSN < pNetsyncMessage->LowSN) || (pClient->HighReceiveSN < pNetsyncMessage->HighSN)) {
                // Allocate the memory for the queued message
                pNewQueuedMessage = (PNETSYNC_MESSAGE_QUEUE) xMemAlloc(pNetsyncObject->hMemObject, sizeof(NETSYNC_MESSAGE_QUEUE));
                if (NULL == pNewQueuedMessage) {
                    // Release access to the receive sequence number
                    LeaveCriticalSection(&pClient->csReceiveSN);

                    continue;
                }

                // Allocate the memory for the message
                pNewQueuedMessage->pReceivedMessage = (char *) xMemAlloc(pNetsyncObject->hMemObject, pNetsyncMessage->dwMessageSize + sizeof(HANDLE));
                if (NULL == pNewQueuedMessage->pReceivedMessage) {
                    // Free the queued message
                    xMemFree(pNetsyncObject->hMemObject, pNewQueuedMessage);

                    // Release access to the receive sequence number
                    LeaveCriticalSection(&pClient->csReceiveSN);

                    continue;
                }

                // Copy the queue message
                pNewQueuedMessage->dwMessageSize = pNetsyncMessage->dwMessageSize;

                pNewQueuedMessage->FromInAddr = fromname.sin_addr.s_addr;
                CopyMemory(&pNewQueuedMessage->FromXnAddr, &pNetsyncMessage->FromXnAddr, sizeof(pNewQueuedMessage->FromXnAddr));

                pNewQueuedMessage->LowSN = pNetsyncMessage->LowSN;
                pNewQueuedMessage->HighSN = pNetsyncMessage->HighSN;

                CopyMemory(pNewQueuedMessage->pReceivedMessage, &pNetsyncObject->hMemObject, sizeof(HANDLE));
                CopyMemory((char *) (UINT_PTR) pNewQueuedMessage->pReceivedMessage + sizeof(HANDLE), pGenericMessage, pNetsyncMessage->dwMessageSize);
            }

            if (NULL != pNetsyncMessage->hACKEvent) {
                // ACK the message
                dwMessageId = pNetsyncMessage->dwMessageId;
                pNetsyncMessage->dwMessageId = NETSYNC_MSG_ACK;

                if (NETSYNC_MSG_STOPRECEIVE == pGenericMessage->dwMessageId) {
                    DebugMessage(NETSYNC_DEBUG_RECEIVE, "ReceiveThread(): NETSYNC_MSG_STOPRECEIVE\n");
                    SetEvent(pNetsyncMessage->hACKEvent);
                }
                else {
                    DebugMessage(NETSYNC_DEBUG_RECEIVE, "ReceiveThread(): Send ACK Message 0x%016I64x 0x%016I64x From 0x%08x On Port %u\n", pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, DebugAddr, ntohs(fromname.sin_port));
                    sendto(pNetsyncObject->sSocket, (char *) pNetsyncMessage, sizeof(NETSYNC_MESSAGE_HEADER), 0, (SOCKADDR *) &fromname, sizeof(SOCKADDR_IN));
                }

                pNetsyncMessage->dwMessageId = dwMessageId;
            }

            if (NULL != pNewQueuedMessage) {
                // Queue the message
                DebugMessage(NETSYNC_DEBUG_RECEIVE, "ReceiveThread(): Queue Message 0x%016I64x 0x%016I64x From 0x%08x On Port %u\n", pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, DebugAddr, ntohs(fromname.sin_port));

                if (NETSYNC_MSGTYPE_SERVER == pNetsyncMessage->dwMessageId) {
                    // Server message
                    NetsyncQueueMessage(&pNetsyncObject->csServerQueue, pNetsyncObject->hServerSemaphore, &pNetsyncObject->pHeadServerQueue, &pNetsyncObject->pTailServerQueue, pNewQueuedMessage);
                }
                else {
                    // Client message
                    NetsyncQueueMessage(&pNetsyncObject->csClientQueue, pNetsyncObject->hClientSemaphore, &pNetsyncObject->pHeadClientQueue, &pNetsyncObject->pTailClientQueue, pNewQueuedMessage);
                }

                if ((0 != pNetsyncMessage->LowSN) || (0 != pNetsyncMessage->HighSN)) {
                    // Update the receive sequence number
                    pClient->LowReceiveSN = pNetsyncMessage->LowSN;
                    pClient->HighReceiveSN = pNetsyncMessage->HighSN;
                }
            }

            // Release access to the receive sequence number
            LeaveCriticalSection(&pClient->csReceiveSN);
        }
        else {
            // Wait for access to the ack sequence number
            EnterCriticalSection(&pClient->csAckSN);

            if ((pClient->LowAckSN < pNetsyncMessage->LowSN) || (pClient->HighAckSN < pNetsyncMessage->HighSN)) {
                DebugMessage(NETSYNC_DEBUG_RECEIVE, "ReceiveThread(): Receive ACK Message 0x%016I64x 0x%016I64x From 0x%08x On Port %u\n", pNetsyncMessage->HighSN, pNetsyncMessage->LowSN, DebugAddr, ntohs(fromname.sin_port));

                // ACK the message
                SetEvent(pNetsyncMessage->hACKEvent);

                // Update the ack sequence number
                pClient->LowAckSN = pNetsyncMessage->LowSN;
                pClient->HighAckSN = pNetsyncMessage->HighSN;
            }

            // Release access to the ack sequence number
            LeaveCriticalSection(&pClient->csAckSN);
        }
    } while (NETSYNC_MSG_STOPRECEIVE != pGenericMessage->dwMessageId);

    return 0;
}

} // namespace NetsyncNamespace



DWORD
WINAPI
NetsyncSendClientMessage(
    IN HANDLE  hNetsyncObject,
    IN u_long  ToAddr,
    IN DWORD   dwMessageSize,
    IN char    *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a netsync message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  ToAddr - Destination address
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT  pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    return NetsyncSendMessageToPort(hNetsyncObject, ToAddr, pNetsyncObject->NetsyncPort, TRUE, NETSYNC_MSGTYPE_CLIENT, dwMessageSize, pMessage);
}



DWORD
WINAPI
NetsyncReceiveServerMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Receives a netsync server message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  dwTimeout - Specifies the timeout interval, in milliseconds
  FromInAddr - Source ip address
  FromXnAddr - Source xnet address
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Address of the pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT  pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;
    // dwMessageType is the message type
    DWORD            dwMessageType = NETSYNC_MSGTYPE_SERVER;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    return NetsyncDequeueMessage(hNetsyncObject, dwTimeout, &dwMessageType, FromInAddr, FromXnAddr, dwMessageSize, pMessage);
}



DWORD
WINAPI
NetsyncReceiveClientMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Receives a netsync message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  dwTimeout - Specifies the timeout interval, in milliseconds
  FromInAddr - Source ip address
  FromXnAddr - Source xnet address
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Address of the pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT  pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;
    // dwMessageType is the message type
    DWORD            dwMessageType = NETSYNC_MSGTYPE_CLIENT;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    return NetsyncDequeueMessage(hNetsyncObject, dwTimeout, &dwMessageType, FromInAddr, FromXnAddr, dwMessageSize, pMessage);
}



DWORD
WINAPI
NetsyncReceiveMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT DWORD   *dwMessageType,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Receives a netsync message

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  dwTimeout - Specifies the timeout interval, in milliseconds
  dwMessageType - Specifies the type of message
  FromInAddr - Source ip address
  FromXnAddr - Source xnet address
  dwMessageSize - Size of the message buffer, in bytes
  pMessage - Address of the pointer to the message buffer

Return Value:

  DWORD:
    If the function succeeds, the return value is WAIT_OBJECT_0.
    If the function times out, the return value is WAIT_TIMEOUT.
    If the function fails, the return value is WAIT_FAILED.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT  pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    *dwMessageType = NETSYNC_MSGTYPE_SERVER | NETSYNC_MSGTYPE_CLIENT;

    return NetsyncDequeueMessage(hNetsyncObject, dwTimeout, dwMessageType, FromInAddr, FromXnAddr, dwMessageSize, pMessage);
}



BOOL
WINAPI
NetsyncFreeMessage(
    IN  char  *pMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Frees a block of memory allocated from the private heap for a message

Arguments:

  pMessage - Pointer to the message buffer

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pReceivedMessage is a pointer to the entire message
    char    *pReceivedMessage = NULL;
    // hMemObject is a handle to the memory object
    HANDLE  *hMemObject = NULL;



    // Get the message
    pReceivedMessage = (char *) ((UINT_PTR) pMessage - sizeof(HANDLE));

    // Get the memory object
    hMemObject = (HANDLE *) pReceivedMessage;

    return xMemFree(*hMemObject, pReceivedMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\client.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  client.c

Abstract:

  This module handles the netsync client logic

Author:

  Steven Kehrli (steveke) 15-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace NetsyncNamespace;

namespace NetsyncNamespace {

// g_hNetsyncClientInfoMutex is the object to synchronize access to the netsync client info
HANDLE               g_hNetsyncClientInfoMutex;
// g_NetsyncClientInfo is the netsync client info
NETSYNC_CLIENT_INFO  g_NetsyncClientInfo = { INVALID_HANDLE_VALUE, 0 };



PNETSYNC_SERVER
AddNetsyncServer(
    IN HANDLE               hMemObject,
    IN PNETSYNC_SERVER      pServers,
    IN u_long               ServerInAddr,
    IN XNADDR               *ServerXnAddr,
    IN PNETSYNC_ENUM_REPLY  pEnumReply
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Adds a netsync server to the head of a list

Arguments:

  hMemObject - Handle to the memory object
  pServers - Pointer to the head of the netsync server list
  ServerInAddr - ip address of the netsync server
  ServerXnAddr - xnet address of the netsync server
  pEnumReply - Pointer to the netsync server info

Return Value:

  PNETSYNC_SERVER: Pointer to the head of the list of netsync servers

------------------------------------------------------------------------------*/
{
    // pCurrentServer is a pointer to the current server element
    PNETSYNC_SERVER  pCurrentServer = NULL;
    // pNewServer is a pointer to the new server element
    PNETSYNC_SERVER  pNewServer = NULL;



    // Set the current server to the head of the server list
    pCurrentServer = pServers;

    while (NULL != pCurrentServer) {
        if ((0 != ServerInAddr) && (pCurrentServer->InAddr == ServerInAddr)) {
            break;
        }
        else if ((0 == ServerInAddr) && (0 == memcmp(&pCurrentServer->XnAddr, ServerXnAddr, sizeof(pCurrentServer->XnAddr)))) {
            break;
        }

        // Set the current server to the next server
        pCurrentServer = pCurrentServer->pNextServer;
    }

    if (NULL == pCurrentServer) {
        // Allocate the memory for the new server element
        pNewServer = (PNETSYNC_SERVER) xMemAlloc(hMemObject, sizeof(NETSYNC_SERVER));
        if (NULL == pNewServer) {
            goto FunctionExit;
        }
    }
    else {
        pNewServer = pCurrentServer;
    }

    // Setup the new server element
    pNewServer->InAddr = ServerInAddr;
    CopyMemory(&pNewServer->XnAddr, ServerXnAddr, sizeof(pNewServer->XnAddr));
    CopyMemory(&pNewServer->XnKid, &pEnumReply->XnKid, sizeof(pNewServer->XnKid));
    CopyMemory(&pNewServer->XnKey, &pEnumReply->XnKey, sizeof(pNewServer->XnKey));

    pNewServer->bySessionClientCount = pEnumReply->bySessionClientCount;
    pNewServer->nServerClientCount = pEnumReply->nServerClientCount;
    pNewServer->bySessionCount = pEnumReply->bySessionCount;

    if (NULL == pCurrentServer) {
        pNewServer->pNextServer = pServers;
        return pNewServer;
    }

FunctionExit:
    return pServers;
}



PNETSYNC_SERVER
FindNetsyncServer(
    IN PNETSYNC_SERVER  pServers
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds a netsync server from the server list

Arguments:

  pServers - Pointer to the head of the netsync server list

Return Value:

  PNETSYNC_SERVER: Pointer to the netsync server

------------------------------------------------------------------------------*/
{
    // pSelectedServer is a pointer to the selected server
    PNETSYNC_SERVER  pSelectedServer = NULL;
    // pCurrentServer is a pointer to the current server
    PNETSYNC_SERVER  pCurrentServer = NULL;



    // Set the selected and current server to the head of the server list
    pCurrentServer = pServers;

    while (NULL != pCurrentServer) {
        if (NULL == pSelectedServer) {
            pSelectedServer = pCurrentServer;
        }
        else {
            if (pCurrentServer->bySessionClientCount == pSelectedServer->bySessionClientCount) {
                if (pCurrentServer->nServerClientCount == pSelectedServer->nServerClientCount) {
                    if (pCurrentServer->bySessionCount < pSelectedServer->bySessionCount) {
                        // Current server has fewer sessions running
                        pSelectedServer = pCurrentServer;
                    }
                }
                else if (pCurrentServer->nServerClientCount < pSelectedServer->nServerClientCount) {
                    // Current server has fewer clients connected
                    pSelectedServer = pCurrentServer;
                }
            }
            else if (pCurrentServer->bySessionClientCount > pSelectedServer->bySessionClientCount) {
                // Current session has more clients connected
                pSelectedServer = pCurrentServer;
            }
        }

        // Set pCurrentServer to the next server in the list
        pCurrentServer = pCurrentServer->pNextServer;
    }

    return pSelectedServer;
}

} // namespace NetsyncNamespace



HANDLE
WINAPI
NetsyncCreateClient(
    IN  u_long   RemoteInAddr,
    IN  DWORD    dwSessionType,
    IN  LPVOID   pSessionType,
    OUT u_long   *ServerInAddr,
    OUT XNADDR   *ServerXnAddr,
    OUT u_short  *LowPort,
    OUT u_short  *HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates a netsync client

Arguments:

  RemoteInAddr - Specifies the ip address of the remote server
  dwSessionType - Specifies the type of netsync session
  pSessionType - Pointer to the netsync session information
  ServerInAddr - Specifies the ip address of the netsync server
  ServerXnAddr - Specifies the xnet address of the netsync server
  LowPort - Specifies the low port allocated for the session
  HighPort - Specifies the high port allocated for the session

Return Value:

  HANDLE:
    If the function succeeds, the return value is a handle to the NETSYNC_OBJECT
    If the function fails, the return value is INVALID_HANDLE_VALUE

------------------------------------------------------------------------------*/
{
    // pNetsyncConnectObject is a pointer to the NETSYNC_OBJECT for connect
    PNETSYNC_OBJECT          pNetsyncConnectObject = NULL;
    // pNetsyncObject is a pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT          pNetsyncObject = NULL;
    // hNetsyncObject is the handle to the NETSYNC_OBJECT
    HANDLE                   hNetsyncObject = INVALID_HANDLE_VALUE;
    // SessionMessage is the session message buffer
    NETSYNC_SESSION_MESSAGE  SessionMessage;
    // pCurrentServer is a pointer to the current netsync server
    PNETSYNC_SERVER          pCurrentServer = NULL;
    // pServers is a pointer to the list of netsync servers
    PNETSYNC_SERVER          pServers = NULL;
    // sin_addr is the server in_addr
    IN_ADDR                  sin_addr;

    // ToInAddr is the destination ip address
    u_long                   ToInAddr;
    // FromInAddr is the source ip address
    u_long                   FromInAddr;
    // FromXnAddr is the source xnet address
    XNADDR                   FromXnAddr;
    // dwMessageSize is the size of the receive message
    DWORD                    dwMessageSize;
    // pMessage is a pointer to the received message
    char                     *pMessage = NULL;
    // pEnumSessionReply is a pointer to the enum session reply
    PNETSYNC_ENUM_REPLY      pEnumSessionReply;
    // pConnectSessionReply is a pointer to the connect session reply
    PNETSYNC_CONNECT_REPLY   pConnectSessionReply;

    // dwEnumStartTime is the start time of enumeration
    DWORD                    dwEnumStartTime;
    // dwLoopStartTime is the start time of an enumeration loop
    DWORD                    dwLoopStartTime;
    // dwWaitTime is the wait time of an enumeration loop
    DWORD                    dwWaitTime;
    // dwCurrentTime is the current time
    DWORD                    dwCurrentTime;

    // iErrorCode is the error code
    int                      iErrorCode = ERROR_SUCCESS;



    if (((NETSYNC_SESSION_THREAD != dwSessionType) && (NETSYNC_SESSION_CALLBACK != dwSessionType)) || (NULL == pSessionType)) {
        iErrorCode = ERROR_INVALID_PARAMETER;

        goto FunctionExit;
    }

    // Create the netsync client mutex
    g_hNetsyncClientInfoMutex = CreateMutexA(NULL, FALSE, "NetsyncClientMutex");

    // Wait for the netsync client mutex
    WaitForSingleObject(g_hNetsyncClientInfoMutex, INFINITE);

    if (0 == g_NetsyncClientInfo.dwRefCount) {
        // Create the memory object
        g_NetsyncClientInfo.hMemObject = xMemCreate();
        if (INVALID_HANDLE_VALUE == g_NetsyncClientInfo.hMemObject) {
            iErrorCode = GetLastError();

            goto FunctionExit;
        }
    }

    // Create the NETSYNC_OBJECT
    pNetsyncConnectObject = CreateNetsyncObject(g_NetsyncClientInfo.hMemObject, 0, NETSYNC_PORT);
    if (NULL == pNetsyncConnectObject) {
        iErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Setup the destination addr
    ToInAddr = (0 == RemoteInAddr) ? htonl(INADDR_BROADCAST) : RemoteInAddr;

    // Setup the message buffer
    ZeroMemory(&SessionMessage, sizeof(SessionMessage));
    SessionMessage.dwMessageId = NETSYNC_MSG_ENUM;
    CopyMemory(&SessionMessage.FromObjectUUID, &pNetsyncConnectObject->ObjectUUID, sizeof(SessionMessage.FromObjectUUID));
    SessionMessage.dwSessionType = dwSessionType;

    if (NETSYNC_SESSION_THREAD == dwSessionType) {
        SessionMessage.byMinClientCount = ((PNETSYNC_TYPE_THREAD) pSessionType)->byClientCount;
        SessionMessage.byMaxClientCount = ((PNETSYNC_TYPE_THREAD) pSessionType)->byClientCount;

        SessionMessage.nMinPortCount = ((PNETSYNC_TYPE_THREAD) pSessionType)->nMinPortCount;

        // Copy the dll name
        lstrcpy(SessionMessage.szDllName_W, ((PNETSYNC_TYPE_THREAD) pSessionType)->lpszDllName_W);

        // Copy the main function name
        strcpy(SessionMessage.szMainFunction_A, ((PNETSYNC_TYPE_THREAD) pSessionType)->lpszMainFunction_A);
    }
    else {
        SessionMessage.byMinClientCount = ((PNETSYNC_TYPE_CALLBACK) pSessionType)->byMinClientCount;
        SessionMessage.byMaxClientCount = ((PNETSYNC_TYPE_CALLBACK) pSessionType)->byMaxClientCount;

        SessionMessage.nMinPortCount = ((PNETSYNC_TYPE_CALLBACK) pSessionType)->nMinPortCount;

        // Copy the dll name
        lstrcpy(SessionMessage.szDllName_W, ((PNETSYNC_TYPE_CALLBACK) pSessionType)->lpszDllName_W);

        // Copy the main, start and stop function names
        strcpy(SessionMessage.szMainFunction_A, ((PNETSYNC_TYPE_CALLBACK) pSessionType)->lpszMainFunction_A);
        strcpy(SessionMessage.szStartFunction_A, ((PNETSYNC_TYPE_CALLBACK) pSessionType)->lpszStartFunction_A);
        strcpy(SessionMessage.szStopFunction_A, ((PNETSYNC_TYPE_CALLBACK) pSessionType)->lpszStopFunction_A);
    }

    // Get the current time
    dwEnumStartTime = GetTickCount();

    do {
        // Get the current time
        dwLoopStartTime = GetTickCount();

        DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Send Enum Message\n");

        // Send the query
        NetsyncSendServerMessage(pNetsyncConnectObject, ToInAddr, 0, FALSE, sizeof(SessionMessage), (char *) &SessionMessage);

        DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Wait For Enum Reply\n");

        // Calculate the wait time
        dwCurrentTime = GetTickCount();
        dwWaitTime = ((dwCurrentTime - dwLoopStartTime) < 5000) ? 5000 - (dwCurrentTime - dwLoopStartTime) : 0;

        while (WAIT_OBJECT_0 == NetsyncReceiveServerMessage(pNetsyncConnectObject, dwWaitTime, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
            pEnumSessionReply = (PNETSYNC_ENUM_REPLY) pMessage;
            if ((NETSYNC_REPLY_ENUM == pEnumSessionReply->dwMessageId) && (0 == memcmp(&pEnumSessionReply->FromObjectUUID, &pNetsyncConnectObject->ObjectUUID, sizeof(pEnumSessionReply->FromObjectUUID)))) {
                DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Received Enum Reply\n");

                // Add the server to the server list
                pServers = AddNetsyncServer(pNetsyncConnectObject->hMemObject, pServers, (0 == pEnumSessionReply->InAddr) ? 0 : FromInAddr, &FromXnAddr, pEnumSessionReply);
            }

            // Free the message
            NetsyncFreeMessage(pMessage);
            pMessage = NULL;

            // Calculate the wait time
            dwCurrentTime = GetTickCount();
            dwWaitTime = ((dwCurrentTime - dwLoopStartTime) < 5000) ? 5000 - (dwCurrentTime - dwLoopStartTime) : 0;
        }
    } while ((NULL == pServers) && ((GetTickCount() - dwEnumStartTime) < 60000));

    // Find the netsync server
    pCurrentServer = FindNetsyncServer(pServers);
    if (NULL == pCurrentServer) {
        iErrorCode = GetLastError();

        goto FunctionExit;
    }

    if (NULL != ServerXnAddr) {
        ZeroMemory(ServerXnAddr, sizeof(*ServerXnAddr));
    }
#ifdef _XBOX
    if (0 == pCurrentServer->InAddr) {
        // Copy the xnet key id and key
        CopyMemory(&pNetsyncConnectObject->XnKid, &pCurrentServer->XnKid, sizeof(pNetsyncConnectObject->XnKid));
        CopyMemory(&pNetsyncConnectObject->XnKey, &pCurrentServer->XnKey, sizeof(pNetsyncConnectObject->XnKey));

        // Register the xnet key id and key
        XNetRegisterKey(&pCurrentServer->XnKid, &pCurrentServer->XnKey);
        pNetsyncConnectObject->bXnKey = TRUE;

        // Get the server address
        XNetXnAddrToInAddr(&pCurrentServer->XnAddr, &pCurrentServer->XnKid, &sin_addr);
        *ServerInAddr = sin_addr.s_addr;
        if (NULL != ServerXnAddr) {
            CopyMemory(ServerXnAddr, &pCurrentServer->XnAddr, sizeof(*ServerXnAddr));
        }
    }
    else {
        *ServerInAddr = pCurrentServer->InAddr;
    }
#else
    // Get the server address
    *ServerInAddr = pCurrentServer->InAddr;
#endif

    // Setup the message buffer
    SessionMessage.dwMessageId = NETSYNC_MSG_CONNECT;

    DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Send Connect Message To 0x%08x\n", *ServerInAddr);

    // Send the message
    if (WAIT_OBJECT_0 != NetsyncSendServerMessage(pNetsyncConnectObject, *ServerInAddr, 0, TRUE, sizeof(SessionMessage), (char *) &SessionMessage)) {
        iErrorCode = GetLastError();

        DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Connect Message Failed - ec: 0x%08x\n", iErrorCode);

        goto FunctionExit;
    }

    DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Wait For Connect Reply\n");

    while (WAIT_OBJECT_0 == NetsyncReceiveServerMessage(pNetsyncConnectObject, INFINITE, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
        pConnectSessionReply = (PNETSYNC_CONNECT_REPLY) pMessage;
        if ((FromInAddr == *ServerInAddr) && ((NETSYNC_MSG_STOPSESSION == pConnectSessionReply->dwMessageId) || (NETSYNC_REPLY_CONNECT == pConnectSessionReply->dwMessageId))) {
            break;
        }

        // Free the message
        NetsyncFreeMessage(pMessage);
        pMessage = NULL;
    }

    if (NULL == pMessage) {
        iErrorCode = GetLastError();

        goto FunctionExit;
    }

    if (NETSYNC_MSG_STOPSESSION == pConnectSessionReply->dwMessageId) {
        iErrorCode = ERROR_SERVER_DISABLED;

        goto FunctionExit;
    }

    DebugMessage(NETSYNC_DEBUG_CLIENT, "NetsyncCreateClient(): Received Connect Reply From 0x%08x - ec: 0x%08x\n", FromInAddr, pConnectSessionReply->dwErrorCode);

    if (ERROR_SUCCESS != pConnectSessionReply->dwErrorCode) {
        iErrorCode = pConnectSessionReply->dwErrorCode;

        goto FunctionExit;
    }

    // Create the NETSYNC_OBJECT
    pNetsyncObject = CreateNetsyncObject(g_NetsyncClientInfo.hMemObject, *ServerInAddr, pConnectSessionReply->LowPort - 1);
    if (NULL == pNetsyncObject) {
        iErrorCode = GetLastError();

        goto FunctionExit;
    }

#ifdef _XBOX
    if (0 == pCurrentServer->InAddr) {
        // Copy the xnet key id and key
        CopyMemory(&pNetsyncObject->XnKid, &pCurrentServer->XnKid, sizeof(pNetsyncObject->XnKid));
        CopyMemory(&pNetsyncObject->XnKey, &pCurrentServer->XnKey, sizeof(pNetsyncObject->XnKey));
        pNetsyncConnectObject->bXnKey = FALSE;
        pNetsyncObject->bXnKey = TRUE;
    }
#endif

    // Copy the low and high port
    if (NULL != LowPort) {
        *LowPort = pConnectSessionReply->LowPort;
    }
    if (NULL != HighPort) {
        *HighPort = pConnectSessionReply->HighPort;
    }

    // Set hNetsyncObject
    hNetsyncObject = (HANDLE) pNetsyncObject;

FunctionExit:
    if (NULL != pMessage) {
        // Free the message
        NetsyncFreeMessage(pMessage);
    }

    // Set the current server to the head of the server list
    pCurrentServer = pServers;

    while (NULL != pCurrentServer) {
        // Set the head of the server list to the next server in the list
        pServers = pServers->pNextServer;

        // Free the current server
        xMemFree(pNetsyncConnectObject->hMemObject, pCurrentServer);

        // Set the current server to the head of the server list
        pCurrentServer = pServers;
    }

    // Free the NETSYNC_OBJECT for connect, if necessary
    if (NULL != pNetsyncConnectObject) {
        CloseNetsyncObject(pNetsyncConnectObject);
    }

    if (INVALID_HANDLE_VALUE != hNetsyncObject) {
        // Increment the reference count
        g_NetsyncClientInfo.dwRefCount++;
    }
    else if (0 == g_NetsyncClientInfo.dwRefCount){
        // Close the memory object
        xMemClose(g_NetsyncClientInfo.hMemObject);
        g_NetsyncClientInfo.hMemObject = INVALID_HANDLE_VALUE;
    }

    // Release the netsync client mutex
    ReleaseMutex(g_hNetsyncClientInfoMutex);

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return hNetsyncObject;
}




VOID
WINAPI
NetsyncCloseClient(
    IN HANDLE  hNetsyncObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes the netsync client

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT          pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;
    // GenericMessage is the delete client message
    NETSYNC_GENERIC_MESSAGE  GenericMessage;



    // Assert hNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != hNetsyncObject) && (NULL != hNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    // Setup the delete client message
    GenericMessage.dwMessageId = NETSYNC_MSG_DELETECLIENT;

    // Send the delete client message
    NetsyncSendServerMessage(hNetsyncObject, 0, pNetsyncObject->NetsyncPort, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);

    // Free the NETSYNC_OBJECT
    CloseNetsyncObject(pNetsyncObject);

    // Create the netsync client mutex
    g_hNetsyncClientInfoMutex = CreateMutexA(NULL, FALSE, "NetsyncClientMutex");

    // Wait for the netsync client mutex
    WaitForSingleObject(g_hNetsyncClientInfoMutex, INFINITE);

    // Ref count must be at least 1
    ASSERT(0 < g_NetsyncClientInfo.dwRefCount);

    // Decrement the reference count
    g_NetsyncClientInfo.dwRefCount--;

    if (0 == g_NetsyncClientInfo.dwRefCount) {
        // Close the memory object
        xMemClose(g_NetsyncClientInfo.hMemObject);
        g_NetsyncClientInfo.hMemObject = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\;

SOURCES=\
    util.c     \
    server.c   \
    client.c   \
    message.c  \
    netsync.c  \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\netsyncp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  netsyncp.h

Abstract:

  This module contains the private definitions for netsync.dll

Author:

  Steven Kehrli (steveke) 15-Nov-2000

------------------------------------------------------------------------------*/

#pragma once



namespace NetsyncNamespace {

// NETSYNC_OBJECT_TYPE identifies a NETSYNC_OBJECT
#define NETSYNC_OBJECT_TYPE             0x083E546B

// NETSYNC_PORT_LOW_RANGE is the low edge of the port range
#define NETSYNC_PORT_LOW_RANGE          49152
// NETSYNC_PORT_HIGH_RANGE is the high edge of the port range
#define NETSYNC_PORT_HIGH_RANGE         65471
// NETSYNC_PORT_SECTION_SIZE is the number of ports per section in the port range
#define NETSYNC_PORT_SECTION_SIZE       64
// NETSYNC_PORT_SECTIONS is the number of port sections in the port range
#define NETSYNC_PORT_SECTIONS           255

typedef struct _NETSYNC_MESSAGE_HEADER {
    DWORD                         dwMessageId;                         // Specifies the message id
    DWORD                         dwMessageSize;                       // Specifies the message size, in bytes
    XNADDR                        FromXnAddr;                          // Specifies the sender xnet address
    ULONGLONG                     LowSN;                               // Specifies the low field of the sequence number
    ULONGLONG                     HighSN;                              // Specifies the high field of the sequence number
    HANDLE                        hACKEvent;                           // Handle to the ACK event
} NETSYNC_MESSAGE_HEADER, *PNETSYNC_MESSAGE_HEADER;

typedef struct _NETSYNC_MESSAGE_QUEUE {
    DWORD                         dwMessageSize;                       // Specifies the size of the message
    u_long                        FromInAddr;                          // Specifies the sender ip address
    XNADDR                        FromXnAddr;                          // Specifies the sender xnet address
    ULONGLONG                     LowSN;                               // Specifies the low field of the sequence number
    ULONGLONG                     HighSN;                              // Specifies the high field of the sequence number
    char                          *pReceivedMessage;                   // Pointer to the message
    struct _NETSYNC_MESSAGE_QUEUE *pNextQueuedMessage;                 // Pointer to the next message in the queue
} NETSYNC_MESSAGE_QUEUE, *PNETSYNC_MESSAGE_QUEUE;

typedef struct _NETSYNC_CLIENT_OBJECT {
    u_long                        ClientAddr;                          // Specifies the client address
    CRITICAL_SECTION              csSendSN;                            // Object to synchronize access to the next send sequence number
    ULONGLONG                     LowSendSN;                           // Specifies the low field of the send sequence number
    ULONGLONG                     HighSendSN;                          // Specifies the high field of the send sequence number
    CRITICAL_SECTION              csAckSN;                             // Object to synchronize access to the next ack sequence number
    ULONGLONG                     LowAckSN;                            // Specifies the low field of the ack sequence number
    ULONGLONG                     HighAckSN;                           // Specifies the high field of the ack sequence number
    CRITICAL_SECTION              csReceiveSN;                         // Object to synchronize access to the next receive sequence number
    ULONGLONG                     LowReceiveSN;                        // Specifies the low field of the receive sequence number
    ULONGLONG                     HighReceiveSN;                       // Specifies the high field of the receive sequence number
    struct _NETSYNC_CLIENT_OBJECT *pNextClient;                        // Pointer to the next client in the list
} NETSYNC_CLIENT_OBJECT, *PNETSYNC_CLIENT_OBJECT;

typedef struct _NETSYNC_OBJECT {
    DWORD                         dwObjectType;                        // Specifies the object type
    HANDLE                        hMemObject;                          // Specified the memory object for this object
    UUID                          ObjectUUID;                          // Specifies the unique identifier of this object
    u_long                        InAddr;                              // Specifies the ip address
    XNADDR                        XnAddr;                              // Specifies the xnet address
    XNKID                         XnKid;                               // Specifies the xnet session key id
    XNKEY                         XnKey;                               // Specifies the xnet session key
    BOOL                          bXnKey;                              // Specifies if xnet session key id and key are registered
    u_long                        ServerAddr;                          // Specifies the server address
    CRITICAL_SECTION              csClientList;                        // Object to synchronize access to the client list
    PNETSYNC_CLIENT_OBJECT        pClientList;                         // Pointer to the head of the client list
    CRITICAL_SECTION              csSocket;                            // Object to synchronize access to the socket
    SOCKET                        sSocket;                             // A socket descriptor to communicate with all clients in the session
    u_short                       NetsyncPort;                         // Specifies the port used by the socket for netsync communication
    HANDLE                        hReceiveEvent;                       // Handle to an event to signal receipt of a message
    HANDLE                        hReceiveThread;                      // Handle to the receive thread
    CRITICAL_SECTION              csServerQueue;                       // Object to synchronize access to the server message queue
    HANDLE                        hServerSemaphore;                    // Object to synchronize access to the server message queue
    PNETSYNC_MESSAGE_QUEUE        pHeadServerQueue;                    // Pointer to the head of the server message queue
    PNETSYNC_MESSAGE_QUEUE        pTailServerQueue;                    // Pointer to the tail of the server message queue
    CRITICAL_SECTION              csClientQueue;                       // Object to synchronize access to the client message queue
    HANDLE                        hClientSemaphore;                    // Object to synchronize access to the client message queue
    PNETSYNC_MESSAGE_QUEUE        pHeadClientQueue;                    // Pointer to the head of the client message queue
    PNETSYNC_MESSAGE_QUEUE        pTailClientQueue;                    // Pointer to the head of the client message queue
} NETSYNC_OBJECT, *PNETSYNC_OBJECT;

typedef struct _NETSYNC_SESSION {
    CRITICAL_SECTION              cs;                                  // Object to synchronize access to this session
    DWORD                         dwSessionStatus;                     // Specifies the session status (pending or running)
    BOOL                          bStopSession;                        // Specifies if the session thread should exit
    PNETSYNC_OBJECT               pNetsyncObject;                      // Pointer to the NETSYNC_OBJECT
    HANDLE                        hThread;                             // Handle to the session thread
    struct _NETSYNC_SESSION_INFO  *pSessionInfo;                       // Pointer to the session info
    BYTE                          byClientCount;                       // Specifies the number of clients in the session
    u_long                        *ClientInAddrs;                      // Pointer to an array of ip addresses of the clients in the session
    XNADDR                        *ClientXnAddrs;                      // Pointer to an array of xnet addresses of the clients in the session
    BYTE                          byPortSection;                       // Specifies the base port section allocated for the session
    u_short                       LowPort;                             // Specifies the low port allocated for the session
    u_short                       HighPort;                            // Specifies the high port allocated for the session
    struct _NETSYNC_SESSION       *pNextSession;                       // Pointer to the next session in the list
} NETSYNC_SESSION, *PNETSYNC_SESSION;

typedef struct _NETSYNC_SESSION_INFO {
    DWORD                         dwSessionType;                       // Specifies the session type
    BYTE                          byMinClientCount;                    // Specifies the minimum client count for a session
    BYTE                          byMaxClientCount;                    // Specifies the maximum client count for a session
    u_short                       nMinPortCount;                       // Specifies the minimum port count for a session
    LPSTR                         lpszMainFunction_A;                  // Pointer to a null-terminated string (ANSI) that specifies the main function name
    PNETSYNC_THREAD_FUNCTION      pThreadFunction;                     // Pointer to the main thread function
    PNETSYNC_CALLBACK_FUNCTION    pCallbackFunction;                   // Pointer to the main callback function
    LPSTR                         lpszStartFunction_A;                 // Pointer to a null-terminated string (ANSI) that specifies the start function name
    PNETSYNC_START_FUNCTION       pStartFunction;                      // Pointer to the start function
    LPSTR                         lpszStopFunction_A;                  // Pointer to a null-terminated string (ANSI) that specifies the stop function name
    PNETSYNC_STOP_FUNCTION        pStopFunction;                       // Pointer to the stop function
    PNETSYNC_SESSION              pActiveSession;                      // Pointer to the active session
    PNETSYNC_SESSION              pRunningSessions;                    // Pointer to the list of running sessions
    struct _NETSYNC_SESSION_INFO  *pNextSessionInfo;                   // Pointer to the next session info in the list
} NETSYNC_SESSION_INFO, *PNETSYNC_SESSION_INFO;

typedef struct _NETSYNC_SESSION_DLL {
    LPWSTR                        lpszDllName_W;                       // Pointer to a null-terminated string (UNICODE) that specifies the dll name
    HMODULE                       hModule;                             // Handle to the dll module
    PNETSYNC_SESSION_INFO         pSessionInfos;                       // Pointer to the list of session infos for this dll
    struct _NETSYNC_SESSION_DLL   *pNextSessionDll;                    // Pointer to the next session dll in the list
} NETSYNC_SESSION_DLL, *PNETSYNC_SESSION_DLL;

typedef struct _NETSYNC_SERVER_INFO {
    HANDLE                        hMemObject;                          // Specified the memory object for this object
    DWORD                         dwRefCount;                          // Specifies the reference count of this object
    PNETSYNC_OBJECT               pNetsyncObject;                      // Pointer to the NETSYNC_OBJECT
    HANDLE                        hThread;                             // Handle to the server thread
    u_short                       nServerClientCount;                  // Specifies the number of clients connected to this server
    BYTE                          bySessionCount;                      // Specifies the number of sessions running on the server
    PNETSYNC_SESSION_DLL          pSessionDlls;                        // Pointer to the list of session dlls for this server
    BOOL                          bStopServer;                         // Specifies if the server is stopping
    HANDLE                        hStopEvent;                          // Handle to the stop event
    BOOL                          bPortInUse[NETSYNC_PORT_SECTIONS];   // An array of values that specifies whether the port section is in use
    BOOL                          bPortUsed[NETSYNC_PORT_SECTIONS];    // An array of values that specifies whether the port section has been used recently
} NETSYNC_SERVER_INFO, *PNETSYNC_SERVER_INFO;

typedef struct _NETSYNC_CLIENT_INFO {
    HANDLE                        hMemObject;                          // Specified the memory object for this object
    DWORD                         dwRefCount;                          // Specifies the reference count of this object
} NETSYNC_CLIENT_INFO, *PNETSYNC_CLIENT_INFO;

typedef struct _NETSYNC_SERVER {
    u_long                        InAddr;                              // Specifies the ip address
    XNADDR                        XnAddr;                              // Specifies the xnet address
    XNKID                         XnKid;                               // Specifies the xnet session key id
    XNKEY                         XnKey;                               // Specifies the xnet session key
    BYTE                          bySessionClientCount;                // Specifies the number of clients in the session
    u_short                       nServerClientCount;                  // Specifies the number of clients connected to the server
    BYTE                          bySessionCount;                      // Specifies the number of sessions running on the server
    struct _NETSYNC_SERVER        *pNextServer;                        // Pointer to the next server in the list
} NETSYNC_SERVER, *PNETSYNC_SERVER;

typedef struct _NETSYNC_SESSION_MESSAGE {
    DWORD                         dwMessageId;                         // Specifies the message id
    UUID                          FromObjectUUID;                      // Specifies the unique identifier of the sender
    DWORD                         dwSessionType;                       // Specifies the session type
    BYTE                          byMinClientCount;                    // Specifies the minimum client count for a session
    BYTE                          byMaxClientCount;                    // Specifies the maximum client count for a session
    u_short                       nMinPortCount;                       // Specifies the minimum port count for a session
    WCHAR                         szDllName_W[128];                    // Specifies the dll name
    CHAR                          szMainFunction_A[128];               // Specifies the main function name
    CHAR                          szStartFunction_A[128];              // Specifies the start function name
    CHAR                          szStopFunction_A[128];               // Specifies the stop function name
} NETSYNC_SESSION_MESSAGE, *PNETSYNC_SESSION_MESSAGE;

typedef struct _NETSYNC_ENUM_REPLY {
    DWORD                         dwMessageId;                         // Specifies the message id
    UUID                          FromObjectUUID;                      // Specifies the unique identifier of the sender
    u_long                        InAddr;                              // Specifies the ip address
    XNKID                         XnKid;                               // Specifies the xnet session key id
    XNKEY                         XnKey;                               // Specifies the xnet session key
    BYTE                          bySessionClientCount;                // Specifies the number of clients in the session
    u_short                       nServerClientCount;                  // Specifies the number of clients connected to the server
    BYTE                          bySessionCount;                      // Specifies the number of sessions running on the server
} NETSYNC_ENUM_REPLY, *PNETSYNC_ENUM_REPLY;

typedef struct _NETSYNC_CONNECT_REPLY {
    DWORD                         dwMessageId;                         // Specifies the message id
    DWORD                         dwErrorCode;                         // Specifies the error code if the connect failed
    u_short                       LowPort;                             // Specifies the low port allocated for the session
    u_short                       HighPort;                            // Specifies the high port allocated for the session
} NETSYNC_CONNECT_REPLY, *PNETSYNC_CONNECT_REPLY;

typedef struct _NETSYNC_CLIENT_MESSAGE {
    DWORD                         dwMessageId;                         // Specifies the message id
    u_long                        FromInAddr;                          // Specifies the source ip address
    XNADDR                        FromXnAddr;                          // Specifies the source xnet address
} NETSYNC_CLIENT_MESSAGE, *PNETSYNC_CLIENT_MESSAGE;



// NETSYNC_PORT is the socket port for initial communication between client and server
#define NETSYNC_PORT                    65472

// SESSION_PENDING indicates the session is pending
#define SESSION_PENDING                 0
// SESSION_RUNNING indicates the session is running
#define SESSION_RUNNING                 1

// NETSYNC_MSG_ACK is the message id to indicate an ack
#define NETSYNC_MSG_ACK                 0x11

// NETSYNC_MSG_ENUM is the message id of a NETSYNC_SESSION_MSG struct
#define NETSYNC_MSG_ENUM                0x21
// NETSYNC_REPLY_ENUM is the message id of the NETSYNC_ENUM_REPLY struct
#define NETSYNC_REPLY_ENUM              0x22
// NETSYNC_MSG_CONNECT is the message id of a NETSYNC_SESSION_MSG struct
#define NETSYNC_MSG_CONNECT             0x23
// NETSYNC_REPLY_CONNECT is the message id of the NETSYNC_CONNECT_REPLY struct
#define NETSYNC_REPLY_CONNECT           0x24
// NETSYNC_MSG_STOPRECEIVE is the message id to indicate the receive thread is to exit
#define NETSYNC_MSG_STOPRECEIVE         0x25



// Function prototypes

typedef BOOL (WINAPI *LPDLLMAIN_PROC) (HINSTANCE, DWORD, PVOID);

PNETSYNC_OBJECT
CreateNetsyncObject(
    IN HANDLE   hMemObject,
    IN u_long   ServerAddr,
    IN u_short  NetsyncPort
);

VOID
CloseNetsyncObject(
    IN PNETSYNC_OBJECT  pNetsyncObject
);

PNETSYNC_CLIENT_OBJECT
FindClientObject(
    IN PNETSYNC_OBJECT  pNetsyncObject,
    IN u_long           ClientAddr
);

DWORD
NetsyncSendMessageToPort(
    IN HANDLE   hNetsyncObject,
    IN u_long   ToAddr,
    IN u_short  ToPort,
    IN BOOL     bGuarantee,
    IN DWORD    dwMessageId,
    IN DWORD    dwMessageSize,
    IN char     *pMessage
);

DWORD
NetsyncSendServerMessage(
    IN HANDLE   hNetsyncObject,
    IN u_long   ToAddr,
    IN u_short  ToPort,
    IN BOOL     bGuarantee,
    IN DWORD    dwMessageSize,
    IN char     *pMessage
);

DWORD
ReceiveThread(
    IN LPVOID  lpv
);

} // namespace Netsyncnamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\netsync.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  netsync.c

Abstract:

  This module synchronizes test machines

Author:

  Steven Kehrli (steveke) 15-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace NetsyncNamespace;

namespace NetsyncNamespace {

#ifndef _XBOX

u_long
GetHostAddr(
    IN HANDLE  hMemObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the host address

Arguments:

  hMemObject - Handle to the memory object

Return Value:

  u_long:
    If the function succeeds, the return value is the host address.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // hostname is the host name
    char            *hostname = NULL;
    // hostaddr is the host address
    u_long          hostaddr = 0;
    // hostnamelen is the length of the host name buffer
    int             hostnamelen = 0x10;
    // hostent is a pointer to the returned host information
    struct hostent  *hostent = NULL;
    // iResultCode is the result code from gethostname()
    int             iResultCode = 0;
    // iErrorCode is the last error code
    int             iErrorCode = ERROR_SUCCESS;



    do {
        if (NULL == hostname) {
            // Allocate the memory for the standard host name
            hostname = (char *) xMemAlloc(hMemObject, hostnamelen);
        }
        else {
            // Increase the memory for the standard host name and reallocate
            hostnamelen += 0x10;
            hostname = (char *) xMemReAlloc(hMemObject, hostname, hostnamelen);
        }

        if (NULL == hostname) {
            // Get the last error code
            iErrorCode = GetLastError();

            goto FunctionFailed0;
        }

        iResultCode = gethostname(hostname, hostnamelen);
    } while ((SOCKET_ERROR == iResultCode) && (WSAEFAULT == WSAGetLastError()));

    if (SOCKET_ERROR == iResultCode) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionFailed0;
    }

    // Get the host information for the local machine
    hostent = gethostbyname(hostname);
    if (NULL == hostent) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionFailed0;
    }

    // Check the type of the address
    if (AF_INET != hostent->h_addrtype) {
        // Set the last error code
        iErrorCode = WSAEFAULT;

        goto FunctionFailed0;
    }

    // Check the size of the address
    if (sizeof(hostaddr) != hostent->h_length) {
        // Set the last error code
        iErrorCode = WSAEFAULT;

        goto FunctionFailed0;
    }

    // Get the host address for the local machine
    CopyMemory(&hostaddr, hostent->h_addr, sizeof(hostaddr));

FunctionFailed0:
    if (NULL != hostname) {
        // Free the standard host name
        xMemFree(hMemObject, hostname);
    }

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return hostaddr;
}

#endif



PNETSYNC_OBJECT
CreateNetsyncObject(
    IN HANDLE   hMemObject,
    IN u_long   ServerAddr,
    IN u_short  NetsyncPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates a NETSYNC_OBJECT

Arguments:

  hMemObject - Handle to the memory object
  ServerAddr - Specifies the server address
  NetsyncPort - Specifies the port used by the socket for netsync communication

Return Value:

  HANDLE:
    If the function succeeds, the return value is a pointer to the NETSYNC_OBJECT.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT     pNetsyncObject = NULL;
    // bBroadcast indicates the control socket is enabled to send broadcast data
    BOOL                bBroadcast = TRUE;
#ifdef _XBOX
    // nResult is the int status code returned by a function
    INT                 nResult = 0;
#else
    // RpcStatus is the rpc status code returned by a function
    RPC_STATUS          RpcStatus = RPC_S_OK;
#endif
    // dwResult is the result of the address acquisition
    DWORD               dwResult = 0;
    // localname is the local address
    struct sockaddr_in  localname = { AF_INET, 0, 0, 0 };
    // iErrorCode is the last error code
    int                 iErrorCode = ERROR_SUCCESS;



    // Increment the net ref count
    if (FALSE == AddRefNet()) {
        iErrorCode = GetLastError();

        goto FunctionFailed0;
    }

    // Allocate the memory for the NETSYNC_OBJECT
    pNetsyncObject = (PNETSYNC_OBJECT) xMemAlloc(hMemObject, sizeof(NETSYNC_OBJECT));
    if (NULL == pNetsyncObject) {
        iErrorCode = GetLastError();

        goto FunctionFailed1;
    }

    // Set the object type
    pNetsyncObject->dwObjectType = NETSYNC_OBJECT_TYPE;

    // Set the memory object
    pNetsyncObject->hMemObject = hMemObject;

#ifdef _XBOX
    // Create the UUID
    nResult = XNetRandom((BYTE *) &pNetsyncObject->ObjectUUID, sizeof(pNetsyncObject->ObjectUUID));
    if (0 != nResult) {
        // Get the last error code
        iErrorCode = nResult;

        goto FunctionFailed2;
    }
#else
    // Create the UUID
    RpcStatus = UuidCreate(&pNetsyncObject->ObjectUUID);
    if (RPC_S_OK != RpcStatus) {
        // Set the last error code
        iErrorCode = (DWORD) RpcStatus;

        goto FunctionFailed2;
    }
#endif

#ifdef _XBOX
    // Get the xnet address
    do {
        dwResult = XNetGetTitleXnAddr(&pNetsyncObject->XnAddr);
        if (0 == dwResult) {
            Sleep(1000);
        }
    } while (0 == dwResult);

    if (0 == (XNET_GET_XNADDR_ETHERNET & dwResult)) {
        // Get the local address
        pNetsyncObject->InAddr = pNetsyncObject->XnAddr.ina.s_addr;
    }
#else
    // Get the local address
    pNetsyncObject->InAddr = GetHostAddr(pNetsyncObject->hMemObject);
#endif

    // Set the server address
    if (0 == ServerAddr) {
        pNetsyncObject->ServerAddr = pNetsyncObject->InAddr;
    }
    else {
        pNetsyncObject->ServerAddr = ServerAddr;
    }

    // Create the session socket descriptor
    pNetsyncObject->sSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == pNetsyncObject->sSocket) {
        iErrorCode = WSAGetLastError();

        goto FunctionFailed2;
    }

    // Enable the control socket to send broadcast data
    if (SOCKET_ERROR == setsockopt(pNetsyncObject->sSocket, SOL_SOCKET, SO_BROADCAST, (char *) &bBroadcast, sizeof(bBroadcast))) {
        iErrorCode = WSAGetLastError();

        goto FunctionFailed3;
    }

    // Setup the local address
    localname.sin_port = htons(NetsyncPort);

    // Bind the session socket
    if (SOCKET_ERROR == bind(pNetsyncObject->sSocket, (SOCKADDR *) &localname, sizeof(localname))) {
        iErrorCode = WSAGetLastError();

        goto FunctionFailed3;
    }

    // Copy the port
    pNetsyncObject->NetsyncPort = NetsyncPort;

    // Create the receive event
    pNetsyncObject->hReceiveEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == pNetsyncObject->hReceiveEvent) {
        iErrorCode = GetLastError();

        goto FunctionFailed3;
    }

    // Create the semaphores
    pNetsyncObject->hServerSemaphore = CreateSemaphore(NULL, 0, 0xFFFF, NULL);
    if (NULL == pNetsyncObject->hServerSemaphore) {
        iErrorCode = GetLastError();

        goto FunctionFailed4;
    }

    pNetsyncObject->hClientSemaphore = CreateSemaphore(NULL, 0, 0xFFFF, NULL);
    if (NULL == pNetsyncObject->hClientSemaphore) {
        iErrorCode = GetLastError();

        goto FunctionFailed5;
    }

    // Create the receive thread
    pNetsyncObject->hReceiveThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ReceiveThread, pNetsyncObject, CREATE_SUSPENDED, NULL);
    if (NULL == pNetsyncObject->hReceiveThread) {
        iErrorCode = GetLastError();

        goto FunctionFailed6;
    }

    // Initialize the critical sections
    InitializeCriticalSection(&pNetsyncObject->csClientList);
    InitializeCriticalSection(&pNetsyncObject->csSocket);
    InitializeCriticalSection(&pNetsyncObject->csServerQueue);
    InitializeCriticalSection(&pNetsyncObject->csClientQueue);

    // Initialize the client list
    pNetsyncObject->pClientList = NULL;

    // Initialize the message queues
    pNetsyncObject->pHeadServerQueue = NULL;
    pNetsyncObject->pTailServerQueue = NULL;
    pNetsyncObject->pHeadClientQueue = NULL;
    pNetsyncObject->pTailClientQueue = NULL;

    // Allow the receive thread to run now that the NETSYNC_OBJECT is initialized
    ResumeThread(pNetsyncObject->hReceiveThread);

    return pNetsyncObject;

FunctionFailed6:
    // Close the semaphore
    CloseHandle(pNetsyncObject->hClientSemaphore);

FunctionFailed5:
    // Close the semaphore
    CloseHandle(pNetsyncObject->hServerSemaphore);

FunctionFailed4:
    // Close the event
    CloseHandle(pNetsyncObject->hReceiveEvent);

FunctionFailed3:
    // Close the socket
    closesocket(pNetsyncObject->sSocket);

FunctionFailed2:
    // Free the NETSYNC_OBJECT
    xMemFree(hMemObject, pNetsyncObject);

FunctionFailed1:
    // Decrement the net ref count
    ReleaseNet();

FunctionFailed0:
    // Set the last error code
    SetLastError(iErrorCode);

    return NULL;
}



VOID
CloseNetsyncObject(
    IN PNETSYNC_OBJECT  pNetsyncObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Frees the NETSYNC_OBJECT

Arguments:

  pNetsyncObject - Pointer to the NETSYNC_OBJECT

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // GenericMessage is the end session message
    NETSYNC_GENERIC_MESSAGE  GenericMessage;
    // FromInAddr is the source ip address
    u_long                   FromInAddr;
    // FromXnAddr is the source xnet address
    XNADDR                   FromXnAddr;
    // dwMessageSize is the size of the receive message
    DWORD                    dwMessageSize;
    // pMessage is a pointer to a received message, either query or connect
    char                     *pMessage;
    // pNextClient is a pointer to the next client in the client list
    PNETSYNC_CLIENT_OBJECT   pNextClient = NULL;



    // Assert pNetsyncObject is valid
    ASSERT((INVALID_HANDLE_VALUE != pNetsyncObject) && (NULL != pNetsyncObject) && (NETSYNC_OBJECT_TYPE == pNetsyncObject->dwObjectType));

    // Send the shutdown complete message
    GenericMessage.dwMessageId = NETSYNC_MSG_STOPRECEIVE;
    NetsyncSendServerMessage(pNetsyncObject, htonl(INADDR_LOOPBACK), pNetsyncObject->NetsyncPort, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);

    // Wait for the receive thread to exit
    WaitForSingleObject(pNetsyncObject->hReceiveThread, INFINITE);

    // Flush the client message queue
    while (WAIT_OBJECT_0 == NetsyncReceiveClientMessage(pNetsyncObject, 0, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
        // Free the message
        NetsyncFreeMessage(pMessage);
    }

    // Flush the server message queue
    while (WAIT_OBJECT_0 == NetsyncReceiveServerMessage(pNetsyncObject, 0, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
        // Free the message
        NetsyncFreeMessage(pMessage);
    }

#ifdef _XBOX
    if (TRUE == pNetsyncObject->bXnKey) {
        // Unregister the xnet key id and key
        XNetUnregisterKey(&pNetsyncObject->XnKid);
    }
#endif

    // Wait for access to the critical section
    EnterCriticalSection(&pNetsyncObject->csSocket);

    // Close the socket
    closesocket(pNetsyncObject->sSocket);

    // Release access to the critical section
    LeaveCriticalSection(&pNetsyncObject->csSocket);

    // Wait for access to the client list
    EnterCriticalSection(&pNetsyncObject->csClientList);

    while (NULL != pNetsyncObject->pClientList) {
        // Get the next client
        pNextClient = pNetsyncObject->pClientList->pNextClient;

        // Delete the critical sections
        DeleteCriticalSection(&pNetsyncObject->pClientList->csReceiveSN);
        DeleteCriticalSection(&pNetsyncObject->pClientList->csAckSN);
        DeleteCriticalSection(&pNetsyncObject->pClientList->csSendSN);

        // Free the current client
        xMemFree(pNetsyncObject->hMemObject, pNetsyncObject->pClientList);

        // Set the next client
        pNetsyncObject->pClientList = pNextClient;
    }

    // Release access to the client list
    LeaveCriticalSection(&pNetsyncObject->csClientList);

    // Delete the critical sections
    DeleteCriticalSection(&pNetsyncObject->csClientQueue);
    DeleteCriticalSection(&pNetsyncObject->csServerQueue);
    DeleteCriticalSection(&pNetsyncObject->csSocket);
    DeleteCriticalSection(&pNetsyncObject->csClientList);

    // Close the semaphores
    CloseHandle(pNetsyncObject->hClientSemaphore);
    CloseHandle(pNetsyncObject->hServerSemaphore);

    // Close the receive event
    CloseHandle(pNetsyncObject->hReceiveEvent);

    // Free the NETSYNC_OBJECT
    xMemFree(pNetsyncObject->hMemObject, pNetsyncObject);

    // Decrement the net ref count
    ReleaseNet();
}



PNETSYNC_CLIENT_OBJECT
FindClientObject(
    IN PNETSYNC_OBJECT  pNetsyncObject,
    IN u_long           ClientAddr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the specified client or creates the client object

Arguments:

  pNetsyncObject - Pointer to the NETSYNC_OBJECT
  ClientAddr - Client address

Return Value:

  PNETSYNC_CLIENT_OBJECT:
    If the function succeeds, the return value is a pointer to the NETSYNC_CLIENT_OBJECT.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pClient is a pointer to the client
    PNETSYNC_CLIENT_OBJECT  pClient = NULL;
    // iErrorCode is the last error code
    int                     iErrorCode = ERROR_SUCCESS;



    // Wait for access to the client list
    EnterCriticalSection(&pNetsyncObject->csClientList);

    // Get the next client
    pClient = pNetsyncObject->pClientList;

    while (NULL != pClient) {
        // Check the client address
        if (ClientAddr == pClient->ClientAddr) {
            goto ExitFunc;
        }

        // Get the next client
        pClient = pClient->pNextClient;
    }

    // Allocate the memory for the NETSYNC_CLIENT_OBJECT
    pClient = (PNETSYNC_CLIENT_OBJECT) xMemAlloc(pNetsyncObject->hMemObject, sizeof(NETSYNC_CLIENT_OBJECT));
    if (NULL == pClient) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    // Set the client address
    pClient->ClientAddr = ClientAddr;

    // Initialize the critical sections
    InitializeCriticalSection(&pClient->csSendSN);
    InitializeCriticalSection(&pClient->csAckSN);
    InitializeCriticalSection(&pClient->csReceiveSN);

    // Add the client object to the client list
    pClient->pNextClient = pNetsyncObject->pClientList;
    pNetsyncObject->pClientList = pClient;

ExitFunc:
    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    // Release access to the client list
    LeaveCriticalSection(&pNetsyncObject->csClientList);

    return pClient;
}

} // namespace NetsyncNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef _XBOX

#include <ntos.h>

#include <xtl.h>

#include <xnetref.h>
#include <xtestlib.h>

#else

#include <windows.h>
#include <winsock2.h>
#include <wsockntp.h>
#include <rpc.h>

#endif

#include <stdlib.h>
#include <stdio.h>

#include <xmem.h>
#include <netsync.h>

#include "util.h"
#include "netsyncp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\server.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  server.c

Abstract:

  This module handles the netsync server logic

Author:

  Steven Kehrli (steveke) 15-Nov-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _XBOX

#pragma data_seg( ".SYNCEXP$A" )
NETSYNC_EXPORT_TABLE_DIRECTORY __netsync_export_table_directory_start[] = { NULL };

#pragma data_seg( ".SYNCEXP$Z" )
NETSYNC_EXPORT_TABLE_DIRECTORY __netsync_export_table_directory_end[] = { NULL };

#pragma data_seg()

#pragma comment(linker, "/merge:.SYNCEXP=.export")

#endif // _XBOX



using namespace NetsyncNamespace;

namespace NetsyncNamespace {

// g_hNetsyncServerInfoMutex is the object to synchronize access to the netsync server info
HANDLE               g_hNetsyncServerInfoMutex;
// g_NetsyncServerInfo is the netsync server info
NETSYNC_SERVER_INFO  g_NetsyncServerInfo = {
                                             INVALID_HANDLE_VALUE, // hMemObject
                                             0,                    // dwRefCount
                                             NULL,                 // pNetsyncObject
                                             NULL,                 // hThread
                                             0,                    // nServerClientCount
                                             0,                    // bySessionCount
                                             NULL,                 // pSessionDlls
                                             FALSE,                // bStopServer
                                             NULL,                 // hStopEvent
                                             { FALSE },            // bPortInUse[NETSYNC_PORT_SECTIONS]
                                             { FALSE },            // bPortUsed[NETSYNC_PORT_SECTIONS]
                                            };



#ifdef _XBOX

FARPROC
FindProcAddress(
    IN HMODULE  hModule,
    IN LPSTR    lpszFunction_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the address of the specified function

Arguments:

  hModule - Pointer to the module's NETSYNC_EXPORT_TABLE_DIRECTORY
  lpszFunction_A - Pointer to a null-terminated string (ANSI) that specifies the function name

Return Value:

  FARPROC:
    If the function succeeds, the return value is a pointer the function address
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pTableEntry is a pointer to a table entry
    PNETSYNC_EXPORT_TABLE_ENTRY  pTableEntry = ((PNETSYNC_EXPORT_TABLE_DIRECTORY) hModule)->pTableEntry;
    // pFunction is a pointer to the function address
    FARPROC                      pFunction = NULL;
    // dwErrorCode is the last error code
    DWORD                        dwErrorCode = ERROR_SUCCESS;



    // Search each table entry for the specified function
    while ((NULL != pTableEntry->lpszFunction_A) && (NULL != pTableEntry->pFunction)) {
        if (0 == strcmp(lpszFunction_A, pTableEntry->lpszFunction_A)) {
            pFunction = pTableEntry->pFunction;

            break;
        }

        pTableEntry++;
    }

    // Specified function was not found
    if (NULL == pFunction) {
        dwErrorCode = ERROR_PROC_NOT_FOUND;
    }

    if (ERROR_SUCCESS != dwErrorCode) {
        SetLastError(dwErrorCode);
    }

    return pFunction;
}



PNETSYNC_EXPORT_TABLE_DIRECTORY
FindModuleAddress(
    IN HANDLE  hMemObject,
    IN LPWSTR  lpszDllName_W
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the specified dll and calls its entry point

Arguments:

  hMemObject - Handle to the memory object
  lpszDllName_W - Pointer to a null-terminated string (UNICODE) that specifies the dll name

Return Value:

  PNETSYNC_EXPORT_TABLE_DIRECTORY:
    If the function succeeds, the return value is a pointer to its NETSYNC_EXPORT_TABLE_DIRECTORY.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pTableDir is a pointer to a table directory
    PNETSYNC_EXPORT_TABLE_DIRECTORY   pTableDir = __netsync_export_table_directory_start;
    // pLastTableDir is a pointer to the last table directory
    PNETSYNC_EXPORT_TABLE_DIRECTORY   pLastTableDir = __netsync_export_table_directory_end;
    // pDllMain is a pointer to the dll entry point
    LPDLLMAIN_PROC                    pDllMain = NULL;

    // lpszModules is a pointer to the list of modules
    LPWSTR                            lpszModules = NULL;
    // pDot3 is a pointer to the dot 3 portion of the dll name
    PWCHAR                            pDot3 = NULL;

    // dwErrorCode is the last error code
    DWORD                             dwErrorCode = ERROR_SUCCESS;



    // Strip ".dll" or ".lib" from lpszDllName_W
    pDot3 = wcsrchr(lpszDllName_W, L'.');
    if (NULL != pDot3) {
        if ((lstrcmpi(L".dll", pDot3)) || (lstrcmpi(L".lib", pDot3))) {
            *pDot3 = L'\0';
        }
        else {
            pDot3 = NULL;
        }
    }

    // Get the modules
    lpszModules = GetIniSection(hMemObject, L"syncsrv");

    // Find the module
    if ((NULL == lpszModules) || (FALSE == FindString(lpszModules, lpszDllName_W))) {
        dwErrorCode = ERROR_MOD_NOT_FOUND;

        goto ExitFunc;
    }

    // Search each table directory for the specified dll
    while (pTableDir < pLastTableDir) {
        if ((NULL != pTableDir->lpszModuleName) && (0 == lstrcmp(lpszDllName_W, pTableDir->lpszModuleName))) {
            pDllMain = (LPDLLMAIN_PROC) FindProcAddress((HMODULE) pTableDir, "DllMain");
            if (NULL != pDllMain) {
                pDllMain(NULL, DLL_PROCESS_ATTACH, NULL);
            }

            break;
        }

        pTableDir++;
    }

    // Specified dll was not found
    if (pTableDir == pLastTableDir) {
        dwErrorCode = ERROR_MOD_NOT_FOUND;
    }

ExitFunc:
    if (NULL != pDot3) {
        *pDot3 = L'.';
    }

    if (NULL != lpszModules) {
        xMemFree(hMemObject, lpszModules);
    }

    if (ERROR_SUCCESS != dwErrorCode) {
        SetLastError(dwErrorCode);
    }

    return (ERROR_SUCCESS == dwErrorCode) ? pTableDir : NULL;
}

#endif



PNETSYNC_SESSION_DLL
FindSessionDll(
    IN HANDLE                hMemObject,
    IN PNETSYNC_SESSION_DLL  *pSessionDlls,
    IN LPWSTR                lpszDllName_W
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the specified dll name in the list of session dlls

Arguments:

  hMemObject - Handle to the memory object
  pSessionDlls - Pointer to the head of the list of session dlls
  lpszDllName_W - Pointer to a null-terminated string (UNICODE) that specifies the dll name

Return Value:

  PNETSYNC_SESSION_DLL:
    If the dll is found, the return value is a pointer to the session dll within the list.
    If the dll is not found, the return value is NULL.

------------------------------------------------------------------------------*/
{
    // pSessionDll is a pointer to the session dll
    PNETSYNC_SESSION_DLL  pSessionDll = NULL;
    // iErrorCode is the last error code
    int                   iErrorCode = ERROR_SUCCESS;



    for (pSessionDll = *pSessionDlls; NULL != pSessionDll; pSessionDll = pSessionDll->pNextSessionDll) {
        // Check the dll name
        if (0 == lstrcmp(lpszDllName_W, pSessionDll->lpszDllName_W)) {
            break;
        }
    }

    if (NULL != pSessionDll) {
        return pSessionDll;
    }

    // Allocate the memory for the new session dll
    pSessionDll = (PNETSYNC_SESSION_DLL) xMemAlloc(hMemObject, sizeof(NETSYNC_SESSION_DLL) + (lstrlen(lpszDllName_W) + 1) * sizeof(WCHAR));
    if (NULL == pSessionDll) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Load the dll
#ifdef _XBOX
    pSessionDll->hModule = (HMODULE) FindModuleAddress(hMemObject, lpszDllName_W);
#else
    pSessionDll->hModule = LoadLibrary(lpszDllName_W);
#endif
    if (NULL == pSessionDll->hModule) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Copy the dll name
    pSessionDll->lpszDllName_W = (LPWSTR) ((UINT_PTR) pSessionDll + sizeof(NETSYNC_SESSION_DLL));
    lstrcpy(pSessionDll->lpszDllName_W, lpszDllName_W);

    // Set the pointer to the next session dll to the head of the session dll list
    pSessionDll->pNextSessionDll = *pSessionDlls;

    // Set the head of the session dll list to the new session dll
    *pSessionDlls = pSessionDll;

    return pSessionDll;

FunctionFailed:
    // Free the new session dll, if necessary
    if (NULL != pSessionDll) {
        xMemFree(hMemObject, pSessionDll);
    }

    // Set the last error code
    SetLastError(iErrorCode);

    return NULL;
}



PNETSYNC_SESSION_INFO
FindSessionInfo(
    IN HANDLE                 hMemObject,
    IN PNETSYNC_SESSION_INFO  *pSessionInfos,
    IN HMODULE                hModule,
    IN DWORD                  dwSessionType,
    IN BYTE                   byMinClientCount,
    IN BYTE                   byMaxClientCount,
    IN u_short                nMinPortCount,
    IN LPSTR                  lpszMainFunction_A,
    IN LPSTR                  lpszStartFunction_A,
    IN LPSTR                  lpszStopFunction_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the specified session info in the list of session infos

Arguments:

  hMemObject - Handle to the memory object
  pSessionInfos - Pointer to the head of the list of session infos
  hModule - Handle to the module of the dll
  dwSessionType - Specifies the session type
  byMinClientCount - Specifies the minimum client count for the session
  byMaxClientCount - Specifies the maximum client count for the session
  nMinPortCount - Specifies the minimum port count for the session
  lpszMainFunction_A - Pointer to a null-terminated string (ANSI) that specifies the main function name
  lpszStartFunction_A - Pointer to a null-terminated string (ANSI) that specifies the start function name
  lpszStopFunction_A - Pointer to a null-terminated string (ANSI) that specifies the stop function name

Return Value:

  PNETSYNC_SESSION_INFO:
    If the dll is found, the return value is a pointer to the session info within the list.
    If the dll is not found, the return value is NULL.

------------------------------------------------------------------------------*/
{
    // pSessionInfo is a pointer to the session info
    PNETSYNC_SESSION_INFO  pSessionInfo;
    // dwBufferSize is the size of the new session info buffer
    DWORD                  dwBufferSize = sizeof(NETSYNC_SESSION_INFO);
    // dwOffset is the offset into the new session info buffer
    DWORD                  dwOffset = sizeof(NETSYNC_SESSION_INFO);
    // iErrorCode is the last error code
    int                    iErrorCode = ERROR_SUCCESS;



    for (pSessionInfo = *pSessionInfos; NULL != pSessionInfo; pSessionInfo = pSessionInfo->pNextSessionInfo) {
        // Check the session type
        if (dwSessionType != pSessionInfo->dwSessionType) {
            continue;
        }

        // Check the function name
        if (0 != strcmp(lpszMainFunction_A, pSessionInfo->lpszMainFunction_A)) {
            continue;
        }

        if (NETSYNC_SESSION_CALLBACK == dwSessionType) {
            // Check the start function name
            if (0 != strcmp(lpszStartFunction_A, pSessionInfo->lpszStartFunction_A)) {
                continue;
            }

            // Check the stop function name
            if (0 != strcmp(lpszStopFunction_A, pSessionInfo->lpszStopFunction_A)) {
                continue;
            }
        }

        break;
    }

    if (NULL != pSessionInfo) {
        return pSessionInfo;
    }

    // Determine the memory required by the new session info
    dwBufferSize += (strlen(lpszMainFunction_A) + 1);

    if (NETSYNC_SESSION_CALLBACK == dwSessionType) {
        dwBufferSize += (strlen(lpszStartFunction_A) + 1);
        dwBufferSize += (strlen(lpszStopFunction_A) + 1);
    }

    // Allocate the memory for the new session info
    pSessionInfo = (PNETSYNC_SESSION_INFO) xMemAlloc(hMemObject, dwBufferSize);
    if (NULL == pSessionInfo) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Load the functions
    if (NETSYNC_SESSION_THREAD == dwSessionType) {
#ifdef _XBOX
        pSessionInfo->pThreadFunction = (PNETSYNC_THREAD_FUNCTION) FindProcAddress(hModule, lpszMainFunction_A);
#else
        pSessionInfo->pThreadFunction = (PNETSYNC_THREAD_FUNCTION) GetProcAddress(hModule, lpszMainFunction_A);
#endif
        if (NULL == pSessionInfo->pThreadFunction) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }
    else {
#ifdef _XBOX
        pSessionInfo->pCallbackFunction = (PNETSYNC_CALLBACK_FUNCTION) FindProcAddress(hModule, lpszMainFunction_A);
#else
        pSessionInfo->pCallbackFunction = (PNETSYNC_CALLBACK_FUNCTION) GetProcAddress(hModule, lpszMainFunction_A);
#endif
        if (NULL == pSessionInfo->pCallbackFunction) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }

#ifdef _XBOX
        pSessionInfo->pStartFunction = (PNETSYNC_START_FUNCTION) FindProcAddress(hModule, lpszStartFunction_A);
#else
        pSessionInfo->pStartFunction = (PNETSYNC_START_FUNCTION) GetProcAddress(hModule, lpszStartFunction_A);
#endif
        if (NULL == pSessionInfo->pStartFunction) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }

#ifdef _XBOX
        pSessionInfo->pStopFunction = (PNETSYNC_STOP_FUNCTION) FindProcAddress(hModule, lpszStopFunction_A);
#else
        pSessionInfo->pStopFunction = (PNETSYNC_STOP_FUNCTION) GetProcAddress(hModule, lpszStopFunction_A);
#endif
        if (NULL == pSessionInfo->pStopFunction) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }

    // Copy the session type
    pSessionInfo->dwSessionType = dwSessionType;

    // Copy the client info
    pSessionInfo->byMinClientCount = byMinClientCount;
    pSessionInfo->byMaxClientCount = byMaxClientCount;

    if (pSessionInfo->byMinClientCount < 1) {
        pSessionInfo->byMinClientCount = 1;
    }

    if (pSessionInfo->byMaxClientCount < pSessionInfo->byMinClientCount) {
        pSessionInfo->byMaxClientCount = pSessionInfo->byMinClientCount;
    }

    // Copy the port info
    pSessionInfo->nMinPortCount = nMinPortCount;

    // Copy the function names
    pSessionInfo->lpszMainFunction_A = (LPSTR) ((UINT_PTR) pSessionInfo + dwOffset);
    strcpy(pSessionInfo->lpszMainFunction_A, lpszMainFunction_A);
    dwOffset += (strlen(pSessionInfo->lpszMainFunction_A) + 1);

    if (NETSYNC_SESSION_CALLBACK == dwSessionType) {
        pSessionInfo->lpszStartFunction_A = (LPSTR) ((UINT_PTR) pSessionInfo + dwOffset);
        strcpy(pSessionInfo->lpszStartFunction_A, lpszStartFunction_A);
        dwOffset += (strlen(pSessionInfo->lpszStartFunction_A) + 1);

        pSessionInfo->lpszStopFunction_A = (LPSTR) ((UINT_PTR) pSessionInfo + dwOffset);
        strcpy(pSessionInfo->lpszStopFunction_A, lpszStopFunction_A);
        dwOffset += (strlen(pSessionInfo->lpszStopFunction_A) + 1);
    }

    // Set the pointer to the next session info to the head of the session info list
    pSessionInfo->pNextSessionInfo = *pSessionInfos;

    // Set the head of the session info list to the new session info
    *pSessionInfos = pSessionInfo;

    return pSessionInfo;

FunctionFailed:
    // Free the new session info, if necessary
    if (NULL != pSessionInfo) {
        xMemFree(hMemObject, pSessionInfo);
    }

    // Set the last error code
    SetLastError(iErrorCode);

    return NULL;
}



BOOL
DoesSessionInfoExist(
    IN  HANDLE                    hMemObject,
    IN  PNETSYNC_SESSION_MESSAGE  pSessionMessage,
    OUT BYTE                      *bySessionClientCount
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Checks the list of session infos for the specified session info

Arguments:

  hMemObject - Handle to the memory object
  pSessionMessage - Pointer to a session message
  bySessionCount - Pointer to the number of clients in the session

Return Value:

  BOOL:
    If the specified session is found, the return value is nonzero.
    If the specified session is not found or cannot be loaded, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pSessionDll is a pointer to the session dll
    PNETSYNC_SESSION_DLL   pSessionDll = NULL;
    // pSessionInfo is a pointer to the session info
    PNETSYNC_SESSION_INFO  pSessionInfo = NULL;
    // lpszDllName_W is a pointer to szDllName_W within the session message
    LPWSTR                 lpszDllName_W = pSessionMessage->szDllName_W;
    // lpszMainFunction_A is a pointer to szMainFunction_A within the session message
    LPSTR                  lpszMainFunction_A = pSessionMessage->szMainFunction_A;
    // lpszStartFunction_A is a pointer to szStartFunction_A within the session message
    LPSTR                  lpszStartFunction_A = NULL;
    // lpszStopFunction_A is a pointer to szStopFunction_A within the session message
    LPSTR                  lpszStopFunction_A = NULL;
    // iErrorCode is the last error code
    int                    iErrorCode = ERROR_SUCCESS;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    if (TRUE == g_NetsyncServerInfo.bStopServer) {
        // Server is stopping
        iErrorCode = ERROR_SERVER_DISABLED;

        goto ExitFunc;
    }

    if (NETSYNC_SESSION_CALLBACK == pSessionMessage->dwSessionType) {
        // Get the pointers to the function names within the session message
        lpszStartFunction_A = pSessionMessage->szStartFunction_A;
        lpszStopFunction_A = pSessionMessage->szStopFunction_A;
    }

    // Check if the session dll is loaded
    pSessionDll = FindSessionDll(hMemObject, &g_NetsyncServerInfo.pSessionDlls, lpszDllName_W);
    if (NULL == pSessionDll) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    // Check if the session info is loaded
    pSessionInfo = FindSessionInfo(hMemObject, &pSessionDll->pSessionInfos, pSessionDll->hModule, pSessionMessage->dwSessionType, pSessionMessage->byMinClientCount, pSessionMessage->byMaxClientCount, pSessionMessage->nMinPortCount, lpszMainFunction_A, lpszStartFunction_A, lpszStopFunction_A);
    if (NULL == pSessionInfo) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    // Copy the session client count
    if (NULL == pSessionInfo->pActiveSession) {
        *bySessionClientCount = 0;
    }
    else {
        *bySessionClientCount = pSessionInfo->pActiveSession->byClientCount;
    }

ExitFunc:
    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return (ERROR_SUCCESS == iErrorCode);
}



BYTE
AllocatePortSections(
    IN  u_short  nMinPortCount,
    OUT u_short  *LowPort,
    OUT u_short  *HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Marks a number of port sections as allocated.

Arguments:

  nMinPortCount - Specifies the minimum port count
  LowPort - Pointer to the low port allocated
  HighPort - Pointer to the high port allocated

Return Value:

  BYTE:
    If the port sections are allocated, the return value is the first section allocated.
    If the port sections are not allocated, the return value is 0.

------------------------------------------------------------------------------*/
{
    // byPortSection is the base port section allocated
    BYTE  byPortSection = 0;

    // bySectionCount is the section count to allocate
    BYTE  bySectionCount = 0;
    // byCurrentSection is a counter to enumerate each section in the port range
    BYTE  byCurrentSection = 0;
    // byNumSections is a counter to enumerate the block of sections
    BYTE  byNumSections = 0;



    // Determine the section count to allocate
    bySectionCount = ((nMinPortCount + 1) / NETSYNC_PORT_SECTION_SIZE) + ((0 != ((nMinPortCount + 1) % NETSYNC_PORT_SECTION_SIZE)) ? 1 : 0);

    // Find a free block of port sections
    for (byCurrentSection = 0; (byCurrentSection + bySectionCount - 1) < NETSYNC_PORT_SECTIONS; byCurrentSection++) {
        for (byNumSections = 0; byNumSections < bySectionCount; byNumSections++) {
            if ((TRUE == g_NetsyncServerInfo.bPortInUse[byCurrentSection + byNumSections]) || (TRUE == g_NetsyncServerInfo.bPortUsed[byCurrentSection + byNumSections])) {
                break;
            }
        }

        if (byNumSections == bySectionCount) {
            break;
        }
    }

    if (byCurrentSection < NETSYNC_PORT_SECTIONS) {
        // Mark the block of port sections as allocated
        for (byNumSections = 0; byNumSections < bySectionCount; byNumSections++) {
            g_NetsyncServerInfo.bPortInUse[byCurrentSection + byNumSections] = TRUE;
            g_NetsyncServerInfo.bPortUsed[byCurrentSection + byNumSections] = TRUE;
        }

        // Set the first section allocated
        byPortSection = byCurrentSection;

        // Set the low and high port allocated
        *LowPort = (byPortSection * NETSYNC_PORT_SECTION_SIZE) + NETSYNC_PORT_LOW_RANGE;
        *HighPort = ((byPortSection + bySectionCount) * NETSYNC_PORT_SECTION_SIZE) + NETSYNC_PORT_LOW_RANGE - 1;
    }

    return byPortSection;
}



VOID
ReleasePortSections(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Marks port sections as not recently used.

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // byPortSection is a counter to enumeration each port section
    BYTE  byPortSection = 0;



    // Enumerate each port section
    for (byPortSection = 0; byPortSection < NETSYNC_PORT_SECTIONS; byPortSection++) {
        if ((FALSE == g_NetsyncServerInfo.bPortInUse[byPortSection]) && (TRUE == g_NetsyncServerInfo.bPortUsed[byPortSection])) {
            g_NetsyncServerInfo.bPortUsed[byPortSection] = FALSE;
        }
    }
}



VOID
FreePortSections(
    IN BYTE     byPortSection,
    IN u_short  nMinPortCount
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Marks a number of port sections as free.

Arguments:

  byPortSection - Specifies the first section to be freed
  nMinPortCount - Specifies the minimum port count

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // bySectionCount is the section count to free
    BYTE  bySectionCount = 0;
    // byNumSections is a counter to enumerate the block of sections
    BYTE  byNumSections = 0;



    // Determine the section count to free
    bySectionCount = ((nMinPortCount + 1) / NETSYNC_PORT_SECTION_SIZE) + ((0 != ((nMinPortCount + 1) % NETSYNC_PORT_SECTION_SIZE)) ? 1 : 0);

    // Free the block of port sections
    for (byNumSections = 0; byNumSections < bySectionCount; byNumSections++) {
        g_NetsyncServerInfo.bPortInUse[byPortSection + byNumSections] = FALSE;
    }
}



VOID
RemoveSessionFromList(
    IN PNETSYNC_SESSION  pSession
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Removes the specified session from the list of sessions

Arguments:

  pSession - Pointer to the session

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pPrevSession is a pointer to the previous session in the list
    PNETSYNC_SESSION  pPrevSession = NULL;
    // pCurrentSession is a pointer to the current session in the list
    PNETSYNC_SESSION  pCurrentSession = NULL;
    // pNextSession is a pointer to the next session in the list
    PNETSYNC_SESSION  pNextSession = NULL;



    if (pSession->pSessionInfo->pActiveSession == pSession) {
        // The specified session is the active session

        // Set the active session to NULL
        pSession->pSessionInfo->pActiveSession = NULL;
    }
    else {
        // The specified session is in the list of running sessions

        // Set the current session to the head of the list of running sessions
        pCurrentSession = pSession->pSessionInfo->pRunningSessions;

        while (NULL != pCurrentSession) {
            // Set the next session to the next session
            pNextSession = pCurrentSession->pNextSession;

            if (pCurrentSession == pSession) {
                break;
            }

            // Set the previous session to the current session
            pPrevSession = pCurrentSession;

            // Set the current session to the next session
            pCurrentSession = pNextSession;
        }

        if (NULL != pCurrentSession) {
            // The specified session was found
            if (NULL == pPrevSession) {
                // The specified session is the head of the list of running sessions

                // Set the head of the list of running sessions to the next session in the list
                pSession->pSessionInfo->pRunningSessions = pNextSession;
            }
            else {
                // The specified session is in the list of running sessions

                // Set the previous session pointer to the next session to the next session
                pPrevSession->pNextSession = pNextSession;
            }
        }
    }
}



VOID
FreeSession(
    IN PNETSYNC_SESSION  pSession
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Frees the specified session from the list of sessions

Arguments:

  pSession - Pointer to the session

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE           hMemObject = NULL;
    // pNetsyncObject is handle to the netsync object
    PNETSYNC_OBJECT  pNetsyncObject = NULL;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    // Get the memory object
    hMemObject = pSession->pNetsyncObject->hMemObject;

    // Get the netsync object
    pNetsyncObject = pSession->pNetsyncObject;

    // Decrement the server client count
    g_NetsyncServerInfo.nServerClientCount -= pSession->byClientCount;

    // Decrement the session count
    g_NetsyncServerInfo.bySessionCount--;

    if ((0 == g_NetsyncServerInfo.bySessionCount) && (TRUE == g_NetsyncServerInfo.bStopServer)) {
        // Set the stop event
        SetEvent(g_NetsyncServerInfo.hStopEvent);
    }

    // Free the allocated port sections
    FreePortSections(pSession->byPortSection, pSession->pSessionInfo->nMinPortCount);

    // Free the session
    xMemFree(hMemObject, pSession);

    // Free the NETSYNC_OBJECT
    CloseNetsyncObject(pNetsyncObject);

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);
}



VOID
RemoveClientFromList(
    IN PNETSYNC_SESSION  pSession,
    IN u_long            ClientInAddr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Removes the client from the list

Arguments:

  pSession - Pointer to the specified session
  ClientInAddr - ip address of the new client

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // byCurrentClient is a counter to enumerate each client in the list
    BYTE  byCurrentClient = 0;
    // byOffset is the lookahead offset
    BYTE  byOffset = 0;



    for (byCurrentClient = 0; (byCurrentClient + byOffset) < pSession->byClientCount; byCurrentClient++) {
        // Check if the current client is the specified client
        if (ClientInAddr == pSession->ClientInAddrs[byCurrentClient]) {
            byOffset = 1;
        }

        // Copy the client address
        pSession->ClientInAddrs[byCurrentClient] = pSession->ClientInAddrs[byCurrentClient + byOffset];
        CopyMemory(&pSession->ClientXnAddrs[byCurrentClient], &pSession->ClientXnAddrs[byCurrentClient + byOffset], sizeof(pSession->ClientXnAddrs[byCurrentClient]));
    }

    // Decrement the client count
    pSession->byClientCount--;

    // Decrement the server client count
    g_NetsyncServerInfo.nServerClientCount--;

    if ((NULL == pSession->pSessionInfo->pActiveSession) || ((SESSION_RUNNING == pSession->pSessionInfo->pActiveSession->dwSessionStatus) && (pSession->byClientCount < pSession->pSessionInfo->pActiveSession->byClientCount))) {
        // This session now has fewer clients than the active session so make it the active session

        if (NULL != pSession->pSessionInfo->pActiveSession) {
            // Move the active session to the running list
            pSession->pSessionInfo->pActiveSession->pNextSession = pSession->pSessionInfo->pRunningSessions;
            pSession->pSessionInfo->pRunningSessions = pSession->pSessionInfo->pActiveSession;
            pSession->pSessionInfo->pActiveSession = NULL;
        }

        // Remove session from running list
        RemoveSessionFromList(pSession);

        // Set the active session to this session
        pSession->pSessionInfo->pActiveSession = pSession;
    }
}



VOID
RemoveClientFromSession(
    IN PNETSYNC_SESSION  pSession,
    IN u_long            ClientInAddr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Removes the client from the specified session

Arguments:

  pSession - Pointer to the specified session
  ClientInAddr - ip address of the new client

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // byCurrentClient is a counter to enumerate each client in the list
    BYTE  byCurrentClient = 0;
    // byOffset is the lookahead offset
    BYTE  byOffset = 0;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    // Enter the session critical section
    EnterCriticalSection(&pSession->cs);

    // Remove the client
    RemoveClientFromList(pSession, ClientInAddr);

    // Leave the session critical section
    LeaveCriticalSection(&pSession->cs);

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);
}



VOID
SendConnectReply(
    IN HANDLE   hNetsyncObject,
    IN DWORD    dwErrorCode,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs,
    IN u_short  LowPort,
    IN u_short  HighPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a netsync connect reply to an array of clients

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  dwErrorCode - Specifies the error code of the connect
  byClientCount - Specifies the number of clients in the array
  ClientInAddrs - Pointer to an array of client ip addresses
  LowPort - Low port allocated for the session
  HighPort - High port allocated for the session

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // ConnectSessionReply is a connect session reply
    NETSYNC_CONNECT_REPLY  ConnectSessionReply;
    // byCurrentClient is a counter to enumerate each client address in the session
    BYTE                   byCurrentClient;



    // Setup the connect session reply
    ZeroMemory(&ConnectSessionReply, sizeof(ConnectSessionReply));
    ConnectSessionReply.dwMessageId = NETSYNC_REPLY_CONNECT;
    ConnectSessionReply.dwErrorCode = dwErrorCode;
    ConnectSessionReply.LowPort = LowPort;
    ConnectSessionReply.HighPort = HighPort;

    for (byCurrentClient = 0; byCurrentClient < byClientCount; byCurrentClient++) {
        // Send the connect session reply
        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Send Connect Reply To: 0x%08x\n", ClientInAddrs[byCurrentClient]);
        NetsyncSendServerMessage(hNetsyncObject, ClientInAddrs[byCurrentClient], 0, TRUE, sizeof(ConnectSessionReply), (char *) &ConnectSessionReply);
    }
}



VOID
SendStopMessageToPort(
    IN HANDLE   hNetsyncObject,
    IN BOOL     bNetsyncPort,
    IN BYTE     byClientCount,
    IN u_long   *ClientInAddrs
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a netsync stop message to an array of clients

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  bNetsyncPort - Specifies if destination port is netsync port
  byClientCount - Specifies the number of clients in the array
  ClientInAddrs - Pointer to an array of client addresses

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT          pNetsyncObject = (PNETSYNC_OBJECT) hNetsyncObject;
    // GenericMessage is the stop session message
    NETSYNC_GENERIC_MESSAGE  GenericMessage;
    // byCurrentClient is a counter to enumerate each client address in the session
    BYTE                     byCurrentClient;



    GenericMessage.dwMessageId = NETSYNC_MSG_STOPSESSION;

    for (byCurrentClient = 0; byCurrentClient < byClientCount; byCurrentClient++) {
        // Send the stop session message
        NetsyncSendServerMessage(hNetsyncObject, ClientInAddrs[byCurrentClient], (TRUE == bNetsyncPort) ? 0 : pNetsyncObject->NetsyncPort, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);
    }
}



DWORD
SessionThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the session logic

Arguments:

  lpv - Pointer to the session

------------------------------------------------------------------------------*/
{
    // pSesssion is a pointer to the session
    PNETSYNC_SESSION       pSession = (PNETSYNC_SESSION) lpv;
    // lpContext is a pointer to a context structure
    LPVOID                 lpContext = NULL;
    // FromInAddr is the source ip address
    u_long                 FromInAddr;
    // FromXnAddr is the source xnet address
    XNADDR                 FromXnAddr;
    // dwMessageType is the type of receive message
    DWORD                  dwMessageType;
    // dwMessageSize is the size of the receive message
    DWORD                  dwMessageSize;
    // pMessage is a pointer to the received message
    char                   *pMessage;
    // bExceptionOccurred indicates if an exception occurred
    BOOL                   bExceptionOccurred = FALSE;
    // bStopSession indicates if the stop session message was received
    BOOL                   bStopSession = FALSE;
    // bCallbackFunction is the return value from pCallbackFunction
    BOOL                   bCallbackFunction = FALSE;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    // Enter the session critical section
    EnterCriticalSection(&pSession->cs);

    if (TRUE == pSession->bStopSession) {
        goto ExitSession;
    }

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    // Send the connect session replies
    SendConnectReply(pSession->pNetsyncObject, ERROR_SUCCESS, pSession->byClientCount, pSession->ClientInAddrs, pSession->LowPort, pSession->HighPort);

    if (NETSYNC_SESSION_CALLBACK == pSession->pSessionInfo->dwSessionType) {
        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread() Started\n  Session Id: 0x%08x\n  Start Function: %s\n  Main Function: %s\n  Stop Function: %s\n", pSession->hThread, pSession->pSessionInfo->lpszStartFunction_A, pSession->pSessionInfo->lpszMainFunction_A, pSession->pSessionInfo->lpszStopFunction_A);
    }
    else {
        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread() Started\n  Session Id: 0x%08x\n  Main Function: %s\n", pSession->hThread, pSession->pSessionInfo->lpszMainFunction_A);
    }

    // Check the session type
    if (NETSYNC_SESSION_CALLBACK == pSession->pSessionInfo->dwSessionType) {
        __try {
            DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Start Function - Call %s\n", pSession->pSessionInfo->lpszStartFunction_A);

            // Call the start function
            lpContext = pSession->pSessionInfo->pStartFunction((HANDLE) pSession, pSession->pNetsyncObject, pSession->byClientCount, pSession->ClientInAddrs, pSession->ClientXnAddrs, pSession->LowPort, pSession->HighPort);

            DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Start Function - %s Return\n", pSession->pSessionInfo->lpszStartFunction_A);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            // An exception occurred
            bExceptionOccurred = TRUE;

            DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Start Function - %s Caused An Exception: 0x%08x\n", pSession->pSessionInfo->lpszStartFunction_A, GetExceptionCode());
        }
    }

    // Leave the session critical section
    LeaveCriticalSection(&pSession->cs);

    // Check if an exception occurred
    if (FALSE == bExceptionOccurred) {
        // Check the session type
        if (NETSYNC_SESSION_THREAD == pSession->pSessionInfo->dwSessionType) {
            __try {
                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - Call %s\n", pSession->pSessionInfo->lpszMainFunction_A);

                // Call the main thread function
                pSession->pSessionInfo->pThreadFunction(pSession->pNetsyncObject, pSession->byClientCount, pSession->ClientInAddrs, pSession->ClientXnAddrs, pSession->LowPort, pSession->HighPort);

                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - %s Return\n", pSession->pSessionInfo->lpszMainFunction_A);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // An exception occurred
                bExceptionOccurred = TRUE;

                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - %s Caused An Exception: 0x%08x\n", pSession->pSessionInfo->lpszMainFunction_A, GetExceptionCode());
            }
        }
        else {
            do {
                if (WAIT_OBJECT_0 == NetsyncReceiveMessage(pSession->pNetsyncObject, INFINITE, &dwMessageType, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
                    if (NETSYNC_MSGTYPE_SERVER == dwMessageType) {
                        // Check if the message indicates a client joined the session
                        if ((NETSYNC_MSG_ADDCLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) || (NETSYNC_MSG_DUPLICATECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId)) {
                            FromInAddr = ((PNETSYNC_CLIENT_MESSAGE) pMessage)->FromInAddr;
                            CopyMemory(&FromXnAddr, &((PNETSYNC_CLIENT_MESSAGE) pMessage)->FromXnAddr, sizeof(FromXnAddr));

                            if (NETSYNC_MSG_ADDCLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
                                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): NETSYNC_MSG_ADDCLIENT - From: 0x%08x\n", FromInAddr);
                            }
                            else {
                                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): NETSYNC_MSG_DUPLICATECLIENT - From: 0x%08x\n", FromInAddr);
                            }

                            // Send the connect session reply
                            SendConnectReply(pSession->pNetsyncObject, ERROR_SUCCESS, 1, &FromInAddr, pSession->LowPort, pSession->HighPort);
                        }
                        // Check if the message indicates a client left the session
                        else if (NETSYNC_MSG_DELETECLIENT == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
                            // Remove the client from the session
                            RemoveClientFromSession(pSession, FromInAddr);

                            DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): NETSYNC_MSG_DELETECLIENT - From: 0x%08x\n", FromInAddr);
                        }
                        // Check if the message indicates the session has stopped
                        else if (NETSYNC_MSG_STOPSESSION == ((PNETSYNC_GENERIC_MESSAGE) pMessage)->dwMessageId) {
                            DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): NETSYNC_MSG_STOPSESSION\n");
                        }
                    }

                    __try {
                        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - Call %s\n", pSession->pSessionInfo->lpszMainFunction_A);

                        // Call the main callback function
                        bCallbackFunction = pSession->pSessionInfo->pCallbackFunction((HANDLE) pSession, pSession->pNetsyncObject, FromInAddr, &FromXnAddr, dwMessageType, dwMessageSize, pMessage, lpContext);

                        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - %s Returned %s\n", pSession->pSessionInfo->lpszMainFunction_A, (TRUE == bCallbackFunction) ? "TRUE" : "FALSE");
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        // An exception occurred
                        bExceptionOccurred = TRUE;

                        DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Main Function - %s Caused An Exception %s\n", pSession->pSessionInfo->lpszMainFunction_A, GetExceptionCode());
                    }

                    // Free the message
                    NetsyncFreeMessage(pMessage);
                }
            } while ((TRUE != bExceptionOccurred) && (FALSE != bCallbackFunction));
        }
    }

    // Check if an exception occurred
    if (FALSE == bExceptionOccurred) {
        // Check the session type
        if (NETSYNC_SESSION_CALLBACK == pSession->pSessionInfo->dwSessionType) {
            __try {
                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Stop Function - Call %s\n", pSession->pSessionInfo->lpszStopFunction_A);

                // Call the stop function
                pSession->pSessionInfo->pStopFunction((HANDLE) pSession, pSession->pNetsyncObject, lpContext);

                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Stop Function - %s Return\n", pSession->pSessionInfo->lpszStopFunction_A);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // An exception occurred
                bExceptionOccurred = TRUE;

                DebugMessage(NETSYNC_DEBUG_SESSION, "SessionThread(): Stop Function - %s Caused An Exception %s\n", pSession->pSessionInfo->lpszStopFunction_A, GetExceptionCode());
            }
        }
    }

    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    // Enter the session critical section
    EnterCriticalSection(&pSession->cs);

ExitSession:
    // Remove the session from the list of sessions
    RemoveSessionFromList(pSession);

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    // Send the stop session messages
    SendStopMessageToPort(pSession->pNetsyncObject, pSession->bStopSession, pSession->byClientCount, pSession->ClientInAddrs);

    // Leave the session critical section
    LeaveCriticalSection(&pSession->cs);

    // Free the session
    FreeSession(pSession);

    return 0;
}



PNETSYNC_SESSION
StartSession(
    IN HANDLE                 hMemObject,
    IN PNETSYNC_SESSION_INFO  pSessionInfo
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Starts the specified session in a suspended thread.  The thread is resumed when there are sufficient clients in the session.

Arguments:

  hMemObject - Handle to the memory object
  pSessionInfo - Pointer to the session info

Return Value:

  PNETSYNC_SESSION:
    If the function succeeds, the return value is a pointer to the new NETSYNC_SESSION struct.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is a pointer to the new netsync object
    PNETSYNC_OBJECT   pNetsyncObject = NULL;
    // pSession is a pointer to the new session
    PNETSYNC_SESSION  pSession = NULL;

    // byPortSection is the base port section allocated for the session
    BYTE              byPortSection = 0;
    // LowPort is the low port allocated for the session
    u_short           LowPort = 0;
    // HighPort is the high port allocated for the session
    u_short           HighPort = 0;

    // iErrorCode is the last error code
    int               iErrorCode = ERROR_SUCCESS;



    // Allocate the port range for the session
    byPortSection = AllocatePortSections(pSessionInfo->nMinPortCount, &LowPort, &HighPort);
    if (0 == byPortSection) {
        // Release port sections
        ReleasePortSections();

        // Allocate the port range for the session
        byPortSection = AllocatePortSections(pSessionInfo->nMinPortCount, &LowPort, &HighPort);
        if (0 == byPortSection) {
            iErrorCode = ERROR_NOT_ENOUGH_QUOTA;

            goto FunctionFailed;
        }
    }

    // Create the netsync object
    pNetsyncObject = CreateNetsyncObject(hMemObject, 0, LowPort);
    if (NULL == pNetsyncObject) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Allocate the memory for the new session
    pSession = (PNETSYNC_SESSION) xMemAlloc(pNetsyncObject->hMemObject, sizeof(NETSYNC_SESSION) + pSessionInfo->byMaxClientCount * (sizeof(u_long) + sizeof(XNADDR)));
    if (NULL == pSession) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Set the netsync object
    pSession->pNetsyncObject = pNetsyncObject;

#ifdef _XBOX
    // Copy the xnet key id and key
    CopyMemory(&pSession->pNetsyncObject->XnKid, &g_NetsyncServerInfo.pNetsyncObject->XnKid, sizeof(pSession->pNetsyncObject->XnKid));
    CopyMemory(&pSession->pNetsyncObject->XnKey, &g_NetsyncServerInfo.pNetsyncObject->XnKey, sizeof(pSession->pNetsyncObject->XnKey));
#endif

    // Initialize the critical section
    InitializeCriticalSection(&pSession->cs);

    // Set the pointer to the session info
    pSession->pSessionInfo = pSessionInfo;

    // Set the initial client count
    pSession->byClientCount = 0;

    // Set the initial client addresses
    pSession->ClientInAddrs = (u_long *) ((UINT_PTR) pSession + sizeof(NETSYNC_SESSION));
    pSession->ClientXnAddrs = (XNADDR *) ((UINT_PTR) pSession + sizeof(u_long) * pSessionInfo->byMaxClientCount + sizeof(NETSYNC_SESSION));

    // Set the ports
    pSession->byPortSection = byPortSection;
    pSession->LowPort = LowPort + 1;
    pSession->HighPort = HighPort;

    // Create the session thread
    pSession->hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SessionThread, pSession, CREATE_SUSPENDED, NULL);
    if (NULL == pSession->hThread) {
        iErrorCode = GetLastError();

        goto FunctionFailed;
    }

    return pSession;

FunctionFailed:
    // Free the new session, if necessary
    if (NULL != pSession) {
        xMemFree(pNetsyncObject->hMemObject, pSession);
    }

    // Close the netsync object, if necessary
    if (NULL != pNetsyncObject) {
        CloseNetsyncObject(pNetsyncObject);
    }

    // Free the port range, if necessary
    if (0 != byPortSection) {
        FreePortSections(byPortSection, pSessionInfo->nMinPortCount);
    }

    // Set the last error code
    SetLastError(iErrorCode);

    return NULL;
}



BOOL
AddClientToSession(
    IN HANDLE                    hMemObject,
    IN u_long                    ClientInAddr,
    IN XNADDR                    *ClientXnAddr,
    IN PNETSYNC_SESSION_MESSAGE  pSessionMessage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Adds the client to the specified session

Arguments:

  hNetsyncObject - Handle to the NETSYNC_OBJECT
  ClientIpAddr - ip address of the new client
  ClientXnAddr - xnet address of the new client
  pSessionMessage - Pointer to a session message

Return Value:

  BOOL:
    If the client is added, the return value is nonzero.
    If the client is not added, the return value is 0.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pSessionDll is a pointer to the session dll
    PNETSYNC_SESSION_DLL    pSessionDll = NULL;
    // pSessionInfo is a pointer to the session info
    PNETSYNC_SESSION_INFO   pSessionInfo = NULL;
    // lpszDllName_W is a pointer to szDllName_W within the session message
    LPWSTR                  lpszDllName_W = pSessionMessage->szDllName_W;
    // lpszMainFunction_A is a pointer to szMainFunction_A within the session message
    LPSTR                   lpszMainFunction_A = pSessionMessage->szMainFunction_A;
    // lpszStartFunction_A is a pointer to szStartFunction_A within the session message
    LPSTR                   lpszStartFunction_A = NULL;
    // lpszStopFunction_A is a pointer to szStopFunction_A within the session message
    LPSTR                   lpszStopFunction_A = NULL;
    // bNewClient specifies if the client is new or a duplicate
    BOOL                    bNewClient = TRUE;
    // byCurrentClient is a counter to enumerate each client in the list
    BYTE                    byCurrentClient = 0;
    // ClientMessage is the client message
    NETSYNC_CLIENT_MESSAGE  ClientMessage;
    // iErrorCode is the last error code
    int                     iErrorCode = ERROR_SUCCESS;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    if (TRUE == g_NetsyncServerInfo.bStopServer) {
        // Server is stopping
        iErrorCode = ERROR_SERVER_DISABLED;

        goto ExitFunc;
    }

    if (NETSYNC_SESSION_CALLBACK == pSessionMessage->dwSessionType) {
        // Get the pointers to the function names within the session message
        lpszStartFunction_A = pSessionMessage->szStartFunction_A;
        lpszStopFunction_A = pSessionMessage->szStopFunction_A;
    }

    // Check if the session dll is loaded
    pSessionDll = FindSessionDll(hMemObject, &g_NetsyncServerInfo.pSessionDlls, lpszDllName_W);
    if (NULL == pSessionDll) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    // Check if the session info is loaded
    pSessionInfo = FindSessionInfo(hMemObject, &pSessionDll->pSessionInfos, pSessionDll->hModule, pSessionMessage->dwSessionType, pSessionMessage->byMinClientCount, pSessionMessage->byMaxClientCount, pSessionMessage->nMinPortCount, lpszMainFunction_A, lpszStartFunction_A, lpszStopFunction_A);
    if (NULL == pSessionInfo) {
        iErrorCode = GetLastError();

        goto ExitFunc;
    }

    if (NULL == pSessionInfo->pActiveSession) {
        // Start the session
        pSessionInfo->pActiveSession = StartSession(hMemObject, pSessionInfo);
        if (NULL == pSessionInfo->pActiveSession) {
            iErrorCode = GetLastError();

            goto ExitFunc;
        }

        // Update the session status
        pSessionInfo->pActiveSession->dwSessionStatus = SESSION_PENDING;

        // Increment the session count
        g_NetsyncServerInfo.bySessionCount++;
    }

    // Enter the session critical section
    EnterCriticalSection(&pSessionInfo->pActiveSession->cs);

    // Check if the client is a duplicate
    for (byCurrentClient = 0; byCurrentClient < pSessionInfo->pActiveSession->byClientCount; byCurrentClient++) {
        // Check if the current client is the specified client
        if (ClientInAddr == pSessionInfo->pActiveSession->ClientInAddrs[byCurrentClient]) {
            break;
        }
    }
    bNewClient = (byCurrentClient == pSessionInfo->pActiveSession->byClientCount);

    if (TRUE == bNewClient) {
        DebugMessage(NETSYNC_DEBUG_SERVER, "AddClientToSession(): New Client 0x%08x\n", ClientInAddr);

        // Increment the client count
        pSessionInfo->pActiveSession->byClientCount++;

        // Copy the new client address
        pSessionInfo->pActiveSession->ClientInAddrs[pSessionInfo->pActiveSession->byClientCount - 1] = ClientInAddr;
        CopyMemory(&pSessionInfo->pActiveSession->ClientXnAddrs[pSessionInfo->pActiveSession->byClientCount - 1], ClientXnAddr, sizeof(pSessionInfo->pActiveSession->ClientXnAddrs[pSessionInfo->pActiveSession->byClientCount - 1]));

        // Increment the server client count
        g_NetsyncServerInfo.nServerClientCount++;
    }
    else {
        DebugMessage(NETSYNC_DEBUG_SERVER, "AddClientToSession(): Duplicate Client 0x%08x\n", ClientInAddr);
    }

    if (SESSION_RUNNING == pSessionInfo->pActiveSession->dwSessionStatus) {
        if (TRUE == bNewClient) {
            // Setup the add client message
            ClientMessage.dwMessageId = NETSYNC_MSG_ADDCLIENT;
        }
        else {
            // Setup the duplicate client message
            ClientMessage.dwMessageId = NETSYNC_MSG_DUPLICATECLIENT;
        }
        ClientMessage.FromInAddr = ClientInAddr;
        CopyMemory(&ClientMessage.FromXnAddr, ClientXnAddr, sizeof(ClientMessage.FromXnAddr));

        // Send the add client message
        NetsyncSendServerMessage(pSessionInfo->pActiveSession->pNetsyncObject, htonl(INADDR_LOOPBACK), pSessionInfo->pActiveSession->pNetsyncObject->NetsyncPort, TRUE, sizeof(ClientMessage), (char *) &ClientMessage);
    }
    else if (pSessionInfo->byMinClientCount == pSessionInfo->pActiveSession->byClientCount) {
        // Update the session status
        pSessionInfo->pActiveSession->dwSessionStatus = SESSION_RUNNING;

        // Resume the session thread
        ResumeThread(pSessionInfo->pActiveSession->hThread);
    }

    // Leave the session critical section
    LeaveCriticalSection(&pSessionInfo->pActiveSession->cs);

    if (pSessionInfo->byMaxClientCount == pSessionInfo->pActiveSession->byClientCount) {
        // Session has the maximum number of clients, so move the active session to the list of running sessions
        pSessionInfo->pActiveSession->pNextSession = pSessionInfo->pRunningSessions;
        pSessionInfo->pRunningSessions = pSessionInfo->pActiveSession;
        pSessionInfo->pActiveSession = NULL;
    }

ExitFunc:
    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return (ERROR_SUCCESS == iErrorCode);
}



DWORD
ServerThread(
    IN LPVOID  lpv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Thread to handle the server logic

Arguments:

  lpv - Handle of the NETSYNC_OBJECT

------------------------------------------------------------------------------*/
{
    // pNetsyncObject is the pointer to the NETSYNC_OBJECT
    PNETSYNC_OBJECT           pNetsyncObject = (PNETSYNC_OBJECT) lpv;

    // FromInAddr is the source ip address
    u_long                    FromInAddr;
    // FromXnAddr is the source xnet address
    XNADDR                    FromXnAddr;
    // dwMessageSize is the size of the receive message
    DWORD                     dwMessageSize;
    // pMessage is a pointer to a received message, either query or connect
    char                      *pMessage;
    // pGenericMessage is a pointer to a generic message
    PNETSYNC_GENERIC_MESSAGE  pGenericMessage;
    // pSessionMessage is a pointer to a session message, either query or connect
    PNETSYNC_SESSION_MESSAGE  pSessionMessage;
    // EnumSessionReply is a enum session reply
    NETSYNC_ENUM_REPLY        EnumSessionReply;
    // ConnectSessionReply is a connect session reply
    NETSYNC_CONNECT_REPLY     ConnectSessionReply;



    while (WAIT_OBJECT_0 == NetsyncReceiveServerMessage(pNetsyncObject, INFINITE, &FromInAddr, &FromXnAddr, &dwMessageSize, &pMessage)) {
        pGenericMessage = (PNETSYNC_GENERIC_MESSAGE) pMessage;
        pSessionMessage = (PNETSYNC_SESSION_MESSAGE) pMessage;

        if (NETSYNC_MSG_STOPSESSION == pGenericMessage->dwMessageId) {
            // Free the message
            NetsyncFreeMessage(pMessage);

            break;
        }

        // Handle the message
        switch (pGenericMessage->dwMessageId) {

        case NETSYNC_MSG_ENUM:
            DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_ENUM From 0x%08x\n", FromInAddr);

            ZeroMemory(&EnumSessionReply, sizeof(EnumSessionReply));

            // Check if the session info exists
            if (TRUE == DoesSessionInfoExist(pNetsyncObject->hMemObject, pSessionMessage, &EnumSessionReply.bySessionClientCount)) {
                DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_ENUM Enum Succeeded\n");

                // Wait for the netsync server mutex
                WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

                // Setup the enum session reply
                EnumSessionReply.dwMessageId = NETSYNC_REPLY_ENUM;
                CopyMemory(&EnumSessionReply.FromObjectUUID, &pSessionMessage->FromObjectUUID, sizeof(EnumSessionReply.FromObjectUUID));
                EnumSessionReply.nServerClientCount = g_NetsyncServerInfo.nServerClientCount;
                EnumSessionReply.bySessionCount = g_NetsyncServerInfo.bySessionCount;
                EnumSessionReply.InAddr = pNetsyncObject->InAddr;
                CopyMemory(&EnumSessionReply.XnKid, &pNetsyncObject->XnKid, sizeof(EnumSessionReply.XnKid));
                CopyMemory(&EnumSessionReply.XnKey, &pNetsyncObject->XnKey, sizeof(EnumSessionReply.XnKey));

                // Release the netsync server mutex
                ReleaseMutex(g_hNetsyncServerInfoMutex);

                // Send the enum session reply
                NetsyncSendServerMessage(pNetsyncObject, htonl(INADDR_BROADCAST), 0, FALSE, sizeof(EnumSessionReply), (char *) &EnumSessionReply);
            }
            else {
                DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_ENUM Enum Failed\n");
            }

            break;

        case NETSYNC_MSG_CONNECT:
            DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_CONNECT From 0x%08x\n", FromInAddr);

            // Add the client to the specified session
            if (FALSE == AddClientToSession(pNetsyncObject->hMemObject, FromInAddr, &FromXnAddr, pSessionMessage)) {
                DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_CONNECT Connect Failed - ec: 0x%08x\n", GetLastError());

                // Setup the connect session reply
                ZeroMemory(&ConnectSessionReply, sizeof(ConnectSessionReply));
                ConnectSessionReply.dwMessageId = NETSYNC_REPLY_CONNECT;
                ConnectSessionReply.dwErrorCode = GetLastError();

                // Send the connect session reply
                NetsyncSendServerMessage(pNetsyncObject, FromInAddr, 0, TRUE, sizeof(ConnectSessionReply), (char *) &ConnectSessionReply);
            }
            else {
                DebugMessage(NETSYNC_DEBUG_SERVER, "ServerThread(): NETSYNC_MSG_CONNECT Connect Succeeded\n");
            }

            break;

        default:
            break;
        }

        // Free the message
        NetsyncFreeMessage(pMessage);
    }

    return 0;
}

} // namespace NetsyncNamespace



BOOL
WINAPI
NetsyncCreateServer(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Increments the server ref count and creates a netsync server, if necessary

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero
    If the function fails, the return value is 0.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // iErrorCode is the last error code
    int  iErrorCode = ERROR_SUCCESS;



    DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCreateServer()\n");

    // Create the netsync server mutex
    g_hNetsyncServerInfoMutex = CreateMutexA(NULL, FALSE, "NetsyncServerMutex");

    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    if (0 == g_NetsyncServerInfo.dwRefCount) {
        // Create the memory object
        g_NetsyncServerInfo.hMemObject = xMemCreate();
        if (INVALID_HANDLE_VALUE == g_NetsyncServerInfo.hMemObject) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }

        // Create the NETSYNC_OBJECT
        g_NetsyncServerInfo.pNetsyncObject = CreateNetsyncObject(g_NetsyncServerInfo.hMemObject, 0, NETSYNC_PORT);
        if (NULL == g_NetsyncServerInfo.pNetsyncObject) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }

#ifdef _XBOX
        // Create and register the xnet key id and key
        XNetCreateKey(&g_NetsyncServerInfo.pNetsyncObject->XnKid, &g_NetsyncServerInfo.pNetsyncObject->XnKey);
        XNetRegisterKey(&g_NetsyncServerInfo.pNetsyncObject->XnKid, &g_NetsyncServerInfo.pNetsyncObject->XnKey);
        g_NetsyncServerInfo.pNetsyncObject->bXnKey = TRUE;
#endif

        g_NetsyncServerInfo.hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == g_NetsyncServerInfo.hStopEvent) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }

        // Create the server thread
        g_NetsyncServerInfo.hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ServerThread, g_NetsyncServerInfo.pNetsyncObject, 0, NULL);
        if (NULL == g_NetsyncServerInfo.hThread) {
            iErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }

    // Increment the reference count
    g_NetsyncServerInfo.dwRefCount++;

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    return TRUE;

FunctionFailed:
    // Close the stop event, if necessary
    if (NULL != g_NetsyncServerInfo.hStopEvent) {
        CloseHandle(g_NetsyncServerInfo.hStopEvent);
        g_NetsyncServerInfo.hStopEvent = NULL;
    }

    // Free the NETSYNC_OBJECT, if necessary
    if (NULL != g_NetsyncServerInfo.pNetsyncObject) {
        CloseNetsyncObject(g_NetsyncServerInfo.pNetsyncObject);
        g_NetsyncServerInfo.pNetsyncObject = NULL;
    }

    // Close the memory object, if necessary
    if (INVALID_HANDLE_VALUE != g_NetsyncServerInfo.hMemObject) {
        xMemClose(g_NetsyncServerInfo.hMemObject);
        g_NetsyncServerInfo.hMemObject = INVALID_HANDLE_VALUE;
    }

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);

    // Set the last error code
    SetLastError(iErrorCode);

    return FALSE;
}



VOID
WINAPI
NetsyncCloseServer(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decrements the server ref count and close the netsync server, if necessary

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pCurrentSessionDll is a pointer to the current session dll in the list
    PNETSYNC_SESSION_DLL     pCurrentSessionDll = NULL;
    // pNextSessionDll is a pointer to the next session dll in the list
    PNETSYNC_SESSION_DLL     pNextSessionDll = NULL;
    // pCurrentSessionInfo is a pointer to the current session info in the list
    PNETSYNC_SESSION_INFO    pCurrentSessionInfo = NULL;
    // pNextSessionInfo is a pointer to the next session info in the list
    PNETSYNC_SESSION_INFO    pNextSessionInfo = NULL;
    // pCurrentSession is a pointer to a session within the list
    PNETSYNC_SESSION         pCurrentSession = NULL;
    // GenericMessage is the end session message
    NETSYNC_GENERIC_MESSAGE  GenericMessage;
    // pDllMain is a pointer to the dll entry point
    LPDLLMAIN_PROC           pDllMain = NULL;



    DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer()\n");

    // Create the netsync server mutex
    g_hNetsyncServerInfoMutex = CreateMutexA(NULL, FALSE, "NetsyncServerMutex");

    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    // Ref count must be at least 1
    ASSERT(0 < g_NetsyncServerInfo.dwRefCount);

    // Decrement the reference count
    g_NetsyncServerInfo.dwRefCount--;

    if (0 == g_NetsyncServerInfo.dwRefCount) {
        DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer(): Notify Server Thread Of Pending Stop\n");

        g_NetsyncServerInfo.bStopServer = TRUE;

        // Setup the end session message
        GenericMessage.dwMessageId = NETSYNC_MSG_STOPSESSION;

        // Send the end session message
        NetsyncSendServerMessage(g_NetsyncServerInfo.pNetsyncObject, htonl(INADDR_LOOPBACK), 0, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);

        if (0 != g_NetsyncServerInfo.bySessionCount) {
            for (pCurrentSessionDll = g_NetsyncServerInfo.pSessionDlls; NULL != pCurrentSessionDll; pCurrentSessionDll = pCurrentSessionDll->pNextSessionDll) {
                for (pCurrentSessionInfo = pCurrentSessionDll->pSessionInfos; NULL != pCurrentSessionInfo; pCurrentSessionInfo = pCurrentSessionInfo->pNextSessionInfo) {
                    if (NULL != pCurrentSessionInfo->pActiveSession) {
                        // Enter the session critical section
                        EnterCriticalSection(&pCurrentSessionInfo->pActiveSession->cs);

                        if (SESSION_RUNNING == pCurrentSessionInfo->pActiveSession->dwSessionStatus) {
                            DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer(): Notify Session 0x%08x Of Stop\n", pCurrentSessionInfo->pActiveSession->hThread);

                            // Send the end session message
                            NetsyncSendServerMessage(g_NetsyncServerInfo.pNetsyncObject, htonl(INADDR_LOOPBACK), pCurrentSessionInfo->pActiveSession->pNetsyncObject->NetsyncPort, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);
                        }
                        else {
                            DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer(): Notify Session 0x%08x Of Stop\n", pCurrentSessionInfo->pActiveSession->hThread);

                            pCurrentSessionInfo->pActiveSession->bStopSession = TRUE;

                            // Resume the session thread
                            ResumeThread(pCurrentSessionInfo->pActiveSession->hThread);
                        }

                        // Leave the session critical section
                        LeaveCriticalSection(&pCurrentSessionInfo->pActiveSession->cs);
                    }

                    for (pCurrentSession = pCurrentSessionInfo->pRunningSessions; NULL != pCurrentSession; pCurrentSession = pCurrentSession->pNextSession) {
                        DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer(): Notify Session 0x%08x Of Stop\n", pCurrentSession->hThread);

                        // Send the end session message
                        NetsyncSendServerMessage(g_NetsyncServerInfo.pNetsyncObject, htonl(INADDR_LOOPBACK), pCurrentSession->pNetsyncObject->NetsyncPort, TRUE, sizeof(GenericMessage), (char *) &GenericMessage);
                    }
                }
            }

            // Release access to the netsync server mutex
            ReleaseMutex(g_hNetsyncServerInfoMutex);

            DebugMessage(NETSYNC_DEBUG_SERVER, "NetsyncCloseServer(): Wait For Session Threads To Exit\n");

            // Wait for the stop event to be signaled
            WaitForSingleObject(g_NetsyncServerInfo.hStopEvent, INFINITE);

            // Wait for the netsync server mutex
            WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);
        }

        // Wait for the server thread to exit
        WaitForSingleObject(g_NetsyncServerInfo.hThread, INFINITE);

        for (pCurrentSessionDll = g_NetsyncServerInfo.pSessionDlls; NULL != pCurrentSessionDll; pCurrentSessionDll = pNextSessionDll) {
            for (pCurrentSessionInfo = pCurrentSessionDll->pSessionInfos; NULL != pCurrentSessionInfo; pCurrentSessionInfo = pNextSessionInfo) {
                // Get the next session info in the list
                pNextSessionInfo = pCurrentSessionInfo->pNextSessionInfo;

                // Free the current session info
                xMemFree(g_NetsyncServerInfo.pNetsyncObject->hMemObject, pCurrentSessionInfo);
            }

            // Get the next session dll in the list
            pNextSessionDll = pCurrentSessionDll->pNextSessionDll;

            // Free the module
#ifdef _XBOX
            pDllMain = (LPDLLMAIN_PROC) FindProcAddress(pCurrentSessionDll->hModule, "DllMain");
            if (NULL != pDllMain) {
                pDllMain(NULL, DLL_PROCESS_DETACH, NULL);
            }
#else
            FreeLibrary(pCurrentSessionDll->hModule);
#endif

            // Free the current session dll
            xMemFree(g_NetsyncServerInfo.pNetsyncObject->hMemObject, pCurrentSessionDll);
        }

        // Reset the server info
        g_NetsyncServerInfo.pSessionDlls = NULL;
        g_NetsyncServerInfo.bStopServer = FALSE;

        // Close the stop event
        CloseHandle(g_NetsyncServerInfo.hStopEvent);
        g_NetsyncServerInfo.hStopEvent = NULL;

        // Free the NETSYNC_OBJECT
        CloseNetsyncObject(g_NetsyncServerInfo.pNetsyncObject);
        g_NetsyncServerInfo.pNetsyncObject = NULL;

        // Close the memory object
        xMemClose(g_NetsyncServerInfo.hMemObject);
        g_NetsyncServerInfo.hMemObject = INVALID_HANDLE_VALUE;
    }

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);
}



VOID
WINAPI
NetsyncRemoveClientFromSession(
    IN HANDLE  hSessionObject,
    IN HANDLE  hNetsyncObject,
    IN u_long  ClientInAddr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Removes a client from the session and sends a netsync stop message to the client

Arguments:

  hSessionObject - Handle to the session
  hNetsyncObject - Handle to the NETSYNC_OBJECT
  ClientInAddr - Address of the new client

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pCurrentSessionDll is a pointer to the current session dll in the list
    PNETSYNC_SESSION_DLL   pCurrentSessionDll = NULL;
    // pCurrentSessionInfo is a pointer to the current session info in the list
    PNETSYNC_SESSION_INFO  pCurrentSessionInfo = NULL;
    // pCurrentSession is a pointer to the current session in the list
    PNETSYNC_SESSION       pCurrentSession = NULL;
    // pSession is a pointer to the session
    PNETSYNC_SESSION       pSession = NULL;



    // Wait for the netsync server mutex
    WaitForSingleObject(g_hNetsyncServerInfoMutex, INFINITE);

    for (pCurrentSessionDll = g_NetsyncServerInfo.pSessionDlls; (NULL != pCurrentSessionDll) && (NULL == pSession); pCurrentSessionDll = pCurrentSessionDll->pNextSessionDll) {
        for (pCurrentSessionInfo = pCurrentSessionDll->pSessionInfos; (NULL != pCurrentSessionInfo) && (NULL == pSession); pCurrentSessionInfo = pCurrentSessionInfo->pNextSessionInfo) {
            if ((PNETSYNC_SESSION) hSessionObject == pCurrentSessionInfo->pActiveSession) {
                pSession = (PNETSYNC_SESSION) hSessionObject;
                break;
            }

            for (pCurrentSession = pCurrentSessionInfo->pRunningSessions; NULL != pCurrentSession; pCurrentSession = pCurrentSession->pNextSession) {
                if ((PNETSYNC_SESSION) hSessionObject == pCurrentSession) {
                    pSession = (PNETSYNC_SESSION) hSessionObject;
                    break;
                }
            }
        }
    }

    if (NULL != pSession) {
        // Enter the session critical section
        EnterCriticalSection(&pSession->cs);

        // Remove the client
        RemoveClientFromList(pSession, ClientInAddr);

        // Send the stop session messages
        SendStopMessageToPort(hNetsyncObject, FALSE, 1, &ClientInAddr);

        // Leave the session critical section
        LeaveCriticalSection(&pSession->cs);
    }

    // Release the netsync server mutex
    ReleaseMutex(g_hNetsyncServerInfoMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for netsync.dll

Author:

  Steven Kehrli (steveke) 21-Jul-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace NetsyncNamespace {

DWORD  dwNetsyncDebug = 0;  // dwNetsyncDebug specifies the level of debug messages enabled



VOID
DebugMessage(
    IN  DWORD  dwDebugLevel,
    IN  LPSTR  lpszFormatString,
    ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Displays a message in the debugger

Arguments:

  dwDebugLevel - The debug level of the message
  lpszFormatString - Pointer to a null-terminated format string for the message

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list     varg_ptr;
    // SystemTime is the current system time
    SYSTEMTIME  SystemTime;
    // szDebugBuffer is the debug message string
    CHAR        szDebugBuffer[1024];
    // dwCaptionSize is the size of the caption, in bytes
    DWORD       dwCaptionSize;



    if (0 != (dwNetsyncDebug & dwDebugLevel)) {
        // Initialize the buffer
        ZeroMemory(szDebugBuffer, sizeof(szDebugBuffer));

        // Get the current time
        GetLocalTime(&SystemTime);

        dwCaptionSize = sprintf(szDebugBuffer, "NETSYNC - Time: %02d.%02d.%04d@%02d:%02d:%02d.%03d - Thread Id: 0x%08x\n  ", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds, GetCurrentThreadId());

        va_start(varg_ptr, lpszFormatString);
        _vsnprintf(&szDebugBuffer[dwCaptionSize], sizeof(szDebugBuffer) - dwCaptionSize, lpszFormatString, varg_ptr);
        OutputDebugStringA(szDebugBuffer);
    }
}



BOOL
AddRefNet(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Increments the reference count for the net stack

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // WSAData is the details of the Winsock implementation
    WSADATA   WSAData;
    // XNetRefCount is the reference count of the net stack
    ULONG     XNetRefCount = 0;
    // dwErrorCode is the last error code
    DWORD     dwErrorCode = ERROR_SUCCESS;



#ifdef _XBOX
    // Initialize the net stack
    XNetRefCount = XNetAddRef();
    if (0 == XNetRefCount) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed0;
    }
#endif

    // Initialize Winsock
    ZeroMemory(&WSAData, sizeof(WSAData));
    dwErrorCode = WSAStartup(MAKEWORD(2, 2), &WSAData);
    if (0 != dwErrorCode) {
        goto FunctionFailed1;
    }

    return TRUE;

FunctionFailed1:
#ifdef _XBOX
    // Terminate the net stack
    XNetRelease();

FunctionFailed0:
#endif
    return FALSE;
}



VOID
ReleaseNet(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decrements the reference count for the net stack

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Terminate Winsock
    WSACleanup();

#ifdef _XBOX
    // Terminate the net stack
    XNetRelease();
#endif
}



#ifdef _XBOX

LPWSTR
GetIniSection(
    HANDLE   hMemObject,
    LPCWSTR  lpszSectionName
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the strings in the specified section of the .ini file

Arguments:

  hMemObject - handle to the memory object
  lpszSectionName - pointer to the ini section name

Return Value:

  LPWSTR:
    If the function succeeds, the return value is a pointer to the string.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

-----------------------------------------------------------------------------*/
{
    // lpszString is a pointer to the string
    LPWSTR  lpszString = NULL;
    // dwBufferSize is the size of the buffer referenced by lpszString
    DWORD   dwBufferSize = 0;
    // dwResult is the result of the GetProfileString call
    DWORD   dwResult = 0;

    // Allocate the memory for the string
    dwBufferSize = 0x10;
    lpszString = (LPWSTR) xMemAlloc(hMemObject, dwBufferSize * sizeof(WCHAR));

    while (NULL != lpszString) {
        dwResult = GetProfileSectionW(lpszSectionName, lpszString, dwBufferSize);

        if (0 == dwResult) {
            goto FunctionFailed;
        }

        if (dwResult < (dwBufferSize - 2)) {
            break;
        }

        dwBufferSize += 0x10;
        lpszString = (LPWSTR) xMemReAlloc(hMemObject, lpszString, dwBufferSize * sizeof(WCHAR));
    }

    if (NULL == lpszString) {
        goto FunctionFailed;
    }

    return lpszString;

FunctionFailed:
    if (NULL != lpszString) {
        xMemFree(hMemObject, lpszString);
    }

    return NULL;
}



BOOL
FindString(
    LPWSTR  lpszString,
    LPWSTR  lpszSubString
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Search a list of strings for a specified string

Arguments:

  lpszString - pointer to the list of strings
  lpszSubString - pointer to the specified string

Return Value:

  BOOL:
    If the specified string is found, the return value is non-zero.
    If the specified string is not found, the return value is zero.

-----------------------------------------------------------------------------*/
{
    // lpszCurString is a pointer to the current string
    LPWSTR  lpszCurString = lpszString;

    while ('\0' != *lpszCurString) {
        if (0 == _wcsicmp(lpszCurString, lpszSubString)) {
            break;
        }

        lpszCurString += (wcslen(lpszCurString) + 1);
    }

    return ('\0' != *lpszCurString);
}

#endif

} // namespace NetsyncNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\netsync\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 21-Jul-2000

------------------------------------------------------------------------------*/

#pragma once



namespace NetsyncNamespace {

// Function prototypes

VOID
DebugMessage(
    IN  DWORD  dwDebugLevel,
    IN  LPSTR  lpszFormatString,
    ...
);

#define NETSYNC_DEBUG_SEND     0x00000001
#define NETSYNC_DEBUG_RECEIVE  0x00000002
#define NETSYNC_DEBUG_QUEUE    0x00000004
#define NETSYNC_DEBUG_CLIENT   0x00000008
#define NETSYNC_DEBUG_SERVER   0x00000010
#define NETSYNC_DEBUG_SESSION  0x00000020

#define NETSYNC_DEBUG_ALL      0xFFFFFFFF

BOOL
AddRefNet(
);

VOID
ReleaseNet(
);

LPWSTR
GetIniSection(
    HANDLE   hMemObject,
    LPCWSTR  lpszSectionName
);

BOOL
FindString(
    LPWSTR  lpszString,
    LPWSTR  lpszSubString
);

} // namespace NetsyncNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\bitmap.c ===
#include "bitmap.h"
#include "defs.h"
#include "file.h"
#include "mem.h"


// Initializes the compression bitmap
int InitBitmap(LPIMGBITMAP lpBitmap, DWORD dwSize, FILEHANDLE hFile, DWORD dwFileOffset, BOOL fExisting)
{
    DWORD                   dwFilePos;
    int                     nRet;
    DWORD                   dw;
    
    // Fill the structure
    lpBitmap->dwSize = dwSize;
    lpBitmap->dwPage = BITMAP_PAGE_ERROR;
    lpBitmap->fDirty = FALSE;
    lpBitmap->hFile = hFile;
    lpBitmap->dwFileOffset = dwFileOffset;
    
    // Allocate memory for the bit buffer
    if(!(lpBitmap->lpbBuffer = MemAlloc(CBSEC)))
    {
        return ERROR_OOM;
    }
    
    // If this is a new bitmap, write 0's out to the file
    if(!fExisting)
    {
        MemSet(lpBitmap->lpbBuffer, 0, CBSEC);
        
        // Save the current file position
        dwFilePos = FileGetPos(hFile);
    
        // Seek to the beginning of the bitmap
        FileSetPos(hFile, dwFileOffset * CBSEC, SEEK_SET);
    
        // Write 0's to the file
        for(dw = 0; dw < dwSize; dw++)
        {
            if(FileWrite(hFile, lpBitmap->lpbBuffer, CBSEC) != CBSEC)
            {
                return ERROR_FILEWRITE;
            }
        }

        // Restore the file position
        FileSetPos(hFile, dwFilePos, SEEK_SET);
    }
    
    // Load the first bitmap page
    if(nRet = ClusterInMemory(lpBitmap, 0))
    {
        return nRet;
    }
    
    // Return success
    return ERROR_NONE;
}


// Reads the necessary bitmap page into memory
int ClusterInMemory(LPIMGBITMAP lpBitmap, DWORD dwCluster)
{
    DWORD                   dwPageNeeded;
    DWORD                   dwFilePos;
    int                     nRet;
    
    dwPageNeeded = dwCluster / 8 / CBSEC;
    
    // Is this cluster already in memory?
    if(dwPageNeeded == lpBitmap->dwPage)
    {
        return ERROR_NONE;
    }
    
    // Flush the buffer
    if(nRet = FlushBitmapBuffer(lpBitmap))
    {
        return nRet;
    }

    // Save the current file position
    dwFilePos = FileGetPos(lpBitmap->hFile);
    
    // Seek to the beginning of the bitmap page
    FileSetPos(lpBitmap->hFile, (lpBitmap->dwFileOffset + dwPageNeeded) * CBSEC, SEEK_SET);
        
    // Read in the bitmap pages
    if(FileRead(lpBitmap->hFile, lpBitmap->lpbBuffer, CBSEC) != CBSEC)
    {
    	return ERROR_FILEREAD;
    }
        
    // Restore the file position
    FileSetPos(lpBitmap->hFile, dwFilePos, SEEK_SET);
    
    // Update the bitmap info
    lpBitmap->dwPage = dwPageNeeded;
    lpBitmap->fDirty = FALSE;
    
    // Return success
    return ERROR_NONE;
}


// Flushes the bitmap's dirty buffer
int FlushBitmapBuffer(LPIMGBITMAP lpBitmap)
{
    DWORD                   dwFilePos;
    
    // If there's nothing dirty, return immediately
    if(!lpBitmap->fDirty)
    {
        return ERROR_NONE;
    }
    
    // Make sure no-one's being stupid
    if(lpBitmap->dwPage == BITMAP_PAGE_ERROR)
    {
        return ERROR_FILEWRITE;
    }
    
    // Save the current file position
    dwFilePos = FileGetPos(lpBitmap->hFile);
    
    // Seek to the correct point in the bitmap
    FileSetPos(lpBitmap->hFile, (lpBitmap->dwFileOffset + lpBitmap->dwPage) * CBSEC, SEEK_SET);
    
    // Write the buffer
    if(FileWrite(lpBitmap->hFile, lpBitmap->lpbBuffer, CBSEC) != CBSEC)
    {
        return ERROR_FILEWRITE;
    }
    
    // Restore the file position
    FileSetPos(lpBitmap->hFile, dwFilePos, SEEK_SET);
    
    // Set the bitmap's dirty flag to false
    lpBitmap->fDirty = FALSE;
    
    // Return success
    return ERROR_NONE;
}


// Retrieves a bitmap bit
int GetBitmapBit(LPIMGBITMAP lpBitmap, DWORD dwCluster, LPBOOL lpfSet)
{
    int                     nRet;
    
    // Get the correct page
    if(nRet = ClusterInMemory(lpBitmap, dwCluster))
    {
        return nRet;
    }
        
    dwCluster -= lpBitmap->dwPage * CBSEC * 8;
    
    // Get the cluster's value
    if(lpfSet)
    {
        *lpfSet = *(lpBitmap->lpbBuffer + (dwCluster / 8)) & (1 << (dwCluster % 8));
    }
    
    // Return success
    return ERROR_NONE;
}


// Sets a bitmap bit
int SetBitmapBit(LPIMGBITMAP lpBitmap, DWORD dwCluster)
{
    int                     nRet;
    
    // Get the correct page
    if(nRet = ClusterInMemory(lpBitmap, dwCluster))
    {
        return nRet;
    }
        
    dwCluster -= lpBitmap->dwPage * CBSEC * 8;
    
    // Set the cluster's value
    *(lpBitmap->lpbBuffer + (dwCluster / 8)) |= 1 << (dwCluster % 8);
    
    // Set the bitmap's buffer to dirty
    lpBitmap->fDirty = TRUE;
    
    // Return success
    return ERROR_NONE;
}


int DiscardBitmap(LPIMGBITMAP lpBitmap)
{
    int                     nRet;
    
    // Flush the bitmap's buffer
    if(nRet = FlushBitmapBuffer(lpBitmap))
    {
        return nRet;
    }
    
    // Free memory
    MemFree(lpBitmap->lpbBuffer);
    lpBitmap->lpbBuffer = NULL;
    
    // Return success
    return ERROR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\bootsec.c ===
#include "bootsec.h"
#include "defs.h"
#include "diskutil.h"
#include "image.h"
#include "mem.h"


BOOL GetFileSystemType(BYTE bDrive, LPSTR lpszType)
{
    BGBOOTSECTOR            bs;
    BYTE                    abType[8];
    int                     nSize;
    
    // Read the boot sector
    if(!ReadSector(bDrive, &bs, 0, 1))
    {
        return FALSE;
    }
    
    MemCopy(abType, GetFSType(&bs), sizeof(abType));
    
    // Ignore any trailing spaces
    nSize = sizeof(abType);
    
    while(nSize && abType[nSize - 1] == ' ')
    {
        nSize--;
    }
    
    // Copy the string
    MemCopy(lpszType, abType, nSize);
    
    // Null-terminate the string
    *(lpszType + nSize) = 0;
    
    // Return success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\compress.h ===
#ifndef _INC_COMPRESS
#define _INC_COMPRESS

#include "defs.h"

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL CompressData(LPVOID, WORD, LPVOID, LPWORD);
extern BOOL UncompressData(LPVOID, LPWORD, LPVOID, WORD);

#ifdef __cplusplus
}
#endif

#endif // _INC_COMPRESS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\bitmap.h ===
#ifndef _INC_BITMAP
#define _INC_BITMAP

#include "defs.h"

// Invalid page
#define BITMAP_PAGE_ERROR       0xFFFFFFFF

// Compression bitmap info
typedef struct tagIMGBITMAP
{
    DWORD                       dwSize;             // Size of entire bitmap in sectors
    DWORD                       dwPage;             // Current page in memory
    BOOL                        fDirty;             // Set TRUE when modified
    FILEHANDLE                  hFile;              // File handle
    DWORD                       dwFileOffset;       // Sector offset to the begining of the bitmap in the file
    LPBYTE                      lpbBuffer;          // Bit buffer
} IMGBITMAP, *PIMGBITMAP, far *LPIMGBITMAP;

#ifdef __cplusplus
extern "C" {
#endif

extern int InitBitmap(LPIMGBITMAP, DWORD, FILEHANDLE, DWORD, BOOL);
extern int ClusterInMemory(LPIMGBITMAP, DWORD);
extern int FlushBitmapBuffer(LPIMGBITMAP);
extern int GetBitmapBit(LPIMGBITMAP, DWORD, LPBOOL);
extern int SetBitmapBit(LPIMGBITMAP, DWORD);
extern int DiscardBitmap(LPIMGBITMAP);

#ifdef __cplusplus
}
#endif

#endif // _INC_BITMAP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\compress.c ===
#include "compress.h"
#include "defs.h"
#include "mrcicode.h"


// Compressed data format is as follows:  2 bytes indicating the size of
// the compressed data that when uncompressed will equal 1 cluster, followed
// by the MRCI 1 compresed data itself.


// Compresses a given data buffer.  On entry, lpvInput points to a buffer
// containing the uncompressed data, wInputSize is the size of the buffer,
// lpvOutput points to a buffer to receive the compressed data, lpwOutputSize
// points to the size of the output buffer.  On exit, lpwOutputSize points
// to the size of the compressed data.
BOOL CompressData(LPVOID lpvInput, WORD wInputSize, LPVOID lpvOutput, LPWORD lpwOutputSize)
{
    LPVOID                  lpvOffsetOutput;
    WORD                    wOffsetInputSize;
    WORD                    wCompressedSize;
    
    // Compress the data.  Note that the output buffer needs to point
    // to 2 bytes after the actual beginning and the size of the buffer
    // needs to be 2 less than the actual because we'll be writing the
    // compressed data size to the first 2 bytes.
    lpvOffsetOutput = (LPBYTE)lpvOutput + sizeof(WORD);
    wOffsetInputSize = wInputSize - sizeof(WORD);

    wCompressedSize = Mrci1MaxCompress(lpvInput, wInputSize, lpvOffsetOutput, wOffsetInputSize);
    
    // Make sure the compressor didn't return failure
    if(wCompressedSize == (WORD)-1)
    {
        return FALSE;
    }
    
    // Did we actually save anything?
    if(wCompressedSize >= wOffsetInputSize)
    {
        return FALSE;
    }
    
    // Write the compressed data size to the first two bytes.  This is
    // the size of the actual compressed data, not including the first
    // two bytes.
    *(LPWORD)lpvOutput = wCompressedSize;
    
    // Return the size of the data that will need to be written to the file
    *lpwOutputSize = wCompressedSize + sizeof(WORD);
    
    return TRUE;
}


// Uncompress a given data buffer.  On entry, lpvInput points to a buffer
// containing the compressed data, wInputSize is the size of the buffer to
// uncompress, lpvOutput points to a buffer to receive the uncompressed data,
// lpwOutputSize points to the expected size of compressed data.  On exit, 
// lpwOutputSize points to the size of the uncompressed data.
BOOL UncompressData(LPVOID lpvInput, LPWORD lpwInputSize, LPVOID lpvOutput, WORD wOutputSize)
{
    WORD                    wCompressed;
    WORD                    wUncompressed;
    
    // The actual size of the compressed data is in the first 2 bytes of
    // the input buffer
    wCompressed = *(LPWORD)lpvInput;
    lpvInput = (LPWORD)lpvInput + 1;

    // Uncompress the data to the output buffer
    wUncompressed = Mrci1Decompress((LPBYTE)lpvInput, wCompressed, lpvOutput, wOutputSize);
    
    // Did we uncompress properly?
    if(wUncompressed != wOutputSize)
    {
        return FALSE;
    }
    
    // Return success
    *lpwInputSize = wCompressed + sizeof(WORD);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\bootsec.h ===
#ifndef _INC_BOOTSEC
#define _INC_BOOTSEC

#include "defs.h"

#pragma pack(1)

// BIOS parameter block
typedef struct tagBPB
{
    WORD                        wSectorSize;
    BYTE                        bSectorsPerCluster;
    WORD                        wReservedSectors;
    BYTE                        bFATCount;
    WORD                        wRootDirEntries;
    WORD                        wTotalSectors;
    BYTE                        bMediaType;
    WORD                        wFATSize;
    WORD                        wSectorsPerTrack;
    WORD                        wHeadCount;
    DWORD                       dwHiddenSectors;
    DWORD                       dwBigTotalSectors;
} BPB, *PBPB, far *LPBPB;

// FAT32 BIOS parameter block
typedef struct tagBGBPB
{
    WORD                        wSectorSize;
    BYTE                        bSectorsPerCluster;
    WORD                        wReservedSectors;
    BYTE                        bFATCount;
    WORD                        wRootDirEntries;
    WORD                        wTotalSectors;
    BYTE                        bMediaType;
    WORD                        wFATSize;
    WORD                        wSectorsPerTrack;
    WORD                        wHeadCount;
    DWORD                       dwHiddenSectors;
    DWORD                       dwBigTotalSectors;
    // Start of FAT32 extensions
    DWORD                       dwBigFATSize;
    WORD                        wExtFlags;
    WORD                        wFSVer;
    DWORD                       dwRootCluster;
    WORD                        wFSInfoSector;
    WORD                        wBackupBootSector;
    WORD                        Reserved[6];
} BGBPB, *PBGBPB, far *LPBGBPB;

// Boot sector
typedef struct tagBOOTSECTOR
{
    BYTE                        abJump[3];
    BYTE                        abOEMName[8];
    BPB                         bpb;
    BYTE                        bDrive;
    BYTE                        Reserved;
    BYTE                        bBootSignature;
    DWORD                       dwVolumeID;
    BYTE                        abVolumeLabel[11];
    BYTE                        abFSType[8];
    BYTE                        code[450];
} BOOTSECTOR, *PBOOTSECTOR, far *LPBOOTSECTOR;

// FAT32 boot sector
typedef struct tagBGBOOTSECTOR
{
    BYTE                        abJump[3];
    BYTE                        abOEMName[8];
    BGBPB                       bpb;
    BYTE                        bDrive;
    BYTE                        bReserved;
    BYTE                        bBootSignature;
    DWORD                       dwVolumeID;
    BYTE                        abVolumeLabel[11];
    BYTE                        abFSType[8];
    BYTE                        code[422];
} BGBOOTSECTOR, *PBGBOOTSECTOR, far *LPBGBOOTSECTOR;

#pragma pack()

#endif // _INC_BOOTSEC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/15/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif  // DEBUG
#endif // _DEBUG

#ifdef DEBUG
extern void dprintf(const char *pszFormat, ...);
#define DPF dprintf
#else // DEBUG
#pragma warning(disable:4002)
#define DPF(a)
#endif // DEBUG

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\debug.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.c
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/15/00    dereks  Created.
 *
 ***************************************************************************/

#include "debug.h"

#ifdef DEBUG

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "text.h"


/***************************************************************************
 *
 *  dprintf
 *
 *  Description:
 *      Writes a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *      ... [in]: optional string modifiers.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

void dprintf(const char *pszFormat, ...)
{
    char                    szFinal[0x400]  = { 0 };
    char *                  pszString       = szFinal;
    va_list                 va;

#ifdef DPF_LIBRARY

    // Add the library name
    pszString += sprintf(pszString, DPF_LIBRARY ": ");

#endif // DPF_LIBRARY

    // Format the string
    va_start(va, pszFormat);
    pszString += vsprintf(pszString, pszFormat, va);
    va_end(va);

    // Add a carriage-return since OuputDebugString doesn't
    strcpy(pszString, CRLF);

    // Output to the debugger

#ifdef WIN32

    OutputDebugStringA(szFinal);

#else // WIN32

    printf(szFinal);

#endif // WIN32

}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\fatutil.h ===
#ifndef _INC_FATUTIL
#define _INC_FATUTIL

#include "defs.h"
#include "image.h"
#include "bitmap.h"

typedef BOOL (CALLBACK *WALKFATCALLBACK)(DWORD, DWORD, BYTE, LPVOID);

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD FATtoDWORD(LPBYTE, DWORD, DWORD, BYTE);
extern int WalkFAT(LPDRIVEINFO, BYTE, DWORD, DWORD, WALKFATCALLBACK, LPVOID);
extern int FindUnallocatedClusters(LPEVERYTHING, DWORD, DWORD, LPIMGBITMAP, LPDWORD, BOOL);
extern int FindBadClusters(LPEVERYTHING, DWORD, DWORD, LPDWORD FAR *, LPDWORD, BOOL);

#ifdef __cplusplus
}
#endif

#endif // _INC_FATUTIL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\diskutil.c ===
#if defined(WIN32) || defined(WIN16)
#include <windows.h>
#endif // defined(WIN32) || defined(WIN16)

#include <dos.h>
#include "debug.h"
#include "defs.h"
#include "diskutil.h"
#include "mem.h"

#pragma pack(1)

// Used with GetExtendedDPB()
typedef struct tagGETEXTDPB
{
    WORD                    wSize;
    DPB                     dpb;
} GETEXTDPB, *PGETEXTDPB, far *LPGETEXTDPB;

// DISKIO structure used for int25, int26 calls
typedef struct tagDISKIO
{
    DWORD                   dwSecStart;
    WORD                    wSecCount;
    LPBYTE                  lpbBuffer;
} DISKIO, *PDISKIO, far *LPDISKIO;

#pragma pack()


// Globals
static WORD                 g_wDosVer = 0;


// Local prototypes
BOOL DISKUTILAPI SectorIo(BYTE, LPVOID, DWORD, WORD, BOOL);
BOOL DISKUTILAPI Fat16SectorIo(BYTE, LPDISKIO, BOOL);
BOOL DISKUTILAPI Fat32SectorIo(BYTE, LPDISKIO, BOOL);
BOOL DISKUTILAPI Fat16GetDPB(BYTE, LPDPB);
BOOL DISKUTILAPI Fat32GetDPB(BYTE, LPDPB);


BOOL DISKUTILAPI InitDiskUtil(void)
{
    g_wDosVer = GetDosVersion();
    
    return TRUE;
}


BOOL DISKUTILAPI FreeDiskUtil(void)
{
    g_wDosVer = 0;

    return TRUE;
}


BOOL DISKUTILAPI ReadSector(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount)
{
    DPF("Reading sectors %lu to %lu on drive %u", dwSector, dwSector + wCount, bDrive);

    return SectorIo(bDrive, lpvBuffer, dwSector, wCount, FALSE);
}


BOOL DISKUTILAPI WriteSector(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount)
{
    DPF("Writing sectors %lu to %lu on drive %u", dwSector, dwSector + wCount, bDrive);

    return SectorIo(bDrive, lpvBuffer, dwSector, wCount, TRUE);
}


BOOL DISKUTILAPI SectorIo(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount, BOOL fWrite)
{
    DISKIO                  diskio;
    BOOL                    fSuccess;
    BYTE                    bTry;
    
    diskio.dwSecStart = dwSector;
    diskio.wSecCount = wCount;
    diskio.lpbBuffer = (LPBYTE)lpvBuffer;

    bTry = 0;
    
    do
    {
        if(IS_FAT32_KERNEL(g_wDosVer))
        {
            fSuccess = Fat32SectorIo(bDrive, &diskio, fWrite);
        }
        else
        {
            fSuccess = Fat16SectorIo(bDrive, &diskio, fWrite);
        }

        if(!fSuccess)
        {
            bTry++;
        }
    }
    while(!fSuccess && bTry < ABSRETRIES);

    return fSuccess;
}


#pragma optimize("", off)


BOOL DISKUTILAPI ResetDrive(void)
{
    DPF("Flushing all disk buffers");

    _asm
    {
        mov     ah, 0Dh         ; Reset Drive
        int     21h
    }

    return TRUE;
}


BOOL DISKUTILAPI Fat16SectorIo(BYTE bDrive, LPDISKIO lpDiskIo, BOOL fWrite)
{
    BOOL                    fSuccess;

    _asm
    {
        mov     fSuccess, FALSE     ; assume failure
    
        push    ds
    
        mov     al, bDrive          ; zero-based drive number
        lds     bx, lpDiskIo        ; ds:bx points to a DISKIO structure
        mov     cx, 0FFFFh          ; indicate we're using a DISKIO structure
    
        cmp     fWrite, TRUE        ; are we reading or writing?
        je      dowrite
    
        int     25h
        jmp     iodone
    
    dowrite:

        int     26h

    iodone:

        jc      failure
    
        mov     fSuccess, TRUE      ; success
    
    failure:

        popf                        ; remove the flags left by int 25h/26h
        pop     ds
    }
    
    return fSuccess;            
}


BOOL DISKUTILAPI Fat32SectorIo(BYTE bDrive, LPDISKIO lpDiskIo, BOOL fWrite)
{
    BOOL                        fSuccess;

    _asm
    {
        mov     fSuccess, FALSE     ; assume failure
    
        push    ds
        push    si
        
        mov     ax, 7305h           ; Extended Absolute Read/Write
        mov     cx, 0FFFFh          ; indicate we're using a DISKIO structure
        mov     dl, bDrive          ; 0-based drive number
        inc     dx                  ; 1-based drive number
        mov     bx, fWrite          ; are we reading or writing?
        mov     si, bx              ; indicate read/write
        lds     bx, lpDiskIo        ; ds:bx points to DISKIO structure
        int     21h
        jc      failure
    
        mov     fSuccess, TRUE      ; indicate success
    
    failure:

        pop     si
        pop     ds
    }

    return fSuccess;
}


WORD DISKUTILAPI GetDosVersion(void)
{
    WORD                    wVer;
    
    DPF("Getting DOS version");

    _asm
    {
        mov     ax, 3306h       ; Get MS-DOS Version
        int     21h
        
        mov     byte ptr [wVer], bh
        mov     byte ptr [wVer + 1], bl
    }
    
    DPF("DOS Version 0x%4.4X", wVer);

    return wVer;
}


BOOL DISKUTILAPI LockVolume(BYTE bDrive)
{
    BOOL                    fSuccess;
    
    DPF("Attempting to obtain level 0 lock on drive %u", bDrive);

    if(!IS_DOS7_KERNEL(g_wDosVer))
    {
        DPF("OS does not support locking");
        return TRUE;
    }
    
    _asm
    {
        mov     fSuccess, FALSE ; assume failure
        
        mov     ax, 440Dh       ; generic IOCTL
        mov     bl, bDrive      ; 0-based drive number
        inc     bl              ; 1-based drive number
        mov     bh, 0           ; lock level
        mov     cx, 084Ah       ; Lock Logical Volume
        mov     dx, 0           ; permissions
        int     21h
        jc      failure         ; CY set on error
        
        mov     fSuccess, TRUE  ; indicate success
        
    failure:
    
    }
    
    if(!fSuccess)
    {
        DPF("Lock failed");
    }
    
    return fSuccess;
}


BOOL DISKUTILAPI UnlockVolume(BYTE bDrive)
{
    BOOL                    fSuccess;
    
    DPF("Releasing level 0 lock on drive %u", bDrive);

    if(!IS_DOS7_KERNEL(g_wDosVer))
    {
        DPF("OS does not support locking");
        return TRUE;
    }
    
    _asm
    {
        mov     fSuccess, FALSE ; assume failure
        
        mov     ax, 440Dh       ; generic IOCTL
        mov     bl, bDrive      ; 0-based drive number
        inc     bl              ; 1-based drive number
        mov     bh, 0           ; lock level
        mov     cx, 086Ah       ; Unlock Logical Volume
        int     21h
        jc      failure         ; CY set on error
        
        mov     fSuccess, TRUE  ; indicate success
    
    failure:
    
    }
    
    if(!fSuccess)
    {
        DPF("Unlock failed");
    }

    return fSuccess;
}


BOOL DISKUTILAPI GetDriveMapping(BYTE bDrive, LPBYTE lpbHostDrive, LPBYTE lpbSequence)
{
    BOOL                    fSuccess;
    BOOL                    fCompressed;
    BYTE                    bHost;
    BYTE                    bSeq;
    
    DPF("Getting mapping for drive %u", bDrive);

    _asm
    {
        mov     fSuccess, FALSE     ; assume failure
        mov     fCompressed, FALSE  ; assume uncompressed
        
        mov     ax, 4A11h           ; DriveSpace multiplex
        mov     bx, 1               ; DSGetDriveMapping
        mov     dl, bDrive          ; 0-based drive number
        int     2Fh
        or      ax, ax              ; AX == 0 on success
        jnz     failure

        mov     fSuccess, TRUE
        
        test    bl, 80h             ; BL & 80h if drive is compressed
        jz      uncompressed
        
        mov     fCompressed, TRUE
        
        and     bl, 7Fh             ; mask off high bit
        mov     bHost, bl           ; host drive number stored in BL
        mov     bSeq, bh            ; CVF sequence number stored in BH
    
    uncompressed:
    failure:
    
    }
    
    if(!fSuccess)
    {
        DPF("Unable to get drive mapping");
        return FALSE;
    }
    
    if(!fCompressed)
    {
        DPF("Drive is not compressed");
        return FALSE;
    }
    
    GetDriveMapping(bHost, &bHost, &bSeq);
    
    if(lpbHostDrive)
    {
        *lpbHostDrive = bHost;
        DPF("Host drive:  %u", *lpbHostDrive);
    }
        
    if(lpbSequence)
    {
        *lpbSequence = bSeq;
        DPF("Sequence:  %u", *lpbSequence);
    }
    
    return TRUE;
}


BOOL DISKUTILAPI GetDPB(BYTE bDrive, LPDPB lpDpb)
{
    BOOL                    fSuccess;
    
    if(IS_FAT32_KERNEL(g_wDosVer))
    {
        fSuccess = Fat32GetDPB(bDrive, lpDpb);
    }
    else
    {
        fSuccess = Fat16GetDPB(bDrive, lpDpb);
    }

    if(fSuccess && lpDpb->wOldFATSize)
    {
        lpDpb->wExtFlags = 0;
        lpDpb->dwFirstSector = lpDpb->wOldFirstSector;
        lpDpb->dwMaxCluster = lpDpb->wOldMaxCluster;
        lpDpb->dwFATSize = lpDpb->wOldFATSize;
        lpDpb->dwRootCluster = 0;
        lpDpb->dwNextFree = lpDpb->wOldNextFree;
    }

    return fSuccess;
}


BOOL DISKUTILAPI Fat16GetDPB(BYTE bDrive, LPDPB lpDpb)
{
    LPDPB               lpDpbTemp;
    
    _asm
    {
        mov     word ptr [lpDpbTemp], 0 ; assume failure
        mov     word ptr [lpDpbTemp + 2], 0
        
        push    ds
        push    si
        
        mov     ax, 3200h       ; Get DPB
        mov     dl, bDrive      ; 0-based drive number
        inc     dl              ; 1-based drive number
        
        int     21h
        
        cmp     al, 0FFh        ; AL == FFh on error
        je      failure
        
        mov     word ptr [lpDpbTemp], bx   
        mov     word ptr [lpDpbTemp + 2], ds   ; pointer to DPB stored in ds:bx
    
    failure:
    
        pop     si
        pop     ds
    }
    
    if(!lpDpbTemp)
    {
        DPF("Unable to get DPB");
        return FALSE;
    }
    
    MemSet(lpDpb, 0, sizeof(*lpDpb));
    MemCopy(lpDpb, lpDpbTemp, sizeof(*lpDpbTemp));

    return TRUE;
}


BOOL DISKUTILAPI Fat32GetDPB(BYTE bDrive, LPDPB lpDpb)
{
    GETEXTDPB           gd;
    LPGETEXTDPB         lpgd;
    WORD                wSize;
    BOOL                fSuccess;
    
    lpgd = &gd;
    wSize = sizeof(gd);
    
    _asm
    {
        mov     fSuccess, FALSE ; assume failure
        
        push    di
        
        mov     ax, 7302h       ; Get Extended DPB
        mov     cx, wSize       ; buffer size
        mov     dl, bDrive      ; 0-based drive number
        inc     dl              ; 1-based drive number
        mov     di, word ptr [lpgd]
        mov     bx, word ptr [lpgd + 2]
        mov     es, bx          ; es:di points to GETEXTDPB structure
        int     21h
        jc      failure         ; CY indicates error
        
        mov     fSuccess, TRUE  ; indicate success
    
    failure:
    
        pop     di
    }
    
    if(!fSuccess)
    {
        DPF("Unable to get DPB");
        return FALSE;
    }
    
    MemSet(lpDpb, 0, sizeof(*lpDpb));
    MemCopy(lpDpb, &(gd.dpb), gd.wSize);
    
    return TRUE;
}


#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\fatutil.c ===
#include <stdio.h>
#include "bitmap.h"
#include "bootsec.h"
#include "debug.h"
#include "defs.h"
#include "diskutil.h"
#include "fatutil.h"
#include "mem.h"
#include "image.h"
#include "text.h"


typedef struct tagFINDUNALLOCATEDCLUSTERS
{
    DWORD                   dwStartCluster;
    LPIMGBITMAP             lpBitmap;
    DWORD                   dwTotalFound;
} FINDUNALLOCATEDCLUSTERS, *PFINDUNALLOCATEDCLUSTERS, FAR *LPFINDUNALLOCATEDCLUSTERS;

typedef struct tagFINDBADCLUSTERS
{
    LPDWORD FAR *           lplpList;
    DWORD                   dwTotalFound;
} FINDBADCLUSTERS, *PFINDBADCLUSTERS, FAR *LPFINDBADCLUSTERS;


// Converts a FAT entry as it sits on the disk into a DWORD cluster entry.
DWORD FATtoDWORD(LPBYTE lpbBuffer, DWORD dwOffset, DWORD dwCluster, BYTE bBitsPerEntry)
{
    DWORD                   dwRet = 0;
    
    lpbBuffer += dwOffset;
    
    switch(bBitsPerEntry)
    {
        case 12:
            if(dwCluster & 1)
            {
                dwRet = (DWORD)HINIBBLE(*lpbBuffer) | (DWORD)(*(lpbBuffer + 1)) << 4;
            }
            else
            {
                dwRet = (DWORD)*lpbBuffer | (DWORD)(LONIBBLE(*(lpbBuffer + 1)) << 8);
            }
           
            break;
       
        case 16:
            dwRet = (DWORD)*(LPWORD)lpbBuffer;
            
            break;
        
        case 32:
            dwRet = *(LPDWORD)lpbBuffer;
            
            break;
    }
    
    return dwRet;
}


int WalkFAT(LPDRIVEINFO lpDrive, BYTE bFAT, DWORD dwStartCluster, DWORD dwClusterCount, WALKFATCALLBACK fnCallback, LPVOID lpvContext)
{
    LPBYTE                  lpbBuffer;
    DWORD                   dwPage;
    DWORD                   dwOffset;
    DWORD                   dwCluster;
    
    // Don't be stupid
    if(bFAT != 1 && bFAT != 2)
    {
        return ERROR_DRIVEREAD;
    }
    
    // Modify the starting cluster.  Must be at least 2.
    dwStartCluster = max(2, dwStartCluster);
    
    // Modify the cluster count to be sure we don't try to read more than
    // there actually are.
    dwClusterCount = min(lpDrive->bs.dwTotalClusters - (dwStartCluster - 2), dwClusterCount);
    
    // Our internal cluster counter is 0-based from the starting cluster
    dwCluster = 0;

    // We're reading the FAT in 3-sector pages
    dwPage = (dwStartCluster * lpDrive->bs.dwBitsPerFATEntry / 8) / (lpDrive->bs.dwSectorSize * 3);
    
    // Allocate a 3-sector buffer
    if(!(lpbBuffer = MemAlloc((UINT)(lpDrive->bs.dwSectorSize * 3))))
    {
        return ERROR_OOM;
    }
    
    // Read in each page of the FAT.  Pass each entry to the callback function.
    while(dwPage < DIVUP(lpDrive->bs.dwFATSize, 3))
    {
        if(!ReadSector(lpDrive->bDrive, lpbBuffer, lpDrive->bs.dwReservedSectors + ((bFAT - 1) * lpDrive->bs.dwFATSize) + (dwPage * 3), 3))
        {
            MemFree(lpbBuffer);
            return ERROR_DRIVEREAD;
        }
        
        dwOffset = (dwCluster + dwStartCluster) * lpDrive->bs.dwBitsPerFATEntry / 8;
        dwOffset -= dwPage * lpDrive->bs.dwSectorSize * 3;

        while(dwOffset < lpDrive->bs.dwSectorSize * 3 && dwCluster < dwClusterCount)
        {
            // Call the callback function
            if(!(*fnCallback)(dwCluster + dwStartCluster, FATtoDWORD(lpbBuffer, dwOffset, dwCluster + dwStartCluster, (BYTE)lpDrive->bs.dwBitsPerFATEntry), (BYTE)lpDrive->bs.dwBitsPerFATEntry, lpvContext))
            {
                MemFree(lpbBuffer);
                return ERROR_NONE;
            }
            
            // Increment the offset.  Remember that if this is a 12-bit FAT, we have to
            // tweak the incrementation a bit.
            if(lpDrive->bs.dwBitsPerFATEntry == 12 && dwCluster & 1)
            {
                dwOffset += 2;
            }
            else
            {
                dwOffset += lpDrive->bs.dwBitsPerFATEntry / 8;
            }
            
            // Increment the cluster
            dwCluster++;
        }
        
        // Next page, please
        dwPage++;
    }
    
    // Free memory
    MemFree(lpbBuffer);
    
    // Return success
    return ERROR_NONE;
}


BOOL CALLBACK FindUnallocatedClustersCallback(DWORD dwCluster, DWORD dwValue, BYTE bBits, LPVOID lpvContext)
{
    LPFINDUNALLOCATEDCLUSTERS lpUn = (LPFINDUNALLOCATEDCLUSTERS)lpvContext;
    
    // If the cluster is unused, set it's corresponding bit in the bitmap
    if(dwValue == 0)
    {
        if(lpUn->lpBitmap)
        {
            SetBitmapBit(lpUn->lpBitmap, dwCluster - lpUn->dwStartCluster);
        }
        
        lpUn->dwTotalFound++;
    }
    
    return TRUE;
}


int FindUnallocatedClusters(LPEVERYTHING lpData, DWORD dwStartCluster, DWORD dwClusterCount, LPIMGBITMAP lpBitmap, LPDWORD lpdwCount, BOOL fQuiet)
{
    FINDUNALLOCATEDCLUSTERS un;
    int                     nRet;
    
    un.dwStartCluster = dwStartCluster;
    un.lpBitmap = lpBitmap;
    un.dwTotalFound = 0;

    if(lpData->lpImage->wFlags & OPTIONS_ALLOCATED)
    {
        if(!fQuiet)
        {

#ifdef WIN32

            SetProgressLabel(lpData->lpImageRes->hWnd, "Scanning for unallocated clusters...");

#else // WIN32
        
            printf("Scanning for unallocated clusters... ");

#endif // WIN32

        }
        
        if(nRet = WalkFAT(lpData->lpDrive, 1, dwStartCluster, dwClusterCount, FindUnallocatedClustersCallback, &un))
        {
            return nRet;
        }

        if(!fQuiet)
        {

#ifndef WIN32

            printf("%lu" CRLF CRLF, un.dwTotalFound);

#endif // WIN32

        }
    }
    
    if(lpdwCount)
    {
        *lpdwCount = un.dwTotalFound;
    }
    
    return ERROR_NONE;
}


BOOL CALLBACK FindBadClustersCallback(DWORD dwCluster, DWORD dwValue, BYTE bBits, LPVOID lpvContext)
{
    LPFINDBADCLUSTERS       lpBad   = (LPFINDBADCLUSTERS)lpvContext;
    LPDWORD                 lpList  = *(lpBad->lplpList);

    // Is this cluster marked bad?
    switch(bBits)
    {
        case 12:
            if(dwValue != 0xFF7)
            {
                return TRUE;
            }

            break;

        case 16:
            if(dwValue != 0xFFF7)
            {
                return TRUE;
            }

            break;

        case 32:
            if(dwValue != 0xFFFFFFF7)
            {
                return TRUE;
            }

            break;
    }
    
    // Add this cluster to the list
    lpList = (LPDWORD)MemReAlloc(lpList, (UINT)((++lpBad->dwTotalFound) * sizeof(DWORD)));

    if(!lpList)
    {
        return FALSE;
    }
        
    lpList[lpBad->dwTotalFound - 1] = dwCluster - 2;
    
    *(lpBad->lplpList) = lpList;
    
    return TRUE;
}


int FindBadClusters(LPEVERYTHING lpData, DWORD dwStartCluster, DWORD dwClusterCount, LPDWORD FAR * lplpList, LPDWORD lpdwCount, BOOL fQuiet)
{
    FINDBADCLUSTERS         bad;
    int                     nRet;
    
    if(lplpList)
    {
        *lplpList = NULL;
    }
    
    bad.lplpList = lplpList;
    bad.dwTotalFound = 0;
    
    if(lpData->lpImage->wFlags & OPTIONS_FINDBAD)
    {
        if(!fQuiet)
        {

#ifdef WIN32

            SetProgressLabel(lpData->lpImageRes->hWnd, "Scanning for bad clusters...");

#else // WIN32
        
            printf("Scanning for bad clusters... ");

#endif // WIN32

        }
        
        if(nRet = WalkFAT(lpData->lpDrive, 1, dwStartCluster, dwClusterCount, FindBadClustersCallback, &bad))
        {
            return nRet;
        }

        if(!fQuiet)
        {

#ifndef WIN32

            printf("%lu" CRLF CRLF, bad.dwTotalFound);

#endif // WIN32

        }
    }
    
    if(lpdwCount)
    {
        *lpdwCount = bad.dwTotalFound;
    }
    
    return ERROR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\diskutil.h ===
#ifndef _INC_DISKUTIL
#define _INC_DISKUTIL

#include "defs.h"

// Function type modifiers
#define DISKUTILAPI             FAR PASCAL LOADDS

// Number of retries when an absolute disk read/write fails
#define ABSRETRIES              2

// Maximum number of clusters that can be passed to ReadSector/WriteSector
#define SECTORIO_MAX_SECTORS    64

// DOS version macros
#define IS_DOS7_KERNEL(ver)     (ver >= 0x700)
#define IS_FAT32_KERNEL(ver)    (ver >= 0x70A)

#pragma pack(1)

// DOS parameter block
typedef struct tagDPB
{
    BYTE                        bDrive;
    BYTE                        bUnit;
    WORD                        wSectorSize;
    BYTE                        bClusterMask;
    BYTE                        bClusterShift;
    WORD                        wFirstFAT;
    BYTE                        bFATCount;
    WORD                        wOldRootEntries;
    WORD                        wOldFirstSector;
    WORD                        wOldMaxCluster;
    WORD                        wOldFATSize;
    WORD                        wOldDirSector;
    DWORD                       dwDriverAddr;
    BYTE                        bMedia;
    BYTE                        bFlags;
    DWORD                       dwNextDPB;
    WORD                        wOldNextFree;
    DWORD                       dwFreeCount;
    WORD                        wExtFlags;
    WORD                        wFSInfoSector;
    WORD                        wBackupBootSector;
    DWORD                       dwFirstSector;
    DWORD                       dwMaxCluster;
    DWORD                       dwFATSize;
    DWORD                       dwRootCluster;
    DWORD                       dwNextFree;
} DPB, *PDPB, far *LPDPB;

#pragma pack()

#ifdef WIN32

#define InitDiskUtil        InitDiskUtil32
#define FreeDiskUtil        FreeDiskUtil32
#define ResetDrive          ResetDrive32
#define ReadSector          ReadSector32
#define WriteSector         WriteSector32
#define GetDosVersion       GetDosVersion32
#define LockVolume          LockVolume32
#define UnlockVolume        UnlockVolume32
#define GetDriveMapping     GetDriveMapping32
#define GetDPB              GetDPB32

#endif // WIN32

#ifdef WIN16

#define InitDiskUtil        InitDiskUtil16
#define FreeDiskUtil        FreeDiskUtil16
#define ResetDrive          ResetDrive16
#define ReadSector          ReadSector16
#define WriteSector         WriteSector16
#define GetDosVersion       GetDosVersion16
#define LockVolume          LockVolume16
#define UnlockVolume        UnlockVolume16
#define GetDriveMapping     GetDriveMapping16
#define GetDPB              GetDPB16

#endif // WIN16

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL DISKUTILAPI InitDiskUtil(void);
extern BOOL DISKUTILAPI FreeDiskUtil(void);
extern BOOL DISKUTILAPI ResetDrive(void);
extern BOOL DISKUTILAPI ReadSector(BYTE, LPVOID, DWORD, WORD);
extern BOOL DISKUTILAPI WriteSector(BYTE, LPVOID, DWORD, WORD);
extern WORD DISKUTILAPI GetDosVersion(void);
extern BOOL DISKUTILAPI LockVolume(BYTE);
extern BOOL DISKUTILAPI UnlockVolume(BYTE);
extern BOOL DISKUTILAPI GetDriveMapping(BYTE, LPBYTE, LPBYTE);
extern BOOL DISKUTILAPI GetDPB(BYTE, LPDPB);

#ifdef __cplusplus
}
#endif

#endif // _INC_DISKUTIL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\file.c ===
#ifdef WIN32
#include <windows.h>
#include "win32\winmisc.h"
#else // WIN32
#include <conio.h>
#include <dos.h>
#include <stdio.h>
#endif // WIN32

#include "defs.h"
#include "diskutil.h"
#include "image.h"
#include "file.h"
#include "text.h"
#include "debug.h"


#ifndef WIN32
#pragma optimize("", off)
#endif // WIN32

FILEHANDLE FileOpen(LPSTR lpszName, WORD wMode, WORD wAttrib, WORD wAction)
{
    FILEHANDLE              fh;    

#ifdef WIN32

    DWORD                   dwDesiredAccess;
    DWORD                   dwShareMode;
    DWORD                   dwCreationDistribution;
    DWORD                   dwFlagsAndAttributes;

    // Set up access mode
    dwDesiredAccess = GENERIC_READ;

    if(wMode & OPEN_ACCESS_WRITEONLY)
    {
        dwDesiredAccess = GENERIC_WRITE;
    }

    if(wMode & OPEN_ACCESS_READWRITE)
    {
        dwDesiredAccess |= GENERIC_WRITE;
    }

    // Set up share mode
    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

    if(wMode & OPEN_SHARE_DENYREADWRITE)
    {
        dwShareMode = 0;
    }

    if(wMode & OPEN_SHARE_DENYWRITE)
    {
        dwShareMode &= ~(FILE_SHARE_WRITE);
    }

    if(wMode & OPEN_SHARE_DENYREAD)
    {
        dwShareMode &= ~(FILE_SHARE_READ);
    }

    // Set up creation distribution
    dwCreationDistribution = OPEN_EXISTING;

    if(wAction & ACTION_FILE_TRUNCATE)
    {
        dwCreationDistribution = CREATE_ALWAYS;
    }

    if(wAction & ACTION_FILE_CREATE)
    {
        dwCreationDistribution = CREATE_NEW;
    }

    // Set up flags and attributes
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;

    if(wAttrib & ATTR_READONLY)
    {
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_READONLY;
    }

    if(wAttrib & ATTR_HIDDEN)
    {
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_HIDDEN;
    }

    if(wAttrib & ATTR_SYSTEM)
    {
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_SYSTEM;
    }

    if(wAttrib & ATTR_ARCHIVE)
    {
        dwFlagsAndAttributes |= FILE_ATTRIBUTE_ARCHIVE;
    }

    if(wAttrib & OPEN_FLAGS_COMMIT)
    {
        dwFlagsAndAttributes |= FILE_FLAG_NO_BUFFERING;
    }

    // TODO: find out about EXTENDED_SIZE under Win32
    fh = CreateFile(lpszName, dwDesiredAccess, dwShareMode, NULL, dwCreationDistribution, dwFlagsAndAttributes, NULL);

    if(fh == INVALID_HANDLE_VALUE)
    {
        fh = INVALID_FILE_HANDLE;
    }

#else // WIN32

    // Set the EXTENDED_SIZE attribute, allowing a file to grow to over 2 gigs
    if(GetDosVersion() >= 0x70A)
    {
        wAttrib |= 0x1000;
    }

    _asm
    {
        mov     fh, 0FFFFh      ; assume failure
        
        push    ds
        push    si
        
        mov     bx, wMode       ; specifies the mode to open the file in
        mov     cx, wAttrib     ; file attributes
        mov     dx, wAction     ; action to take if file exists
        lds     si, lpszName    ; filename
        mov     ah, 6Ch         ; Extended File Open/Create
        int     21h
        
        pop     si
        pop     ds
        
        jc      failure
        
        mov     fh, ax          ; AX contains the file handle
    
    failure:
    
    }

#endif // WIN32

	if(INVALID_FILE_HANDLE == fh)
	{
		DPF("Failed to open %s (%X %X %X)", lpszName, wMode, wAttrib, wAction);
	}
	else
	{
		DPF("Opened %s (%X %X %X).  Handle = %X", lpszName, wMode, wAttrib, wAction, fh);
	}

    return fh;

}

#ifndef WIN32
#pragma optimize("", on)
#endif // WIN32


void FileClose(FILEHANDLE fh)
{

#ifdef WIN32

    CloseHandle(fh);

#else // WIN32

    _dos_close(fh);

#endif // WIN32

	DPF("Closed file handle %X", fh);
}


DWORD FileRead(FILEHANDLE fh, LPVOID lpvBuffer, DWORD dwBufSize)
{
    DWORD                   dwRead;

#ifdef WIN32

    if(!ReadFile(fh, lpvBuffer, dwBufSize, &dwRead, NULL))
    {
        return (DWORD)-1;
    }

#else // WIN32

    WORD                    wRead;

    if(dwBufSize > MAXWORD)
    {
        return (DWORD)-1;
    }

    if(_dos_read(fh, lpvBuffer, (WORD)dwBufSize, &wRead))
    {
        dwRead = (DWORD)-1;
    }
    else
    {
        dwRead = wRead;
    }

#endif // WIN32

    return dwRead;
}
 
 
DWORD FileWrite(FILEHANDLE fh, LPVOID lpvBuffer, DWORD dwBufSize)
{
    DWORD                   dwWritten;

#ifdef WIN32

    if(!WriteFile(fh, lpvBuffer, dwBufSize, &dwWritten, NULL))
    {
        return (DWORD)-1;
    }

#else // WIN32

    WORD                    wWritten;

    if(dwBufSize > MAXWORD)
    {
        return (DWORD)-1;
    }

    if(_dos_write(fh, lpvBuffer, (WORD)dwBufSize, &wWritten))
    {
        dwWritten = (DWORD)-1;
    }
    else
    {
        dwWritten = wWritten;
    }
            
#endif // WIN32

    return dwWritten;
}


void FileCommit(FILEHANDLE fh)
{

#ifdef WIN32
    
    FlushFileBuffers(fh);

#else // WIN32

    _dos_commit(fh);

#endif // WIN32

}


DWORD FileGetPos(FILEHANDLE fh)
{
    return FileSetPos(fh, 0, SEEK_CUR);
}


DWORD FileSetPos(FILEHANDLE fh, long lOffset, BYTE bMethod)
{
    long                    lNewOffset;

#ifdef WIN32

    lNewOffset = SetFilePointer(fh, lOffset, NULL, bMethod);

#else // WIN32

    lNewOffset = _dos_seek(fh, lOffset, bMethod);

#endif // WIN32

    return lNewOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\defs.h ===
#ifndef _INC_DEFS
#define _INC_DEFS

#if defined(WIN32) || defined(WIN16)
#include <windows.h>
#endif // defined(WIN32) || defined(WIN16)

// Internal sector size.  This is not the true size of a sector on the drive,
// just what we call a sector when talking about the Pad Sector, Lead Sector, etc.
#define CBSEC                   512

// Command-line switches
#define SWITCH_HELP             '?'
#define SWITCH_ALLOCATED        'A'
#define SWITCH_FINDBAD          'B'
#define SWITCH_COMPRESS         'C'
#define SWITCH_DUMPINFO         'D'
#define SWITCH_FORCE            'F'
#define SWITCH_IGNORETYPE       'I'
#define SWITCH_NOLOCK           'L'
#define SWITCH_NOPROMPT         'N'
#define SWITCH_OVERWRITE        'O'
#define SWITCH_NOSTATUS         'Q'
#define SWITCH_NORECOVER        'R'
#define SWITCH_SPAN             'S'
#define SWITCH_TEXTCOMMENT      'T'
#define SWITCH_VERIFY           'V'
#define SWITCH_WIPE             'W'

// Undocumented switch for reading/writing 1 cluster at a time
#define SWITCH_1CLUSTER         '1'

// Options
#define OPTIONS_NONE            0x0000
#define OPTIONS_COMPRESS        0x0001
#define OPTIONS_NOPROMPT        0x0002
#define OPTIONS_SPAN            0x0004
#define OPTIONS_IGNORETYPE      0x0008
#define OPTIONS_NOLOCK          0x0010
#define OPTIONS_OVERWRITE       0x0020
#define OPTIONS_NORECOVER       0x0040
#define OPTIONS_FORCE           0x0080
#define OPTIONS_ALLOCATED       0x0100
#define OPTIONS_WIPE            0x0200
#define OPTIONS_FINDBAD         0x0400
#define OPTIONS_NOSTATUS        0x0800
#define OPTIONS_VERIFY          0x1000
#define OPTIONS_DUMPINFO        0x2000
#define OPTIONS_1CLUSTER        0x8000

// Error returns
#define ERROR_NONE              0
#define ERROR_FILEOPEN          1
#define ERROR_FILEWRITE         2
#define ERROR_FILEREAD          3
#define ERROR_DRIVEREAD         4
#define ERROR_DRIVEWRITE        5
#define ERROR_OOM               6
#define ERROR_TOOMANYFRAGMENTS  7
#define ERROR_INVALIDIMAGE      8
#define ERROR_DRIVETOOSMALL     9
#define ERROR_LOCKFAIL          10
#define ERROR_OUTOFSEQUENCE     11
#define ERROR_COMPRESSEDDRIVE   12
#define ERROR_DRIVECLUSTERSTOOBIG   13
#define ERROR_IMAGECLUSTERSTOOBIG   14
#define ERROR_COMPRESS          15
#define ERROR_UNCOMPRESS        16
#define ERROR_DPB               17
#define ERROR_OLDKERNEL         18
#define ERROR_DRIVETOOBIG       19
#define ERROR_STUPIDRECOVERY    20
#define ERROR_WRONGFSTYPE       21
#define ERROR_BADCLUSTEROFFSET  22
#define ERROR_RECOVERYFAILED    23
#define ERROR_VERIFYFILE        24
#define ERROR_VERIFYDISK        25
#define ERROR_USERCANCEL        26
#define ERROR_LFN               27
#define ERROR_UNSUPPORTEDFS     28

#ifdef WIN32
#define READWRITE_BUFFER_SIZE   0x40000
#else // WIN32
#define READWRITE_BUFFER_SIZE   0x8000
#endif // WIN32

#ifndef TRUE
#define TRUE                    1
#endif // TRUE

#ifndef FALSE
#define FALSE                   0
#endif // FALSE

#ifndef NULL
#define NULL                    0
#endif // NULL

#ifndef MAX_FILE
#ifdef WIN32
#define MAX_FILE                256
#else // WIN32
#define MAX_FILE                64
#endif // WIN32
#endif // MAX_FILE

#ifndef MAX_DIR
#define MAX_DIR                 MAX_FILE
#endif // MAX_DIR

#ifndef MAX_PATH
#define MAX_PATH                (MAX_FILE + 2)
#endif // MAX_PATH

#ifndef MAXWORD
#define MAXWORD                 ((WORD)0xFFFF)
#endif // MAXWORD

#ifndef MAXDWORD
#define MAXDWORD                ((DWORD)0xFFFFFFFF)
#endif // MAXDWORD

#ifndef min
#define min(a, b)               ((a < b) ? a : b)
#endif // min

#ifndef max
#define max(a, b)               ((a > b) ? a : b)
#endif // max

#if defined(WIN32) || defined(WIN16)

typedef HANDLE                  FILEHANDLE;

#else // defined(WIN32) || defined(WIN16)

#define CALLBACK                __cdecl __far
#define NEAR                    __near
#define FAR                     __far
#define PASCAL                  __pascal

typedef char                    FAR *LPSTR, const FAR *LPCSTR;

typedef unsigned char           BYTE,   *PBYTE,     FAR *LPBYTE;
typedef unsigned short          WORD,   *PWORD,     FAR *LPWORD;
typedef unsigned int            UINT,   *PUINT,     FAR *LPUINT;
typedef unsigned long           DWORD,  *PDWORD,    FAR *LPDWORD;
typedef int                     BOOL,   *PBOOL,     FAR *LPBOOL;
typedef int                     FILEHANDLE;
typedef void                            *PVOID,     FAR *LPVOID;
typedef char                                        FAR *LPSTR;

#endif // defined(WIN32) || defined(WIN16)

#ifdef WIN16
#define LOADDS                  __loadds
#else // WIN16
#define LOADDS
#endif // WIN16

#ifndef LONIBBLE
#define LONIBBLE(b)             ((BYTE)(((BYTE)(b)) & 0xF))
#endif // LONIBBLE

#ifndef HINIBBLE
#define HINIBBLE(b)             ((BYTE)((((BYTE)(b)) >> 4) & 0xF))
#endif // HINIBBLE

#ifndef LOBYTE
#define LOBYTE(w)               ((BYTE)((WORD)(w)))
#endif // LOBYTE

#ifndef HIBYTE
#define HIBYTE(w)               ((BYTE)((((WORD)(w)) >> 8) & 0xFF))
#endif // HIBYTE

#ifndef LOWORD
#define LOWORD(dw)              ((WORD)((DWORD)(dw)))
#endif // LOWORD

#ifndef HIWORD
#define HIWORD(dw)              ((WORD)((((DWORD)(dw)) >> 16) & 0xFFFF))
#endif // HIWORD

#ifndef MAKEWORD
#define MAKEWORD(l, h)          ((((WORD)h) << 8) | (WORD)l)
#endif // MAKEWORD

#ifndef MAKEDWORD
#define MAKEDWORD(l, h)         ((((DWORD)h) << 16) | (DWORD)l)
#endif // MAKEDWORD

#define DIVUP(a, b)             (((a) / (b)) + (((a) % (b)) ? 1 : 0))

#endif // _INC_DEFS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\file.h ===
#ifndef _INC_FILE
#define _INC_FILE

#include "defs.h"
#include "stdio.h"

#define INVALID_FILE_HANDLE     ((FILEHANDLE)-1)

#define OPEN_ACCESS_READONLY    0x0000
#define OPEN_ACCESS_WRITEONLY   0x0001
#define OPEN_ACCESS_READWRITE   0x0002

#define OPEN_SHARE_COMPAT       0x0000
#define OPEN_SHARE_DENYREADWRITE 0x0010
#define OPEN_SHARE_DENYWRITE    0x0020
#define OPEN_SHARE_DENYREAD     0x0030
#define OPEN_SHARE_DENYNONE     0x0040

#define OPEN_FLAGS_NOINHERIT    0x0080
#define OPEN_FLAGS_NOCRIT_ERR   0x2000
#define OPEN_FLAGS_COMMIT       0x4000

#define ATTR_NORMAL             0x0000
#define ATTR_READONLY           0x0001
#define ATTR_HIDDEN             0x0002
#define ATTR_SYSTEM             0x0004
#define ATTR_ARCHIVE            0x0020

#define ACTION_FILE_OPEN        0x0001
#define ACTION_FILE_TRUNCATE    0x0002
#define ACTION_FILE_CREATE      0x0010 

#define ACTION_OPENED           0x0001
#define ACTION_CREATED_OPENED   0x0002
#define ACTION_REPLACED_OPENED  0x0003
 
#ifndef WIN32

#define ERROR_INVALID_FUNCTION  0x0001
#define ERROR_FILE_NOT_FOUND    0x0002
#define ERROR_PATH_NOT_FOUND    0x0002
#define ERROR_TOO_MANY_OPEN_FILES 0x0004
#define ERROR_ACCESS_DENIED     0x0005

#endif // WIN32

#ifdef __cplusplus
extern "C" {
#endif

// Prototypes
FILEHANDLE FileOpen(LPSTR, WORD, WORD, WORD);
DWORD FileRead(FILEHANDLE, LPVOID, DWORD);
DWORD FileWrite(FILEHANDLE, LPVOID, DWORD);
void FileClose(FILEHANDLE);
void FileCommit(FILEHANDLE);
DWORD FileGetPos(FILEHANDLE);
DWORD FileSetPos(FILEHANDLE, long, BYTE);

#ifdef __cplusplus
}
#endif

#endif // _INC_FILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\image.c ===
#include <stdio.h>
#include <stdlib.h>
#include "bitmap.h"
#include "bootsec.h"
#include "defs.h"
#include "diskutil.h"
#include "image.h"
#include "file.h"
#include "mem.h"
#include "text.h"
#include "debug.h"

#ifdef WIN32
#include "win32\resource.h"
#include "win32\winmisc.h"
#endif // WIN32


// Used with GetFragNames
typedef struct tagGETFRAGNAMES
{
    DWORD                   dwFirst;
    DWORD                   dwCount;
    LPSTR                   lpszList;
} GETFRAGNAMES, *LPGETFRAGNAMES;


// Image signatures
const char                  sig11[] = { 'D', 'S' };
const char                  sig30[] = { 'R', 'R' };


// Local prototypes
BOOL SectorIOWrapper(BYTE, LPVOID, DWORD, DWORD, DWORD, BOOL);


// Reads the image Pad Sector and Lead Sector
int ReadImageHeader(FILEHANDLE fhImage, LPLEADSECTOR lpLeadSector, LPDWORD lpdwFirstData, BOOL fRequireCurrentVersion)
{
    BYTE                    bSector[CBSEC];
    LPLEADSECTOR            lpls;
    BOOL                    fOldImage;
    UINT                    i;
    
    // Seek to the beginning of the file
    FileSetPos(fhImage, 0, SEEK_SET);

    // Read the Pad Sector
    if(FileRead(fhImage, &bSector, CBSEC) != CBSEC)
    {
        return ERROR_FILEREAD;
    }

    // Validate the Pad Sector
    for(i = 0; i < CBSEC - 2; i++)
    {
        if(bSector[i] != 0xFF)
        {
            return ERROR_INVALIDIMAGE;
        }
    }
    
    // Check the image version
    if(bSector[CBSEC - 2] == sig11[0] && bSector[CBSEC - 1] == sig11[1])
    {
        fOldImage = TRUE;
    }
    if(bSector[CBSEC - 2] == sig30[0] && bSector[CBSEC - 1] == sig30[1])
    {
        fOldImage = FALSE;
    }
    else
    {
        return ERROR_INVALIDIMAGE;
    }

    if(fRequireCurrentVersion && fOldImage)
    {
        return ERROR_INVALIDIMAGE;
    }

    // Read the Lead Sector
    if(FileRead(fhImage, &bSector, CBSEC) != CBSEC)
    {
        return ERROR_FILEREAD;
    }

    lpls = (LPLEADSECTOR)&bSector;
    
    // Certain flags were unavailable in old versions
    if(fOldImage)
    {
        if(lpls->wFlags & OPTIONS_COMPRESS || lpls->wFlags & OPTIONS_ALLOCATED)
        {
            return ERROR_INVALIDIMAGE;
        }
    }
    
    // Make sure we got a valid number of fragments.
    // This is also a good check for the structure's
    // integrity.
    if(lpls->bFragCount < 1 || lpls->bFragCount > MAX_IMAGE_FRAGMENTS)
    {
        return ERROR_INVALIDIMAGE;
    }
    
    // Copy the Lead Sector
    MemCopy(lpLeadSector, lpls, sizeof(LEADSECTOR));
    
    // Return the offset to the first data area
    if(lpdwFirstData)
    {
        if(fOldImage)
        {
            if(lpLeadSector->bSequence == 0)
            {
                *lpdwFirstData = (2 + (lpLeadSector->Reserved1 ? lpLeadSector->Reserved1 : lpLeadSector->dwCompBitmapSize)) * CBSEC;
            }
            else
            {
                *lpdwFirstData = 2 * CBSEC;
            }
        }
        else
        {
            *lpdwFirstData = (2 + lpLeadSector->dwCompBitmapSize + lpLeadSector->dwAllocBitmapSize) * CBSEC;
        }
    }

    // Update the Lead Sector to the 3.0 format
    if(fOldImage)
    {
        if(lpLeadSector->bFragCount == 1)
        {
            lpLeadSector->dwClustersPerFrag = lpLeadSector->dwClusterCount;
        }
        
        lpLeadSector->dwCompBitmapSize = 0;
        lpLeadSector->dwAllocBitmapSize = 0;
        lpLeadSector->dwFirstCluster = lpLeadSector->dwClustersPerFrag * lpLeadSector->bSequence;
        lpLeadSector->dwLastCluster = lpLeadSector->dwFirstCluster + lpLeadSector->dwClustersPerFrag - 1;
        lpLeadSector->fCompleted = TRUE;
    }

    // Return success
    return ERROR_NONE;
}


// Writes the image header (Pad Sector and Lead Sector)
int WriteImageHeader(FILEHANDLE fhImage, LPLEADSECTOR lpLeadSector, LPDWORD lpdwFirstData)
{
    BYTE                    bSector[CBSEC];

    // Seek to the beginning of the file
    FileSetPos(fhImage, 0, SEEK_SET);

    // Write the Pad Sector
    MemSet(&bSector, 0xFF, CBSEC - 2);

    bSector[CBSEC - 2] = sig30[0];
    bSector[CBSEC - 1] = sig30[1];
    
    if(FileWrite(fhImage, &bSector, CBSEC) != CBSEC)
    {
        return ERROR_FILEWRITE;
    }
    
    // Write the Lead Sector    
    MemCopy(&bSector, lpLeadSector, sizeof(LEADSECTOR));
    MemSet((LPBYTE)&bSector + sizeof(LEADSECTOR), 0, CBSEC - sizeof(LEADSECTOR));
    
    if(FileWrite(fhImage, &bSector, CBSEC) != CBSEC)
    {
        return ERROR_FILEWRITE;
    }
    
    // Return the offset to the first data area
    if(lpdwFirstData)
    {
        *lpdwFirstData = (2 + lpLeadSector->dwCompBitmapSize + lpLeadSector->dwAllocBitmapSize) * CBSEC;
    }

    // Return success
    return ERROR_NONE;
}


// Determines whether an aborted image can be recovered
BOOL CanRecoverImage(FILEHANDLE fhImage, BYTE bDrive)
{
    BYTE                    bSector[2][CBSEC];
    LEADSECTOR              ls;
    DWORD                   dwFirstData;
    RRBOOTSECTOR            bsImage;
    RRBOOTSECTOR            bsDrive;
    WORD                    i;
    int						nRet;

    // Read the image header
    if(ReadImageHeader(fhImage, &ls, &dwFirstData, TRUE))
    {
        return FALSE;
    }
    
    // Can't safely recover an image with allocated clusters only or compression
    if(ls.dwAllocBitmapSize || ls.dwCompBitmapSize)
    {
        return FALSE;
    }

    // Seek to the first data byte
    FileSetPos(fhImage, dwFirstData, SEEK_SET);

    // Read the boot sector from the image
    if(FileRead(fhImage, &bSector[0], CBSEC) != CBSEC)
    {
        return FALSE;
    }

    // Read the boot sector from the drive
    if(!ReadSector(bDrive, &bSector[1], 0, 1))
    {
        return FALSE;
    }
    
    // Compare the boot sectors
    if(MemCmp(&bSector[0], &bSector[1], CBSEC))
    {
        return FALSE;
    }

    // Convert the boot sectors
    if(nRet = ConvertBootSector((LPBGBOOTSECTOR)&bSector[0], &bsImage))
    {
        return FALSE;
    }

    if(nRet = ConvertBootSector((LPBGBOOTSECTOR)&bSector[1], &bsDrive))
    {
        return FALSE;
    }
    
    // Compare the FATs
    for(i = 0; i < bsImage.dwFATSize; i++)
    {
        if(FileRead(fhImage, &bSector[0], CBSEC) != CBSEC)
        {
            return FALSE;
        }
        
        if(!ReadSector(bDrive, &bSector[1], i + 1, 1))
        {
            return FALSE;
        }
        
        if(MemCmp(&bSector[0], &bSector[1], CBSEC))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}


int GetClustersInFragment(LPLEADSECTOR lpLeadSector, LPIMGBITMAP lpAllocBitmap, LPDWORD lpdwClusters)
{
    DWORD                   dwCluster;
    BOOL                    fSet;
    int                     nRet;
    
    *lpdwClusters = lpLeadSector->dwClustersPerFrag;
    
    if(lpLeadSector->dwAllocBitmapSize && lpAllocBitmap)
    {
        for(dwCluster = 0; dwCluster < *lpdwClusters; dwCluster++)
        {
            if(nRet = GetBitmapBit(lpAllocBitmap, dwCluster, &fSet))
            {
                return nRet;
            }
            
            if(fSet)
            {
                (*lpdwClusters)++;
            }
        }
    }
    
    return ERROR_NONE;
}


int GetDriveInfo(BYTE bDrive, LPDRIVEINFO lpDrive)
{
    BGBOOTSECTOR            bs;
    int                     nRet;
    
    // Initialize the structure
    MemSet(lpDrive, 0, sizeof(DRIVEINFO));

    lpDrive->bDrive = bDrive;

    // Get the DPB
    if(!GetDPB(bDrive, &(lpDrive->dpb)))
    {
        return ERROR_DPB;
    }
    
    // Read the DOS boot sector
    if(!ReadSector(bDrive, &bs, 0, 1))
    {
        return ERROR_DRIVEREAD;
    }

    // Convert the DOS boot sector to our own internal version
    if(nRet = ConvertBootSector(&bs, &(lpDrive->bs)))
    {
        return nRet;
    }

    // Return success
    return ERROR_NONE;
}


int ConvertBootSector(LPBGBOOTSECTOR lpSource, LPRRBOOTSECTOR lpDest)
{
    LPBOOTSECTOR            lpbs;
    UINT                    i;

    // Check for NT FAT16
    if(!lpSource->bpb.wSectorSize || lpSource->bpb.wSectorSize > CBSEC)
    {
        return ERROR_UNSUPPORTEDFS;
    }

    if(lpSource->bpb.bSectorsPerCluster > 64)
    {
        return ERROR_DRIVECLUSTERSTOOBIG;
    }

    // Save the original boot sector
    MemCopy(&(lpDest->bsOriginal), lpSource, sizeof(BGBOOTSECTOR));

    // Save the important parts of the boot sector
    lpDest->dwSectorSize = lpSource->bpb.wSectorSize;
    DPF("dwSectorSize = %lu", lpDest->dwSectorSize);
     
    lpDest->dwSectorsPerCluster = lpSource->bpb.bSectorsPerCluster;
    DPF("dwSectorsPerCluster = %lu", lpDest->dwSectorsPerCluster);

    lpDest->dwReservedSectors = lpSource->bpb.wReservedSectors;
    DPF("dwReservedSectors = %lu", lpDest->dwReservedSectors);

    lpDest->dwFATCount = lpSource->bpb.bFATCount;
    DPF("dwFATCount = %lu", lpDest->dwFATCount);

    lpDest->dwFATSize = lpSource->bpb.wFATSize ? lpSource->bpb.wFATSize : lpSource->bpb.dwBigFATSize;
    DPF("dwFATSize = %lu", lpDest->dwFATSize);

    lpDest->dwRootDirEntries = lpSource->bpb.wRootDirEntries;
    DPF("dwRootDirEntries = %lu", lpDest->dwRootDirEntries);

    lpDest->dwPreDataSectors = lpDest->dwReservedSectors + (lpDest->dwFATCount * lpDest->dwFATSize) + ((lpDest->dwRootDirEntries * 32) / lpDest->dwSectorSize);
    DPF("dwPreDataSectors = %lu", lpDest->dwPreDataSectors);

    lpDest->dwTotalSectors = lpSource->bpb.wTotalSectors ? lpSource->bpb.wTotalSectors : lpSource->bpb.dwBigTotalSectors;
    DPF("dwTotalSectors = %lu", lpDest->dwTotalSectors);

    lpDest->dwTotalClusters = (lpDest->dwTotalSectors - lpDest->dwPreDataSectors) / lpDest->dwSectorsPerCluster;
    DPF("dwTotalClusters = %lu", lpDest->dwTotalClusters);

    lpDest->dwUsableSectors = lpDest->dwPreDataSectors + (lpDest->dwTotalClusters * lpDest->dwSectorsPerCluster);
    DPF("dwUsableSectors = %lu", lpDest->dwUsableSectors);

    if(lpDest->dwTotalClusters < 4096)
    {
        lpDest->dwBitsPerFATEntry = 12;
    }
    else if(lpDest->dwTotalClusters < 65526)
    {
        lpDest->dwBitsPerFATEntry = 16;
    }
    else
    {
        lpDest->dwBitsPerFATEntry = 32;
    }

    DPF("dwBitsPerFATEntry = %lu", lpDest->dwBitsPerFATEntry);

    if(lpSource->bpb.wFATSize)
    {
        lpbs = (LPBOOTSECTOR)lpSource;

        for(i = 0; i < sizeof(lpbs->abVolumeLabel); i++)
        {
            lpDest->szVolumeLabel[i] = lpbs->abVolumeLabel[i];
        }

        for(i = sizeof(lpbs->abVolumeLabel) - 1; i >= 0; i--)
        {
            if(' ' == lpDest->szVolumeLabel[i])
            {
                lpDest->szVolumeLabel[i] = 0;
            }
            else
            {
                break;
            }
        }

        for(i = 0; i < sizeof(lpbs->abFSType); i++)
        {
            lpDest->szFSType[i] = lpbs->abFSType[i];
        }

        for(i = sizeof(lpbs->abFSType) - 1; i >= 0; i--)
        {
            if(' ' == lpDest->szFSType[i])
            {
                lpDest->szFSType[i] = 0;
            }
            else
            {
                break;
            }
        }
    }
    else
    {
        for(i = 0; i < sizeof(lpSource->abVolumeLabel); i++)
        {
            lpDest->szVolumeLabel[i] = lpSource->abVolumeLabel[i];
        }

        for(i = sizeof(lpSource->abVolumeLabel) - 1; i >= 0; i--)
        {
            if(' ' == lpDest->szVolumeLabel[i])
            {
                lpDest->szVolumeLabel[i] = 0;
            }
            else
            {
                break;
            }
        }

        for(i = 0; i < sizeof(lpSource->abFSType); i++)
        {
            lpDest->szFSType[i] = lpSource->abFSType[i];
        }

        for(i = sizeof(lpSource->abFSType) - 1; i >= 0; i--)
        {
            if(' ' == lpDest->szFSType[i])
            {
                lpDest->szFSType[i] = 0;
            }
            else
            {
                break;
            }
        }

    }

    DPF("szVolumeLabel = %s", lpDest->szVolumeLabel);
    DPF("szFSType = %s", lpDest->szFSType);

    // Return success
    return ERROR_NONE;
}


#ifdef WIN32

BOOL CALLBACK FragListDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPGETFRAGNAMES       lpgfn;
    DWORD                       i;
    int                         nSel;
    
    switch(uMsg)
    {
        case WM_INITDIALOG:
            lpgfn = (LPGETFRAGNAMES)lParam;

            // Add each fragment to the list box
            for(i = lpgfn->dwFirst; i < lpgfn->dwCount; i++)
            {
                SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_ADDSTRING, 0, (LPARAM)(lpgfn->lpszList + MAX_PATH));
            }

            SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_SETCURSEL, 0, 0);

            break;

        case WM_CLOSE:
            EndDialog(hWnd, ERROR_USERCANCEL);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hWnd, ERROR_NONE);

                    break;

                case IDCANCEL:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);

                    break;

                case IDC_FRAGLIST:
                    if(HIWORD(wParam) != LBN_DBLCLK)
                    {
                        break;
                    }

                    // fall through

                case IDC_CHANGE:
                    if((nSel = SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_GETCURSEL, 0, 0)) == LB_ERR)
                    {
                        MessageBeep(MB_ICONEXCLAMATION);
                        break;
                    }
                    
                    if(GetFragmentName(hWnd, nSel + lpgfn->dwFirst + 1, lpgfn->lpszList + (MAX_PATH * (nSel + lpgfn->dwFirst))))
                    {
                        SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_DELETESTRING, nSel, 0);
                        SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_INSERTSTRING, nSel, (LPARAM)(lpgfn->lpszList + (MAX_PATH * (nSel + lpgfn->dwFirst))));
                        SendDlgItemMessage(hWnd, IDC_FRAGLIST, LB_SETCURSEL, nSel, 0);
                    }

                    break;
            }

            break;
    }

    return FALSE;
}

#endif // WIN32


void GetDefaultFragNames(LPSTR lpszFile, LPIMAGESTRUCT lpImage, DWORD dwFirst, DWORD dwCount)
{
    char                        szDrivePart[_MAX_DRIVE] = { 0 };
    char                        szDirPart[_MAX_DIR] = { 0 };
    char                        szFilePart[_MAX_FNAME] = { 0 };
    char                        szExtPart[_MAX_EXT] = { 0 };
    char                        szPath[MAX_PATH];
    int                         nPathLen;
    int                         nExtLen;
    LPSTR                       lpsz;
    DWORD                       i;

    if(lpszFile && *lpszFile)
    {
        // Separate the file name into it's component parts
        _splitpath(lpszFile, szDrivePart, szDirPart, szFilePart, szExtPart);

#ifndef WIN32

        // The filename may have been generated from the image label.  If this is
        // the case, remove any invalid characters.
        for(lpsz = szFilePart; *lpsz; lpsz++)
        {
            if(' ' == *lpsz)
            {
                *lpsz = '_';
            }
        }

#endif // WIN32

    }

    if(!szFilePart[0])
    {
        StrCpy(szFilePart, "Unnamed");
    }

    if(!szExtPart[0])
    {
        StrCpy(szExtPart, ".img");
    }

    _makepath(szPath, szDrivePart, szDirPart, szFilePart, szExtPart);

    nPathLen = GetFullPathInPlace(szPath, MAX_PATH);
    nExtLen = StrLen(szExtPart) - 1;
        
    // Fill in the fragment names
    for(i = dwFirst; dwCount; dwCount--, i++)
    {
        if(i > 0)
        {
            lpsz = &szPath[nPathLen - nExtLen];
            
            if((i + 1 < 100) && (nExtLen >= 1))
            {
                lpsz++;
            
                if((i + 1 < 10) && (nExtLen >= 2))
                {
                    lpsz++;
                }
            }

            itoa((int)(i + 1), lpsz, 10);
        }

        StrCpy(lpImage->aszFragNames[i], szPath);
    }
}


int GetFragNames(LPIMAGESTRUCT lpImage, DWORD dwFirst, DWORD dwCount)
{

#ifdef WIN32

    GETFRAGNAMES                gfn;
    int                         nRet;

#else // WIN32

    char                        szFile[MAX_PATH];
    DWORD                       i;

#endif // WIN32

    if(!dwCount)
    {
        return ERROR_NONE;
    }

#ifdef WIN32

    gfn.dwFirst = dwFirst;
    gfn.dwCount = dwCount;
    gfn.lpszList = lpImage->aszFragNames[0];

    if(nRet = DialogBoxParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_FRAGLIST), lpImage->hWnd, FragListDlgProc, (LPARAM)&gfn))
    {
        return nRet;
    }

#else // WIN32

    for(i = dwFirst; dwCount; dwCount--, i++)
    {
        while(TRUE)
        {
            printf("Enter the filename for fragment %lu:  ", i + 1);
            gets(szFile);
            
            if(StrLen(szFile))
            {
                if(!ValidateFileName(lpImage->aszFragNames[i]))
                {
                    GetFullPath(lpImage->aszFragNames[i], szFile, MAX_PATH);
                    break;
                }
            }
        }
    }

    printf(CRLF);

#endif // WIN32

    return ERROR_NONE;
}


FILEHANDLE OpenFragmentForRead(BYTE bFrag, LPIMAGESTRUCT lpImage)
{
    FILEHANDLE              fhImage = INVALID_FILE_HANDLE;

    while((fhImage = FileOpen(lpImage->aszFragNames[bFrag], OPEN_ACCESS_READONLY, 0, ACTION_FILE_OPEN)) == INVALID_FILE_HANDLE)
    {

#ifdef WIN32

        ImageMessageBox(lpImage->hWnd, MB_ICONEXCLAMATION, "Unable to open %s", lpImage->aszFragNames[bFrag]);
        
        if(!GetFileName(lpImage->hWnd, "Please enter the correct path...", lpImage->aszFragNames[bFrag]))
        {
            return INVALID_FILE_HANDLE;
        }

#else // WIN32

        FlushKeyboardBuffer();
        
        printf(CRLF "Unable to open %s" CRLF, lpImage->aszFragNames[bFrag]);
        printf("Please enter the correct path:  ");
        
        gets(lpImage->aszFragNames[bFrag]);
        
        printf(CRLF);

#endif // WIN32

    }
    
    return fhImage;
}


FILEHANDLE OpenFragmentForWrite(BYTE bFrag, LPIMAGESTRUCT lpImage)
{
    FILEHANDLE              fhImage = INVALID_FILE_HANDLE;
    
    if((fhImage = FileOpen(lpImage->aszFragNames[bFrag], OPEN_ACCESS_READWRITE, ATTR_NORMAL, ACTION_FILE_CREATE)) == INVALID_FILE_HANDLE)
    {
        if((lpImage->wFlags & OPTIONS_OVERWRITE) || (lpImage->wFlags & OPTIONS_FORCE))
        {
            fhImage = FileOpen(lpImage->aszFragNames[bFrag], OPEN_ACCESS_READWRITE, 0, ACTION_FILE_TRUNCATE);
        }
        else
        {
            if(AskUser(lpImage, "%s already exists." CRLF "Would you like to overwrite this file?", lpImage->aszFragNames[bFrag]))
            {
                fhImage = FileOpen(lpImage->aszFragNames[bFrag], OPEN_ACCESS_READWRITE, 0, ACTION_FILE_TRUNCATE);
            }
            else
            {
                fhImage = INVALID_FILE_HANDLE;
            }
        }
    }
            
    return fhImage;
}


BOOL ReadSectorEx(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, DWORD dwCount, DWORD dwSectorSize)
{
    LPBYTE                  lpbBuffer   = (LPBYTE)lpvBuffer;
    WORD                    wCount;
    BOOL                    fSuccess;

    while(dwCount)
    {
        wCount = (WORD)min(dwCount, SECTORIO_MAX_SECTORS);
        fSuccess = ReadSector(bDrive, lpbBuffer, dwSector, wCount);

        if(!fSuccess)
        {
            return FALSE;
        }

        lpbBuffer += wCount * dwSectorSize;
        dwSector += wCount;
        dwCount -= wCount;
    }

    return TRUE;
}


BOOL WriteSectorEx(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, DWORD dwCount, DWORD dwSectorSize)
{
    LPBYTE                  lpbBuffer   = (LPBYTE)lpvBuffer;
    WORD                    wCount;
    BOOL                    fSuccess;

    while(dwCount)
    {
        wCount = (WORD)min(dwCount, SECTORIO_MAX_SECTORS);
        fSuccess = WriteSector(bDrive, lpbBuffer, dwSector, wCount);

        if(!fSuccess)
        {
            return FALSE;
        }

        lpbBuffer += wCount * dwSectorSize;
        dwSector += wCount;
        dwCount -= wCount;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\mem.c ===
#ifndef WIN32
#include <malloc.h>
#include <memory.h>
#endif // WIN32

#include "defs.h"
#include "mem.h"


LPVOID MemAlloc(UINT uBytes)
{

#if defined(WIN32) || defined(WIN16)

    return (LPVOID)LocalAlloc(LPTR, uBytes);

#else // WIN32

    return _fmalloc((size_t)uBytes);

#endif // _WIN32

}


LPVOID MemReAlloc(LPVOID lpvBlock, UINT uBytes)
{
    LPVOID                  lpvNewBlock;
    
    // Be nice
    if(!lpvBlock)
    {
        return MemAlloc(uBytes);
    }
    
    // Attempt to reallocate
    if(!(lpvNewBlock = MemAlloc(uBytes)))
    {
        return NULL;
    }

    MemCopy(lpvNewBlock, lpvBlock, min(uBytes, MemSize(lpvBlock)));
    MemFree(lpvBlock);

    return lpvNewBlock;
}


void MemFree(LPVOID lpvBlock)
{

#if defined(WIN32) || defined(WIN16)

    LocalFree((HLOCAL)lpvBlock);

#else // WIN32

    _ffree(lpvBlock);

#endif // WIN32

}


void MemCopy(LPVOID lpvDest, LPVOID lpvSrc, UINT uBytes)
{

#ifdef WIN32

    CopyMemory(lpvDest, lpvSrc, uBytes);

#else // WIN32

    _fmemcpy(lpvDest, lpvSrc, (size_t)uBytes);

#endif // WIN32

}


void MemSet(LPVOID lpvBlock, BYTE bFill, UINT uBytes)
{

#ifdef WIN32

    FillMemory(lpvBlock, uBytes, bFill);

#else // WIN32

    _fmemset(lpvBlock, bFill, (size_t)uBytes);

#endif // WIN32

}


int MemCmp(LPVOID lpvBlockA, LPVOID lpvBlockB, UINT dwSize)
{

#ifdef WIN32

    LPBYTE                  lpba, lpbb;

    lpba = (LPBYTE)lpvBlockA;
    lpbb = (LPBYTE)lpvBlockB;

    while(dwSize--)
    {
        if(*lpba != *lpbb)
        {
            return *lpba - *lpbb;
        }

        lpba++;
        lpbb++;
    }

    return 0;

#else // WIN32

    return _fmemcmp(lpvBlockA, lpvBlockB, (size_t)dwSize);

#endif // WIN32

}


UINT MemSize(LPVOID lpvBlock)
{

#ifdef WIN32

    return LocalSize((HLOCAL)lpvBlock);

#else

    return _fmsize(lpvBlock);

#endif // WIN32

}


void MemBogify(LPVOID lpvBlock, DWORD dwSize)
{
    LPBYTE                  lpb = (LPBYTE)lpvBlock;

    while(dwSize)
    {
        *lpb = ~*lpb;

        dwSize--;
        lpb++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\mrcicode.h ===
#ifndef _INC_MRCICODE
#define _INC_MRCICODE

#include "defs.h"

#ifdef __cplusplus
extern "C" {
#endif

extern WORD Mrci1MaxCompress(LPBYTE, WORD, LPBYTE, WORD);
extern WORD Mrci1Decompress(LPBYTE, WORD, LPBYTE, WORD);
extern WORD Mrci2MaxCompress(LPBYTE, WORD, LPBYTE, WORD);
extern WORD Mrci2Decompress(LPBYTE, WORD, LPBYTE, WORD);

#ifdef __cplusplus
}
#endif

#endif // _INC_MRCICODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

#include "defs.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern LPVOID MemAlloc(UINT);
extern LPVOID MemReAlloc(LPVOID, UINT);
extern void MemFree(LPVOID);
extern void MemCopy(LPVOID, LPVOID, UINT);
extern void MemSet(LPVOID, BYTE, UINT);
extern int MemCmp(LPVOID, LPVOID, UINT);
extern UINT MemSize(LPVOID);
extern void MemBogify(LPVOID, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\rawinfo.c ===
#include <stdlib.h>
#include <stdio.h>
#include "bitmap.h"
#include "defs.h"
#include "file.h"
#include "image.h"
#include "text.h"


int main(int argc, char **argv)
{
    FILEHANDLE                  hFile;
    LEADSECTOR                  ls;
    DWORD                       dwFirstData;
    IMGBITMAP                   bitmap;
    DWORD                       dwCluster;
    BOOL                        fSet;
    DWORD                       dwCount;
    int                         nRet;
    
    GoPropaganda();
    
    if((hFile = FileOpenForRead(argv[1])) == -1)
    {
        return ErrorMsg(ERROR_FILEOPEN);
    }
    
    if(nRet = ReadImageHeader(hFile, &ls, &dwFirstData))
    {
        return ErrorMsg(nRet);
    }
    
    printf("===============================================================================\n");
    printf("Image header\n");
    printf("===============================================================================\n");
    
    printf("dwClusterCount:     %lu\n", ls.dwClusterCount);
    printf("bSequence:          %u\n", ls.bSequence);
    printf("bFragCount:         %u\n", ls.bFragCount);
    printf("dwClustersPerFrag:  %lu\n", ls.dwClustersPerFrag);
    printf("szNextFrag:         %s\n", ls.szNextFrag);
    printf("Reserved1:          %u\n", ls.Reserved1);
    printf("wFlags:             %u %s%s\n", ls.wFlags, (ls.wFlags & OPTIONS_COMPRESS) ? "compress " : "", (ls.wFlags & OPTIONS_ALLOCATED) ? "allocated " : "");
    printf("Reserved2:          %lu\n", ls.Reserved2);
    printf("dwCompBitmapSize:   %lu\n", ls.dwCompBitmapSize);
    printf("dwAllocBitmapSize:  %lu\n", ls.dwAllocBitmapSize);
    printf("dwFirstCluster:     %lu\n", ls.dwFirstCluster);
    printf("dwLastCluster:      %lu\n", ls.dwLastCluster);
    printf("fCompleted:         %s\n", ls.fCompleted ? "TRUE" : "FALSE");
    printf("\n");
    printf("First data byte:    %lu\n", dwFirstData);
    printf("\n");
    
    if(ls.dwCompBitmapSize > 0)
    {
        if(nRet = InitBitmap(&bitmap, ls.dwCompBitmapSize, hFile, 2, TRUE))
        {
            return ErrorMsg(nRet);
        }
        
        printf("===============================================================================\n");
        printf("Compressed clusters\n");
        printf("===============================================================================\n");
        
        dwCount = 0;
        
        for(dwCluster = 0; dwCluster <= ls.dwLastCluster; dwCluster++)
        {
            if(nRet = GetBitmapBit(&bitmap, dwCluster, &fSet))
            {
                return ErrorMsg(nRet);
            }
            
            if(fSet)
            {
                printf("%lu\t", dwCluster + ls.dwFirstCluster + 2);
                dwCount++;
            }
        }
        
        if(nRet = DiscardBitmap(&bitmap))
        {
            return ErrorMsg(nRet);
        }
        
        printf("\n\n%lu compressed clusters found.\n\n", dwCount);
    }
        
    if(ls.dwCompBitmapSize > 0)
    {
        if(nRet = InitBitmap(&bitmap, ls.dwCompBitmapSize, hFile, 2 + ls.dwCompBitmapSize, TRUE))
        {
            return ErrorMsg(nRet);
        }
        
        printf("===============================================================================\n");
        printf("Unallocated clusters\n");
        printf("===============================================================================\n");
        
        dwCount = 0;
        
        for(dwCluster = 0; dwCluster <= ls.dwLastCluster; dwCluster++)
        {
            if(nRet = GetBitmapBit(&bitmap, dwCluster, &fSet))
            {
                return ErrorMsg(nRet);
            }
            
            if(fSet)
            {
                printf("%lu\t", dwCluster + ls.dwFirstCluster + 2);
                dwCount++;
            }
        }
        
        if(nRet = DiscardBitmap(&bitmap))
        {
            return ErrorMsg(nRet);
        }
        
        printf("\n\n%lu unallocated clusters found.\n\n", dwCount);
    }
        
    FileClose(hFile);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#include "defs.h"
#include "mrcicode.h"                   /* prototype verification */

#pragma warning(disable:4704)           /* no in-line ASM bickering */
#pragma warning(disable:4761)           /* no size mismatch bickering */

#ifndef NDEBUG
#define NDEBUG                          /* turn off assertions */
#endif

#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         (((unsigned short FAR *)(p))[0])
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

static WORD abits;                  /* Array of bits */
static WORD cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed; /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static WORD FAR ahash[CHASH];      /* Hash table */
static WORD FAR alink[MAXDISPBIG]; /* Links */


/* compression internal functions */

#define  FAST  NEAR PASCAL            /* speed up local calls */

static void FAST inithash(void);
static void FAST charbuf(WORD c);
static void FAST putbits(WORD bits,WORD cbits);
static void FAST outlength(WORD cb);

static void FAST mrci1outsingle(WORD ch);
static void FAST mrci1outstring(WORD disp,WORD cb);

static void FAST mrci2outsingle(WORD ch);
static void FAST mrci2outstring(WORD disp,WORD cb);


/* decompression internal functions */

static WORD FAST getbit(void);
static WORD FAST getbits(WORD cbits);
static void FAST expandstring(unsigned char FAR **ppchout,WORD disp,
        WORD cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    WORD FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (WORD) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(WORD c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(WORD ab,WORD cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(WORD cb)
{
    WORD alogbits, clogbits;
    WORD avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(WORD ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(WORD ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(WORD disp,WORD cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(WORD disp,WORD cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

WORD Mrci1MaxCompress(unsigned char FAR *pchbase,WORD cchunc,
        unsigned char FAR *pchcmpBase,WORD cchcmpMax)
{
    WORD cchbest;                   /* Length of best match */
    WORD cchmatch;                  /* Length of this match */
    WORD ibest;                     /* Position of best match */
    WORD icur;                      /* Current position */
    WORD ihash;                     /* Hash table index */
    WORD ilink;                     /* Link index */
    unsigned char FAR *pch;            /* Char pointer */
    unsigned char FAR *pch2;           /* Char pointer */
    unsigned char FAR *pchend;         /* End of input (-> last valid) */
    WORD cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((WORD) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((WORD) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (WORD)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (WORD) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((WORD) (pCompressed - pchcmpBase) > cchunc)
    {
        return((WORD) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

WORD Mrci2MaxCompress(unsigned char FAR *pchbase,WORD cchunc,
        unsigned char FAR *pchcmpBase,WORD cchcmpMax)
{
    WORD cchbest;                   /* Length of best match */
    WORD cchmatch;                  /* Length of this match */
    WORD ibest;                     /* Position of best match */
    WORD icur;                      /* Current position */
    WORD ihash;                     /* Hash table index */
    WORD ilink;                     /* Link index */
    unsigned char FAR *pch;            /* Char pointer */
    unsigned char FAR *pch2;           /* Char pointer */
    unsigned char FAR *pchend;         /* End of input (-> last valid) */
    WORD cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((WORD) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((WORD) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (WORD)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (WORD) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((WORD) (pCompressed - pchcmpBase) > cchunc)
    {
        return((WORD) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static WORD FAST getbit(void)
{
    WORD bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static WORD FAST getbits(WORD cbits)
{
    WORD bits;                      /* Bits to return */
    WORD cbitsdone;                 /* number of bits added so far */
    WORD cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,WORD disp,
        WORD cb)
{
    unsigned char FAR *source;         /* Easier for ASM to pick up */
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    _asm
    {
        cld                             ; assure direction
        mov     ax,ds                   ; preserve DS
        mov     cx,cb                   ; get byte count
        les     di,target               ; get target pointer
        lds     si,source               ; get source pointer
        rep     movsb                   ; copy
        mov     ds,ax                   ; restore DS
    }

    *ppchout += cb;                     /* Update the output pointer */
}


/*
 *  (MRCI1) Decompress
 */

WORD Mrci1Decompress(unsigned char FAR *pchin,WORD cchin,
        unsigned char FAR *pchdecBase,WORD cchdecMax)
{
    WORD b;                         /* A byte */
    WORD length;                    /* Length of match */
    WORD disp;                      /* Displacement */
    unsigned char FAR *pchout;         /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((WORD) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((WORD) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((WORD) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

WORD Mrci2Decompress(unsigned char FAR *pchin,WORD cchin,
        unsigned char FAR *pchdecBase,WORD cchdecMax)
{
    WORD length;                    /* Length of match */
    WORD disp;                      /* Displacement */
    unsigned char FAR *pchout;         /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((WORD) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((WORD) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((WORD) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\image.h ===
#ifndef _INC_IMAGE
#define _INC_IMAGE

#include "bitmap.h"
#include "bootsec.h"
#include "defs.h"
#include "diskutil.h"

// Maximum number of image fragments
#define MAX_IMAGE_FRAGMENTS     0xFF

#pragma pack(1)

typedef struct tagLEADSECTOR
{
    DWORD                       dwClusterCount;     // Count of clusters in the image
    BYTE                        bSequence;          // Image fragment sequence number
    BYTE                        bFragCount;         // Count of fragments in the image
    DWORD                       dwClustersPerFrag;  // Count of clusters per fragment
    char                        szNextFrag[13];     // 8.3 DOS filename of next fragment in sequence
    BYTE                        Reserved1;          // Reserved - formally compression bitmap size
    WORD                        wFlags;             // Options used when image was created
    DWORD                       Reserved2;          // Reserved
    DWORD                       dwCompBitmapSize;   // Count of sectors in the compression bitmap for this fragment
    DWORD                       dwAllocBitmapSize;  // Count of sectors in the allocation bitmap for this fragment
    DWORD                       dwFirstCluster;     // First cluster in this fragment
    DWORD                       dwLastCluster;      // Last cluster in this fragment
    BOOL                        fCompleted;         // Was image fragment completed successfully?
    char                        szComment[0x100];   // NULL-terminated comment string
} LEADSECTOR, *PLEADSECTOR, FAR *LPLEADSECTOR;

typedef struct tagIMAGESTRUCT
{
    WORD                        wFlags;                                         // Options/flags
    DWORD                       dwMaxFragSize;                                  // Maximum fragment size (in megabytes)
    char                        aszFragNames[MAX_IMAGE_FRAGMENTS][MAX_PATH];    // Fragment names
    LEADSECTOR                  ls;                                             // Lead sector
    DWORD                       dwCurrentCluster;                               // Current cluster
    FILEHANDLE                  fhImage;                                        // Current image fragment file handle
    LPBYTE                      lpbReadBuffer;                                  // Buffer to read into
    LPBYTE                      lpbWriteBuffer;                                 // Buffer to write from
    IMGBITMAP                   ibmpCompression;                                // Compression bitmap
    IMGBITMAP                   ibmpAllocation;                                 // Allocation bitmap

#ifdef WIN32

    HWND                        hWnd;                                           // Main window handle

#endif // WIN32

} IMAGESTRUCT, *PIMAGESTRUCT, FAR *LPIMAGESTRUCT;

typedef struct tagRRBOOTSECTOR
{
    BGBOOTSECTOR                bsOriginal;         // The original boot sector
    DWORD                       dwSectorSize;       // Sector size (in bytes)
    DWORD                       dwSectorsPerCluster;// Cluster size (in sectors)
    DWORD                       dwReservedSectors;  // Count of reserved sectors
    DWORD                       dwFATCount;         // Count of FATs
    DWORD                       dwFATSize;          // FAT size (each, in sectors)
    DWORD                       dwBitsPerFATEntry;  // Count of bits in each FAT entry
    DWORD                       dwRootDirEntries;   // Count of root directory entries (FAT12/FAT16 only)
    DWORD                       dwPreDataSectors;   // Count of sectors prior to first cluster
    DWORD                       dwTotalSectors;     // Count of sectors
    DWORD                       dwUsableSectors;    // Count of usable sectors
    DWORD                       dwTotalClusters;    // Count of clusters
    char                        szVolumeLabel[12];  // Volume label
    char                        szFSType[9];        // File system type
} RRBOOTSECTOR, *PRRBOOTSECTOR, FAR *LPRRBOOTSECTOR;

typedef struct tagDRIVEINFO
{
    BYTE                        bDrive;             // 0-based drive number
    DPB                         dpb;                // DPB
    RRBOOTSECTOR                bs;                 // Boot sector
    DWORD                       dwUnusedClusters;   // Count of unallocated clusters
    DWORD                       dwBadClusters;      // Count of bad clusters
    LPDWORD                     adwBadClusters;     // Bad cluster list
} DRIVEINFO, *PDRIVEINFO, FAR *LPDRIVEINFO;

typedef struct tagEVERYTHING
{
    LPIMAGESTRUCT               lpImage;            // Image information
    LPDRIVEINFO                 lpDrive;            // Drive information
} EVERYTHING, *PEVERYTHING, FAR *LPEVERYTHING;

#pragma pack()

// Image signatures
extern const char               sig11[];
extern const char               sig30[];

__inline DWORD SectorToCluster(LPRRBOOTSECTOR lpbs, DWORD dwSector)
{
    return (dwSector - lpbs->dwPreDataSectors) / (lpbs->dwSectorsPerCluster + 2);
}

__inline DWORD ClusterToSector(LPRRBOOTSECTOR lpbs, DWORD dwCluster)
{
    return lpbs->dwPreDataSectors + ((dwCluster - 2) * lpbs->dwSectorsPerCluster);
}

#ifdef __cplusplus
extern "C" {
#endif

// Prototypes
extern int ReadImageHeader(FILEHANDLE, LPLEADSECTOR, LPDWORD, BOOL);
extern int WriteImageHeader(FILEHANDLE, LPLEADSECTOR, LPDWORD);
extern BOOL CanRecoverImage(FILEHANDLE, BYTE);
extern int GetClustersInFragment(LPLEADSECTOR, LPIMGBITMAP, LPDWORD);
extern int GetDriveInfo(BYTE, LPDRIVEINFO);
extern int ConvertBootSector(LPBGBOOTSECTOR, LPRRBOOTSECTOR);
extern void GetDefaultFragNames(LPSTR, LPIMAGESTRUCT, DWORD, DWORD);
extern int GetFragNames(LPIMAGESTRUCT, DWORD, DWORD);
extern FILEHANDLE OpenFragmentForRead(BYTE, LPIMAGESTRUCT);
extern FILEHANDLE OpenFragmentForWrite(BYTE, LPIMAGESTRUCT);
extern BOOL ReadSectorEx(BYTE, LPVOID, DWORD, DWORD, DWORD);
extern BOOL WriteSectorEx(BYTE, LPVOID, DWORD, DWORD, DWORD);

#ifdef __cplusplus
}
#endif

#endif // _INC_IMAGE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\rawread.c ===
#ifdef WIN32
#include <windows.h>
#include <commctrl.h>
#include "win32\reg.h"
#include "win32\resource.h"
#include "win32\winmisc.h"
#else // WIN32
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#endif // WIN32

#include <string.h>
#include <direct.h>
#include "bitmap.h"
#include "bootsec.h"
#include "compress.h"
#include "debug.h"
#include "defs.h"
#include "diskutil.h"
#include "fatutil.h"
#include "file.h"
#include "image.h"
#include "mem.h"
#include "text.h"


// Local prototypes
int GetImage(LPEVERYTHING);
int RecoverImage(LPEVERYTHING);
int EnterMainLoop(LPEVERYTHING);
int NextFragment(LPEVERYTHING);
int OpenFragment(BYTE, LPEVERYTHING);
int CloseFragment(LPEVERYTHING);
int VerifyFileWrite(FILEHANDLE, LPVOID, LPVOID, DWORD, WORD);
int DumpInfo(LPEVERYTHING);

#ifdef WIN32

LPARAM CALLBACK MainWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPEVERYTHING         lpInfo;
    static BOOL                 fDrive, fFile;
    HMENU                       hSysMenu;
    char                        szFile[MAX_PATH];
    LPNM_LISTVIEW               lpnmlv;
    LV_ITEM                     lvi;
    int                         nRet;
    
    switch(uMsg)
    {
        case WM_INITDIALOG:
            lpInfo = (LPEVERYTHING)lParam;
            
            // Set the window title
            SetWindowText(hWnd, APPTITLE);
            
            // Disable 'maximize' and 'size' on the system menu
            hSysMenu = GetSystemMenu(hWnd, FALSE);
            
            EnableMenuItem(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

            // Enable dropping files on the file text box
            EnableDragDrop(GetDlgItem(hWnd, IDC_FILE), TRUE);
            
            // Initialize the fragment size spinner
            SendDlgItemMessage(hWnd, IDC_FRAGSIZE_SPIN, UDM_SETRANGE, 0, MAKELONG(UD_MAXVAL, 0));

            // Initialize control values
            SetDlgItemText(hWnd, IDC_FILE, lpInfo->lpData->lpImage->szFile);

            SendDlgItemMessage(hWnd, IDC_FRAGSIZE_SPIN, UDM_SETPOS, 0, MAKELPARAM(lpInfo->lpData->lpImage->dwMaxFragSize, 0));
            SetDlgItemInt(hWnd, IDC_FRAGSIZE, lpInfo->lpData->lpImage->dwMaxFragSize, FALSE);
            
            SetCheckFlag(hWnd, IDC_OPTION_COMPRESS, OPTIONS_COMPRESS, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_ALLOCATED, OPTIONS_ALLOCATED, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_SPAN, OPTIONS_SPAN, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_FINDBAD, OPTIONS_FINDBAD, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_VERIFY, OPTIONS_VERIFY, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_NOSTOPONERROR, OPTIONS_FORCE, lpInfo->lpData->lpImage->wFlags);
    
            // Make the window visible
            GetRegWindowPos(hWnd);
            ShowWindow(hWnd, SW_RESTORE);
            UpdateWindow(hWnd);

            // Initialize the drive list
            InitDriveList(GetDlgItem(hWnd, IDC_DRIVELIST));
            
            return TRUE;
        
        case WM_SIZE:
            // Fixing a bug in Windows' dialog handler
            if(wParam == SIZE_RESTORED || wParam == SIZE_MINIMIZED)
            {
                hSysMenu = GetSystemMenu(hWnd, FALSE);

                EnableMenuItem(hSysMenu, SC_MINIMIZE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_ENABLED : MF_GRAYED);
                EnableMenuItem(hSysMenu, SC_RESTORE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_GRAYED : MF_ENABLED);
            }

            break;
        
        case WM_DESTROY:
            // Audi
            PutRegWindowPos(hWnd);
            PostQuitMessage(0);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_FILE_REFRESHDRIVELIST:
                    // Disable the OK button
                    fDrive = FALSE;
                    EnableWindow(GetDlgItem(hWnd, IDOK), FALSE);

                    // Refresh the drive list
                    InitDriveList(GetDlgItem(hWnd, IDC_DRIVELIST));

                    break;

                case ID_FILE_EXIT:
                case IDCANCEL:
                    // Later
                    SendMessage(hWnd, WM_CLOSE, 0, 0);

                    break;

                case ID_HELP_ABOUT:
                    // About me
                    ShellAbout(hWnd, APPTITLE, "Contact DEREKS for questions or comments", LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_IMAGE)));

                    break;

                case IDC_FILE:
                    if(HIWORD(wParam) != EN_CHANGE)
                    {
                        break;
                    }

                    fFile = GetWindowTextLength((HWND)lParam);
                    EnableWindow(GetDlgItem(hWnd, IDOK), fDrive && fFile);

                    break;

                case IDC_FILE_BROWSE:
                    // Select a new image file
                    GetDlgItemText(hWnd, IDC_FILE, szFile, sizeof(szFile));
                    
                    if(BrowseForImageFile(hWnd, szFile, TRUE))
                    {
                        SetDlgItemText(hWnd, IDC_FILE, szFile);
                        SetFocus(GetDlgItem(hWnd, IDC_FILE));
                        SendDlgItemMessage(hWnd, IDC_FILE, EM_SETSEL, 0, -1);
                    }

                    break;

                case IDOK:
                    // Get selected item
                    lvi.iItem = ListView_GetNextItem(GetDlgItem(hWnd, IDC_DRIVELIST), -1, LVNI_ALL | LVNI_SELECTED);

                    if(lvi.iItem == -1)
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "No item selected in drive list");
                        break;
                    }

                    // Get drive number from item data
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;

                    if(!ListView_GetItem(GetDlgItem(hWnd, IDC_DRIVELIST), &lvi))
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "Unable to get drive item data");
                        break;
                    }

                    lpInfo->lpData->lpDrive->bDrive = (BYTE)lvi.lParam;

                    // Get filename
                    GetDlgItemText(hWnd, IDC_FILE, lpInfo->lpData->lpImage->szFile, sizeof(lpInfo->lpData->lpImage->szFile));

                    if(!lstrlen(lpInfo->lpData->lpImage->szFile))
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "No image file name");
                        SetFocus(GetDlgItem(hWnd, IDC_FILE));
                        SendDlgItemMessage(hWnd, IDC_FILE, EM_SETSEL, 0, -1);
                        break;
                    }

                    // Get max fragment size
                    lpInfo->lpData->lpImage->dwMaxFragSize = GetDlgItemInt(hWnd, IDC_FRAGSIZE, NULL, FALSE);

                    // Get options
                    GetCheckFlag(hWnd, IDC_OPTION_COMPRESS, OPTIONS_COMPRESS, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_ALLOCATED, OPTIONS_ALLOCATED, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_SPAN, OPTIONS_SPAN, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_FINDBAD, OPTIONS_FINDBAD, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_VERIFY, OPTIONS_VERIFY, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_NOSTOPONERROR, OPTIONS_FORCE, &(lpInfo->lpData->lpImage->wFlags));

                    // Save settings to the registry
                    SetRegOptions(lpInfo->lpData->lpImage);
                    
                    // Go
                    if(nRet = PrepImage(lpInfo))
                    {
                        ErrorMsg(lpInfo->lpData->lpImage, nRet);
                    }

                    break;
            }

            break;

        case WM_NOTIFY:
            switch(wParam)
            {
                case IDC_DRIVELIST:
                    lpnmlv = (LPNM_LISTVIEW)lParam;

                    switch(lpnmlv->hdr.code)
                    {
                        case LVN_ITEMCHANGED:
                            fDrive = lpnmlv->uNewState & LVIS_SELECTED;
                            EnableWindow(GetDlgItem(hWnd, IDOK), fDrive && fFile);
                            
                            break;
                    }

                    break;
            }
            
            break;
    }

    // Allow for default processing
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

#endif // WIN32


#ifdef WIN32

int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine, int nCmdShow)

#else // WIN32

int main(int argc, char **argv)

#endif // WIN32

{
    EVERYTHING                  data;

#ifdef WIN32

    WNDCLASSEX                  wc;
    HACCEL                      hAccel;
    HWND                        hWnd;
    MSG                         msg;

#else // WIN32

    BOOL                        fRecover    = FALSE;
    BOOL                        fGetComment = FALSE;
    char                        szFile[MAX_PATH];
    char                        szPath[MAX_PATH];
    BYTE                        bDrive;
    int                         i, z;
    int                         nRet;

#endif // WIN32
    
    // Allocate memory
    MemSet(&data, 0, sizeof(data));

    data.lpImage = (LPIMAGESTRUCT)MemAlloc(sizeof(IMAGESTRUCT));
    data.lpDrive = (LPDRIVEINFO)MemAlloc(sizeof(DRIVEINFO));

    if(!data.lpImage || !data.lpDrive)
    {
        return ErrorMsg(NULL, ERROR_OOM);
    }

    MemSet(data.lpImage, 0, sizeof(IMAGESTRUCT));
    MemSet(data.lpDrive, 0, sizeof(DRIVEINFO));

    data.lpImage->lpbReadBuffer = (LPBYTE)MemAlloc(READWRITE_BUFFER_SIZE);
    data.lpImage->lpbWriteBuffer = (LPBYTE)MemAlloc(READWRITE_BUFFER_SIZE);

    if(!data.lpImage->lpbReadBuffer || !data.lpImage->lpbWriteBuffer)
    {
        return ErrorMsg(data.lpImage, ERROR_OOM);
    }

    data.lpImage->fhImage = INVALID_FILE_HANDLE;
    
#ifdef WIN32

    GetRegOptions(&(data.image));

#endif // WIN32
    
    // Init disk util
    InitDiskUtil();

#ifdef WIN32

    // Init common controls
    InitCommonControls();

    // Register the window class
    wc.cbSize = sizeof(wc);

    GetClassInfoEx(NULL, WC_DIALOG, &wc);

    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInst;
    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_IMAGE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "RawRead:Main";
    wc.hIconSm = LoadImage(hInst, MAKEINTRESOURCE(IDI_IMAGE), IMAGE_ICON, 16, 16, 0);

    RegisterClassEx(&wc);

    // Load the accelerator table
    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));
    
    // Create the main window
    data.lpImage->hWnd = hWnd = CreateDialogParam(hInst, MAKEINTRESOURCE(IDD_RAWREAD), NULL, wc.lpfnWndProc, (LPARAM)&data);

    // Enter message loop
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if(!TranslateAccelerator(hWnd, hAccel, &msg) && !IsDialogMessage(hWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    nRet = msg.wParam;

#else // WIN32

    // Whoo-hoo!  Look at me!
    GoPropaganda();

    // Parse for switches
    for(i = 1; i < argc; i++)
    {
        if(argv[i][0] == '/' || argv[i][0] == '-' || fGetComment)
        {
            if(fGetComment)
            {
                strncpy(data.lpImage->ls.szComment, argv[i], sizeof(data.lpImage->ls.szComment));
                fGetComment = FALSE;
            }
            else
            {
                for(z = 1; z < StrLen(argv[i]); z++)
                {
                    switch(toupper(argv[i][z]))
                    {
                        case SWITCH_HELP:
                            return GoRawReadHelp();
                               
                        case SWITCH_NOPROMPT:
                            data.lpImage->wFlags |= OPTIONS_NOPROMPT;
                            break;
                            
                        case SWITCH_SPAN:
                            data.lpImage->wFlags |= OPTIONS_SPAN;
                            break;
                            
                        case SWITCH_NOLOCK:
                            data.lpImage->wFlags |= OPTIONS_NOLOCK;
                            break;
                            
                        case SWITCH_OVERWRITE:
                            data.lpImage->wFlags |= OPTIONS_OVERWRITE;
                            break;
                            
                        case SWITCH_NORECOVER:
                            data.lpImage->wFlags |= OPTIONS_NORECOVER;
                            break;
                            
                        case SWITCH_COMPRESS:
                            data.lpImage->wFlags |= OPTIONS_COMPRESS;
                            break;
                            
                        case SWITCH_ALLOCATED:
                            data.lpImage->wFlags |= OPTIONS_ALLOCATED;
                            break;
                            
                        case SWITCH_FINDBAD:
                            data.lpImage->wFlags |= OPTIONS_FINDBAD;
                            break;
                            
                        case SWITCH_NOSTATUS:
                            data.lpImage->wFlags |= OPTIONS_NOSTATUS;
                            break;
                            
                        case SWITCH_VERIFY:
                            data.lpImage->wFlags |= OPTIONS_VERIFY;
                            break;
                               
                        case SWITCH_FORCE:
                            data.lpImage->wFlags |= OPTIONS_FORCE;
                            break;
                                
                        case SWITCH_DUMPINFO:
                            data.lpImage->wFlags |= OPTIONS_DUMPINFO;
                            break;
                               
                        case SWITCH_TEXTCOMMENT:
                            fGetComment = TRUE;
                            break;
                            
                        default:
                            printf("Erroneous switch:  %c" CRLF CRLF, argv[i][z]);
                            return GoRawReadHelp();
                    }
                }
            }
            
            for(z = i; z < argc - 1; z++)
            {
                argv[z] = argv[z + 1];
            }
            
            argc--;
            i--;
        }
    }
    
    // Did we get the right number of arguments?
    if(argc < 2 || argc > 4)
    {
        return GoRawReadHelp();
    }

    // First argument should be a drive letter followed by a colon
    if(toupper(argv[1][0]) < 'A' || toupper(argv[1][0]) > 'Z' || argv[1][1] != ':')
    {
        return GoRawReadHelp();
    }
    
    bDrive = data.lpDrive->bDrive = toupper(argv[1][0]) - 'A';

    // If the drive is compressed, grab it's host
    GetDriveMapping(bDrive, &(data.lpDrive->bDrive), NULL);
    
    // Get drive info
    if(nRet = GetDriveInfo(data.lpDrive->bDrive, data.lpDrive))
    {
        return ErrorMsg(NULL, nRet);
    }

    // Second argument should be a filename.  If this parameter is omitted, use
    // the source drive's volume label.
    if(argc >= 3)
    {
        StrCpy(szFile, argv[2]);
    }
    else
    {
        StrCpy(szFile, data.lpDrive->bs.szVolumeLabel);
    }

    // Long file names are not supported
    if(nRet = ValidateFileName(szFile))
    {
        return ErrorMsg(NULL, nRet);
    }

    // Generate the default fragment names
    GetDefaultFragNames(szFile, data.lpImage, 0, MAX_IMAGE_FRAGMENTS);

    // Can't put the image file on the image drive
    if(toupper(data.lpImage->aszFragNames[0][0]) == bDrive + 'A' || toupper(data.lpImage->aszFragNames[0][0]) == bDrive + 'A')
    {
        return ErrorMsg(NULL, ERROR_FILEOPEN);
    }
    
    // Set the current drive and directory to coincide with the first image
    // fragment.  This is an easy way to use that directory as the default
    // when getting the other fragment names.
    GetFileLocation(data.lpImage->aszFragNames[0], szPath, NULL);
    _chdrive(toupper(szPath[0]) - 'A' + 1);
    _chdir(szPath);

    // Third argument should be a max image size.  0 indicates unlimited size.
    // Default to 0 if no argument
    if(argc >= 4)
    {
        for(i = 0; i < StrLen(argv[3]); i++)
        {
            if(!isdigit(argv[3][i]))
            {
                return GoRawReadHelp();
            }
        }
        
        data.lpImage->dwMaxFragSize = (DWORD)atol(argv[3]);
    }
    
    // Does the image already exist?
    if(!(data.lpImage->wFlags & OPTIONS_DUMPINFO))
    {
        if((data.lpImage->fhImage = FileOpen(data.lpImage->aszFragNames[0], OPEN_ACCESS_READWRITE, 0, ACTION_FILE_OPEN)) != INVALID_FILE_HANDLE)
        {
            if(!(data.lpImage->wFlags & OPTIONS_NORECOVER) && CanRecoverImage(data.lpImage->fhImage, data.lpDrive->bDrive))
            {
                fRecover = AskUser(data.lpImage, "%s appears to be an aborted image." CRLF "Would you like to attempt to recover it?", data.lpImage->aszFragNames[0]);
            }
    
            if(!fRecover)
            {
                FileClose(data.lpImage->fhImage);
                data.lpImage->fhImage = INVALID_FILE_HANDLE;
            }
        }
    }
        
    // Attempt to lock the drive
    if(!(data.lpImage->wFlags & OPTIONS_NOLOCK))
    {
        if(!LockVolume(data.lpDrive->bDrive) && !(data.lpImage->wFlags & OPTIONS_FORCE))
        {
            if(!AskUser(data.lpImage, "Unable to lock drive %c:.  Continue anyway?", data.lpDrive->bDrive + 'A'))
            {
                return ErrorMsg(NULL, ERROR_LOCKFAIL);
            }
        }
    }
    
    if(data.lpImage->wFlags & OPTIONS_DUMPINFO)
    {
        nRet = DumpInfo(&data);
    }
    else
    {

#ifdef WIN32

        // Create the progress dialog
        data.lpImage->hWnd = CreateProgressDialog(data.lpImage->hWnd);
    
#endif // WIN32
    
        // Start imaging
        if(fRecover)
        {
            nRet = RecoverImage(&data);
        }
        else
        {
            nRet = GetImage(&data);
        }

#ifdef WIN32

        // Close the progress dialog
        data.lpImage->hWnd = CloseProgressDialog(data.lpImage->hWnd);

#endif // WIN32

    }

#endif // WIN32

    // Unlock the drive
    if(!(data.lpImage->wFlags & OPTIONS_NOLOCK))
    {
        UnlockVolume(data.lpDrive->bDrive);
    }

    // Release disk util
    FreeDiskUtil();

    // Display any errors
    if(nRet != ERROR_NONE)
    {
        ErrorMsg(data.lpImage, nRet);
    }
    
    // Free memory
    MemFree(data.lpImage->lpbReadBuffer);
    MemFree(data.lpImage->lpbWriteBuffer);

    MemFree(data.lpImage);
    MemFree(data.lpDrive);

    // Return

#ifndef WIN32

    printf(CRLF);

#endif // WIN32

    return nRet;
}


int GetImage(LPEVERYTHING lpData)
{
    DWORD                       dwFragCount;
    DWORD                       dwCurrentSector;
    DWORD                       dwRead;
    int                         nRet;

    // Calculate the total number of clusters in the image.
    lpData->lpImage->ls.dwClusterCount = lpData->lpDrive->bs.dwTotalClusters;
    
    // Copy the options to the LEADSECTOR
    lpData->lpImage->ls.wFlags = lpData->lpImage->wFlags;
   
    // Scan for bad clusters
    if(nRet = FindBadClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, &(lpData->lpDrive->adwBadClusters), &(lpData->lpDrive->dwBadClusters), FALSE))
    {
        return nRet;
    }
    
    // Scan for unallocated clusters
    if(nRet = FindUnallocatedClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, NULL, &(lpData->lpDrive->dwUnusedClusters), FALSE))
    {
        return nRet;
    }
    
    // Calculate the maximum number of clusters allowable in each image 
    // fragment.  If we're not fragmenting the image, set the number of 
    // clusters per fragment to the total number of clusters on the drive so 
    // that we can do safe math based on this number.  The number of clusters 
    // per fragment is really a loose calculation based on only the number of 
    // clusters that will fit into the maximum fragment size.  This number 
    // does not take into account the image header, bitmaps or pre-data 
    // sectors.  But, because we're dealing in mb, it's probably not a big 
    // deal if we're off by a couple here and there.

    // BUGBUG: this should really be fixed

    if(lpData->lpImage->dwMaxFragSize)
    {
        lpData->lpImage->ls.dwClustersPerFrag = (lpData->lpImage->dwMaxFragSize * 1024 * 1024) / lpData->lpDrive->bs.dwSectorsPerCluster / lpData->lpDrive->bs.dwSectorSize;
    }
    else
    {
        lpData->lpImage->ls.dwClustersPerFrag = lpData->lpImage->ls.dwClusterCount;
    }

    // Calculate the number of fragments this operation will require
    dwFragCount = max(1, DIVUP(lpData->lpImage->ls.dwClusterCount - lpData->lpDrive->dwUnusedClusters, lpData->lpImage->ls.dwClustersPerFrag));
        
    if(dwFragCount > MAX_IMAGE_FRAGMENTS)
    {
        return ERROR_TOOMANYFRAGMENTS;
    }

    lpData->lpImage->ls.bFragCount = (BYTE)dwFragCount;
        
    // Get the image fragment filenames
    if(!(lpData->lpImage->wFlags & OPTIONS_NOPROMPT))
    {
        if(nRet = GetFragNames(lpData->lpImage, 1, lpData->lpImage->ls.bFragCount - 1))
        {
            return nRet;
        }
    }

    // Open the first fragment
    if(nRet = OpenFragment(0, lpData))
    {
        return nRet;
    }
    
    // Write the metadata area
    dwCurrentSector = 0;

#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Preprocessing %lu sectors...", lpData->lpDrive->bs.dwPreDataSectors);

#else // WIN32

    printf("Preprocessing %lu sectors... ", lpData->lpDrive->bs.dwPreDataSectors);

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZCLUSTER, dwCurrentSector);
    }

#endif // WIN32
    
    if(nRet = VerifyFileWrite(lpData->lpImage->fhImage, &(lpData->lpDrive->bs.bsOriginal), lpData->lpImage->lpbReadBuffer, sizeof(lpData->lpDrive->bs.bsOriginal), lpData->lpImage->wFlags))
    {
        return nRet;
    }
    
    dwCurrentSector++;

    while(dwCurrentSector < lpData->lpDrive->bs.dwPreDataSectors)
    {

#ifndef WIN32

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZBACK SZCLUSTER, dwCurrentSector);
        }

#endif // WIN32
    
        dwRead = READWRITE_BUFFER_SIZE / lpData->lpDrive->bs.dwSectorSize;

        if(dwCurrentSector + dwRead > lpData->lpDrive->bs.dwPreDataSectors)
        {
            dwRead = lpData->lpDrive->bs.dwPreDataSectors - dwCurrentSector;
        }

        if(!ReadSectorEx(lpData->lpDrive->bDrive, lpData->lpImage->lpbWriteBuffer, dwCurrentSector, dwRead, lpData->lpDrive->bs.dwSectorSize))
        {
            return ERROR_DRIVEREAD;
        }
        
        if(nRet = VerifyFileWrite(lpData->lpImage->fhImage, lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, dwRead * lpData->lpDrive->bs.dwSectorSize, lpData->lpImage->wFlags))
        {
            return nRet;
        }

        dwCurrentSector += dwRead;
    }
    
#ifndef WIN32

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZBACK);
    }

    printf(SZDONE CRLF);

#endif // WIN32
    
    // Enter the main loop
    return EnterMainLoop(lpData);
}


int RecoverImage(LPEVERYTHING lpData)
{
    DWORD                       dwFirstData;
    BOOL                        fSet;
    WORD                        wSize;
    DWORD                       dwRead;
    int                         nRet;
    char                        szFile[MAX_PATH];
    
    // Read the image header
    if(nRet = ReadImageHeader(lpData->lpImage->fhImage, &(lpData->lpImage->ls), &dwFirstData, FALSE))
    {
        return nRet;
    }
    
    // Override (some of) the command-line options
    if(lpData->lpImage->ls.wFlags & OPTIONS_ALLOCATED)
    {
        lpData->lpImage->wFlags |= OPTIONS_ALLOCATED;
    }
    else
    {
        lpData->lpImage->wFlags &= ~OPTIONS_ALLOCATED;
    }
    
    if(lpData->lpImage->ls.wFlags & OPTIONS_COMPRESS)
    {
        lpData->lpImage->wFlags |= OPTIONS_COMPRESS;
    }
    else
    {
        lpData->lpImage->wFlags &= ~OPTIONS_COMPRESS;
    }
    
    // Scan for bad clusters
    if(nRet = FindBadClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, &(lpData->lpDrive->adwBadClusters), &(lpData->lpDrive->dwBadClusters), FALSE))
    {
        return nRet;
    }
    
    // Scan for unallocated clusters
    if(nRet = FindUnallocatedClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, NULL, &(lpData->lpDrive->dwUnusedClusters), FALSE))
    {
        return nRet;
    }
    
    // Find the fragment we left off with

#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Finding incomplete fragment...");

#else // WIN32

    printf("Finding incomplete fragment... ");

#endif // WIN32

    while(lpData->lpImage->ls.fCompleted && lpData->lpImage->ls.bSequence + 1 < lpData->lpImage->ls.bFragCount)
    {
        // Open the next fragment
        if(lpData->lpImage->fhImage != INVALID_FILE_HANDLE)
        {
            FileClose(lpData->lpImage->fhImage);
            lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
        }

        lpData->lpImage->dwCurrentCluster = lpData->lpImage->ls.dwLastCluster + 1;
        lpData->lpImage->ls.bSequence++;
        
        SetFilePath(lpData->lpImage->ls.szNextFrag, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence - 1], lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]);
        
        while(TRUE)
        {
            if((lpData->lpImage->fhImage = FileOpen(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence], OPEN_ACCESS_READONLY, 0, ACTION_FILE_OPEN)) != INVALID_FILE_HANDLE)
            {
                break;
            }

            if(!ReadImageHeader(lpData->lpImage->fhImage, &(lpData->lpImage->ls), &dwFirstData, FALSE))
            {
                break;
            }
            
            if(lpData->lpImage->fhImage != INVALID_FILE_HANDLE)
            {
                FileClose(lpData->lpImage->fhImage);
                lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
            }

#ifdef WIN32

            ImageMessageBox(lpData->lpImage->hWnd, MB_ICONEXCLAMATION, "Unable to open %s", lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]);
            StrCpy(szFile, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]);
            
            if(!GetFragmentName(lpData->lpImage->hWnd, lpData->lpImage->ls.bSequence + 1, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]))
            {
                return ERROR_FILEOPEN;
            }

            // The user won't have changed the path if this is correct
            if(!StrCmp(szFile, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]))
            {
                break;
            }

#else // WIN32

            printf(CRLF CRLF "Unable to open %s" CRLF, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]);
            printf("Please enter the correct path, or press <ENTER>" CRLF "to begin the recovery with this file:  ");
            
            gets(szFile);

#ifndef WIN32

            printf(CRLF "Finding incomplete fragment... ");

#endif // WIN32
            
            if(!StrLen(szFile))
            {
                break;
            }

            GetFullPath(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence], szFile, MAX_PATH);
            
#endif // WIN32

        }
        
        if(lpData->lpImage->fhImage == INVALID_FILE_HANDLE)
        {
            break;
        }
    }

#ifndef WIN32

    printf(SZDONE CRLF);

#endif // WIN32
    
    // Did we find an incomplete fragment?
    if(lpData->lpImage->ls.bSequence >= lpData->lpImage->ls.bFragCount)
    {
        DPF("%lu %lu", lpData->lpImage->ls.bSequence, lpData->lpImage->ls.bFragCount);
        return ERROR_STUPIDRECOVERY;
    }
    
    // Remove the 'completed' flag from the image header
    lpData->lpImage->ls.fCompleted = FALSE;

    // Do we have a valid image?
    if(lpData->lpImage->fhImage == INVALID_FILE_HANDLE || (DWORD)FileSetPos(lpData->lpImage->fhImage, dwFirstData, SEEK_SET) != dwFirstData)
    {
        // If we're still looking at the first fragment, recovery failed.
        if(lpData->lpImage->ls.bSequence == 0)
        {
            return ERROR_RECOVERYFAILED;
        }
        
        // Get the remaining fragment names
        if(!(lpData->lpImage->wFlags & OPTIONS_NOPROMPT))
        {
            if(nRet = GetFragNames(lpData->lpImage, lpData->lpImage->ls.bSequence + 1, lpData->lpImage->ls.bFragCount - (lpData->lpImage->ls.bSequence + 1)))
            {
                return nRet;
            }
        }
        
        // Open the fragment
        if(lpData->lpImage->fhImage != INVALID_FILE_HANDLE)
        {
            FileClose(lpData->lpImage->fhImage);
            lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
        }
        
        if(nRet = OpenFragment(lpData->lpImage->ls.bSequence, lpData))
        {
            return nRet;
        }
        
        // Go
        return EnterMainLoop(lpData);
    }
    
    // Get the remaining fragment names
    if(!(lpData->lpImage->wFlags & OPTIONS_NOPROMPT))
    {
        if(nRet = GetFragNames(lpData->lpImage, lpData->lpImage->ls.bSequence + 1, lpData->lpImage->ls.bFragCount - (lpData->lpImage->ls.bSequence + 1)))
        {
            return nRet;
        }
    }
    
    // Re-open the fragment with write priveliges
    if(lpData->lpImage->fhImage != INVALID_FILE_HANDLE)
    {
        FileClose(lpData->lpImage->fhImage);
        lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
    }
                            
    if((lpData->lpImage->fhImage = FileOpen(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence], OPEN_ACCESS_READWRITE, 0, ACTION_FILE_OPEN)) == INVALID_FILE_HANDLE)
    {
        return ERROR_FILEOPEN;
    }
    
#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Verifying fragment integrity...");

#else // WIN32

    printf("Verifying fragment integrity... ");

#endif // WIN32

    // Update the image header
    if(nRet = WriteImageHeader(lpData->lpImage->fhImage, &(lpData->lpImage->ls), &dwFirstData))
    {
        return nRet;
    }
    
    // We need to find which cluster we left off with.  Initialize
    // the bitmaps to be sure we read the correct number of bytes.
    if(lpData->lpImage->ls.dwCompBitmapSize > 0)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpCompression), lpData->lpImage->ls.dwCompBitmapSize, lpData->lpImage->fhImage, 2, TRUE))
        {
            return nRet;
        }
    }
    
    if(lpData->lpImage->ls.dwAllocBitmapSize > 0)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->ls.dwAllocBitmapSize, lpData->lpImage->fhImage, 2 + lpData->lpImage->ls.dwCompBitmapSize, TRUE))
        {
            return nRet;
        }
    }
    
    // Seek past the image header
    FileSetPos(lpData->lpImage->fhImage, dwFirstData, SEEK_SET);
    
    // Seek past the pre data area
    if(lpData->lpImage->ls.bSequence == 0)
    {
        FileSetPos(lpData->lpImage->fhImage, lpData->lpDrive->bs.dwPreDataSectors * lpData->lpDrive->bs.dwSectorSize, SEEK_CUR);
    }
    
    while(lpData->lpImage->dwCurrentCluster <= lpData->lpImage->ls.dwLastCluster)
    {
        // How big is this cluster?
        wSize = (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);

        if(lpData->lpImage->ls.dwAllocBitmapSize > 0)
        {
            if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
            {
                return nRet;
            }
        }
        else
        {
            fSet = FALSE;
        }
            
        if(fSet)
        {
            // Cluster isn't really in the image
            wSize = 0;
        }
        else
        {
            if(lpData->lpImage->ls.dwCompBitmapSize > 0)
            {
                if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpCompression), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
                {
                    return nRet;
                }
            }
            else
            {
                fSet = FALSE;
            }                
                    
            if(fSet)
            {
                // The size of the compressed cluster is stored in the first 2
                // bytes of the data.
                if((dwRead = FileRead(lpData->lpImage->fhImage, &wSize, sizeof(WORD))) != sizeof(WORD))
                {
                    // Back up
                    FileSetPos(lpData->lpImage->fhImage, 0 - dwRead, SEEK_CUR);
                 
                    // This is the cluster we died on

#ifndef WIN32

                    printf(SZDONE CRLF);

#endif // WIN32

                    return EnterMainLoop(lpData);
                }
            }
        }
        
        // Can we read the cluster?
        if(wSize > 0 && (dwRead = FileRead(lpData->lpImage->fhImage, lpData->lpImage->lpbReadBuffer, wSize)) != wSize)
        {
            // Back up
           FileSetPos(lpData->lpImage->fhImage, 0 - dwRead, SEEK_CUR);
                 
            // This is the cluster we died on

#ifndef WIN32

            printf(SZDONE CRLF);

#endif // WIN32

            return EnterMainLoop(lpData);
        }
        
        // Increment the current cluster
        lpData->lpImage->dwCurrentCluster++;
    }
                                            
    // We couldn't find the cluster we left off with.  This fragment must have actually been
    // completed.
    FileClose(lpData->lpImage->fhImage);
    lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
    
    lpData->lpImage->ls.bSequence++;
    
    if(lpData->lpImage->ls.bSequence >= lpData->lpImage->ls.bFragCount)
    {
        DPF("(2) %lu %lu", lpData->lpImage->ls.bSequence, lpData->lpImage->ls.bFragCount);
        return ERROR_STUPIDRECOVERY;
    }
    
    // Open the fragment and go for it

#ifndef WIN32

    printf(SZDONE CRLF);

#endif // WIN32

    if(nRet = OpenFragment(lpData->lpImage->ls.bSequence, lpData))
    {
        return nRet;
    }
    
    return EnterMainLoop(lpData);
}


int EnterMainLoop(LPEVERYTHING lpData)
{
    DWORD                       dwCluRead;
    DWORD                       dwWrite;
    DWORD                       dwBadCluster;
    DWORD                       dwCheck;
    WORD                        wCompressed;
    WORD                        wUncompressed;
    BOOL                        fSet;
    LPBYTE                      lpb;
    DWORD                       dwCurrentSector;
    UINT                        nNextBad;
    int                         nRet;
    
    // Position the next bad cluster in the list
    for(nNextBad = 0; nNextBad < lpData->lpDrive->dwBadClusters; nNextBad++)
    {
        if(lpData->lpDrive->adwBadClusters[nNextBad] >= lpData->lpImage->dwCurrentCluster)
        {
            break;
        }
    }

    // Here we go...

#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Processing clusters %lu through %lu...", 2, lpData->lpImage->ls.dwClusterCount + 2);

#else // WIN32

    printf("Processing clusters %lu through %lu... ", lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwLastCluster + 2);

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);
    }

#endif // WIN32

    while(TRUE)
    {

#ifdef WIN32

        // Process all pending messages
        ProcessMessages(lpData->lpImage->hWnd);

        if(!IsWindow(lpData->lpImage->hWnd))
        {
            // Time to die
            return ERROR_USERCANCEL;
        }

#endif // WIN32
            
        // Update the progress meter
        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {

#ifdef WIN32

            SetProgressPos(lpData->lpImage->hWnd, lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwClusterCount + 2);

#else // WIN32

            printf(SZBACK SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);

#endif // WIN32

        }

        // Skip ahead to the next allocated cluster.  While we're at it,
        // check to see if it's time to move on to a new fragment.
        while(lpData->lpImage->dwCurrentCluster < lpData->lpImage->ls.dwClusterCount)
        {
            if(nRet = NextFragment(lpData))
            {
                return nRet;
            }

            if(!lpData->lpImage->ls.dwAllocBitmapSize)
            {
                break;
            }

            if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
            {
                return nRet;
            }

            if(!fSet)
            {
                break;
            }

            DPF("Cluster %lu is unused", lpData->lpImage->dwCurrentCluster);

            lpData->lpImage->dwCurrentCluster++;
        }

        // This is done for UI niceness.  It would be cleaner to change
        // the above while() to check for this.
        if(lpData->lpImage->dwCurrentCluster >= lpData->lpImage->ls.dwClusterCount)
        {
            break;
        }

        // Determine the number of clusters to read
        dwCluRead = READWRITE_BUFFER_SIZE / (lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
        
        // Make sure we don't read past the end of this fragment
        dwCluRead = min(dwCluRead, lpData->lpImage->ls.dwLastCluster + 1 - lpData->lpImage->dwCurrentCluster);
        
        // If there's any bad clusters within the next read buffer, stop just before them
        if(nNextBad < lpData->lpDrive->dwBadClusters)
        {
            dwCluRead = min(dwCluRead, lpData->lpDrive->adwBadClusters[nNextBad] - lpData->lpImage->dwCurrentCluster);
        }
        
        // If there's any unused clusters within the next read buffer, stop just before them
        if(lpData->lpImage->ls.dwAllocBitmapSize)
        {
            dwCheck = 0;
            
            while(dwCheck < dwCluRead)
            {
                if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster + dwCheck, &fSet))
                {
                    return nRet;
                }
                
                if(fSet)
                {
                    break;
                }
                
                dwCheck++;
            }
            
            dwCluRead = min(dwCluRead, dwCheck);
        }
        
        // Undocumented switch to force 1 cluster at a time
        if(lpData->lpImage->wFlags & OPTIONS_1CLUSTER)
        {
            dwCluRead = min(dwCluRead, 1);
        }
        
        // Calculate the current sector
        dwCurrentSector = ClusterToSector(&(lpData->lpDrive->bs), lpData->lpImage->dwCurrentCluster + 2);
    
        // Read the cluster(s) from the drive
        if(dwCluRead)
        {
            if(!ReadSectorEx(lpData->lpDrive->bDrive, lpData->lpImage->lpbReadBuffer, dwCurrentSector, dwCluRead * lpData->lpDrive->bs.dwSectorsPerCluster, lpData->lpDrive->bs.dwSectorSize))
            {
                // Uh-oh.  We couldn't read from one of the clusters.  Break the loop
                // down to 1 cluster at a time and determine which cluster it was.
                for(dwBadCluster = 0; dwBadCluster < dwCluRead; dwBadCluster++)
                {
                    lpb = lpData->lpImage->lpbReadBuffer + (dwBadCluster * lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
                    
                    if(!ReadSector(lpData->lpDrive->bDrive, lpb, dwCurrentSector + (dwBadCluster * lpData->lpDrive->bs.dwSectorsPerCluster), 1))
                    {

#ifdef WIN32

                        if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
                        {
                            ImageMessageBox(lpData->lpImage->hWnd, MB_ICONEXCLAMATION, "Unable to read from cluster %lu.... ", lpData->lpImage->dwCurrentCluster + 2 + dwBadCluster);
                        }

#else // WIN32

                        printf(CRLF "Unable to read from cluster %lu.  ", lpData->lpImage->dwCurrentCluster + 2 + dwBadCluster);
                        
                        if(lpData->lpImage->wFlags & OPTIONS_FORCE)
                        {
                            printf("Continuing... ");
                        }
                        else
                        {
                            printf(CRLF);
                        }
                        
#endif // WIN32
                        
                        if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
                        {
                            return ERROR_DRIVEREAD;
                        }
                        
#ifndef WIN32

                        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
                        {
                            printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + dwBadCluster + 2 + 1);
                        }

#endif // WIN32

                        MemSet(lpb, 0xF6, (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize));
                    }
                }
            }
        }
        else
        {
            // We didn't read any clusters.  Was it because of a bad cluster?  If so,
            // fill inthe cluster with 0xF6 and write it to the image.
            if(nNextBad < lpData->lpDrive->dwBadClusters && lpData->lpDrive->adwBadClusters[nNextBad] == lpData->lpImage->dwCurrentCluster)
            {
                MemSet(lpData->lpImage->lpbReadBuffer, 0xF6, (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize));
            
                // Make sure the buffer is written
                dwCluRead = 1;

                // Increment the bad cluster list pointer
                nNextBad++;
            }
        }
            
        // Copy the data to the output buffer
        dwWrite = 0;
        
        if(dwCluRead)
        {
            // Compress the data before writing it to the image
            if(lpData->lpImage->ls.dwCompBitmapSize)
            {
                for(dwCheck = 0, lpb = lpData->lpImage->lpbReadBuffer; dwCheck < dwCluRead; dwCheck++, lpb += lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize)
                {
                    wCompressed = wUncompressed = (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
                    
                    if(CompressData(lpb, wUncompressed, lpData->lpImage->lpbWriteBuffer + dwWrite, &wCompressed))
                    {
                        DPF("Compressed cluster %lu from %u to %u bytes", lpData->lpImage->dwCurrentCluster + dwCheck, wUncompressed, wCompressed);
                    
                        // Data was successfully compressed.  Flip the bit in the bitmap
                        // and move on.
                        if(nRet = SetBitmapBit(&(lpData->lpImage->ibmpCompression), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster + dwCheck))
                        {
                            return nRet;
                        }
                        
                        dwWrite += wCompressed;
                    }
                    else
                    {
                        // Just copy the uncompressed data to the write buffer.
                        DPF("Cluster %lu is uncompressible", lpData->lpImage->dwCurrentCluster + dwCheck);
                        MemCopy(lpData->lpImage->lpbWriteBuffer + dwWrite, lpb, wUncompressed);
                        
                        dwWrite += wUncompressed;
                    }
                }
            }
            else
            {
                // Copy the read data to the output buffer
                dwWrite = dwCluRead * lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize;

                MemCopy(lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, (UINT)dwWrite);
            }
        }
        
        // Write the cluster(s) to the image file
        if(dwWrite)
        {
            if(nRet = VerifyFileWrite(lpData->lpImage->fhImage, lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, dwWrite, lpData->lpImage->wFlags))
            {
                return nRet;
            }
        }

        // It's possible we didn't actually read any clusters.  This
        // will happen if we were looking for allocated clusters only
        // and the next cluster to read was unused.
        dwCluRead = max(dwCluRead, 1);
        
        // Increment the current cluster pointer
        lpData->lpImage->dwCurrentCluster += dwCluRead;
    }
    
    // Close the last fragment

#ifdef WIN32

    ImageMessageBox(lpData->lpImage->hWnd, MB_ICONINFORMATION, "Image complete");

#else // WIN32

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZBACK);
    }

    printf("\a" SZDONE);

#endif // WIN32

    if(nRet = CloseFragment(lpData))
    {
        return nRet;
    }
    
    // Return success
    return ERROR_NONE;
}


#ifndef WIN32
#pragma optimize("", off)
#endif // WIN32

int GetDriveFreeSpace(BYTE bDrive, LPDWORD lpdwFreeSpace, LPBOOL lpfOverflow)
{
    DWORD                       dwSectorsPerCluster = 0;
    DWORD                       dwBytesPerSector = 0;
    DWORD                       dwFreeClusters = 0;
    DWORD                       dwTotalClusters = 0;
    BOOL                        fOverflow;
    BOOL                        fSuccess;

#ifdef WIN32

    char                        szRoot[] = { 'A' + bDrive, ':', '\\', 0 };

    fOverflow = FALSE;

    fSuccess = GetDiskFreeSpace(szRoot, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwTotalClusters);
   
#else

    _asm
    {
        mov     fOverflow, TRUE
        mov     fSuccess, FALSE

        mov     dl, bDrive
        mov     ah, 36h
        int     21h
        
        cmp     ax, 0FFFFh
        je      failure
        
        mov     word ptr [dwSectorsPerCluster], ax
        mov     word ptr [dwFreeClusters], bx
        mov     word ptr [dwBytesPerSector], cx
        mov     word ptr [dwTotalClusters], dx
        mov     fSuccess, TRUE
        
        jo      overflow
        mov     fOverflow, FALSE
  
    overflow:
    failure:
    
    }
    
#endif // WIN32
    
    if(!fSuccess)
    {
        return ERROR_DRIVEREAD;
    }
    
    DPF("dwSectorsPerCluster = %lu", dwSectorsPerCluster);
    DPF("dwFreeClusters = %lu", dwFreeClusters);
    DPF("dwBytesPerSector = %lu", dwBytesPerSector);
    DPF("dwTotalClusters = %lu", dwTotalClusters);

    if(!fOverflow && (dwFreeClusters > (0xFFFFFFFF / dwSectorsPerCluster / dwBytesPerSector)))
    {
        fOverflow = TRUE;
    }
    
    if(!fOverflow)
    {
        *lpdwFreeSpace = dwFreeClusters * dwSectorsPerCluster * dwBytesPerSector;
    }
    
    *lpfOverflow = fOverflow;
    
    return ERROR_NONE;
}
    
#ifndef WIN32
#pragma optimize("", on)
#endif // WIN32


#ifndef WIN32
#pragma optimize("", off)
#endif // WIN32

int IsDriveRemote(BYTE bDrive, LPBOOL pfRemote)
{
    BOOL                        fSuccess = FALSE;
    BOOL                        fRemote = TRUE;

#ifndef WIN32

    _asm
    {
        mov     bl, bDrive
        mov     ax, 4409h
        int     21h

        jc      failure

        test    dx, 1000h
        jnz     remote

        mov     fRemote, FALSE

    remote:
        
        mov     fSuccess, TRUE
        
    failure:
    }
    
#endif // WIN32
    
    if(!fSuccess)
    {
        return ERROR_DRIVEREAD;
    }
    
    *pfRemote = fRemote;
    
    return ERROR_NONE;
}
    
#ifndef WIN32
#pragma optimize("", on)
#endif // WIN32


int NextFragment(LPEVERYTHING lpData)
{
    int                     nRet;
    
    if(lpData->lpImage->dwCurrentCluster > lpData->lpImage->ls.dwLastCluster)
    {

#ifndef WIN32

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZBACK);
        }

        printf(SZDONE CRLF);

#endif // WIN32
    
        if(nRet = CloseFragment(lpData))
        {
            return nRet;
        }
        
        if(nRet = OpenFragment(++(lpData->lpImage->ls.bSequence), lpData))
        {
            return nRet;
        }

#ifndef WIN32

        printf("Processing clusters %lu through %lu... ", lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwLastCluster + 2);

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);
        }

#endif // WIN32

    }

    return ERROR_NONE;
}


int OpenFragment(BYTE bFrag, LPEVERYTHING lpData)
{
    static const char *         pszNoLabel = "no label";
    const char *                pszLabel;
    DWORD                       dwFirstData;
    DWORD                       dwFirst;
    DWORD                       dwCount;
    DWORD                       dwUnused;
    DWORD                       dwClustersThisFrag;
    DWORD                       dwFileSize;
    DWORD                       dwFreeSpace;
    BOOL                        fOverflow;
    BOOL                        fRemote;
    int                         nRet;

    // Copy the fragment sequence number
    lpData->lpImage->ls.bSequence = bFrag;
    
    // If we're spanning media, prompt the user to insert the next disk
    if(lpData->lpImage->wFlags & OPTIONS_SPAN)
    {
        InsertDisk(lpData->lpImage, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence], (char)toupper(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence][0]));
    }

#ifndef WIN32

    // Tell the user what we're going to do
    if(lpData->lpDrive->bs.szVolumeLabel[0])
    {
        pszLabel = lpData->lpDrive->bs.szVolumeLabel;
    }
    else
    {
        pszLabel = pszNoLabel;
    }
    
    printf("Imaging drive:  %c: (%s)" CRLF, lpData->lpDrive->bDrive + 'A', pszLabel);
    printf("To file:        %s" CRLF, lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence]);
    printf("Fragment:       %u of %u" CRLF, lpData->lpImage->ls.bSequence + 1, lpData->lpImage->ls.bFragCount);

#endif // WIN32

    // Open the file
    if(lpData->lpImage->fhImage == INVALID_FILE_HANDLE)
    {
        if((lpData->lpImage->fhImage = OpenFragmentForWrite(lpData->lpImage->ls.bSequence, lpData->lpImage)) == INVALID_FILE_HANDLE)
        {
            return ERROR_FILEOPEN;
        }
    }
    
    // Copy the name of the next fragment
    if(lpData->lpImage->ls.bSequence + 1 < lpData->lpImage->ls.bFragCount)
    {
        GetFileLocation(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence + 1], NULL, lpData->lpImage->ls.szNextFrag);
    }
    else
    {
        MemSet(lpData->lpImage->ls.szNextFrag, 0, sizeof(lpData->lpImage->ls.szNextFrag));
    }
    
    // Set the cluster offset for this fragment
    lpData->lpImage->ls.dwFirstCluster = lpData->lpImage->dwCurrentCluster;
    
    // Calculate the size of the bitmaps.  This involves some tricky math to
    // make up for unallocted clusters.
    dwClustersThisFrag = lpData->lpImage->ls.dwClustersPerFrag;
    
    if(lpData->lpDrive->dwUnusedClusters)
    {
        dwFirst = lpData->lpImage->dwCurrentCluster;
        dwCount = lpData->lpImage->ls.dwClustersPerFrag;
        dwUnused = 0;
    
        while(dwFirst < lpData->lpImage->ls.dwClusterCount && dwCount)
        {
            if(nRet = FindUnallocatedClusters(lpData, dwFirst + 2, dwCount, NULL, &dwUnused, TRUE))
            {
                return nRet;
            }
            
            dwClustersThisFrag += dwUnused;
            dwFirst += dwCount;
            dwCount = dwUnused;
        }
    }
    
    // Increment the cluster to stop on
    lpData->lpImage->ls.dwLastCluster = min(lpData->lpImage->dwCurrentCluster + dwClustersThisFrag, lpData->lpImage->ls.dwClusterCount) - 1;
    
     // Determine the size of the compression and allocation bitmaps (1 bit for every allocated cluster on the drive)
    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        lpData->lpImage->ls.dwCompBitmapSize = DIVUP(DIVUP(dwClustersThisFrag, 8), CBSEC);
    }
    else
    {
        lpData->lpImage->ls.dwCompBitmapSize = 0;
    }
        
    if(dwClustersThisFrag > lpData->lpImage->ls.dwClustersPerFrag)
    {
        lpData->lpImage->ls.dwAllocBitmapSize = DIVUP(DIVUP(dwClustersThisFrag, 8), CBSEC);
    }
    else
    {
        lpData->lpImage->ls.dwAllocBitmapSize = 0;
    }

    // Calculate the fragment size (pad sector + lead sector + bitmaps + 
    // [pre-data sectors] + clusters in fragment) in sectors.  If we're 
    // compressing, assume 2:1.
    dwFileSize = (2 + lpData->lpImage->ls.dwCompBitmapSize + lpData->lpImage->ls.dwAllocBitmapSize) / 2;

    if(!lpData->lpImage->ls.bSequence)
    {
        dwFileSize += lpData->lpDrive->bs.dwPreDataSectors;
    }

    dwFileSize += (lpData->lpImage->ls.dwLastCluster - lpData->lpImage->ls.dwFirstCluster) * lpData->lpDrive->bs.dwSectorsPerCluster;

    if(lpData->lpDrive->dwUnusedClusters)
    {
        dwFileSize -= dwUnused * lpData->lpDrive->bs.dwSectorsPerCluster;
    }

    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        dwFileSize /= 2;
    }
    
    printf("Fragment size:  %lu MB", dwFileSize / 2 / 1024);

    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        printf(" (assuming 2:1 compression)");
    }

    printf(CRLF CRLF);

    // Make sure there's enough space for the file
    if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
    {
        if(nRet = GetDriveFreeSpace((BYTE)((toupper(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence][0]) - 'A') + 1), &dwFreeSpace, &fOverflow))
        {
            return ERROR_DRIVEREAD;
        }
        
        if(fOverflow)
        {
            if(!AskUser(lpData->lpImage, "The amount of free space on the destination drive cannot be determined." CRLF "There may not be enough free space to write the image file." CRLF "Continue anyway?"))
            {
                return ERROR_DRIVETOOSMALL;
            }
        }
        else if(dwFreeSpace < dwFileSize)
        {
            if(!AskUser(lpData->lpImage, "The destination drive does not appear to contain enough free space." CRLF "Continue anyway?"))
            {
                return ERROR_DRIVETOOSMALL;
            }
        }
    }

    // If the fragment is on a network drive, it can't be larger than 2GB.
    if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
    {
        if(dwFileSize >= 0x400000)
        {
            if(nRet = IsDriveRemote((BYTE)((toupper(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence][0]) - 'A') + 1), &fRemote))
            {
                if(!AskUser(lpData->lpImage, "Unable to determine if the destination drive is a mapped network share." CRLF "If it is, files whose size is greater than 2 GB cannot be created." CRLF "Continue anyway?"))
                {
                    return ERROR_DRIVETOOSMALL;
                }
            }
            else if(fRemote)
            {
                if(!AskUser(lpData->lpImage, "Files created on a mapped network share cannot be greater than 2 GB." CRLF "Continue anyway?"))
                {
                    return ERROR_DRIVETOOSMALL;
                }
            }
        }
    }                
   
    // Write the image header
    if(nRet = WriteImageHeader(lpData->lpImage->fhImage, &lpData->lpImage->ls, &dwFirstData))
    {
        return nRet;
    }
    
    // Initialize the bitmaps
    if(lpData->lpImage->ls.dwCompBitmapSize)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpCompression), lpData->lpImage->ls.dwCompBitmapSize, lpData->lpImage->fhImage, 2, FALSE))
        {
            return nRet;
        }
    }
    
    if(lpData->lpImage->ls.dwAllocBitmapSize)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->ls.dwAllocBitmapSize, lpData->lpImage->fhImage, 2 + lpData->lpImage->ls.dwCompBitmapSize, FALSE))
        {
            return nRet;
        }
    }
    
    // Save the unallocated clusters to the bitmap
    if(lpData->lpImage->ls.dwAllocBitmapSize)
    {
        if(nRet = FindUnallocatedClusters(lpData, lpData->lpImage->dwCurrentCluster + 2, dwClustersThisFrag, &(lpData->lpImage->ibmpAllocation), NULL, TRUE))
        {
            return nRet;
        }

        FlushBitmapBuffer(&(lpData->lpImage->ibmpAllocation));
    }
    
    // Seek to the start of the data area
    if((DWORD)FileSetPos(lpData->lpImage->fhImage, dwFirstData, SEEK_SET) != dwFirstData)
    {
        return ERROR_FILEWRITE;
    }

    // Return success
    return ERROR_NONE;
}


int CloseFragment(LPEVERYTHING lpData)
{
    int                         nRet;
    
    // Close the bitmaps
    if(lpData->lpImage->ls.dwCompBitmapSize)
    {
        if(nRet = DiscardBitmap(&(lpData->lpImage->ibmpCompression)))
        {
            return nRet;
        }
    }
    
    if(lpData->lpImage->ls.dwAllocBitmapSize)
    {
        if(nRet = DiscardBitmap(&(lpData->lpImage->ibmpAllocation)))
        {
            return nRet;
        }
    }
    
    // Update the 'completed' flag in the header
    lpData->lpImage->ls.fCompleted = TRUE;
    
    if(nRet = WriteImageHeader(lpData->lpImage->fhImage, &lpData->lpImage->ls, NULL))
    {
        return nRet;
    }
    
    lpData->lpImage->ls.fCompleted = FALSE;
    
    // Close the file handle
    FileClose(lpData->lpImage->fhImage);
    lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
    
    // Return success
    return ERROR_NONE;
}


int VerifyFileWrite(FILEHANDLE fh, LPVOID lpvWriteBuffer, LPVOID lpvVerifyBuffer, DWORD dwSize, WORD wFlags)
{
    if(FileWrite(fh, lpvWriteBuffer, dwSize) != dwSize)
    {
        return ERROR_FILEWRITE;
    }

    if(wFlags & OPTIONS_VERIFY)
    {
        FileSetPos(fh, -(long)dwSize, SEEK_CUR);
        
        FileCommit(fh);
        
        if(FileRead(fh, lpvVerifyBuffer, dwSize) != dwSize)
        {
            return ERROR_FILEREAD;
        }

        if(MemCmp(lpvVerifyBuffer, lpvWriteBuffer, (UINT)dwSize))
        {
            return ERROR_VERIFYFILE;
        }
    }

    return ERROR_NONE;
}


int DumpInfo(LPEVERYTHING lpData)
{
    DWORD                       dwFragCount;
    DWORD                       dwFileSize;
    int							nRet;
    
    // Calculate the total number of clusters in the image.
    lpData->lpImage->ls.dwClusterCount = lpData->lpDrive->bs.dwTotalClusters;
    
    // Scan for unallocated clusters
    if(nRet = FindUnallocatedClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, NULL, &(lpData->lpDrive->dwUnusedClusters), FALSE))
    {
        return nRet;
    }
    
    // Calculate the maximum number of clusters allowable in each
    // image fragment.  If we're not fragmenting the image,
    // set the number of clusters per fragment to the total number
    // of clusters on the drive so that we can do safe math based
    // on this number.
    if(lpData->lpImage->dwMaxFragSize)
    {
        lpData->lpImage->ls.dwClustersPerFrag = (lpData->lpImage->dwMaxFragSize * 1024 * 1024) / lpData->lpDrive->bs.dwSectorsPerCluster / lpData->lpDrive->bs.dwSectorSize;
    }
    else
    {
        lpData->lpImage->ls.dwClustersPerFrag = lpData->lpImage->ls.dwClusterCount;
    }

    // Calculate the number of fragments this operation will require
    dwFragCount = max(1, DIVUP(lpData->lpImage->ls.dwClusterCount - lpData->lpDrive->dwUnusedClusters, lpData->lpImage->ls.dwClustersPerFrag));
        
    if(dwFragCount > MAX_IMAGE_FRAGMENTS)
    {
        return ERROR_TOOMANYFRAGMENTS;
    }
    
    lpData->lpImage->ls.bFragCount = (BYTE)dwFragCount;

     // Determine the size of the compression and allocation bitmaps (1 bit for every allocated cluster on the drive)
    lpData->lpImage->ls.dwCompBitmapSize = DIVUP(DIVUP(lpData->lpImage->ls.dwClusterCount, 8), CBSEC);
    lpData->lpImage->ls.dwAllocBitmapSize = DIVUP(DIVUP(lpData->lpImage->ls.dwClusterCount, 8), CBSEC);
    
    // Calculate the size of the image
    dwFileSize = lpData->lpImage->ls.bFragCount * (2 + lpData->lpImage->ls.dwCompBitmapSize + lpData->lpImage->ls.dwAllocBitmapSize);
    dwFileSize += lpData->lpDrive->bs.dwPreDataSectors;
    dwFileSize += lpData->lpImage->ls.dwClusterCount * lpData->lpDrive->bs.dwSectorsPerCluster;

    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        dwFileSize /= 2;
    }
    
    // Spew
    DumpBootSector("Source drive boot sector", &(lpData->lpDrive->bs));
    DumpDPB("Source drive DOS parameter block", &(lpData->lpDrive->dpb));
    
    printf("Image breakdown" CRLF LINE);
    
    printf("Total image size:                           %lu kb", dwFileSize / 2);

    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        printf(" (assuming 2:1 compression)");
    }

    printf(CRLF);

    printf("Header size:                                %lu bytes per fragment" CRLF, 2L * CBSEC);

    if(lpData->lpImage->wFlags & OPTIONS_COMPRESS)
    {
        printf("Compression bitmap size:                    %lu bytes per fragment" CRLF, lpData->lpImage->ls.dwCompBitmapSize * CBSEC);
    }
    
    if(lpData->lpImage->wFlags & OPTIONS_ALLOCATED)
    {
        printf("Allocation bitmap size:                     %lu bytes per fragment" CRLF, lpData->lpImage->ls.dwAllocBitmapSize * CBSEC);
    }
    
    printf("Fragment count:                             %u" CRLF, lpData->lpImage->ls.bFragCount);
    
    return ERROR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\text.c ===
#ifdef WIN32
#include <windows.h>
#else // WIN32
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif // WIN32

#include <stdarg.h>
#include "bootsec.h"
#include "defs.h"
#include "diskutil.h"
#include "image.h"
#include "text.h"
#include "debug.h"


const LPSTR             g_lpszErrorMsg[] =
{
    "",
    "An error occurred while attempting to open the image file.",
    "An error occurred while attempting to write to the image file.",
    "An error occurred while attempting to read from the image file.",
    "An error occurred while attempting to read from the drive.",
    "An error occurred while attempting to write to the drive.",
    "Out of memory.",
    "This operation would require more than the maximum number of image fragments.",
    "This is not a valid " RAWREAD "/" RAWWRITE " image.",
    "The target drive is too small to write this image.",
    "Lock failed.",
    "The image framents are out of sequence.",
    "Can't write to a compressed drive.",
    "Can't run on a drive with clusters greater than 32kb.",
    "Can't restore an image with clusters greater than 32kb.",
    "A fatal error occurred while compressing data.",
    "A fatal error occurred while uncompressing data.",
    "Unable to retrieve the DPB.",
    "This version of the MS-DOS kernel does not support FAT32.",
    "The source drive is too large to image with this version of " RAWREAD ".",
    "The recovery failed because the previous image was created successfully.",
    "The target drive's file system type differs from the image's.",
    "An internal error has occurred.  The current cluster is not equal to the" CRLF "offset stored in the image's Lead Sector.",
    "Unable to recover this image.",
    "Verification of the file write failed.  The image is corrupt.",
    "Verification of the disk write failed.  The drive is corrupt.",
    "Operation cancelled.",
    "Long filenames are not supported.",
    "The source drive's filesystem is not supported.",
};


#ifdef WIN32

int ImageMessageBox(HWND hWnd, UINT uType, LPCSTR lpszFormat, ...)
{
    va_list             va;
    char                szString[0xFF];

    va_start(va, lpszFormat);
    wvsprintf(szString, lpszFormat, va);
    va_end(va);

    MessageBeep(uType);
    
    return MessageBox(hWnd, szString, APPTITLE, MB_OK | MB_TASKMODAL | uType);
}

#else // WIN32

void GoPropaganda(void)
{

#ifdef PROPAGANDA1

    printf(PROPAGANDA1 CRLF);
   
#endif // PROPAGANDA1    

#ifdef PROPAGANDA2

    printf(PROPAGANDA2 CRLF);
   
#endif // PROPAGANDA2


#ifdef PROPAGANDA3

    printf(PROPAGANDA3 CRLF);
   
#endif // PROPAGANDA3


#ifdef PROPAGANDA4

    printf(PROPAGANDA4 CRLF);
   
#endif // PROPAGANDA4

#if defined(PROPAGANDA1) || defined(PROPAGANDA2) || defined(PROPAGANDA3) || defined(PROPAGANDA4)

    printf(CRLF);

#endif // defined(PROPAGANDA1) || defined(PROPAGANDA2) || defined(PROPAGANDA3) || defined(PROPAGANDA4))

}


int GoRawReadHelp(void)
{
    printf("Usage:  " RAWREAD " <drive:> [imagefile] [maxsize]" CRLF);
    printf(CRLF);
    printf("Options:" CRLF);
    printf("    /A          Only read allocated clusters." CRLF);
    printf("    /B          Scan the FAT for bad clusters." CRLF);
    printf("    /C          Compress drive data." CRLF);
    printf("    /D          Dump drive information." CRLF);
    printf("    /F          Ignore errors.  Should only be used by advanced" CRLF);
    printf("                users." CRLF);
    printf("    /L          Do not attempt to lock the drive." CRLF);
    printf("    /N          Automatically generate image fragment names." CRLF);
    printf("    /O          Overwrites if the image file already exists." CRLF);
    printf("    /Q          Do not print status information." CRLF);
    printf("    /R          Do not attempt to recover an aborted image." CRLF);
    printf("    /S          Span media." CRLF);
    printf("    /T          Store a text comment in the image.  The next parameter" CRLF);
    printf("                after this switch should be the comment enclosed in" CRLF);
    printf("                quotation marks (\" \")" CRLF);
    printf("    /V          Verify data was written to the file properly." CRLF);
    
    cprintf(CRLF "-- More --");
    FlushKeyboardBuffer();
    getch();
    cprintf(SZBACK);

    printf("Required parameters:" CRLF);
    printf("    drive:      Drive to image." CRLF);
    printf(CRLF);
    printf("Optional parameters:" CRLF);
    printf("    imagefile   File to write image to.  If this parameter is omitted," CRLF);
    printf("                the volume label of the source drive will be used." CRLF);
    printf("    maxsize     Maximum image fragment size in megabytes.  Note that" CRLF);
    printf("                maxsize must appear as the last parameter.  Leaving this" CRLF);
    printf("                field blank or 0 indicates an unlimited image size." CRLF);
    
    return -1;
}


int GoRawWriteHelp(void)
{
    printf("Usage:  " RAWWRITE " <imagefile> <drive:>" CRLF);
    printf(CRLF);
    printf("Options:" CRLF);
    printf("    /B          Scan the FAT for bad clusters." CRLF);
    printf("    /D          Dump drive and image information.  When this option is" CRLF);
    printf("                specified, the image file name or drive path may be left off." CRLF);
    printf("    /F          Ignore errors.  Should only be used by advanced users." CRLF);
    printf("    /I          Ignore image type." CRLF);
    printf("    /Q          Do not print status information." CRLF);
    printf("    /V          Verify data was written to the drive properly." CRLF);
    printf("    /W          Wipe unused clusters." CRLF);
    printf(CRLF);
    printf("Required parameters:" CRLF);
    printf("    imagefile   Image file to read from." CRLF);
    printf("    drive:      Drive to write image to." CRLF);
    
    return -1;
}

#endif // WIN32


int ErrorMsg(LPIMAGESTRUCT lpImage, int n)
{

#ifdef WIN32

    HWND                    hWnd    = NULL;

    if(lpImage)
    {
        hWnd = lpImage->hWnd;
    }
    
    ImageMessageBox(hWnd, MB_ICONHAND, g_lpszErrorMsg[n]);

#else // WIN32

    printf(CRLF CRLF "\a%s" CRLF, g_lpszErrorMsg[n]);

#endif // WIN32
    
    return n;
} 

BOOL AskUser(LPIMAGESTRUCT lpImage, LPCSTR lpszFormat, ...)
{
    BOOL                    fResult;

#ifdef WIN32

    // BUGBUG: this will only work on x86
    fResult = ImageMessageBox(lpImage->hWnd, MB_YESNO | MB_TASKMODAL | MB_ICONQUESTION, lpszFormat, *(&lpszFormat + 1)) == IDYES;

#else // WIN32

    va_list                 va;
    char                    c;
    
    printf(CRLF);
    
    va_start(va, lpszFormat);
    vprintf(lpszFormat, va);
    va_end(va);

    printf(" (Y/N) ");
    
    FlushKeyboardBuffer();

    do
    {
        c = getch();
        c = toupper(c);
    }
    while(c != 'Y' && c != 'N');
   
    cprintf("%c" CRLF CRLF, c);
    
    fResult = (c == 'Y') ? TRUE : FALSE;

#endif // WIN32

    return fResult;
}


void InsertDisk(LPIMAGESTRUCT lpImage, LPCSTR lpszFilename, char cDrive)
{

#ifdef WIN32

    ImageMessageBox(lpImage->hWnd, MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL, "Please insert the disk for %s in drive %c:", lpszFilename, cDrive);

#else // WIN32

    FlushKeyboardBuffer();
    cprintf("\a" CRLF "Please insert the disk for %s in drive %c: and press any key... ", lpszFilename, cDrive);
    getch();
    cprintf(CRLF CRLF);

#endif // WIN32

}


#ifndef WIN32
#pragma optimize("", off)

void FlushKeyboardBuffer(void)
{
    _asm
    {
        mov     ax, 0C00h
        int     21h
    }
}

#pragma optimize("", on)
#endif // WIN32


int GetFullPath(LPSTR lpszFullPath, LPCSTR lpszRelPath, UINT uBufSize)
{

#ifdef WIN32

    if(!GetFullPathName(lpszRelPath, uBufSize, lpszFullPath, NULL))
    {
        return -1;
    }

#else // WIN32

    if(!_fullpath(lpszFullPath, lpszRelPath, uBufSize))
    {
        return -1;
    }

#endif // WIN32

    return StrLen(lpszFullPath);
}


int GetFullPathInPlace(LPSTR lpszPath, UINT uBufSize)
{
    char                    szFullPath[MAX_PATH];
    int                     nRet;

    if((nRet = GetFullPath(szFullPath, lpszPath, sizeof(szFullPath))) == -1)
    {
        return -1;
    }

    strncpy(lpszPath, szFullPath, uBufSize);

    return nRet;
}


int SplitPath(LPCSTR lpszPath, LPSTR lpszDir, LPSTR lpszFile)
{
    char                    szFullPath[MAX_PATH];
    LPSTR                   lpsz;

    StrCpy(szFullPath, lpszPath);

    // Walk backwards from the end of the absolute path until
    // we hit a : or \ indicating part of the path
    for(lpsz = szFullPath; *lpsz; lpsz++);
    
    while(*lpsz != '\\')
    {
        lpsz--;
    }

    // Null terminate the string here
    *lpsz = 0;

    // Copy the strings
    if(lpszDir)
    {
        StrCpy(lpszDir, szFullPath);
    }

    if(lpszFile)
    {
        StrCpy(lpszFile, lpsz + 1);
    }

    return 0;
}


int GetFileLocation(LPCSTR lpszFile, LPSTR lpszDirPart, LPSTR lpszFilePart)
{
    char                    szFullPath[MAX_PATH];

    if(GetFullPath(szFullPath, lpszFile, sizeof(szFullPath)) == -1)
    {
        return -1;
    }

    return SplitPath(szFullPath, lpszDirPart, lpszFilePart);
}


#ifdef WIN32

int GetShortFileName(LPCSTR lpszPath, LPSTR lpszFile)
{
    char                    szShortPath[MAX_PATH];

    if(GetShortPathName(lpszPath, szShortPath, sizeof(szShortPath)))
    {
        return -1;
    }

    return GetFileLocation(szShortPath, NULL, lpszFile);
}

#endif // WIN32


int SetFilePath(LPCSTR lpszFile, LPCSTR lpszDir, LPSTR lpszResult)
{
    char                    szFile[MAX_FILE];
    char                    szDir[MAX_DIR];

    // Split the paths
    if(GetFileLocation(lpszFile, NULL, szFile) == -1)
    {
        return -1;
    }

    if(GetFileLocation(lpszDir, szDir, NULL) == -1)
    {
        return -1;
    }

    // Append the path and file
    StrCpy(lpszResult, szDir);
    
    if(lpszResult[StrLen(lpszResult) - 1] != '\\')
    {
        StrCat(lpszResult, "\\");
    }

    StrCat(lpszResult, szFile);

    return StrLen(lpszResult);
}


int ValidateFileName(LPCSTR lpszFile)
{
    char                    szFile[MAX_FILE];
    LPSTR                   lpsz;
    UINT                    uFileLen, uExtLen;
    BOOL                    fSpace;

    GetFileLocation(lpszFile, NULL, szFile);

    uFileLen = 0;
    uExtLen = 0;
    fSpace = FALSE;

    lpsz = szFile;

    while(*lpsz && *lpsz != '.')
    {
        if(*lpsz == ' ')
        {
            fSpace = TRUE;
        }
        
        uFileLen++;
        lpsz++;
    }

    if(*lpsz == '.')
    {
        lpsz++;
    }
    
    while(*lpsz)
    {
        if(*lpsz == ' ')
        {
            fSpace = TRUE;
        }
        
        uExtLen++;
        lpsz++;
    }

    if(uFileLen > 8 || uExtLen > 3 || fSpace)
    {
        return ERROR_LFN;
    }

    return ERROR_NONE;
}


LPSTR StrCpy(LPSTR lpszDest, LPCSTR lpszSrc)
{

#ifdef WIN32

    return lstrcpy(lpszDest, lpszSrc);

#else // WIN32

    return _fstrcpy(lpszDest, lpszSrc);

#endif // WIN32

}


int StrLen(LPCSTR lpszString)
{

#ifdef WIN32

    return lstrlen(lpszString);

#else // WIN32

    return _fstrlen(lpszString);

#endif // WIN32

}


int StrCmp(LPCSTR lpszString1, LPCSTR lpszString2)
{

#ifdef WIN32

    return lstrcmp(lpszString1, lpszString2);

#else // WIN32

    return _fstrcmp(lpszString1, lpszString2);

#endif // WIN32

}


int StrCmpI(LPCSTR lpszString1, LPCSTR lpszString2)
{

#ifdef WIN32

    return lstrcmpi(lpszString1, lpszString2);

#else // WIN32

    return _fstricmp(lpszString1, lpszString2);

#endif // WIN32

}


LPSTR StrCat(LPSTR lpszDest, LPCSTR lpszSrc)
{

#ifdef WIN32

    return lstrcat(lpszDest, lpszSrc);

#else // WIN32

    return _fstrcat(lpszDest, lpszSrc);

#endif // WIN32

}


void DumpBootSector(LPSTR lpszText, LPRRBOOTSECTOR lpbs)
{
    printf("%s" CRLF "%s", lpszText, LINE);

    printf("Sector size:                                %lu bytes" CRLF, lpbs->dwSectorSize);
    printf("Sectors per cluster:                        %lu" CRLF, lpbs->dwSectorsPerCluster);
    printf("Reserved sectors:                           %lu" CRLF, lpbs->dwReservedSectors);
    printf("Number of FATs:                             %lu" CRLF, lpbs->dwFATCount);
    printf("FAT size:                                   %lu bytes" CRLF, lpbs->dwFATSize);
    printf("Number of root directory entries:           %lu" CRLF, lpbs->dwRootDirEntries);
    printf("Number of sectors prior to first cluster:   %lu" CRLF, lpbs->dwPreDataSectors);
    printf("Total number of drive sectors:              %lu" CRLF, lpbs->dwTotalSectors);
    printf("Total number of drive clusters:             %lu" CRLF, lpbs->dwTotalClusters);
    printf("Total number of usable sectors:             %lu" CRLF, lpbs->dwUsableSectors);
    printf("Number of bits per FAT entry:               %lu" CRLF, lpbs->dwBitsPerFATEntry);
    printf("Volume label:                               %s" CRLF, lpbs->szVolumeLabel);
    printf("Filesystem type:                            %s" CRLF, lpbs->szFSType);
    
    printf(CRLF);
}


void DumpDPB(LPSTR lpszText, LPDPB lpdpb)
{
    WORD                    wDosVer = GetDosVersion();

    printf("%s" CRLF "%s", lpszText, LINE);

    printf("Drive number:                               %u" CRLF, lpdpb->bDrive);
    printf("Unit number:                                %u" CRLF, lpdpb->bUnit);
                                                        
    printf("Sector size:                                %u bytes" CRLF, lpdpb->wSectorSize);
    printf("Sectors per cluster:                        %u" CRLF, lpdpb->bClusterMask + 1);
    printf("First FAT sector:                           %u" CRLF, lpdpb->wFirstFAT);
    printf("FAT count:                                  %u" CRLF, lpdpb->bFATCount);
    
    if(!IS_FAT32_KERNEL(wDosVer))
    {
        printf("Number of root directory entries:           %u" CRLF, lpdpb->wOldRootEntries);
        printf("Sector number of cluster 2:                 %u" CRLF, lpdpb->wOldFirstSector);
        printf("Maximun number of drive clusters:           %u" CRLF, lpdpb->wOldMaxCluster - 1);
        printf("FAT size:                                   %u sectors" CRLF, lpdpb->wOldFATSize);
        printf("First root directory sector:                %u" CRLF, lpdpb->wOldDirSector);
    }
    
    printf("Device driver header address:               0x%8.8lX" CRLF, lpdpb->dwDriverAddr);
    printf("Media descriptor:                           %u" CRLF, lpdpb->bMedia);
    printf("Access byte:                                %u" CRLF, lpdpb->bFlags);
    printf("Next DPB address:                           0x%8.8lX" CRLF, lpdpb->dwNextDPB);
    
    if(!IS_FAT32_KERNEL(wDosVer))
    {
        printf("Last allocated cluster:                     %u" CRLF, lpdpb->wOldNextFree);
    }
    
    printf("Free clusters:                              %lu" CRLF, lpdpb->dwFreeCount);
    
    if(IS_FAT32_KERNEL(wDosVer))
    {
        printf("Extended flags:                             %u" CRLF, lpdpb->wExtFlags);
        printf("Filesystem info sector:                     %u" CRLF, lpdpb->wFSInfoSector);
        printf("Backup boot sector:                         %u" CRLF, lpdpb->wBackupBootSector);
        printf("Sector number of cluster 2:                 %lu" CRLF, lpdpb->dwFirstSector);
        printf("Maximun number of drive clusters:           %lu" CRLF, lpdpb->dwMaxCluster - 1);
        printf("FAT size:                                   %lu sectors" CRLF, lpdpb->dwFATSize);
        printf("First root directory cluster:               %lu" CRLF, lpdpb->dwRootCluster);
        printf("Last allocated cluster:                     %lu" CRLF, lpdpb->dwNextFree);
    }
    
    printf(CRLF);
}


void DumpLeadSector(LPSTR lpszText, LPLEADSECTOR lpls)
{
    printf("%s" CRLF "%s", lpszText, LINE);

    printf("Number of clusters in the image:            %lu" CRLF, lpls->dwClusterCount);
    printf("Fragment sequence number:                   %u" CRLF, lpls->bSequence);
    printf("Number of fragments in the image:           %u" CRLF, lpls->bFragCount);
    printf("Number of clusters per fragment:            %lu" CRLF, lpls->dwClustersPerFrag);
    printf("Next fragment filename:                     %s" CRLF, lpls->szNextFrag);
    printf("Flags:                                      0x%4.4X" CRLF, lpls->wFlags);
    printf("Compression bitmap size:                    %lu sectors" CRLF, lpls->dwCompBitmapSize);
    printf("Allocation bitmap size:                     %lu sectors" CRLF, lpls->dwAllocBitmapSize);
    printf("First cluster in this fragment:             %lu" CRLF, lpls->dwFirstCluster + 2);
    printf("Last cluster in this fragment:              %lu" CRLF, lpls->dwLastCluster + 2);
    printf("Fragment was successfully created:          %s" CRLF, lpls->fCompleted ? "TRUE" : "FALSE");
    
    if(StrLen(lpls->szComment))
    {
        printf(CRLF "%s" CRLF, lpls->szComment);
    }
    
    printf(CRLF);
}


BOOL IsDrivePath(LPSTR pszPath, LPBYTE pbDriveNumber)
{
    char                    cDrive;
    
    cDrive = toupper(pszPath[0]);

    if(cDrive < 'A' || cDrive > 'Z')
    {
        return FALSE;
    }

    if(pszPath[1] != ':')
    {
        return FALSE;
    }

    if(pszPath[2] != 0)
    {
        return FALSE;
    }

    if(pbDriveNumber)
    {
        *pbDriveNumber = cDrive - 'A';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\reg.c ===
#include <windows.h>
#include "..\defs.h"
#include "..\image.h"
#include "reg.h"
#include "winmisc.h"


BOOL GetReg(HKEY hKeyParent, LPSTR lpszKey, LPSTR lpszValue, DWORD dwValType, LPVOID lpvData, DWORD dwDataSize)
{
    HKEY                    hKey = hKeyParent;

    if(lpszValue)
    {
        if(lpszKey)
            if(RegOpenKey(hKeyParent, lpszKey, &hKey))
                return FALSE;

        if(RegQueryValueEx(hKey, lpszValue, NULL, &dwValType, (LPBYTE)lpvData, &dwDataSize))
            return FALSE;

        RegCloseKey(hKey);
    }
    else
    {
        if(RegQueryValue(hKeyParent, lpszKey, (LPBYTE)lpvData, (PLONG)&dwDataSize))
            return FALSE;
    }
        
    return TRUE;
}


BOOL PutReg(HKEY hKeyParent, LPSTR lpszKey, LPSTR lpszValue, DWORD dwValType, LPVOID lpvData, DWORD dwDataSize)
{
    HKEY                    hKey = hKeyParent;

    if(lpszValue)
    {
        if(lpszKey)
            if(RegCreateKey(hKeyParent, lpszKey, &hKey))
                return FALSE;

        if(RegSetValueEx(hKey, lpszValue, 0, dwValType, (LPBYTE)lpvData, dwDataSize))
            return FALSE;

        RegCloseKey(hKey);
    }
    else
    {
        if(RegSetValue(hKeyParent, lpszKey, REG_SZ, (LPBYTE)lpvData, dwDataSize))
            return FALSE;
    }
        
    return TRUE;
}


void GetRegWindowPos(HWND hWnd)
{
    RECT                    rc;

    if(GetReg(REG_KEY_PARENT, REG_KEY, REG_VAL_WINDOWPOS, REG_TYPE_WINDOWPOS, &rc, sizeof(rc)))
    {
        SetWindowPos(hWnd, NULL, rc.left, rc.top, 0, 0, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);
    }
    else
    {
        CenterWindow(hWnd, NULL);
    }
}


void PutRegWindowPos(HWND hWnd)
{
    WINDOWPLACEMENT         wp;

    wp.length = sizeof(wp);
    GetWindowPlacement(hWnd, &wp);
    PutReg(REG_KEY_PARENT, REG_KEY, REG_VAL_WINDOWPOS, REG_TYPE_WINDOWPOS, &(wp.rcNormalPosition), sizeof(wp.rcNormalPosition));
}


void GetRegOptions(LPIMAGESTRUCT lpImage)
{
    GetReg(REG_KEY_PARENT, REG_KEY, REG_VAL_DRIVE, REG_TYPE_DRIVE, &(lpImage->bDrive), sizeof(lpImage->bDrive));
    GetReg(REG_KEY_PARENT, REG_KEY, REG_VAL_FILE, REG_TYPE_FILE, lpImage->szFile, sizeof(lpImage->szFile));
    GetReg(REG_KEY_PARENT, REG_KEY, REG_VAL_OPTIONS, REG_TYPE_OPTIONS, &(lpImage->wFlags), sizeof(lpImage->wFlags));

#ifdef RAWREAD

    GetReg(REG_KEY_PARENT, REG_KEY, REG_VAL_MAXFRAGSIZE, REG_TYPE_MAXFRAGSIZE, &(lpImage->dwMaxFragSize), sizeof(lpImage->dwMaxFragSize));

#endif // RAWREAD

}


void SetRegOptions(LPIMAGESTRUCT lpImage)
{
    PutReg(REG_KEY_PARENT, REG_KEY, REG_VAL_DRIVE, REG_TYPE_DRIVE, &(lpImage->bDrive), sizeof(lpImage->bDrive));
    PutReg(REG_KEY_PARENT, REG_KEY, REG_VAL_FILE, REG_TYPE_FILE, lpImage->szFile, sizeof(lpImage->szFile));
    PutReg(REG_KEY_PARENT, REG_KEY, REG_VAL_OPTIONS, REG_TYPE_OPTIONS, &(lpImage->wFlags), sizeof(lpImage->wFlags));

#ifdef RAWREAD

    PutReg(REG_KEY_PARENT, REG_KEY, REG_VAL_MAXFRAGSIZE, REG_TYPE_MAXFRAGSIZE, &(lpImage->dwMaxFragSize), sizeof(lpImage->dwMaxFragSize));

#endif // RAWREAD

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\rawwrite.c ===
#ifdef WIN32
#include <windows.h>
#include <commctrl.h>
#include "win32\reg.h"
#include "win32\resource.h"
#include "win32\winmisc.h"
#else // WIN32
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#endif // WIN32

#include "bitmap.h"
#include "bootsec.h"
#include "compress.h"
#include "debug.h"
#include "defs.h"
#include "diskutil.h"
#include "fatutil.h"
#include "file.h"
#include "image.h"
#include "mem.h"
#include "text.h"

// Local prototypes
int PutImage(LPEVERYTHING);
int EnterMainLoop(LPEVERYTHING);
int NextFragment(LPEVERYTHING);
int OpenFragment(BYTE, LPEVERYTHING, BOOL);
int CloseFragment(LPEVERYTHING);
int WipeClustersToCurrent(LPEVERYTHING, DWORD);
int VerifyWriteSector(LPDRIVEINFO, LPVOID, LPVOID, DWORD, DWORD, WORD);
int DumpInfo(LPEVERYTHING);

#ifdef WIN32

LPARAM CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);

#endif // WIN32


#ifdef WIN32

int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine, int nCmdShow)
{
    EVERYTHING                  info;
    IMAGESTRUCT                 is;
    IMAGERES                    ir;
    DRIVEINFO                   di;
    WNDCLASSEX                  wc;
    HACCEL                      hAccel;
    HWND                        hWnd;
    MSG                         msg;

    // Initialize data
    MemSet(&is, 0, sizeof(is));
    MemSet(data.lpImage, 0, sizeof(ir));
    MemSet(&di, 0, sizeof(di));

    ir.fhImage = INVALID_FILE_HANDLE;
    
    GetRegOptions(&is);
    
    info.lpData->lpImage = &is;
    info.lpData->lpImage = data.lpImage;
    info.lpData->lpDrive = &di;
    
    // Init disk util
    InitDiskUtil();

    // Init common controls
    InitCommonControls();

    // Register the window class
    wc.cbSize = sizeof(wc);

    GetClassInfoEx(NULL, WC_DIALOG, &wc);

    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInst;
    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_IMAGE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "RawWrite:Main";
    wc.hIconSm = LoadImage(hInst, MAKEINTRESOURCE(IDI_IMAGE), IMAGE_ICON, 16, 16, 0);

    RegisterClassEx(&wc);

    // Load the accelerator table
    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));
    
    // Create the main window
    ir.hWnd = hWnd = CreateDialogParam(hInst, MAKEINTRESOURCE(IDD_RAWWRITE), NULL, wc.lpfnWndProc, (LPARAM)&info);

    // Enter message loop
    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        if(!TranslateAccelerator(hWnd, hAccel, &msg) && !IsDialogMessage(hWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Release disk utiil
    FreeDiskUtil();

    // Return success
    return msg.wParam;
}


LPARAM CALLBACK MainWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPEVERYTHING         lpInfo;
    static BOOL                 fDrive, fFile;
    HMENU                       hSysMenu;
    char                        szFile[MAX_PATH];
    LPNM_LISTVIEW               lpnmlv;
    LV_ITEM                     lvi;
    int                         nRet;
    
    switch(uMsg)
    {
        case WM_INITDIALOG:
            lpInfo = (LPEVERYTHING)lParam;
            
            // Set the window title
            SetWindowText(hWnd, APPTITLE);
            
            // Disable 'maximize' and 'size' on the system menu
            hSysMenu = GetSystemMenu(hWnd, FALSE);
            
            EnableMenuItem(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);

            // Enable dropping files on the file text box
            EnableDragDrop(GetDlgItem(hWnd, IDC_FILE), TRUE);
            
            // Initialize control values
            SetDlgItemText(hWnd, IDC_FILE, lpInfo->lpData->lpImage->szFile);

            SetCheckFlag(hWnd, IDC_OPTION_WIPE, OPTIONS_WIPE, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_FINDBAD, OPTIONS_FINDBAD, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_VERIFY, OPTIONS_VERIFY, lpInfo->lpData->lpImage->wFlags);
            SetCheckFlag(hWnd, IDC_OPTION_NOSTOPONERROR, OPTIONS_FORCE, lpInfo->lpData->lpImage->wFlags);
    
            // Make the window visible
            GetRegWindowPos(hWnd);
            ShowWindow(hWnd, SW_RESTORE);
            UpdateWindow(hWnd);

            // Initialize the drive list
            InitDriveList(GetDlgItem(hWnd, IDC_DRIVELIST));
            
            return TRUE;
        
        case WM_SIZE:
            // Fixing a bug in Windows' dialog handler
            if(wParam == SIZE_RESTORED || wParam == SIZE_MINIMIZED)
            {
                hSysMenu = GetSystemMenu(hWnd, FALSE);

                EnableMenuItem(hSysMenu, SC_MINIMIZE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_ENABLED : MF_GRAYED);
                EnableMenuItem(hSysMenu, SC_RESTORE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_GRAYED : MF_ENABLED);
            }

            break;
        
        case WM_DESTROY:
            // Audi
            PutRegWindowPos(hWnd);
            PostQuitMessage(0);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_FILE_REFRESHDRIVELIST:
                    // Disable the OK button
                    fDrive = FALSE;
                    EnableWindow(GetDlgItem(hWnd, IDOK), FALSE);

                    // Refresh the drive list
                    InitDriveList(GetDlgItem(hWnd, IDC_DRIVELIST));

                    break;

                case ID_FILE_EXIT:
                case IDCANCEL:
                    // Later
                    SendMessage(hWnd, WM_CLOSE, 0, 0);

                    break;

                case ID_HELP_ABOUT:
                    // About me
                    ShellAbout(hWnd, APPTITLE, "Contact DEREKS for questions or comments", LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_IMAGE)));

                    break;

                case IDC_FILE:
                    if(HIWORD(wParam) != EN_CHANGE)
                    {
                        break;
                    }

                    fFile = GetWindowTextLength((HWND)lParam);
                    EnableWindow(GetDlgItem(hWnd, IDOK), fDrive && fFile);

                    break;

                case IDC_FILE_BROWSE:
                    // Select a new image file
                    GetDlgItemText(hWnd, IDC_FILE, szFile, sizeof(szFile));
                    
                    if(BrowseForImageFile(hWnd, szFile, TRUE))
                    {
                        SetDlgItemText(hWnd, IDC_FILE, szFile);
                        SetFocus(GetDlgItem(hWnd, IDC_FILE));
                        SendDlgItemMessage(hWnd, IDC_FILE, EM_SETSEL, 0, -1);
                    }

                    break;

                case IDOK:
                    // Get selected item
                    lvi.iItem = ListView_GetNextItem(GetDlgItem(hWnd, IDC_DRIVELIST), -1, LVNI_ALL | LVNI_SELECTED);

                    if(lvi.iItem == -1)
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "No item selected in drive list");
                        break;
                    }

                    // Get drive number from item data
                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;

                    if(!ListView_GetItem(GetDlgItem(hWnd, IDC_DRIVELIST), &lvi))
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "Unable to get drive item data");
                        break;
                    }

                    lpInfo->lpData->lpDrive->bDrive = (BYTE)lvi.lParam;

                    // Get filename
                    GetDlgItemText(hWnd, IDC_FILE, lpInfo->lpData->lpImage->szFile, sizeof(lpInfo->lpData->lpImage->szFile));

                    if(!lstrlen(lpInfo->lpData->lpImage->szFile))
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "No image file name");
                        SetFocus(GetDlgItem(hWnd, IDC_FILE));
                        SendDlgItemMessage(hWnd, IDC_FILE, EM_SETSEL, 0, -1);
                        break;
                    }

                    // Get options
                    GetCheckFlag(hWnd, IDC_OPTION_WIPE, OPTIONS_WIPE, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_FINDBAD, OPTIONS_FINDBAD, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_VERIFY, OPTIONS_VERIFY, &(lpInfo->lpData->lpImage->wFlags));
                    GetCheckFlag(hWnd, IDC_OPTION_NOSTOPONERROR, OPTIONS_FORCE, &(lpInfo->lpData->lpImage->wFlags));

                    // Save settings to the registry
                    SetRegOptions(lpInfo->lpData->lpImage);
                    
                    // Go
                    if(nRet = PrepImage(lpInfo->lpData->lpImage, lpInfo->lpData->lpImage, lpInfo->lpData->lpDrive))
                    {
                        ErrorMsg(lpInfo->lpData->lpImage, nRet);
                    }

                    break;
            }

            break;

        case WM_NOTIFY:
            switch(wParam)
            {
                case IDC_DRIVELIST:
                    lpnmlv = (LPNM_LISTVIEW)lParam;

                    switch(lpnmlv->hdr.code)
                    {
                        case LVN_ITEMCHANGED:
                            fDrive = lpnmlv->uNewState & LVIS_SELECTED;
                            EnableWindow(GetDlgItem(hWnd, IDOK), fDrive && fFile);
                            
                            break;
                    }

                    break;
            }
            
            break;
    }

    // Allow for default processing
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


#endif // WIN32


#ifdef WIN32

int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine, int nCmdShow)

#else // WIN32

int main(int argc, char **argv)

#endif // WIN32

{
    EVERYTHING                  data;

#ifdef WIN32

    WNDCLASSEX                  wc;
    HACCEL                      hAccel;
    HWND                        hWnd;
    MSG                         msg;

#else // WIN32

    BOOL                        fRecover    = FALSE;
    BOOL                        fGetComment = FALSE;
    int                         i, z;
    int                         nRet;

#endif // WIN32
    
    // Allocate memory
    MemSet(&data, 0, sizeof(data));

    data.lpImage = (LPIMAGESTRUCT)MemAlloc(sizeof(IMAGESTRUCT));
    data.lpDrive = (LPDRIVEINFO)MemAlloc(sizeof(DRIVEINFO));

    if(!data.lpImage || !data.lpDrive)
    {
        return ErrorMsg(NULL, ERROR_OOM);
    }

    MemSet(data.lpImage, 0, sizeof(IMAGESTRUCT));
    MemSet(data.lpDrive, 0, sizeof(DRIVEINFO));

    data.lpImage->lpbReadBuffer = (LPBYTE)MemAlloc(READWRITE_BUFFER_SIZE);
    data.lpImage->lpbWriteBuffer = (LPBYTE)MemAlloc(READWRITE_BUFFER_SIZE);

    if(!data.lpImage->lpbReadBuffer || !data.lpImage->lpbWriteBuffer)
    {
        return ErrorMsg(data.lpImage, ERROR_OOM);
    }

    data.lpDrive->bDrive = 0xFF;
    data.lpImage->fhImage = INVALID_FILE_HANDLE;
    
#ifdef WIN32

    GetRegOptions(&(data.image));

#endif // WIN32
    
    // Init disk util
    InitDiskUtil();

#ifdef WIN32

    // Init common controls
    InitCommonControls();

    // Register the window class
    wc.cbSize = sizeof(wc);

    GetClassInfoEx(NULL, WC_DIALOG, &wc);

    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInst;
    wc.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_IMAGE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "RawWrite:Main";
    wc.hIconSm = LoadImage(hInst, MAKEINTRESOURCE(IDI_IMAGE), IMAGE_ICON, 16, 16, 0);

    RegisterClassEx(&wc);

    // Load the accelerator table
    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));
    
    // Create the main window
    data.lpImage->hWnd = hWnd = CreateDialogParam(hInst, MAKEINTRESOURCE(IDD_RAWWRITE), NULL, wc.lpfnWndProc, (LPARAM)&data);

    // Enter message loop
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if(!TranslateAccelerator(hWnd, hAccel, &msg) && !IsDialogMessage(hWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    nRet = msg.wParam;

#else // WIN32

    // Whoo-hoo!  Look at me!
    GoPropaganda();

    // Parse for switches
    for(i = 1; i < argc; i++)
    {
        if(argv[i][0] == '/' || argv[i][0] == '-')
        {
            for(z = 1; z < StrLen(argv[i]); z++)
            {
                switch(toupper(argv[i][z]))
                {
                    case SWITCH_HELP:
                        return GoRawWriteHelp();
                       
                    case SWITCH_FORCE:
                        data.lpImage->wFlags |= OPTIONS_FORCE;
                        break;
                    
                    case SWITCH_IGNORETYPE:
                        data.lpImage->wFlags |= OPTIONS_IGNORETYPE;
                        break;
                    
                    case SWITCH_WIPE:
                        data.lpImage->wFlags |= OPTIONS_WIPE;
                        break;
                    
                    case SWITCH_NOSTATUS:
                        data.lpImage->wFlags |= OPTIONS_NOSTATUS;
                        break;
                    
                    case SWITCH_VERIFY:
                        data.lpImage->wFlags |= OPTIONS_VERIFY;
                        break;
                    
                    case SWITCH_FINDBAD:
                        data.lpImage->wFlags |= OPTIONS_FINDBAD;
                        break;
                    
                    case SWITCH_DUMPINFO:
                        data.lpImage->wFlags |= OPTIONS_DUMPINFO;
                        break;
                   
                    default:
                        printf("Erroneous switch:  %c" CRLF CRLF, argv[i][z]);
                        return GoRawWriteHelp();
                }
            }
            
            for(z = i; z < argc - 1; z++)
            {
                argv[z] = argv[z + 1];
            }
            
            argc--;
            i--;
        }
    }
    
    // Did we get the right number of arguments?  If we're just dumping
    // data, the user is allowed to leave out either the file name or
    // drive letter.
    if(argc != 3)
    {
        if(!((data.lpImage->wFlags & OPTIONS_DUMPINFO) && (argc == 2)))
        {
            return GoRawWriteHelp();
        }
    }
    
    // First argument should be a filename
    if(!(data.lpImage->wFlags & OPTIONS_DUMPINFO) || !IsDrivePath(argv[1], &data.lpDrive->bDrive))
    {
        GetFullPath(data.lpImage->aszFragNames[0], argv[1], MAX_PATH);
    }
    
    // Second argument should be a drive path
    if(argc > 2)
    {
        if(!IsDrivePath(argv[2], &data.lpDrive->bDrive))
        {
            return GoRawWriteHelp();
        }
    }

    // If the drive is compressed, bail
    if(data.lpDrive->bDrive != 0xFF)
    {
        if(GetDriveMapping(data.lpDrive->bDrive, NULL, NULL))
        {
            return ErrorMsg(data.lpImage, ERROR_COMPRESSEDDRIVE);
        }
    }
 
    // Can't put the image file on the image drive
    if(data.lpDrive->bDrive != 0xFF)
    {
        if(toupper(data.lpImage->aszFragNames[0][0]) == data.lpDrive->bDrive + 'A')
        {
            return ErrorMsg(data.lpImage, ERROR_DRIVEWRITE);
        }
    }

#endif // WIN32
    
    // Get drive info
    if(data.lpDrive->bDrive != 0xFF)
    {
        if(nRet = GetDriveInfo(data.lpDrive->bDrive, data.lpDrive))
        {
            return ErrorMsg(data.lpImage, nRet);
        }
    }

    // Attempt to lock the drive
    if((data.lpDrive->bDrive != 0xFF) && !(data.lpImage->wFlags & OPTIONS_NOLOCK))
    {
        if(!LockVolume(data.lpDrive->bDrive) && !(data.lpImage->wFlags & OPTIONS_FORCE))
        {
            if(!AskUser(data.lpImage, "Unable to lock drive %c:.  Continue anyway?", data.lpDrive->bDrive + 'A'))
            {
                return ErrorMsg(data.lpImage, ERROR_LOCKFAIL);
            }
        }
    }

    if(data.lpImage->wFlags & OPTIONS_DUMPINFO)
    {
        nRet = DumpInfo(&data);
    }
    else
    {

#ifdef WIN32

        // Create the progress dialog
        data.lpImage->hWnd = CreateProgressDialog(data.lpImage->hWnd);
    
#endif // WIN32
    
        // Start imaging
        nRet = PutImage(&data);

#ifdef WIN32

        // Close the progress dialog
        data.lpImage->hWnd = CloseProgressDialog(data.lpImage->hWnd);

#endif // WIN32

    }

    // Unlock the drive
    if((data.lpDrive->bDrive != 0xFF) && !(data.lpImage->wFlags & OPTIONS_NOLOCK))
    {
        UnlockVolume(data.lpDrive->bDrive);
    }

    // Release disk util
    FreeDiskUtil();

    // Display any errors
    if(nRet != ERROR_NONE)
    {
        ErrorMsg(data.lpImage, nRet);
    }
    
    // Free memory
    MemFree(data.lpImage->lpbReadBuffer);
    MemFree(data.lpImage->lpbWriteBuffer);

    MemFree(data.lpImage);
    MemFree(data.lpImage);
    MemFree(data.lpDrive);

    // Return

#ifndef WIN32

    printf(CRLF);

#endif // WIN32

    return nRet;
}


int PutImage(LPEVERYTHING lpData)
{
    BGBOOTSECTOR                bsRaw;
    RRBOOTSECTOR                bsImage;
    int                         nRet;
    BOOL                        fBSRead = FALSE;
    DWORD                       dwCurrentSector;
    DWORD                       dwRead;
    DWORD                       dwDriveSectors;
    
    // Scan for bad clusters
    if(nRet = FindBadClusters(lpData, 2, lpData->lpDrive->bs.dwTotalClusters, &(lpData->lpDrive->adwBadClusters), &(lpData->lpDrive->dwBadClusters), FALSE))
    {
        return nRet;
    }

    // Open the first fragment
    if(nRet = OpenFragment(0, lpData, FALSE) && nRet != ERROR_INVALIDIMAGE)
    {
        return nRet;
    }

    // It's possible that the user is trying to dump an invalid image.
    // Let's give them the benefit of the doubt and try to dump it anyway.
    if(nRet == ERROR_INVALIDIMAGE)
    {
        if(!(lpData->lpImage->wFlags & OPTIONS_IGNORETYPE))
        {
            if(!AskUser(lpData->lpImage, "This is not a valid " RAWREAD "/" RAWWRITE " image." CRLF "Attempt to process the image anyway?"))
            {
                return ERROR_INVALIDIMAGE;
            }
        }
        
        // Generate a fake LEADSECTOR based on the boot sector in the image
        MemSet(&(lpData->lpImage->ls), 0, sizeof(lpData->lpImage->ls));
        
        FileSetPos(lpData->lpImage->fhImage, 0, SEEK_SET);            

        if(FileRead(lpData->lpImage->fhImage, &bsRaw, sizeof(bsRaw)) != sizeof(bsRaw))
        {
            return ERROR_FILEREAD;
        }

        if(nRet = ConvertBootSector(&bsRaw, &bsImage))
        {
            return nRet;
        }

        fBSRead = TRUE;
        
        lpData->lpImage->ls.dwClusterCount = bsImage.dwTotalClusters;
        lpData->lpImage->ls.bFragCount = 1;
        lpData->lpImage->ls.dwClustersPerFrag = lpData->lpImage->ls.dwClusterCount;
        lpData->lpImage->ls.dwLastCluster = lpData->lpImage->ls.dwClusterCount - 1;
        lpData->lpImage->ls.fCompleted = TRUE;
    }

    // Read the boot sector from the image
    if(!fBSRead)
    {
        if(FileRead(lpData->lpImage->fhImage, &bsRaw, sizeof(bsRaw)) != sizeof(bsRaw))
        {
            return ERROR_FILEREAD;
        }

        if(nRet = ConvertBootSector(&bsRaw, &bsImage))
        {
            return nRet;
        }
    }
    
    // Is the drive big enough to hold this image?
    if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
    {
        dwDriveSectors = lpData->lpDrive->bs.dwTotalSectors - (lpData->lpDrive->dwBadClusters * lpData->lpDrive->bs.dwSectorsPerCluster);
        
        if(bsImage.dwUsableSectors > dwDriveSectors)
        {
            return ERROR_DRIVETOOSMALL;
        }
        else if(bsImage.dwUsableSectors < dwDriveSectors)
        {
            if(!AskUser(lpData->lpImage, "The target drive has %lu more usable sectors than the original drive." CRLF "These extra sectors will be unusable until the target drive is " CRLF "repartitioned.  Continue anyway?", dwDriveSectors - bsImage.dwUsableSectors))
            {
                return ERROR_USERCANCEL;
            }
        }
    }
    
    // Are the filesystem types compatible?
    if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
    {
        if(StrCmpI(bsImage.szFSType, lpData->lpDrive->bs.szFSType))
        {
            if(!AskUser(lpData->lpImage, "The file system types of the source image and target drive are different.  The" CRLF "target drive will, in essence, be reformatted.  Continue anyway?"))
            {
                return ERROR_WRONGFSTYPE;
            }
        }
    }
    
    // Some fields of the boot sector need to be preserved
    bsRaw.bpb.wSectorsPerTrack = lpData->lpDrive->bs.bsOriginal.bpb.wSectorsPerTrack;
    bsRaw.bpb.wHeadCount = lpData->lpDrive->bs.bsOriginal.bpb.wHeadCount;
    bsRaw.bpb.dwHiddenSectors = lpData->lpDrive->bs.bsOriginal.bpb.dwHiddenSectors;

    // Overwrite our copy of the drive's boot sector with the image's
    ConvertBootSector(&bsRaw, &(lpData->lpDrive->bs));
    
    // Write the metadata area
    dwCurrentSector = 0;

#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Preprocessing %lu sectors...", lpData->lpDrive->bs.dwPreDataSectors);

#else // WIN32

    printf("Preprocessing %lu sectors... ", lpData->lpDrive->bs.dwPreDataSectors);

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZCLUSTER, dwCurrentSector);
    }

#endif // WIN32
    
    if(nRet = VerifyWriteSector(lpData->lpDrive, &(lpData->lpDrive->bs.bsOriginal), lpData->lpImage->lpbReadBuffer, 0, 1, lpData->lpImage->wFlags))
    {
        return nRet;
    }

    dwCurrentSector++;

    while(dwCurrentSector < lpData->lpDrive->bs.dwPreDataSectors)
    {

#ifndef WIN32

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZBACK SZCLUSTER, dwCurrentSector);
        }

#endif // WIN32
    
        dwRead = READWRITE_BUFFER_SIZE / lpData->lpDrive->bs.dwSectorSize;

        if(dwCurrentSector + dwRead > lpData->lpDrive->bs.dwPreDataSectors)
        {
            dwRead = bsImage.dwPreDataSectors - dwCurrentSector;
        }

        if(FileRead(lpData->lpImage->fhImage, lpData->lpImage->lpbWriteBuffer, dwRead * lpData->lpDrive->bs.dwSectorSize) != dwRead * lpData->lpDrive->bs.dwSectorSize)
        {
            return ERROR_FILEREAD;
        }

        if(nRet = VerifyWriteSector(lpData->lpDrive, lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, dwCurrentSector, dwRead, lpData->lpImage->wFlags))
        {
            return nRet;
        }

        dwCurrentSector += dwRead;
    }
    
#ifndef WIN32

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZBACK);
    }

    printf(SZDONE CRLF);

#endif // WIN32
    
    // Enter the main loop
    return EnterMainLoop(lpData);
}


int EnterMainLoop(LPEVERYTHING lpData)
{
    DWORD                       dwBadCluster;
    DWORD                       dwCluWrite;
    DWORD                       dwRead;
    DWORD                       dwWrite;
    DWORD                       dwCheck;
    WORD                        wCompressed;
    DWORD                       dwTotalCompressed;
    WORD                        wUncompressed;
    DWORD                       dwTotalUncompressed;
    BOOL                        fSet;
    LPBYTE                      lpbWrite;
    LPBYTE                      lpbRead;
    DWORD                       dwWipe;
    DWORD                       dwCurrentSector;
    UINT                        nNextBad;
    int                         nRet;
    
    // Position the next bad cluster in the list
    for(nNextBad = 0; nNextBad < lpData->lpDrive->dwBadClusters; nNextBad++)
    {
        if(lpData->lpDrive->adwBadClusters[nNextBad] >= lpData->lpImage->dwCurrentCluster)
        {
            break;
        }
    }
    
    // Here we go...

#ifdef WIN32

    SetProgressLabel(lpData->lpImage->hWnd, "Processing clusters %lu through %lu...", 2, lpData->lpImage->ls.dwClusterCount + 2);

#else // WIN32

    printf("Processing clusters %lu through %lu... ", lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwLastCluster + 2);

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);
    }

#endif // WIN32

    while(TRUE)
    {

#ifdef WIN32

        // Process all pending messages
        ProcessMessages(lpData->lpImage->hWnd);

        if(!IsWindow(lpData->lpImage->hWnd))
        {
            // Time to die
            return ERROR_USERCANCEL;
        }

#endif // WIN32
            
        // Update the progress meter
        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {

#ifdef WIN32

            SetProgressPos(lpData->lpImage->hWnd, lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwClusterCount + 2);

#else // WIN32

            printf(SZBACK SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);

#endif // WIN32

        }

        // Skip ahead to the next allocated cluster.  While we're at it,
        // check to see if it's time to move on to a new fragment.
        dwWipe = 0;

        while(lpData->lpImage->dwCurrentCluster < lpData->lpImage->ls.dwClusterCount)
        {
            if(nRet = NextFragment(lpData))
            {
                return nRet;
            }

            if(!lpData->lpImage->ls.dwAllocBitmapSize)
            {
                break;
            }

            if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
            {
                return nRet;
            }

            if(!fSet)
            {
                break;
            }

            DPF("Cluster %lu is unused", lpData->lpImage->dwCurrentCluster);

            lpData->lpImage->dwCurrentCluster++;
            dwWipe++;
        }

        // Wipe any unused clusters
        if(lpData->lpImage->wFlags & OPTIONS_WIPE && dwWipe)
        {
            if(nRet = WipeClustersToCurrent(lpData, dwWipe))
            {
                return nRet;
            }
        }

        // This is done for UI niceness.  It would be cleaner to change
        // the above while() to check for this.
        if(lpData->lpImage->dwCurrentCluster >= lpData->lpImage->ls.dwClusterCount)
        {
            break;
        }

        // Determine the number of clusters to read
        dwCluWrite = READWRITE_BUFFER_SIZE / (lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
        
        // Make sure we don't read past the end of this fragment
        dwCluWrite = min(dwCluWrite, lpData->lpImage->ls.dwLastCluster + 1 - lpData->lpImage->dwCurrentCluster);
        
        // If there's any unused clusters within the next write buffer, stop just before them
        if(lpData->lpImage->ls.dwAllocBitmapSize)
        {
            dwCheck = 0;
            
            while(dwCheck < dwCluWrite)
            {
                if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster + dwCheck, &fSet))
                {
                    return nRet;
                }
                
                if(fSet)
                {
                    break;
                }
                
                dwCheck++;
            }
            
            dwCluWrite = min(dwCluWrite, dwCheck);
        }
        
        // If there's any bad clusters within the next read buffer, stop just before them
        if(nNextBad < lpData->lpDrive->dwBadClusters)
        {
            dwCluWrite = min(dwCluWrite, lpData->lpDrive->adwBadClusters[nNextBad] - lpData->lpImage->dwCurrentCluster);
        }
        
        // Undocumented switch to force 1 cluster at a time
        if(lpData->lpImage->wFlags & OPTIONS_1CLUSTER)
        {
            dwCluWrite = min(dwCluWrite, 1);
        }
        
        // Calculate the current sector
        dwCurrentSector = ClusterToSector(&(lpData->lpDrive->bs), lpData->lpImage->dwCurrentCluster + 2);
    
        // Read the cluster(s) from the image
        if(dwCluWrite > 0)
        {
            // Read the clusters from the image file
            dwWrite = dwCluWrite * lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize;
            dwRead = FileRead(lpData->lpImage->fhImage, lpData->lpImage->lpbReadBuffer, dwWrite);

            // Copy the read data to the write buffer
            if(lpData->lpImage->ls.dwCompBitmapSize)
            {
                lpbRead = lpData->lpImage->lpbReadBuffer;
                lpbWrite = lpData->lpImage->lpbWriteBuffer;

                dwTotalCompressed = 0;
                dwTotalUncompressed = 0;

                for(dwCheck = 0; dwCheck < dwCluWrite; dwCheck++)
                {
                    wCompressed = wUncompressed = (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
                    
                    if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpCompression), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster + dwCheck, &fSet))
                    {
                        return nRet;
                    }

                    if(fSet)
                    {
                        // This is a compressed cluster
                        if(!UncompressData(lpbRead, &wCompressed, lpbWrite, wUncompressed))
                        {
                            return ERROR_UNCOMPRESS;
                        }

                        DPF("Uncompressed cluster %lu from %u to %u bytes", dwCheck + lpData->lpImage->dwCurrentCluster, wCompressed, wUncompressed);
                    }
                    else
                    {
                        // The data is not compressed.  Just copy it to the write buffer
                        DPF("Cluster %lu is not compressed", dwCheck + lpData->lpImage->dwCurrentCluster);
                        MemCopy(lpbWrite, lpbRead, wUncompressed);
                    }

                    lpbRead += wCompressed;
                    dwTotalCompressed += wCompressed;

                    lpbWrite += wUncompressed;
                    dwTotalUncompressed += wUncompressed;
                }

                DPF("Uncompressed a total of %lu to %lu bytes", dwTotalCompressed, dwTotalUncompressed);

                // Verify that we uncompressed the correct amount of data
                if(dwTotalUncompressed != dwWrite)
                {
                    return ERROR_UNCOMPRESS;
                }

                // Reposition the file cursor
                DPF("Backing up %ld bytes", dwTotalCompressed - dwRead);
                
                if(FileSetPos(lpData->lpImage->fhImage, dwTotalCompressed - dwRead, SEEK_CUR) == -1)
                {
                    return ERROR_FILEREAD;
                }
            }
            else
            {
                // The data is not compressed.  Verify that we read the correct 
                // amount of data.
                if(dwWrite != dwRead)
                {
                    return ERROR_FILEREAD;
                }

                // Copy the data to the write buffer
                MemCopy(lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, (UINT)dwRead);
            }
        }

        // Special case any odd clusters (i.e. bad, unallocated)
        if(dwCluWrite < 1)
        {
            // Is the corresponding cluster on the drive bad?
            if(nNextBad < lpData->lpDrive->dwBadClusters && lpData->lpDrive->adwBadClusters[nNextBad] == lpData->lpImage->dwCurrentCluster)
            {
                nNextBad++;
                
                // Determine the cluster size
                if(lpData->lpImage->ls.dwCompBitmapSize)
                {
                    if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpCompression), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
                    {
                        return nRet;
                    }
                }
                else
                {
                    fSet = FALSE;
                }
                
                if(fSet)
                {
                    // The size of the compressed cluster is stored in the first
                    // two bytes of the data.
                    if(FileRead(lpData->lpImage->fhImage, &wCompressed, sizeof(WORD)) != sizeof(WORD))
                    {
                        return ERROR_FILEREAD;
                    }
                }
                else
                {
                    // Just go with the default
                    wCompressed = (WORD)(lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);
                }
                
                // Seek past the cluster
                if(FileSetPos(lpData->lpImage->fhImage, wCompressed, SEEK_CUR) == -1)
                {
                    return ERROR_FILEREAD;
                }
            }
            else
            {
                // Is the cluster unused?
                if(lpData->lpImage->ls.dwAllocBitmapSize)
                {
                    if(nRet = GetBitmapBit(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->dwCurrentCluster - lpData->lpImage->ls.dwFirstCluster, &fSet))
                    {
                        return nRet;
                    }
                }
                else
                {
                    fSet = FALSE;
                }
                
                if(fSet)
                {
                    // The cluster isn't allocated, and therefore is not
                    // actually in the image.  Just move along...
                }
            }
        }
        
        // Write the cluster(s) to the drive
        if(dwCluWrite)
        {
            if(nRet = VerifyWriteSector(lpData->lpDrive, lpData->lpImage->lpbWriteBuffer, lpData->lpImage->lpbReadBuffer, dwCurrentSector, dwCluWrite * lpData->lpDrive->bs.dwSectorsPerCluster, lpData->lpImage->wFlags))
            {
                if(nRet == ERROR_DRIVEWRITE)
                {
                    // Uh-oh.  We couldn't write to one of the clusters.  Break the loop
                    // down to 1 cluster at a time and determine which cluster it was.
                    for(dwBadCluster = 0; dwBadCluster < dwCluWrite; dwBadCluster++)
                    {
                        lpbWrite = lpData->lpImage->lpbWriteBuffer + (dwBadCluster * lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize);

                        if(nRet = VerifyWriteSector(lpData->lpDrive, lpbWrite, lpData->lpImage->lpbReadBuffer, dwCurrentSector + (dwBadCluster * lpData->lpDrive->bs.dwSectorsPerCluster), 1, lpData->lpImage->wFlags))
                        {
                            if(nRet == ERROR_DRIVEWRITE)
                            {

#ifdef WIN32

                                if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
                                {
                                    ImageMessageBox(lpData->lpImage->hWnd, MB_ICONEXCLAMATION, "Unable to write to cluster %lu.... ", lpData->lpImage->dwCurrentCluster + 2 + dwBadCluster);
                                }

#else // WIN32

                                printf(CRLF "Unable to write to cluster %lu.  ", lpData->lpImage->dwCurrentCluster + 2 + dwBadCluster);
                        
                                if(lpData->lpImage->wFlags & OPTIONS_FORCE)
                                {
                                    printf("Continuing... ");
                                }
                                else
                                {
                                    printf(CRLF);
                                }

#endif // WIN32
                        
                                if(!(lpData->lpImage->wFlags & OPTIONS_FORCE))
                                {
                                    return ERROR_DRIVEWRITE;
                                }

#ifndef WIN32
                        
                                if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
                                {
                                    printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + dwBadCluster + 2 + 1);
                                }

#endif // WIN32
                            
                            }
                            else
                            {
                                return nRet;
                            }
                        }
                    }
                }
                else
                {
                    return nRet;
                }
            }
        }
        
        // It's possible we didn't actually write any clusters.  This
        // will happen if we were looking for allocated clusters only
        // and the next cluster to write was unused.
        dwCluWrite = max(dwCluWrite, 1);
        
        lpData->lpImage->dwCurrentCluster += dwCluWrite;
    }
    
    // Close the last fragment

#ifdef WIN32

    ImageMessageBox(lpData->lpImage->hWnd, MB_ICONINFORMATION, "Image complete");

#else // WIN32

    if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
    {
        printf(SZBACK);
    }

    printf("\a" SZDONE);

#endif // WIN32

    if(nRet = CloseFragment(lpData))
    {
        return nRet;
    }
    
    // Return success
    return ERROR_NONE;
}


int NextFragment(LPEVERYTHING lpData)
{
    int						nRet;
    
    if(lpData->lpImage->dwCurrentCluster > lpData->lpImage->ls.dwLastCluster)
    {

#ifndef WIN32

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZBACK);
        }

        printf(SZDONE CRLF);

#endif // WIN32
    
        if(nRet = CloseFragment(lpData))
        {
            return nRet;
        }
        
        if(nRet = OpenFragment(++(lpData->lpImage->ls.bSequence), lpData, FALSE))
        {
            return nRet;
        }

#ifndef WIN32

        printf("Processing clusters %lu through %lu... ", lpData->lpImage->dwCurrentCluster + 2, lpData->lpImage->ls.dwLastCluster + 2);

        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {
            printf(SZCLUSTER, lpData->lpImage->dwCurrentCluster + 2);
        }

#endif // WIN32

    }

    return ERROR_NONE;
}
    

int OpenFragment(BYTE bFrag, LPEVERYTHING lpData, BOOL fQuiet)
{
    DWORD                       dwFirstData;
    int                         nRet;

    // If we're spanning media, prompt the user to insert the next disk
    if(lpData->lpImage->wFlags & OPTIONS_SPAN)
    {
        InsertDisk(lpData->lpImage, lpData->lpImage->aszFragNames[bFrag], (char)toupper(lpData->lpImage->aszFragNames[bFrag][0]));
    }

    do
    {
        // Open the file
        if((lpData->lpImage->fhImage = OpenFragmentForRead(bFrag, lpData->lpImage)) == INVALID_FILE_HANDLE)
        {
            return ERROR_FILEOPEN;
        }
        
        // Read the image header
        if(nRet = ReadImageHeader(lpData->lpImage->fhImage, &(lpData->lpImage->ls), &dwFirstData, FALSE))
        {
            return nRet;
        }
        
        // Is this actually the next image in the sequence?
        if(lpData->lpImage->ls.bSequence != bFrag)
        {
            FileClose(lpData->lpImage->fhImage);
            lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
                
            ErrorMsg(lpData->lpImage, ERROR_OUTOFSEQUENCE);

            if(nRet = GetFragNames(lpData->lpImage, bFrag, 1))
            {
                return nRet;
            }
        }
    }
    while(lpData->lpImage->ls.bSequence != bFrag);

#ifndef WIN32

    // Tell the user what we're going to do
    if(!fQuiet)
    {
        printf("Writing image:  %s" CRLF, lpData->lpImage->aszFragNames[bFrag]);
        printf("To drive:       %c: (%s)" CRLF, lpData->lpDrive->bDrive + 'A', lpData->lpDrive->bs.szVolumeLabel);
        printf("Fragment:       %u of %u" CRLF, bFrag + 1, lpData->lpImage->ls.bFragCount);
        printf(CRLF);
    }

#endif // WIN32

    // Validate the cluster offset
    if(lpData->lpImage->ls.dwFirstCluster != lpData->lpImage->dwCurrentCluster)
    {
        return ERROR_BADCLUSTEROFFSET;
    }
    
    // Initialize the bitmaps
    if(lpData->lpImage->ls.dwCompBitmapSize)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpCompression), lpData->lpImage->ls.dwCompBitmapSize, lpData->lpImage->fhImage, 2, TRUE))
        {
            return nRet;
        }
    }
    
    if(lpData->lpImage->ls.dwAllocBitmapSize)
    {
        if(nRet = InitBitmap(&(lpData->lpImage->ibmpAllocation), lpData->lpImage->ls.dwAllocBitmapSize, lpData->lpImage->fhImage, 2 + lpData->lpImage->ls.dwCompBitmapSize, TRUE))
        {
            return nRet;
        }
    }
    
    // Seek to the start of the data area
    FileSetPos(lpData->lpImage->fhImage, dwFirstData, SEEK_SET);

    // Return success
    return ERROR_NONE;
}


int CloseFragment(LPEVERYTHING lpData)
{
    int                         nRet;
    
    // Copy the name of the next fragment into the array
    GetFullPath(lpData->lpImage->aszFragNames[lpData->lpImage->ls.bSequence + 1], lpData->lpImage->ls.szNextFrag, MAX_PATH);
    
    // Close the bitmaps
    if(lpData->lpImage->ls.dwCompBitmapSize)
    {
        if(nRet = DiscardBitmap(&(lpData->lpImage->ibmpCompression)))
        {
            return nRet;
        }
    }
    
    if(lpData->lpImage->ls.dwAllocBitmapSize)
    {
        if(nRet = DiscardBitmap(&(lpData->lpImage->ibmpAllocation)))
        {
            return nRet;
        }
    }
    
    // Close the file handle
    FileClose(lpData->lpImage->fhImage);
    lpData->lpImage->fhImage = INVALID_FILE_HANDLE;
    
    // Return success
    return ERROR_NONE;
}


int VerifyWriteSector(LPDRIVEINFO lpDrive, LPVOID lpvWriteBuffer, LPVOID lpvVerifyBuffer, DWORD dwSector, DWORD dwCount, WORD wFlags)
{
    if(!WriteSectorEx(lpDrive->bDrive, lpvWriteBuffer, dwSector, dwCount, lpDrive->bs.dwSectorSize))
    {
        return ERROR_DRIVEWRITE;
    }
    
    if(wFlags & OPTIONS_VERIFY)
    {
        if(!ReadSectorEx(lpDrive->bDrive, lpvVerifyBuffer, dwSector, dwCount, lpDrive->bs.dwSectorSize))
        {
            return ERROR_DRIVEREAD;
        }

        if(MemCmp(lpvVerifyBuffer, lpvWriteBuffer, (UINT)(dwCount * lpDrive->bs.dwSectorSize)))
        {
            return ERROR_VERIFYDISK;
        }
    }

    return ERROR_NONE;
}


int WipeClustersToCurrent(LPEVERYTHING lpData, DWORD dwCount)
{
    DWORD                       dwCurrentCluster;
    DWORD                       dwCurrentSector;
    DWORD                       dwWipe;
    
    dwCurrentCluster = lpData->lpImage->dwCurrentCluster - dwCount;
    dwCurrentSector = ClusterToSector(&(lpData->lpDrive->bs), dwCurrentCluster + 2);
    
    MemSet(lpData->lpImage->lpbWriteBuffer, 0, (UINT)READWRITE_BUFFER_SIZE);

    while(dwCount)
    {
        if(!(lpData->lpImage->wFlags & OPTIONS_NOSTATUS))
        {

#ifdef WIN32

            SetProgressPos(lpData->lpImage->hWnd, dwCurrentCluster + 2, lpData->lpImage->ls.dwClusterCount + 2);

#else // WIN32

            printf(SZBACK SZCLUSTER, dwCurrentCluster + 2);

#endif // WIN32

        }

        dwWipe = min(dwCount, READWRITE_BUFFER_SIZE / (lpData->lpDrive->bs.dwSectorsPerCluster * lpData->lpDrive->bs.dwSectorSize));
        DPF("Wiping clusters %lu to %lu", dwCurrentCluster, dwWipe);

        if(!WriteSectorEx(lpData->lpDrive->bDrive, lpData->lpImage->lpbWriteBuffer, dwCurrentSector, dwWipe * lpData->lpDrive->bs.dwSectorsPerCluster, lpData->lpDrive->bs.dwSectorSize))
        {
            return ERROR_DRIVEWRITE;
        }

        dwCurrentCluster += dwWipe;
        dwCurrentSector += dwWipe * lpData->lpDrive->bs.dwSectorsPerCluster;
        dwCount -= dwWipe;
    }

    return ERROR_NONE;
}


int DumpInfo(LPEVERYTHING lpData)
{
    BGBOOTSECTOR                bsRaw;
    RRBOOTSECTOR                bs;
    int                         nRet;
    BYTE                        bFrag;
    char                        szText[0xFF];
    
    if(lpData->lpDrive->bDrive != 0xFF)
    {
        DumpBootSector("Target drive boot sector", &(lpData->lpDrive->bs));
    }

    if(lpData->lpImage->aszFragNames[0][0])
    {
        bFrag = 0;
        
        do
        {
            if(nRet = OpenFragment(bFrag, lpData, TRUE))
            {
                return nRet;
            }

            if(!bFrag)
            {
                if(FileRead(lpData->lpImage->fhImage, &bsRaw, sizeof(bsRaw)) != sizeof(bsRaw))
                {
                    return ERROR_FILEREAD;
                }

                if(nRet = ConvertBootSector(&bsRaw, &bs))
                {
                    return nRet;
                }
        
                DumpBootSector("Source drive boot sector", &bs);
            }

            sprintf(szText, "Image header for fragment %u", bFrag);
            DumpLeadSector(szText, &(lpData->lpImage->ls));

            if(nRet = CloseFragment(lpData))
            {
                return nRet;
            }
    
            lpData->lpImage->dwCurrentCluster = lpData->lpImage->ls.dwLastCluster + 1;
        } 
        while(++bFrag < lpData->lpImage->ls.bFragCount);
    }

    return ERROR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\reg.h ===
#ifndef _INC_REG
#define _INC_REG

#include <windows.h>
#include "..\defs.h"
#include "..\image.h"

#define REG_KEY_PARENT          HKEY_LOCAL_MACHINE
#define REG_KEY                 "Software\\Microsoft\\"APPTITLE

#define REG_VAL_DRIVE           "Drive"
#define REG_TYPE_DRIVE          REG_BINARY

#define REG_VAL_FILE            "File"
#define REG_TYPE_FILE           REG_SZ

#define REG_VAL_MAXFRAGSIZE     "Maximum Fragment Size"
#define REG_TYPE_MAXFRAGSIZE    REG_BINARY

#define REG_VAL_WINDOWPOS       "Window Position"
#define REG_TYPE_WINDOWPOS      REG_BINARY

#define REG_VAL_OPTIONS         "Options"
#define REG_TYPE_OPTIONS        REG_BINARY

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern void GetRegWindowPos(HWND);
extern void PutRegWindowPos(HWND);
extern void GetRegOptions(LPIMAGESTRUCT lpImage);
extern void SetRegOptions(LPIMAGESTRUCT lpImage);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _INC_REG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by image.rc
//
#define IDD_RAWREAD                     101
#define IDD_FRAGLIST                    102
#define IDD_FRAGNAME                    103
#define IDD_RAWWRITE                    104
#define IDD_PROGRESS                    105
#define IDI_IMAGE                       106
#define IDI_IMAGEDOC                    107
#define IDM_IMAGE                       111
#define IDR_ACCELERATOR                 112
#define IDC_DRIVELIST                   1000
#define IDC_FILE                        1001
#define IDC_FILE_BROWSE                 1002
#define IDC_FRAGSIZE                    1003
#define IDC_FRAGSIZE_SPIN               1004
#define IDC_OPTION_COMPRESS             1005
#define IDC_OPTION_SPAN                 1006
#define IDC_OPTION_ALLOCATED            1012
#define IDC_OPTION_FINDBAD              1013
#define IDC_OPTION_VERIFY               1014
#define IDC_OPTION_NOSTOPONERROR        1015
#define IDC_FRAGLIST                    1018
#define IDC_FRAGNAME                    1019
#define IDC_FRAGNAME_BROWSE             1021
#define IDC_LABEL                       1022
#define IDC_OPTION_WIPE                 1023
#define IDC_CLUSTER                     1023
#define IDC_PROGRESS                    1024
#define IDC_CHANGE                      1030
#define ID_FILE_REFRESHDRIVELIST        40001
#define ID_FILE_EXIT                    40002
#define ID_HELP_ABOUT                   40003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\text.h ===
#ifndef _INC_TEXT
#define _INC_TEXT

#include "defs.h"
#include "image.h"

#define VERSION         "3.22"

#define RAWREAD         "RawRead"
#define RAWWRITE        "RawWrite"

#ifdef MSINTERNAL
#define PROPAGANDA1     RAWREAD "/" RAWWRITE " version " VERSION " by Derek Smith (dereks)."
#else // MSINTERNAL
#define PROPAGANDA1     RAWREAD "/" RAWWRITE " version " VERSION "."
#endif // MSINTERNAL

#define PROPAGANDA2     "Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved."
#define PROPAGANDA3     "Reads or writes an exact copy of any MS-DOS or Win9X formatted media."

#ifdef MSINTERNAL
#define PROPAGANDA4     "This is a Microsoft-internal tool and may not be distributed."
#endif // MSINTERNAL

#define CRLF            "\r\n"

#define SZCLUSTER       "%10lu"
#define SZBACK          "\b\b\b\b\b\b\b\b\b\b"
#define SZDONE          "[ok]      " CRLF

#define LINE            "==============================================================================" CRLF

#ifdef __cplusplus
extern "C" {
#endif

// Prototypes
extern BOOL AskUser(LPIMAGESTRUCT, LPCSTR, ...);
extern void InsertDisk(LPIMAGESTRUCT, LPCSTR, char);
extern int ErrorMsg(LPIMAGESTRUCT, int);
extern int GetFullPath(LPSTR, LPCSTR, UINT);
extern int GetFullPathInPlace(LPSTR, UINT);
extern int GetFileLocation(LPCSTR, LPSTR, LPSTR);
extern int SetFilePath(LPCSTR, LPCSTR, LPSTR);
extern int ValidateFileName(LPCSTR);
extern LPSTR StrCpy(LPSTR, LPCSTR);
extern int StrLen(LPCSTR);
extern int StrCmp(LPCSTR, LPCSTR);
extern int StrCmpI(LPCSTR, LPCSTR);
extern LPSTR StrCat(LPSTR, LPCSTR);
extern void DumpBootSector(LPSTR, LPRRBOOTSECTOR);
extern void DumpDPB(LPSTR, LPDPB);
extern void DumpLeadSector(LPSTR, LPLEADSECTOR);
extern BOOL IsDrivePath(LPSTR, LPBYTE);

#ifdef WIN32

extern int ImageMessageBox(HWND, UINT, LPCSTR, ...);
extern int GetShortFileName(LPCSTR, LPSTR);

#else // WIN32

extern void GoPropaganda(void);
extern int GoRawReadHelp(void);
extern int GoRawWriteHelp(void);
extern void FlushKeyboardBuffer(void);

#endif // WIN32

#ifdef __cplusplus
}
#endif

#endif // _INC_TEXT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\winmisc.c ===
#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include "..\bootsec.h"
#include "debug.h"
#include "..\diskutil.h"
#include "..\mem.h"
#include "winmisc.h"
#include "resource.h"
#include "..\text.h"


typedef struct tagFILENAMESTRUCT
{
    LPSTR                   lpszLabel;
    LPSTR                   lpszFile;
} FILENAMESTRUCT, *LPFILENAMESTRUCT;


HCURSOR                     g_hPrevCursor = NULL;
HWND                        g_hWndParent = NULL;
WNDPROC                     g_lpfnOldWndProc = NULL;


BOOL CALLBACK ProgressDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK GetFileNameDlgProc(HWND, UINT, WPARAM, LPARAM);
LPARAM CALLBACK DragDropCallback(HWND, UINT, WPARAM, LPARAM);


int ParseCommandLine(LPCSTR lpszCmdLine, LPSTR **lpszArg)
{
    LPSTR                   lpszParsed, lpsz;
    BOOL                    fOpenQuote = FALSE;
    int                     nArgCount = 0, i, nLen;;

    *lpszArg = NULL;
    
    // Make a copy of the command line
    if(!(lpszParsed = (LPSTR)MemAlloc(lstrlen(lpszCmdLine) + 2)))
    {
        DPF("Out of memory");
        return 0;
    }

    lpsz = lpszParsed;

    // Skip any leading spaces
    while(*lpszCmdLine == ' ')
    {
        lpszCmdLine++;
    }

    // Parse the command line
    while(*lpszCmdLine)
    {
        switch(*lpszCmdLine)
        {
            case '\"':
                fOpenQuote = !fOpenQuote;
                lpszCmdLine++;
                
                break;

            case ' ':
                if(!fOpenQuote)
                {
                    while(*lpszCmdLine && *lpszCmdLine == ' ')
                    {
                        lpszCmdLine++;
                    }
                    
                    *lpsz++ = 0;

                    break;
                }

                // Fall through

            default:
                *lpsz++ = *lpszCmdLine++;

                break;
        }
    }

    // double NULL-terminate
    *(LPWORD)lpsz = 0;

    // Count the number of arguments
    lpsz = lpszParsed;

    while(*lpsz)
    {
        while(*lpsz++);

        nArgCount++;
        lpsz++;
    }

    if(!nArgCount)
    {
        return 0;
    }

    // Return the number of arguments
    if(!(*lpszArg = (LPSTR *)MemAlloc(sizeof(LPSTR) * nArgCount)))
    {
        DPF("Out of memory");
        MemFree(lpszParsed);

        return 0;
    }

    lpsz = lpszParsed;
    
    for(i = 0; i < nArgCount; i++)
    {
        nLen = lstrlen(lpsz);
        (*lpszArg)[i] = (LPSTR)MemAlloc(nLen + 1);
        lstrcpy((*lpszArg)[i], lpsz);
        lpsz += lstrlen(lpsz) + 1;

        DPF("Argument %u:  %s", i, (*lpszArg)[i]);
    }

    return nArgCount;
}


void FreeCommandLine(int argc, LPSTR **argv)
{
    int                     i;
    
    if(argc)
    {
        for(i = 0; i < argc; i++)
        {
            MemFree((*argv)[i]);
        }

        MemFree(*argv);
    }

    *argv = NULL;
}    


void InitDriveList(HWND hWndLV)
{
    HIMAGELIST              hImageList;
    LV_COLUMN               lvc;
    LV_ITEM                 lvi;
    int                     nItem;
    BYTE                    bDrive;
    char                    szRoot[4], szLabel[0xFF];
    UINT                    uDriveType;
    SHFILEINFO              shfi;
    DWORD                   dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwTotalClusters;

    // Hourglass
    SetWaitCursor(hWndLV);
    
    // Reset the list
    ListView_DeleteAllItems(hWndLV);
    while(ListView_DeleteColumn(hWndLV, 0));

    if(hImageList = ListView_GetImageList(hWndLV, LVSIL_SMALL))
    {
        ImageList_Destroy(hImageList);
    }

    hImageList = ImageList_Create(16, 16, ILC_COLOR8, 16, 16);

    ImageList_SetBkColor(hImageList, GetSysColor(COLOR_WINDOW));
    ListView_SetImageList(hWndLV, hImageList, LVSIL_SMALL);    

    // Add the columns
    MemSet(&lvc, 0, sizeof(lvc));

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 125;
    lvc.pszText = "Name";
    lvc.cchTextMax = lstrlen(lvc.pszText);

    ListView_InsertColumn(hWndLV, lvc.iSubItem, &lvc);

    lvc.fmt = LVCFMT_CENTER;
    lvc.cx = 75;
    lvc.pszText = "File System";
    lvc.cchTextMax = lstrlen(lvc.pszText);

    ListView_InsertColumn(hWndLV, ++(lvc.iSubItem), &lvc);

    lvc.pszText = "Total Size";
    lvc.cchTextMax = lstrlen(lvc.pszText);

    ListView_InsertColumn(hWndLV, ++(lvc.iSubItem), &lvc);

    lvc.pszText = "Free Space";
    lvc.cchTextMax = lstrlen(lvc.pszText);

    ListView_InsertColumn(hWndLV, ++(lvc.iSubItem), &lvc);

    // Add each local drive to the list
    szRoot[1] = ':';
    szRoot[2] = '\\';
    szRoot[3] = 0;

    nItem = 0;
    
    for(bDrive = 0; bDrive < 26; bDrive++)
    {
        szRoot[0] = bDrive + 'A';
        uDriveType = GetDriveType(szRoot);

        DPF("Drive %u (%c:) is type %u", bDrive, szRoot[0], uDriveType);

        if(uDriveType == DRIVE_REMOVABLE || uDriveType == DRIVE_FIXED || uDriveType == DRIVE_RAMDISK)
        {
            if(!GetDiskFreeSpace(szRoot, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwTotalClusters))
            {
                DPF("Can't get free space on drive %u", bDrive);
                continue;
            }

            if(GetDriveMapping(bDrive, NULL, NULL))
            {
                DPF("Drive %u is compressed", bDrive);
                continue;
            }

            if(!GetFileSystemType(bDrive, szLabel))
            {
                DPF("Can't get file system type for drive %u", bDrive);
                continue;
            }

            MemSet(&shfi, 0, sizeof(shfi));
            SHGetFileInfo(szRoot, 0, &shfi, sizeof(shfi), SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON);
            
            MemSet(&lvi, 0, sizeof(lvi));

            lvi.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_TEXT;
            lvi.iItem = nItem;
            lvi.pszText = shfi.szDisplayName;
            lvi.cchTextMax = lstrlen(lvi.pszText);
            lvi.iImage = ImageList_AddIcon(hImageList, shfi.hIcon);
            lvi.lParam = bDrive;

            ListView_InsertItem(hWndLV, &lvi);

            lvi.mask &= ~(LVIF_IMAGE | LVIF_PARAM);
            lvi.pszText = szLabel;
            lvi.cchTextMax = lstrlen(lvi.pszText);
            lvi.iSubItem++;

            ListView_SetItem(hWndLV, &lvi);

            BytesToString(dwSectorsPerCluster * dwBytesPerSector * dwTotalClusters, szLabel);
            
            lvi.pszText = szLabel;
            lvi.cchTextMax = lstrlen(lvi.pszText);
            lvi.iSubItem++;

            ListView_SetItem(hWndLV, &lvi);

            BytesToString(dwSectorsPerCluster * dwBytesPerSector * dwFreeClusters, szLabel);
                        
            lvi.pszText = szLabel;
            lvi.cchTextMax = lstrlen(lvi.pszText);
            lvi.iSubItem++;

            ListView_SetItem(hWndLV, &lvi);

            nItem++;
        }
    }

    // Un-hourglass
    ReleaseWaitCursor();
}


void BytesToString(DWORDLONG dwBytes, LPSTR lpszString)
{
    DWORDLONG               dwDiv, dwMod;
    LPCSTR                  lpszLabel;
    
    if(dwBytes >= 0x40000000)
    {
        dwDiv = 0x40000000;
        lpszLabel = "GB";
    }
    else if(dwBytes >= 0x100000)
    {
        dwDiv = 0x100000;
        lpszLabel = "MB";
    }
    else
    {
        dwDiv = 1;
        lpszLabel = "Bytes";
    }

    wsprintf(lpszString, "%lu", (DWORD)(dwBytes / dwDiv));
    
    if(dwMod = dwBytes % dwDiv)
    {
        wsprintf(lpszString + lstrlen(lpszString), ".%-2.2lu", (DWORD)((dwMod * 100) / dwDiv));
    }

    lstrcat(lpszString, " ");
    lstrcat(lpszString, lpszLabel);
}


void SetWaitCursor(HWND hWnd)
{
    SetCapture(hWnd);
    g_hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
}


void ReleaseWaitCursor(void)
{
    SetCursor(g_hPrevCursor);
    ReleaseCapture();
}


BOOL BrowseForImageFile(HWND hWndParent, LPSTR lpszFileName, BOOL fAllowCreate)
{
    OPENFILENAME            ofn;
    static char             szCurDir[MAX_PATH];

    MemSet(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWndParent;
    ofn.lpstrFilter = "Image Files (*.img)\0*.img\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = lpszFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szCurDir;
    ofn.lpstrTitle = "Open Image File";
    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = "img";

    if(!fAllowCreate)
    {
        ofn.Flags |= OFN_FILEMUSTEXIST;
    }

    return GetOpenFileName(&ofn);
}


void CenterWindow(HWND hWnd, HWND hWndParent)
{
    RECT                    rc, rcParent;

    GetWindowRect(hWnd, &rc);

    if(hWndParent)
    {
        GetWindowRect(hWndParent, &rcParent);
    }
    else
    {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcParent, 0);
    }

    SetWindowPos(hWnd, NULL, rcParent.left + (((rcParent.right - rcParent.left) - (rc.right - rc.left)) / 2), rcParent.top + (((rcParent.bottom - rcParent.top) - (rc.bottom - rc.top)) / 2), 0, 0, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);
}


HWND CreateProgressDialog(HWND hWndParent)
{
    g_hWndParent = hWndParent;
    
    return CreateDialog(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_PROGRESS), hWndParent, ProgressDlgProc);
}


HWND CloseProgressDialog(HWND hWnd)
{
    // Close the dialog
    if(IsWindow(hWnd))
    {
        SendMessage(hWnd, WM_CLOSE, 0, 0);
        while(IsWindow(hWnd));
    }

    // Return the parent window handle
    return g_hWndParent;
}


BOOL CALLBACK ProgressDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND                    hWndParent;
    
    switch(uMsg)
    {
        case WM_INITDIALOG:
            hWndParent = GetParent(hWnd);
            
            // Initialize the progress bar
            SendDlgItemMessage(hWnd, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
            SendDlgItemMessage(hWnd, IDC_PROGRESS, PBM_SETPOS, 0, 0);

            // Center the window
            CenterWindow(hWnd, hWndParent);

            // Become visible
            ShowWindow(hWnd, SW_RESTORE);
            UpdateWindow(hWnd);

            // Disable the parent window
            EnableWindow(hWndParent, FALSE);

            return FALSE;

        case WM_CLOSE:
            hWndParent = GetParent(hWnd);
            
            // Enable the parent window
            EnableWindow(hWndParent, TRUE);
            
            // Destroy the dialog
            ShowWindow(hWnd, SW_HIDE);
            DestroyWindow(hWnd);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);

                    break;
            }

            break;
    }

    return FALSE;
}


void SetProgressLabel(HWND hWnd, LPSTR lpszFormat, ...)
{
    va_list                 va;
    char                    szString[0xFF];

    va_start(va, lpszFormat);
    wvsprintf(szString, lpszFormat, va);
    va_end(va);

    SetDlgItemText(hWnd, IDC_LABEL, szString);
    
    UpdateWindow(hWnd);
}


void SetProgressPos(HWND hWnd, DWORD dwCurrentCluster, DWORD dwTotalClusters)
{
    char                    szCluster[13];

    wsprintf(szCluster, "%lu", dwCurrentCluster);
    
    SendDlgItemMessage(hWnd, IDC_PROGRESS, PBM_SETPOS, (WORD)(((DWORDLONG)dwCurrentCluster * 100) / (DWORDLONG)dwTotalClusters), 0);
    SetDlgItemText(hWnd, IDC_CLUSTER, szCluster);

    UpdateWindow(hWnd);
}


BOOL GetFileName(HWND hWndParent, LPSTR lpszLabel, LPSTR lpszFile)
{
    FILENAMESTRUCT          fns;
    
    fns.lpszLabel = lpszLabel;
    fns.lpszFile = lpszFile;

    return DialogBoxParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_FRAGNAME), hWndParent, GetFileNameDlgProc, (LPARAM)&fns);
}


BOOL GetFragmentName(HWND hWndParent, UINT uFrag, LPSTR lpszFile)
{
    char                    szLabel[512];

    wsprintf(szLabel, "Please enter the filename for fragment %u", uFrag);

    return GetFileName(hWndParent, szLabel, lpszFile);
}


BOOL CALLBACK GetFileNameDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPFILENAMESTRUCT lpfns;
    char                    szFile[MAX_PATH];

    switch(uMsg)
    {
        case WM_INITDIALOG:
            lpfns = (LPFILENAMESTRUCT)lParam;

            // Set the text label
            SetDlgItemText(hWnd, IDC_LABEL, lpfns->lpszLabel);

            // Initialize the filename
            SetDlgItemText(hWnd, IDC_FRAGNAME, lpfns->lpszFile);

            return TRUE;

        case WM_CLOSE:
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    GetDlgItemText(hWnd, IDC_FRAGNAME, szFile, MAX_PATH);

                    // Check the image filename.  Names > 8.3 are not supported
                    if(ValidateFileName(szFile))
                    {
                        ImageMessageBox(hWnd, MB_ICONEXCLAMATION, "Long filenames are not supported for image fragments.");
                        break;
                    }
    
                    GetFullPath(lpfns->lpszFile, szFile, MAX_PATH);
                    EndDialog(hWnd, TRUE);

                    break;

                case IDCANCEL:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);

                    break;

                case IDC_FRAGNAME_BROWSE:
                    GetDlgItemText(hWnd, IDC_FRAGNAME, szFile, sizeof(szFile));
                    
                    if(BrowseForImageFile(hWnd, szFile, TRUE))
                    {
                        SetDlgItemText(hWnd, IDC_FRAGNAME, szFile);
                    }
                    
                    break;
            }

            break;
    }

    return FALSE;
}


void ProcessMessages(HWND hWnd)
{
    MSG                         msg;

    while(PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
    {
        GetMessage(&msg, NULL, 0, 0);

        if(!IsDialogMessage(hWnd, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}
    

void GetCheckFlag(HWND hWnd, UINT uId, WORD wBit, LPWORD lpwFlags)
{
    if(IsDlgButtonChecked(hWnd, uId))
    {
        *lpwFlags |= wBit;
    }
    else
    {
        *lpwFlags &= ~wBit;
    }
}

void SetCheckFlag(HWND hWnd, UINT uId, WORD wBit, WORD wFlags)
{
    CheckDlgButton(hWnd, uId, (wFlags & wBit) ? BST_CHECKED : BST_UNCHECKED);
}


void EnableDragDrop(HWND hWnd, BOOL fEnable)
{
    DragAcceptFiles(hWnd, fEnable);

    if(fEnable && !g_lpfnOldWndProc)
    {
        g_lpfnOldWndProc = (WNDPROC)SetWindowLong(hWnd, GWL_WNDPROC, (LONG)DragDropCallback);
    }
}


LPARAM CALLBACK DragDropCallback(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char                        szFile[MAX_PATH];

    switch(uMsg)
    {
        case WM_DROPFILES:
            DragQueryFile((HDROP)wParam, 0, szFile, sizeof(szFile));
            DragFinish((HDROP)wParam);
            SetWindowText(hWnd, szFile);

            return TRUE;
    }

    return g_lpfnOldWndProc ? CallWindowProc(g_lpfnOldWndProc, hWnd, uMsg, wParam, lParam) : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\winmisc.h ===
#ifndef _INC_WINMISC
#define _INC_WINMISC

#include <windows.h>
#include "..\defs.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern int ParseCommandLine(LPCSTR, LPSTR **);
extern void FreeCommandLine(int, LPSTR **);
extern void InitDriveList(HWND);
extern void BytesToString(DWORDLONG, LPSTR);
extern void SetWaitCursor(HWND);
extern void ReleaseWaitCursor(void);
extern BOOL BrowseForImageFile(HWND, LPSTR, BOOL);
extern void CenterWindow(HWND, HWND);
extern HWND CreateProgressDialog(HWND);
extern HWND CloseProgressDialog(HWND);
extern void SetProgressLabel(HWND, LPSTR, ...);
extern void SetProgressPos(HWND, DWORD, DWORD);
extern BOOL GetFileName(HWND, LPSTR, LPSTR);
extern BOOL GetFragmentName(HWND, UINT, LPSTR);
extern void ProcessMessages(HWND);
extern void GetCheckFlag(HWND, UINT, WORD, LPWORD);
extern void SetCheckFlag(HWND, UINT, WORD, WORD);
extern void EnableDragDrop(HWND, BOOL);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _INC_WINMISC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\imutil16\dllmain.c ===
#include <windows.h>
#include "..\debug.h"


BOOL WINAPI imutil_ThunkConnect16(LPSTR lpszDll16, LPSTR lpszDll32, WORD hInst, DWORD dwReason);


BOOL WINAPI DllEntryPoint(DWORD dwReason, HINSTANCE hInst, WORD wDS, WORD wHeapSize, DWORD dwReserved1, WORD wReserved2)
{
    static DWORD                dwRefCount = 0;

    if(dwReason)
    {
        DPF("DLL_PROCESS_ATTACH: 0x%8.8lX, 0x%4.4X, 0x%4.4X, 0x%4.4X, 0x%8.8lX, 0x%4.4X", hInst, dwReason, wDS, wHeapSize, dwReserved1, wReserved2);
        dwRefCount++;
    }
    else
    {
        DPF("DLL_PROCESS_DETACH: 0x%8.8lX, 0x%4.4X, 0x%4.4X, 0x%4.4X, 0x%8.8lX, 0x%4.4X", hInst, dwReason, wDS, wHeapSize, dwReserved1, wReserved2);
        dwRefCount--;

        if(!dwRefCount)
        {
            DPF("IMUTIL16 going away!");
        }
    }

    return imutil_ThunkConnect16("IMUTIL16.DLL", "IMUTIL32.DLL", hInst, dwReason);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\regsuite\RSTest\RSTest.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RSTest.h

Abstract:

    RSTest utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\imutil32\dllmain.c ===
#include <windows.h>
#include "..\debug.h"


BOOL WINAPI imutil_ThunkConnect32(LPSTR lpszDll16, LPSTR lpszDll32, DWORD hInst, DWORD dwReason);


BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, DWORD dwReserved)
{
    static DWORD                dwRefCount = 0;

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("DLL_PROCESS_ATTACH: 0x%8.8lX, 0x%8.8lX, 0x%8.8lX", hInst, dwReason, dwReserved);
            dwRefCount++;
            break;

        case DLL_THREAD_ATTACH:
            DPF("DLL_THREAD_ATTACH: 0x%8.8lX, 0x%8.8lX, 0x%8.8lX", hInst, dwReason, dwReserved);
            break;

        case DLL_PROCESS_DETACH:
            DPF("DLL_PROCESS_DETACH: 0x%8.8lX, 0x%8.8lX, 0x%8.8lX", hInst, dwReason, dwReserved);
            dwRefCount--;

            if(!dwRefCount)
            {
                DPF("IMUTIL32 going away!");
            }

            break;

        case DLL_THREAD_DETACH:
             DPF("DLL_THREAD_DETACH: 0x%8.8lX, 0x%8.8lX, 0x%8.8lX", hInst, dwReason, dwReserved);
             break;
    }
   
    return imutil_ThunkConnect32("IMUTIL16.DLL", "IMUTIL32.DLL", (DWORD)hInst, dwReason);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\rawread\win32\imutil32\imutil32.c ===
#define Not_VxD

#include <windows.h>
#include "..\debug.h"
#include "..\..\defs.h"
#include "..\..\diskutil.h"
#include "..\..\mem.h"

#define CARRY_FLAG_SET(_ptr) ((_ptr)->reg_Flags & 0x0001)

#define VWIN32_DIOC_DOS_IOCTL   1
#define VWIN32_DIOC_DOS_INT25   2
#define VWIN32_DIOC_DOS_INT26   3

typedef struct tagDIOC_REGISTERS
{
    DWORD   reg_EBX; 
    DWORD   reg_EDX; 
    DWORD   reg_ECX; 
    DWORD   reg_EAX; 
    DWORD   reg_EDI; 
    DWORD   reg_ESI; 
    DWORD   reg_Flags; 
} DIOC_REGISTERS, *LPDIOC_REGISTERS;

static WORD                 g_wDosVer = 0;
static HANDLE               g_hVWIN32 = NULL;


extern BOOL DISKUTILAPI InitDiskUtil16(void);
extern BOOL DISKUTILAPI FreeDiskUtil16(void);
extern BOOL DISKUTILAPI ResetDrive16(void);
extern BOOL DISKUTILAPI ReadSector16(BYTE, LPVOID, DWORD, WORD);
extern BOOL DISKUTILAPI WriteSector16(BYTE, LPVOID, DWORD, WORD);
extern WORD DISKUTILAPI GetDosVersion16(void);
extern BOOL DISKUTILAPI LockVolume16(BYTE);
extern BOOL DISKUTILAPI UnlockVolume16(BYTE);
extern BOOL DISKUTILAPI GetDriveMapping16(BYTE, LPBYTE, LPBYTE);
extern BOOL DISKUTILAPI GetDPB16(BYTE, LPDPB);


BOOL DeviceIoControlEx(HANDLE hDevice, DWORD dwIoControlCode, LPDIOC_REGISTERS lpReg, BOOL fCheckCarry)
{
    DWORD                   dwSize;
    BOOL                    fSuccess;

    fSuccess = DeviceIoControl(hDevice, dwIoControlCode, lpReg, sizeof(*lpReg), lpReg, sizeof(lpReg), &dwSize, NULL);

    if(!fSuccess)
    {
        return FALSE;
    }

    if(fCheckCarry && CARRY_FLAG_SET(lpReg))
    {
        SetLastError(0);
        return FALSE;
    }

    return TRUE;
}


void DISKUTILAPI InitRegisters(DIOC_REGISTERS *lpReg)
{
    MemSet(lpReg, 0, sizeof(DIOC_REGISTERS));
}


BOOL DISKUTILAPI InitDiskUtil32(void)
{
    if(!InitDiskUtil16())
    {
        return FALSE;
    }
    
    g_wDosVer = GetDosVersion32();
    g_hVWIN32 = CreateFile("\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

    DPF("VWIN32.VXD device handle 0x%8.8lX", g_hVWIN32);
    
    if(!g_hVWIN32)
    {
        DPF("Unable to open VWIN32.VXD");
        return FALSE;
    }

    return TRUE;
}


BOOL DISKUTILAPI FreeDiskUtil32(void)
{
    CloseHandle(g_hVWIN32);

    g_wDosVer = 0;
    g_hVWIN32 = NULL;

    FreeDiskUtil16();

    return TRUE;
}


BOOL DISKUTILAPI ResetDrive32(void)
{
    return ResetDrive16();
}


BOOL DISKUTILAPI SectorIo32(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount, BOOL fWrite)
{
    DIOC_REGISTERS          reg;
    BOOL                    fSuccess;
    BYTE                    bTry;

    bTry = 0;

    do
    {
        if(bTry)
        {
            DPF("Retry %u", bTry);
        }

        InitRegisters(&reg);

        reg.reg_EAX = bDrive;
        reg.reg_EBX = (DWORD)lpvBuffer;
        reg.reg_ECX = wCount;
        reg.reg_EDX = dwSector;

        fSuccess = DeviceIoControlEx(g_hVWIN32, fWrite ? VWIN32_DIOC_DOS_INT26 : VWIN32_DIOC_DOS_INT25, &reg, TRUE);

        if(!fSuccess)
        {
            DPF("DeviceIoControl() returned error %lu", GetLastError());
        }
    }
    while(!fSuccess && ++bTry <= ABSRETRIES);

    return fSuccess;
}


BOOL DISKUTILAPI ReadSector32(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount)
{
    BOOL                    fSuccess;
    
    if(IS_FAT32_KERNEL(g_wDosVer))
    {
        fSuccess = ReadSector16(bDrive, lpvBuffer, dwSector, wCount);
    }
    else
    {
        fSuccess = SectorIo32(bDrive, lpvBuffer, dwSector, wCount, FALSE);
    }

    return fSuccess;
}


BOOL DISKUTILAPI WriteSector32(BYTE bDrive, LPVOID lpvBuffer, DWORD dwSector, WORD wCount)
{
    BOOL                    fSuccess;
    
    if(IS_FAT32_KERNEL(g_wDosVer))
    {
        fSuccess = WriteSector16(bDrive, lpvBuffer, dwSector, wCount);
    }
    else
    {
        fSuccess = SectorIo32(bDrive, lpvBuffer, dwSector, wCount, TRUE);
    }

    return fSuccess;
}


WORD DISKUTILAPI GetDosVersion32(void)
{
    return GetDosVersion16();
}


BOOL DISKUTILAPI LockVolume32(BYTE bDrive)
{
    DIOC_REGISTERS          reg;
    
    DPF("Attempting to obtain level 0 lock on drive %u", bDrive);

    if(!IS_DOS7_KERNEL(g_wDosVer))
    {
        DPF("OS does not support locking");
        return TRUE;
    }
    
    InitRegisters(&reg);

    reg.reg_EAX = 0x440D;
    reg.reg_EBX = bDrive + 1;
    reg.reg_ECX = 0x84A;
    
    if(!DeviceIoControlEx(g_hVWIN32, VWIN32_DIOC_DOS_IOCTL, &reg, TRUE))
    {
        DPF("DeviceIoControl() returned error %lu", GetLastError());
        return FALSE;
    }

    return TRUE;
}


BOOL DISKUTILAPI UnlockVolume32(BYTE bDrive)
{
    DIOC_REGISTERS          reg;
    
    DPF("Releasing level 0 lock on drive %u", bDrive);

    if(!IS_DOS7_KERNEL(g_wDosVer))
    {
        DPF("OS does not support locking");
        return TRUE;
    }
    
    InitRegisters(&reg);
    
    reg.reg_EAX = 0x440D;
    reg.reg_EBX = bDrive + 1;
    reg.reg_ECX = 0x86A;
    
    if(!DeviceIoControlEx(g_hVWIN32, VWIN32_DIOC_DOS_IOCTL, &reg, TRUE))
    {
        DPF("DeviceIoControl() returned error %lu", GetLastError());
        return FALSE;
    }

    return TRUE;
}


BOOL DISKUTILAPI GetDriveMapping32(BYTE bDrive, LPBYTE lpbHostDrive, LPBYTE lpbSequence)
{
    return GetDriveMapping16(bDrive, lpbHostDrive, lpbSequence);
}


BOOL DISKUTILAPI GetDPB32(BYTE bDrive, LPDPB lpdpb)
{
    return GetDPB16(bDrive, lpdpb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\regsuite\RSTest\RSTest.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RSTest.cpp

Abstract:

    RSTest tests

--*/

#include "RSTest.h"
#include <regsuite.h>
#include <stdio.h>

#define TEST_PTR	0x40123068

VOID _stdcall /*(*RSINIT_FUNC)*/ParseFunc( LPCSTR szKey, LPCSTR szValue, LPVOID lpUserParam )
{
	if ( TEST_PTR != (INT)lpUserParam )
	{
		DbgPrint( "User param was %x, should be %x\n", lpUserParam, TEST_PTR );
	}
	DbgPrint( "Key = '%s' Value = '%s'\n", szKey, szValue );
	return;
}

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
RSTest_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for RSTest

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;
	DWORD				dwSuccess		= XLL_FAIL;
	UINT64				uiPass, uiFail;
	CHAR				szNotes[1024];

	uiPass = uiFail = 0;

	//MEDIAFILEDESC MediaFiles[6];

	//LoadMedia( MediaFiles );

    //
    // Return the Hresult
    //
	RSTESTPARAMS	TestParams;
	dwSuccess = RSBeginTest( 0, &TestParams, ParseFunc, (LPVOID)TEST_PTR );
	if ( XLL_PASS == dwSuccess )
	{
		uiPass++;
		sprintf( szNotes,
			"D3D_uiBackBufferWidth = %d\\n\
D3D_uiBackBufferHeight = %d\\n\
D3D_BackBufferFormat = %x\\n\
D3D_uiBackBufferCount = %d\\n\
D3D_MultiSampleType = %x\\n\
D3D_SwapEffect = %x\\n\
D3D_bEnableAutoDepthStencil = %d\\n\
D3D_AutoDepthStencilFormat = %x\\n\
D3D_dwFlags = %x\\n\
D3D_uiFullScreen_RefreshRateInHz = %d\\n\
D3D_uiFullScreen_PresentationInterval = %x\\n\
D3D_bSingleStepPusher = %d\\n\
D3D_bD3dParser = %d\\n\
D3D_bNullHardware = %d\\n\
DM_bDoWorkLocally = %d\\n\
DM_dwDoWorkFrequency = %d\\n\
DM_dwDebugLevel = %d\\n\
DM_dwRIPLevel = %d\\n\
DM_dwTestDebugLevel = %d\\n\
DM_dwVoiceCount = %d\\n\
DM_szDMHeap[MAX_PATH] = %s\\n\
DM_dwHeapSizeNorm = %d\\n\
DM_dwHeapSizePhys = %d\\n\
DS_bEnableHeadphones = %d\\n\
DS_szFXImage[MAX_PATH] = %s\\n\
DS_szHRTF[MAX_PATH] = %s\\n\
RS_szTestRun[MAX_PATH] = %s\\n\
RS_szHttpServer[MAX_PATH] = %s\\n\
RS_szConfigPage[MAX_PATH] = %s\\n\
RS_szStatePage[MAX_PATH] = %s\\n\
RS_szLogPage[MAX_PATH] = %s\\n\
RS_szPostFileName[MAX_PATH] = %s\\n\
RS_bLogResults = %d\\n\
RS_dwDecreaseMemory = %d\\n\
RS_dwDSUsedVoices2D = %d\\n\
RS_dwDSUsedVoices3D = %d\\n\
RS_dwMLErrorLevel = %d",
			TestParams.D3D_uiBackBufferWidth,
			TestParams.D3D_uiBackBufferHeight,
			TestParams.D3D_BackBufferFormat,
			TestParams.D3D_uiBackBufferCount,
			TestParams.D3D_MultiSampleType,
			TestParams.D3D_SwapEffect,
			TestParams.D3D_bEnableAutoDepthStencil,
			TestParams.D3D_AutoDepthStencilFormat,
			TestParams.D3D_dwFlags,						
			TestParams.D3D_uiFullScreen_RefreshRateInHz, 
			TestParams.D3D_uiFullScreen_PresentationInterval,
			TestParams.D3D_bSingleStepPusher,
			TestParams.D3D_bD3dParser,
			TestParams.D3D_bNullHardware,
			TestParams.DM_bDoWorkLocally,					
			TestParams.DM_dwDoWorkFrequency,				
			TestParams.DM_dwDebugLevel,					
			TestParams.DM_dwRIPLevel,						
			TestParams.DM_dwTestDebugLevel,				
			TestParams.DM_dwVoiceCount,					
			TestParams.DM_szDMHeap,				
			TestParams.DM_dwHeapSizeNorm,					
			TestParams.DM_dwHeapSizePhys,					
			TestParams.DS_bEnableHeadphones,				
			TestParams.DS_szFXImage,				
			TestParams.DS_szHRTF,
			TestParams.RS_szTestRun,				
			TestParams.RS_szHttpServer,			
			TestParams.RS_szConfigPage,			
			TestParams.RS_szStatePage,			
			TestParams.RS_szLogPage,				
			TestParams.RS_szPostFileName,		
			TestParams.RS_bLogResults,						
			TestParams.RS_dwDecreaseMemory,				
			TestParams.RS_dwDSUsedVoices2D,				
			TestParams.RS_dwDSUsedVoices3D,				
			TestParams.RS_dwMLErrorLevel 
			);
	}
	else
	{
		uiFail++;
		sprintf( szNotes, "Initialization failure" );
	}

	DbgPrint( szNotes );
	RSEndTest( uiPass, /*uiFail*/1, szNotes );
				
    return hr;
}

VOID 
WINAPI 
RSTest_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the RSTest tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test RSTest in the mannor it was meant to be called
    //

    if ( SHOULDRUNTEST( "RSTest", "Basic" ) )
    {
        SETLOG( LogHandle, "jeffsul", "Online", "RSTest", "Basic" );
        EXECUTE( RSTest_BasicTest() );
    }

}

VOID 
WINAPI 
RSTest_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    RSTest_StartTest( NULL );
    RSTest_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( RSTest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( RSTest )
    EXPORT_TABLE_ENTRY( "StartTest", RSTest_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", RSTest_EndTest )
END_EXPORT_TABLE( RSTest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\regsuite\regsuite.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	regsuite.cpp

Abstract:

	Implementation file for regression suite library (regsuite.lib)

Author:

	Jeff Sullivan (jeffsul) 11-Feb-2002

[Notes:]

	Known Issues

		RSBeginTest() returns XLL_FAIL at this point for error.  It should return XLL_ABORT or XLL_SKIP when those values are defined.

		If g_D3D_PresentFlag is not set to one of the following values, the variable will not be set correctly:
		D3DPRESENTFLAG_WIDESCREEN
		D3DPRESENTFLAG_INTERLACED            
		D3DPRESENTFLAG_PROGRESSIVE
		D3DPRESENTFLAG_FIELD

		If g_D3D_MultiSampleType is not set to one of the following values, the variable will not be set correctly:
		D3DMULTISAMPLE_NONE                                    
		D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR            
		D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX          
		D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR 
		D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR   
		D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR            
		D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR            
		D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN

Revision History:

	13-Feb-2002 jeffsul
		Initial Version

--*/

#include "regsuite.h"
#include <stdio.h>
#include <xdbg.h>
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

//------------------------------------------------------------------------------
//	Globals
//------------------------------------------------------------------------------
LPBYTE		g_pUsedMem		= NULL;
BOOL		g_bHVSLaunched	= FALSE;
RSINIT_FUNC	g_pfTestFunc	= NULL;
LPDIRECTSOUND8 g_pDSound	= NULL;
LPDIRECTSOUNDBUFFER     g_pDSBuffer[256] = {0};


//------------------------------------------------------------------------------
//	Pre-defines
//------------------------------------------------------------------------------
VOID
SetDefaults( 
	RSTESTPARAMS*		pTestParams
);

HRESULT 
ParseTestParams(
	CHAR*				lpszBuffer,
	RSTESTPARAMS*		pTestParams,
	LPVOID				lpUserParam
);

/*++

Routine Description:

	Parses launch data for test initialization.  
	If the test is launched from HVS Launcher, the data comes from the launch data.  Otherwise (test is stand alone), 
		the data comes from <XBENAME>.ini file in the same directory as the .xbe.
	The routine generates a .repro file (in the same directory as the .xbe) that will only be removed if RSEndTest() 
		is called with 0 passed as uiFail.
	The routine also allocates memory and voices as specified by launch parameters.  To override this, use the flags parameter.
	The routine will set medialoader debug level based on input.

Arguments:

	IN DWORD			dwFlags			-	0 for default behaviour, use RS_DONTALLOCXXX to avoid unwanted allocations
	OUT RSTESTPARAMS*	pTestParams		-	pointer to a struct to be filled in with launch data
	IN RSINIT_FUNC		LocalTestInit	-	pointer to function to parse remaining test-specific init values
	IN LPVOID			lpUserParam		-	pointer to a user defined variable that is passed to LocalTestInit when called

Return Value:

	XLL_PASS	-	if success
	XLL_FAIL	-	never returned
	XLL_INFO	-	?
	XLL_ABORT	-	if function fails
	XLL_SKIP	-	if current configuration is not supported

--*/
DWORD _stdcall
RSBeginTest( 
	IN DWORD			dwFlags,
	OUT RSTESTPARAMS*	pTestParams,
	IN RSINIT_FUNC		LocalTestInit,
	IN LPVOID			lpUserParam
)
{
	DWORD		dwStatus		= XLL_PASS;//XLL_SKIP;
	HANDLE		hFile			= INVALID_HANDLE_VALUE;
	CHAR*		pIniBuffer		= NULL;

	if ( NULL == pTestParams )
	{
		DbgPrint( "Null passed for pTestParams\n" );
		goto error;
	}

	g_pfTestFunc = LocalTestInit;

	//------------------------------------------------------------------------------
	//	Determine how the test was launched
	//------------------------------------------------------------------------------

	DWORD		dwSuccess;
	DWORD		dwLaunchType;
	LAUNCH_DATA	LaunchData;
	ToTestData* pToTestData;

	dwSuccess = XGetLaunchInfo( &dwLaunchType, &LaunchData );
	if ( ERROR_SUCCESS == dwSuccess )
	{
		if ( LDT_TITLE == dwLaunchType )
		{
			pToTestData = (ToTestData*)(LaunchData.Data);
			if ( HVSLAUNCHERID == pToTestData->titleID )
			{
				g_bHVSLaunched = TRUE;
			}
		}
	}

	//------------------------------------------------------------------------------
	//	Read in initialization values
	//------------------------------------------------------------------------------
	if ( TRUE == g_bHVSLaunched )
	{
		// get info from launch data
		ParseTestParams( pToTestData->configSettings, pTestParams, lpUserParam );
	}
	else
	{
		// get info from ini file
		DWORD	dwFileSize		= 0;
		DWORD	dwNumBytesRead	= 0;
		BOOL	bSuccess		= FALSE;

		CHAR	szFileName[MAX_PATH];
		CHAR	szPath[MAX_PATH] = "D:\\";
		
		wcstombs( szFileName, XeImageHeader()->Certificate->TitleName, wcslen( XeImageHeader()->Certificate->TitleName ) + 1 );
		strcat( szPath, szFileName );
		strcat( szPath, ".ini" );

		hFile = CreateFile( szPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
		if ( INVALID_HANDLE_VALUE == hFile )
		{
			DbgPrint( "Unable to open .ini file '%s'\n", szPath );
			goto error;
		}

		dwFileSize = GetFileSize( hFile, NULL );
		if ( -1 == dwFileSize )
		{
			DbgPrint( "Unable to get .ini file size for '%s'\n", szPath );
			goto error;
		}
		
		pIniBuffer = new CHAR [ dwFileSize + 1 ];
		if ( NULL == pIniBuffer )
		{
			DbgPrint( "Ran out of memory creating ini buffer\n" );
			goto error;
		}
		
		bSuccess = ReadFile( hFile, pIniBuffer, dwFileSize, &dwNumBytesRead, NULL );
		if ( FALSE == bSuccess || dwNumBytesRead != dwFileSize )
		{
			DbgPrint( "Unable to read file '%s' (error %x)\n", szPath, GetLastError() );
			goto error;
		}
		
		pIniBuffer[ dwFileSize ] = '\0';
		CloseHandle( hFile );

		ParseTestParams( pIniBuffer, pTestParams, lpUserParam );

		SAFEDELETEARRAY( pIniBuffer );
	}

	//------------------------------------------------------------------------------
	//	Do work
	//------------------------------------------------------------------------------
	// set medialoader error level
	if ( !(RS_DONTSETMLDEBUG & dwFlags) )
	{
		//MLSetErrorLevel( pTestParams->RS_dwMLErrorLevel );
	}

	// allocate a chunk of memory
	if ( !(RS_DONTALLOCMEMORY & dwFlags) && 0 < pTestParams->RS_dwDecreaseMemory )
	{
		g_pUsedMem = new BYTE [ pTestParams->RS_dwDecreaseMemory ];
		if ( NULL == g_pUsedMem )
		{
			DbgPrint( "Ran out of memory creating pre-allocation\n" );
			goto error;
		}
	}

	// allocate voices
	if ( !(RS_DONTALLOCVOICES & dwFlags) && (0 != pTestParams->RS_dwDSUsedVoices2D || 0 != pTestParams->RS_dwDSUsedVoices3D) )
	{
		HRESULT                 hr;
		DSBUFFERDESC            dsbd;
		WAVEFORMATEX            wfx;
		
		// Create DSound Object
		hr = DirectSoundCreate(NULL, &g_pDSound, NULL);
		if( FAILED(hr) )
		{
			DbgPrint( "Failed to create DSound (error %x)\n", hr );
            goto error;
		}
		
		// Check free 2D/3D voices
		DSCAPS deviceCaps;
		g_pDSound->GetCaps(&deviceCaps);
		
		if ( pTestParams->RS_dwDSUsedVoices2D > deviceCaps.dwFree2DBuffers || pTestParams->RS_dwDSUsedVoices2D > deviceCaps.dwFree3DBuffers )
		{
			DbgPrint( "Too many voices: 2D = %d, 3D = %d\n", pTestParams->RS_dwDSUsedVoices2D, pTestParams->RS_dwDSUsedVoices3D );
			goto error;
		}

		// verify dsp
		//ASSERT(XAudioDownloadEffectsImage("dsstdfx", &effectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc) == S_OK);

		// set 3D algorithm initialization function
		if ( 0 == strcmp( pTestParams->DS_szHRTF, "FULL" ) ) DirectSoundUseFullHRTF();
		else if ( 0 == strcmp( pTestParams->DS_szHRTF, "LIGHT" ) ) DirectSoundUseLightHRTF();
		else if ( 0 == strcmp( pTestParams->DS_szHRTF, "PAN3D" ) ) DirectSoundUsePan3D();
		else { DbgPrint( "Un-supported DS 3D algorithm '%s'\n", pTestParams->DS_szHRTF ); goto error; }
		
		// Data structures for buffer
		memset(&wfx, 0, sizeof(WAVEFORMATEX));
		wfx.wFormatTag          = WAVE_FORMAT_PCM;
		wfx.nChannels           = 1;
		wfx.nSamplesPerSec      = 11500;
		wfx.nBlockAlign         = 1;
		wfx.nAvgBytesPerSec     = wfx.nSamplesPerSec * wfx.nBlockAlign;
		wfx.wBitsPerSample      = 8;
		
		ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
		dsbd.dwSize             = sizeof(DSBUFFERDESC);
		dsbd.dwFlags            = 0;
		dsbd.dwBufferBytes      = 4;
		dsbd.lpwfxFormat  = (LPWAVEFORMATEX)&wfx;
		
		// Create the DSound 2D buffers
		for ( UINT i=0; i < pTestParams->RS_dwDSUsedVoices2D; i++ )
		{
			hr = g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer[i], NULL);
			if( FAILED(hr) )
			{
				DbgPrint( "Can not create DirectSoundBuffer (error %x)\n", hr );
				goto error;
			}
		}
		// create the DSound 3D buffers
		dsbd.dwFlags            = DSBCAPS_CTRL3D;
		for ( ; i < pTestParams->RS_dwDSUsedVoices2D + pTestParams->RS_dwDSUsedVoices3D; i++ )
		{
			hr = g_pDSound->CreateSoundBuffer(&dsbd, &g_pDSBuffer[i], NULL);
			if( FAILED(hr) )
			{
				DbgPrint( "Can not create DirectSoundBuffer (error %x)\n", hr );
				goto error;
			}
		}
	}

	return dwStatus;

error:
	SAFEDELETEARRAY( g_pUsedMem );
	SAFEDELETEARRAY( pIniBuffer );
	for ( UINT i=0; i < 256; i++ )
	{
		RELEASE( g_pDSBuffer[i] );
	}
	RELEASE( g_pDSound );
	CloseHandle( hFile );
	dwStatus = XLL_FAIL;//XLL_ABORT;
	return dwStatus;
}


/*++

Routine Description:

	Called at the end of a test app to give control back to the HVS launcher or reboot the box.
	If uiFail is 0, this routine deletes the .repro file created by RSInitializeTest().
	Also cleans up any memory/voices allocated by RSBeginTest().

Arguments:

	UINT64		uiPass		-	the number of tests passed
	UINT64		uiFail		-	the number of tests failed
	LPCSTR		lpszNotes	-	optional string of notes to pass back to the launcher

Return Value:

	None

--*/
VOID _stdcall
RSEndTest( 
	IN UINT64			uiPass,
	IN UINT64			uiFail,
	IN LPCSTR			lpszNotes
)
{
	LAUNCH_DATA		LaunchData;
	ToLauncherData* pLauncherData = (ToLauncherData*)&LaunchData;
	pLauncherData->titleID = XeImageHeader()->Certificate->TitleID;
	pLauncherData->numPass = uiPass;
	pLauncherData->numFail = uiFail;
	strcpy( pLauncherData->notes, lpszNotes );

	//------------------------------------------------------------------------------
	//	Clean up
	//------------------------------------------------------------------------------

	// free used memory
	if ( NULL != g_pUsedMem )
	{
		SAFEDELETEARRAY( g_pUsedMem );
	}

	//	delete .repro file
	if ( 0 == uiFail )
	{
		CHAR	szFileName[MAX_PATH];
		CHAR	szPath[MAX_PATH] = "D:\\";
		
		if ( TRUE == g_bHVSLaunched )
		{
			strcat( szPath, "tests\\" );
		}
		
		wcstombs( szFileName, XeImageHeader()->Certificate->TitleName, wcslen( XeImageHeader()->Certificate->TitleName ) + 1 );
		strcat( szPath, szFileName );
		strcat( szPath, ".repro" );
		
		HANDLE hFile = CreateFile( szPath, DELETE, FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, NULL );
		CloseHandle( hFile );
	}

	// free voices
	for ( UINT i=0; i < 256; i++ )
	{
		RELEASE( g_pDSBuffer[i] );
	}
	RELEASE( g_pDSound );

	//------------------------------------------------------------------------------
	//	Return to Launcher or reboot system
	//------------------------------------------------------------------------------
	if ( TRUE == g_bHVSLaunched)
    {
        LaunchImage( "D:\\default.xbe", &LaunchData );
    }
    else
	{
        XLaunchNewImage( NULL, NULL );
    }
}


HRESULT 
ParseTestParams(
	CHAR*				lpszBuffer,
	RSTESTPARAMS*		pTestParams,
	LPVOID				lpUserParam
)
{
	HRESULT hr = S_OK;

	if ( NULL == lpszBuffer || NULL == pTestParams )
	{
		DbgPrint( "Bad argument to ParseTestParams\n" );
		goto error;
	}

	SetDefaults( pTestParams );

	//------------------------------------------------------------------------------
	//	Output buffer to .repro file
	//------------------------------------------------------------------------------
	CHAR	szFileName[MAX_PATH];
	CHAR	szPath[MAX_PATH] = "D:\\";

	if ( TRUE == g_bHVSLaunched )
	{
		strcat( szPath, "tests\\" );
	}

	wcstombs( szFileName, XeImageHeader()->Certificate->TitleName, wcslen( XeImageHeader()->Certificate->TitleName ) + 1 );
	strcat( szPath, szFileName );
	strcat( szPath, ".repro" );

	HANDLE hFile = CreateFile( szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == hFile )
	{
		DbgPrint( "Unable to create .repro file '%s' (error %x)\n", szPath, GetLastError() );
		goto error;
	}

	DWORD	dwSize, dwNumBytesWritten = 0;
	BOOL	bSuccess = FALSE;
	dwSize = strlen( lpszBuffer );
	bSuccess = WriteFile( hFile, lpszBuffer, dwSize, &dwNumBytesWritten, NULL );
	CloseHandle( hFile );
	if ( FALSE == bSuccess || dwSize != dwNumBytesWritten )
	{
		DbgPrint( "Unable to write .repro file '%s' (error %x)\n", szPath, GetLastError() );
		goto error;
	}

	//------------------------------------------------------------------------------
	//	Parse variables into struct and pass off test specific ones
	//------------------------------------------------------------------------------

	CHAR	szValue[256];
    CHAR	szVariable[64];
    CHAR*	lpszEnd;
	CHAR*	c;

    do
    {
        lpszEnd = strchr( lpszBuffer, '\n' );
        if ( NULL != lpszEnd )
		{
			*lpszEnd = '\0';
		}
		
        c = strchr( lpszBuffer, ';' );
        if ( NULL != c ) 
		{
			*c = '\0';
		}

        c = strchr( lpszBuffer, '[' );
        if ( NULL != c ) 
		{
			*c = '\0';
		}

        RightTrim( lpszBuffer );

		DWORD	dwFlag = 0;
		
        if( sscanf( lpszBuffer, "%63[^=]= %255[^\0]", szVariable, szValue ) == 2 )
		{
            // global settings
			//d3d
            if( strstr( szVariable, "g_D3D_BackBufferWidth") != NULL)							pTestParams->D3D_uiBackBufferWidth = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_BackBufferHeight") != NULL)					pTestParams->D3D_uiBackBufferHeight = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_BackBufferFormat") != NULL)						GetConst( szValue, 256, (PDWORD)&(pTestParams->D3D_BackBufferFormat) );
			else if( strstr( szVariable, "g_D3D_BackBufferCount") != NULL)					pTestParams->D3D_uiBackBufferCount = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_SwapEffect") != NULL)							GetConst( szValue, 256, (PDWORD)&(pTestParams->D3D_BackBufferFormat) );
			else if( strstr( szVariable, "g_D3D_EnableAutoDepthStencil") != NULL)				pTestParams->D3D_bEnableAutoDepthStencil = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_AutoDepthStencilFormat") != NULL)				GetConst( szValue, 256, (PDWORD)&(pTestParams->D3D_AutoDepthStencilFormat) );
			else if( strstr( szVariable, "g_D3D_RefreshRateInHz") != NULL)			pTestParams->D3D_uiFullScreen_RefreshRateInHz = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_PresentationInterval") != NULL)	GetConst( szValue, 256, (PDWORD)&(pTestParams->D3D_bSingleStepPusher) );
			else if( strstr( szVariable, "g_D3D_SingleStepPusher") != NULL)					pTestParams->D3D_bSingleStepPusher = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_Parser") != NULL)							pTestParams->D3D_bD3dParser = GetNumber(szValue);
			else if( strstr( szVariable, "g_D3D_NullHardware") != NULL)						pTestParams->D3D_bNullHardware = GetNumber(szValue);
			//dwflags
			else if( strstr( szVariable, "g_D3D_PresentFlag") != NULL){							GetConst( szValue, 256, &dwFlag ); pTestParams->D3D_dwFlags |= dwFlag; }
			else if( strstr( szVariable, "g_D3D_WidescreenMode") != NULL){						GetConst( szValue, 256, &dwFlag ); pTestParams->D3D_dwFlags |= dwFlag; }
			else if( strstr( szVariable, "g_D3D_10x11PixelAspectRatio") != NULL){				GetConst( szValue, 256, &dwFlag ); pTestParams->D3D_dwFlags |= dwFlag; }
			//multisampletype         
			else if( strstr( szVariable, "g_D3D_MultiSampleType") != NULL){						GetConst( szValue, 256, &dwFlag ); pTestParams->D3D_MultiSampleType |= dwFlag; }
			else if( strstr( szVariable, "g_D3D_PrefilterBufferFormat") != NULL){				GetConst( szValue, 256, &dwFlag ); pTestParams->D3D_MultiSampleType |= dwFlag; }

			//dmusic
			else if( strstr( szVariable, "g_DM_bDoWorkLocally") != NULL)		pTestParams->DM_bDoWorkLocally = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwDoWorkFrequency") != NULL)		pTestParams->DM_dwDoWorkFrequency = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwDebugLevel") != NULL)			pTestParams->DM_dwDebugLevel = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwRIPLevel") != NULL)			pTestParams->DM_dwRIPLevel = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwTestDebugLevel") != NULL)		pTestParams->DM_dwTestDebugLevel = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwVoiceCount") != NULL)			pTestParams->DM_dwVoiceCount = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_szDMHeap") != NULL)				strcpy( pTestParams->DM_szDMHeap, szValue );
			else if( strstr( szVariable, "g_DM_dwHeapSizeNorm") != NULL)		pTestParams->DM_dwHeapSizeNorm = GetNumber(szValue);
			else if( strstr( szVariable, "g_DM_dwHeapSizePhys") != NULL)		pTestParams->DM_dwHeapSizePhys = GetNumber(szValue);

			//dsound
			else if( strstr( szVariable, "g_DS_bEnableHeadphones") != NULL)		pTestParams->DS_bEnableHeadphones = GetNumber(szValue);
			else if( strstr( szVariable, "g_DS_szFXImage") != NULL)				strcpy( pTestParams->DS_szFXImage, szValue );
			else if( strstr( szVariable, "g_DS_szHRTF") != NULL)				strcpy( pTestParams->DS_szHRTF, szValue );

			//other
			else if( strstr( szVariable, "g_RS_szTestRun") != NULL)				strcpy( pTestParams->RS_szTestRun, szValue );
			else if( strstr( szVariable, "g_RS_szHttpServer") != NULL)			strcpy( pTestParams->RS_szHttpServer, szValue );
			else if( strstr( szVariable, "g_RS_szConfigPage") != NULL)			strcpy( pTestParams->RS_szConfigPage, szValue );
			else if( strstr( szVariable, "g_RS_szStatePage") != NULL)			strcpy( pTestParams->RS_szStatePage, szValue );
			else if( strstr( szVariable, "g_RS_szLogPage") != NULL)				strcpy( pTestParams->RS_szLogPage, szValue );
			else if( strstr( szVariable, "g_RS_szPostFileName") != NULL)		strcpy( pTestParams->RS_szPostFileName, szValue );
			else if( strstr( szVariable, "g_RS_bLogResults") != NULL)			pTestParams->RS_bLogResults = GetNumber(szValue);
			else if( strstr( szVariable, "g_RS_dwDecreaseMemory") != NULL)		pTestParams->RS_dwDecreaseMemory = GetNumber(szValue);
			else if( strstr( szVariable, "g_RS_dwDSUsedVoices2D") != NULL)		pTestParams->RS_dwDSUsedVoices2D = GetNumber(szValue);
			else if( strstr( szVariable, "g_RS_dwDSUsedVoices3D") != NULL)		pTestParams->RS_dwDSUsedVoices3D = GetNumber(szValue);
			else if( strstr( szVariable, "g_RS_dwMLErrorLevel") != NULL)		pTestParams->RS_dwMLErrorLevel = GetNumber(szValue);
			//core config settings
			//else if( strstr( szVariable, "g_RS_szResultsServer") != NULL)		strcpy( pTestParams->RS_szResultsServer, szValue );
			//else if( strstr( szVariable, "g_RS_dwStopAfter") != NULL)			pTestParams->RS_dwStopAfter = GetNumber(szValue);
			//else if( strstr( szVariable, "g_RS_szSaveName") != NULL)			strcpy( pTestParams->RS_szSaveName, szValue );
			
            // test specific settings
            else if ( NULL != g_pfTestFunc) (g_pfTestFunc)( szVariable, szValue, lpUserParam );
		}
		
        if ( lpszEnd ) 
		{ 
			lpszBuffer = lpszEnd+1;
		}

	} while( lpszEnd );

	return hr;

error:
	return E_FAIL;
}


VOID
SetDefaults( 
	RSTESTPARAMS*		pTestParams
)
{
	if ( NULL == pTestParams )
	{
		DbgPrint( "Bad argument to SetDefaults\n" );
		return;
	}

	ZeroMemory( pTestParams, sizeof( RSTESTPARAMS ) );
	/*pTestParams->D3D_uiBackBufferWidth	= 640;
	pTestParams->D3D_uiBackBufferHeight = 480;
	pTestParams->D3D_BackBufferFormat	= D3DFMT_LIN_A8R8G8B8;
	pTestParams->D3D_uiBackBufferCount	= 1;
	
	pTestParams->D3D_SwapEffect			= D3DSWAPEFFECT_DISCARD;
	
	pTestParams->D3D_AutoDepthStencilFormat = D3DFMT_LIN_D24S8;
						
	pTestParams->D3D_uiFullScreen_RefreshRateInHz = 60; 
	pTestParams->D3D_uiFullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
			
	pTestParams->DM_dwDoWorkFrequency	= 60;				
	pTestParams->DM_dwDebugLevel		= 1;					
							
	pTestParams->DM_dwTestDebugLevel	= 2;				
	pTestParams->DM_dwVoiceCount		= 180;					
			
	pTestParams->DM_dwHeapSizeNorm		= 16777216;					
	pTestParams->DM_dwHeapSizePhys		= 16777216;	
	
	pTestParams->RS_dwMLErrorLevel		= 3;*/
	
	//pTestParams->D3D_MultiSampleType	= D3DMULTISAMPLE_NONE;
	//pTestParams->D3D_bEnableAutoDepthStencil;
	//pTestParams->D3D_dwFlags			= D3DPRESENTFLAG_INTERLACED;	
	//pTestParams->D3D_bSingleStepPusher;
	//pTestParams->D3D_bD3dParser;
	//pTestParams->D3D_bNullHardware;
	//pTestParams->DM_bDoWorkLocally;
	//pTestParams->DM_dwRIPLevel;
	//pTestParams->DM_szDMHeap[MAX_PATH];
	//pTestParams->DS_bEnableHeadphones;				
	//pTestParams->DS_szFXImage[MAX_PATH];				
	//pTestParams->DS_szHRTF[MAX_PATH];				
	//pTestParams->RS_szTestRun[MAX_PATH];				
	//pTestParams->RS_szHttpServer[MAX_PATH];			
	//pTestParams->RS_szConfigPage[MAX_PATH];			
	//pTestParams->RS_szStatePage[MAX_PATH];			
	//pTestParams->RS_szLogPage[MAX_PATH];				
	//pTestParams->RS_szPostFileName[MAX_PATH];		
	//pTestParams->RS_bLogResults;						
	//pTestParams->RS_dwDecreaseMemory;				
	//pTestParams->RS_dwDSUsedVoices2D;				
	//pTestParams->RS_dwDSUsedVoices3D;				
}			


BOOL _stdcall
GetConst(
	IN CONST CHAR*	szStr, 
	IN INT		cchStr, 
	OUT PDWORD	pval
)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        INT Val;
        CONST CHAR *szStr;
    } rgszConsts[] =
    {
        // Pixel Shaders
        XTAG(PS_TEXTUREMODES_NONE), XTAG(PS_TEXTUREMODES_PROJECT2D), XTAG(PS_TEXTUREMODES_PROJECT3D),
        XTAG(PS_TEXTUREMODES_CUBEMAP), XTAG(PS_TEXTUREMODES_PASSTHRU), XTAG(PS_TEXTUREMODES_CLIPPLANE),
        XTAG(PS_TEXTUREMODES_BUMPENVMAP), XTAG(PS_TEXTUREMODES_BUMPENVMAP_LUM), XTAG(PS_TEXTUREMODES_BRDF),
        XTAG(PS_TEXTUREMODES_DOT_ST), XTAG(PS_TEXTUREMODES_DOT_ZW), XTAG(PS_TEXTUREMODES_DOT_RFLCT_DIFF),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC), XTAG(PS_TEXTUREMODES_DOT_STR_3D), XTAG(PS_TEXTUREMODES_DOT_STR_CUBE),
        XTAG(PS_TEXTUREMODES_DPNDNT_AR), XTAG(PS_TEXTUREMODES_DPNDNT_GB), XTAG(PS_TEXTUREMODES_DOTPRODUCT),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST), XTAG(PS_COMPAREMODE_S_LT), XTAG(PS_COMPAREMODE_S_GE),
        XTAG(PS_COMPAREMODE_T_LT), XTAG(PS_COMPAREMODE_T_GE), XTAG(PS_COMPAREMODE_R_LT),
        XTAG(PS_COMPAREMODE_R_GE), XTAG(PS_COMPAREMODE_Q_LT), XTAG(PS_COMPAREMODE_Q_GE),
        XTAG(PS_COMBINERCOUNT_MUX_LSB), XTAG(PS_COMBINERCOUNT_MUX_MSB), XTAG(PS_COMBINERCOUNT_SAME_C0),
        XTAG(PS_COMBINERCOUNT_UNIQUE_C0), XTAG(PS_COMBINERCOUNT_SAME_C1), XTAG(PS_COMBINERCOUNT_UNIQUE_C1),
        XTAG(PS_INPUTMAPPING_UNSIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_UNSIGNED_INVERT), XTAG(PS_INPUTMAPPING_EXPAND_NORMAL),
        XTAG(PS_INPUTMAPPING_EXPAND_NEGATE), XTAG(PS_INPUTMAPPING_HALFBIAS_NORMAL), XTAG(PS_INPUTMAPPING_HALFBIAS_NEGATE),
        XTAG(PS_INPUTMAPPING_SIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_SIGNED_NEGATE), XTAG(PS_REGISTER_ZERO),
        XTAG(PS_REGISTER_DISCARD), XTAG(PS_REGISTER_C0), XTAG(PS_REGISTER_C1),
        XTAG(PS_REGISTER_FOG), XTAG(PS_REGISTER_V0), XTAG(PS_REGISTER_V1),
        XTAG(PS_REGISTER_T0), XTAG(PS_REGISTER_T1), XTAG(PS_REGISTER_T2),
        XTAG(PS_REGISTER_T3), XTAG(PS_REGISTER_R0), XTAG(PS_REGISTER_R1),
        XTAG(PS_REGISTER_V1R0_SUM), XTAG(PS_REGISTER_EF_PROD), XTAG(PS_REGISTER_ONE),
        XTAG(PS_REGISTER_NEGATIVE_ONE), XTAG(PS_REGISTER_ONE_HALF), XTAG(PS_REGISTER_NEGATIVE_ONE_HALF),
        XTAG(PS_CHANNEL_RGB), XTAG(PS_CHANNEL_BLUE), XTAG(PS_CHANNEL_ALPHA),
        XTAG(PS_FINALCOMBINERSETTING_CLAMP_SUM), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_V1), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_R0),
        XTAG(PS_COMBINEROUTPUT_IDENTITY), XTAG(PS_COMBINEROUTPUT_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1),
        XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_2), XTAG(PS_COMBINEROUTPUT_SHIFTRIGHT_1),
        XTAG(PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_AB_MULTIPLY),
        XTAG(PS_COMBINEROUTPUT_AB_DOT_PRODUCT), XTAG(PS_COMBINEROUTPUT_CD_MULTIPLY), XTAG(PS_COMBINEROUTPUT_CD_DOT_PRODUCT),
        XTAG(PS_COMBINEROUTPUT_AB_CD_SUM), XTAG(PS_COMBINEROUTPUT_AB_CD_MUX),
        XTAG(PS_DOTMAPPING_ZERO_TO_ONE), XTAG(PS_DOTMAPPING_MINUS1_TO_1_D3D), XTAG(PS_DOTMAPPING_MINUS1_TO_1_GL),
        XTAG(PS_DOTMAPPING_MINUS1_TO_1), XTAG(PS_DOTMAPPING_HILO_1), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_D3D), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_GL),
        XTAG(PS_DOTMAPPING_HILO_HEMISPHERE),

        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

		// D3DSWAPEFFECT
		XTAG(D3DSWAPEFFECT_DISCARD), XTAG(D3DSWAPEFFECT_FLIP), XTAG( D3DSWAPEFFECT_COPY),

		// D3DPRESENTFLAGs
		XTAG(D3DPRESENTFLAG_LOCKABLE_BACKBUFFER), XTAG(D3DPRESENTFLAG_WIDESCREEN),
		XTAG(D3DPRESENTFLAG_INTERLACED), XTAG(D3DPRESENTFLAG_PROGRESSIVE),
		XTAG(D3DPRESENTFLAG_FIELD), XTAG(D3DPRESENTFLAG_10X11PIXELASPECTRATIO),

		// D3DMULTISAMPLE_TYPEs
        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        /*XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),*/

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

		// STENCILOPs
		XTAG(D3DSTENCILOP_KEEP),
		XTAG(D3DSTENCILOP_ZERO),
		XTAG(D3DSTENCILOP_REPLACE),
		XTAG(D3DSTENCILOP_INCRSAT),
		XTAG(D3DSTENCILOP_DECRSAT),
		XTAG(D3DSTENCILOP_INVERT),
		XTAG(D3DSTENCILOP_INCR),
		XTAG(D3DSTENCILOP_DECR),

		// D3DZBUFFERTYPE
		XTAG(D3DZB_TRUE), XTAG(D3DZB_USEW), XTAG(D3DZB_FALSE),

        XTAG(D3DTEXF_NONE), XTAG(D3DTEXF_POINT), XTAG(D3DTEXF_LINEAR), XTAG(D3DTEXF_ANISOTROPIC),
        XTAG(D3DTEXF_QUINCUNX), XTAG(D3DTEXF_GAUSSIANCUBIC),

//        XTAG(TEX_None), XTAG(TEX_2d), XTAG(TEX_Cubemap), XTAG(TEX_Volume),

 //       XTAG(TIME_Present), XTAG(TIME_Render),

        // swaths
        XTAG(D3DSWATH_8), XTAG(D3DSWATH_16), XTAG(D3DSWATH_32),
        XTAG(D3DSWATH_64), XTAG(D3DSWATH_128), XTAG(D3DSWATH_OFF),

        XTAG(D3DCOLORWRITEENABLE_RED), XTAG(D3DCOLORWRITEENABLE_GREEN), XTAG(D3DCOLORWRITEENABLE_BLUE),
        XTAG(D3DCOLORWRITEENABLE_ALPHA), XTAG(D3DCOLORWRITEENABLE_ALL),

		// File Creation Flags
		XTAG(CREATE_NEW), XTAG(CREATE_ALWAYS), XTAG(OPEN_EXISTING), XTAG(OPEN_ALWAYS), XTAG(TRUNCATE_EXISTING),

		// File Copy Flags
//		XTAG(COPY_IF_NOT_EXIST), XTAG(COPY_IF_NEWER), XTAG(COPY_ALWAYS),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = (DWORD)rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\sampledll\sampledll.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SampleDLL.c

Abstract:

    Sample test DLL for XBox test harness. This sample demostrates how to write
    test DLL for XBox test harness. The DLL exports two of the mandatory APIs,
    StartTest and EndTest. TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest for this sample DLL.

    Please see "x-box test harness.doc" for more information.

Author:

    Sakphong Chanbai (schanbai) 21-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>


//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The 
// default is only one thread.
// 

LONG SampleDllThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE SampleDllHeapHandle;


BOOL
WINAPI
SampleDllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {

        SampleDllHeapHandle = HeapCreate( 0, 0, 0 );

        if ( !SampleDllHeapHandle ) {
            OutputDebugString( TEXT("SAMPLEDLL: Unable to create heap\n") );
        }

    } else if ( fdwReason == DLL_PROCESS_DETACH ) {

        if ( SampleDllHeapHandle ) {
            HeapDestroy( SampleDllHeapHandle );
        }
    }

    return TRUE;
}


VOID
RunTest1(
    IN HANDLE LogHandle
    )
{
    HANDLE FileHandle;
    CHAR FileName[MAX_PATH];
    xSetComponent( LogHandle, "Harness", "SampleDll" );
    xSetFunctionName( LogHandle, "Test1" );
    xStartVariation( LogHandle, "CreateFile" );

    //
    // First test: Create new file if it doesn't exist, overwrite it 
    // if it is there. This test must be success
    //
    lstrcpyA( FileName, "Z:\\TestFile.XBox" );
    FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,   // No SECURITY_ATTRIBUTES
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL    // No template
                    );

    xLog(
        LogHandle,
        FileHandle == INVALID_HANDLE_VALUE ? XLL_FAIL : XLL_PASS,
        "CreateFile with CREATE_ALWAYS, no template (LastError=%d)",
        GetLastError()
        );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }


    //
    // Second test: Always create new file. This test must be failed
    // because the file is already there
    //
    FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,   // No SECURITY_ATTRIBUTES
                    CREATE_NEW,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL    // No template
                    );

    xLog(
        LogHandle,
        FileHandle == INVALID_HANDLE_VALUE ? XLL_PASS: XLL_FAIL,
        "CreateFile with CREATE_NEW, no template (LastError=%d)",
        GetLastError()
        );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    //
    // Third test: Create new file with hTemplateFile != NULL
    // This test must be failed with ERROR_INVALID_PARAMETER since
    // we don't support hTemplateFile
    //
    FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,   // No SECURITY_ATTRIBUTES
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE
                    );

    xLog(
        LogHandle,
        FileHandle == INVALID_HANDLE_VALUE ? XLL_PASS: XLL_FAIL,
        "CreateFile with hTemplateFile, no template (LastError=%d)",
        GetLastError()
        );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    OutputDebugString( TEXT("SAMPLEDLL: Test 1 is terminating\n") );
    xEndVariation( LogHandle );
}


VOID
RunTest2(
    IN HANDLE LogHandle
    )
{
    LPVOID pv;

    xSetComponent( LogHandle, "Harness", "SampleDll" );
    xSetFunctionName( LogHandle, "Test2" );
    xStartVariation( LogHandle, "Test2" );
    OutputDebugString( TEXT("SAMPLEDLL: Test 2 is running\n") );

    pv = HeapAlloc( SampleDllHeapHandle, HEAP_ZERO_MEMORY, 4096 );

    if ( !pv ) {
        OutputDebugString( TEXT("SAMPLEDLL: Unable to allocate heap\n") );
        xLog( LogHandle, XLL_FAIL, "HeapAlloc failed" );
    } else {
        xLog( LogHandle, XLL_PASS, "HeapAlloc passed" );
        HeapFree( SampleDllHeapHandle, 0, pv );
    }

    OutputDebugString( TEXT("SAMPLEDLL: Test 2 is terminating\n") );
    xEndVariation( LogHandle );
}


VOID
RunTest3(
    IN HANDLE LogHandle,
    ULONG ID
    )
{
    char Buffer[80];

    sprintf( Buffer, "Test%d", ID );
    xSetComponent( LogHandle, "Harness", "SampleDll" );
    xSetFunctionName( LogHandle, "Test3" );
    xStartVariation( LogHandle, Buffer );
    sprintf( Buffer, "SAMPLEDLL: Test %d is running\n", ID );
    OutputDebugStringA( Buffer );
    Sleep(250);
    xEndVariation( LogHandle );
}


VOID
WINAPI
SampleStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    LONG ID;

    OutputDebugString( TEXT("SAMPLEDLL: StartTest is called\n") );

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample.dll]. Everytime
    // the harness calls StartTest, SampleDllThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    // 

    ID = InterlockedIncrement( &SampleDllThreadID );

    switch ( SampleDllThreadID ) {

    case 1:
        RunTest1( LogHandle );
        break;

    case 2:
        RunTest2( LogHandle );
        break;

    default:
        RunTest3( LogHandle, ID );
        break;
    }
}


VOID
WINAPI
SampleEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    SampleDllThreadID = 0;
    OutputDebugString( TEXT("SAMPLEDLL: EndTest is called\n") );
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( sampledll )
#pragma data_seg()

BEGIN_EXPORT_TABLE( sampledll )
    EXPORT_TABLE_ENTRY( "StartTest", SampleStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SampleEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", SampleDllMain )
END_EXPORT_TABLE( sampledll )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slix\slix.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slix.h

Abstract:

    #defines, classes, & functions used in Slix2k

Author:

    Jason Gould (a-jasgou) June 2000

--*/
//slix.h, defines the USBProvider class temporarily, until slix2k can merge with Sli30
#ifndef __slix_h_
#define __slix_h_

#include "cclient.h"
#include "usbprovider.h"

//#include "slixresource.h"

//#include <windows.h>

//header in big ugly folder name, because it is shared between XBox and Hardware projects...
//it sets up a bunch of structures for data formatting for transmitting stuff
#include "..\slixtransfer.h" 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slix\slixsock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    declares networking functions for Slix2k to communicate with slixbox

Author:

    Jason Gould (a-jasgou) June 2000

--*/
//SlixSock.h, declares functions for sending data for SliX-Win2k

#ifndef __slixsock_h_
#define __slixsock_h_

//header in c:\, because it is shared between XBox and Hardware projects...
//it sets up a bunch of structures for data formatting for transmitting stuff
//#include "\slixtransfer.h" 

#include "..\slixtransfer.h" 

#include <winsock2.h>

SOCKET ssConnectTCP(char * szDestination, char * szService);  //log on to the server at szDestination, using szService
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int * len = NULL);  //log off of the server
int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend); //send "tosend" bytes from sockdata through hsock
int ssRecv(SOCKET hsock, TRANSFERDATA * sockdata, int maxrecv, int timeout = RECV_TIMEOUT);//recv at most "maxrecv" bytes to sockdata through hsock

DWORD WINAPI ReadThread(LPVOID pParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slix\slixsock.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixsock.cpp

Abstract:

    network routines used by slix2k

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#include <windowsx.h>
#include <winsock2.h>

#include "slixsock.h"

#include <stdio.h>



//HANDLE			gDoRead			= INVALID_HANDLE_VALUE;	//event, tells read thread to read
//HANDLE			gHasRead		= INVALID_HANDLE_VALUE;	//event, tells main thread read has occurred
//HANDLE			gDoQuit			= INVALID_HANDLE_VALUE;	//event, tells read thread to quit
//HANDLE			gReadThread 	= INVALID_HANDLE_VALUE;	//handle to read thread
//int				gToRecv			= 0;					//num of bytes for read thread to read
//SOCKET			gReadSock		= INVALID_SOCKET;		//socket for read thread to read from
//char			gReadData[256];							//buffer to read data to



/*************************************************************************************
Function:   GetAddr
Purpose:	get an ip address from a text ip address or computer name
Params:     szHost --- pointer to string that contains host name or "#.#.#.#" format
Return:     0 if it failed, non-zero if an address was found
*************************************************************************************/
unsigned long GetAddr(char * szHost)
{
	unsigned long ret = INADDR_ANY;
	LPHOSTENT host;
	if(!*szHost)
		return ret;
	ret = inet_addr(szHost);	//check first for "#.#.#.#" format...
	if((ret == INADDR_NONE) && strcmp(szHost, "255.255.255.255"))	//if that didn't work,
	{
		host = gethostbyname(szHost);	//try to get it by name...
		if(!host) {						//if that didn't work,
			return INADDR_ANY;				//return 0
		}
		ret = *(unsigned long *)(host->h_addr_list[0]);	//return the address from hostname
	}	
	return ret;	//return the address from "#.#.#.#" format
}

/*************************************************************************************
Function:   GetPort
Purpose:	get the port number of a particular service
Params:     service --- either a number in a string, or a service name
Return:     the port number of the service
*************************************************************************************/
unsigned short GetPort (char * service)
{
	LPSERVENT servent;
	if(isdigit(service[0]))
		return atoi(service);

	servent = getservbyname(service, "tcp");
	if(!servent)
		return 0;
	return servent->s_port;
}

void DoBox(char * text, ...) {
	char buf[256];
	vsprintf(buf, text, (char*)((&text) + 1));
	MessageBox(NULL, buf, buf, MB_OK);
}

/*************************************************************************************
Function:   ssConnectTCP
Purpose:	initialize the tcp connections, connect to the server, start read thread
Params:     szDestination --- the computer name to connect to
            szService --- the service to use (for slix, should be "53331"
Return:     INVALID_SOCKET if it failed, socket value if it worked
*************************************************************************************/
SOCKET ssConnectTCP(char * szDestination, char * szService)
{
	SOCKET hsock;
	WSADATA wsadata;
	int ret;
	SOCKADDR_IN RemoteName;

	ret = WSAStartup(2, &wsadata);	//initialize Winsock
	if(ret != 0) {
		DoBox("WSAStartup, error %d", WSAGetLastError());
		return 0;
	}

	hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);	//create a socket
	if(hsock==INVALID_SOCKET) {
		DoBox("socket, error %d", WSAGetLastError());
		return 0;
	}

	RemoteName.sin_addr.S_un.S_addr = GetAddr(szDestination);	//get address of server
	if(RemoteName.sin_addr.S_un.S_addr == INADDR_NONE) {
		DoBox("GetAddr, error %d", WSAGetLastError());
//		closesocket(hsock);
		return 0;
	}

	RemoteName.sin_port = GetPort(szService);	//get port for the address
	if(RemoteName.sin_port==0) {
		DoBox("GetPort, error %d", WSAGetLastError());
//		closesocket(hsock);
		return 0;
	}
    RemoteName.sin_port = 53331;
	
	RemoteName.sin_family = PF_INET;
	ret = connect(hsock, (LPSOCKADDR)&RemoteName, sizeof(SOCKADDR));  //connect to server
	if(ret == SOCKET_ERROR) {
		DoBox("connect, error %d", WSAGetLastError());
//		closesocket(hsock);
		return 0;
	}

	int tRuE = TRUE;
	setsockopt(hsock, IPPROTO_TCP, TCP_NODELAY, (char*)&tRuE, 1);

	tRuE = 5;
	setsockopt(hsock, IPPROTO_TCP, SO_RCVTIMEO, (char*)&tRuE, 4);


//	DWORD ThreadID;
//	gDoRead  = CreateEvent(NULL, TRUE, FALSE, NULL);	//init DoRead event
  //  gHasRead = CreateEvent(NULL, TRUE, FALSE, NULL);	//init HasRead event
	//gDoQuit  = CreateEvent(NULL, TRUE, FALSE, NULL);	//init DoQuit event
	
//	gReadThread   = CreateThread(NULL, 0, ReadThread, NULL, 0, &ThreadID);	//begin the read thread
//	/if(gReadThread == INVALID_HANDLE_VALUE) {
//		DoBox("CreateThread, error %d", WSAGetLastError());
//		closesocket(hsock);
//		return 0;
//	}

	return hsock;	
}

/*************************************************************************************
Function:   ssCloseTCP
Purpose:	close the tcp connection, 
Params:     [IN] hsock --- the socket to close
			[OPT OUT] inbuf --- buffer to receive data if there is a transfer left to do
			[OPT IN OUT] len --- (IN) max buffer size, (OUT) num of bytes received
Return:     0 if everything closed properly, non-0 if an error happened
*************************************************************************************/
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int * len)
{
	int ret;
	int bytesdone = 0;

	if(inbuf) {						//if we can,
		ret = (len ? *len : 256);			
		ret = recv(hsock, (char*)inbuf, ret, 0);	//receive the last piece of data...
		if(len) *len = ret;			
	}

	if(WSAIsBlocking()) {			//cancel blocking calls
		WSACancelBlockingCall();	
	}

	shutdown(hsock, 1);				//shut down the socket

//	SetEvent(gDoQuit);				//tell the Read Thread to quit
//	if(WaitForSingleObject(gHasRead, 100))	//give the read thread some time to quit...
//		TerminateThread(gReadThread, 1);	//if it's stuck, terminate it (that sounds cruel, doesn't it?)

	ret = closesocket(hsock);		//close our socket

	WSACleanup();					//and close down winsock, if necessary
	return ret;
}


/*************************************************************************************
Function:   ssSend
Purpose:	send data!
Params:     [IN] hsock --- the socket to send through
			[IN] sockdata --- pointer to the data to send
			[IN] tosend --- the number of bytes from sockdata to send
Return:     number of bytes sent (0 would imply an error then...)
*************************************************************************************/
int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend)
{
	tosend = sockdata->size;
	int sent = 0;
	int temp;
	while(sent < tosend) {
		temp = send(hsock, &(sockdata->all[sent]), tosend, 0);
		if(temp == SOCKET_ERROR) {
			DoBox("send failed, error %d", WSAGetLastError());
			return 0;
		}
		sent += temp;
	}
	return sent;
}


/*************************************************************************************
Function:   ssRecv
Purpose:	receive data
Params:     [IN]  hsock --- the socket to read from
			[OUT] sockdata --- buffer to receive data into
			[IN]  maxrecv --- the max number of bytes to receive
			[OPT] timeout --- the number of miliseconds to wait
Return:     number of bytes received (should be > 2)
*************************************************************************************/
/*
int ssRecv(SOCKET hsock, TRANSFERDATA * sockdata, int maxrecv, int timeout)
{
	gToRecv = maxrecv;
	gReadSock = hsock;
	SetEvent(gDoRead);
	ResetEvent(gHasRead);
	if(WAIT_OBJECT_0 == WaitForSingleObject(gHasRead, timeout)) {
		memcpy((void*)sockdata, (void*)gReadData, sizeof(sockdata));
		return sockdata->size;
	}
	return 0;
}
*/

/*************************************************************************************
Function:   ReadThread
Purpose:	the thread to read stuff from slixbox
Params:     [UNUSED] pParam
Return:     irrelevant
*************************************************************************************/
/*DWORD WINAPI ReadThread(LPVOID pParam)
{
	int received = 0;
	int temp;
	int torecv;
	SOCKET hsock;
	
	HANDLE events[] = {gDoRead, gDoQuit, gHasRead};	//various events we use

	while(1) {
		temp = WaitForMultipleObjects(2, events, FALSE, INFINITE);	//wait for DoRead or DoQuit
		if(WAIT_OBJECT_0 + 1 == temp) {							//if we're supposed to quit...
			SetEvent(gHasRead);									//say that we're quitting
			break;												//quit	
		}
		printf("gDoRead received.\n");

		torecv = gToRecv;									//the amount to receive
		hsock = gReadSock;									//the socket to read from

		memset(gReadData, 0, sizeof(gReadData));			//we're reading, so clean the buffer

		received = 0;
		do {
			temp = recv(hsock, &gReadData[received], torecv - received, 0);	//receive already!
			printf("recv received %d\n", temp);

			torecv = gReadData[0];				//the num of bytes we should have received
			if(temp == 0 || temp == SOCKET_ERROR) {		//if there was a problem, 
				break;									//go back to main loop
			}
			received += temp;					//we received data!
		} while (received < torecv);			//receive until we've got it all
		SetEvent(gHasRead);						//we've read something...
	}

	return 0;		//we will get here if gDoQuit ever gets set.
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixbox\slixbox.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixbox.cpp

Abstract:

    slixbox main loop, initialization, and other stuff

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#include "slixbox.h"
#include "slixdriver.h"
//#include "..\..\..\..\public\ddk\inc\usb.h"

//#include <mmsystem.h>







//__inline void free(void * a) {delete[] a; }
//__inline void * malloc(size_t s) {return (void*)(new char[s]); }

#pragma warning(disable : 4035)
INT64 __inline GetTime() { 	_asm rdtsc }
#pragma warning(default : 4035)
#define measure(Description, code) {INT64 _ttt1, _ttt2; _ttt1 = GetTime(); code; _ttt2 = GetTime(); DebugPrint(Description ": %I64d\n", (_ttt2 - _ttt1) / 733);}

//extern "C" void  __stdcall free(void*);
//extern "C" void* __stdcall malloc(size_t);
BYTE UsbdCodeToSliCode(USBD_STATUS u, BOOL isIn);

SOCKET gSock;

//
//  Call USB's init function directly since we do not link to xapi.
//

/*************************************************************************************
Function:   init
Purpose:	do all initialization for slixbox
Params:     none
Return:     0 if good, non-0 if bad
*************************************************************************************/
int init()
{
	gSock = ssInitServer();
	return 0;
}

extern SOCKET ggSock;

#define SETUP_IN 1
#define SETUP_OUT 2
#define SETUP_NONE 0
typedef struct {
	char * data2;		//to be malloced as needed. Holds the big data buffer
	char data[8];		//the main setup packet
	long datasize;		//size of data[]
	BYTE type;			//SETUP_IN, SETUP_OUT, or SETUP_NONE, depending on the type of setup
	USHORT expected;	//total size of data2, the number of bytes to send to either islixboxd or slix
	USHORT current;		//number of bytes sent so far to islixboxd or slix
} SetupBuffer;

typedef struct _QUEUE {
	struct _QUEUE* next;
	TRANSFERDATA * d;
} QUEUE, *PQUEUE;

QUEUE q = {0,0};

SetupBuffer sbs[128][16];	//[address][endpoint] //////port //slot //endpoint

typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

BYTE parse(TRANSFERDATA * c, BOOL isqueue) 
{
	TRANSFERDATA t;
	SetupBuffer *tempsb;
	USBD_STATUS temp;
	int i;
	USHORT sTemp = 0;
	int size;
	static int slixdout=0,slixdin=0;


	switch(c->type) {	//the type of packet we receive
	case PID_INIT_IN:	//a request for an IN
		if(sbs[c->initin.address][c->initin.endpoint].type != SETUP_IN) {
			if(c->initin.endpoint == 0) {
				t.in.ret = XSTATUS_UserError;
			} else {
				//normal in request... (no setup packet buffering)
				//send in the request!
				slixdin++;
				temp = SlixdIn(c->initin.address, c->initin.endpoint, &t.in.data[0], &c->initin.max);
				t.in.ret = UsbdCodeToSliCode(temp, TRUE);	//prepare the return code
//				DebugPrint("Printing from Slixbox.cpp->parse->IN, Slixdout=%d, Slixdin=%d\n", slixout, slixdin);
//				DebugPrint("from SlixdIn, code %02x, data %d %016I64x\n", t.in.ret, c->initin.max, *(__int64*)&t.in.data[0]);
			}

			t.type = PID_IN;							//and the type of packet we're sending back
			t.size = c->initin.max + sizeof(TRANSFER_IN);//size of packet we're sending

			if(isqueue) return t.in.ret;

			temp = send(gSock, (char*)&t, t.size, 0);			//send the packet

//				DebugPrint("send returned %d\n", temp);
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;										//and go back to the main loop again
			
		} else {
			//DebugPrint("buffered in...\n");
			//we're doing setup packet buffering for this address!
			tempsb = &sbs[c->initin.address][c->initin.endpoint];

			t.size = (sizeof(TRANSFER_IN) +	//size of the packet to send...
				min((signed)c->initin.max, (tempsb->expected - tempsb->current)));

			t.type = PID_IN;	//type of the packet to send
			t.in.ret = XSTATUS_Success;	//"handshake" to send back

			if (tempsb->current >= tempsb->expected && ((t.size - sizeof(TRANSFER_IN)) < 8)) {	//if we've sent all the data...
				//DebugPrint("All data sent. (current %d, expected %d) Setup packet is completed...\n", tempsb->current, tempsb->expected);
				free(tempsb->data2);					//free our buffer
                tempsb->data2 = NULL;
				tempsb->type = SETUP_NONE;				//and stop buffering this endpoint
			}


			for(i = 0; i < (signed)t.size - (signed)sizeof(TRANSFER_IN); i++) {		//copy the data to the slixboxsock buffer
				t.in.data[i] = tempsb->data2[tempsb->current++];
			}
			
			if(isqueue) return t.in.ret;

			temp = send(gSock, (char*)&t, t.size, 0);				//& send that data !
//				DebugPrint("send returned %d\n", temp);
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

			break;
		}

	case PID_OUT:
		if(sbs[c->out.address][c->out.endpoint].type != SETUP_OUT) {
			//normal OUT operation
//				DebugPrint("Out request received\n");

			//send the data out!
			slixdout++;
			temp = SlixdOut(c->out.address, c->out.endpoint, c->out.data, c->out.size - sizeof(c->out));

			t.ret.ret = UsbdCodeToSliCode(temp, FALSE);		//get our return code
			

			t.type = PID_RET;								//prepare our packet
			t.size = sizeof(TRANSFER_RETURN);				//size of the packet

			if(isqueue) return t.ret.ret;
			
			temp = send(gSock, (char*)&t, t.size, 0);		// & send the packet!
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;

		} else {
			//DebugPrint("Buffered Out...\n");
			//we're doing SETUP packet buffering...
			tempsb = &sbs[c->out.address][c->out.endpoint];

			c->out.size = min((signed)c->out.size, (tempsb->expected - tempsb->current)); //so we don't over-run data2
//                       (signed)c->out.size - (signed)sizeof(TRANSFER_OUT); i++){	//copy the data into the buffer for islixboxd
			for(i=0; i < (signed)c->out.size; i++){	//copy the data into the buffer for islixboxd
				tempsb->data2[tempsb->current++] = c->out.data[i];
			}

			//if we have enough to send...
			if(tempsb->current >= tempsb->expected) {
				//DebugPrint("Sending our buffer, %d bytes", tempsb->expected);
				//sned the stuff to islixboxd
				temp = SlixdSetup(c->out.address, c->out.endpoint, 
					tempsb->data, tempsb->datasize, 
					tempsb->data2, &tempsb->expected);

				free(tempsb->data2);	//release the data buffer
                tempsb->data2 = NULL;
				tempsb->type = SETUP_NONE;	//and stop buffering this endpoint

				t.ret.ret = UsbdCodeToSliCode(temp, FALSE); //prepare the return value

				t.type = PID_RET;							//prepare the slixboxsock packet ...
				t.size = sizeof(TRANSFER_RETURN);
				
				if(isqueue) return t.ret.ret;

				temp = send(gSock, (char*)&t, t.size, 0);	//send that packet
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

				break;
			} else {
				//DebugPrint("Bytes collected: %d, bytes expected: %d\n", tempsb->current, tempsb->expected);
				//produce a fake packet to send back, so recv is happy on slix.
				t.ret.ret = XSTATUS_Ack;


				t.type = PID_RET;
				t.size = sizeof(TRANSFER_RETURN);
				
				if(isqueue) return t.ret.ret;

				temp = send(gSock, (char*)&t, t.size, 0);
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
				break;
			}
		}

	case PID_SETUP:
//			DebugPrint("PID_SETUP received");
		sTemp = *(USHORT*)&(c->setup.data[6]); //get the USHORT stored starting at &data[6]
		tempsb = &sbs[c->setup.address][c->setup.endpoint];
		size = c->setup.size - sizeof(c->setup);

		if(sTemp == 0 ) {
			//this is a "no-data" setup transfer (just the setup packet)
//			DebugPrint("no-data setup transfer.\n");

			//send our data!
//				DebugPrint("SlixBox Setup: address %x, endpoint %x, data %16I64x, size %d, size2 %d", c->setup.address, c->setup.endpoint, *(INT64*)c->setup.data, size, sTemp);
			temp = SlixdSetup(c->setup.address, c->setup.endpoint, c->setup.data, size, NULL, &sTemp);
//				DebugPrint("SlixdSetup returned %x", temp);

			t.ret.ret = UsbdCodeToSliCode(temp, FALSE);	//prepare the return value
			

			t.type = PID_RET;							//and prepare the return packet
			t.size = sizeof(TRANSFER_RETURN);

			if(isqueue) return t.ret.ret;
			
			temp = send(gSock, (char*)&t, t.size, 0);			//send the return packet
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;

		} else {
			//this setup transfer requires some data!
//			DebugPrint("setup requires data.\n");

			if(tempsb->data2) {			//if we didn't get around to freeing the data before... (it could happen)
				free(tempsb->data2);	//do it now...
                tempsb->data2 = NULL;
			}

			//prepare the setup buffering structure
			
			tempsb->expected = *(USHORT*)&c->setup.data[6];				//size of data2 to buffer
			tempsb->data2 = (char*)malloc(*(USHORT*)&c->setup.data[6]);	//create that buffer
			tempsb->current = 0;										//we haven't collected any yet!

			if(c->setup.data[0] & 0x80) {								
				//this is a SETUP_IN transfer, so we do the INs now, & send data to slix when requested

				tempsb->type = SETUP_IN;		

				//send the setup packet, get the data back
				temp = SlixdSetup(c->setup.address, c->setup.endpoint, c->setup.data, size, 
					tempsb->data2, &tempsb->expected);

//				DebugPrint("Setup requires INs. %d bytes buffered.\n", tempsb->expected);

			} else {
				//this is a SETUP_OUT transfer, so we will wait to collect the data from the user.

				//store our setup packet
				for(i = 0; i < size; i++) {
					tempsb->data[i] = c->setup.data[i];
				}
				tempsb->datasize = size;		//size of the setup packet
				tempsb->type = SETUP_OUT;

				temp = USBD_STATUS_SUCCESS;		//bogus return value ... 
			}
		}
	
		t.ret.ret = UsbdCodeToSliCode(temp, FALSE);	//convert the return code


		t.type = PID_RET;							//prepare the return packet
		t.size = sizeof(TRANSFER_RETURN);
		
		if(isqueue) return t.ret.ret;

		temp = send(gSock, (char*)&t, t.size, 0);	//send the return packet	
		if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
		break;

	case PID_DATA0:
		//data toggle tweaks... 
//			DebugPrint("data0 requested\n");
		SlixdData0(c->toggle.endpoint);

		if(isqueue) return XSTATUS_Success;
		
		break;
	case PID_DATA1:
//			DebugPrint("data1 requested\n");
		//data toggle tweaks... 
		SlixdData1(c->toggle.endpoint);
		
		if(isqueue) return XSTATUS_Success;
		
		break;
	case PID_RESET:
		temp = SlixdReset();

		t.ret.ret = UsbdCodeToSliCode(temp, TRUE);


		t.type = PID_RET;
		t.size = sizeof(TRANSFER_RETURN);

		if(isqueue) return t.ret.ret;
		
		temp = send(gSock, (char*)&t, t.size, 0);
		if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

		break;
	default:
		DebugPrint("ssRecv received data of unknown type 0x%02x.\n", c->type);
		return XSTATUS_TransmissionError;
		break;
	}
	return XSTATUS_Success;
}

/*************************************************************************************
Function:   main
Purpose:	entrypoint, main loop, etc
Params:     none
Return:     it shouldn't ever... this is an xbox app.
*************************************************************************************/
void __cdecl main()
{
	TRANSFERDATA c;	//in-bound stuff

	TRANSFERDATA t;	//out-bound stuff

    XInitDevices(0,NULL);
	
	DebugPrint("sizeof(TRANSFERDATA) (should be 256): %d\n", sizeof(TRANSFERDATA));

 	DebugPrint("SliXbox has begun!\n");
	int r;
	int count = 3;
	USHORT sTemp = 0;
	int size;
	int i;
	SetupBuffer *tempsb;
	USBD_STATUS temp;
	int queue = 0;
	QUEUE *pq, *pq2;
	BYTE NakIsOK;

	//[topology][endpoint] // even though endpoint should only be 0...
	//this holds all the stuff for the setup packet "buffering"
	
	memset(sbs, 0, sizeof(sbs));//zero the sbs array

	while ((r = init()) != 0) {	//keep trying to init since there is no point in quitting
		DebugPrint("init failed with return value %d. Trying again.\n", r);
		Sleep(2000);
	}
	
	DebugPrint("init worked!\n");

	while(1) {
		temp = recv(gSock, (char*)&c, 256, 0);

		if(temp <= 0) {
			if(WSAGetLastError() == 10103) {
				continue;
			}

			DebugPrint("recv failed, error %d\n", WSAGetLastError());
			if (SOCKET_ERROR == closesocket(gSock))	{
				DebugPrint("closesocket failed, error %d\n", WSAGetLastError());
			}
			if (SOCKET_ERROR == listen(ggSock, 1)) {
				DebugPrint("listen failed, error %d\n", WSAGetLastError());
			}
			gSock = accept(ggSock, NULL, NULL);
			if(gSock == INVALID_SOCKET) {
				DebugPrint("accept failed, error %d\n", WSAGetLastError());
			}

			continue;
		} else {
		}

		switch(c.type) {	//the type of packet we receive
		case PID_BEGIN_QUEUE:
			if(queue) {
				DebugPrint("Error! Queue already in progress!\n");
				break;
			}
			NakIsOK = c.beginqueue.successonnak;
			queue = 1;
			pq = &q;
			break;
		case PID_INIT_END_QUEUE:
			t.type = PID_RETURN_END_QUEUE;
			t.size = sizeof(TRANSFER_RETURN_END_QUEUE);
			t.retendqueue.linefailed = 0;
			t.retendqueue.ret = XSTATUS_Success;
			if(!queue) {
				DebugPrint("Error! no queue to end!\n");
				break;
			}
			for(pq = q.next; pq;)	{
				if(0 == t.retendqueue.linefailed) {
					temp = parse((TRANSFERDATA*)pq->d, TRUE);
				}
				pq2 = pq;
				pq = pq->next;
				free(pq2);
                pq2 = NULL;
				if((temp == XSTATUS_Ack) || (temp == XSTATUS_Success) || ((temp == XSTATUS_Nak) && NakIsOK)) {
				} else {
					t.retendqueue.linefailed = queue;
					t.retendqueue.ret = (BYTE)temp;
				}
				queue++;
			}
			temp = send(gSock, (char*)&t, t.size, 0);			//send the packet
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			queue = 0;
			break;
		default:
			if(queue == 0) {
				parse(&c, FALSE);
			} else {
				pq->next = (QUEUE*)malloc(sizeof(QUEUE));
				pq = pq->next;
				pq->next = 0;
				pq->d = (TRANSFERDATA*)malloc(c.size);
				memcpy(pq->d, &c, c.size);
			}
			break;
		}

	} 
}



/*************************************************************************************
Function:   UsbdCodeToSliCode
Purpose:	convert status codes from usbd to slix
Params:		u --- the usbd status code to convert
			isIn --- TRUE if this code is from an IN, FALSE if it is from an OUT or SETUP
Return:		the sli status code
Note:		if (isIn), USBD_STATUS_SUCCESS becomes STATUS_Success, otherwise, XSTATUS_Ack
*************************************************************************************/
BYTE UsbdCodeToSliCode(USBD_STATUS u, BOOL isIn)
{
	switch (u)
	{
	case USBD_STATUS_SUCCESS:
		if(isIn)
			return XSTATUS_Success;
		else
			return XSTATUS_Ack;
	case USBD_STATUS_PENDING:
	case 0xC000000F:			//this "error" doesn't seem to be defined anywhere, 
								//but it is sent to the callback when the request is cancelled.
		return XSTATUS_Nak;

	case USBD_STATUS_CRC:
		return XSTATUS_DataCRCError;
	case USBD_STATUS_BTSTUFF:
		return XSTATUS_SyncError;
	case USBD_STATUS_DATA_TOGGLE_MISMATCH:
		return XSTATUS_DataToggleError;
	case USBD_STATUS_STALL_PID:
		return XSTATUS_Stall;
	case USBD_STATUS_PID_CHECK_FAILURE:
	case USBD_STATUS_UNEXPECTED_PID:
		return XSTATUS_PIDError;
	case USBD_STATUS_DATA_OVERRUN:
		return XSTATUS_ShortPacketError;
	case USBD_STATUS_DATA_UNDERRUN:
		return XSTATUS_ShortPacketError;

	case USBD_STATUS_HALTED:
		DebugPrint("Usbd error: halted 0x%x\n", u);
		goto narf;
	case USBD_STATUS_DEV_NOT_RESPONDING:
		DebugPrint("Usbd error: dev_not_responding 0x%x\n", u);
		goto narf;
	case USBD_STATUS_ERROR:
		DebugPrint("Usbd error: \"ERROR\" 0x%x\n", u);
		goto narf;
	case USBD_STATUS_RESERVED1:
		DebugPrint("Usbd error: reserved1 0x%x\n", u);
		goto narf;
	case USBD_STATUS_RESERVED2:
		DebugPrint("Usbd error: reserved2 0x%x\n", u);
		goto narf;
	case USBD_STATUS_BUFFER_OVERRUN:
		DebugPrint("Usbd error: buffer_overrun 0x%x\n", u);
		goto narf;
	case USBD_STATUS_BUFFER_UNDERRUN:
		DebugPrint("Usbd error: buffer_underrun 0x%x\n", u);
		goto narf;
	case USBD_STATUS_NOT_ACCESSED:
		DebugPrint("Usbd error: not_accessed 0x%x\n", u);
		goto narf;
	case USBD_STATUS_FIFO:
		DebugPrint("Usbd error: fifo 0x%x\n", u);
		goto narf;
	default:
		DebugPrint("Unknown usbd error! 0x%x\n", u);
narf:
		return XSTATUS_ConfigurationError;
	}
}


/*************************************************************************************
Function:   deinit
Purpose:	deinitialization routine?
Note:		there is no function. This program should never quit.
*************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slix\myassert.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    myassert.h

Abstract:

    a shared header for slixbox and slix2k, defines simple macros for 
	doing error codes on xbox or win2k


Author:

    Jason Gould (a-jasgou) June 2000

--*/

#undef MyAssertPreCode1
#undef MyAssertPreCode2
#undef MyAssertPreCode3
#undef MyAssertPostCode1	
#undef MyAssertPostCode2	
#undef MyAssertPostCode3	
#undef MyAssertPreCodeDebug1
#undef MyAssertPreCodeDebug2
#undef MyAssertPreCodeDebug3
#undef MyAssertPostCodeDebug1
#undef MyAssertPostCodeDebug2
#undef MyAssertPostCodeDebug3
#undef MyAssertFunctionTitle
#undef MyAssertStr1Level1
#undef MyAssertStr1Level2
#undef MyAssertStr1Level3
#undef MyAssertStr2Level1
#undef MyAssertStr2Level2
#undef MyAssertStr2Level3
#undef MyAssertOut1
#undef MyAssertOut2
#undef MyAssertOut3

/******************************************************************************
/*	#undef then #define these in your program appropriately...
/*****************************************************************************/

#define MyAssertPreCode	
//#define MyAssertPreCode0	
#define MyAssertPreCode1	MyAssertPreCode //warning pre-message code
#define MyAssertPreCode2	MyAssertPreCode //problem pre-message code
#define MyAssertPreCode3	MyAssertPreCode //error pre-message code

#define MyAssertPostCode
//#define MyAssertPostCode0
#define MyAssertPostCode1	MyAssertPostCode //warning after-message code
#define MyAssertPostCode2	MyAssertPostCode //problem after-message code
#define MyAssertPostCode3	MyAssertPostCode //error after-message code

//#define MyAssertPreCodeDebug0	//message pre-message debug code 
#define MyAssertPreCodeDebug1	//warning pre-message debug code 
#define MyAssertPreCodeDebug2	//problem pre-message debug code
#define MyAssertPreCodeDebug3	//error pre-message debug code
	
//#define MyAssertPostCodeDebug0					//message post-message debug code
#define MyAssertPostCodeDebug1					//warning post-message debug code
#define MyAssertPostCodeDebug2	//__asm {int 3};	//problem post-message debug code
#define MyAssertPostCodeDebug3	//__asm {int 3};	//error post-message debug code

#define MyAssertFunctionTitle	"Global"	//function name... "global" until declared otherwise

//#define MyAssertStr1Level0(_Code, _Title) MyAssertFunctionTitle "" _Title " -- File: " __FILE__ ", Line: " MyAssertLine
#define MyAssertStr1Level1(_Code, _Title) MyAssertFunctionTitle " Warning: " _Title " -- File: " __FILE__ ", Line: " MyAssertLine
#define MyAssertStr1Level2(_Code, _Title) MyAssertFunctionTitle " Problem: " _Title " -- File: " __FILE__ ", Line: " MyAssertLine
#define MyAssertStr1Level3(_Code, _Title) MyAssertFunctionTitle " Error: " _Title " : " #_Code " -- File: " __FILE__ ", Line: " MyAssertLine

//#define MyAssertStr2Level0(_Code, _Title) MyAssertFunctionTitle ": Notice"
#define MyAssertStr2Level1(_Code, _Title) MyAssertFunctionTitle ": Warning"
#define MyAssertStr2Level2(_Code, _Title) MyAssertFunctionTitle " Problem: " _Title
#define MyAssertStr2Level3(_Code, _Title) MyAssertFunctionTitle " Error: " _Title

#ifndef _XBOX_

	#ifdef _DEBUG
		#define MyAssertOut1(_Code, _Title) MessageBox(NULL, MyAssertStr1Level1(_Code, _Title), MyAssertStr2Level1(_Code, _Title), MB_OK);
	#else
		#define MyAssertOut1(_Code, _Title)
	#endif

	#define MyAssertOut2(_Code, _Title) MessageBox(NULL, MyAssertStr1Level2(_Code, _Title), MyAssertStr2Level2(_Code, _Title), MB_OK);
	#define MyAssertOut3(_Code, _Title) MessageBox(NULL, MyAssertStr1Level3(_Code, _Title), MyAssertStr2Level3(_Code, _Title), MB_OK);

#else

//	#define MyAssertOut0(_Code, _Title) DebugPrint(MyAssertStr1Level0(_Code, _Title) "\n");
	#define MyAssertOut1(_Code, _Title) DebugPrint(MyAssertStr1Level1(_Code, _Title) "\n");
	#define MyAssertOut2(_Code, _Title) DebugPrint(MyAssertStr1Level2(_Code, _Title) "\n");
	#define MyAssertOut3(_Code, _Title) DebugPrint(MyAssertStr1Level3(_Code, _Title) "\n");

#endif


/******************************************************************************
/*	Don't change this...
/*****************************************************************************/

#ifdef _DEBUG

	#define MyAssert(_code, _level, _title)									\
		if(!(_code)) {														\
			MyAssertPreCode##_level;										\
			MyAssertPreCodeDebug##_level;									\
			MyAssertOut##_level(_code, _title);								\
			MyAssertPostCodeDebug##_level;									\
			MyAssertPostCode##_level;										\
		}

#else

	#define MyAssert(_code, _level, _title)									\
		if(!_code) {														\
			MyAssertPreCode##_level;										\
			MyAssertOut##_level(_code, _title);								\
			MyAssertPostCode##_level;										\
		}

#endif

#define MyAssertIntToStr_(_narf) #_narf
#define MyAssertIntToStr(_narf) MyAssertIntToStr_(_narf)
#define MyAssertLine MyAssertIntToStr(__LINE__)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slix\slix.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slix.cpp

Abstract:

    main file for Slix2k

Author:

    Jason Gould (a-jasgou) June 2000

--*/

#include <stdio.h>
#include "slix.h"
#include "slixsock.h"
#include "myassert.h"

#undef IN
#undef OUT
#undef SETUP

//Get the name of the server, store it in gMachineName
BOOL CALLBACK GetMachineNameProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
char gMachineName[128] = {0};	//hold the name of the server
#define ADDRESS_FROM_PORT_SLOT(port, slot) ((slot << 4) + (port))

void DoBox(char * text, ...);

BOOL isqueue = 0;


/**********Global varaibles*************/
BOOL gInited = FALSE;			//are we properly initialized?
SOCKET gSock = INVALID_SOCKET;	//our winsock socket
//extern SOCKET ggSock;

extern "C" int kbhit();

#pragma warning(disable : 4035)
INT64 __inline GetTime() { 	_asm rdtsc }
#pragma warning(default : 4035)
#define measure(Description, code) {INT64 _ttt1, _ttt2; _ttt1 = GetTime(); code; _ttt2 = GetTime(); printf(Description ": %I64d\n", (_ttt2 - _ttt1) / 700);}

/*
void main()
{
	printf("sizeof(TRANSFERDATA) (should be 256): %d\n", sizeof(TRANSFERDATA));
	CBSEIDEClient arf;
	CUSBProvider u;
	BYTE data[256] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	int size;
	BYTE temp[4];
	BYTE datapid = PID_DATA0;

	u.Initialize(&arf);

//	size = 8;
//	temp = u.SETUP(ADDRESS_FROM_PORT_SLOT(1,0), 0, &data[0], size);
//	printf("SETUP returned %d... \n", temp);

	while(1)
	{
		do {
			size = 8;
			temp[0] = u.IN(ADDRESS_FROM_PORT_SLOT(1,0), 0x01, &data[0], &size);
//			if(temp[0] != STATUS_Nak && temp[0] != STATUS_Success) {
//				printf("in returned 0x%x\n", temp[0]);
//			}
			if(temp[0] != STATUS_Success) {
				switch (temp[0]) {
				case STATUS_Nak				   :
					printf("NAK\n"); break;
				case STATUS_Stall              :
					printf("Stall\n"); break;
				case STATUS_Ignore             :
					printf("Ignore\n"); break;
				case STATUS_DataCRCError       :
					printf("CRC Error\n"); break;
				case STATUS_DataToggleError    :
					printf("DataToggle Error!\n"); break;
				case STATUS_SyncError          :
					printf("Sync Error!\n"); break;
				case STATUS_BabbleError        :
					printf("Babble Error!\n"); break;
				case STATUS_PIDError           :
					printf("PID Error!\n"); break;
				case STATUS_ShortPacketError   :
					printf("ShortPacket!\n"); break;
				case STATUS_ConfigurationError :
					printf("ConfigurationError!\n"); break;
				case STATUS_TransmissionError  :
					printf("TransmissionError!\n"); break;
				}
			}
		} while (temp[0] != STATUS_Success);

		size = 8;
		temp[1] = u.IN(ADDRESS_FROM_PORT_SLOT(1,0), 0x01, &data[8], &size);
		size = 8;
		temp[2] = u.IN(ADDRESS_FROM_PORT_SLOT(1,0), 0x01, &data[16], &size);
		size = 8;
		temp[3] = u.IN(ADDRESS_FROM_PORT_SLOT(1,0), 0x01, &data[24], &size);
		printf("IN:%2x%2x%2x%2x %016I64x %016I64x %016I64x %016I64x\n", 
			temp[0], temp[1], temp[2], temp[3], 
			*(INT64*)&data[0], *(INT64*)&data[8], *(INT64*)&data[16], *(INT64*)&data[24]);

		size = 4;
		data[100] = 0;	//set up the OUT packet to set motor speed...
		data[101] = 4;
		data[102] = data[8]; 
		data[103] = data[9];
		u.OUT(ADDRESS_FROM_PORT_SLOT(1,0), 0x02, datapid, &data[100], size);
		datapid ^= PID_DATA0 ^ PID_DATA1;
		
//	    SEND("OUT ADDR(" + Address$ + ") ENDP(02) DATA0 DATA(00 04 " + LeftSpd$ + " " + RightSpd$ + ")")
	}
	u.~CUSBProvider();
	while(!kbhit());
}
*/

BYTE CUSBProvider::GetStatus(BYTE nPortStatus)
{
	return ROOT1_NO_ERROR;
}
BYTE CUSBProvider::PortPower(BOOL bOn)
{
	return ROOT1_NO_ERROR;
}
BYTE CUSBProvider::Suspend()
{
	return ROOT1_NO_ERROR;
}
BYTE CUSBProvider::Resume()
{
	return ROOT1_NO_ERROR;
}

BYTE CUSBProvider::Reset()
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::Reset"
#undef MyAssertPostCode
#define MyAssertPostCode return FALSE;

	BYTE szEndpoint = 1;

	TRANSFERDATA sockdata;
	int temp;
	
	MyAssert(gSock != INVALID_SOCKET, 2, "Invalid Socket");

	sockdata.size = sizeof(TRANSFER_RESET);	//set up the packet to send to slixbox
	sockdata.type = PID_RESET;

	temp = ssSend(gSock, &sockdata, sockdata.size);
/*	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return FALSE;
	} */

	MyAssert(temp > 0, 2, "SOCKET_ERROR during send()");

	if(isqueue) return 0;

	temp = recv(gSock, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(temp <= 0) {
		printf("recv failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}

	return sockdata.ret.ret;	//return the handshake packet from the device
}


typedef struct {
    int  status;
    char *name;
} STATUS_NAME1;

STATUS_NAME1 gStatusNames[] = 
{
    {ROOT1_STATUS_Success,              "Success"},
    {ROOT1_STATUS_Ack,                  "Ack"},
    {ROOT1_STATUS_Nak,                  "Nak"},
    {ROOT1_STATUS_Stall,                "Stall"},
    {ROOT1_STATUS_Ignore,               "Ignore"},
    {ROOT1_STATUS_DataCRCError,         "DataCRCError"},
    {ROOT1_STATUS_DataToggleError,      "DataToggleError"},
    {ROOT1_STATUS_SyncError,            "SyncError"},
    {ROOT1_STATUS_BabbleError,          "BabbleError"},
    {ROOT1_STATUS_PIDError,             "PIDError"},
    {ROOT1_STATUS_ShortPacketError,     "ShortPacketError"},
    {ROOT1_STATUS_ConfigurationError,   "ConfigurationError"},
    {STATUS_TransmissionError,			"TransmissionError"},
	{XSTATUS_UserError,					"UserError"},
    {0, NULL}
};
void CUSBProvider::InterpretStatus (BYTE nStatus, char *pszStatus, int size)
{
	int i=0;
    pszStatus[0] = 0;

    while (gStatusNames[i].name)
    {
        if (gStatusNames[i].status == nStatus)
        {
            strcpy(pszStatus, gStatusNames[i].name);
            break;
        }
        ++i;
    }
}


CUSBProvider::CUSBProvider() 
{
	Initialize(NULL);
}


/*************************************************************************************
Function:   CUSBProvider::Initialize
Purpose:	set up the winsock connection so we can talk with the Xbox running slixbox
Params:     pParent --- a pointer to CBSEIDEClient, that is currently unused
Return:     FALSE if it failed, non-FALSE if it worked
*************************************************************************************/
BOOL CUSBProvider::Initialize(void *pParent)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::Initialize"
#undef MyAssertPostCode
#define MyAssertPostCode return FALSE;

	if(gSock != INVALID_SOCKET) {
		ssCloseTCP(gSock, NULL, NULL);
	}
	
//	temp = DialogBox(NULL, MAKEINTRESOURCE(SLIX_GET_MACHINE_NAME), NULL, GetMachineNameProc);
//	if(temp == FALSE)
//		return FALSE;

	FILE* f = fopen("net.txt", "r");
	if(!f) {
		sprintf(gMachineName, "a-jasgoux2");
	} else {
		fscanf(f, "%s", gMachineName);
		fclose(f);
	}

	gSock = ssConnectTCP(gMachineName, "3331");
	MyAssert(gSock != INVALID_SOCKET, 3, "Couldn't connect to server");

	gInited = TRUE;
	return TRUE;
}


/*************************************************************************************
Function:   CUSBProvider::~CUSBProvider
Purpose:	deinitialize the winsock connection so we aren't left with an open port
Params:     (none)
Return:     (none)
*************************************************************************************/
CUSBProvider::~CUSBProvider(void)
{
	ssCloseTCP(gSock, NULL, NULL);
	gInited = FALSE;
}


BOOL CUSBProvider::BeginQueue(BOOL bSuccessOnNak)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::BeginQueue"
#undef MyAssertPostCode
#define MyAssertPostCode return FALSE;

	TRANSFERDATA sockdata;
	int temp;
	
	MyAssert(gSock != INVALID_SOCKET, 2, "Invalid Socket");

	CREATE_BEGIN_QUEUE(sockdata, bSuccessOnNak);

	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return FALSE;
	}
	MyAssert(temp > 0, 2, "SOCKET_ERROR during send()");
	isqueue = TRUE;
	return TRUE;
}

BYTE CUSBProvider::EndQueue(DWORD* CommandThatFailed)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::EndQueue"
#undef MyAssertPostCode
#define MyAssertPostCode return XSTATUS_TransmissionError;

	TRANSFERDATA sockdata;
	int temp;
	
	isqueue = FALSE;

	MyAssert(gSock != INVALID_SOCKET, 2, "Invalid Socket");
	MyAssert(CommandThatFailed, 3, "CommandThatFailed is NOT an optional paramater!");

	CREATE_INIT_END_QUEUE(sockdata);

	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return FALSE;
	}

//	MyAssert(temp > 0, 2, "SOCKET_ERROR during send()");


	temp = recv(gSock, (char*)&sockdata, sizeof(TRANSFER_RETURN_END_QUEUE), 0);	//receive some data back
	
	if(temp <= 0) {
		printf("recv failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}

	*CommandThatFailed = sockdata.retendqueue.linefailed;

	return sockdata.ret.ret;											//return status of the IN
}

	// IN should return STATUS_Success, or the appropriate error
/*************************************************************************************
Function:   CUSBProvider::IN
Purpose:	request an IN From slixbox, receive data, put it in pszData
Params:     [IN]  szAddress --- the USB address for slixbox to send the request
			[IN]  szEndpoint --- the USB endpoint for slixbox to send the request
			[OUT] pszData --- pointer to the buffer to receive data from the device
			[OUT] pDataSize --- pointer to receive the length of data received
Return:     STATUS_Success if it worked, or other STATUS_* for errors
*************************************************************************************/
BYTE CUSBProvider::In(BYTE szAddress, BYTE szEndpoint, BYTE szDataPID, int *iReturnDataPID, BYTE *pszData, int *pDataSize, BOOL *bToggleCorrect)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::IN"
#undef MyAssertPostCode
#define MyAssertPostCode return STATUS_TransmissionError;


	*bToggleCorrect = TRUE;

	TRANSFERDATA sockdata;		//network data buffer
	TRANSFERDATA sockdata2;
	int temp;
	int received = 0;			//data received so far
	int totaltoreceive = sizeof(TRANSFERDATA);	//max data to receive

	char buf[256] = {'\0'};

	MyAssert(gSock != INVALID_SOCKET, 3, "invalid socket");
	MyAssert(pszData != NULL, 3, "bad pointer to data buffer");
	MyAssert(pDataSize != NULL, 3, "bad pointer to data size buffer");
	MyAssert(*pDataSize != 0, 2, "expected data size == 0!");

//	for (i = 0; i < 10000; i++) {
	
		CREATE_ININIT(sockdata, szAddress, szEndpoint, *pDataSize);		//set up the request for an IN

	//measure("ssSend",
		temp = ssSend(gSock, &sockdata, sockdata.size); 
	//);

		MyAssert(temp > 0, 3, "send failed");
//		if(temp <= 0) {
//			printf("send failed, %d", WSAGetLastError());
//			return STATUS_TransmissionError;
//		}

//tryagain:
		if(isqueue) return 0;

		received = recv(gSock, (char*)&sockdata2, totaltoreceive - received, 0);	//receive some data back

		if(received <= 0) {
//			if(WSAGetLastError() == 0) continue;
			sprintf(buf, "recv failed, %d", WSAGetLastError());
			MessageBox(NULL, buf, buf, MB_OK);
		}
//		MyAssert(received >= 0, 3, "recv failed");
//		if(received < 0) {
//			printf("recv failed, %d...", WSAGetLastError());
//			return STATUS_TransmissionError;
//		}

		for(temp = 0; temp < received - (int)(sizeof(TRANSFER_IN)); temp++) {	//copy the received data into 
			pszData[temp] = sockdata2.in.data[temp];						//the supplied buffer
		}

		*pDataSize = received - sizeof(TRANSFER_IN);					//set the received data length

	//	sprintf(buf, "Incoming data length: %d, %016I64x", *pDataSize, *(INT64*)&pszData[0]);
	//	MessageBox(NULL, buf, "Incoming data!", MB_OK);

		if(sockdata2.in.ret == STATUS_DataToggleError) *bToggleCorrect = FALSE;
//	}

	return sockdata2.in.ret;											//return status of the IN
}

	// OUT and SETUP should return what happened (Ack, Nak, Stall, etc.)
/*************************************************************************************
Function:   CUSBProvider::OUT
Purpose:	send data to slixbox to send to device; receive handshake from device
Params:     [IN]  szAddress --- the USB address for slixbox to send the data
			[IN]  szEndpoint --- the USB endpoint for slixbox to send the data
			[IN]  szDataPid --- either PID_DATA0 or PID_DATA1
			[IN]  pszData --- pointer to the buffer that holds the data to be sent
			[IN]  iDataSize --- number of bytes of data in pszData
Return:     STATUS_Ack, STATUS_Nak, STATUS_Stall, or any other STATUS_*
*************************************************************************************/
BYTE CUSBProvider::Out(BYTE szAddress, BYTE szEndpoint, BYTE pid, BYTE *pszData, int iDataSize)
{  
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::OUT"
#undef MyAssertPostCode
#define MyAssertPostCode return STATUS_TransmissionError;

	BYTE szDataPid = 0;

	int sdcount = 0, i = 0;
	TRANSFERDATA sockdata;
	int temp;

	MyAssert(gSock != INVALID_SOCKET, 3, "Invalid Socket");
	MyAssert(iDataSize < 1024, 2, "Too much data to send");
	MyAssert(pszData != NULL, 3, "bad pointer to data buffer");

	//set up the data packet to send to slixbox
	CREATE_OUT(sockdata, szAddress, szEndpoint, szDataPid, pszData, iDataSize);

	//send the data to slixbox
	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}

	if(isqueue) return 0;

	//try to receive a handshake packet back...
	temp = recv(gSock, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(temp <= 0) {
		printf("recv failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}

	return sockdata.ret.ret;	//return the handshake packet from the device
}

/*************************************************************************************
Function:   CUSBProvider::SETUP
Purpose:	send SETUP data to slixbox to send to device; receive handshake from device
Params:     [IN]  szAddress --- the USB address for slixbox to send the data
			[IN]  szEndpoint --- the USB endpoint for slixbox to send the data
			[IN]  pszData --- pointer to the buffer that holds the data to be sent
			[IN]  iDataSize --- number of bytes of data in pszData
Return:     STATUS_Ack, STATUS_Nak, STATUS_Stall, or any other STATUS_*
Note:		for SETUP, DataPid is always 0 (Data0, instead of alternating to Data1)
*************************************************************************************/
BYTE CUSBProvider::Setup (BYTE szAddress, BYTE szEndpoint, BYTE *pszData, int iDataSize)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::SETUP"
#undef MyAssertPostCode
#define MyAssertPostCode return STATUS_TransmissionError;

	int sdcount = 0, i = 0;
	TRANSFERDATA sockdata;
	int temp;

	MyAssert(gSock != INVALID_SOCKET, 3, "Invalid Socket");
	MyAssert(iDataSize < 250, 2, "Too much data to send");
	MyAssert(pszData != NULL, 3, "bad pointer to data buffer");

	//set up the data packet to send to slixbox
	CREATE_SETUP(sockdata, szAddress, szEndpoint, pszData, iDataSize);

	//send the data to slixbox
	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}
	//MyAssert(temp > 0, 2, "Socket error during send");

	if(isqueue) return 0;

	//try to receive a handshake packet back...
	temp = recv(gSock, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(temp <= 0) {
		printf("recv failed, %d...", WSAGetLastError());
		return STATUS_TransmissionError;
	}

	MyAssert(temp > 0, 2, "0-byte receive");
	MyAssert(temp != SOCKET_ERROR, 2, "Socket error during receive");
	MyAssert(sockdata.size == sizeof(TRANSFER_RETURN), 2, "Not enough data received");
	MyAssert(sockdata.type == PID_RET, 2, "Return data type wasn't PID_RET!");

	return sockdata.ret.ret;	//return the handshake packet from the device
}

	
/*************************************************************************************
Function:   CUSBProvider::ClearDataToggle
Purpose:	send switch the expected data toggle to Data0
Params:     [IN]  szEndpoint --- the USB endpoint to expect Data0 from
Return:     none
*************************************************************************************/

BOOL CUSBProvider::ClearDataToggle(int szAddress, int szEndpoint)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::ClearDataToggle"
#undef MyAssertPostCode
#define MyAssertPostCode return FALSE;

	TRANSFERDATA sockdata;
	int temp;
	
	MyAssert(gSock != INVALID_SOCKET, 2, "Invalid Socket");

	sockdata.size = sizeof(TRANSFER_DATA_TOGGLE);	//set up the packet to send to slixbox
	sockdata.type = PID_DATA0;
	sockdata.toggle.endpoint = szEndpoint;

	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return FALSE;
	}
//	MyAssert(temp > 0, 2, "SOCKET_ERROR during send()");
	return TRUE;
}

/*************************************************************************************
Function:   CUSBProvider::SetDataToggle
Purpose:	send switch the expected data toggle to Data1
Params:     [IN]  szEndpoint --- the USB endpoint to expect Data1 from
Return:     none
*************************************************************************************/

BOOL CUSBProvider::SetDataToggle(int szEndpoint, int szAddress)
{
#undef MyAssertFunctionTitle
#define MyAssertFunctionTitle "CUSBProvider::SetDataToggle"
#undef MyAssertPostCode
#define MyAssertPostCode return FALSE;

	TRANSFERDATA sockdata;
	int temp;
	
	MyAssert(gSock != INVALID_SOCKET, 2, "Invalid Socket");

	sockdata.size = sizeof(TRANSFER_DATA_TOGGLE);	//set up the packet to send to slixbox
	sockdata.type = PID_DATA1;
	sockdata.toggle.endpoint = szEndpoint;

	temp = ssSend(gSock, &sockdata, sockdata.size);
	if(temp <= 0) {
		printf("send failed, %d...", WSAGetLastError());
		return FALSE;
	}
//	MyAssert(temp > 0, 2, "SOCKET_ERROR during send()");
	return TRUE;
}


/*************************************************************************************
Function:   GetMachineNameProc
Purpose:	dialog proc to get user input for the name of the server computer
Params:     standard dialog proc params...
Return:     FALSE if DialogBox() needs to do stuff after calling this, TRUE otherwise
*************************************************************************************/
BOOL CALLBACK GetMachineNameProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

	sprintf(gMachineName, "a-jasgoutst");
	EndDialog(hDlg, TRUE);
	return TRUE;
/*/
	switch (message)
	{
	case WM_INITDIALOG:
		SetFocus(GetDlgItem(hDlg, SLIX_EDIT));			//the edit box, so the user can type
		return FALSE;
	case WM_COMMAND:
		if(LOWORD(wParam) == SLIX_OK) {					//if they pressed "OK"
			GetDlgItemText(hDlg, SLIX_EDIT, gMachineName, 127);	//get the machine name
			EndDialog(hDlg, TRUE);						//and quit
			return TRUE;
		} else if(LOWORD(wParam) == SLIX_CANCEL) {		//if they pressed "Cancel"
			EndDialog(hDlg, FALSE);						//don't get the machine name ... quit ...
			return TRUE;
		}
		return FALSE;
	}
	return FALSE;
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixbox\slixboxsock.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixboxsock.cpp

Abstract:

    winsock routines used on SliXbox

Author:

    Jason Gould (a-jasgou) June 2000

--*/

#include "slixboxsock.h"


SOCKET ggSock;

HANDLE			gDoRead			= INVALID_HANDLE_VALUE;
HANDLE			gHasRead		= INVALID_HANDLE_VALUE;
HANDLE			gDoQuit			= INVALID_HANDLE_VALUE;
HANDLE			gReadThread 	= INVALID_HANDLE_VALUE;
int				gToRecv			= 0;
SOCKET			gReadSock		= INVALID_SOCKET;
char			gReadData[256];
DWORD WINAPI ReadThread(LPVOID pParam);


SOCKET ssInitServer()
{
	SOCKET sock;
    XNetStartupParams  XNetParams;
	WSADATA wsadata;
	sockaddr_in name;

	DebugPrint("XNetStartup()\n");
    ZeroMemory(&XNetParams, sizeof(XNetParams));
    XNetParams.cfgSizeOfStruct = sizeof(XNetParams);
    XNetParams.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	XNetStartup(&XNetParams);
	DebugPrint("WSAStartup(2, ..)\n");
	WSAStartup(2, &wsadata);

	DebugPrint("Getting socket()\n");
	ggSock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if(ggSock == INVALID_SOCKET) {
		DebugPrint("ggSock == INVALID_SOCKET), %d\n", WSAGetLastError());
		return 1;
	}

    name.sin_family = AF_INET;
    name.sin_port = 53331;
    name.sin_addr.s_addr = htonl(INADDR_ANY); // (u_long) 0; //(u_long)0x9D370D57?

	DebugPrint("bind()\n");
    if(SOCKET_ERROR == bind(ggSock, (LPSOCKADDR)&name, sizeof(SOCKADDR))) {
		DebugPrint("bind returned SOCKET_ERROR, %d\n", WSAGetLastError());
		return 2;
	}

ListenLine:
	DebugPrint("listen()\n");
	if (SOCKET_ERROR == listen(ggSock, 1)) {
		DebugPrint("listen returned SOCKET_ERROR, %d\n", WSAGetLastError());
		goto ListenLine;
		return 3;
	}

	DebugPrint("accept()\n");
	sock = accept(ggSock, NULL, NULL);
	if(sock == INVALID_SOCKET) {
		DebugPrint("gSock == INVALID_SOCKET, %d\n", WSAGetLastError());
		return 4;
	}

/*	DebugPrint("ReadThread()\n");
	DWORD ThreadID;
	gDoRead  = CreateEvent(NULL, TRUE, FALSE, NULL);
    gHasRead = CreateEvent(NULL, TRUE, FALSE, NULL);
	gDoQuit  = CreateEvent(NULL, TRUE, FALSE, NULL);
	gReadThread   = CreateThread(NULL, 0, ReadThread, NULL, 0, &ThreadID);
*/
	return sock;
}

/*
int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend)
{
	tosend = sockdata->size;
	int sent = 0;
	int temp;
	while(sent < tosend) {
		temp = send(hsock, &(sockdata->all[sent]), tosend - sent, 0);
		if(temp == SOCKET_ERROR || temp <= 0) {
			DebugPrint("send error: %d\n", WSAGetLastError());
			return 0;
		}
		sent += temp;
	}
	return sent;
}
*/

/*
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int len)
{
	int ret;
	int bytesdone = 0;

	shutdown(hsock, 1);
	ret = 1;
	if(inbuf) {
		if(SOCKET_ERROR == recv(hsock, (char*)inbuf, len, 0)) {
			DebugPrint("recv error: %d\n", WSAGetLastError());
		}
	}
	
	SetEvent(gDoQuit);
//	if(WaitForSingleObject(gHasRead, 100))
//		TerminateThread(gReadThread, 1);

	ret = closesocket(hsock);

	WSACleanup();
	XnetCleanup();	
	return ret;
}
*/

/*
int ssRecv(SOCKET hsock, TRANSFERDATA  * sockdata, int maxrecv, int timeout)
{
	int received = 0;
	gToRecv = maxrecv;
	gReadSock = hsock;
	SetEvent(gDoRead);
	ResetEvent(gHasRead);
	if(WAIT_OBJECT_0 == WaitForSingleObject(gHasRead, timeout)) {
		memcpy((void*)sockdata, (void*)gReadData, sizeof(sockdata));
		return sockdata->size;
	}
	return 0;
}
*/
/*
DWORD WINAPI ReadThread(LPVOID pParam)
{
	int received = 0;
	int temp;
	int torecv;
	SOCKET hsock;
	
	HANDLE events[] = {gDoRead, gDoQuit, gHasRead};

	while(1) {
//		temp = WaitForMultipleObjects(2, events, FALSE, INFINITE);
//		if(WAIT_OBJECT_0 + 1 == temp) { //if we're supposed to quit...
//			SetEvent(gHasRead);
//			break;	//quit
//		}
//		DebugPrint("gDoRead received.\n");
//		ResetEvent(gDoRead);
		memset(gReadData, 0, sizeof(gReadData));

		torecv = gToRecv;
		hsock = gReadSock;

		received = 0;
		do {
			temp = recv(hsock, &gReadData[received], torecv - received, 0);
			DebugPrint("recv() returned %d!", temp);
			torecv = gReadData[0];
			if(temp == 0 || temp == SOCKET_ERROR) {
				listen(hsock, 1);
				accept(hsock, NULL, NULL);
			}
			received += temp;
		} while (received < torecv);
		SetEvent(gHasRead);
	}
	return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixbox\slixbox.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixbox.h

Abstract:

    main header file for slixbox

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#ifndef __slixbox_h_
#define __slixbox_h_

#define NODSOUND //prevent some weird build break
#include <xtl.h>

#include <winsockx.h>
#include <stdio.h>
#include <time.h>			
//#include "xinput.h"      //Mitch's input (control pad, etc) routines
//#include "dxconio.h"    //Matt's text routines
//#include "tsc.h"

#include "slixtransfer.h"

#include "slixboxsock.h"



//#include "usbd.h"

#ifdef __cplusplus
extern "C" {
#endif
	ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer
	int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow);
#ifdef __cplusplus
}
#endif

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)


//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixbox\slixboxsock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixboxsock.cpp

Abstract:

    declares networking functions for slixbox to communicate with slix2k

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#ifndef __slixboxsock_h_
#define __slixboxsock_h_

#define NODSOUND
#include <xtl.h>
#include "slixtransfer.h" 

#ifdef __cplusplus
extern "C" {
#include <winsockx.h>
#endif
	ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer
    DWORD WINAPI TestMain();              //our entry-point
	int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow);
#ifdef __cplusplus
}
#endif

//int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend);
//int ssRecv(SOCKET hsock, TRANSFERDATA  * sockdata, int maxrecv, int timeout = RECV_TIMEOUT);
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int len);
SOCKET ssInitServer();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixd\i_slixdriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i_slixdriver.h

Abstract:

    internal header for the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __i_slixdriver_h_
#define __i_slixdriver_h_


//*****************************************************************************
//**  Defines  ****************************************************************
//*****************************************************************************



#define SLIX_DRIVER_EXTENSION_ID 0
#define MAX_PORTS 8					    //max num of ports on the xbox (currently 5)
#define MAX_SLOTS 4						//max num of slots on a duke, plus 1 (currently 3)
#define BACK_PORT 0xf					//the number corresponding to the back-port of the xbox 
#define MAX_ENDPOINTS 32                                                                                        //changed by Bing
#define SLIX_MAX_BULK_PACKET_SIZE    0x40	//max bytes that can be transfered in a packet


// PDEVICE_EXTENSION->DeviceFlags state flags
//
//#define DF_MRB_IN_PROGRESS          0x00000002
//#define DF_PERSISTENT_ERROR         0x00000004
//#define DF_RESET_IN_PROGRESS        0x00000008
//#define DF_DEVICE_DISCONNECTED      0x00000010
#define DF_CONNECTED   0x0001
#define DF_INITIALIZED 0x0002


#define INCREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedIncrement((PLONG)&((deviceExtension)->PendingIoCount))

#define DECREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedDecrement((PLONG)&((deviceExtension)->PendingIoCount))

typedef unsigned char BYTE;	
typedef unsigned long DWORD;

typedef struct _DEVICE_EXTENSION
{
    // device class interface to USB core stack
    IUsbDevice                      *Device;
	VOID*							Endpoints[MAX_ENDPOINTS];                                                                 //changed by Bing
	UCHAR							EndpointType[MAX_ENDPOINTS];                                                              //changed by Bing

	DWORD flags;

/*
    KDPC                            TimeoutDpcObject;
    KTIMER                          MrbTimer;
*/
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct SLIX_DRIVER_EXTENSION {				//driver extension, holds all relevant data
//    USB_PNP_CLASS_DRIVER_DESCRIPTION ClassDescriptionList[16];	//basically unused except in DriverInit
    DEVICE_EXTENSION Nodes[MAX_PORTS][MAX_SLOTS]; //[port][slot]		//pointers to the deviceObjects of each possible device
	BYTE LastAddress;								//last device referenced in IN, OUT, or SETUP
}  SLIX_DRIVER_EXTENSION, *PSLIX_DRIVER_EXTENSION;

extern SLIX_DRIVER_EXTENSION * gDriverExtension;	//pointer to the driver extension is global...

#if DBG || DEBUG_LOG

extern ULONG               DebugFlags;     // DBGF_* Flags
extern ULONG               DebugLevel;     // Level of debug output

#define DBGPRINT(level, _x_) \
    if (level <= DebugLevel) { \
        KdPrint(("SlixD: ")); \
        KdPrint( _x_ ); \
    }


#else

#define DBGPRINT(level, _x_)

#endif



/*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************


NTSTATUS SLIX_Create (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS SLIX_Close (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);


NTSTATUS SLIX_DeviceControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID SLIX_StartIo (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//VOID SLIX_TimeoutDpc (IN PKDPC Dpc, IN PVOID Context, IN PVOID SysArg1, IN PVOID SysArg2);



typedef struct _REQUEST {
	BYTE* pData;
	int MaxData;
	
} REQUEST, *PREQUEST;
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixd\islixd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/


extern "C" {
#include <nt.h>
#include <ntos.h>
}

#include <xtl.h>

#include <stdio.h>
#include <usb.h>
#include "slixdriver.h"
#include "i_slixdriver.h"

//#include "slixdriver.cpp"
//extern void SLIX_RemoveDevice (IN IUsbDevice *Device);


///////////////////////#define _WAIT (733000 * 1000 * 30)  //50 milliseconds
#define _TICKS_PER_MILLISECOND 733000I64
const __int64 _WAIT = (_TICKS_PER_MILLISECOND * 1000 * 40);

#define PORT_FROM_ADDRESS(a) ((a) & 0x0f)
#define SLOT_FROM_ADDRESS(a) (((a) >> 4) & 0x7)

#define ENDPOINT_TYPE(e) ((e >> 4) & 3)
#define ENDPOINT_DIRECTION(e) (e & 0x80)

#define ENDPOINT_NUM(e) (ENDPOINT_DIRECTION(e)?(e & 15):((e & 15)+16))                                                  //changed by Bing from 15 to 31

#define ENDPOINT_NUM_DIRECTION(e) (e & 0x8f)


typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

volatile int gYouMayPass = 0;

#pragma warning(disable:4035) 
//disable "no return". rdtsc changes edx:eax, which is where __int64 is returned.
//this incriments roughly 733000000 times/second.
//733000 = 1 millisecond, etc.
__int64 __inline gettsc() {_asm {rdtsc} }	
#pragma warning(default:4035)




VOID CompleteProc (PURB urb, PVOID con)
{
 	gYouMayPass = ~urb->Header.Status;	//encoding it for the moment...
}

VOID IsochCompleteProc (USBD_ISOCH_TRANSFER_STATUS* puits, PVOID con)
{
 	gYouMayPass = ~puits->Status;	//encoding it for the moment...
}


//#define USB_ENDPOINT_TYPE_CONTROL                 0x00
//#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
//#define USB_ENDPOINT_TYPE_BULK                    0x02
//#define USB_ENDPOINT_TYPE_INTERRUPT               0x03
HANDLE GetEndpoint(IUsbDevice * pud, BYTE endpoint)
{
	URB urb;
	int temp;
	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

	if((0 == ENDPOINT_NUM(endpoint)) || (16==ENDPOINT_NUM(endpoint)) ) {	//default (control) endpoint
		if(Endpoints[0] != (void*)-1) {	//if it's been opened already
			return Endpoints[0];		//return it...
		}

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
		pud->SubmitRequest(&urb);
		Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
		return NULL;

	} else {	//normal endpoint

		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

			//if it's not already opened...
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));

			}

			return Endpoints[ENDPOINT_NUM(endpoint)];

		} else { //not isoch
			if(Endpoints[ENDPOINT_NUM(endpoint)] != (void*) -1 && Endpoints[ENDPOINT_NUM(endpoint)] != NULL) {
				return Endpoints[ENDPOINT_NUM(endpoint)];
			}

			RtlZeroMemory(&urb,sizeof(URB));

			USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
			pud->SubmitRequest(&urb);
			Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
			return urb.OpenEndpoint.EndpointHandle;
		}

	}
}



 

 


//callback for endpoint closes (below) to allow them to be asynchronous
//but I don't think this is a callback function, it just a stub, may useless called by IUsbDevice class.
//VOID arf (PURB urb, PVOID context)
//{ }

 

void CloseEndpoint(IUsbDevice * pud, BYTE endpoint, HANDLE eh)
{
//	URB urb;
//	int temp;
//	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

//
//	if(0 == ENDPOINT_NUM(endpoint)) {	//default (control) endpoint
//		if(Endpoints[0] == (void*)-1) {	//if it's been closed already
//			return; //Endpoints[0];		//return it...
//		} else {

		//RtlZeroMemory(&urb,sizeof(URB));
//		USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&urb.CloseEndpoint, arf,0);

		//USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
//		pud->SubmitRequest(&urb);
		//Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
//		return;// NULL;
//		}

//	} else {//normal endpoint
//		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

			//if it's not already opened...

			/* we will consider this later on
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));
            
			}
			*/

//			return; //Endpoints[ENDPOINT_NUM(endpoint)];

//		} else { //not isoch
//			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				//already closed
//				return; //Endpoints[ENDPOINT_NUM(endpoint)];
//			} else {
			//RtlZeroMemory(&urb,sizeof(URB));

			//USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
			
			
//            USB_BUILD_CLOSE_ENDPOINT(&urb.CloseEndpoint,Endpoints[ENDPOINT_NUM(endpoint)] , arf,0);
//			pud->SubmitRequest(&urb);
			//Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
//			return; // urb.OpenEndpoint.EndpointHandle;
//			}
//		}

//	}

	//intiliaze it again
  // Endpoints[ENDPOINT_NUM(endpoint)]=(void *) -1;
  //((PDEVICE_EXTENSION)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] = 0;



}


/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE Address, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len)
{	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG templen = 8;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	BYTE closeendpoint = Endpoint;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles
	de = &gDriverExtension->Nodes[port][slot];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		DBGPRINT(2,("SlixdIn: Port %d, Slot %d, pud==NULL\n", port, slot));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	if(!(de->flags & DF_CONNECTED)){
		DBGPRINT(2,("SlixdIn: de->DeviceFlags & DF_CONNECTED"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}
	
	if(data == NULL) {
		if(len != NULL) *len = 0;
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3, ("ERROR! Can't send additional INs to endpoint 0\n"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	Endpoint |= 0x80;

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		DBGPRINT(3, ("ourendpoint == NULL && Endpoint != 0\n"));
		if(len) *len = 0;
		return USBD_STATUS_ERROR;
	} 

	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)*len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = _WAIT;	//3.1 milliseconds

	} else {	//non-isoch
		*len = (*len + 63) & ~63;	//round up to the nearest 64 bytes so we don't get buffer overflows
	
		if(!*len) {	//len == 0
			DBGPRINT(3, ("*len == 0!!!\n"));
			*len = 64;
		}
	
		templen = *len;
	
		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, templen, USB_TRANSFER_DIRECTION_IN, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = _WAIT;	//roughly 3 milliseconds
		//(if a 64-byte packet comes back, ohci requests another one until our buffer is full)
	}
	gYouMayPass = 0;

	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for request to come back

	if((gettsc() - tim) > maxwaittime) {	//if we timed out
		pud->CancelRequest(&urb);			//cancel request
		while(!gYouMayPass) { }				//and wait for the thing to cancel
	}

	//we got a response!
	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n"
				"returned data size: %d, first 8 bytes = %016I64x\n", 
				retcode, urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { 
		//*len = *len //hope that we really got that much data back
	} else {
		*len = (USHORT)urb.BulkOrInterruptTransfer.TransferBufferLength;
	}

	//CloseEndpoint(pud, Endpoint, ourendpoint);
	CloseEndpoint(pud, closeendpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles
	de = &gDriverExtension->Nodes[port][slot];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3,("ERROR! Can't send additional OUTs to endpoint 0\n"));
//		*len = 0;
		return USBD_STATUS_ERROR;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);
	
	if(data == NULL) {
		if(len != 0) {
			return USBD_STATUS_ERROR;	//trying to send data that doesn't exist??
		}
	}

	//if(ourendpoint == NULL && Endpoint != 0) {
	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {                                           //changed by Bing from above line to this, this should be the same as SlixDIN().
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}


	if(ENDPOINT_TYPE(Endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = _WAIT;	//3.1 milliseconds

	} else {	//non-isoch

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, len, USB_TRANSFER_DIRECTION_OUT, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = _WAIT;		//wait 3 milliseconds

	}
	gYouMayPass = 0;



	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }	//wait to time out, or for response

	if((gettsc() - tim) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	CloseEndpoint(pud, Endpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received. Not optional.
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _IN _OUT USHORT *len2)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	USHORT extlen;
	BYTE direction;
	int port, slot;
	__int64 maxwaittime;

	port = PORT_FROM_ADDRESS(Address);
	slot = SLOT_FROM_ADDRESS(Address);

	gDriverExtension->LastAddress = Address;	//so that we don't have to guess when we do SetDataToggles
	de = &gDriverExtension->Nodes[port][slot];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(data == NULL) {
		DBGPRINT(1, ("data == NULL"));
		return USBD_STATUS_ERROR;
	} else if(len != 8) {
		DBGPRINT(1, ("Setup packets should be 8 bytes! len = %d, data = %016I64x, len2 = %d", len, *(INT64*)data, *len2));
		return USBD_STATUS_ERROR;
	} 

	extlen = (*(USHORT*)&data[6]); //get the length of the data to send/recv
	if(!len2) {
		DBGPRINT(1, ("Setup: len2 is NOT optional!"));
		return USBD_STATUS_ERROR;
	} else if(*len2 < extlen) {
		DBGPRINT(1, ("sending data without enough buffer length?? len2: %d, extlen: %d", *len2, extlen));
		return USBD_STATUS_ERROR;
	}

	if(*len2 > 2048) *len2 = 2048;	//can't send or expect too much data, due to ohci requrements

	if(*len2 > 0) {
		if(data2 == NULL) {
			DBGPRINT(1, ("data2 == NULL"));
			return USBD_STATUS_ERROR;
		}

		direction = (data[0] & 128) ? USB_TRANSFER_DIRECTION_IN : USB_TRANSFER_DIRECTION_OUT;
	} else {
		direction = 0;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && Endpoint != 0) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}
	
	RtlZeroMemory(&urb,sizeof(URB));
	USB_BUILD_CONTROL_TRANSFER(&urb.ControlTransfer,
		ourendpoint, data2, *len2, direction,		////////////////////data2
		CompleteProc, (void*)pud, TRUE,
		data[0], data[1], (*(USHORT*)&data[2]), (*(USHORT*)&data[4]), (*(USHORT*)&data[6]) );


	gYouMayPass = 0;
	__int64 tim = gettsc();
	retcode = pud->SubmitRequest(&urb);

    maxwaittime = _WAIT;        //wait 3 milliseconds
	
    while(!gYouMayPass && (gettsc() - tim) < maxwaittime) { }               //wait for 3 milliseconds, or for the response.

	if((gettsc() - tim) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}


	*len2 = (USHORT)urb.ControlTransfer.TransferBufferLength;

	CloseEndpoint(pud, Endpoint, ourendpoint);
	return retcode;
}

/*************************************************************************************
Function:   SlixdData0
Purpose:	set the expected data toggle for the specified endpoint to Data0
Params:     in Endpoint --- the endpoint to start expecting Data0 from
Return:     none
*************************************************************************************/
VOID SlixdData0(BYTE Endpoint)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	BYTE Address;
	HANDLE ourendpoint;

	Address = gDriverExtension->LastAddress;
	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;
	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);//de->endpoint[Endpoint];
	if(ourendpoint == NULL && Endpoint != 0) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return;
	}

	USB_BUILD_SET_ENDPOINT_STATE((&urb.GetSetEndpointState), 
		ourendpoint, USB_ENDPOINT_STATE_DATA_TOGGLE_RESET);
	pud->SubmitRequest(&urb);
	CloseEndpoint(pud, Endpoint, ourendpoint);
}

/*************************************************************************************
Function:   SlixdData1
Purpose:	set the expected data toggle for the specified endpoint to Data1
Params:     in Endpoint --- the endpoint to start expecting Data1 from
Return:     none
*************************************************************************************/
VOID SlixdData1(BYTE Endpoint)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	BYTE Address;
	HANDLE ourendpoint;

	Address = gDriverExtension->LastAddress;
	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;
	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);//de->endpoint[Endpoint];

	USB_BUILD_SET_ENDPOINT_STATE((&urb.GetSetEndpointState), 
		ourendpoint, USB_ENDPOINT_STATE_DATA_TOGGLE_SET);
	pud->SubmitRequest(&urb);
	CloseEndpoint(pud, Endpoint, ourendpoint);
}

/*************************************************************************************
Function:   SlixdReset
Purpose:	reset the last-used device
Params:     due to sli requriements, no params... :o(
Return:     error if last device used doesn't exist
*************************************************************************************/
USBD_STATUS SlixdReset()
{
	DEVICE_EXTENSION * de;
	IUsbDevice * pud;
	BYTE Address;
	KIRQL kirql;

	Address = gDriverExtension->LastAddress;
	if(SLOT_FROM_ADDRESS(Address) > 0x7) Address = 0;
	de = &gDriverExtension->Nodes[PORT_FROM_ADDRESS(Address)][SLOT_FROM_ADDRESS(Address)];
	pud = de->Device;

	if (pud == NULL) { //device isn't connected
		return USBD_STATUS_ERROR;
	}

    kirql = KeRaiseIrqlToDpcLevel();
		pud->DeviceNotResponding();
    KeLowerIrql(kirql);
	
	return USBD_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixbox\slixtransfer.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixtransfer.h

Abstract:

    a shared header for slixbox and slix2k, including networking protocols

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#ifndef __slixtransfer_h_
#define __slixtransfer_h_

#define __TRANSFER_BASE struct{unsigned long size; BYTE type;} 

typedef __TRANSFER_BASE TRANSFER_BASE;					//base structure for all sends

#pragma warning(push)
#pragma warning(disable:4200)	//since we're using 0-length arrays... kill the warning

typedef struct : TRANSFER_BASE{	//box->2k IN data
	BYTE ret;
	char data[0];	
} TRANSFER_IN;					

typedef struct : TRANSFER_BASE{ //2k->box OUT data
	BYTE address;
	BYTE endpoint;
	BYTE dataPid;
	char data[0];
} TRANSFER_OUT;

typedef struct : TRANSFER_BASE{	//2k->box SETUP data
	BYTE address;
	BYTE endpoint;
	char data[0];
} TRANSFER_SETUP;

typedef struct : TRANSFER_BASE{	//2k->box DataToggle messages
	BYTE endpoint;
} TRANSFER_DATA_TOGGLE;

typedef struct : TRANSFER_BASE{	//box->2k result of OUT or SETUP
	BYTE ret;
} TRANSFER_RETURN;

typedef struct : TRANSFER_BASE{	//2k->box request for IN
	BYTE address;
	BYTE endpoint;
	DWORD max;
} TRANSFER_INIT_IN;

typedef struct : TRANSFER_RETURN{
	DWORD linefailed;
} TRANSFER_RETURN_END_QUEUE;

typedef struct : TRANSFER_BASE{
	BYTE successonnak;
} TRANSFER_BEGIN_QUEUE;

typedef struct : TRANSFER_BASE{
} TRANSFER_INIT_END_QUEUE;

typedef struct : TRANSFER_BASE{
} TRANSFER_RESET;

#pragma warning(pop)

typedef union ussTransferData{	//all possible data & transfer types
	__TRANSFER_BASE;
	TRANSFER_INIT_IN initin;
	TRANSFER_IN in;
	TRANSFER_OUT out;
	TRANSFER_SETUP setup;
	TRANSFER_DATA_TOGGLE toggle;
	TRANSFER_RETURN ret;
	TRANSFER_RESET reset;
	TRANSFER_RETURN_END_QUEUE retendqueue;
	TRANSFER_INIT_END_QUEUE initendqueue;
	TRANSFER_BEGIN_QUEUE beginqueue;
	char all[1032];
} TRANSFERDATA, *pTRANSFERDATA;

#define RECV_TIMEOUT				10000

#define PID_OUT                    0x01
#define PID_IN                     0x69
#define PID_SETUP                  0x2D
#define PID_DATA0			       0xC3
#define PID_DATA1			       0x4B

//these aren't PID codes, but they are being used in the same way, in my code, 
//as the 5 codes above. They are just arbitrary numbers...
#define PID_RET					   0xDA	
#define PID_INIT_IN				   0xDB 
#define PID_RESET				   0xDC
#define PID_BEGIN_QUEUE			   0xDD
#define PID_INIT_END_QUEUE		   0xDE
#define PID_RETURN_END_QUEUE	   0xDF

const BYTE XSTATUS_Success            = 0x00;
const BYTE XSTATUS_Ack                = 0x02;
const BYTE XSTATUS_Nak                = 0x0A;
const BYTE XSTATUS_Stall              = 0x0E;
const BYTE XSTATUS_Ignore             = 0x80;
const BYTE XSTATUS_DataCRCError       = 0x81;
const BYTE XSTATUS_DataToggleError    = 0x82;
const BYTE XSTATUS_SyncError          = 0x83;
const BYTE XSTATUS_BabbleError        = 0x84;
const BYTE XSTATUS_PIDError           = 0x85;
const BYTE XSTATUS_ShortPacketError   = 0x86;
const BYTE XSTATUS_ConfigurationError = 0x87;
const BYTE XSTATUS_TransmissionError  = 0x92;	//this is new, as of 6/21/2000
const BYTE XSTATUS_UserError          = 0x95;	//new, as of 8-28-2000


//Macro to fill in a TRANSFER_IN_INIT packet to send from Slix2k to Slixbox
#define CREATE_BEGIN_QUEUE(_sockdata, _SuccessOnNak)					\
	_sockdata.size = sizeof(TRANSFER_BEGIN_QUEUE);		\
	_sockdata.type = PID_BEGIN_QUEUE;					\
	_sockdata.beginqueue.successonnak = (BYTE)_SuccessOnNak;

#define CREATE_INIT_END_QUEUE(_sockdata)					\
	_sockdata.size = sizeof(TRANSFER_INIT_END_QUEUE);	\
	_sockdata.type = PID_INIT_END_QUEUE;				

#define CREATE_ININIT(_sockdata, _address, _endpoint, _maxsize)	\
	_sockdata.size = sizeof(TRANSFER_INIT_IN);			\
	_sockdata.type = PID_INIT_IN;						\
	_sockdata.initin.address = _address;				\
	_sockdata.initin.max = _maxsize;					\
	_sockdata.initin.endpoint = _endpoint;

//Macro to fill in a TRANSFER_OUT packet to send from Slix2k to Slixbox
#define CREATE_OUT(_sockdata, _address, _endpoint, _pid, _data, _size)	\
	_sockdata.size = sizeof(TRANSFER_OUT) + _size;						\
	_sockdata.type = PID_OUT;											\
	_sockdata.out.address = _address;									\
	_sockdata.out.endpoint = _endpoint;									\
	_sockdata.out.dataPid = _pid;										\
	{int _arf; for(_arf = 0; _arf < _size; _arf++) sockdata.out.data[_arf] = _data[_arf];}	

//Macro to fill in a TRANSFER_SETUP packet to send from Slix2k to Slixbox
#define CREATE_SETUP(_sockdata, _address, _endpoint, _data, _size)		\
	_sockdata.size = sizeof(TRANSFER_SETUP) + _size;					\
	_sockdata.type = PID_SETUP;											\
	_sockdata.setup.address = _address;									\
	_sockdata.setup.endpoint = _endpoint;								\
	{int _arf; for(_arf = 0; _arf < _size; _arf++) sockdata.setup.data[_arf] = _data[_arf]; }

//#include "\MyAssert.h"	//definition of MyAssert, & its support features

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stressmon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixd\slixdriver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/

extern "C" {
#include <nt.h>
#include <ntos.h>
}


#include <scsi.h>
//#include <ntdddisk.h>

#include <xtl.h>

#include <usb.h>
#include <stdio.h>

#include "i_slixdriver.h"

ULONG               DebugFlags;     // DBGF_* Flags
ULONG               DebugLevel=5;     // Level of debug output
SLIX_DRIVER_EXTENSION gde = {{0},0};
PSLIX_DRIVER_EXTENSION gDriverExtension = &gde;

//the following mess allows slix to grab & talk to all devices
#define SLIX1_Init DriverInit
#define SLIX2_Init DriverInit
#define SLIX3_Init DriverInit
#define SLIX4_Init DriverInit
#define SLIX5_Init DriverInit
#define SLIX6_Init DriverInit
#define SLIX7_Init DriverInit
#define SLIX8_Init DriverInit
#define SLIX9_Init DriverInit
#define SLIX10_Init DriverInit



#define SLIX1_AddDevice SLIX_AddDevice
#define SLIX2_AddDevice SLIX_AddDevice
#define SLIX3_AddDevice SLIX_AddDevice
#define SLIX4_AddDevice SLIX_AddDevice
#define SLIX5_AddDevice SLIX_AddDevice
#define SLIX6_AddDevice SLIX_AddDevice
#define SLIX7_AddDevice SLIX_AddDevice
#define SLIX8_AddDevice SLIX_AddDevice
#define SLIX9_AddDevice SLIX_AddDevice
#define SLIX10_AddDevice SLIX_AddDevice

#define SLIX1_RemoveDevice SLIX_RemoveDevice
#define SLIX2_RemoveDevice SLIX_RemoveDevice
#define SLIX3_RemoveDevice SLIX_RemoveDevice
#define SLIX4_RemoveDevice SLIX_RemoveDevice
#define SLIX5_RemoveDevice SLIX_RemoveDevice
#define SLIX6_RemoveDevice SLIX_RemoveDevice
#define SLIX7_RemoveDevice SLIX_RemoveDevice
#define SLIX8_RemoveDevice SLIX_RemoveDevice
#define SLIX9_RemoveDevice SLIX_RemoveDevice
#define SLIX10_RemoveDevice SLIX_RemoveDevice


#define SLIXDEVICEPORT  (&SLIXDEVICEPORT_TABLE)
#define SLIXDEVICESLOT  (&SLIXDEVICESLOT_TABLE)
DECLARE_XPP_TYPE(SLIXDEVICEPORT)
DECLARE_XPP_TYPE(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX1_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX2_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX3_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX4_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX5_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX6_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX7_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX8_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX9_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX10_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
#define XBOX_DEVICE_CLASS_INPUT_DEVICE 0x58
#define XBOX_DEVICE_CLASS_XHAWK_DEVICE 0x78
USB_CLASS_DRIVER_DECLARATION(SLIX1_, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX1_, 1, XBOX_DEVICE_CLASS_XHAWK_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX2_, USB_DEVICE_CLASS_COMMUNICATIONS, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX3_, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX3_, 1, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX4_, USB_DEVICE_CLASS_MONITOR, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX5_, USB_DEVICE_CLASS_PHYSICAL_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX6_, USB_DEVICE_CLASS_POWER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX7_, USB_DEVICE_CLASS_PRINTER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX8_, USB_DEVICE_CLASS_STORAGE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX9_, USB_DEVICE_CLASS_RESERVED, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX10_, USB_DEVICE_CLASS_VENDOR_SPECIFIC, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassAAASLIX") //ohci should load this before anything else
USB_CLASS_DECLARATION_POINTER(SLIX1_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX1_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX2_)
USB_CLASS_DECLARATION_POINTER(SLIX3_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX3_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX4_)
USB_CLASS_DECLARATION_POINTER(SLIX5_)
USB_CLASS_DECLARATION_POINTER(SLIX6_)
USB_CLASS_DECLARATION_POINTER(SLIX7_)
USB_CLASS_DECLARATION_POINTER(SLIX8_)
USB_CLASS_DECLARATION_POINTER(SLIX9_)
USB_CLASS_DECLARATION_POINTER(SLIX10_)
#pragma data_seg()


//apis we are replacing by over-writing xid.sys... xapi is still looking for these!
/*
extern "C" void XInputClose(int){}
extern "C" void XInputGetCapabilities(int,int){}
extern "C" void XInputGetState(int,int){}
extern "C" void XInputOpen(int,int,int,int){}
extern "C" void XInputPoll(int){}
extern "C" void XInputSetState(int,int){}
*/

URB CloseUrb[MAX_ENDPOINTS];                                                                                              //changed by Bing from 16 to 32
URB StopUrb[MAX_ENDPOINTS];
static int gInstance;

/*************************************************************************************
Function:   DriverInit
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
void
DriverInit (IUsbInit *pUsbInit)
{
    DBGPRINT(2, ("enter:  DriverInit\n"));    
    ULONG port, slot;
    UCHAR realMaxPorts = (UCHAR)XGetPortCount();

    for (port = 0;port < MAX_PORTS; port++) {
		for (slot = 0; slot < MAX_SLOTS; slot++) {
			gDriverExtension->Nodes[port][slot].Device = NULL;
		}
    }
    gInstance = 0;
    //
    //  Allocate a whole bunch of resources, we don't
    //  care that much how much memory we take, and
    //  we don't want to run out.
    //
    USB_RESOURCE_REQUIREMENTS resourceRequirements;
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_DIRECT;
    resourceRequirements.MaxDevices = realMaxPorts;
    resourceRequirements.MaxCompositeInterfaces = 3;
    resourceRequirements.MaxControlEndpoints = 2;
    resourceRequirements.MaxBulkEndpoints = 2;
    resourceRequirements.MaxInterruptEndpoints = 2;    
    resourceRequirements.MaxControlTDperTransfer = 40;
    resourceRequirements.MaxBulkTDperTransfer = 40;
    resourceRequirements.MaxIsochEndpoints = 2;
    resourceRequirements.MaxIsochMaxBuffers = 5;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_HIGH_POWER;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_LOW_POWER;
    resourceRequirements.MaxDevices = realMaxPorts*2;
    pUsbInit->RegisterResources(&resourceRequirements);

    DBGPRINT(2, ("exit:  DriverInit\n"));    

    return;// status;
}

//callback for endpoint closes (below) to allow them to be asynchronous
VOID Arf (PURB urb, PVOID context)
{

	PKEVENT pEvent = (PKEVENT) context;
	KeSetEvent(pEvent, IO_NO_INCREMENT ,FALSE);

}

/*************************************************************************************
Function:   SLIX_RemoveDevice
Purpose:	called by pnp when a device is unplugged. Removes that interface from our array
Params:     Device = the interface to talk to usbd
Return:     none
*************************************************************************************/

VOID SLIX_RemoveDevice (IN IUsbDevice *Device)
{
	HANDLE ourendpoints[MAX_ENDPOINTS];
	int i;
	KEVENT event;

	KeInitializeEvent(&event,NotificationEvent,FALSE);

    DBGPRINT(2, ("enter: SLIX_RemoveDevice\n"));
	if(Device == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called with NULL Device!\n"));
		return;
	}

    PDEVICE_EXTENSION   fdoDeviceExtension = (PDEVICE_EXTENSION) Device->GetExtension();

	if(fdoDeviceExtension == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called for device that has already been removed!!\n"
			"IUsbDevice passed: %p. Port: %x\n", Device, Device->GetPort()))
	}


	fdoDeviceExtension->flags = 0;

	fdoDeviceExtension->Device = 0;


	if(fdoDeviceExtension->Endpoints[0] == NULL) 
	{	//-1 == closed, other == open
		RtlZeroMemory(&CloseUrb[0],sizeof(URB));
		USB_BUILD_CLOSE_DEFAULT_ENDPOINT((&CloseUrb[0].CloseEndpoint), Arf, &event);
		Device->SubmitRequest(&CloseUrb[0]);
		KeWaitForSingleObject(&event,Executive,KernelMode,FALSE,NULL);  // Wait for completion
		KeResetEvent(&event);
	}
	for(i = 1; i < MAX_ENDPOINTS; i++)	
	{                                                                            //changed by Bing from 16 to 32
		if(fdoDeviceExtension->Endpoints[i] != (void*)-1 && fdoDeviceExtension->Endpoints[i] != (void*)NULL) 
		{
			RtlZeroMemory(&CloseUrb[i],sizeof(URB));
			if(fdoDeviceExtension->EndpointType[i] == 1)
			{
				RtlZeroMemory(&StopUrb[i],sizeof(URB));
				USB_BUILD_ISOCH_STOP_TRANSFER((&StopUrb[i].IsochStopTransfer), fdoDeviceExtension->Endpoints[i]);
				Device->SubmitRequest(&StopUrb[i]);
				USB_BUILD_ISOCH_CLOSE_ENDPOINT((&CloseUrb[i].IsochCloseEndpoint), fdoDeviceExtension->Endpoints[i], Arf, &event);

			} else 
			{
				USB_BUILD_CLOSE_ENDPOINT((&CloseUrb[i].CloseEndpoint), fdoDeviceExtension->Endpoints[i], Arf, &event);
			}
			Device->SubmitRequest(&CloseUrb[i]);
			KeWaitForSingleObject(&event,Executive,KernelMode,FALSE,NULL);  // Wait for completion
			KeResetEvent(&event);
		}
	}

	for(i = 0; i < MAX_ENDPOINTS; i++) 
	{
		fdoDeviceExtension->Endpoints[i] = (void*)-1;
		fdoDeviceExtension->EndpointType[i] = 0;
	}

	Device->SetExtension(NULL);
	Device->RemoveComplete();


	DBGPRINT(2, ("exit:  SLIX_RemoveDevice - Instance %d\n", gInstance));
	gInstance--; // decrement count of devices 

}

/*************************************************************************************
Function:   SLIX_AddDevice
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
VOID SLIX_AddDevice (IN IUsbDevice *Device)
{
    PSLIX_DRIVER_EXTENSION driverExtension;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION fdoDeviceExtension;
    ULONG port,slot,bUSBInterface;
	URB urb;
	int i;
	
    const USB_INTERFACE_DESCRIPTOR    *interfacedescriptor;
	DBGPRINT(2, ("enter: SLIX_AddDevice - Instance %d\n", gInstance));
	ASSERT(Device != NULL /* SLIX_RemoveDevice */);
	driverExtension = gDriverExtension;

	// get topology so we know where we are plugged in
	port = Device->GetPort();
    slot = 0;
    if(port >= 16)
    {
        slot = 1;
        port -= 16;
    } 

	interfacedescriptor = Device->GetInterfaceDescriptor();
	bUSBInterface = interfacedescriptor->bInterfaceNumber;

	
	if(bUSBInterface == 0) {
	gInstance++; // increment count of devices 
	DBGPRINT(3, ("interface Class: %d, interface Subclass: %d , interface number: %d\n", 
		interfacedescriptor->bInterfaceClass,
		interfacedescriptor->bInterfaceSubClass,
		bUSBInterface));

	//if it's an MU or hawk, move it to the next port...
	//(if we didn't do this, it would be impossible ot distinguish top-slot from control pad)
	if((interfacedescriptor->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE) 
		&& (interfacedescriptor->bInterfaceClass != USB_DEVICE_CLASS_PHYSICAL_INTERFACE)
		&& (interfacedescriptor->bInterfaceClass != XBOX_DEVICE_CLASS_INPUT_DEVICE)) {
		slot++;
	}	

	DBGPRINT(3, ("Topology:  port: %d, slot %d\n", port, slot));
	fdoDeviceExtension = &driverExtension->Nodes[port][slot];


	// Set our DeviceExtension in our CUSB class data
	DBGPRINT(3, ("Device->SetExtension\n"));
	Device->SetExtension(fdoDeviceExtension);

	for(i = 0; i < MAX_ENDPOINTS; i++) {
		fdoDeviceExtension->Endpoints[i] = (void*)-1;
		fdoDeviceExtension->EndpointType[i] = 0;
	}

	// save our device class pointer
	fdoDeviceExtension->Device = Device;
	fdoDeviceExtension->flags |= DF_CONNECTED;

	DBGPRINT(2, ("exit:  SLIX_AddDevice\n"));

	Device->SetClassSpecificType(1);
	Device->AddComplete(USBD_STATUS_SUCCESS);
	}else{
	DBGPRINT(3, ("Threw out an interface\n"))
	Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);

	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\slixbox\slixd\slixdriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i_slixdriver.h

Abstract:

    header of exposed routines from the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __slixdriver_h__
#define __slixdriver_h__

#define _IN
#define _OUT
#define _OPT

/* unused, since we aren't going through CreateFile
#define IOCTL_SLIX_IN		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_OUT		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_SETUP	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_DATA0	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
#define IOCTL_SLIX_DATA1	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, (FILE_READ_DATA | FILE_WRITE_DATA))
*/

typedef long USBD_STATUS;
typedef unsigned char       BYTE;
typedef unsigned long		DWORD;

#ifdef __cplusplus
extern "C" { //to prevent name mangling... 
#endif

/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE Address, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len);


/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len);


/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received.  OPT if data[6] == 0
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE Address, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _OPT _IN _OUT USHORT *len2);

/*************************************************************************************
Function:   SlixdData0
Purpose:	set the expected data toggle for the specified endpoint to Data0
Params:     in Endpoint --- the endpoint to start expecting Data0 from
Return:     none
*************************************************************************************/
VOID SlixdData0(BYTE Endpoint);


/*************************************************************************************
Function:   SlixdData1
Purpose:	set the expected data toggle for the specified endpoint to Data1
Params:     in Endpoint --- the endpoint to start expecting Data1 from
Return:     none
*************************************************************************************/
VOID SlixdData1(BYTE Endpoint);


USBD_STATUS SlixdReset();



#ifdef __cplusplus
} //extern "C"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stat\i386\87ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-88, Microsoft Corporation
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
;	 include cruntime.inc
;	 include mrt386.inc
;	 include os2supp.inc
.list

;	 CODESEG
	.386
	.387
	.model small,C
	.code


public _fltused
_fltused equ	9876h

_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

;	 mov	 rax, IWORD ptr [intval]
;	 mov	 rdx, IWORD ptr [intval+ISIZE]

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp




sqrt	proc	x:qword

	fld	[x]
	fsqrt

	ret
sqrt	endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stressmon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif


// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
    {
    ULONG DebugPrint(PCHAR Format, ...);
    __declspec(dllimport) NTSTATUS NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
    }


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stat\stat.c ===
/*
*      Stat.c        -    Source file for a statistical
*                         dll package that exports eleven
*                         entry points:
*                         a) TestStatOpen
*                         b) TestStatInit
*                         c) TestStatConverge
*                         d) TestStatValues
*                         e) TestStatClose
*                         f) TestStatRand
*                         g) TestStatUniRand
*                         h) TestStatNormDist
*                         i) TestStatShortRand
*                         j) TestStatFindFirstMode
*                         k) TestStatFindNextMode
*
*                         Entry point a) is an allocating routine
*                         that is called by an application program
*                         that desires to automatically compute
*                         convergence.
*
*                         Entry point b) initializes all variables that
*                         are used by entry points c) and d) in computing
*                         convergence and statistical information.
*
*                         Entry point c) automatically computes the
*                         the number of passes that the application has to
*                         go through for a 95% confidence data.
*                         This routine has to be called by the application
*                         after each pass.
*
*                         Entry point d) automatically computes the
*                         various statistical values eg. mean, SD etc.
*                         This function has to be called only after the
*                         application has called c) several times and has
*                         either converged or reached the iteration limit.
*
*                         Entry point e) deallocates all instance data
*                         data structures that were allocated by entry
*                         point a).
*
*                         Entry point f) returns a Random Number in a
*                         given range.
*
*                         Entry point g) returns a uniformly distributed
*                         number in the range 0 - 1.
*
*                         Entry point h) returns a normally distributed
*                         set of numbers, with repeated calls, whose
*                         mean and standard deviation are approximately
*                         equal to those that are passed in.
*
*                         Entry point i) is the same as g) except that
*                         the range is 0 - 65535.
*
*                         The following should be the rules of calling
*                         the entry points:
*
*                         Entry a) should be called before any of the others.
*                         Entry c) should be preceded by at least one call
*                         to entry b) for meaningful results.  Entry d)
*                         should be preceded by several calls to entry c).
*                         A call to b) and c) after a call to e) should
*                         preceded by a call to a) again.
*
*      Created         -  Paramesh Vaidyanathan  (vaidy)
*      Initial Version -  October 29, '90
*/

/*********************************************************************
*
*      Formula Used in Computing 95 % confidence level is derived here:
*
*
*        Any reference to (A) would imply "Experimental Design
*        in Psychological Research", by Allan Edwards.
*
*        Any reference to (B) would imply "Statistical Methods"
*        by Allan Edwards.
*
*        Assumptions - TYPE I Error  -  5% (B)
*                      TYPE II Error - 16% -do-
*
*        Area under the curve for Type I  - 1.96
*        Area under the curve for Type II - 1.00
*
*        For a 5% deviation, number of runs,
*
*                     2              2
*            n = 2 (c)  (1.96 + 1.00)
*                ------                      .....Eqn (1)
*                     2
*                 (d)
*
*            where c is the Std. Dev. and d is the absolute
*            difference bet. means [(B) Page 91].
*
*                    d = 5% X'               .....Eqn (2)
*
*            where X' is the mean of samples
*                         _
*                and  =  >_ X
*                        -----               .....Eqn (3)
*                         n
*                          0
*
*            When the number of iterations -> infinity,
*
*                     2     2
*                    S ->  c                 .....Eqn (4)
*
*
*                   2
*            where S is the estimate of the common population
*            variance (Eqn. 4 is a big assumption)
*
*        From (B) page 59, we have,
*
*             2     _  2       _   2
*            S  =  >_ X   - ( >_ X)
*                            -----
*                              n
*                               0
*                  -----------------         .....Eqn (5)
*                        n - 1
*                         0
*
*    Substituting Eqn (2), (3), (4) and (5) in (1), we get:
*                          _                     _
*                      2  |   _  2         _   2  |
*        n  = 7008  (n  ) |( >_ X  ) -  ( >_ X)   |
*                     0   |             --------  |
*                         |                n      |
*                         |_                0    _|
*                 ---------------------------------------
*                                        _    2
*                           (n  - 1)  ( >_ X )
*                             0
*
*    It should be mentioned that n  is the iteration pass number.
*                                 0
*********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <math.h>

#include "teststat.h"

#define SQR(A) ( (A) * (A) )        /* macro for squaring */
#define SUCCESS_OK          0       /* weird, but OK */
#define MIN_ITER            3       /* MIN. ITERATIONS */
#define MAX_ITER        65535       /* max. iterations */
#define REPEATS            14       /* repeat count for Norm. Dist. Fn. */
/**********************************************************************/
USHORT  usMinIter;              /* global min iter */
USHORT  usMaxIter;              /* global max iter */
ULONG  *pulDataArray;           /* a pointer to the data array for this
                                       package.  Will be as large as the
                                       maximum iterations */
double  dSumOfData;             /* sum of data during each pass */
double  dSumOfDataSqr;          /* sum of sqr. of each data point */
ULONG   ulTotalIterCount;       /* No. of iters returned by the interna;
                                   routine */
USHORT  cusCurrentPass;         /* count of the current iteration pass */
BOOL    bDataConverged = FALSE; /* TRUE will return a precision of 5% */
BOOL    bMemoryAllocated=FALSE; /* TRUE will allow alloced mem to free */
BOOL    bPowerComputed = FALSE; /* compute 10 exp. 9 for random no. gen */

BOOL   *pbIndexOfOutlier;       /* to keep track of values in
                                       pulDataArray, that were thrown out */

HANDLE hMemHandle = NULL;       /* handle to mem. allocated */
HANDLE hMemOutlierFlag;         /* handle to outlier flag memory */
/**********************************************************************/
ULONG TestStatRepeatIterations (double, double);
VOID TestStatStatistics (PSZ, PULONG far *, USHORT,
                                    PUSHORT, PUSHORT);
void DbgDummy (double, double);
ULONG   ulDataArrayAddress;         /* call to mem alloc routine returns
                                       base address of alloced. mem. */
BOOL    bOutlierDataIndex;          /* for allocating memory for outliers'
                                       index in data set */

/*********************************************************************/
/*
*    Function - TestStatOpen          (EXPORTED)
*
*    Arguments -
*                a) USHORT - usMinIterations
*                b) USHORT - usMaxIterations
*
*    Returns -
*                0 if the call was successful
*
*                An error code if the call failed.  The error code
*                may be one of:
*
*                   STAT_ERROR_ILLEGAL_MIN_ITER
*                   STAT_ERROR_ILLEGAL_MAX_ITER
*                   STAT_ERROR_ALLOC_FAILED
*
*
*    Instance data is allocated for the statistical package.  This
*    call should precede any other calls in this dll.  This function
*    should also be called after a call to TestStatClose, if convergence
*    is required on a new set of data.  An error code is returned if
*    argument a) is zero or a) is greater than b).  An error code is
*    also returned of one of the allocations failed.
*
*/

USHORT
TestStatOpen (
             USHORT usMinIterations,
             USHORT usMaxIterations
             )
{

    /* check for invalid args to this function */
    if (!usMinIterations)
        return (STAT_ERROR_ILLEGAL_MIN_ITER);
    if ((usMinIterations > usMaxIterations) || (usMaxIterations > MAX_ITER))
        return (STAT_ERROR_ILLEGAL_MAX_ITER);
    /* any other parameter is allowed */
    usMinIter = usMinIterations;      /* set global vars */
    usMaxIter = usMaxIterations;      /*    -do -        */

    // change made based on request from JeffSt/Somase/JonLe

    if (hMemHandle != NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    hMemHandle = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, usMaxIter *
                              sizeof(ULONG));
    if (hMemHandle == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    pulDataArray = (ULONG *) GlobalLock (hMemHandle);
    if (pulDataArray == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    bMemoryAllocated = TRUE;  /* A call to TestStatClose will
                                 now free the mem */
    return (SUCCESS_OK);
}

/*
*    Function - TestStatClose          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Instance data allocated for the statistical package by TestStatOpen
*    is freed.  Any call to entry points b) and c) following a call to
*    this function, should be preceded by a call to a).
*
*/
VOID
TestStatClose (VOID)
{
    if (bMemoryAllocated) {   /* free only if memory allocated */
        GlobalUnlock (hMemHandle);
        GlobalFree (hMemHandle);
        hMemHandle = NULL; /* Indicate released (t-WayneR/JohnOw) */
    }  /* end of if (bMemoryAllocated) */
    bMemoryAllocated = FALSE;  /* further calls to TestStatClose should be
                                  preceded by a memory allocation */
    return;
}

/*
*    Function - TestStatInit          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Initializes all the data arrays/variables for use by the convergence
*    and statistics routines.  This call should precede the first call
*    to TestStatConverge for each set of data.
*
*/

VOID
TestStatInit (VOID)
{
    USHORT usTempCtr;

    /* initialize all counters, variables and the data array itself */
    for (usTempCtr = 0; usTempCtr < usMaxIter; usTempCtr++) {
        pulDataArray [usTempCtr] = 0L;
    }
    dSumOfData = 0.0;
    dSumOfDataSqr = 0.0;
    ulTotalIterCount = 0L;
    cusCurrentPass = 0;
    bDataConverged = FALSE;
    return;
}

/*
*    Function - TestStatConverge          (EXPORTED)
*
*    Arguments -
*                a) ULONG - ulNewData
*    Returns -
*                TRUE if data set converged or limit on max. iters reached
*
*                FALSE if more iterations required for converged.
*
*    Computes the number of iterations required for a 95% confidence
*    in the data received (please see teststat.txt under \ntdocs on
*    \\jupiter\perftool for an explanation of the confidence.
*    If the current iteration count is larger than the maximum specified
*    with the call to TestStatOpen, or if the data set has converged
*    this function returns a TRUE.  The calling application should test
*    for the return value.
*/

BOOL
TestStatConverge (
                 ULONG ulNewData
                 )
{
    dSumOfData += (double)ulNewData;   /* sum of all data points in the set */
    dSumOfDataSqr += SQR ((double) ulNewData);
    /* sqr of data needed for the computation */
    if (cusCurrentPass < (USHORT) (usMinIter-(USHORT)1)) { /* do nothing if current iter
                                           < min specified value */
        ulTotalIterCount = (ULONG)usMaxIter + 1;  /* bogus value */
        pulDataArray [cusCurrentPass++] = ulNewData;
        /* register this data into the array and return FALSE */
        return (FALSE);
    }
    if ((cusCurrentPass == usMaxIter) ||
        (cusCurrentPass >= (USHORT) ulTotalIterCount)) {
        /* either the limit on the max. iters. specified has been reached
           or, the data has converged during the last iter; return TRUE */

        if (cusCurrentPass >= (USHORT) ulTotalIterCount)
            bDataConverged = TRUE;  /* set to determine if precision
                                       should be computed */
        return (TRUE);
    }
    if ((usMinIter < MIN_ITER) &&
        (usMinIter == usMaxIter) && ((USHORT)(cusCurrentPass+(USHORT)1) >= usMaxIter))
        /* don't call convergence algorithm, just return a TRUE */
        /* It does not make any sense in calling the convergence
           algorithm if less than 3 iterations are specifed for the
           minimum */
        return (TRUE);
    pulDataArray [cusCurrentPass++] = ulNewData; /* register this data into
                                                    the array */
    if (dSumOfData == 0.0) { /* possible if data points are all zeros */
        bDataConverged = TRUE;
        return (TRUE);
    }
    ulTotalIterCount = TestStatRepeatIterations (dSumOfData,
                                                 dSumOfDataSqr);

    if (ulTotalIterCount <= cusCurrentPass)
        return (TRUE);

    return (FALSE);
}

/*
*    Function - TestStatValues          (EXPORTED)
*
*    Arguments -
*               a) PSZ - pszOutputString
*               b) USHORT - usOutlierFactor
*               c) PULONG - *pulData
*               d) PUSHORT - pcusElementsInArray
*               e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%4u %10lu  %10lu  %10lu  %6u %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mode number, mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*/
VOID
TestStatValues(
              PSZ     pszOutputString,
              USHORT  usOutlierFactor,
              PULONG  *pulFinalData,
              PUSHORT pcusElementsInArray,
              PUSHORT pcusDiscardedElements
              )
{
    ULONG far * pulArray;
    USHORT Count =0;
    /* Call the low-level routine to do the statistics computation */
    /* doing this ,'cos, there is a possibility that the low-level
       routine may be used for some apps, within the perf. group.  This
       may not be fair, but that is the way life is */
    TestStatStatistics (pszOutputString, &pulArray,
                        usOutlierFactor, pcusElementsInArray,
                        pcusDiscardedElements);
    *pulFinalData = pulArray;
    return;

}

/***********************************************************************
                ROUTINES NOT EXPORTED, BEGIN
***********************************************************************/
/*
*     Function  - TestStatRepeatIterations  (NOT EXPORTED)
*     Arguments -
*               (a) double - Sum of Individual Data Points thus far
*               (b) double - Sum of Squares of Indiv. data points
*
*     Returns  - ULONG  - value of no. of iterations required for 95%
*                         confidence,
*
*     Computes the number of iterations required of the calling program
*     before a 95% confidence level can be reached.  This will return
*     a zero if the application calls this routine before 3 passes
*     are complete.  The function normally returns the total number of
*     iterations that the application has to pass through before
*     offering a 95% confidence on the data.
*/

ULONG
TestStatRepeatIterations(
                        double dSumOfIndiv,
                        double dSumOfSqrIndiv
                        )
{
    double dSqrSumOfIndiv = 0;
    ULONG  ulRepeatsNeeded = 0L;

    /* dSqrSumOfIndiv. stands for the square of the Sum of Indiv. data
       points,
       dSumOfSqrIndiv stands for the sum of the square of each entry point,
       dSumOfIndiv. stands for the sum of each data point in the set, and
       uIter is the iteration pass count
    */
    if (cusCurrentPass < MIN_ITER)
        /* not enough passes to compute convergence count */
        return (MAX_ITER);
    dSqrSumOfIndiv = SQR (dSumOfIndiv);
    /* use the formula derived at the beginning of this file to
       compute the no. of iterations required */

    ulRepeatsNeeded = (ULONG) (7008 *
                               (dSumOfSqrIndiv - dSqrSumOfIndiv/cusCurrentPass)
                               * SQR (cusCurrentPass) /
                               ((cusCurrentPass - 1) * dSqrSumOfIndiv));

    return (ulRepeatsNeeded);
}
/***************************************************************************/
/*
*     Function  - TestStatStatistics
*     Arguments -
*                 a) PSZ - pszOutputString
*                 b) PULONG far * - pulFinalData
*                 c) USHORT - usOutlierFactor
*                 d) PUSHORT - pcusElementsInArray
*                 e) PUSHORT - pcusDiscardedValues
*
*     Returns  -  Nothing
*
*     Computes the max, min, mean, and std. dev. of a given
*     data set.  The calling program should convert the values obtained
*     from this routine from a "ULONG" to the desired data type.  The
*     outlier factor decides how many data points of the data set are
*     within acceptable limits.  Data is returned to the buffer whose
*     address is the first argument to this call.
*
*/

VOID
TestStatStatistics (
                   PSZ     pszOutputString,
                   PULONG  *pulFinalData,
                   USHORT  usOutlierFactor,
                   PUSHORT pcusElementsInArray,
                   PUSHORT pcusDiscardedValues
                   )
{
    static USHORT   uArrayCount = 0;  /* local variable that may be reused */
    USHORT uTempCt = 0;  /* local variable that may be reused */
    double dSqrOfSDev = 0;       /* sqr of the std. deviation */
    double dSumOfSamples = 0;    /* sum of all data points */
    double dSumOfSquares = 0;    /* sum of squares of data points */
    ULONG  ulMean = 0L;
    ULONG  ulStdDev = 0L;
    ULONG  ulDiffMean = 0L;           /* to store the diff. of mean and SD,
                                         outlier factor */
    BOOL   bAcceptableSDev = TRUE ;   /* flag to determine if SDev. is
                                         acceptable */
    ULONG  ulMax = 0L;                /* pilot value */
    ULONG  ulMin = 0xffffffff;        /* largest possible ULONG */
    USHORT usPrecision = 0;           /* to obtain precision */
    USHORT uModeNumber = 0;           /* DUMMY VALUE until this is
                                         supported */

    /* compute mean by adding up all values and dividing by the no.
       of elements in data set - might need to recompute the
       mean if outlier factor is selected.  However, the min. and max. will
       be selected from the entire set */

    USHORT Count = 0;

    *pcusDiscardedValues = 0;       /* init. this variable */

    *pcusElementsInArray = cusCurrentPass;
    if (cusCurrentPass == 0)
        return;   /* get out without doing anything - this is a weird
                         case when the user calls this routine without
                         calling a converge routine */

    /* every iteration produces one data point */
    uArrayCount = 0;
    while (uArrayCount < *pcusElementsInArray) {
        if (pulDataArray[uArrayCount] > ulMax)
            ulMax = pulDataArray[uArrayCount];     /* new Max. value */
        if (pulDataArray[uArrayCount] < ulMin)
            ulMin = pulDataArray[uArrayCount];     /* new min. value */

        ulMean += pulDataArray [uArrayCount++];
    }
    ulMean /= *pcusElementsInArray;   /* this is the mean */
    /* the standard deviation needs to be computed */

    for (uArrayCount = 0; uArrayCount < *pcusElementsInArray; uArrayCount++) {
        dSumOfSamples += (double) pulDataArray [uArrayCount];
        dSumOfSquares += SQR ((double) pulDataArray [uArrayCount]);
    }

    dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                  SQR (dSumOfSamples)) /
                 (*pcusElementsInArray * (*pcusElementsInArray - 1));
    ulStdDev = (ULONG) sqrt (dSqrOfSDev);

    /* the standard deviation has been computed for the first pass */
    /* Use the outlier factor and the S.D to find out if any of
       individual data points are abnormal.  If so, throw them out and
        increment the discard value counter */
    if (usOutlierFactor) { /* if outlier factor is zero, do not go
                          through with the following */
        /*** here is what we do....
           allocate space for an array of BOOLs.  Each of these is a flag
           corresponding to a data point.  Initially, these flags will be
           all set to FALSE.  We then go thru each data point.  If a data
           point does not satisfy the condition for throwing out outliers,
           we set the flag corresponding to that data point to TRUE.  That
           point is not used to recompute the mean and SDev.  We recompute
           the mean and SDev after each round of outlier elimination.  When
           we reach a stage where no points were discarded during a round,
           we get out of the while loop and compute the statistics for the
           new data set ****/

        hMemOutlierFlag = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                       *pcusElementsInArray * sizeof(BOOL));
        pbIndexOfOutlier = (BOOL FAR *) GlobalLock (hMemOutlierFlag);

        for (uArrayCount = 0; uArrayCount < *pcusElementsInArray;
            uArrayCount ++)
            pbIndexOfOutlier [uArrayCount] = FALSE;

        while (1) { /* begin the data inspection round */
            bAcceptableSDev = TRUE; /* set this flag to TRUE.  If we
                                       hit an outlier, this flag will
                                       be reset */
            for (uArrayCount = 0; uArrayCount < cusCurrentPass;
                uArrayCount++) {
                /*** check the individual data points ***/
                if (ulMean < (ulStdDev * usOutlierFactor))
                    /* just make sure that we are not comparing with a
                       negative number */
                    ulDiffMean = 0L;
                else
                    ulDiffMean = (ulMean - (ulStdDev * usOutlierFactor));
                if (!pbIndexOfOutlier [uArrayCount]) {
                    if ((pulDataArray [uArrayCount] < ulDiffMean)
                        || (pulDataArray [uArrayCount] >
                            (ulMean + (ulStdDev * usOutlierFactor)))) {
                        /* set the flag of this data point to TRUE to
                           indicate that this data point should not be
                           considered in the mean and SDev computation */
                        pbIndexOfOutlier [uArrayCount] = TRUE;
                        /*** increment the discarded qty ***/
                        (*pcusDiscardedValues)++;
                        /*** decrement the count of good data points ***/

                        // uncomment next line if outliers should be part of mean - vaidy

                        //                        (*pcusElementsInArray)--;
                        bAcceptableSDev = FALSE;
                    }  /*** end of if statement ***/
                }   /*** end of if !pbIndexOfOutlier ***/
            }  /*** end of for loop ***/
            if (!bAcceptableSDev) {  /*** there were some bad data points ;
                                        recompute S.Dev ***/
                // Starting at next statement, uncomment all lines until you see
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN", if you want outliers to be
                // part of mean.  vaidy Aug. 1991.

                //                dSumOfSamples = 0.0; /* init these two guys */
                //                dSumOfSquares = 0.0;
                //                for (uArrayCount = 0;
                //                     uArrayCount < cusCurrentPass;
                //                     /* check all elements in the data array */
                //                     uArrayCount++) {
                //                    /* consider only those data points that do not have the
                //                       pbIndexOfOutlier flag set */

                //                    if (!pbIndexOfOutlier [uArrayCount]) {
                //                        dSumOfSamples += (double) pulDataArray [uArrayCount];
                //                        dSumOfSquares += SQR ((double)pulDataArray
                //                                                      [uArrayCount]);
                //                    }
                //                }
                //                if (*pcusElementsInArray > 1)
                //                    /* compute StdDev. only if there are atleast 2 elements */
                //                    dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                //                               SQR (dSumOfSamples)) /
                //                              (*pcusElementsInArray *
                //                              (*pcusElementsInArray - 1));
                //                ulStdDev = (ULONG) sqrt (dSqrOfSDev);
                //                /* since some data points were discarded, the mean has to be
                //                   recomputed */
                //                uArrayCount = 0;
                //                ulMean = 0;
                //                while (uArrayCount < cusCurrentPass) {
                //                    /* consider only those data points that do not have the
                //                       bIndexOfOutlier flag set */
                //                    if (!pbIndexOfOutlier [uArrayCount++])
                //                        ulMean += pulDataArray [uArrayCount - 1];
                //                }
                //                if (*pcusElementsInArray > 0)  /* only then compute mean */
                //                    ulMean /= *pcusElementsInArray; /* this is the new mean */
                //                else
                //                    ulMean = 0L;
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN"
            } /*** end of if (!bAcceptableSDev) ***/
            else       /*** if the for loop completed without
                            a single bad data point ***/
                break;
        } /* end of while */
        /****  free the memory for the bIndexOfOutiler flag */
        GlobalUnlock (hMemOutlierFlag);
        GlobalFree (hMemOutlierFlag);
    }  /* end of if (iOutlierFactor) */
    /* so, now an acceptable Standard deviation and mean have been obtained */

    if ((!bDataConverged) &&
        (usMaxIter < MIN_ITER)) {
        /* set precision to 0% if max iters chosen is less than 3 */
        usPrecision = 0;
    } else { /* need to compute precision */
        /* using eqn. 1. above, it can be shown that the precision, p,
           can be written as:
                                      1
                 _                 _   /
                |        2       2  |   2
                |  2 * SD  * 2.96   |
            p = | ----------------- |
                |             2     |
                |     n * Mean      |
                |_                 _|
        *************************************************************/
        if (ulMean > 0) {
            usPrecision = (USHORT) (sqrt((double) ((2 *
                                                    SQR ((double)ulStdDev) *
                                                    SQR (2.96) /(*pcusElementsInArray *
                                                                 SQR ((double) ulMean))))) * 100.0
                                    + 0.5);

        } else
            usPrecision = (USHORT)~0;
    }  /* end of else need to compute precision */
    sprintf (pszOutputString,
             "%4u %10lu %10lu %10lu %6u %5u %10lu %4u %2u ",
             uModeNumber, ulMean, ulMin, ulMax, cusCurrentPass,
             usPrecision, ulStdDev, *pcusDiscardedValues,
             usOutlierFactor);

    *pcusElementsInArray = cusCurrentPass;
    *pulFinalData = pulDataArray;
    return;
}


/*
*        The following is the source for generating random numbers.
*        Two procs are provided:  TestStatRand and TestStatUniRand.
*
*   a)   TestStatRand is called as follows: TestStatRand (Low, High)
*            The result is a number returned in the range Low - High (both
*            inclusive.
*
*        A given intial value of Seed will yield a set of repeatable
*        results.  The first call to TestStatRand should be with an odd seed
*        in the range of 1 - 67108863, both inclusive.  The following
*        9 seeds have been tested with good results:
*
*        32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
*        20302541, 32524125, 42152159.
*
*        The result should never be equal to the seed since this would
*        eliminate the theoretical basis for the claim for uniform
*        randomeness.
*
*   b)   TestStatUniRand is called as follows:
*                 NormFrac = TestStatUniRand ();
*            NormFrac is uniformaly distributed between 0 and 1 with
*            a scale of 9 (values range bet. 0 and 0.999999999).
*
*        The basis for this algorithm is the multiplicative congruential
*        method found in Knuth (Vol.2 , Chap.3).  Constants were selected
*        by Pike, M.C and Hill, I.D; Sullivans, W.L. provides the
*        the list of tested seeds.
*
*        The code here has been adapted from Russ Blake's work.
*
*        Created  :   vaidy   - Nov. 29, 90
*/

#define MODULUS     67108864      /* modulus for computing random no */
#define SQRTMODULUS 8192          /* sqrt of MODULUS */
#define MULTIPLIER  3125
#define MAX_UPPER   67108863
#define MAX_SEEDS   8           /* 8 good starting seeds */
#define SCALE       65535

ULONG aulSeedTable [] = {     /* lookup table for good seeds */
    32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
    20302541, 32524125, 42152159};

USHORT uSeedIndex;            /* index to lookup table */
ULONG  ulSeed = 32347753;     /* the seed chosen from table (hardcoded here)
                                 and recomputed */

/*********************************************************************/
/*
*    Function - TestStatRand          (EXPORTED)
*
*    Arguments -
*                a) ULONG  - ulLower
*                b) ULONG  - ulUpper
*
*    Returns -
*                a random number in the range ulLower to ulUpper
*
*                An error code if the call failed.  The error code
*                will be:
*
*                   STAT_ERROR_ILLEGAL_BOUNDS
*
*
*   Calls TestStatUniRand and returns a random number in the range passed
*   in (both inclusive).  The limits for the lower and upper bounds
*   are 1 and 67108863.  The start seed index looks up into the array
*   of seeds to select a good, tested starting seed value.  The returned
*   values will be uniformaly distributed within the boundary.  A start
*   seed has been hardcoded into this dll.
*
*/

ULONG
TestStatRand (
             ULONG ulLower,
             ULONG ulUpper
             )
{
    double dTemp;
    double dNormRand;
    LONG   lTestForLowBounds = (LONG) ulLower;

    /* check args */
    if ((lTestForLowBounds < 1L) ||
        (ulUpper > MAX_UPPER) || (ulUpper < ulLower))
        return (STAT_ERROR_ILLEGAL_BOUNDS);
    dNormRand = TestStatUniRand ();  /* call TestStatUniRand */
    dTemp = (double) ((ulUpper - ulLower) * dNormRand); /* scale value */
    return (ulLower + (ULONG) dTemp);
}

/*
*
*   Function - TestStatUniRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a uniformaly distrib. normalized number in the range 0 - 0.9999999
*   (both inclusive).  Modifies the seed to the next value.
*
*/

double
TestStatUniRand (VOID)
{
    ULONG  ulModul = MODULUS;   /* use the modulus for getting remainder
                                   and dividing the current value */
    double dMult   = MULTIPLIER;
    double dTemp   = 0.0;       /* a temp variable */
    double dTemp2  = 0.0;       /* a temp variable */
    ULONG  ulDivForMod;         /* used for obtaining the remainder of
                                   the present seed / MODULUS */

    /* the following long-winded approach has to be adopted to
       obtain the remainder.  % operator does not work on floats */

    /* use a temp variable.  Makes the code easier to follow */

    dTemp = dMult * (double) ulSeed;  /* store product in temp var. */
    DbgDummy (dTemp, dMult); // NT screws up bigtime for no reason
                             // if this is not used - possible compiler
                             // bug
    dTemp2 = (double) ulModul; // more compiler problems reported
                               // on Build 259 by JosephH.
                               // April 13, 1992.
    ulDivForMod = (ULONG) (dTemp / dTemp2);

    //    ulDivForMod = (ULONG) (dTemp / ulModul); /* store quotient of present
    //                                                seed divided by MODULUS */
    dTemp -= ((double)ulDivForMod * (double)ulModul);
    /* dTemp will contain the remainder of present seed / MODULUS */

    ulSeed = (ULONG) dTemp;   /* seed for next iteration obtained */
    /* return value */
    return ((dTemp)/(double)ulModul);
}

/*
*
*   Function - TestStatNormDist ()          EXPORTED
*
*   Accepts -
*              a) ULONG  - ulMean
*              b) USHORT - usStdDev
*
*   Returns -  LONG - A LONG that allows the mean of the generated
*              points to be approximately ulMean and the SD of the
*              set to be ulStdDev.
*
*   Formula used here is:            REPEATS
*                                    _
*   Return Value = ulMean + (-7 + [ >_ TestStatUniRandRand ()] * ulStdDev
*                                   i = i
*
*   This formula is based on 'Random Number Generation and Testing',
*   IBM Data Processing Techniques, C20-8011.
*/

LONG
TestStatNormDist (
                 ULONG ulMean,
                 USHORT usSDev
                 )
{
    LONG   lSumOfRands = 0L;  /* store the sum of the REPEATS calls here */
    USHORT cuNorm;            /* a counter */
    LONG   lMidSum = 0L;
    LONG   lRemainder = 0L;

    for (cuNorm = 0; cuNorm < REPEATS; cuNorm++)
        lSumOfRands += (LONG) TestStatShortRand ();

    /* we now do a lot of simple but ugly mathematics to obtain the
       correct result.  What we do is as follows:

       Divide the lSumOfRands by the scale factor.
       Since we are dealing with short and long integers, we are
       likely to lose precision.  So, we get the remainder of this
       division and multiply each of the values by the standard division.

       Eg. if lSumOfRands = 65534 and std.dev is 10,
       lQuotient = 0, lRemainder = 65534.

       lMidSum = (-7 * 10) + (0 * 10) + (65534 * 10/65535) = -61,
       which is pretty accurate.  We then add the mean and return.
       Actually, we do not return right away.  To be more precise,
       we need to find out if the third element in the above term
       yields a remainder of < 0.5.  If so, we do not do anything.
       Else, we add 1 to the result to round off and then return.
       In the above example, the remainder = 0.99.  So we add 1 to
       -61.  The result is -60 and this is accurate. */

    lRemainder = (lSumOfRands * usSDev) % SCALE;
    /* the above remainder is the one to determine the rounding off */

    lMidSum =  ((-7 + (lSumOfRands / SCALE)) * usSDev) +
               ((lSumOfRands % SCALE) * usSDev / SCALE);

    if (lRemainder >= (SCALE / 2L))  /* need to roundup ? */
        lMidSum += 1L;

    return (lMidSum + ulMean);
}

/*
*
*   Function - TestStatShortRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a normalized number in the range 0 - 65535
*   (both inclusive).  Modifies the seed to the next value.
*
*/

USHORT
TestStatShortRand (VOID)
{
    ULONG  ulTemp = SCALE / SQRTMODULUS;

    ulSeed =  (MULTIPLIER * ulSeed) % MODULUS;
    /* seed for next iteration obtained */

    /* note: the return value should be (ulSeed * SCALE / MODULUS).
       However, the product of the elements in the numerator, far exceeds
       4 Billion.  So, the math is done in two stages.  The value of
       MODULUS is a perfect square (of 8192).  So, the SCALE is first
       divided by the SQRT of the MODULUS, the product of ulSeed and the
       result of the division is divided by the SQRT of the MODULUS again */

    /* return scale value - add one to ulTemp for correction */
    return ((USHORT) ((ulSeed * (ulTemp + 1)) / SQRTMODULUS));
}

/*
*
*   Function - TestStatFindFirstMode ()          EXPORTED
*
*   Accepts -  a) PSZ     - pszOutputString
*              b) USHORT  - usOutlierFactor
*              c) PULONG  - *pulData
*              d) PUSHORT - pcusElementsInArray
*              e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%10lu  %10lu  %10lu  %10lu %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*   Returns
*                TO BE COMPLETED.....
*
*/

/*++
  Had to call this routine in TestStatUniRand - compiler screws up
--*/
void
DbgDummy (
         double dTemp,
         double dLocal
         )
{
    dTemp = 0.0;
    dLocal = 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\strgen\strgen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    strgen.h

Abstract:

    Routine to generate random string

Environment:

    Xbox

Revision History:

--*/


#define SG_FORMAT_ASCII			0
#define SG_FORMAT_UNICODE		1

#define SG_MAXLENGTH_256		0
#define SG_MAXLENGTH_32768		-1

#define SG_STYLE_NORMAL			0
#define SG_STYLE_NETBIOS		1

#define SG_PRESUDO_YES          1
#define SG_PRESUDO_NO           0

#define SG_RISK_NO              0
#define SG_RISK_YES             1

int strgen(LCID ,int ,int ,	int ,unsigned int,int,int,void *);
int PassString(char *,int ,void **,BOOL *,LCID );
int  ConvertLCIDtoCodePage(LCID );
void GenerateFERiskString(char **,WORD **,int ,LCID,int);
void GenerateEuroRiskString(char **,WORD **,int , LCID,int);
void GenerateMixRiskString(LCID*,WCHAR **,int,int);
BOOL ISFELocale(LCID);

extern LCID  g_lcID[MAX_PATH] ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\strgen\main.c ===
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>
#include <time.h>

#include <assert.h>
#include <locale.h>

#include <tchar.h>

#include "strgen.h"

//
// CONSTANTS
//

#define  chDash      '-'
#define  chSlash     '/'
#define  chColon     ':'

#define  chFormat    'F'
#define  chformat    'f'

#define  chseed      's'
#define  chSeed      'S'

#define  chstyle     't'
#define  chStyle     'T'

#define  chlength    'l'
#define  chLength    'L'

#define  chOutput    'o'
#define  choutput    'O'

#define  chRisk    'R'
#define  chrisk    'r'

#define  chPresudo    'P'
#define  chpresudo    'p'

#define  chANSIInput    'A'
#define  chansinput    'a'

#define  chUnicodeInput    'U'
#define  chunciodeinput    'u'

#define  chUnicodeInput    'U'
#define  chunciodeinput    'u'


#define  chLANG            'G'
#define  chlang            'g'

#define  chNETBIOS            'N'
#define  chnetbios            'n'



void  Usage(char **);
int  CommandLineParse(	int,char**,int*,unsigned int*,int*,int*,int*,int*,char *,char**);
int  ConvertLCIDtoCodePage(LCID);
LCID LanguageHelper(char *);
BOOL SendDataToClipBoard(void);

const char *pstrUsage[] =
{
    "\n",
//    "strgen [-L:length] [-s:seed] [-f:format] [-t:style] [-o:OutFileName] [-p:Presudo]",
    //"strgen [-l:length] [-s:seed] [-f:format] [-g:style] ] [-n:nValidNetBiosName] [-r:nRiskString]",
    "strgen [-l:length] [-s:seed] [-f:format] [-g:style] ] [-n:nValidNetBiosName] ",
    "\n",
    "        -l  specifies the length of string in byte	\n",
	"             0 means random length with max_length being 255,default is 0  \n",
    "            -1 means random length with max_length being 32767 \n",
    "        -s  specifies the seed ,default seed is generated from time\n",
    //"        -t  specifies string style 0:ANSI 1:Pure loc string 2:MIXED,default is 2\n",
    //"        -o  output file name \n",
    "        -f  a :the strgen generated in Clipboard is in ANSI \n",
    "            u :the strgen generated in Clipboard is in UNICODE  default is  u\n",
    //"        -r  0 means ,default is try to generate risky chars ,specify 0 will generate random chars\n",
    "        -g  specify language(3-letter,eg JPN/GER/ARA/HEB/CHS/CHT/KOR...)\n"
    "        -a  input ANSI code String \n"
    "        -u  input Unicode  code String \n"
//    "            0 means not necessary contains risk string ,default is 0\n",
//    "        -p  1 means generate char despite wether it really exists, \n",
//    "            0 means generate char  only  it really exists \n ", 
//    "              default is 0  \n",
	"\n",
    "  Note: Generated string is always put in the Clipboard. \n",
    "  Note: set clipboard=off before running if you do not want the string \n",
    "  Note: be put in clipboard\n",
    "\n",    
    NULL
};

const char *pstrJapanese[] =
{
    "\n",
    "In Japanese leading byte is 0x81,0x40,0x82,0x9F,0xFC,0xE5 \n",
    "or trailing byte is 0x5B,0x5C,0x5D,0x7C,0xA1,0xAE,0xBF,0xDF,0xE0,0x40,0xFC\n",
    "will mostly exposed code dealing with DBCS problem ",
    "\n",
    NULL
};

const char *pstrGerman[] =
{
    "\n",
    "In German using  extended chars (above 0x80) will have larger chance to find \n",
    "coding dealing with code page problem, since the same coed point above 0x80  \n",
    "has different meaning between German's Wndows code page 1252 and DOC code page 850 \n",
    "The  most common used chars are 0xE4,0xF6,0xFC,0xC4,0xD6,0xDC,0xDF in 1252 \n",
    "\n",
    NULL
};
    

LCID  g_lcID[MAX_PATH] ;
int   g_nLang = 0;


int _cdecl  main(int argc, char *argv[ ])
{
    int nFormat ,nStyle, nLength,nPresudo,nRisk;
    unsigned int  uSeed;
    char achOutputFileName[MAX_PATH];
    
    void  *pVoid;
    HANDLE hFile = NULL;
    int nWritten;
    int  n;
    char achLang[128];
    HWND hWnd;
    HANDLE hMem;
    DWORD dw;
    char *pInputString;
    BOOL fValid;
    char achCodePage[10],achCodePageTmp[10];
    WORD *pwRiskUnicode = NULL;
    char *pRiskAnsi = NULL;
    BYTE i,j;
    BOOL bNotValidMixedLocale=FALSE;
    char *achTmp;
    


    //setlocale(LC_ALL,"");
    if ( ! CommandLineParse(argc,
                              argv,
                  	      &nFormat,
                              &uSeed,
                              &nStyle,
			                  &nLength,
                              &nPresudo,
                              &nRisk,
                              achOutputFileName,
                              &pInputString))
    {
            Usage(pstrUsage);
            return -1;
    }
    if (!g_nLang)
    {
       g_lcID[0]=GetSystemDefaultLCID();
       g_lcID[1]=0;
    }  

    for (i=0;i<g_nLang;i++)
    {
        if (!IsValidLocale(g_lcID[i], LCID_INSTALLED))
        {
            //assert(0 && " Not Correct Locale ");
	        //g_lcID = GetSystemDefaultLCID();
            printf("LCID %x not valid, most probally the langpack for that locale not installed !\n",g_lcID[i]);
            exit(1);
        }
    }

    strcpy(achCodePage,".");

    _itoa(ConvertLCIDtoCodePage(g_lcID[0]),achCodePageTmp,10);
    strcat(achCodePage,achCodePageTmp);

    setlocale(LC_ALL,achCodePage);
    //setlocale(LC_ALL,"");

    if (pInputString)
    {
       nRisk = 0;
       PassString(pInputString,nFormat,&pVoid,&fValid,g_lcID[0]);    
    }
    else
    if (g_nLang >1 )
    {
        if (SG_MAXLENGTH_256==nLength)
        {
           nLength = 1;           
        }        
        nFormat = 1;
        srand(uSeed);
        GenerateMixRiskString(g_lcID,(WCHAR**)&pVoid,nLength  ,nStyle);
    }
    else
    {
        if (nRisk)
        {
            if (SG_MAXLENGTH_256==nLength)
            {
                nLength = 1;
            }                
            srand(uSeed);
            if ( ISFELocale(g_lcID[0]))
            {
                GenerateFERiskString(&pRiskAnsi,&pwRiskUnicode,nLength,g_lcID[0],nStyle);
            }
            else
            {
               GenerateEuroRiskString(&pRiskAnsi,&pwRiskUnicode,nLength,g_lcID[0],nStyle);
            }
        }        
        else  
        {
            //BUGBUG Normal risk string
        }
    }

    if (!pVoid)
    {
       printf("Internal Error,Not Enough Memory\n");
       exit(1);
    }

    if (nRisk && (g_nLang<2) )
    {
        printf("\n The code generated is :\n");

    }

    if (g_nLang >1)
    {
        printf("The String generated is in clipboard and str.txt in current directory\n");
    }
    else
    {

        if (nFormat)
        {
            if (pwRiskUnicode)
                pVoid = pwRiskUnicode;
            wprintf(L"%s",(WCHAR*)pVoid);
        }
        else   
        {
            if (pRiskAnsi)
                pVoid = pRiskAnsi;
            printf("%s",(char*)pVoid);
        }
    }

    if ( (!pInputString) && (g_nLang<2))
    {
    if (nRisk)
    {
        
        if (ISFELocale(g_lcID[0]))
        {
            int k,n;
            n = strlen((char*)pVoid);

            if (1!=nLength) 
            {
                printf("\n");
            }
            printf("ANSI: ");
            for (k=0;k<n;k=k+2)
            {
                i = pRiskAnsi[k];
                j = pRiskAnsi[k+1];
                printf("%X%X ",i,j);
            }            
            if (1!=nLength) 
            {
                printf("\n");
            }
            printf("Unicode:");
            n = wcslen(pwRiskUnicode);
            for (k=0;k<n  ;k++)
            {
                printf("%X ",pwRiskUnicode[k]);
            }
        }
        else
        {
            
            int k,n;
            n = strlen((char*)pVoid);

            if (1!=nLength) 
            {
                printf("\n");
            }
            printf("ANSI: ");
            for (k=0;k<n;k++)
            {
                BYTE  a = 0;
                a = pRiskAnsi[k];
                printf("%X",a);
            }            
            if (1!=nLength) 
            {
                printf("\n");
            }
            printf("Unicode:");
            n = wcslen(pwRiskUnicode);
            for (k=0;k<n    ;k++)
            {
                printf("%X ",pwRiskUnicode[k]);
            }
        }

    }
    }
    
    printf("\n");
    //first try user input file name
    hFile = INVALID_HANDLE_VALUE;

    if (*achOutputFileName)
    {
        hFile =  CreateFile(
				achOutputFileName,
				GENERIC_WRITE,
				0,
				NULL,
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
    }

    //If fail or user did not give file name,use default name
    if (INVALID_HANDLE_VALUE == hFile)
    {
		hFile =  CreateFile(
				"str.txt",
				GENERIC_WRITE,
				0,
				NULL,
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
    }
    if (INVALID_HANDLE_VALUE == hFile) 
    {   char tmpPath[MAX_PATH];

        GetTempPath(MAX_PATH,tmpPath);
        strcat(tmpPath,"\\str.txt");

        hFile =  CreateFile(
				tmpPath,
				GENERIC_WRITE,
				0,
				NULL,
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
    }
    if (INVALID_HANDLE_VALUE == hFile) 
    {
        //BUGBUG need to contine , do not quit 
        //printf("file write error !");
        //return 1;
        hFile = NULL;
    }
    hWnd = GetDesktopWindow();
	assert(hWnd&&"Invalid Desktop Win handle");

    
    if (nFormat)
    {
        unsigned char ucTag;
        ucTag=0xFF;
        if (hFile)
		    WriteFile(hFile,
					&ucTag,
					sizeof(unsigned char),
					&nWritten,
					NULL);
        ucTag=0xFE;
        if (hFile)
            WriteFile(hFile,
					&ucTag,
					sizeof(unsigned char),
					&nWritten,
					NULL);
        if (hFile)
		    WriteFile(hFile,
					(WCHAR*)pVoid,
					wcslen((WCHAR*)pVoid) * sizeof(WCHAR),
					&nWritten,
					NULL);  
        if (SendDataToClipBoard())
        {
            if (OpenClipboard(NULL)) 
		    {
			    WCHAR *pWStr;
			    hMem = GlobalAlloc(
						    GMEM_MOVEABLE | GMEM_DDESHARE,
						    (wcslen((WCHAR*)pVoid)+1) * sizeof(WCHAR));
			    if (!hMem) 
				    goto CleanUp;
			
			    pWStr = GlobalLock(hMem);

			    if (!pWStr) 
			    {	
				    GlobalFree(hMem);
				    goto CleanUp;
			    }

			    wcscpy(pWStr,(WCHAR*)pVoid);
			    GlobalUnlock(hMem);
                EmptyClipboard();
			    SetClipboardData(CF_UNICODETEXT,hMem);
                dw = GetLastError();
			    CloseClipboard();
		    }
        }
                    
    }
    else
    {
        if (hFile)
		    WriteFile(hFile,
					(char*)pVoid,
					strlen((char*)pVoid) ,
					&nWritten,
					NULL);  

        if (SendDataToClipBoard())
        {
            if (OpenClipboard(NULL)) 
		    {
			    char *pStr;
                int n;

                n = (strlen((char*)pVoid)+1) * sizeof(char);
			    hMem = GlobalAlloc(
				    		GMEM_MOVEABLE | GMEM_DDESHARE,
					    	(strlen((char*)pVoid)+1) * sizeof(char));
			    if (!hMem) 
				    goto CleanUp;
			
			    pStr = GlobalLock(hMem);

			    if (!pStr) 
			    {	
				    GlobalFree(hMem);
				    goto CleanUp;
			    }

			    strcpy(pStr,(char*)pVoid);
			    GlobalUnlock(hMem);
                EmptyClipboard();
			    SetClipboardData(CF_TEXT,hMem);
                dw = GetLastError();
			    CloseClipboard();
		    }
        }
    }
 
	CleanUp:
    if ( (INVALID_HANDLE_VALUE!=hFile) && (hFile!=NULL) )
        CloseHandle(hFile);

	free(pVoid);
	return 1;

}


void  Usage(char **achStr)
{
    register i = 0;
    while (achStr[i] != NULL)
    {
        fprintf(stderr, achStr[i++]);
    }
    fflush(stderr);
}


int  CommandLineParse(	int           argc,
                        char          *argv[],
			int           *pFormat,
			unsigned int  *pSeed,
			int	      *pStyle,
			int           *pLength,
                        int           *pPresudo,
                        int           *pRisk,
			char	      *pOutputFileName,
                        char          **pInputString
                        )
{
    int  nParaType;

    // Cycle through all the command line arguments.
    //
#define PARAMETER_TYPE_FORMAT		0
#define PARAMETER_TYPE_STYLE		1
#define PARAMETER_TYPE_SEED		2
#define PARAMETER_TYPE_LENGTH		3
#define PARAMETER_TYPE_OUTPUT		4
#define PARAMETER_TYPE_PRESUDO		5
#define PARAMETER_TYPE_RISK 		6
#define PARAMETER_TYPE_ANSIINPUT	7
#define PARAMETER_TYPE_UNICODEINPUT	8
#define PARAMETER_TYPE_LANG             9

    register i = 1;

    *pFormat = SG_FORMAT_UNICODE;
    *pLength = SG_MAXLENGTH_256;
    *pStyle  = SG_STYLE_NORMAL;
    *pSeed   = (unsigned)time( NULL );
    *pPresudo = SG_PRESUDO_NO;
    *pRisk    = SG_RISK_YES;

    *pInputString = NULL;

    strcpy(pOutputFileName,"");

    if (1 == argc)//no parameter using default
    {
        return TRUE;
    }
    if (_stricmp(argv[1], "-?") == 0 ||
                    _stricmp(argv[1], "/?") == 0 ||
                    _stricmp(argv[1], "?") == 0 ||
                    _stricmp(argv[1], "help") == 0)
    {
        return FALSE;//return false and print help meaasge
    }

    while (i < argc)
    {
        char  *ptchArg = argv[i++];

        // Check that what has been typed is meant to be an argument.
        //
        if ((*ptchArg == chDash) || (*ptchArg == chSlash))
        {
            ptchArg++;

            // Determine which argument is being set.
            //
            switch (*ptchArg)
            {
            case chFormat:
            case chformat:
                   nParaType = PARAMETER_TYPE_FORMAT;
		   break;

            case chstyle:
            case chStyle:
                   nParaType = PARAMETER_TYPE_STYLE;
                 break;

            case chseed:
            case chSeed:
                   nParaType = PARAMETER_TYPE_SEED;
                break;
            case chlength:
            case chLength:
		nParaType = PARAMETER_TYPE_LENGTH;
                break;

            case choutput:
            case chOutput:
		nParaType = PARAMETER_TYPE_OUTPUT;
                break;
            case chPresudo:
            case chpresudo:
                nParaType = PARAMETER_TYPE_PRESUDO;
                break;
            case chNETBIOS:
            case chnetbios:
                nParaType = PARAMETER_TYPE_STYLE;
                break;
            case chRisk:
            case chrisk:
                nParaType = PARAMETER_TYPE_RISK;
                break;

            case chANSIInput:
            case chansinput :
                nParaType = PARAMETER_TYPE_ANSIINPUT;
                break;
            case chUnicodeInput:
            case chunciodeinput:
                nParaType = PARAMETER_TYPE_UNICODEINPUT;
                break;
            case  chLANG:
            case  chlang:
                nParaType = PARAMETER_TYPE_LANG;
                break;
            default:
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }

        // Only the first character is used to determine the option
        // being set.  After it should be a colon followed by the
        // argument itself.  If this is not the case, then it is an
        // error.
        //
        ptchArg++;
        if ((*ptchArg++ == chColon) && (*ptchArg != (char)NULL))
        {
            switch (nParaType)
	    {
		case PARAMETER_TYPE_FORMAT:
		   if (*ptchArg=='A' || *ptchArg=='a')
        		*pFormat = SG_FORMAT_ASCII;
		break;
		case PARAMETER_TYPE_LENGTH:
		if (-1==atoi(ptchArg))
			*pLength=SG_MAXLENGTH_32768;
		else if (atoi(ptchArg) > 0)
	    	        *pLength=atoi(ptchArg);
		break;

			case PARAMETER_TYPE_SEED:
				*pSeed = atoi(ptchArg);
                break;
            case PARAMETER_TYPE_RISK:
                //if (1==atoi(ptchArg))
					*pRisk=SG_RISK_NO;
				 break;
			case PARAMETER_TYPE_STYLE:
				if (SG_STYLE_NETBIOS == atoi(ptchArg))
					*pStyle = SG_STYLE_NETBIOS;
				break;
			case PARAMETER_TYPE_OUTPUT:
				strcpy(pOutputFileName,ptchArg);
				break;
            case PARAMETER_TYPE_PRESUDO:
				if (atoi(ptchArg)==0)
                    *pPresudo = SG_PRESUDO_NO;
                else  if (atoi(ptchArg)==1)
                    *pPresudo = SG_PRESUDO_YES;
                break;
            case PARAMETER_TYPE_ANSIINPUT:
                *pInputString = malloc((strlen(ptchArg)+1)*sizeof(BYTE));
                strcpy(*pInputString,ptchArg);
                *pFormat = 0;
                i = argc + 1;
                break;
            case PARAMETER_TYPE_UNICODEINPUT:
                *pInputString = malloc((strlen(ptchArg)+1)*sizeof(BYTE));
                strcpy(*pInputString,ptchArg);
                *pFormat = 1;
                i = argc + 1;
                break;
            case PARAMETER_TYPE_LANG:
                g_lcID[g_nLang] = LanguageHelper(ptchArg);
                g_nLang++;
                break;

			default:
				assert(0&&"Undefined Parameter Type!");
				break;

			}
            
        }
        else
        {
            return FALSE;
        }
    }

    // If we got to here, then we made it.
    //
    return TRUE;
}

LCID LanguageHelper(char *achLang)
{
    int n;
    LCID lcid;

    n=0;
    while(achLang[n]) 
    {
        achLang[n] = _totupper(achLang[n]);
        n++;
    }

    if (0==_tcscmp(achLang,_T("JPN")))
    {
        lcid = 0x0411;
    }
    else if (0==_tcscmp(achLang,_T("CHT")))
    {
        lcid = 0x0404;
    }
    else if (0==_tcscmp(achLang,_T("CHS")))
    {
       lcid = 0x0804;
    }
    else if (0==_tcscmp(achLang,_T("KOR")))
    {
        lcid = 0x0412;
    }
    else if (0==_tcscmp(achLang,_T("ARA")))
    {
        lcid = 0x0401;
    }
    else if (0==_tcscmp(achLang,_T("HEB")))
    {
        lcid = 0x040D;
    }
    else if (0==_tcscmp(achLang,_T("THA")))
    {
        lcid = 0x041E;
    }
    else if (0==_tcscmp(achLang,_T("GER")))
    {
        lcid = 0x0407;
    }
    else
    {
        assert(0&&"Invalid LANG Enviroment Setting!");
        //lcid = LOCALE_SYSTEM_DEFAULT;
        lcid = GetSystemDefaultLCID();
    }
    return (lcid);
}


//**********Locale _code Page conversion
#define lidSerbianCyrillic 0xc1a

WORD CodePageTable[] = {
/* CodePage		  PLID	primary language
   ------------------------------------- */
	   0,		// 00 -	undefined
	1256,		// 01 - Arabic
	1251,		// 02 - Bulgarian
	1252,		// 03 - Catalan
	 950,		// 04 - Taiwan, Hong Kong (PRC and Singapore are 936)
	1250,		// 05 - Czech
	1252,		// 06 - Danish
	1252,		// 07 - German
	1253,		// 08 - Greek
	1252,		// 09 - English
	1252,		// 0a - Spanish
	1252,		// 0b - Finnish
	1252,		// 0c - French
	1255,		// 0d - Hebrew
	1250,		// 0e - Hungarian
	1252,		// 0f - Icelandic
	1252,		// 10 - Italian
	 932,		// 11 - Japan
	 949,		// 12 - Korea
	1252,		// 13 - Dutch
	1252,		// 14 - Norwegian
	1250,		// 15 - Polish
	1252,		// 16 - Portuguese
	   0,		// 17 -	Rhaeto-Romanic
	1250,		// 18 - Romanian
	1251,		// 19 - Russian
	1250,		// 1a -	Croatian
	1250,		// 1b - Slovak
	1250,		// 1c -	Albanian
	1252,		// 1d - Swedish
	 874,		// 1e - Thai
	1254,		// 1f - Turkish
	   0,		// 20 -	Urdu
	1252,		// 21 - Indonesian
	1251,		// 22 - Ukranian
	1251,		// 23 - Byelorussian
	1250,		// 24 -	Slovenian
	1257,		// 25 - Estonia
	1257,		// 26 - Latvian
	1257,		// 27 - Lithuanian
	   0,		// 28 -	undefined
	1256,		// 29 - Farsi
	   0,		// 2a -	Vietnanese
	   0,		// 2b -	undefined
	   0,		// 2c -	undefined
	1252		// 2d - Basque
				// 2e - Sorbian
				// 2f - Macedonian
				// 30 - Sutu
				// 31 - Tsonga
				// 32 - Tswana
				// 33 - Venda
				// 34 - Xhosa
				// 35 - Zulu
				// 36 - Africaans (uses 1252)
				// 38 - Faerose
				// 39 - Hindi
				// 3a - Maltese
				// 3b - Sami
				// 3c - Gaelic
				// 3e - Malaysian
};

#define nCodePageTable	(sizeof(CodePageTable)/sizeof(CodePageTable[0]))

int  ConvertLCIDtoCodePage(LCID  lcid)	
{
	UINT j = PRIMARYLANGID(lcid);			// j = primary language (PLID)

	if(j >= LANG_CROATIAN)					// PLID = 0x1a
	{
		if(lcid == lidSerbianCyrillic)		// Special case for LID = 0xc1a
			return 1251;					// Use Cyrillic code page

		if(j >= nCodePageTable)				// Africans PLID = 0x36, which
			return j == 0x36 ? 1252 : CP_ACP;	//  is outside table
	}

	j = CodePageTable[j];					// Translate PLID to code page

	if(j != 950 || (lcid & 0x400))			// All but Singapore and PRC
		return j;

	return 936;								// Singapore and PRC
}


BOOL SendDataToClipBoard()
{
    int n;
    char achValue[127];

    n = GetEnvironmentVariable("ClipBoard",achValue,128);
    if (!n)
        return TRUE;
    if (!_stricmp(achValue,"off"))
        return FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stressmon\stressmon.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stressmon.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

VOID WINAPI StressMONStartTest(HANDLE hLog);

namespace StressMON
    {
    extern DWORD stressMode;
    } // namespace StressMON
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\strgen\strgen.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    strgen.c

Abstract:

    Routine to generate random string

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>
#include "strgen.h"


#define MAXRISKCHAR 128


//
// Risky characters: index by primary language ID
//
unsigned char SingleByteRiskChar[][MAXRISKCHAR+1] = {
                // Primary language
    {0},        // 00 - undefined
    {0},        // 01 - Arabic
    {0},        // 02 - Bulgarian
    {0},        // 03 - Catalan
    {0},        // 04 - Taiwan, Hong Kong (PRC and Singapore are 936)
    {0},        // 05 - Czech
    {0},        // 06 - Danish
    {0xE4,0xF6,0xFC,0xC4,0xD6,0xDC,0xDF,0x00 },     // 07 - German
    {0},        // 08 - Greek
    {0},        // 09 - English
    {0},        // 0a - Spanish
    {0},        // 0b - Finnish
    {0},        // 0c - French
    {0},        // 0d - Hebrew
    {0},        // 0e - Hungarian
    {0},        // 0f - Icelandic
    {0},        // 10 - Italian
    {0},        // 11 - Japan
    {0},        // 12 - Korea
    {0},        // 13 - Dutch
    {0},        // 14 - Norwegian
    {0},        // 15 - Polish
    {0},        // 16 - Portuguese
    {0},        // 17 - Rhaeto-Romanic
    {0},        // 18 - Romanian
    {0},        // 19 - Russian
    {0},        // 1a - Croatian
    {0},        // 1b - Slovak
    {0},        // 1c - Albanian
    {0},        // 1d - Swedish
    {0},        // 1e - Thai
    {0},        // 1f - Turkish
    {0},        // 20 - Urdu
    {0},        // 21 - Indonesian
    {0},        // 22 - Ukranian
    {0},        // 23 - Byelorussian
    {0},        // 24 - Slovenian
    {0},        // 25 - Estonia
    {0},        // 26 - Latvian
    {0},        // 27 - Lithuanian
    {0},        // 28 - undefined
    {0},        // 29 - Farsi
    {0},        // 2a - Vietnanese
    {0},        // 2b - undefined
    {0},        // 2c - undefined
    {0}         // 2d - Basque
                // 2e - Sorbian
                // 2f - Macedonian
                // 30 - Sutu
                // 31 - Tsonga
                // 32 - Tswana
                // 33 - Venda
                // 34 - Xhosa
                // 35 - Zulu
                // 36 - Africaans (uses 1252)
                // 38 - Faerose
                // 39 - Hindi
                // 3a - Maltese
                // 3b - Sami
                // 3c - Gaelic
                // 3e - Malaysian
};


//
// This is Japanese/FE risky chars, Need to add locale specfic code
//
unsigned char riskHi[20] = {
    0x81,0x82,0x9F,0xFC,0xE5,0x00

};
unsigned char riskLo[20] = {
    0x5B,0x5C,0x5D,0x7C,0xA1,0xAE,0xBF,0xDF,0xE0,0x40,0xFC,0x00
};

unsigned char InvalidChar[50] = {
    0x20,
    '\\',
    '/',
    ':',
    '<',
    '>',
    '|',
    '.',
    '_',
    '*',
    '+',
    ',',
    '?',
    '"',
    0x00
};


unsigned char OneAsscii(void);
unsigned char HalfDBSC(CPINFO ,char *,BOOL bIsLeadingByte);
BOOL          IsValid(unsigned char *,LCID);
void          EnsureValid(CPINFO,CPINFO,char *,char * ,BOOL , unsigned char *,LCID);
BOOL          IsMET(LCID);
int           StrGenMET(LCID ,int,int,int,unsigned int ,int,int,void **);
int           StrGenOther(LCID ,int,int,int,unsigned int ,int,int,void **);
BOOL          IsFE(LCID);
BOOL          IsValidAnsiString(char *, LCID );
int           THEXVAL(char);
int           StrtoInt(BYTE  , char * );
BOOL          IsValidAnsiString(char *, LCID );
void GenerateFEOneRiskChar(char *,WORD *,LCID,int);
void GerenareOneEuroRisk(char *,WORD *,LCID,int);
BOOL IsValidNETBiosChar(char);


int strgen(LCID lcid,           //Locale ID
           int nStyle,          //0 for ansi 
                                //1 for DBCS  or locale char eg in MET
                                //2 for Mixed
           int length,          //the lenght of string 
                                //0 for random MAX Limit is 255,
                                //-1  for random MAX Limit is 65535,
           int nFormat,         //0: ANSI 1:UNICODE
           unsigned int nSeed,
           int nPresudo,
           int nRisk,
           void **pStr
        )
{
    unsigned char  *achString;
    WCHAR           *awString;
    CPINFO          cpInfoLo,cpInfoHi;
    int i,nNumofChar=0;
    char   *pRiskHi,*pRiskLo;

    
    
        
    if (LOCALE_SYSTEM_DEFAULT == lcid)
        lcid = GetSystemDefaultLCID();
    else if (LOCALE_USER_DEFAULT == lcid)
        lcid = GetUserDefaultLCID();
    if (!IsValidLocale(lcid, LCID_INSTALLED))
    {
       assert(0 && " Not Correct Locale ");
       lcid = GetSystemDefaultLCID();
    }

    srand(nSeed);

    if (IsMET(lcid))
    {
        return StrGenMET(lcid,nStyle,length,nFormat,nSeed,nPresudo,nRisk,pStr);         
    }
    else
    if (!IsFE(lcid))
    {
        return StrGenOther(lcid,nStyle,length,nFormat,nSeed,nPresudo,nRisk,pStr);
    }
#ifdef NEVER
    if (lcid != GetSystemDefaultLCID())//we got the locale from LANG enviroment
    {//This usually means in US NT ,we generate Japanese string
        switch (lcid)
        {
            case 0x0411://Japanese
                cpInfoHi.LeadByte[0] =0x81;
                cpInfoHi.LeadByte[1] =0x9F;
                cpInfoHi.LeadByte[2] =0xE0;
                cpInfoHi.LeadByte[3] =0xFC;
                cpInfoHi.LeadByte[4] =0x00;
                cpInfoHi.LeadByte[5] =0x00;
                break;
            case 0x0804://Simplified  Chinese
                cpInfoHi.LeadByte[0] =0xA1;
                cpInfoHi.LeadByte[1] =0xFE;
                cpInfoHi.LeadByte[2] =0x00;
                cpInfoHi.LeadByte[3] =0x00;
                break;
            case 0x0412://Korea0x0404
                cpInfoHi.LeadByte[0] =0x84;
                cpInfoHi.LeadByte[1] =0xD3;
                cpInfoHi.LeadByte[2] =0xD8;
                cpInfoHi.LeadByte[3] =0xD8;
                cpInfoHi.LeadByte[4] =0xD9;
                cpInfoHi.LeadByte[5] =0xDE;
                cpInfoHi.LeadByte[6] =0xE0;
                cpInfoHi.LeadByte[7] =0xF9;
                cpInfoHi.LeadByte[8] =0x00;
                cpInfoHi.LeadByte[9] =0x00;
                break;
            case 0x0404://Traditional Chinese
                cpInfoHi.LeadByte[0] =0x81;
                cpInfoHi.LeadByte[1] =0xFE;
                cpInfoHi.LeadByte[2] =0x00;
                cpInfoHi.LeadByte[3] =0x00;
                break;
            default:
                assert(0 && "Invalid Enviroment LANG setting");
                nStyle = 0;//non FE NT Generate Ansi string
                break;
        }
        nFormat = 0;//We can only generate ANSI here , since in US NT, there is 
                    //no way to convert our internally ANSI string to Unicode string
    }
    else
#endif
    {
        GetCPInfo(ConvertLCIDtoCodePage(lcid),&cpInfoHi);//Get the Hi byte range    
    }

    if (nRisk)
    {
        pRiskHi = riskHi;
        pRiskLo = riskLo;
    }
    else
    {
        pRiskHi = NULL;
        pRiskLo = NULL;
    }

    //Set the Lobyte range
    //Copy from Developing International Software p65 except S Chinese using GBK range
    switch (lcid)
    {
        case 0x0411://Japanese
            cpInfoLo.LeadByte[0] =0x40;
            cpInfoLo.LeadByte[1] =0xFC;
            cpInfoLo.LeadByte[2] =0x00;
            cpInfoLo.LeadByte[3] =0x00;
            break;
        case 0x0804://Simplified  Chinese
            cpInfoLo.LeadByte[0] =0x40;
            cpInfoLo.LeadByte[1] =0xFE;
            cpInfoLo.LeadByte[2] =0x00;
            cpInfoLo.LeadByte[3] =0x00;
            break;
        case 0x0412://Korea0x0404
            cpInfoLo.LeadByte[0] =0x41;
            cpInfoLo.LeadByte[1] =0x5A;
            cpInfoLo.LeadByte[2] =0x61;
            cpInfoLo.LeadByte[3] =0x7A;
            cpInfoLo.LeadByte[4] =0x81;
            cpInfoLo.LeadByte[5] =0xFE;
            cpInfoLo.LeadByte[6] =0x00;
            cpInfoLo.LeadByte[7] =0x00;
            break;
        case 0x0404://Traditional Chinese
            cpInfoLo.LeadByte[0] =0x40;
            cpInfoLo.LeadByte[1] =0x7E;
            cpInfoLo.LeadByte[2] =0xA1;
            cpInfoLo.LeadByte[3] =0xFE;
            cpInfoLo.LeadByte[4] =0x00;
            cpInfoLo.LeadByte[5] =0x00;
            break;
        default:
            nStyle = 0;//non FE NT Generate Ansi string
            break;
    }
    if (-1 == length)
        length = rand() % 65535 +1;
    else if (0 == length)
        length = rand() % 255 +1 ;
    else if (length<0)
        length = length = rand() % 255 +1 ;
    
    
    achString = (char*) malloc(length+1);
    if (!achString)
        return 2;
    if ( (nStyle <0) || (nStyle >2) )
    {
        assert (0 && "Unknown Style");
        nStyle = 0;
    }


    

    if (0==nStyle)//Pure Asscii
    {
        for (i=0;i<length;i++)
        {
            achString[i]=OneAsscii();
        }
        achString[length]='\0';
        nNumofChar = length;
    }
    else if (1==nStyle)//Pure DBCS
    {
        if (1==length) length++;
        
        for (i=0;i<length;i+=2)
        {
            char achTmp[3];

            EnsureValid(cpInfoHi,cpInfoLo,riskHi,riskLo,!nPresudo, achTmp,lcid);
            
            achString[i]
                = achTmp[0];
            achString[i+1]
                = achTmp[1];
        }
        achString[(length/2) * 2 ]='\0';
        nNumofChar = length / 2;
    }
    else //DBCS and ASCII Mixed
    {
        i=0;
        if (1==length) length++;
        while (i<length)
        {
            nNumofChar ++;
            if ( (rand() %2) && (i+2) <=length) 
            {
                char achTmp[3];
                
                EnsureValid(cpInfoHi,cpInfoLo,riskHi,riskLo,!nPresudo, achTmp,lcid);
                
                achString[i]  = (unsigned char) achTmp[0];
                achString[i+1] = (unsigned char)achTmp[1];
                i+=2;
            }
            else
            {
                achString[i]=OneAsscii();
                i++;
            }
            
        }
        achString[length] = '\0';
    }
    

    //Now achString Contains the Result string in ANSI CodePage
    if ( (0 !=nFormat) && (1 !=nFormat) )
    {
        assert(0 && "unsupported format");
        nFormat = 0;
    }
    if (0 ==nFormat)
    {
        *pStr = achString;
    }
    else
    {
        awString = (WCHAR *) malloc((nNumofChar+1) * sizeof(WCHAR));
        MultiByteToWideChar(ConvertLCIDtoCodePage(lcid),
                        0,
                        achString,
                        -1,
                        awString,
                        nNumofChar+1);
        *pStr = awString;
        free(achString);
    }

    return 0;
}

unsigned char OneAsscii(void)
{
    unsigned char uc ;

    if  (0x0411 == GetSystemDefaultLCID())
    {
        uc = rand() % (0x7F+(0xDF-0xA1+1)-32) + 32;
        if (uc>0x7F)
            uc = uc +(0xa1-0x7f-1);
    }
    else uc =rand() % (128-32)+32; 
    return (uc);
}


unsigned char HalfDBSC(CPINFO cpInfo,char *pRisk,BOOL bIsLeadingByte)
{
    unsigned char uc;
    unsigned int nNum = 0;
    int i = 0;
    unsigned int nNumDue;

    
    if (pRisk)
    {
        if (rand() % 2)
        {
            int n = strlen(pRisk);
            return (pRisk[rand() % n]);
        }
    }//otherwise fall through

    //Calculate the Total Number of Possibilities for the current range .
    while (cpInfo.LeadByte[i])
    {
        nNum = nNum + (cpInfo.LeadByte[i+1] - cpInfo.LeadByte[i] +1);
        i+=2;
    }
    //Generate a random number with this range
    uc =  rand() % nNum;

    //Map the uc to real value
    i=0;
    nNumDue = cpInfo.LeadByte[1] - cpInfo.LeadByte[0];
    
    while (uc > nNumDue )
    {
        i+=2;
        nNumDue = nNumDue + cpInfo.LeadByte[i+1] - cpInfo.LeadByte[i];
    }
    if (!bIsLeadingByte)
    {
        if (0x7f == cpInfo.LeadByte[i]+uc-(nNumDue-(cpInfo.LeadByte[i+1]-cpInfo.LeadByte[i])))
        {
            return (0x7E);
        }
        
    }
    return (cpInfo.LeadByte[i]+uc-(nNumDue-(cpInfo.LeadByte[i+1]-cpInfo.LeadByte[i])));
}



void  EnsureValid(CPINFO cpInfoHi,CPINFO cpInfoLo,char *pRiskHi,char *pRiskLo,BOOL bEnsure, unsigned char *achResult,LCID lcid)
{
    BOOL bNotFinish=1;
    unsigned char achTmp[3];

    achTmp[0] = HalfDBSC(cpInfoHi,pRiskHi,1);
    achTmp[1] = HalfDBSC(cpInfoLo,pRiskLo,0);
    achTmp[2] = '\0';
    
    if (!bEnsure)
    {
        achResult[0] = achTmp[0];
        achResult[1] = achTmp[1];
        return ;
    }

    while (!IsValid(achTmp,lcid))
    {
        achTmp[0] = HalfDBSC(cpInfoHi,pRiskHi,1);
        achTmp[1] = HalfDBSC(cpInfoLo,pRiskLo,0);
        achTmp[2] ='\0';
    }

    achResult[0] = achTmp[0];
    achResult[1] = achTmp[1];
    return ;
}

BOOL IsValid(unsigned char *sour,LCID lcid)
{
    unsigned char achResult[16];
    WCHAR         wResult[16];
    int a;
    
    a = MultiByteToWideChar(ConvertLCIDtoCodePage(lcid),
                        0,
                        sour,
                        -1,
                        wResult,
                        16);
    if (!a)
        return (FALSE);

    a = WideCharToMultiByte(
        ConvertLCIDtoCodePage(lcid),
        0,
        wResult,
        -1,
        achResult,
        16,
        NULL,
        NULL );

    if (!a)
        return (FALSE);

    if ( strcmp(sour,achResult))
    {
        return (FALSE);

    }
    return (TRUE);
}

int StrGenMET(LCID lcid,           //Locale ID               
               int nStyle,          //0 for ansi 
                                    //1 for DBCS and 2 for Mixed
               int length,          //the lenght of string 
                                //0 for random MAX Limit is 255,
                                //-1  for random MAX Limit is 65535,
               int nFormat,         //0: ANSI 1:UNICODE
               unsigned int nSeed,
               int nPresudo,
               int nRisk,
               void **pStr
                )
{
    unsigned char  *achString;
    WCHAR           *awString;
    WORD UniocdeRangeUpper,UniocdeRangeLower;
    int i,nNumofChar=0;


    if (-1 == length)
        length = rand() % 65535 +1;
    else if (0 == length)
        length = rand() % 255 +1 ;
    else if (length<0)
        length = length = rand() % 255 +1 ;

    if ( (0 !=nFormat) && (1 !=nFormat) )
    {
        assert(0 && "unsupported format");
        nFormat = 0;
    }
    
    if (nFormat)
    {
        awString = (WCHAR *) malloc(sizeof(WCHAR)*(length+1));
        if (!awString)
            return 2;
        if  (LANG_ARABIC == LOBYTE(lcid)) 
        {
            UniocdeRangeUpper=0x06FF;
            UniocdeRangeLower=0x0600;
        }
        else if (0x040D == lcid)  //Hebrew
        {
            UniocdeRangeUpper=0x05FF;
            UniocdeRangeLower=0x0590;
        }
        else
        {
            UniocdeRangeUpper = 0x0E7F;
            UniocdeRangeLower = 0x0E00;
        }

    }
    else
    {
        achString = (char*) malloc(length+1);
        if (!achString)
            return 2;
    }
    
    if ( (nStyle <0) || (nStyle >2) )
    {
        assert (0 && "Unknown Style");
        nStyle = 0;
    }


    if (0==nStyle)//Pure Asscii
    {
        for (i=0;i<length;i++)
        {
            if (nFormat)
                awString[i] = rand() % (128-32)+32; 
            else
                achString[i] = rand() % (128-32)+32; 
        }
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';

        nNumofChar = length;
    }
    else if (1==nStyle)//Pure locale string
    {
        if (1==length) length++;
        
        for (i=0;i<length;i++)
        {
            if (nFormat)
                awString[i] = rand() % (UniocdeRangeUpper-UniocdeRangeLower+1)+UniocdeRangeLower; 
            else
                achString[i] = rand() % (0xFF-0x80 +1 )+0x80;            
        }
        
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';
        nNumofChar = length ;
    }
    else //locale char  and ASCII Mixed
    {
        i=0;
        if (1==length) length++;
        while (i<length)
        {
            if (rand() %2)
            {
                if (nFormat)
                    awString[i] = rand() % (128-32)+32; 
                else
                    achString[i] = rand() % (128-32)+32; 
            }
            else
            {
                if (nFormat)
                    awString[i] = rand() % (UniocdeRangeUpper-UniocdeRangeLower+1)+UniocdeRangeLower; 
                else
                    achString[i] = rand() % (0xFF-0x80 +1 )+0x80;            
            }
            i++;
        }
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';
        nNumofChar = length ;
    } 

    if (0 ==nFormat)
    {
        *pStr = achString;
    }
    else
    {       
        *pStr = awString;
    }

    return 0;
}

BOOL IsMET(LCID lcid)  //return TRUE if it is ARA HEB and THA
{
        if ( (LANG_ARABIC == LOBYTE(lcid)) //Arabic, since too many Arbic locale
            || (0x040D == lcid)  //Hebrew
            || (0x041E == lcid))  //Thai
            return TRUE;
        return FALSE;
            
}


BOOL IsFE(LCID lcid)  //return TRUE if it is CJK
{
    //CJK
        if ( (LANG_CHINESE == LOBYTE(lcid)) //Chinese
            || (LANG_JAPANESE == LOBYTE(lcid))  //japanese
            || (LANG_KOREAN == LOBYTE(lcid)))  //Korean
            return TRUE;
        return FALSE;
            
}




int StrGenOther(LCID lcid,           //Locale ID               
               int nStyle,          //0 for ansi 
                                    //1 for DBCS and 2 for Mixed
               int length,          //the lenght of string 
                                //0 for random MAX Limit is 255,
                                //-1  for random MAX Limit is 65535,
               int nFormat,         //0: ANSI 1:UNICODE
               unsigned int nSeed,
               int nPresudo,
               int nRisk,
               void **pStr
                )
{
    unsigned char  *achString;
    WCHAR           *awString;
    WORD UniocdeRangeUpper,UniocdeRangeLower;
    int i,nNumofChar=0;


    if (-1 == length)
        length = rand() % 65535 +1;
    else if (0 == length)
        length = rand() % 255 +1 ;
    else if (length<0)
        length = length = rand() % 255 +1 ;

    if ( (0 !=nFormat) && (1 !=nFormat) )
    {
        assert(0 && "unsupported format");
        nFormat = 0;
    }
    
    if (nFormat)
    {
        awString = (WCHAR *) malloc(sizeof(WCHAR)*(length+1));
        if (!awString)
            return 2;
        if  (LANG_GERMAN == LOBYTE(lcid)) 
        {
            UniocdeRangeUpper=0x0000;
            UniocdeRangeLower=0x00FF;
        }
        else
        {
            return 2;
        }

    }
    else
    {
        achString = (char*) malloc(length+1);
        if (!achString)
            return 2;
    }
    
    if ( (nStyle <0) || (nStyle >2) )
    {
        assert (0 && "Unknown Style");
        nStyle = 0;
    }


    if (0==nStyle)//Pure Asscii
    {
        for (i=0;i<length;i++)
        {
            if (nFormat)
                awString[i] = rand() % (128-32)+32; 
            else
                achString[i] = rand() % (128-32)+32; 
        }
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';

        nNumofChar = length;
    }
    else if (1==nStyle)//Pure locale string
    {
        if (1==length) length++;
        
        for (i=0;i<length;i++)
        {
            if (nFormat)
                awString[i] = rand() % (UniocdeRangeUpper-UniocdeRangeLower+1)+UniocdeRangeLower; 
            else
                achString[i] = rand() % (0xFF-0x80 +1 )+0x80;            
        }
        
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';
        nNumofChar = length ;
    }
    else //locale char  and ASCII Mixed
    {
        i=0;
        if (1==length) length++;
        while (i<length)
        {
            if (rand() %2)
            {
                if (nFormat)
                    awString[i] = rand() % (128-32)+32; 
                else
                    achString[i] = rand() % (128-32)+32; 
            }
            else
            {
                if (nFormat)
                    awString[i] = rand() % (UniocdeRangeUpper-UniocdeRangeLower+1)+UniocdeRangeLower; 
                else
                    achString[i] = rand() % (0xFF-0x80 +1 )+0x80;            
            }
            i++;
        }
        if (nFormat)
            awString[length]=0;
        else
            achString[length]='\0';
        nNumofChar = length ;
    } 

    if (0 ==nFormat)
    {
        *pStr = achString;
    }
    else
    {       
        *pStr = awString;
    }

    return 0;
}

int PassString(char *pString,int fUnicode,void **pStr,BOOL *pfValid,LCID lcid)
{
    int nLen;
    BYTE *pByte,HiByte,LoByte;
    char * pTmpString;
    int n,n1;
    char achOneChar[10];
    char ach;
    WORD *pWord;

    nLen = strlen(pString);
    pTmpString = malloc ( (nLen +4) * sizeof(BYTE) );
    if (!pTmpString)
        return FALSE;

    if (fUnicode)
    {
        //If it's Unicode, the only invalide case is odd byte lenth

        if (nLen % 4)
            *pfValid = 0;
        else
        {
            *pfValid = 1;        
        }
        n1=0;
        n = 0;
        pWord = (WORD*) pTmpString;

        while (n<nLen-nLen % 4)
        {
            strncpy(achOneChar,&(pString[n]),4);
            achOneChar[4]=0;
            pWord[n1] =  (WCHAR) StrtoInt(16 , achOneChar);
            n+=4;
            n1++;
        }
        // the last nLen %4 got clipped 
        // BUGBUG do we need to generate such invalid unciode string anyway ???
        pWord[n1]=0;
    }
    else// it's ANSI
    {
        if (!IsFE(lcid))
        {
            *pfValid = 1;            
        }
        else
        {
            *pfValid  = IsValidAnsiString(pString,lcid);
        }
        if (nLen % 2 )
        {
            nLen--;
        }

        n1=0;
        n=0;
        while (n<nLen)
        {
            strncpy(achOneChar,&(pString[n]),2);
            achOneChar[2]=0;            

            HiByte = (BYTE)StrtoInt(16 , achOneChar);
            pTmpString[n1] = HiByte;
            n1++;
            n+=2;
            if (IsDBCSLeadByteEx(ConvertLCIDtoCodePage(lcid),HiByte))
            {
                if (n+2>nLen)
                {
                    n1--;
                    pTmpString[n1] = 0;
                    break;
                }
                else
                {
                    strncpy(achOneChar,&(pString[n]),2);
                    achOneChar[2]=0;            
                    pTmpString[n1] =  (CHAR)StrtoInt(16,achOneChar);
                    
                    n1++;
                    n+=2;
                }
            }
        }
        pTmpString[n1] = 0;
    }
    
    *pStr = (void*)pTmpString;
    return TRUE;
}

BOOL IsValidAnsiString(char *pString, LCID lcid)
{
    int nLen,n;
    char achOneChar[3];
    char ach;

    if (!IsFE(lcid))
        return TRUE;

    nLen = strlen(pString);
    if (nLen % 2) 
        return FALSE;

    n=0;

    while (n < nLen )
    {
        strncpy(achOneChar,&(pString[n]),2);
        achOneChar[2]=0;
        ach =  (char)StrtoInt(16,achOneChar);

        if (IsDBCSLeadByteEx(ConvertLCIDtoCodePage(lcid),ach))
        {
            //BUGBUG Here do we need to take care trailing byte
            n+=4;
        }
        else
        {
            n+=2;
        }
    }
    if (n==nLen)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

int   StrtoInt(BYTE bBase , char * pHexString)
{
    char *pStr = pHexString;
    int  nSum = 0;

    while (*pStr)
    {            
        nSum = nSum*bBase + THEXVAL(*pStr);
        pStr++;
    }
    return (nSum);
}

int THEXVAL(char tch)
{
    int val ;

    if  (tch>='a') 
        val = tch -'a' + 10;
    else if (tch>='A')
        val = tch -'A' + 10;
    else val = tch -'0';

    return (val);
}

void GenerateFEOneRiskChar(char *pchRisk,WORD *pwUnicode,LCID lcid,int nStyle)
{
    CPINFO cpInfoHi , cpInfoLo;
    WCHAR wTmp[10];
    int a;

    GetCPInfo(ConvertLCIDtoCodePage(lcid),&cpInfoHi);//Get the Hi byte range    

    cpInfoLo.LeadByte[0] =0x40;
    cpInfoLo.LeadByte[1] =0xFC;
    cpInfoLo.LeadByte[2] =0x00;
    cpInfoLo.LeadByte[3] =0x00;

    if (rand() %2 == 1 )
    {
        pchRisk[0] = riskHi[rand() % strlen(riskHi)];
        if (SG_STYLE_NETBIOS == nStyle)
        {
            while (!IsValidNETBiosChar(pchRisk[0]))
            {
                pchRisk[0] = riskHi[rand() % strlen(riskHi)];
            }
        }
        pchRisk[1] = HalfDBSC(cpInfoLo,NULL,0);
        if (SG_STYLE_NETBIOS == nStyle)
        {
            while (!IsValidNETBiosChar(pchRisk[1]))
            {
                pchRisk[1] = HalfDBSC(cpInfoLo,NULL,0);
            }
        }
    }
    else
    {
        pchRisk[0] = HalfDBSC(cpInfoHi,NULL,1);
        if (SG_STYLE_NETBIOS == nStyle)
        {
            while (!IsValidNETBiosChar(pchRisk[0]))
            {
                pchRisk[0] = HalfDBSC(cpInfoHi,NULL,0);
            }
        }
        pchRisk[1] = riskLo[rand() % strlen(riskLo)];
        if (SG_STYLE_NETBIOS == nStyle)
        {
            while (!IsValidNETBiosChar(pchRisk[1]))
            {
                pchRisk[1] = riskLo[rand() % strlen(riskLo)];
            }
        }
    }
    pchRisk[2]=0;

    *pwUnicode = 0xFFFF;

    
    a = MultiByteToWideChar(ConvertLCIDtoCodePage(lcid),
                            0,
                            pchRisk,
                            -1,
                            wTmp,
                            10);
    if (!a)
        return;

    *pwUnicode = (WORD) wTmp[0];
    return ;
}

void GerenareOneEuroRisk(char *pchRisk,WORD *pwUnicode,LCID lcid,int nStyle)
{
    WCHAR wTmp[10];
    int a;
    unsigned char achRisk[MAXRISKCHAR+1];

    
    UINT j;
    
    j = PRIMARYLANGID(lcid);            // j = primary language (PLID)

    if (SingleByteRiskChar[j][0])
    {
        strcpy(achRisk,SingleByteRiskChar[j]);
    }
    else
    {
        unsigned char  i;
        for (i=0;i<0x80;i++)
        {
            achRisk[i]=i+0x80;
        }
        achRisk[0x80]=0;

    }

    pchRisk[0] = achRisk[rand() % strlen(achRisk)];
    if (SG_STYLE_NETBIOS == nStyle)
    {
        while (!IsValidNETBiosChar(pchRisk[0]))
        {
            pchRisk[0] = achRisk[rand() % strlen(achRisk)];
        }
    }
    pchRisk[1]=0;

    *pwUnicode = 0xFFFF;
    
    
    a = MultiByteToWideChar(ConvertLCIDtoCodePage(lcid),
                            0,
                            pchRisk,
                            -1,
                            wTmp,
                            10);
    if (!a)
        return;

    *pwUnicode = (WORD) wTmp[0];
    return ;
}

void  GenerateFERiskString(char **pchRisk,WORD **pwUnicode,int nNumofChar,LCID lcid,int nStyle)
{
    int i;

    if (nNumofChar<=0)
        nNumofChar=1;

    *pchRisk = malloc((nNumofChar+1)*2*sizeof(char));
    if (!*pchRisk)
    {
        goto Error;
    }
    *pwUnicode = malloc((nNumofChar+1)*sizeof(WORD));
    if (!*pchRisk)
    {
        goto Error;
    }
    for (i=0;i<2*nNumofChar;i=i+2)
    {
        char achOne[3];
        WORD wUni;
        GenerateFEOneRiskChar(achOne,&wUni,lcid,nStyle);
        (*pchRisk)[i] = achOne[0];
        (*pchRisk)[i+1] = achOne[1];
        (*pwUnicode)[i / 2 ]=wUni;
    }
    (*pchRisk)[2*nNumofChar]=0;
    (*pwUnicode)[nNumofChar ]=0;
    return;

Error:
     if (!*pchRisk)
     {
         free( *pchRisk);
          *pchRisk = NULL;
     }
}

void GenerateEuroRiskString(char **pchRisk,WORD **pwUnicode,int nNumofChar,LCID lcid,int nStyle)
{
    int i;

    if (nNumofChar<=0)
        nNumofChar=1;

    *pchRisk = malloc((nNumofChar+1)*sizeof(char));
    if (!*pchRisk)
    {
        goto Error;
    }
    *pwUnicode = malloc((nNumofChar+1)*sizeof(WORD));
    if (!*pchRisk)
    {
        goto Error;
    }
    
    for (i=0;i<nNumofChar;i++)
    {
        char achOne[2];
        WORD wUni;
        GerenareOneEuroRisk(achOne,&wUni,lcid,nStyle);
        (*pchRisk)[i] = achOne[0];
        (*pwUnicode)[i]=wUni;
    }
    (*pchRisk)[nNumofChar]=0;
    (*pwUnicode)[nNumofChar]=0;
    return;

Error:
     if (!*pchRisk)
     {
         free( *pchRisk);
          *pchRisk = NULL;
     }
}


void GenerateMixRiskString(LCID *plcidArray,//LCID Array, Ended with 0x00
                          WCHAR **pWStr, //String generated , always in unciode
                          int nNumofChar,//number of char
                          int nStyle) //Whether exclude those not valid for netbios name 
{
    int i;
    int nNumofLCID;

    if (nNumofChar<=0)
        nNumofChar=1;

    nNumofLCID = 0;
    while (plcidArray[nNumofLCID]) nNumofLCID++;

    *pWStr = malloc((nNumofChar+1)*sizeof(WCHAR));
    if (!*pWStr)
    {
        return;
    }

    for (i=0;i<nNumofChar;i++)
    {
        char achOne[3];
        WCHAR wUni;

        if ( ISFELocale(plcidArray[i % nNumofLCID]) )
        {
            GenerateFEOneRiskChar(achOne,&wUni,plcidArray[i % nNumofLCID],nStyle);
        }
        else
        {
            GerenareOneEuroRisk(achOne,&wUni,plcidArray[i % nNumofLCID],nStyle);
        }
        (*pWStr)[i] = wUni;            
    }
    (*pWStr)[i] = 0;  
    return;

}


BOOL IsValidNETBiosChar(char ch)
{
    return (!strchr(InvalidChar,ch));
}


BOOL ISFELocale(LCID lcid)
{
    UINT j = PRIMARYLANGID(lcid);           // j = primary language (PLID)

    if ( (LANG_CHINESE == j)
          || (LANG_JAPANESE == j)
          || (LANG_KOREAN == j) )
          return TRUE ;
    else  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\syncsrv\nt\syncsrv.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  syncsrv.c

Abstract:

  This module runs a Netsync server

Author:

  Steven Kehrli (steveke) 3-Oct-2000

------------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <netsync.h>



VOID
DisplayUsageInfo(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Displays the usage info in stdout

Return Value:

  None

------------------------------------------------------------------------------*/
{
    wprintf(L"Starts a Netsync server.\n");
    wprintf(L"\n");
    wprintf(L"SYNCSRV\n");
    wprintf(L"\n");
}



int _cdecl
wmain(
    INT    argc,
    WCHAR  *argvW[]
)
{
    // cInput is the character input from the console
    int    cInput;
    // dwLastError is the last error code
    DWORD  dwLastError = ERROR_SUCCESS;

    if (1 < argc) {
        DisplayUsageInfo();
        goto ExitMain;
    }

    wprintf(L"Starting the Netsync server...\n");

    if (FALSE == NetsyncCreateServer()) {
        dwLastError = GetLastError();
        wprintf(L"Start failed: 0x%08x\n", dwLastError);
        goto ExitMain;
    }

    wprintf(L"Started.\n\n");
    
    wprintf(L"Press 'X' to stop.\n\n");

    do {
        cInput = _getch();
    } while (('x' != cInput) && ('X' != cInput));

    wprintf(L"Stopping the Netsync server...\n");

    NetsyncCloseServer();

    wprintf(L"Stopped.\n");

ExitMain:
    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\syncsrv\xbox\syncsrv.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  syncsrv.c

Abstract:

  This module runs a Netsync server

Author:

  Steven Kehrli (steveke) 3-Oct-2000

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#include <xtl.h>

#include <netsync.h>



int WINAPI NetsyncMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR szCmdLine, int iCmdShow)
{
    // hDevices is an array of handles to the devices
    HANDLE        hDevices[4];
    // dwCurrentDevice is a counter to enumerate each device
    DWORD         dwCurrentDevice = 0;
    // dwInsertions is a bit mask of device insertions
    DWORD         dwInsertions;
    // dwRemovals is a bit mask of device removals
    DWORD         dwRemovals;
    // XInputState is the current device state
    XINPUT_STATE  XInputState;
    // bXPressed indicates if the X button has been pressed
    BOOL          bXPressed = FALSE;
    // dwLastError is the last error code
    DWORD         dwLastError = ERROR_SUCCESS;

    // Initialize the USB stack
    XInitDevices(0,NULL);

    // Initialize the array of device handles
    ZeroMemory(hDevices, sizeof(HANDLE) * XGetPortCount());

    DbgPrint("Starting the Netsync server...\n");

    if (FALSE == NetsyncCreateServer()) {
        dwLastError = GetLastError();
        DbgPrint("Start failed: 0x%08x\n", dwLastError);
        goto ExitMain;
    }

    DbgPrint("Started.\n\n");
    
    DbgPrint("Press 'X' to stop.\n\n");

    do {
        // Get for hotplug insertions or removals
        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Close the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                XInputClose(hDevices[dwCurrentDevice]);
                hDevices[dwCurrentDevice] = NULL;
            }

            // Open the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                hDevices[dwCurrentDevice] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + dwCurrentDevice, XDEVICE_NO_SLOT, NULL);
            }

            // Get the current device state
            if (NULL != hDevices[dwCurrentDevice]) {
                XInputGetState(hDevices[dwCurrentDevice], &XInputState);
                if (0 != XInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]) {
                    bXPressed = TRUE;
                    break;
                }
            }
        }
    } while (FALSE == bXPressed);

    // Close any open devices
    for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
        if (NULL != hDevices[dwCurrentDevice]) {
            XInputClose(hDevices[dwCurrentDevice]);
        }
    }

    DbgPrint("Stopping the Netsync server...\n");

    NetsyncCloseServer();

    DbgPrint("Stopped.\n");

ExitMain:
    DbgPrint("Rebooting...\n");

    // Reboot
    HalReturnToFirmware(HalRebootRoutine);

    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\stressmon\stressmon.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stressmon.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xtl.h>
#include <xbdm.h>
#include "StressMON.h"
#include "xtestlib.h"
#include "xnetref.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <xbeimage.h>
extern "C"
    {
    #include <init.h>
    }
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))


//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//
static ULONG ThreadID = 0;

//
// Heap handle from HeapCreate
//
HANDLE StressMONHeapHandle;


extern "C"
    {
    DECLSPEC_IMPORT
    void
    WINAPI
    HalReadWritePCISpace(
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG RegisterNumber,
        IN PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN WritePCISpace
        );
    #define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
        HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );

    void*
    WINAPI
    MmMapIoSpace(
        IN ULONG_PTR PhysicalAddress,
        IN SIZE_T NumberOfBytes,
        IN ULONG Protect
        );

    void
    WINAPI
    MmUnmapIoSpace(
        IN PVOID BaseAddress,
        IN SIZE_T NumberOfBytes
        );
    }

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

FORCEINLINE ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
    {
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
    }

namespace StressMON
    {
    DWORD stressMode = 0;

    static DWORD WriteSMC(unsigned char addr, unsigned char value)
        {
        return HalWriteSMBusValue(0x20, addr, FALSE, value);
        }

    static DWORD ReadSMC(unsigned char addr)
        {
        DWORD value = 0xCCCCCCCC;
        DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
        return value;
        }

    static const char * const vmodes[] =
        {
        "SDTV%20SCART%20Analog/Digital",
        "HDTV",
        "VGA",
        "RFU",
        "SDTV%20Analog/Digital",
        "Power%20Off",
        "SDTV%20Analog",
        "No%20Pack",
        "SMC%20Error"
        };

    static const char * const hwversions[] =
        {
        "Unknown",                  // 0
        "DVT3(old)",                // 1
        "DVT3(new)",                // 2
        "DVT4/5",                   // 3
        "DVT6",                     // 4
        "QT"                        // 5
        };

    static const char * const lang[] = 
        {
        "Unknown",
        "English",
        "Japanese",
        "German",
        "French",
        "Spanish",
        "Italian"
        };

    static const char * const videostd[] =
        {
        "Unknown",
        "NTSC_M",
        "NTSC_J",
        "PAL_I"
        };

    static char* GetHWVersion(unsigned &hwver);
    static void DumpClocks(char *buffer, unsigned hwver);
    void GetPeripheral(char *buffer);
    void GetDriveID(char* device, char* model, char* serial, char* firmware);
    } // namespace StressMON


BOOL WINAPI StressMONDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        StressMONHeapHandle = HeapCreate(0, 0, 0);

        if(!StressMONHeapHandle)
            {
            OutputDebugString(L"StressMON: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(StressMONHeapHandle)
            {
            HeapDestroy(StressMONHeapHandle);
            }
        }

    return TRUE;
    }





/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI StressMONStartTest(HANDLE hLog)
    {
    DWORD ID = 0;
    ID = InterlockedIncrement((LPLONG) &ThreadID);

    // Initialize the network
    unsigned short version = MAKEWORD(2, 2);
    WSADATA wsaData;
    XNetAddRef();
    Sleep(5000); // Because XNetStartup isnt fully started up when the API returns
    WSAStartup(version, &wsaData);

    // pull server IP from testini.ini
    char serverIP[32];
    memset(serverIP, 0, 32);
    GetProfileStringA("StressMON", "server", "172.26.172.13", serverIP, 32);


    // post settings
    unsigned baseInitTable = 0;
    bool multiple=false;
    char data[2048];
    char post[2048];
    char machineName[40];
    char machineIP[40];
    char peripherals[1024];
    char smcver[4];
    char amode[128];
    char vmode[128];
    char memtype[32];
    char hwflags[64];
    char *hwver;
    char clocks[255];
    char cdModel[64], cdSerial[64], cdFirmware[64];
    char hdModel[64], hdSerial[64], hdFirmware[64];

    while(1)
        {
        data[0] = '\0';
        post[0] = '\0';
        machineName[0] = '\0';
        machineIP[0] = '\0';
        peripherals[0] = '\0';
        smcver[0] = '\0';
        amode[0] = '\0';
        vmode[0] = '\0';
        cdModel[0] = '\0';
        cdSerial[0] = '\0';
        cdFirmware[0] = '\0';
        hdModel[0] = '\0';
        hdSerial[0] = '\0';
        hdFirmware[0] = '\0';
        hwflags[0] = '\0';
        clocks[0] = '\0';

        // get machine name 
        DWORD temp=40;
        ZeroMemory(machineName, 40);
        DmGetXboxName(machineName, &temp);

        // get IP address
        XNADDR xnaddr;
        XNetGetDebugXnAddr(&xnaddr);
        sprintf(machineIP, "%d.%d.%d.%d", xnaddr.ina.S_un.S_un_b.s_b1, xnaddr.ina.S_un.S_un_b.s_b2, xnaddr.ina.S_un.S_un_b.s_b3, xnaddr.ina.S_un.S_un_b.s_b4);

        // get SMC version
        smcver[0] = (char)StressMON::ReadSMC(0x01);
        smcver[1] = (char)StressMON::ReadSMC(0x01);
        smcver[2] = (char)StressMON::ReadSMC(0x01);
        smcver[3] = '\0';

        // hw version
        hwver = StressMON::GetHWVersion(baseInitTable);

        // get clock speeds
        StressMON::DumpClocks(clocks, baseInitTable);

        // get disk manufacturer
        StressMON::GetDriveID("\\Device\\CdRom0", cdModel, cdSerial, cdFirmware);
        StressMON::GetDriveID("\\Device\\Harddisk0\\Partition0", hdModel, hdSerial, hdFirmware);

        // get memory type
        #define NV_PEXTDEV_BOOT_0                                0x00101000 // private\windows\directx\dxg\d3d8\se\nv_ref_2a.h
        #define XPCICFG_GPU_MEMORY_REGISTER_BASE_0               0xFD000000 // private\ntos\inc\xpcicfg.h
        if((REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PEXTDEV_BOOT_0) & 0x0000C0000) == 0) sprintf(memtype, "Micron");
        else sprintf(memtype, "Samsung");

        // hw config
        if(XboxHardwareInfo->Flags & XBOX_HW_FLAG_INTERNAL_USB_HUB)
            strcat(hwflags, "USB%%20HUB");

        // get video settings
        DWORD avpack = StressMON::ReadSMC(0x04);
        if(avpack > 8) avpack = 8; // ReadSMC() can return 0xCCCCCCCC on error
        DWORD language = XGetLanguage();
        if(language >= ARRAYSIZE(StressMON::lang)) language = 0;
        DWORD vidStd = XGetVideoStandard();
        if(vidStd >= ARRAYSIZE(StressMON::videostd)) vidStd = 0;
        DWORD vidFlags = XGetVideoFlags();
        multiple=false;
        strcat(vmode, "(");
        if(vidFlags & XC_VIDEO_FLAGS_WIDESCREEN) multiple = !!strcat(vmode, "WIDE");
        if(multiple) multiple = !strcat(vmode, ",%%20");
        if(vidFlags & XC_VIDEO_FLAGS_HDTV_720p) multiple = !!strcat(vmode, "720p");
        if(multiple) multiple = !strcat(vmode, ",%%20");
        if(vidFlags & XC_VIDEO_FLAGS_HDTV_1080i) multiple = !!strcat(vmode, "1080i");
        if(multiple) multiple = !strcat(vmode, ",%%20");
        if(vidFlags & XC_VIDEO_FLAGS_LETTERBOX) multiple = !!strcat(vmode, "LETTERBOX");
        if(multiple) multiple = !strcat(vmode, ",%%20");
        if(vidFlags & XC_VIDEO_FLAGS_PAL_60Hz) multiple = !!strcat(vmode, "PAL60Hz");
        strcat(vmode, ")");

        // get audio settings
        DWORD audioFlags = XGetAudioFlags();
        multiple=false;
        if(audioFlags & XC_AUDIO_FLAGS_SURROUND) multiple = !!strcat(amode, "SURROUND");
        if(multiple) multiple = !strcat(amode, ",%%20");
        if(audioFlags & XC_AUDIO_FLAGS_STEREO) multiple = !!strcat(amode, "STEREO");
        if(multiple) multiple = !strcat(amode, ",%%20");
        if(audioFlags & XC_AUDIO_FLAGS_MONO) multiple = !!strcat(amode, "MONO");
        if(multiple) multiple = !strcat(amode, ",%%20");
        if(audioFlags & XC_AUDIO_FLAGS_ENABLE_AC3) multiple = !!strcat(amode, "AC3");
        if(multiple) multiple = !strcat(amode, ",%%20");
        if(audioFlags & XC_AUDIO_FLAGS_ENABLE_DTS) multiple = !!strcat(amode, "DTS");

        // get peripherals
        StressMON::GetPeripheral(peripherals);


        // Pull out internal INI file settings
        DebugPrint("STRESSMON: **************************************************************\n");
        DebugPrint("STRESSMON: server=%s\n", serverIP);

        // create socket \ connect to server
        SOCKET sock = socket(PF_INET, SOCK_STREAM, 0);
        SOCKADDR_IN dest;
        dest.sin_family = PF_INET;
        dest.sin_port = htons(80);
        dest.sin_addr.s_addr = inet_addr(serverIP);

        if(connect(sock, (SOCKADDR*)&dest, sizeof(SOCKADDR)) == SOCKET_ERROR)
            {
            DebugPrint("STRESSMON: connect error: (ec: %u)\n", GetLastError());
            }
        else
            {
            unsigned length, dataLen;

            length = sprintf(post, 
                            "machine=%s&"
                            "dbgIP=%s&"
                            "romver=%u.%s&"
                            "swver=%u.%s&"
                            "hwver=%s%%20%s,%%20SMC%%3D%s,%%20GPU%%3D%X,%%20MCP%%3D%X&"
                            "speed=%s&"
                            "hwcfg=MEM%%3D%s,%%20DVD%%3D%s(%s),%%20HD%%3D%s(%s),%%20Flags(%s)&"
                            "vmode=AVPACK%%3D%s,%%20LANG%%3D%s,%%20STD%%3D%s,%%20MODE%%3D%s&"
                            "amode=%s&"
                            "smc=CPUTemp%%3D%d,%%20AIRTemp%%3D%d,%%20Fan%%3D%d,%%20Error%%3D%d&"
                            "periph=%s",
                            machineName, 
                            machineIP, 
                            XboxKrnlVersion->Build, (!!(0x8000 & XboxKrnlVersion->Qfe))?"checked":"free",
                            XeImageHeader()->XapiLibraryVersion->BuildVersion, XeImageHeader()->XapiLibraryVersion->DebugBuild?"checked":"free",
                            hwver, (XboxHardwareInfo->Flags&XBOX_HW_FLAG_DEVKIT_KERNEL)?"DEVKIT":"RETAIL", smcver, XboxHardwareInfo->GpuRevision, XboxHardwareInfo->McpRevision, 
                            clocks,
                            memtype, cdModel, cdFirmware, hdModel, hdFirmware, hwflags,
                            StressMON::vmodes[avpack], StressMON::lang[language], StressMON::videostd[vidStd], vmode,
                            amode,
                            StressMON::ReadSMC(0x09), StressMON::ReadSMC(0x0A), StressMON::ReadSMC(0x10), StressMON::ReadSMC(0x0F),
                            peripherals);
            dataLen = sprintf(data, 
                            "POST /lab/submit/ping.asp HTTP/1.1\r\n"
                            "Accept: */*\r\n"
                            "User-Agent: StressMON\r\n"
                            "Connection: Close\r\n"
                            "Host: %s\r\n"
                            "Content-Length: %u\r\n"
                            "Content-Type: application/x-www-form-urlencoded\r\n"
                            "\r\n"
                            "%s",
                            serverIP,
                            length,
                            post);


            DWORD err = send(sock, data, dataLen, 0);
            //DebugPrint("STRESSMON: post: %s\n", post);
            //DebugPrint("STRESSMON: sent %u, (ec: %u)\n", err, GetLastError());
            //err = recv(sock, data, 256, 0);
            //data[err] = '\0';
            //DebugPrint("%s\n", data);

            shutdown(sock, SD_BOTH);
            }

        closesocket(sock);

        DWORD waitTime = 5*60*1000; // wait 5 min
        while(waitTime > 0)
            {
            StressMON::GetPeripheral(peripherals);
            waitTime -= 1000;
            Sleep(1000); // sleep 1 sec
            }
        }

    WSACleanup();
    XNetRelease();
    }


// TODO can remove this code when bug is fixed
void DukeZerosBug(void)
    {
    DebugPrint("\r\n\r\n\r\n\r\n");
    DebugPrint("*****************************************************************************\r\n");
    DebugPrint("Encountered Duke Zeros Bug: Please notify jeffalex\r\n");
    DebugPrint("*****************************************************************************\r\n");
    __asm int 3;
    }


void StressMON::DumpClocks(char *buffer, unsigned hwver)
    {
    #define NV_PRAMDAC_NVPLL_COEFF 0x00680500 /* RW-4R */
    const float F_XTAL_135 = 13.5f;
    const float F_XTAL_166 = 16.6667f;

    PCI_SLOT_NUMBER SlotNumber;
    DWORD MPLLCoeff;
    DWORD m;
    DWORD n;
    DWORD p;
    DWORD fsbspeed;
    DWORD vcofreq;
    DWORD nvclk;
    DWORD nvpll;
    DWORD fsb_pdiv;
    DWORD mem_pdiv;
    DWORD mclk;
    DWORD cpuspeed;
    float XTAL;

    if(hwver >= 0x46) 
        {
        XTAL = F_XTAL_166;
        }
    else
        {
        XTAL = F_XTAL_135;
        }

    //
    // Read CR_CPU_MPLL_COEFF 
    //
    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = 0;
    SlotNumber.u.bits.FunctionNumber = 3;
    HalReadPCISpace(0, SlotNumber.u.AsULONG, 0x6C, &MPLLCoeff, sizeof(MPLLCoeff));

    m = MPLLCoeff & 0xFF;
    n = (MPLLCoeff >> 8) & 0xFF;

    if(m != 0)
        {
        //
        // Calculate cpu frequency
        //
        fsbspeed = (DWORD)((XTAL / m) * n);

        cpuspeed = (DWORD)((XTAL / m) * n * 11 / 2);
    
        //
        // Calculate nvclk
        //
        nvpll = REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PRAMDAC_NVPLL_COEFF);
        m = nvpll & 0xFF;
        n = (nvpll >> 8)  & 0xFF;
        p = (nvpll >> 16) & 0xFF;
    
        nvclk = (m != 0) ? (DWORD)((n * XTAL / (1 << p) / m)) : 0;
    
        //
        // Calculate vco
        //
        m = MPLLCoeff & 0xFF;
        n = (MPLLCoeff >> 8) & 0xFF;
        fsb_pdiv = (MPLLCoeff >> 16) & 0xF;
        
        vcofreq = (DWORD)((XTAL / m) * (fsb_pdiv * 2 * n));
    
        //
        // Calculate mclk
        //
        mem_pdiv = (MPLLCoeff >> 20) & 0xF;
        mclk = (DWORD)(vcofreq / (2 * mem_pdiv));

        sprintf(buffer, "Crystal%%3D%s,%%20FSB%%3D%d,%%20CPU%%3D%d,%%20NVCLK%%3D%d,%%20VCO%%3D%d,%%20MCLK%%3D%d",
            (hwver >= 0x46) ? "16.6" : "13.5", fsbspeed, cpuspeed, nvclk, vcofreq, mclk);
        }
    else
        {
        sprintf(buffer, "unknown");
        }
    }

char* StressMON::GetHWVersion(unsigned &hwver)
    {
    #define PAGE_SIZE                   4096
    #define ROM_SIZE                    (1024 * 1024)
    #define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
    #define ROM_VERSION_BYTE_OFFSET     0x78
    #define FLASH_BASE_ADDRESS          0xFFF00000
    #define FLASH_REGION_SIZE           (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

    LPBYTE RomBase = (LPBYTE)MmMapIoSpace(FLASH_BASE_ADDRESS, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);

    if(RomBase == NULL) return (char*)hwversions[0];

    hwver = RomBase[ROM_VERSION_BYTE_OFFSET];

    MmUnmapIoSpace(RomBase, PAGE_SIZE);

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version = 0x46: DVT4, DVT5, XDK2 (FAB F)
    // Init table version = 0x60: DVT6+, XDK2 (FAB G/H)
    // Init table version = 0x70: QT (MCP C03)
    // (private\ntos\recovery\recovery.cpp)
    //
    //DebugPrint("hwver: 0x%X\n", hwver);

    if(hwver <  0x40) return (char*)hwversions[1];
    if(hwver == 0x40) return (char*)hwversions[2];
    if(hwver == 0x46) return (char*)hwversions[3];
    if(hwver == 0x60) return (char*)hwversions[4];
    if(hwver == 0x70) return (char*)hwversions[5];
    return (char*)hwversions[0];
    }

void StressMON::GetPeripheral(char *buffer)
    {
    DWORD XIDMasks[] = {
        XDEVICE_PORT0_MASK,
        XDEVICE_PORT1_MASK,
        XDEVICE_PORT2_MASK,
        XDEVICE_PORT3_MASK
        };
    DWORD XMUMasks[] = {
        XDEVICE_PORT0_TOP_MASK,
        XDEVICE_PORT1_TOP_MASK,
        XDEVICE_PORT2_TOP_MASK,
        XDEVICE_PORT3_TOP_MASK,
        XDEVICE_PORT0_BOTTOM_MASK,
        XDEVICE_PORT1_BOTTOM_MASK,
        XDEVICE_PORT2_BOTTOM_MASK,
        XDEVICE_PORT3_BOTTOM_MASK
        };
    DWORD insertions, insertions2;
    unsigned i;
    unsigned port, slot;

    buffer[0] = '\0';

    bool dukeMask[4] = { false, false, false, false }; // Duke zeros bug

    // look for dukes
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Duke(%d);%%20", port);
            dukeMask[port] = true;
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "MU(%d,%%20%d);%%20", port, slot);

            // Duke zeros bug
            // TODO can remove this code when bug is fixed
            if(dukeMask[port] == false)
                {
                DukeZerosBug();
                }
            }
        }

    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    //insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "Hawk(%d,%%20%d);%%20", port, slot);
            }
        }

    // look for dvd dongle
    /* 
    insertions = XGetDevices(XDEVICE_TYPE_IR_REMOTE);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "DVD(%d);%%20", port);
            }
        }
    */

    // look for keyboard
    #ifdef DEBUG_KEYBOARD
    insertions = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Keyboard(%d);%%20", port);
            }
        }
    #endif // DEBUG_KEYBOARD

    }


void StressMON::GetDriveID(char* device, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;


    RtlInitObjectString(&VolumeString, device);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    status = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(strstr(device, "CdRom") != NULL) atapt->IdeReg.bCommandReg = 0xa1;
    else atapt->IdeReg.bCommandReg = 0xec;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             FALSE);
    NtClose(fileHandle);

    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = 0;
    //DebugPrint("Model Number: %s\n", model);

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    serial[i] = 0;
    //DebugPrint("Serial Number: %s\n", serial);

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    firmware[i] = 0;
    //DebugPrint("Firmware Revision: %s\n", firmware);
    }



/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI StressMONEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( stressmon )
#pragma data_seg()

BEGIN_EXPORT_TABLE( stressmon )
    EXPORT_TABLE_ENTRY( "StartTest", StressMONStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", StressMONEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", StressMONDllMain )
END_EXPORT_TABLE( stressmon )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\timer\timer.c ===
/*  OS/2 Version
*      Timer.c       -    Source file for a statistical
*                         dll package that exports four
*                         entry points:
*                         a) TimerOpen
*                         b) TimerInit
*                         c) TimerRead
*                         d) TimerClose
*                         e) TimerReport
*                         f) TimerQueryPerformanceCounter
*                         g) TimerConvertTicsToUSec
*
*                         Entry point a) opens a timer object
*                         and returns a handle to the timer. This
*                         handle is an index into an array of timer
*                         objects (structs) that are allocated at
*                         the time of the initialization of the dll.
*                         This ensures that allocation is done once only.
*                         Each application program will call this
*                         this function so that it has its own set
*                         of timers to use with TimerInit and TimerRead.
*                         The units of the time returned by TimerRead
*                         is also made available as a parameter to
*                         this call.
*
*                         Entry point b) is called by the application
*                         before commencing a timing operation.  This
*                         function is called with a handle to a timer
*                         object that was opened.  This function has to
*                         to be called before a call to TimerRead. The
*                         current time is stored in the timer object.
*
*                         Entry point c) is called each time the time
*                         since the previous call to TimerInit is
*                         desired.  This call also uses the handle to
*                         a timer that has been previosly opened. The
*                         current time is obtained form the lowlevel
*                         timer and this and the time at TimerInit time
*                         are used, along with the clock frequency and
*                         the return time units and the elapsed time
*                         is obtained and returned as a ULONG.
*
*                         Entry point d) is called whenever an opened
*                         timer is not needed any longer.  This call
*                         resets the timer and makes this timer as
*                         available to future calls to TimerOpen.
*
*                         Entry point e) returns the time obtained during
*                         the last call to TimerInit, TimerRead and the
*                         last returned time.
*
*                         Entry point f) accepts pointers to 2 64 bit
*                         vars.  Upon return, the first will contain the
*                         the current timer tic count and the second,
*                         if not NULL, will point to the timer freq.
*
*                         Entry point g) accepts Elapsed Tics as ULONG,
*                         Frequency as a ULONG and returns the time in
*                         microsecs. as  a ULONG.
*
*                         The dll initialization routine does the
*                         following:
*                             a) Obtains the timer overhead for calibration
*                                purposes.
*                             b) Allocates memory for a large number of
*                                timer objects (this will be system dep).
*                             c) Initializes each timer objects "Units'
*                                element to a "TIMER_FREE" indicator.
*                             d) Determines the lowlevel timer's frequency.
*
*                         TimerRead uses an external asm routine to perform
*                         its computation for elapsed time.
*
*     Created         -   Paramesh Vaidyanathan  (vaidy)
*     Initial Version -              October 18, '90
*
*     Modified to include f).  -     Feb. 14, 1992. (vaidy).
*/

char *COPYRIGHT = "Copyright Microsoft Corporation, 1991-1998";

#ifdef SLOOP
    #define INCL_DOSINFOSEG
    #define INCL_DOSDEVICES
    #define INCL_DOSPROCESS
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "timing.h"
/*****************************END OF INCLUDES*************************/
#define ITER_FOR_OVERHEAD   250
#define SUCCESS_OK            0
#define ONE_MILLION     1000000L
#define MICROSEC_FACTOR 1000000
#define TIMER_FREQ   1193167L  /* clock frequency - Hz */
/*********************************************************************/
Timer pTimer [MAX_TIMERS];       /* array of timer struct */

BOOL  bTimerInit = FALSE;        /* TRUE indicates low level timer exists */
ULONG ulTimerOverhead = 50000L;  /* timer overhead stored here */
BOOL  bCalibrated = FALSE;       /* TRUE subtracts overhead also */
ULONG ulFreq;                    /* timer frequency */
LONG aScaleValues[] = {1000000000L, 1000000L, 1000L, 1L, 10L, 1000L};
/* this is the table for scaling the units */
ULONG ulElapsedTime = 0L;
/********************* internal unexported routines ***************/
ULONG  CalibrateTimerForOverhead (VOID);
/*****************DEFINE VARIBLES AND PROTOTYPE FNS. FOR PLATFORMS*****/
NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter (
                          OUT PLARGE_INTEGER PerformanceCount,
                          OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
                          );

LARGE_INTEGER      PerfFreq;
LARGE_INTEGER      CountCurrent;

SHORT  GetTimerFreq (VOID);

/****************** internal unexported routines end***************/

/*
*     Function  - TimerOpen            (EXPORTED)
*     Arguments -
*               (a) SHORT far * -     address to which to return handle of
*                                the timer object.
*               (b) TimerUnits - units in which to return time from
*                                TimerRead.  It is one of the enum
*                                types defined in the header file.
*
*     Returns  -    SHORT  -     0 if handle was returned successfully
*                                Else, an error code which may be one of:
*
*                                    TIMERERR_NOT_AVAILABLE
*                                    TIMERERR_NO_MORE_HANDLES
*                                    TIMERERR_INVALID_UNITS
*
*     Obtains the handle to a timer object after opening it.
*     Should precede any calls to timer manipulation.  Checks
*     for validity of timer units.
*/

SHORT
TimerOpen (
          SHORT *  phTimerHandle,
          _TimerUnits TimerUnits
          )
{
    SHORT csTemp;

    if ((TimerUnits < KILOSECONDS)
        || (TimerUnits > NANOSECONDS)) /* out of the enum range */
        return (TIMERERR_INVALID_UNITS);

    if (!bTimerInit)  /* set during dll initialization */
        return (TIMERERR_NOT_AVAILABLE);

    /* else check if any timers are not in use and return the first
       available timer handle....actually the index into the
       timer object array */
    for (csTemp = 0; csTemp < MAX_TIMERS; csTemp++) {
        if (pTimer [csTemp].TUnits == TIMER_FREE) {
            *phTimerHandle =  csTemp;  /* found a free timer.  Return
                                          the handle */
            pTimer [csTemp].ulHi = pTimer[csTemp].ulLo = 0L;
            pTimer [csTemp].TUnits =
            TimerUnits;  /* set the units for timer */
            return (SUCCESS_OK);
        }
    }
    /* if exec reached here, all timers are being used */
    return (TIMERERR_NO_MORE_HANDLES);
}

/*
*     Function  - TimerInit       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Calls the low-level timer and sets the ulHi and ulLo of the
*     chosen timer to the time returned by the timer.  Should be
*     called after opening the timer with TimerOpen.
*/

SHORT
TimerInit (
          SHORT hTimerHandle
          )
{

    NTSTATUS NtStatus;

    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist. Return error */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise get the time from the low-level timer into
       the structure */

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    pTimer [hTimerHandle].ulLo = CountCurrent.LowPart;
    pTimer [hTimerHandle].ulHi = CountCurrent.HighPart;
    /* this timer structure has all the information needed to compute
       the elapsed time.  So return success, if there was no problem */

    return (SUCCESS_OK);
}

/*
*     Function  - TimerRead       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - ULONG - elapsed time since last call to TimerInit
*                         if call successful.
*
*                        Else, an error code if handle invalid or output
*                         overflow.  The error code will be the same:
*
*                            TIMERERR_OVERFLOW (max possible ULONG)
*
*     Calls the low-level timer.  Uses the ulLo and ulHi from the
*     timer's structure and subtracts the current time from the
*     saved time.  Uses ReturnElapsedTime (an external ASM proc)
*     to return the elapsed time taking into account the clock
*     frequency and the units for this timer.  Each call to this
*     returns the time from the previous TimerInit.
*
*     The user should interpret the return value sensibly to check
*     if the result is an error or a real value.
*/

ULONG
TimerRead (
          SHORT hTimerHandle
          )
{
    NTSTATUS NtStatus;
    LARGE_INTEGER  ElapsedTime, CountPrev, LargeOverhead;

    if ((hTimerHandle > MAX_TIMERS - 1)
        || (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist.
           Return TIMERERR_OVERFLOW ie. 0xffffffff, the max. possible
           ULONG.  The user should interpret such a result sensibly */
        return (TIMERERR_OVERFLOW);

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    CountPrev.LowPart  = pTimer [hTimerHandle].ulLo;
    CountPrev.HighPart = (LONG) pTimer [hTimerHandle].ulHi;
    ElapsedTime.LowPart = CountCurrent.LowPart;
    ElapsedTime.HighPart = (LONG) CountCurrent.HighPart;
    /* everything is just fine, convert to double, subtract the times,
       divide by the frequency, convert to MICROSECONDS and return
       the elapsed time as a ULONG */
    /* convert to us., divide the count by the clock frequency that
       has already been obtained */

    ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime, CountPrev);

    ElapsedTime = RtlExtendedIntegerMultiply (ElapsedTime, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 PerfFreq.LowPart,
                                                 NULL);

    // if the timer is not calibrated, set ulElapsedTime to be the
    // low part of ElapsedTime.  This is because, we do not have to
    // do to any arithmetic to this before returning the value.

    if (!bCalibrated)
        ulElapsedTime = ElapsedTime.LowPart;

    /* this code is common for all platforms but OS2386.  For Win3.x
       if VTD.386 has been installed, the code below should not matter,
       since we should have returned the time by now.

       The elapsed time will be scaled, overhead subtracted
       and the time returned */

    /* we have ulElapsedTime.  Scale it and do the needful */
    /* divide or multiply by the scale factor */

    if (bCalibrated) {
        // Applications like the PROBE call TimerRead repeatedly
        // without calling TimerInit, for more than 70 minutes.  This
        // screws up things.  So treat everything as 64 bit numbers
        // until the very end.

        if ((ElapsedTime.LowPart < ulTimerOverhead) &&
            (!ElapsedTime.HighPart)) { // low part is lower than overhead
                                       // and high part is zero..then make
                                       // elapsed time 0.  We don't want
                                       // negative numbers.
            ElapsedTime.HighPart = 0L;
            ElapsedTime.LowPart = 0L;
        }

        else { // subtract the overhead in tics before converting
               // to time units
            LargeOverhead.HighPart = 0L;
            LargeOverhead.LowPart = ulTimerOverhead;

            ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime,
                                                   LargeOverhead);
        }


        if (pTimer [hTimerHandle].TUnits <= MICROSECONDS) {

            ElapsedTime = RtlExtendedLargeIntegerDivide (
                                                        ElapsedTime,
                                                        aScaleValues [pTimer [hTimerHandle].TUnits],
                                                        NULL
                                                        );
        } else {
            ElapsedTime = RtlExtendedIntegerMultiply (
                                                     ElapsedTime,
                                                     aScaleValues [pTimer [hTimerHandle].TUnits]
                                                     );
        }

        // scaling is done.  Now get the time back into 32 bits.  This
        // should fit.

        ulElapsedTime = ElapsedTime.LowPart;
    }

    if ((LONG) ulElapsedTime < 0L) /* if this guy is -ve, return a 0 */
        return (0L);

    return (ulElapsedTime);
}

/*
*     Function  - TimerClose       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Releases the timer for use by future TimerOpen calls.
*     Resets the elements of the timer structure, setting the
*     Timer's Units element to TIMER_FREE.
*/

SHORT
TimerClose (
           SHORT hTimerHandle
           )
{
    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* error condition, wrong handle */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise, set the TimerUnits of this timer to TIMER_FREE,
       reset the other elements to zero and return */

    pTimer [hTimerHandle].TUnits = TIMER_FREE;
    pTimer [hTimerHandle].ulLo = 0L;
    pTimer [hTimerHandle].ulHi = 0L;
    return (SUCCESS_OK);
}

/*******************************************************************

     Added this routine TimerReport to report individual
     times.  Bob Day requested that such a routine be
     created.  It just maintains the time from the last
     TimerInit and TimerRead and also the last time returned.
     This routine copies this to a user specified buffer.

     Accepts - PSZ   - a pointer to a buffer to print the data out
               SHORT - timer handle

     Returns - TRUE if Timer exists and is open
             - FALSE if Timer not opened

*******************************************************************/

BOOL
FAR
PASCAL
TimerReport (
            PSZ pszReportString,
            SHORT hTimerHandle
            )
{
    if (pTimer [hTimerHandle].TUnits == TIMER_FREE)
        return (FALSE);

    /* stored value is in pTimer[hTimerHandle].ulLo and .ulHi */
    /*
    wsprintf (pszReportString,
        "Init Count (tics) %lu:%lu Current Count (tics) %lu:%lu Returned Time %lu ",
            pTimer [hTimerHandle].ulHi,
            pTimer [hTimerHandle].ulLo, CountCurrent.HighPart,
            CountCurrent.LowPart,
            ulElapsedTime);
    */
    return (TRUE);
}

/*******************************************************************

     Added this routine TimerQueryPerformanceCounter to report
     current tic count at behest of NT GDI folks.


     Accepts - PQWORD   - a pointer to a 64 bit struct. that will
                          contain tic count on return.

               PQWORD [OPTIONAL) - a pointer to a 64 bit struct. that will
                          contain frequency on return.

     Returns - None.

*******************************************************************/

VOID
FAR
PASCAL
TimerQueryPerformanceCounter (
                             PQWORD pqTic,
                             PQWORD pqFreq OPTIONAL
                             )
{

    LARGE_INTEGER TempTic, TempFreq;

    // call the NT API to do the needful and return.
    NtQueryPerformanceCounter (&TempTic, &TempFreq);
    pqTic->LowPart = TempTic.LowPart;
    pqTic->HighPart = TempTic.HighPart;
    pqFreq->LowPart = TempFreq.LowPart;
    pqFreq->HighPart = TempFreq.HighPart;

    return;
}

/*******************************************************************

     Added this routine TimerConvertTicsToUSec to return
     time in usecs. for a given elapsed tic count and freq.


     Accepts - ULONG    - Elapsed Tic Count.

               ULONG    - Frequency.

     Returns - Elapsed Time in usecs. as a ULONG.
             - Zero if input freq. is zero.

*******************************************************************/

ULONG
TimerConvertTicsToUSec (
                       ULONG ulElapsedTics,
                       ULONG ulInputFreq
                       )
{

    LARGE_INTEGER ElapsedTime;
    ULONG ulRemainder = 0L;

    // if the bozo gives me a zero freq, return him a zero.
    // Let him tear his hair.

    if (!ulInputFreq)
        return 0L;

    // multiply tics by a million and divide by the frequency.

    ElapsedTime = RtlEnlargedIntegerMultiply (ulElapsedTics, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 ulInputFreq,
                                                 &ulRemainder);

    ElapsedTime.LowPart += (ulRemainder > (ulInputFreq / 2L));

    return (ElapsedTime.LowPart) ; /* get the result into a ULONG */
}

/**************** ROUTINES NOT EXPORTED, FOLLOW ************************/

/*
*     Function  - CalibrateTimerForOverhead  (NOT EXPORTED)
*     Arguments - None
*     Returns   - ULONG
*
*     Calls TimerElapsedTime a few times to compute the expected
*     mean.  Calls TimerElapsedTime more number of times and
*     averages the mean out of those calls that did not exceed
*     the expected mean by 15%.
*/

ULONG
CalibrateTimerForOverhead (VOID)
{
    ULONG ulOverhead [ITER_FOR_OVERHEAD];
    ULONG ulTempTotal = 0L;
    ULONG ulExpectedValue = 0L;
    SHORT csIter;
    SHORT csNoOfSamples = ITER_FOR_OVERHEAD;
    SHORT hTimerHandle;

    if (TimerOpen (&hTimerHandle, MICROSECONDS)) /* open failed.  Return 0 */
        return (0L);

    for (csIter = 0; csIter < 5; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }
    /* The get elapsed time function has been called 6 times.
       The idea is to calculate the expected mean, then call
       TimerElapsedTime a bunch of times and throw away all times
       that are 15% larger than this mean.  This would give a
       really good overhead time */

    for (csIter = 0; csIter < 5; csIter++ )
        ulTempTotal += ulOverhead [csIter];

    ulExpectedValue = ulTempTotal / 5;

    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }

    ulTempTotal = 0L;         /* reset this value */
    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++ ) {
        if (ulOverhead [csIter] <=  (ULONG) (115L * ulExpectedValue/100L))
            /* include all samples that is < 115% of ulExpectedValue */
            ulTempTotal += ulOverhead [csIter];
        else
            /* ignore this sample and dec. sample count */
            csNoOfSamples--;
    }
    TimerClose (hTimerHandle);

    if (csNoOfSamples == 0)  /* no valid times.  Return a 0 for overhead */
        return (0L);

    return (ulTempTotal/csNoOfSamples);
}

/*
*       Function - GetTimerFreq    (NOT EXPORTED)
*
*      Arguments - None
*
*
*      Return    - 0 if successful or an error code if timer not aailable
*
*      Calls the function to return freq
*
*/
SHORT
GetTimerFreq (VOID)
{
    LARGE_INTEGER PerfCount, Freq;
    NTSTATUS NtStatus;

    NtStatus = NtQueryPerformanceCounter (&PerfCount, &Freq);

    if ((Freq.LowPart == 0L)  && (Freq.HighPart == 0L))
        /* frequency of zero implies timer not available */
        return (TIMERERR_NOT_AVAILABLE);

    PerfFreq.LowPart = Freq.LowPart;
    PerfFreq.HighPart = (LONG) Freq.HighPart;

    return 0;
}

/***************************************************

NT native dll init routine

****************************************************/
SHORT csTempCtr;    /* a counter - had to make this global..compile fails */
ULONG culTemp;      /*    - do -    */

NTSTATUS
TimerDllInitialize (
                   IN PVOID DllHandle,
                   ULONG Reason,
                   IN PCONTEXT Context OPTIONAL
                   )
{
    DllHandle, Context;     // avoid compiler warnings

    if (Reason != DLL_PROCESS_ATTACH) { // if detaching return immediately
        return TRUE;
    }

    for (csTempCtr = 0; csTempCtr < MAX_TIMERS; csTempCtr++) {
        pTimer [csTempCtr].ulLo = 0L;
        pTimer [csTempCtr].ulHi = 0L;
        pTimer [csTempCtr].TUnits = TIMER_FREE;
    }

    bTimerInit = TRUE;
    GetTimerFreq ();
    ulTimerOverhead = CalibrateTimerForOverhead ();
    /* the timer overhead will be placed in a global variable */
    bCalibrated = TRUE;
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\AnsiBstr.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    AnsiBstr.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "ansibstr.h"

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Default Constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr()
    {
    astr = NULL;
    bstr = NULL;
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a BSTR input

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr(BSTR b)
    {
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a char* input

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr(PCHAR a)
    {
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::~AnsiBstr
    Destructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::~AnsiBstr()
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

*****************************************************************************/
void AnsiBstr::SetStr(BSTR b)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

*****************************************************************************/
void AnsiBstr::SetStr(PCHAR a)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }


/*****************************************************************************

Routine Description:

    CreateAnsiFromBstr
    Allocates memory and converts from a BSTR

Arguments:

    BSTR bstr - pointer to a null terminated wide char string

Return Value:

    PCHAR - pointer to the newly allocated string

Notes:

*****************************************************************************/
PCHAR CreateAnsiFromBstr(BSTR bstr)
    {
    if(!bstr) return NULL;

    size_t bstrLen, pszLen;
    PCHAR psz = NULL;

    bstrLen = wcslen(bstr);
    pszLen = bstrLen * sizeof(CHAR);

    psz = (PCHAR)LocalAlloc(LPTR, pszLen + sizeof(CHAR));

    if(!psz) return NULL;

    WideCharToMultiByte(CP_ACP, 0, bstr, bstrLen, psz, pszLen + sizeof(CHAR), NULL, NULL);

    return psz;
    }

/*****************************************************************************

Routine Description:

    CreateBstrFromAnsi
    Allocates memory and converts from a PCHAR

Arguments:

    PCHAR pszText - pointer to a null terminated char string

Return Value:

    BSTR - return pointer to the new string

Notes:

*****************************************************************************/
BSTR CreateBstrFromAnsi(const char *pszText)
    {
    if(!pszText) return NULL;

    size_t TextLen, pszTextLen;

    pszTextLen = strlen(pszText);
    TextLen = pszTextLen * sizeof(WCHAR);

    BSTR pbstr = SysAllocStringByteLen(NULL, TextLen);

    if(!pbstr) return NULL;

    MultiByteToWideChar(CP_ACP, 0, pszText, pszTextLen, pbstr, TextLen + sizeof(WCHAR));

    return pbstr;
    }


/*****************************************************************************

Routine Description:

    CreateBstrFromAnsi
    Allocates memory and converts from a PCHAR

Arguments:

    PCHAR pszText - pointer to a null terminated char string

Return Value:

    BSTR - return pointer to the new string

Notes:

*****************************************************************************/
BSTR CreateBstrFromAnsi(const char *pszText, size_t length)
    {
    if(!pszText) return NULL;

    size_t TextLen, pszTextLen;

    pszTextLen = length;
    TextLen = pszTextLen * sizeof(WCHAR);

    BSTR pbstr = SysAllocStringByteLen(pszText, TextLen);

    if(!pbstr) return NULL;

    pbstr = (BSTR)Ansi2UnicodeHack((char*)pbstr, length);

    pbstr[length] = '\0';

    return pbstr;
    }


/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str, size_t length)
    {
    if(!str) return NULL;

    int align = 0;
    int len = length;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((unsigned long)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((unsigned long)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\AnsiBstr.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    AnsiBstr.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*****************************************************************************/

#ifndef _ANSIBSTR_H_
#define _ANSIBSTR_H_

class AnsiBstr
    {
    public:
        PCHAR astr;
        BSTR bstr;

    public:
        AnsiBstr();
        AnsiBstr(BSTR b);
        AnsiBstr(PCHAR a);

        void SetStr(BSTR b);
        void SetStr(PCHAR a);

        operator PCHAR(void) const { return astr; }
        operator BSTR(void) const { return bstr; }


        ~AnsiBstr();
    };

extern PCHAR CreateAnsiFromBstr(BSTR bstr);
extern BSTR CreateBstrFromAnsi(const char *pszText);
extern BSTR CreateBstrFromAnsi(const char *pszText, size_t length);
extern char* Unicode2AnsiHack(unsigned short *str);
extern char* Ansi2UnicodeHack(char *str);
extern char* Ansi2UnicodeHack(char *str, size_t length);

#endif // _ANSIBSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Debugger.cpp ===
// Debugger.cpp : Implementation of CDebugger
#include "stdafx.h"
#include "Debugger.h"

/////////////////////////////////////////////////////////////////////////////
// CDebugMonitor
CDebugger::CDebugger()
    {
    WSADATA version;
    WSAStartup(2, &version);
    sock = INVALID_SOCKET;
    }
CDebugger::~CDebugger()
    {
    if(sock == INVALID_SOCKET) Disconnect();
    WSACleanup();
    }

/*****************************************************************************

Routine Description:

    IsDataAvailable

    Checks to see if there is new data in the receive buffer

Arguments:

    none

Return Value:

    0 or SOCKET_ERROR - no data is available
    1 - data is available to recv

*****************************************************************************/
int CDebugger::IsDataAvailable(void)
    {
    FD_SET bucket;
    TIMEVAL timeout;

    timeout.tv_sec = 0;
    timeout.tv_usec = 250000;

    bucket.fd_count = 1;
    bucket.fd_array[0] = sock;

    return select(0, &bucket, NULL, NULL, &timeout);
    }



STDMETHODIMP CDebugger::Connect(const BSTR ipAddress)
    {
    USES_CONVERSION;
    if(!ipAddress) return E_INVALIDARG;

	struct sockaddr_in dest;
	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sock == INVALID_SOCKET)
        {
        return E_FAIL;
        }

    dest.sin_family = AF_INET;
	dest.sin_port = htons(DEBUGGER_PORT);
	dest.sin_addr.s_addr = inet_addr(W2A(ipAddress));
    if(dest.sin_addr.s_addr == INADDR_NONE)
        {
        // ipAddress wasnt an IP address, we will try to resolve it
        BSTR addr;
        SearchForIP(ipAddress, &addr);
        Unicode2AnsiHack(addr);
	    dest.sin_addr.s_addr = inet_addr((char*)addr);
        SysFreeString(addr);
        }
	int err = connect(sock, (struct sockaddr *)&dest, sizeof(sockaddr_in));

    if(err == SOCKET_ERROR)
        {
        closesocket(sock);
        return E_FAIL;
        }

    return S_OK;
    }

STDMETHODIMP CDebugger::Disconnect(void)
    {
    closesocket(sock);

    return S_OK;
    }

STDMETHODIMP CDebugger::GetResponse(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    char buffer[1024];

    if(IsDataAvailable() == 1)
        {
        int err = recv(sock, buffer, 1024, 0);
        buffer[err] = '\0';
        *pVal = CreateBstrFromAnsi(buffer);
        }
    else
        {
        *pVal = CreateBstrFromAnsi("No Data is available\r\n");
        return E_PENDING;
        }

    return S_OK;
    }

STDMETHODIMP CDebugger::SendCommand(const BSTR cmd)
    {
    USES_CONVERSION;
    if(!cmd) return E_INVALIDARG;

    char *buffer = W2A(cmd);

    int err = send(sock, buffer, strlen(buffer), 0);

    return S_OK;
    }

STDMETHODIMP CDebugger::Test()
    {
    // TODO: Add your implementation code here

    return S_OK;
    }

STDMETHODIMP CDebugger::SearchForIP(BSTR machineName, BSTR *pVal)
    {
    USES_CONVERSION;

    typedef struct _NM
        {
        BYTE bRequest;
        BYTE cchName;
        char szName[256];
        } NM;

    struct sockaddr_in sinU;
    NM nm;
    SOCKET s;
    int cRetries;
    DWORD dwRetry = 2000;
    BOOL f;
    char *szName = W2A(machineName);
    
    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(s == INVALID_SOCKET)
        {
        *pVal = CreateBstrFromAnsi("");
        return E_FAIL;
        }

    f = TRUE;
    if(0 != setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&f, sizeof f))
        {
        closesocket(s);
        *pVal = CreateBstrFromAnsi("");
        return E_FAIL;
        }
    sinU.sin_family = AF_INET;
    sinU.sin_port = htons(DEBUGGER_PORT);
    sinU.sin_addr.s_addr = htonl(INADDR_BROADCAST);

    nm.bRequest = 1;
    for(nm.cchName = 0; szName[nm.cchName]; ++nm.cchName)
        nm.szName[nm.cchName] = szName[nm.cchName];

    for(cRetries = 3; cRetries--; )
        {
        if(sendto(s, (char*)&nm, nm.cchName + 2, 0, (struct sockaddr *)&sinU, sizeof sinU) == nm.cchName + 2)
            {
            fd_set fds;
            struct timeval tv;
            int fSel;
            
            FD_ZERO(&fds);
            FD_SET(s, &fds);
            tv.tv_sec = dwRetry / 1000;
            tv.tv_usec = dwRetry % 1000;
            fSel = select(0, &fds, NULL, NULL, &tv);
            if(fSel > 0)
                {
                NM nmT;
                int cbAddr = sizeof sinU;
                // Got some data, is it for us?
                if(recvfrom(s, (char*)&nmT, sizeof nmT, 0, (struct sockaddr *)&sinU, &cbAddr) <= 0)
                    fSel = -1;
                else
                    {
                    if(nmT.bRequest == 2 && nmT.cchName == nm.cchName && !_strnicmp(nm.szName, nmT.szName, nm.cchName))
                        break; // Got it!
                    
                    ++cRetries; // We don't count this bogus data as a retry
                    }
                }
            if(fSel < 0) // Error, need to sleep
                Sleep(dwRetry);
            }
        else
            {
            Sleep(dwRetry);
            }
        }

    closesocket(s);
    if(cRetries < 0)
        {
        *pVal = CreateBstrFromAnsi("");
        return S_OK;
        }

    // We have our answer
    *pVal = CreateBstrFromAnsi(inet_ntoa(sinU.sin_addr));

    return S_OK;
    }

STDMETHODIMP CDebugger::Test2(int val/*=22*/)
    {
    // TODO: Add your implementation code here

    int tool = val;



    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\tsc\tsc.cpp ===
#include "tsc.h"

//#define rdtsc __asm __emit 0fh __asm __emit 031h
//#define cpuid __asm __emit 0fh __asm __emit 0a2h

/*****************Global Varaibles********************************************/

//if you really want to get accurate, you could remove the few cc's it takes to 
//call cpuid, which is really only used to keep code aligned, and to make sure
//rdtsc doesn't get executed before the other stuff does...
DWORD gCpuidLen = 0;		

//processor speed, in megahertz
INT gMhz = 733;

//processor speed, in kilohertz
INT gKhz = 733000;

//processor speed, in hertz
INT gHz  = 733000000;

//processor speed, nanoseconds per clock cycle
FLOAT giMhz = (1 / (FLOAT)gMhz);

//processor speed, milliseconds per clock cycle
FLOAT giKhz = (1 / (FLOAT)gKhz);

//processor speed, seconds per clock cycle
FLOAT giHz  = (1 / (FLOAT)gHz );



/*****************Functions***************************************************/

//*****************************************************************************
//* Function:	TscInit
//* Purpose:	Initialize the tsc routines, set the processor speed variables
//* Params:		mhz --- the processor speed, in megahertz. 
//*					If it is 0, 733 is used as the default
//* Return:		TRUE
//*****************************************************************************

BOOL TscInit(int mhz)
{
	if(mhz == 0) mhz = 733;

	_asm{
		cpuid
		rdtsc
		cpuid
		rdtsc
		mov ebx, eax
		cpuid
		rdtsc
		sub eax, ebx
		mov dword ptr [gCpuidLen], eax
	}
	gMhz = mhz;
	gKhz = mhz * 1000;
	gHz  = mhz * 1000000;
	giMhz = (1 / (FLOAT)gMhz);
	giKhz = (1 / (FLOAT)gKhz);
	giHz  = (1 / (FLOAT)gHz );
	return TRUE;
}

//*****************************************************************************
//* Function:	TscGetStamp
//* Purpose:	return the current time-stamp count
//* Params:		none
//* Return:     an INT64 containing the number of clock cycles since reboot
//* Note:		on a 733mhz, it will loop around in about 797 years...
//*****************************************************************************
_i INT64 TscGetStamp()
{
    INT64 i;
	_asm{
		cpuid
		rdtsc
		mov dword ptr [i], eax
		mov dword ptr [i+4], edx
	}
	return i;
}


//*****************************************************************************
//* Function:	TscGetDStamp
//* Purpose:	return the current time-stamp count
//* Params:		none
//* Return:     an INT64 containing the number of clock cycles since reboot
//*	Note:		This will loop every 5.8 seconds. For longer measurements, use
//*					TscGetStamp.
//*****************************************************************************
_i DWORD TscGetDStamp()
{
	DWORD i;
	_asm{
		cpuid
		rdtsc
		mov dword ptr [i], eax
	}
	return i;
}

//*****************************************************************************
//****   INT64 functions                              ************************
//**** (slower, but are accurate for 800 years or so)  ************************
//*****************************************************************************


//*****************************************************************************
//* Function:	TscBegin
//* Purpose:	start measuring time...
//* Params:		none
//* Return:     a INT64 that holds the clock time at start
//* Note:		Pass the return value to TscEnd or TscCurrentTime
//*****************************************************************************
_i INT64 TscBegin() { return TscGetStamp(); }
//*****************************************************************************
//* Function:	TscEnd
//* Purpose:	stop counting time
//* Params:		start is the time when you started measuring time
//* Return:     a INT64 that holds the number of clock cycles since TscBegin
//*****************************************************************************
_i INT64 TscEnd(INT64 start) { return TscGetStamp() - start; }
//*****************************************************************************
//* Function:	TscCurrentTime
//* Purpose:	get the ellapsed time since the corresponding TscBegin
//* Params:		start is the time when you started measuring time
//* Return:     a INT64 that holds the number of clock cycles since TscBegin
//*****************************************************************************
_i INT64 TscCurrentTime(INT64 start) { return TscGetStamp() - start; }



//*****************************************************************************
//****   DWORD functions                               ************************
//**** (faster, but are only accurate for 5.8 seconds  ************************
//*****************************************************************************


//*****************************************************************************
//* Function:	TscBegin
//* Purpose:	start measuring time...
//* Params:		none
//* Return:		a DWORD that holds the clock time at start
//* Note:		Pass the return value to TscEnd or TscCurrentTime
//*****************************************************************************
_i DWORD TscDBegin() { return TscGetDStamp(); }
//*****************************************************************************
//* Function:	TscDEnd
//* Purpose:	stop counting time
//* Params:		start is the time when you started measuring time
//* Return:		a DWORD that holds the number of clock cycles since TscBegin
//*****************************************************************************
_i DWORD TscDEnd(DWORD start) { return TscGetDStamp() - start; }
//*****************************************************************************
//* Function:	TscDCurrentTime
//* Purpose:	get the ellapsed time since the corresponding TscBegin
//* Params:		start is the time when you started measuring time
//* Return:		a DWORD that holds the number of clock cycles since TscBegin
//*****************************************************************************
_i DWORD TscDCurrentTime(DWORD start) { return TscGetDStamp() - start; }

//*****************************************************************************
//* Function:   TscGetCpuidLen()
//* Purpose:    If you're really nit-picky, this tells you how long it takes to
//*               do a cpuid and a rdtsc, in clock-ticks. It shouldn't matter.
//* Return:		a DWORD that holds the number of CCs it takes to cpuid & rdtsc
//*****************************************************************************
_i DWORD TscGetCpuidLen() { return gCpuidLen; }


//*****************************************************************************
//****   conversion functions                          ************************
//****   clock-ticks (I64) to seconds, etc             ************************
//*****************************************************************************
_i FLOAT TscTicksToFSeconds (INT64 ticks) {return (FLOAT)ticks * giHz; }
_i FLOAT TscTicksToFMSeconds(INT64 ticks) {return (FLOAT)ticks * giKhz;}
_i FLOAT TscTicksToFUSeconds(INT64 ticks) {return (FLOAT)ticks * giMhz;}

_i DWORD TscTicksToDSeconds (INT64 ticks) {return (DWORD)(ticks / gHz );}
_i DWORD TscTicksToDMSeconds(INT64 ticks) {return (DWORD)(ticks / gKhz);}
_i DWORD TscTicksToDUSeconds(INT64 ticks) {return (DWORD)(ticks / gMhz);}

_i INT64 TscTicksToSeconds (INT64 ticks) {return (INT64)(ticks / gHz );}
_i INT64 TscTicksToMSeconds(INT64 ticks) {return (INT64)(ticks / gKhz);}
_i INT64 TscTicksToUSeconds(INT64 ticks) {return (INT64)(ticks / gMhz);}


_i INT64 TscFSecondsToTicks (FLOAT seconds ) {return (INT64)(seconds  * gHz); }
_i INT64 TscFMSecondsToTicks(FLOAT mseconds) {return (INT64)(mseconds * gKhz);}
_i INT64 TscFUSecondsToTicks(FLOAT useconds) {return (INT64)(useconds * gMhz);}

_i INT64 TscDSecondsToTicks (DWORD seconds ) {return (INT64)seconds  * gHz; }
_i INT64 TscDMSecondsToTicks(DWORD mseconds) {return (INT64)mseconds * gKhz;}
_i INT64 TscDUSecondsToTicks(DWORD useconds) {return (INT64)useconds * gMhz;}


//*****************************************************************************
//****   conversion functions                          ************************
//****   clock-ticks (DWORD) to seconds, etc           ************************
//*****************************************************************************
_i FLOAT TscDTicksToFSeconds (DWORD ticks) {return (FLOAT)ticks * giHz; }
_i FLOAT TscDTicksToFMSeconds(DWORD ticks) {return (FLOAT)ticks * giKhz;}
_i FLOAT TscDTicksToFUSeconds(DWORD ticks) {return (FLOAT)ticks * giMhz;}

_i DWORD TscDTicksToDSeconds (DWORD ticks) {return ticks / gHz; }
_i DWORD TscDTicksToDMSeconds(DWORD ticks) {return ticks / gKhz;}
_i DWORD TscDTicksToDUSeconds(DWORD ticks) {return ticks / gMhz;}

_i DWORD TscFSecondsToDTicks (FLOAT seconds ) {return (DWORD)(seconds  * gHz); }
_i DWORD TscFMSecondsToDTicks(FLOAT mseconds) {return (DWORD)(mseconds * gKhz);}
_i DWORD TscFUSecondsToDTicks(FLOAT useconds) {return (DWORD)(useconds * gMhz);}

_i DWORD TscDSecondsToDTicks (DWORD seconds ) {return (DWORD)seconds  * gHz; }
_i DWORD TscDMSecondsToDTicks(DWORD mseconds) {return (DWORD)mseconds * gKhz;}
_i DWORD TscDUSecondsToDTicks(DWORD useconds) {return (DWORD)useconds * gMhz;}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Duke.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Duke.cpp

Abstract:

    COM object wrapper for the XID USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "COMUSBSimulator.h"
#include "Duke.h"

CDuke::CDuke()
    {
    buttonUpDelay = 125;
    buttonDownDelay = 350;
    }
CDuke::~CDuke()
    {
    xid.SoftBreak(0);
    }

STDMETHODIMP CDuke::get_deviceName(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = CreateBstrFromAnsi(xid.GetName());
    return S_OK;
    }

STDMETHODIMP CDuke::get_IP(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    char buffer[32];
    sprintf(buffer, "%u.%u.%u.%u", ((unsigned char*)&xid.simIP)[0], ((unsigned char*)&xid.simIP)[1], ((unsigned char*)&xid.simIP)[2], ((unsigned char*)&xid.simIP)[3]);
    *pVal = CreateBstrFromAnsi(buffer);
    return S_OK;
    }

STDMETHODIMP CDuke::put_IP(const BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;
    xid.simIP = inet_addr(W2A(newVal));
    return S_OK;
    }

STDMETHODIMP CDuke::get_port(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = xid.usbPort;
    return S_OK;
    }

STDMETHODIMP CDuke::put_port(short newVal)
    {
    xid.usbPort = (char)newVal;
    xid.destPort = htons(newVal+SIM_NETPORT_BASE);
    return S_OK;
    }

STDMETHODIMP CDuke::get_enumerated(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    if(xid.IsEnumerated()) *pVal = TRUE;
    else *pVal = FALSE;
    return S_OK;
    }

STDMETHODIMP CDuke::get_record(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = xid.record;
    return S_OK;
    }

STDMETHODIMP CDuke::put_record(BOOL newVal)
    {
    xid.record = !!newVal;
    return S_OK;
    }

STDMETHODIMP CDuke::Plug(unsigned long *errCode)
    {
    *errCode = xid.Plug();
    return S_OK;
    }

STDMETHODIMP CDuke::Unplug(unsigned long *errCode)
    {
    *errCode = xid.Unplug();
    return S_OK;
    }

STDMETHODIMP CDuke::EndpointMode(short mode)
    {
    if(mode<0 || mode>3) return E_INVALIDARG;
    xid.EndpointConfig(mode);
    return S_OK;
    }

STDMETHODIMP CDuke::Button(const BSTR buttonName)
    {
    XIDInputReport xidPacket = defaultXIDReport;
    XIDInputReport defaultPacket = defaultXIDReport;

    if(_wcsicmp(buttonName, L"UP") == 0)
        xidPacket.thumbLY = 32000;
    else if(_wcsicmp(buttonName, L"DOWN") == 0)
        xidPacket.thumbLY = -32000;
    else if(_wcsicmp(buttonName, L"LEFT") == 0)
        xidPacket.thumbLX = -32000;
    else if(_wcsicmp(buttonName, L"RIGHT") == 0)
        xidPacket.thumbLX = 32000;

    else if(_wcsicmp(buttonName, L"A") == 0)
        xidPacket.analogButtons[0] = 0xFF;
    else if(_wcsicmp(buttonName, L"B") == 0)
        xidPacket.analogButtons[1] = 0xFF;
    else if(_wcsicmp(buttonName, L"X") == 0)
        xidPacket.analogButtons[2] = 0xFF;
    else if(_wcsicmp(buttonName, L"Y") == 0)
        xidPacket.analogButtons[3] = 0xFF;
    else if(_wcsicmp(buttonName, L"BLACK") == 0)
        xidPacket.analogButtons[4] = 0xFF;
    else if(_wcsicmp(buttonName, L"WHITE") == 0)
        xidPacket.analogButtons[5] = 0xFF;
    else if(_wcsicmp(buttonName, L"LEFTTRIGGER") == 0)
        xidPacket.analogButtons[6] = 0xFF;
    else if(_wcsicmp(buttonName, L"RIGHTTRIGGER") == 0)
        xidPacket.analogButtons[7] = 0xFF;

    else if(_wcsicmp(buttonName, L"LEFTTHUMB") == 0)
        xidPacket.buttons = 0x80;
    else if(_wcsicmp(buttonName, L"RIGHTTHUMB") == 0)
        xidPacket.buttons = 0x40;
    else if(_wcsicmp(buttonName, L"BACK") == 0)
        xidPacket.buttons = 0x20;
    else if(_wcsicmp(buttonName, L"START") == 0)
        xidPacket.buttons = 0x10;
    else if(_wcsicmp(buttonName, L"DPADN") == 0)
        xidPacket.buttons = 0x01;
    else if(_wcsicmp(buttonName, L"DPADNE") == 0)
        xidPacket.buttons = 0x09;
    else if(_wcsicmp(buttonName, L"DPADE") == 0)
        xidPacket.buttons = 0x08;
    else if(_wcsicmp(buttonName, L"DPADSE") == 0)
        xidPacket.buttons = 0x0A;
    else if(_wcsicmp(buttonName, L"DPADS") == 0)
        xidPacket.buttons = 0x02;
    else if(_wcsicmp(buttonName, L"DPADSW") == 0)
        xidPacket.buttons = 0x06;
    else if(_wcsicmp(buttonName, L"DPADW") == 0)
        xidPacket.buttons = 0x04;
    else if(_wcsicmp(buttonName, L"DPADNW") == 0)
        xidPacket.buttons = 0x05;
    else
        {
        return E_INVALIDARG;
        }

    xid.SetInputReport(&xidPacket);
    Sleep(buttonDownDelay);
    xid.SetInputReport(&defaultPacket);
    Sleep(buttonUpDelay);

    return S_OK;
    }


STDMETHODIMP CDuke::get_buttonDownDelay(unsigned short *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = buttonDownDelay;
    return S_OK;
    }

STDMETHODIMP CDuke::put_buttonDownDelay(unsigned short newVal)
    {
    buttonDownDelay = newVal;
    return S_OK;
    }

STDMETHODIMP CDuke::get_buttonUpDelay(unsigned short *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = buttonUpDelay;
    return S_OK;
    }

STDMETHODIMP CDuke::put_buttonUpDelay(unsigned short newVal)
    {
    buttonUpDelay = newVal;
    return S_OK;
    }

STDMETHODIMP CDuke::SetButtonState(long digital, short analog1, short analog2, short analog3, short analog4, short analog5, short analog6, short analog7, short analog8, short thumbLX, short thumbLY, short thumbRX, short thumbRY)
    {
    XIDInputReport xidPacket = defaultXIDReport;

    xidPacket.buttons = (unsigned __int16)digital;
    xidPacket.analogButtons[0] = (unsigned __int8)analog1;
    xidPacket.analogButtons[1] = (unsigned __int8)analog2;
    xidPacket.analogButtons[2] = (unsigned __int8)analog3;
    xidPacket.analogButtons[3] = (unsigned __int8)analog4;
    xidPacket.analogButtons[4] = (unsigned __int8)analog5;
    xidPacket.analogButtons[5] = (unsigned __int8)analog6;
    xidPacket.analogButtons[6] = (unsigned __int8)analog7;
    xidPacket.analogButtons[7] = (unsigned __int8)analog8;
    xidPacket.thumbLX = thumbLX;
    xidPacket.thumbLY = thumbLY;
    xidPacket.thumbRX = thumbRX;
    xidPacket.thumbRY = thumbRY;

    xid.SetInputReport(&xidPacket);
    return S_OK;
    }

STDMETHODIMP CDuke::Free(void)
    {
    return S_OK;
    }

STDMETHODIMP CDuke::get_deviceDescriptor(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    xid.Lock();
    *pVal = CreateBstrFromAnsi((char*)xid.deviceDescriptor, 8);
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::put_deviceDescriptor(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    xid.Lock();
    for(unsigned i=0; i<8; i++)
        xid.deviceDescriptor[i] = (unsigned __int8)newVal[i];
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::get_configurationDescriptor(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    xid.Lock();
    *pVal = CreateBstrFromAnsi((char*)xid.configurationDescriptor, 32);
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::put_configurationDescriptor(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    xid.Lock();
    for(unsigned i=0; i<32; i++)
        xid.configurationDescriptor[i] = (unsigned __int8)newVal[i];
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::get_xidDescriptor(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    xid.Lock();
    *pVal = CreateBstrFromAnsi((char*)xid.xidDescriptor, xid.xidDescriptorLen);
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::put_xidDescriptor(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    xid.Lock();
    for(unsigned i=0; i<xid.xidDescriptorLen; i++)
        xid.xidDescriptor[i] = (unsigned __int8)newVal[i];
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::get_xidPacket(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    xid.Lock();
    *pVal = CreateBstrFromAnsi((char*)xid.xidPacket, xid.xidPacketLen);
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::put_xidPacket(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    xid.Lock();
    for(unsigned i=0; i<xid.xidPacketLen; i++)
        xid.xidPacket[i] = (unsigned __int8)newVal[i];
    xid.Unlock();
    return S_OK;
    }

STDMETHODIMP CDuke::get_deviceCapabilities(BSTR type, BSTR *pVal)
    {
    if(!type || !pVal) return E_INVALIDARG;
    if(_wcsicmp(type, L"IN") == 0) // input - buttons
        {
        xid.Lock();
        *pVal = CreateBstrFromAnsi((char*)xid.inCapabilities, xid.inCapabilitiesLen);
        xid.Unlock();
        }
    else if(_wcsicmp(type, L"OUT") == 0) // output - motors
        {
        xid.Lock();
        *pVal = CreateBstrFromAnsi((char*)xid.outCapabilities, xid.outCapabilitiesLen);
        xid.Unlock();
        }
    else
        {
        return E_INVALIDARG;
        }
    return S_OK;
    }

STDMETHODIMP CDuke::put_deviceCapabilities(BSTR type, BSTR newVal)
    {
    if(!type || !newVal) return E_INVALIDARG;
    if(_wcsicmp(type, L"IN") == 0) // input - buttons
        {
        xid.Lock();
        for(unsigned i=0; i<xid.inCapabilitiesLen; i++)
            xid.inCapabilities[i] = (unsigned __int8)newVal[i];
        xid.Unlock();
        }
    else if(_wcsicmp(type, L"OUT") == 0) // output - motors
        {
        xid.Lock();
        for(unsigned i=0; i<xid.outCapabilitiesLen; i++)
            xid.outCapabilities[i] = (unsigned __int8)newVal[i];
        xid.Unlock();
        }
    else
        {
        return E_INVALIDARG;
        }
    return S_OK;
    }

STDMETHODIMP CDuke::get_xidPacketLength(unsigned short *pVal)
    {
    xid.Lock();
    *pVal = xid.xidPacketLen;
    xid.Unlock();

    return S_OK;
    }

STDMETHODIMP CDuke::put_xidPacketLength(unsigned short newVal)
    {
    xid.Lock();
    xid.xidPacketLen = newVal;
    delete[] xid.xidPacket;
    xid.xidPacket = new unsigned __int8[xid.xidPacketLen];
    xid.Unlock();

    return S_OK;
    }

STDMETHODIMP CDuke::get_xidDescriptorLength(unsigned short *pVal)
    {
    xid.Lock();
    *pVal = xid.xidDescriptorLen;
    xid.Unlock();

    return S_OK;
    }

STDMETHODIMP CDuke::put_xidDescriptorLength(unsigned short newVal)
    {
    xid.Lock();
    xid.xidDescriptorLen = newVal;
    delete[] xid.xidDescriptor;
    xid.xidDescriptor = new unsigned __int8[xid.xidDescriptorLen];
    xid.Unlock();

    return S_OK;
    }

STDMETHODIMP CDuke::get_deviceCapabilitiesLength(BSTR type, unsigned short *pVal)
    {
    if(!type || !pVal) return E_INVALIDARG;
    if(_wcsicmp(type, L"IN") == 0) // input - buttons
        {
        xid.Lock();
        *pVal = xid.inCapabilitiesLen;
        xid.Unlock();
        }
    else if(_wcsicmp(type, L"OUT") == 0) // output - motors
        {
        xid.Lock();
        *pVal = xid.outCapabilitiesLen;
        xid.Unlock();
        }
    else
        {
        return E_INVALIDARG;
        }
    return S_OK;
    }

STDMETHODIMP CDuke::put_deviceCapabilitiesLength(BSTR type, unsigned short newVal)
    {
    if(!type || !newVal) return E_INVALIDARG;
    if(_wcsicmp(type, L"IN") == 0) // input - buttons
        {
        xid.Lock();
        xid.inCapabilitiesLen = newVal;
        delete[] xid.inCapabilities;
        xid.inCapabilities = new unsigned __int8[xid.inCapabilitiesLen];
        xid.Unlock();
        }
    else if(_wcsicmp(type, L"OUT") == 0) // output - motors
        {
        xid.Lock();
        xid.outCapabilitiesLen = newVal;
        delete[] xid.outCapabilities;
        xid.outCapabilities = new unsigned __int8[xid.outCapabilitiesLen];
        xid.Unlock();
        }
    else
        {
        return E_INVALIDARG;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Duke.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Duke.h

Abstract:

    COM object wrapper for the XID USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#ifndef __DUKE_H_
#define __DUKE_H_

#include "resource.h"       // main symbols

class ATL_NO_VTABLE CDuke : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CDuke, &CLSID_Duke>, public IDispatchImpl<IDuke, &IID_IDuke, &LIBID_USBSIMULATORLib>
    {
    public:
	    CDuke();
	    ~CDuke();

    private:
        XIDDevice xid;
        unsigned short buttonUpDelay;
        unsigned short buttonDownDelay;

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_DUKE)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CDuke)
            COM_INTERFACE_ENTRY(IDuke)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // IDuke
    public:
	    STDMETHOD(get_deviceCapabilitiesLength)(BSTR type, /*[out, retval]*/ unsigned short *pVal);
	    STDMETHOD(put_deviceCapabilitiesLength)(BSTR type, /*[in]*/ unsigned short newVal);
	    STDMETHOD(get_xidDescriptorLength)(/*[out, retval]*/ unsigned short *pVal);
	    STDMETHOD(put_xidDescriptorLength)(/*[in]*/ unsigned short newVal);
	    STDMETHOD(get_xidPacketLength)(/*[out, retval]*/ unsigned short *pVal);
	    STDMETHOD(put_xidPacketLength)(/*[in]*/ unsigned short newVal);
	    STDMETHOD(get_deviceCapabilities)(/*[in]*/ BSTR type, /*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_deviceCapabilities)(/*[in]*/ BSTR type, /*[in]*/ BSTR newVal);
	    STDMETHOD(get_xidPacket)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_xidPacket)(/*[in]*/ BSTR newVal);
	    STDMETHOD(get_xidDescriptor)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_xidDescriptor)(/*[in]*/ BSTR newVal);
	    STDMETHOD(get_configurationDescriptor)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_configurationDescriptor)(/*[in]*/ BSTR newVal);
	    STDMETHOD(get_deviceDescriptor)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_deviceDescriptor)(/*[in]*/ BSTR newVal);
	    STDMETHOD(Free)(void);
	    STDMETHOD(SetButtonState)(/*[in]*/ long digital, /*[in]*/ short analog1, /*[in]*/ short analog2, /*[in]*/ short analog3, /*[in]*/ short analog4, /*[in]*/ short analog5, /*[in]*/ short analog6, /*[in]*/ short analog7, /*[in]*/ short analog8, /*[in]*/ short thumbLX, /*[in]*/ short thumbLY, /*[in]*/ short thumbRX, /*[in]*/ short thumbRY);
	    STDMETHOD(get_buttonUpDelay)(/*[out, retval]*/ unsigned short *pVal);
	    STDMETHOD(put_buttonUpDelay)(/*[in]*/ unsigned short newVal);
	    STDMETHOD(get_buttonDownDelay)(/*[out, retval]*/ unsigned short *pVal);
	    STDMETHOD(put_buttonDownDelay)(/*[in]*/ unsigned short newVal);
	    STDMETHOD(Button)(/*[in]*/ const BSTR buttonName);
	    STDMETHOD(EndpointMode)(/*[in]*/ short mode);
	    STDMETHOD(Unplug)(/*[out, retval]*/ unsigned long *errCode);
	    STDMETHOD(Plug)(/*[out, retval]*/ unsigned long *errCode);
	    STDMETHOD(get_enumerated)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(get_record)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(put_record)(/*[in]*/ BOOL newVal);
        STDMETHOD(get_port)(/*[out, retval]*/ short *pVal);
        STDMETHOD(put_port)(/*[in]*/ short newVal);
        STDMETHOD(get_IP)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(put_IP)(/*[in]*/ const BSTR newVal);
	    STDMETHOD(get_deviceName)(/*[out, retval]*/ BSTR *pVal);
    };

#endif //__DUKE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Debugger.h ===
// Debugger.h : Declaration of the CDebugger

#ifndef __DEBUGGER_H_
#define __DEBUGGER_H_

#include "resource.h"       // main symbols

#define DEBUGGER_PORT 0x2db
#define DMBREAK_NONE 0
#define DMBREAK_WRITE 1
#define DMBREAK_READWRITE 2
#define DMBREAK_EXECUTE 3


/////////////////////////////////////////////////////////////////////////////
// CDebugger
class ATL_NO_VTABLE CDebugger : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CDebugger, &CLSID_Debugger>, public IDispatchImpl<IDebugger, &IID_IDebugger, &LIBID_USBSIMULATORLib>
    {
    private:
        SOCKET sock;

    public:
        CDebugger();
        ~CDebugger();

    private:
        int IsDataAvailable(void);

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_DEBUGGER)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CDebugger)
            COM_INTERFACE_ENTRY(IDebugger)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // IDebugger
    public:
	    STDMETHOD(Test2)(/*[defaultvalue(22)]*/ int val);
	    STDMETHOD(SearchForIP)(/*[in]*/ BSTR machineName, /*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(Test)();
        STDMETHOD(SendCommand)(/*[in]*/ const BSTR cmd);
        STDMETHOD(GetResponse)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(Disconnect)(void);
        STDMETHOD(Connect)(/*[in]*/ const BSTR ipAddress);
    };

#endif //__DEBUGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Hawk.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Hawk.cpp

Abstract:

    COM object wrapper for the Isoc USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "COMUSBSimulator.h"
#include "Hawk.h"


CHawk::CHawk()
    {
    }
CHawk::~CHawk()
    {
    hawk.SoftBreak(0);
    }

STDMETHODIMP CHawk::get_deviceName(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = CreateBstrFromAnsi(hawk.GetName());
    return S_OK;
    }

STDMETHODIMP CHawk::get_IP(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    char buffer[32];
    sprintf(buffer, "%u.%u.%u.%u", ((unsigned char*)&hawk.simIP)[0], ((unsigned char*)&hawk.simIP)[1], ((unsigned char*)&hawk.simIP)[2], ((unsigned char*)&hawk.simIP)[3]);
    *pVal = CreateBstrFromAnsi(buffer);
    return S_OK;
    }

STDMETHODIMP CHawk::put_IP(const BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;
    hawk.simIP = inet_addr(W2A(newVal));
    return S_OK;
    }

STDMETHODIMP CHawk::get_port(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = hawk.usbPort;
    return S_OK;
    }

STDMETHODIMP CHawk::put_port(short newVal)
    {
    hawk.usbPort = (char)newVal;
    hawk.destPort = htons(newVal+SIM_NETPORT_BASE);
    return S_OK;
    }

STDMETHODIMP CHawk::get_enumerated(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    if(hawk.IsEnumerated()) *pVal = TRUE;
    else *pVal = FALSE;
    return S_OK;
    }

STDMETHODIMP CHawk::get_record(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = hawk.record;
    return S_OK;
    }

STDMETHODIMP CHawk::put_record(BOOL newVal)
    {
    hawk.record = !!newVal;
    return S_OK;
    }

STDMETHODIMP CHawk::Plug(void)
    {
    hawk.Plug();
    return S_OK;
    }

STDMETHODIMP CHawk::Unplug(void)
    {
    hawk.Unplug();
    return S_OK;
    }

STDMETHODIMP CHawk::EndpointMode(short mode)
    {
    if(mode<0 || mode>3) return E_INVALIDARG;
    hawk.EndpointConfig(mode);
    return S_OK;
    }

STDMETHODIMP CHawk::Free(void)
    {
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by USBSimulator.rc
//
#define IDS_PROJNAME                    100
#define IDR_DUKE                        101
#define IDR_MU                          102
#define IDR_HAWK                        103
#define IDR_SIMULATOR                   104
#define IDR_DEBUGGER                    105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Simulator.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Simulator.h

Abstract:

    COM wrapper object for the USBSimulator class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef __SIMULATOR_H_
#define __SIMULATOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimulator
class ATL_NO_VTABLE CSimulator : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CSimulator, &CLSID_Simulator>, public IDispatchImpl<ISimulator, &IID_ISimulator, &LIBID_USBSIMULATORLib>
    {
    public:
        CSimulator();
        ~CSimulator();

    private:
        USBSimulator usbsim;

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_SIMULATOR)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CSimulator)
            COM_INTERFACE_ENTRY(ISimulator)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // ISimulator
    public:
	    STDMETHOD(GetLastError)(/*[out, retval]*/ unsigned long *pVal);
	    STDMETHOD(get_logFilename)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_logFilename)(/*[in]*/ const BSTR newVal);
	    STDMETHOD(GetErrorDescription)(/*[in]*/ unsigned long errCode, /*[out, retval]*/ BSTR *pDescription);
	    STDMETHOD(LogFormat)(/*[in]*/ short format);
	    STDMETHOD(Log)(/*[in]*/ const BSTR string);
	    STDMETHOD(GetUSBPorts)(/*[in]*/ const BSTR ipAddr, /*[out, retval]*/ short *connectedMask);
	    STDMETHOD(GetMACAddr)(/*[in]*/ const BSTR ipAddr, /*[out, retval]*/ BSTR *macAddr);
        STDMETHOD(GetVersion)(/*[in]*/ const BSTR ipAddr, /*[out, retval]*/ BSTR *version);
    };

#endif //__SIMULATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\StdAfx.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    StdAfx.cpp

Abstract:

    source file that includes just the standard includes

Author:

    Josh Poley (jpoley)

Revision History:

Notes:
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

*****************************************************************************/
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\StdAfx.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    stdafx.h

Abstract:

    Precomiled Header

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _USBSIM_PHC_
#define _USBSIM_PHC_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "COMUSBSimulator.h"
#include "..\..\inc\usbsimulator.h"
#include "AnsiBstr.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _USBSIM_PHC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Simulator.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Simulator.cpp

Abstract:

    COM wrapper object for the USBSimulator class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "COMUSBSimulator.h"
#include "Simulator.h"

CSimulator::CSimulator()
    {
    }
CSimulator::~CSimulator()
    {
    }

STDMETHODIMP CSimulator::GetVersion(const BSTR ipAddr, BSTR *version)
    {
    USES_CONVERSION;
    if(!version) return E_INVALIDARG;

    usbsim.ip[0] = inet_addr(W2A(ipAddr));

    SimPacketTyped<unsigned char [128]> simData;

    usbsim.SendCommand(0, SIM_CMD_IPQUERY, SIM_SUBCMD_IPQUERY, simData);

    if(usbsim.SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_VERSION, simData) != USBSIM_ERROR_OK)
        {
        *version = CreateBstrFromAnsi("");
        return S_OK;
        }
    simData.data[simData.header.dataSize] = '\0';
    *version = CreateBstrFromAnsi((char*)simData.data);

    return S_OK;
    }

STDMETHODIMP CSimulator::GetMACAddr(const BSTR ipAddr, BSTR *macAddr)
    {
    USES_CONVERSION;
    if(!macAddr) return E_INVALIDARG;

    char buffer[128];
    usbsim.ip[0] = inet_addr(W2A(ipAddr));

    SimPacketTyped<unsigned char [128]> simData;
    if(usbsim.SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_MACADDR, simData) != USBSIM_ERROR_OK)
        {
        *macAddr = CreateBstrFromAnsi("");
        return S_OK;
        }
    sprintf(buffer, "%02X %02X %02X %02X %02X %02X", simData.data[0], simData.data[1], simData.data[2], simData.data[3], simData.data[4], simData.data[5]);
    *macAddr = CreateBstrFromAnsi((char*)buffer);

    return S_OK;
    }

STDMETHODIMP CSimulator::GetUSBPorts(const BSTR ipAddr, short *connectedMask)
    {
    USES_CONVERSION;

    if(!connectedMask) return E_INVALIDARG;

    usbsim.ip[0] = inet_addr(W2A(ipAddr));

    SimPacketTyped<unsigned __int8> simData;
    if(usbsim.SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_CONNECTED, simData) != USBSIM_ERROR_OK)
        {
        *connectedMask = 0;
        return S_OK;
        }
    *connectedMask = simData.data;

    return S_OK;
    }

STDMETHODIMP CSimulator::Log(const BSTR string)
    {
    recorder.LogPrint("%ws", string);
    return S_OK;
    }

STDMETHODIMP CSimulator::LogFormat(short format)
    {
    recorder.SetFormat(format);
    return S_OK;
    }

STDMETHODIMP CSimulator::GetErrorDescription(unsigned long errCode, BSTR *pDescription)
    {
    if(!pDescription) return E_INVALIDARG;

    char *descriptions[] =
        {
        "Success",
        "Device is already connected",
        "Device is not connected",
        "Connection failed, use GetLastError to get more information",
        "Socket error, use GetLastError to get more information",
        "Parameter is out of range or denotes a port currently not in use",
        "Parameter is out of range or denotes a simulator currently not in use",
        "Pointer to a USBDevice is not valid",
        "Abort specifed by the user",
        "Timeout waiting for response from simulator",
        "Got data from the simulator but it is likely corrupted",
        "Send failure, use GetLastError to get more information"
        };

    if(errCode >= ARRAYSIZE(descriptions))
        {
        *pDescription = CreateBstrFromAnsi("Unknown Error Code");
        return S_OK;
        }

    *pDescription = CreateBstrFromAnsi(descriptions[errCode]);    

    return S_OK;
    }

STDMETHODIMP CSimulator::get_logFilename(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = CreateBstrFromAnsi(recorder.filename);    

    return S_OK;
    }

STDMETHODIMP CSimulator::put_logFilename(const BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;

    recorder.SetFilename(W2A(newVal));

    return S_OK;
    }

STDMETHODIMP CSimulator::GetLastError(unsigned long *pVal)
    {
    if(!pVal) return E_INVALIDARG;

    *pVal = ::GetLastError();

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\Hawk.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Hawk.h

Abstract:

    COM object wrapper for the Isoc USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#ifndef __HAWK_H_
#define __HAWK_H_

#include "resource.h"       // main symbols

class ATL_NO_VTABLE CHawk : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CHawk, &CLSID_Hawk>, public IDispatchImpl<IHawk, &IID_IHawk, &LIBID_USBSIMULATORLib>
    {
    public:
        CHawk();
        ~CHawk();

    private:
        IsocDevice hawk;

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_HAWK)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CHawk)
            COM_INTERFACE_ENTRY(IHawk)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // IHawk
    public:
	    STDMETHOD(Free)(void);
	    STDMETHOD(EndpointMode)(/*[in]*/ short mode);
	    STDMETHOD(Unplug)(void);
	    STDMETHOD(Plug)(void);
	    STDMETHOD(get_enumerated)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(get_record)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(put_record)(/*[in]*/ BOOL newVal);
        STDMETHOD(get_port)(/*[out, retval]*/ short *pVal);
        STDMETHOD(put_port)(/*[in]*/ short newVal);
        STDMETHOD(get_IP)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(put_IP)(/*[in]*/ const BSTR newVal);
	    STDMETHOD(get_deviceName)(/*[out, retval]*/ BSTR *pVal);
    };

#endif //__HAWK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\MU.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    MU.cpp

Abstract:

    COM object wrapper for the Bulk USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "COMUSBSimulator.h"
#include "MU.h"

CMU::CMU()
    {
    }
CMU::~CMU()
    {
    bulk.SoftBreak(0);
    }

STDMETHODIMP CMU::get_deviceName(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = CreateBstrFromAnsi(bulk.GetName());
    return S_OK;
    }

STDMETHODIMP CMU::get_IP(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    char buffer[32];
    sprintf(buffer, "%u.%u.%u.%u", ((unsigned char*)&bulk.simIP)[0], ((unsigned char*)&bulk.simIP)[1], ((unsigned char*)&bulk.simIP)[2], ((unsigned char*)&bulk.simIP)[3]);
    *pVal = CreateBstrFromAnsi(buffer);
    return S_OK;
    }

STDMETHODIMP CMU::put_IP(const BSTR newVal)
    {
    USES_CONVERSION;
    if(!newVal) return E_INVALIDARG;
    bulk.simIP = inet_addr(W2A(newVal));
    return S_OK;
    }

STDMETHODIMP CMU::get_port(short *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = bulk.usbPort;
    return S_OK;
    }

STDMETHODIMP CMU::put_port(short newVal)
    {
    bulk.usbPort = (char)newVal;
    bulk.destPort = htons(newVal+SIM_NETPORT_BASE);
    return S_OK;
    }

STDMETHODIMP CMU::get_enumerated(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    if(bulk.IsEnumerated()) *pVal = TRUE;
    else *pVal = FALSE;
    return S_OK;
    }

STDMETHODIMP CMU::get_record(BOOL *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    *pVal = bulk.record;
    return S_OK;
    }

STDMETHODIMP CMU::put_record(BOOL newVal)
    {
    bulk.record = !!newVal;
    return S_OK;
    }

STDMETHODIMP CMU::Plug(void)
    {
    bulk.Plug();
    return S_OK;
    }

STDMETHODIMP CMU::Unplug(void)
    {
    bulk.Unplug();
    return S_OK;
    }

STDMETHODIMP CMU::EndpointMode(short mode)
    {
    if(mode<0 || mode>3) return E_INVALIDARG;
    bulk.EndpointConfig(mode);
    return S_OK;
    }

STDMETHODIMP CMU::SetCapacity(unsigned long numBlocks, unsigned short blockSize, unsigned short logicalSize /*=0*/)
    {
    bulk.SetCapacity(numBlocks, blockSize, logicalSize);
    return S_OK;
    }

STDMETHODIMP CMU::FakeCapacity(unsigned long numBlocks, unsigned short blockSize, unsigned short logicalSize)
    {
    bulk.SetCapacity(0x3EFF, 0x0200, 0); // 8megs
    bulk.capacity.numBlocks = numBlocks;
    bulk.capacity.blockSize = blockSize;
    bulk.capacity.logicalSize = logicalSize;

    return S_OK;
    }

STDMETHODIMP CMU::LoadMU(const BSTR filename, unsigned long *pErr)
    {
    USES_CONVERSION;
    if(!filename) return E_INVALIDARG;
    if(!pErr) return E_INVALIDARG;

    *pErr = bulk.LoadMU(W2A(filename));

    return S_OK;
    }

STDMETHODIMP CMU::StoreMU(const BSTR filename, unsigned long *pErr)
    {
    USES_CONVERSION;
    if(!filename) return E_INVALIDARG;
    if(!pErr) return E_INVALIDARG;

    *pErr = bulk.StoreMU(W2A(filename));

    return S_OK;
    }

STDMETHODIMP CMU::Free(void)
    {
    Lock();
    delete[] bulk.storage;
    bulk.storage = NULL;
    Unlock();

    return S_OK;
    }

STDMETHODIMP CMU::Unformat(void)
    {
    Lock();
    memset(bulk.storage, 0xFF, (DWORD)bulk.capacity.numBlocks * (DWORD)bulk.capacity.blockSize);
    Unlock();

    return S_OK;
    }

STDMETHODIMP CMU::Format()
    {
    if(((DWORD)bulk.capacity.numBlocks * (DWORD)bulk.capacity.blockSize) < 8192) return S_OK;

    bulk.Lock();
    memset(bulk.storage, 0xFF, 4096);
    memset(bulk.storage+4096, 0x00, 4096);

    // FATX header
    memcpy(bulk.storage, "\x46\x41\x54\x58\x10\xB9\xD7\xBF\x04\x00\x00\x00\x01\x00\x00\x00\x00\x00", 18);

    // serial number
    bulk.storage[0x0004] = rand()%256;
    bulk.storage[0x0005] = rand()%256;
    bulk.storage[0x0006] = rand()%256;
    bulk.storage[0x0007] = rand()%256;

    bulk.storage[0x1000] = 0xF8;
    bulk.storage[0x1001] = 0xFF;
    bulk.storage[0x1002] = 0xFF;
    bulk.storage[0x1003] = 0xFF;
    bulk.Unlock();

    return S_OK;
    }


STDMETHODIMP CMU::get_data(unsigned long offset, unsigned long length, BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    if(offset + length >= (DWORD)bulk.capacity.numBlocks * (DWORD)bulk.capacity.blockSize) return E_INVALIDARG;
    bulk.Lock();
    *pVal = CreateBstrFromAnsi((char*)bulk.storage+offset, length);
    bulk.Unlock();
    return S_OK;
    }

STDMETHODIMP CMU::put_data(unsigned long offset, unsigned long length, BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    if(offset + length >= (DWORD)bulk.capacity.numBlocks * (DWORD)bulk.capacity.blockSize) return E_INVALIDARG;
    bulk.Lock();
    for(unsigned long i=0; i<length; i++)
        bulk.storage[offset+i] = (unsigned __int8)newVal[i];
    bulk.Unlock();
    return S_OK;
    }

STDMETHODIMP CMU::get_deviceDescriptor(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    bulk.Lock();
    *pVal = CreateBstrFromAnsi((char*)bulk.deviceDescriptor, 8);
    bulk.Unlock();
    return S_OK;
    }

STDMETHODIMP CMU::put_deviceDescriptor(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    bulk.Lock();
    for(unsigned i=0; i<8; i++)
        bulk.deviceDescriptor[i] = (unsigned __int8)newVal[i];
    bulk.Unlock();
    return S_OK;
    }

STDMETHODIMP CMU::get_configurationDescriptor(BSTR *pVal)
    {
    if(!pVal) return E_INVALIDARG;
    bulk.Lock();
    *pVal = CreateBstrFromAnsi((char*)bulk.configurationDescriptor, 32);
    bulk.Unlock();
    return S_OK;
    }

STDMETHODIMP CMU::put_configurationDescriptor(BSTR newVal)
    {
    if(!newVal) return E_INVALIDARG;
    bulk.Lock();
    for(unsigned i=0; i<32; i++)
        bulk.configurationDescriptor[i] = (unsigned __int8)newVal[i];
    bulk.Unlock();
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\MU.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    MU.h

Abstract:

    COM object wrapper for the Bulk USB Device class

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#ifndef __MU_H_
#define __MU_H_

#include "resource.h"       // main symbols

class ATL_NO_VTABLE CMU : public CComObjectRootEx<CComSingleThreadModel>, public CComCoClass<CMU, &CLSID_MU>, public IDispatchImpl<IMU, &IID_IMU, &LIBID_USBSIMULATORLib>
    {
    public:
        CMU();
        ~CMU();

    private:
        BulkDevice bulk;

    public:
        DECLARE_REGISTRY_RESOURCEID(IDR_MU)
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        BEGIN_COM_MAP(CMU)
            COM_INTERFACE_ENTRY(IMU)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()

    // IMU
    public:
	    STDMETHOD(FakeCapacity)(/*[in]*/ unsigned long numBlocks, /*[in]*/ unsigned short blockSize, /*[in, defaultvalue(0)]*/ unsigned short logicalSize);
	    STDMETHOD(get_configurationDescriptor)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_configurationDescriptor)(/*[in]*/ BSTR newVal);
	    STDMETHOD(get_deviceDescriptor)(/*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_deviceDescriptor)(/*[in]*/ BSTR newVal);
	    STDMETHOD(get_data)(/*[in]*/ unsigned long offset, /*[in]*/ unsigned long length, /*[out, retval]*/ BSTR *pVal);
	    STDMETHOD(put_data)(/*[in]*/ unsigned long offset, /*[in]*/ unsigned long length, /*[in]*/ BSTR newVal);
	    STDMETHOD(Format)(void);
	    STDMETHOD(Free)(void);
	    STDMETHOD(Unformat)(void);
	    STDMETHOD(StoreMU)(/*[in]*/ const BSTR filename, /*[out, retval]*/ unsigned long *pErr);
	    STDMETHOD(LoadMU)(/*[in]*/ const BSTR filename, /*[out, retval]*/ unsigned long *pErr);
	    STDMETHOD(SetCapacity)(/*[in]*/ unsigned long numBlocks, /*[in]*/ unsigned short blockSize, /*[in, defaultvalue(0)]*/ unsigned short logicalSize);
	    STDMETHOD(EndpointMode)(/*[in]*/ short mode);
	    STDMETHOD(Unplug)(void);
	    STDMETHOD(Plug)(void);
	    STDMETHOD(get_enumerated)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(get_record)(/*[out, retval]*/ BOOL *pVal);
	    STDMETHOD(put_record)(/*[in]*/ BOOL newVal);
        STDMETHOD(get_port)(/*[out, retval]*/ short *pVal);
        STDMETHOD(put_port)(/*[in]*/ short newVal);
        STDMETHOD(get_IP)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(put_IP)(/*[in]*/ const BSTR newVal);
	    STDMETHOD(get_deviceName)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__MU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\COM\USBSimulator\USBSimulator.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    USBSimulator.cpp

Abstract:

    Implementation of DLL Exports

Author:

    Josh Poley (jpoley)

Revision History:

Notes:
    Proxy/Stub Information
        To build a separate proxy/stub DLL, 
        run nmake -f USBSimulatorps.mk in the project directory.

*****************************************************************************/
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "COMUSBSimulator.h"

#include "USBSimulator_i.c"
#include "Duke.h"
#include "MU.h"
#include "Hawk.h"
#include "Simulator.h"
#include "Debugger.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Duke, CDuke)
OBJECT_ENTRY(CLSID_MU, CMU)
OBJECT_ENTRY(CLSID_Hawk, CHawk)
OBJECT_ENTRY(CLSID_Simulator, CSimulator)
OBJECT_ENTRY(CLSID_Debugger, CDebugger)
END_OBJECT_MAP()


/*****************************************************************************

Routine Description:

    DllMain

    DLL Entry Point

Arguments:


Return Value:

    
*****************************************************************************/
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
    {
    if(dwReason == DLL_PROCESS_ATTACH)
        {
        _Module.Init(ObjectMap, hInstance, &LIBID_USBSIMULATORLib);
        DisableThreadLibraryCalls(hInstance);
        }
    else if(dwReason == DLL_PROCESS_DETACH)
        {
        _Module.Term();
        }
    return TRUE;    // ok
    }


/*****************************************************************************

Routine Description:

    DllCanUnloadNow

    Used to determine whether the DLL can be unloaded by OLE

Arguments:

    none

Return Value:

    
*****************************************************************************/
STDAPI DllCanUnloadNow(void)
    {
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }


/*****************************************************************************

Routine Description:

    DllGetClassObject

    Returns a class factory to create an object of the requested type

Arguments:

Return Value:

*****************************************************************************/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
    return _Module.GetClassObject(rclsid, riid, ppv);
    }


/*****************************************************************************

Routine Description:

    DllRegisterServer

    Adds entries to the system registry

Arguments:

Return Value:

*****************************************************************************/
STDAPI DllRegisterServer(void)
    {
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
    }


/*****************************************************************************

Routine Description:

    DllUnregisterServer

    Removes entries from the system registry

Arguments:

    none

Return Value:
    
*****************************************************************************/
STDAPI DllUnregisterServer(void)
    {
    return _Module.UnregisterServer(TRUE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\buffers.h ===
//****************************************************************************
//	    Filename: buffers.h
//       Project: USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the header file for the buffers module.  It contains
//				  information supporting buffers structures between the network
//                channel and the USB ports.
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/buffers.h $
// $Revision: 1.7 $
// $Date: 2001/03/23 20:03:17Z $ 
// $Author: klpayne $
// $Log: buffers.h $
// Revision 1.7  2001/03/23 20:03:17Z  klpayne
// Reduced buffer size, added more elements
// Revision 1.6  2001/01/29 16:07:30Z  klpayne
// Change xmit/recv buffers to allow 1024 size.
// Revision 1.5  2001/01/10 20:47:28Z  klpayne
// Reduce buffer element size, increase number of them
// Revision 1.4  2001/01/09 21:48:11Z  rjgardner
// Increase size of buffers (MAX_BUF_SIZE) to 1024
// Revision 1.3  2001/01/04 15:35:46Z  klpayne
// Interim checkin
// Revision 1.2  2000/12/19 13:16:12Z  klpayne
// Initial implementation of buffers.
// Revision 1.1  2000/12/06 19:40:01Z  rjgardner
// Initial revision
//
//****************************************************************************
#ifndef BUFFERS_H
#define BUFFERS_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------
#define MAX_BUF_SIZE	512	// maximum size of a buffer
#define NUM_XMIT_ELEMENTS	20		// maximum number of queues in the transmit array
#define NUM_RCV_ELEMENTS	10		// maximum number of queues in the receive array

enum _BUF_INDEX	// note, control channel (200) is handled directly and doesn't need a buffer 
{
	SOCK_201_XMIT,
	SOCK_201_RCV,
	SOCK_202_XMIT,
	SOCK_202_RCV,
	SOCK_203_XMIT,
	SOCK_203_RCV,
	SOCK_204_XMIT,
	SOCK_204_RCV,
    NUM_BUFFERS
};

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------
struct data_element {
	unsigned int size;
	unsigned char data[MAX_BUF_SIZE];
} ;

struct xmit_buffer_queue {
	struct data_element element[NUM_XMIT_ELEMENTS];	// array of data buffer structs 
	unsigned char inindx;	// index used to track putting data into array
	unsigned char outindx;	// index used to track taking data out of array
};

struct rcv_buffer_queue {
	struct data_element element[NUM_RCV_ELEMENTS];	// array of data buffer structs 
	unsigned char inindx;	// index used to track putting data into array
	unsigned char outindx;	// index used to track taking data out of array
};
//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------
extern void Init_Buffers(void);
extern void Put_Buffer(unsigned char buf, unsigned char *ptr, unsigned int size);
extern unsigned int Get_Buffer(unsigned char buf, unsigned char *ptr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\buffers.c ===
//*****************************************************************************
//	    Filename: buffers.c
//       Project: Microsoft USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the source file for the buffers module.  It contains
//				  code to support communication between the network channel
//                and the USB ports.
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/buffers.c $
// $Revision: 1.5 $
// $Date: 2001/03/01 13:24:13Z $ 
// $Author: klpayne $
// $Log: buffers.c $
// Revision 1.5  2001/03/01 13:24:13Z  klpayne
// Add error printout if buffer overrun
// Revision 1.4  2001/01/29 16:07:29Z  klpayne
// Change xmit/recv buffers to allow 1024 size.
// Revision 1.3  2000/12/20 18:04:40Z  klpayne
// Zero'd out size field after using
// Revision 1.2  2000/12/19 13:16:12Z  klpayne
// Initial implementation of buffers.
// Revision 1.1  2000/12/06 19:40:02Z  rjgardner
// Initial revision
//
//*****************************************************************************
#include <mem.h>
#include <stdio.h>
#include "buffers.h"

//------------------------LOCAL CONSTANTS AND MACROS---------------------------

//-----------------------------GLOBAL VARIABLES--------------------------------
static struct xmit_buffer_queue Sock_201_Xmit_Buf;
static struct rcv_buffer_queue Sock_201_Recv_Buf;
static struct xmit_buffer_queue Sock_202_Xmit_Buf;
static struct rcv_buffer_queue Sock_202_Recv_Buf;
static struct xmit_buffer_queue Sock_203_Xmit_Buf;
static struct rcv_buffer_queue Sock_203_Recv_Buf;
static struct xmit_buffer_queue Sock_204_Xmit_Buf;
static struct rcv_buffer_queue Sock_204_Recv_Buf;
//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------

//----------------------PUBLIC FUNCTIONS---------------------------------------
//*****************************************************************************
//
//	   FUNCTION: unsigned int Get_Buffer(unsigned char buf, unsigned char *ptr)
//	DESCRIPTION: this function returns data from the selected buffer   
//
//	     INPUTS: unsigned char buf - which buffer to retrieve from
//				 unsigned char *ptr - pointer to load data into
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
unsigned int Get_Buffer(unsigned char buf, unsigned char *ptr) {

    unsigned char indx;
    unsigned int size;
    unsigned char *sptr;
    struct xmit_buffer_queue *xptr;
    struct rcv_buffer_queue *rptr;
    
    if((buf == SOCK_201_XMIT) || (buf == SOCK_202_XMIT) || (buf == SOCK_203_XMIT) || (buf == SOCK_204_XMIT)) { // its a xmit buffer 
        switch (buf) {
            case SOCK_201_XMIT: // socket 201 xmit
                xptr = &Sock_201_Xmit_Buf;
                break;
            case SOCK_202_XMIT: // socket 202 xmit
                xptr = &Sock_202_Xmit_Buf;
                break;
            case SOCK_203_XMIT: // socket 203 xmit
                xptr = &Sock_203_Xmit_Buf;
                break;
            case SOCK_204_XMIT: // socket 204 xmit
                xptr = &Sock_204_Xmit_Buf;
                break;
        }
        if(xptr->inindx == xptr->outindx) {   // no data in buffers
            return(0);  // return 0 size
        }
        
        indx = xptr->outindx; // set up index into buffer array
        size = xptr->element[indx].size;
        sptr = xptr->element[indx].data;
        memcpy(ptr,sptr,size);
        xptr->element[indx].size = 0;   // make sure it doesn't accidently get reused
    
        xptr->outindx++;
        if(xptr->outindx == NUM_XMIT_ELEMENTS) {    // wrap index
            xptr->outindx = 0;
        }
        return size;
    }
    else {
        switch (buf) {
            case SOCK_201_RCV: // socket 201 recv
                rptr = &Sock_201_Recv_Buf;
                break;
            case SOCK_202_RCV: // socket 202 recv
                rptr = &Sock_202_Recv_Buf;
                break;
            case SOCK_203_RCV: // socket 203 recv
                rptr = &Sock_203_Recv_Buf;
                break;
            case SOCK_204_RCV: // socket 204 recv
                rptr = &Sock_204_Recv_Buf;
                break;
        }
        if(rptr->inindx == rptr->outindx) {   // no data in buffers
            return(0);  // return 0 size
        }
        
        indx = rptr->outindx; // set up index into buffer array
        size = rptr->element[indx].size;
        sptr = rptr->element[indx].data;
        memcpy(ptr,sptr,size);
        rptr->element[indx].size = 0;   // make sure it doesn't accidently get reused
    
        rptr->outindx++;
        if(rptr->outindx == NUM_RCV_ELEMENTS) {    // wrap index
            rptr->outindx = 0;
        }
        return size;
    }

}

//*****************************************************************************
//
//	   FUNCTION: void Put_Buffer(unsigned char buf, unsigned char *ptr, unsigned int size)
//	DESCRIPTION: this function loads data into the selected buffer   
//
//	     INPUTS: unsigned char buf - which buffer to load data to
//				 unsigned char *ptr - pointer to load data from
//               unsigned int size - size of data to load
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void Put_Buffer(unsigned char buf, unsigned char *ptr, unsigned int size) {

    unsigned char indx;
    unsigned char *dptr;
    struct xmit_buffer_queue *xptr;
    struct rcv_buffer_queue *rptr;
    
    if((buf == SOCK_201_XMIT) || (buf == SOCK_202_XMIT) || (buf == SOCK_203_XMIT) || (buf == SOCK_204_XMIT)) { // its a xmit buffer 
        switch (buf) {
            case SOCK_201_XMIT: // socket 201 xmit
                xptr = &Sock_201_Xmit_Buf;
                break;
            case SOCK_202_XMIT: // socket 202 xmit
                xptr = &Sock_202_Xmit_Buf;
                break;
            case SOCK_203_XMIT: // socket 203 xmit
                xptr = &Sock_203_Xmit_Buf;
                break;
            case SOCK_204_XMIT: // socket 204 xmit
                xptr = &Sock_204_Xmit_Buf;
                break;
        }
        indx = xptr->inindx; // set up index into buffer array
        dptr = xptr->element[indx].data;
        memcpy(dptr,ptr,size);
        xptr->element[indx].size = size;
    
        xptr->inindx++;
        if(xptr->inindx == NUM_XMIT_ELEMENTS) {    // wrap index
            xptr->inindx = 0;
        }
        if(xptr->inindx == xptr->outindx) {   // we have problem
            printf("Buffer overrun at %d\r\n",xptr->inindx);      
        }  
    }
    else {
        switch (buf) {
            case SOCK_201_RCV: // socket 201 recv
                rptr = &Sock_201_Recv_Buf;
                break;
            case SOCK_202_RCV: // socket 202 recv
                rptr = &Sock_202_Recv_Buf;
                break;
            case SOCK_203_RCV: // socket 203 recv
                rptr = &Sock_203_Recv_Buf;
                break;
            case SOCK_204_RCV: // socket 204 recv
                rptr = &Sock_204_Recv_Buf;
                break;
        }
        indx = rptr->inindx; // set up index into buffer array
        dptr = rptr->element[indx].data;
        memcpy(dptr,ptr,size);
        rptr->element[indx].size = size;
    
        rptr->inindx++;
        if(rptr->inindx == NUM_RCV_ELEMENTS) {    // wrap index
            rptr->inindx = 0;
        }
    }

}

//*****************************************************************************
//
//	   FUNCTION: void Init_Buffers(void)
//	DESCRIPTION: this function initializes the buffers   
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void Init_Buffers(void) {

    unsigned char i;

    Sock_201_Xmit_Buf.inindx = Sock_201_Xmit_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_XMIT_ELEMENTS;i++) {
        Sock_201_Xmit_Buf.element[i].size = 0; // just a precation
    }
    Sock_201_Recv_Buf.inindx = Sock_201_Recv_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_RCV_ELEMENTS;i++) {
        Sock_201_Recv_Buf.element[i].size = 0; // just a precation
    }
        
    Sock_202_Xmit_Buf.inindx = Sock_202_Xmit_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_XMIT_ELEMENTS;i++) {
        Sock_202_Xmit_Buf.element[i].size = 0; // just a precation
    }
    Sock_202_Recv_Buf.inindx = Sock_202_Recv_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_RCV_ELEMENTS;i++) {
        Sock_202_Recv_Buf.element[i].size = 0; // just a precation
    }
        
    Sock_203_Xmit_Buf.inindx = Sock_203_Xmit_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_XMIT_ELEMENTS;i++) {
        Sock_203_Xmit_Buf.element[i].size = 0; // just a precation
    }
    Sock_203_Recv_Buf.inindx = Sock_203_Recv_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_RCV_ELEMENTS;i++) {
        Sock_203_Recv_Buf.element[i].size = 0; // just a precation
    }
        
    Sock_204_Xmit_Buf.inindx = Sock_204_Xmit_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_XMIT_ELEMENTS;i++) {
        Sock_204_Xmit_Buf.element[i].size = 0; // just a precation
    }
    Sock_204_Recv_Buf.inindx = Sock_204_Recv_Buf.outindx = 0; // init indicies to beginning
    for(i=0;i<NUM_RCV_ELEMENTS;i++) {
        Sock_204_Recv_Buf.element[i].size = 0; // just a precation
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\Ether.c ===
//*****************************************************************************
//	    Filename: Ether.c
//       Project: Microsoft USB Simulator
//	   Copyright: INDesign-LLC, 2000
//
//	 Description:
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/Ether.c $
// $Revision: 1.24 $
// $Date: 2001/03/01 13:25:13Z $ 
// $Author: klpayne $
// $Log: Ether.c $
// Revision 1.24  2001/03/01 13:25:13Z  klpayne
// Change handling of IP xmit to loop until buffer empty of messages
// Revision 1.23  2001/02/15 14:00:43Z  klpayne
// Add support for GPIO set/response commands
// Revision 1.22  2001/02/07 15:50:16Z  rjgardner
// Add finer definitions for ethernet debug messages.  Debug options
// are turned off.
// Revision 1.21  2001/01/25 17:50:46Z  rjgardner
// Remove function Process_Connect and add funtionality into function
// Process_Control_Msg.  Remove function Process_Socket_In and
// add functionality into function Socket_Poll.
// Revision 1.20  2001/01/12 20:47:54Z  rjgardner
// Add new function Simulator_Reset to handle USB channel reset
// command from controller.
// Revision 1.19  2001/01/11 13:41:43Z  rjgardner
// Remove include for version.h and add declaration of extern const
// unsigned char Version[].
// Revision 1.18  2001/01/09 21:30:34Z  rjgardner
// Change response message header from static strings to dynamic
// build to simplify code.
// Revision 1.17  2001/01/08 14:51:15Z  rjgardner
// Add extra debug define to Socket_Poll to eliminate compiler warning
// when debug is turned off.
// Revision 1.16  2001/01/08 14:46:04Z  rjgardner
// Turn off expanded debug messages for release version.
// Revision 1.15  2001/01/05 19:10:08Z  rjgardner
// Give each USB channel its own socket address structure.
// Revision 1.14  2001/01/05 16:14:18Z  rjgardner
// Update processing of USB sockets.
// Revision 1.13  2001/01/05 14:46:50Z  rjgardner
// Update socket Open and Bind for remaining USB channels
// Revision 1.12  2001/01/03 21:46:10Z  rjgardner
// Add new function Open_USB_Socket and support for all four USB
// channels
// Revision 1.11  2000/12/28 21:46:04Z  rjgardner
// Change data size field of MAC response header to be four rather
// than six characters long as per flow document.
// Revision 1.10  2000/12/28 18:14:23Z  rjgardner
// Add new function Get_MAC_Addr to parse MAC address from the
// MAC.TXT file.
// Revision 1.9  2000/12/22 20:54:22Z  rjgardner
// Add logic to respond to status requests from controller.
// Revision 1.8  2000/12/19 20:35:03Z  rjgardner
// Consolidate controller IP address into single variable
// Revision 1.7  2000/12/19 19:57:05Z  rjgardner
// Change destination IP address on USB1 output messages
// Revision 1.6  2000/12/19 18:12:36Z  rjgardner
// Add input and output process on USB1
// Revision 1.5  2000/12/18 21:51:23Z  rjgardner
// Add functions for Process_Connect, Process_Socket_In and
// Process_Socket_Out 
// Revision 1.4  2000/12/16 18:40:37Z  rjgardner
// Consolidate function Check_Msg with function Socket_Poll.
// Revision 1.3  2000/12/14 21:21:40Z  rjgardner
// Add Socket_Poll function
// Revision 1.2  2000/12/13 22:29:08Z  rjgardner
// Add functions Socket_Open(), Socket_Bind() and Check_Msg().
// Revision 1.1  2000/12/06 19:18:02Z  rjgardner
// Initial revision
//
//*****************************************************************************

#include <stdio.h>
#include <ctype.h>
#include <memory.h>
#include "sim.h"
#define NETSOCK_MASTER
#include "netsock.h"
#include "Ether.h"
#include "buffers.h"

//------------------------LOCAL CONSTANTS AND MACROS---------------------------

// NOTE: enable DEBUG in addition to any of the DEBUG_USBx defines
//#define DEBUG
//#define DEBUG_CNTRL
//#define DEBUG_USB1
//#define DEBUG_USB2
//#define DEBUG_USB3
//#define DEBUG_USB4

//-----------------------------GLOBAL VARIABLES--------------------------------

// Netsock data structure
static WSAData SocketData;

// Control socket variables
static SOCKET  CtrlSocket;
static struct sockaddr_in cntlr_ip;

// USB1 socket variables
static SOCKET  USB1Socket;
static struct sockaddr_in usb1_ip;

// USB2 socket variables
static SOCKET  USB2Socket;
static struct sockaddr_in usb2_ip;

// USB3 socket variables
static SOCKET  USB3Socket;
static struct sockaddr_in usb3_ip;

// USB4 socket variables
static SOCKET  USB4Socket;
static struct sockaddr_in usb4_ip;

// IP and MAC address storage variables
static unsigned char ipaddr[IPADDRSIZE];
static unsigned char macaddr[MACADDRSIZE];

// Declare access to version string
extern const unsigned char Version[];

//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------

unsigned char Socket_Open(int);
unsigned char Socket_Bind(int);
unsigned char Process_Control_Msg(unsigned char *, int);
void Get_MAC_Addr(void);
void Simulator_Reset(void);

// The following are public functions for Network access
//
//*****************************************************************************
//
//	   FUNCTION: unsigned char Ether_Init(void)
//	DESCRIPTION: This function initializes the Ethernet channel.
//
//	     INPUTS: None			
//	    RETURNS: TRUE if Ethernet channel could be initialized, FALSE if not		
//        NOTES: This function should be used to initialize the network connection.
//
//*****************************************************************************
unsigned char Ether_Init(void) {
    int err, i;
	struct NetsockConfig cfg;
	unsigned char status = TRUE;

	// GetMAC address
	Get_MAC_Addr();
	
	// Initiate Embedded Netsock stack and start underlying layers
	err = WSAStartup(VREQUEST, &SocketData);

#ifdef DEBUG_CNTRL
	// Display diagnostics
	switch(EmbeddedNetsockLoadError) {
		case 0:
			printf("Successful Netsock initialization!\n");
			break;
		case ENE_LDERR_BIOS:
			printf("System BIOS does not support Embedded Netsock!\n");
			break;
		case ENE_LDERR_ADAPTER:
			printf("No Network adapter found!\n");
			break;
		case ENE_LDERR_MEM:
			printf("Error allocating memory!\n");
			break;
		case ENE_LDERR_NETSOCK:
			printf("Netsock not available!\n");
			break;
	}
#endif

	// Check for stack startup errors
	if(err) {
		printf("WSAStartup failed with error %d\n", err);
		WSACleanup();	// Shut down Embedded Netsock
		status = FALSE;	// Return failure code
	} else {
		// Get our IP address
		ENgetnetconfig(&cfg, sizeof(cfg));

		// Save IP address
		for(i =0; i < IPADDRSIZE; i++) {
			ipaddr[i] = cfg.IPAddr[i];
		}
	}

	// Open control socket
	err = Socket_Open(CNTRL);

	// Check for control socket open errors
	if(err == FALSE) {
		printf("Control Socket_Open failed\n");
		WSACleanup();	// Shut down Embedded Netsock
		status = FALSE;	// Return failure code
	}

	// Bind control socket
	err = Socket_Bind(CNTRL);

	// Check for control socket bind errors
	if(err == FALSE) {
		printf("Control Socket_Bind failed\n");
		WSACleanup();	// Shut down Embedded Netsock
		status = FALSE;	// Return failure code
	}

	// Return status of network stack and control socket startup
	return(status);
}

//*****************************************************************************
//
//	   FUNCTION: unsigned char Socket_Open(int netsock)
//	DESCRIPTION: This function opens the requested socket.
//
//	     INPUTS: Socket Identifier	
//	    RETURNS: TRUE if socket could be allocated, FALSE if not		
//        NOTES: This function should be used to open a network socket.
//
//*****************************************************************************
unsigned char Socket_Open(int netsock) {
	unsigned char status = TRUE;

	// Open the selected network socket
	switch(netsock) {
		case CNTRL:
			// Allocate the requested socket
			CtrlSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

			// Check for command socket error
			if(CtrlSocket == SOCKET_ERROR) {
				printf("Error %d from CmdSocket\n", CtrlSocket);
				status = FALSE;	// Return failure code
			}
			break;

		case USB1:
			// Allocate the requested socket
			USB1Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

			// Check for USB1 socket error
			if(USB1Socket == SOCKET_ERROR) {
				printf("Error %d from USB1Socket\n", USB1Socket);
				status = FALSE;	// Return failure code
			}
			break;

		case USB2:
			// Allocate the requested socket
			USB2Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

			// Check for USB2 socket error
			if(USB2Socket == SOCKET_ERROR) {
				printf("Error %d from USB2Socket\n", USB2Socket);
				status = FALSE;	// Return failure code
			}
			break;

		case USB3:
			// Allocate the requested socket
			USB3Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

			// Check for USB3 socket error
			if(USB3Socket == SOCKET_ERROR) {
				printf("Error %d from USB3Socket\n", USB3Socket);
				status = FALSE;	// Return failure code
			}
			break;

		case USB4:
			// Allocate the requested socket
			USB4Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

			// Check for USB4 socket error
			if(USB4Socket == SOCKET_ERROR) {
				printf("Error %d from USB4Socket\n", USB4Socket);
				status = FALSE;	// Return failure code
			}
			break;

		default:
			break;
	}

	// Return status of socket allocation
	return(status);
}

//*****************************************************************************
//
//	   FUNCTION: unsigned char Socket_Bind(int netsock)
//	DESCRIPTION: This function binds the requested socket.
//
//	     INPUTS: Socket Identifier	
//	    RETURNS: TRUE if socket bind successful, FALSE if not		
//        NOTES: This function should be used to bind a network socket.
//
//*****************************************************************************
unsigned char Socket_Bind(int netsock) {
	int err;
	unsigned char status = TRUE;
	struct sockaddr_in local;

	// Init common variable in local structure for all sockets
	local.sin_family = AF_INET;

	// Bind the selected network socket
	switch(netsock) {
		case CNTRL:
			// Init socket specific variable in command socket local structure
			local.sin_port = htons(CONTROLPORT);

			// Bind command socket
			err = bind(CtrlSocket, &local, sizeof(local));
			break;

		case USB1:
			// Init socket specific variable in USB1 socket local structure
			local.sin_port = htons(USB1PORT);

			// Bind USB1 socket
			err = bind(USB1Socket, &local, sizeof(local));
			break;

		case USB2:
			// Init socket specific variable in USB2 socket local structure
			local.sin_port = htons(USB2PORT);

			// Bind USB2 socket
			err = bind(USB2Socket, &local, sizeof(local));
			break;

		case USB3:
			// Init socket specific variable in USB3 socket local structure
			local.sin_port = htons(USB3PORT);

			// Bind USB3 socket
			err = bind(USB3Socket, &local, sizeof(local));
			break;

		case USB4:
			// Init socket specific variable in USB4 socket local structure
			local.sin_port = htons(USB4PORT);

			// Bind USB4 socket
			err = bind(USB4Socket, &local, sizeof(local));
			break;

		default:
			break;
	}

	// Check for bind error
	if(err == SOCKET_ERROR) {
		printf("Error binding socket: Error %d\n", WSAGetLastError());
		status = FALSE;	// Return failure code
	}

	// Return status of socket allocation
	return(status);
}

//*****************************************************************************
//
//	   FUNCTION: unsigned char Socket_Poll(int netsock)
//	DESCRIPTION: This function checks for and retrieves a message on the
//               requested socket if available.
//
//	     INPUTS: Socket Identifier	
//	    RETURNS: TRUE if control socket connect, FALSE if not		
//        NOTES: this function should be used to check for socket datagrams.
//
//*****************************************************************************
unsigned char Socket_Poll(int netsock) {
	unsigned char status = FALSE;
	char datagram[MAXDGRAMSIZE];
	int err, fromlen, bytecnt;
	unsigned long messagesize;
#ifdef DEBUG
	int i;
#endif

	// Process selected socket
	switch(netsock) {
		case CNTRL:
			// Check for message on control socket
			err = ioctlsocket(CtrlSocket, FIONREAD, &messagesize);

			// Check for socket read error
			if(err == SOCKET_ERROR) {
				printf("ioctlsocket failed with error %d\n", WSAGetLastError());
			} else { // No socket read error
				if(messagesize) { // Check if message available
		
					// Retrieve datagram
					fromlen = sizeof(cntlr_ip);
					bytecnt = recvfrom(CtrlSocket, datagram, sizeof(datagram), FLAGS_ZERO,
			                                &cntlr_ip, (int far *) &fromlen);

					// Check for socket read error
					if(bytecnt == SOCKET_ERROR) {
						printf("ioctlsocket on CNTRL failed with error %d\n", WSAGetLastError());
					} else { // Process message

#ifdef DEBUG_CNTRL
						printf("\nControl socket message = ");
						for(i = 0; i < bytecnt; i++) {
							printf(" %0.2x", datagram[i]);
						}
						printf("\n");
#endif		

						// Pass on control channel connect flag
						status = Process_Control_Msg((unsigned char *)&datagram, bytecnt);
					}
				}
			}		
			break;

		case USB1:
			// process only if USB1 is connected
			if(device_status & USB1_CONNECT) {
				// Check for message on USB1 socket
				err = ioctlsocket(USB1Socket, FIONREAD, &messagesize);

				// Check for socket read error
				if(err == SOCKET_ERROR) {
					printf("ioctlsocket on USB1 failed with error %d\n", WSAGetLastError());
				} else { // No socket read error
					if(messagesize) { // Check if message available
		
						// Retrieve datagram
						fromlen = sizeof(usb1_ip);
						bytecnt = recvfrom(USB1Socket, datagram, sizeof(datagram), FLAGS_ZERO,
			                                   &usb1_ip, (int far *) &fromlen);

						// Check for socket read error
						if(bytecnt == SOCKET_ERROR) {
							printf("recvfrom on USB1 failed with error %d\n", WSAGetLastError());
						} else { // Route message

#ifdef DEBUG_USB1
						    printf("\nUSB1 socket message = ");
						    for(i = 0; i < bytecnt; i++) {
							    printf(" %0.2x", datagram[i]);
						    }
						    printf("\n");
#endif		

							Put_Buffer(SOCK_201_RCV, (unsigned char *)&datagram, bytecnt);
						}
					}
				}
			}		
			break;

		case USB2:
			// process only if USB2 is connected
			if(device_status & USB2_CONNECT) {
				// Check for message on USB2 socket
				err = ioctlsocket(USB2Socket, FIONREAD, &messagesize);

				// Check for socket read error
				if(err == SOCKET_ERROR) {
					printf("ioctlsocket on USB2 failed with error %d\n", WSAGetLastError());
				} else { // No socket read error
					if(messagesize) { // Check if message available
		
						// Retrieve datagram
						fromlen = sizeof(usb2_ip);
						bytecnt = recvfrom(USB2Socket, datagram, sizeof(datagram), FLAGS_ZERO,
			                                   &usb2_ip, (int far *) &fromlen);

						// Check for socket read error
						if(bytecnt == SOCKET_ERROR) {
							printf("recvfrom on USB2 failed with error %d\n", WSAGetLastError());
						} else { // Route message

#ifdef DEBUG_USB2
						    printf("\nUSB2 socket message = ");
						    for(i = 0; i < bytecnt; i++) {
							    printf(" %0.2x", datagram[i]);
						    }
						    printf("\n");
#endif		

							Put_Buffer(SOCK_202_RCV, (unsigned char *)&datagram, bytecnt);
						}
					}
				}
			}		
			break;

		case USB3:
			// process only if USB3 is connected
			if(device_status & USB3_CONNECT) {
				// Check for message on USB3 socket
				err = ioctlsocket(USB3Socket, FIONREAD, &messagesize);

				// Check for socket read error
				if(err == SOCKET_ERROR) {
					printf("ioctlsocket on USB3 failed with error %d\n", WSAGetLastError());
				} else { // No socket read error
					if(messagesize) { // Check if message available
		
						// Retrieve datagram
						fromlen = sizeof(usb3_ip);
						bytecnt = recvfrom(USB3Socket, datagram, sizeof(datagram), FLAGS_ZERO,
			                                   &usb3_ip, (int far *) &fromlen);

						// Check for socket read error
						if(bytecnt == SOCKET_ERROR) {
							printf("recvfrom on USB3 failed with error %d\n", WSAGetLastError());
						} else { // Route message

#ifdef DEBUG_USB3
						    printf("\nUSB3 socket message = ");
						    for(i = 0; i < bytecnt; i++) {
							    printf(" %0.2x", datagram[i]);
						    }
						    printf("\n");
#endif		

							Put_Buffer(SOCK_203_RCV, (unsigned char *)&datagram, bytecnt);
						}
					}
				}
			}		
			break;

		case USB4:
			// process only if USB4 is connected
			if(device_status & USB4_CONNECT) {
				// Check for message on USB4 socket
				err = ioctlsocket(USB4Socket, FIONREAD, &messagesize);

				// Check for socket read error
				if(err == SOCKET_ERROR) {
					printf("ioctlsocket on USB4 failed with error %d\n", WSAGetLastError());
				} else { // No socket read error
					if(messagesize) { // Check if message available
		
						// Retrieve datagram
						fromlen = sizeof(usb4_ip);
						bytecnt = recvfrom(USB4Socket, datagram, sizeof(datagram), FLAGS_ZERO,
			                                   &usb4_ip, (int far *) &fromlen);

						// Check for socket read error
					   	if(bytecnt == SOCKET_ERROR) {
							printf("ioctlsocket on USB4 failed with error %d\n", WSAGetLastError());
						} else { // Route message

#ifdef DEBUG_USB4
						    printf("\nUSB4 socket message = ");
						    for(i = 0; i < bytecnt; i++) {
							    printf(" %0.2x", datagram[i]);
						    }
						    printf("\n");
#endif		

							Put_Buffer(SOCK_204_RCV, (unsigned char *)&datagram, bytecnt);
						}
					}
				}
			}		
			break;

		default:
			break;
	}

	// Return socket read status
	return(status);
}

//*****************************************************************************
//
//	   FUNCTION: unsigned char Open_USB_Socket(int netsock)
//	DESCRIPTION: This function opens the requested USB socket if available.
//
//	     INPUTS: Socket Identifier	
//	    RETURNS: TRUE if socket open successful, FALSE if not		
//        NOTES: this function should be used to open USB socket ports.
//
//*****************************************************************************
unsigned char Open_USB_Socket(int netsock) {
	int err;
	unsigned char status = TRUE;

	// Process selected USB socket
	err = Socket_Open(netsock);

	// Check for USB socket open errors
	if(err == FALSE) {
		printf("Socket_Open on USB%d failed\n", netsock);
		status = FALSE;	// Return failure code
	}

	// Bind USB socket
	err = Socket_Bind(netsock);

	// Check for USB socket bind errors
	if(err == FALSE) {
		printf("Socket_Bind on USB%d failed\n", netsock);
		status = FALSE;	// Return failure code
	}

	// Return socket status
	return(status);
}

//*****************************************************************************
//
//	   FUNCTION: void Process_Socket_Out(int netsock)
//	DESCRIPTION: This function checks for outgoing messages to the controller.
//
//	     INPUTS: Socket Identifier	
//	    RETURNS: None		
//        NOTES: This function check for data to send out selected socket.
//
//*****************************************************************************
void Process_Socket_Out(int netsock) {
	unsigned char outbuf[MAXDGRAMSIZE];
	int err = 0, outbufsize = 0;

	// Handle each socket
	switch(netsock) {
		case USB1:
			// process only if USB1 is connected
			if(device_status & USB1_CONNECT) {
				// Check for USB1 output data
				outbufsize = Get_Buffer(SOCK_201_XMIT, (unsigned char *)&outbuf);
                err = 0;

				// Send out message if available
                while((outbufsize) && (err != SOCKET_ERROR)) {  // keep sending till buffer empty or error
					err = sendto(USB1Socket, (char *)&outbuf, outbufsize, FLAGS_ZERO,
		                                             &usb1_ip, sizeof(usb1_ip));
    				outbufsize = Get_Buffer(SOCK_201_XMIT, (unsigned char *)&outbuf);
				}
			}
			break;

		case USB2:
			// process only if USB2 is connected
			if(device_status & USB2_CONNECT) {
				// Check for USB1 output data
				outbufsize = Get_Buffer(SOCK_202_XMIT, (unsigned char *)&outbuf);
                err = 0;

				// Send out message if available
                while((outbufsize) && (err != SOCKET_ERROR)) {  // keep sending till buffer empty or error
					err = sendto(USB2Socket, (char *)&outbuf, outbufsize, FLAGS_ZERO,
		                                             &usb2_ip, sizeof(usb2_ip));
    				outbufsize = Get_Buffer(SOCK_202_XMIT, (unsigned char *)&outbuf);
				}
			}
			break;

		case USB3:
			// process only if USB3 is connected
			if(device_status & USB3_CONNECT) {
				// Check for USB3 output data
				outbufsize = Get_Buffer(SOCK_203_XMIT, (unsigned char *)&outbuf);
                err = 0;

				// Send out message if available
                while((outbufsize) && (err != SOCKET_ERROR)) {  // keep sending till buffer empty or error
					err = sendto(USB3Socket, (char *)&outbuf, outbufsize, FLAGS_ZERO,
		                                             &usb3_ip, sizeof(usb3_ip));
    				outbufsize = Get_Buffer(SOCK_203_XMIT, (unsigned char *)&outbuf);
				}
			}
			break;

		case USB4:
			// process only if USB4 is connected
			if(device_status & USB4_CONNECT) {
				// Check for USB4 output data
				outbufsize = Get_Buffer(SOCK_204_XMIT, (unsigned char *)&outbuf);
                err = 0;

				// Send out message if available
                while((outbufsize) && (err != SOCKET_ERROR)) {  // keep sending till buffer empty or error
					err = sendto(USB4Socket, (char *)&outbuf, outbufsize, FLAGS_ZERO,
		                                             &usb4_ip, sizeof(usb4_ip));
    				outbufsize = Get_Buffer(SOCK_204_XMIT, (unsigned char *)&outbuf);
				}
			}
			break;

		default:
			break;
	}

	// Check for socket error
	if(err == SOCKET_ERROR) {
		printf("Process_Socket_Out: USB%d Error %d\n", netsock, WSAGetLastError());
	}
}

//*****************************************************************************
//
//	   FUNCTION: unsigned char Process_Control_Msg(void)
//	DESCRIPTION: This function processes command messages from the controller.
//
//	     INPUTS: None	
//	    RETURNS: TRUE if IP request message, FALSE otherwise		
//        NOTES: This function processes command socket messages.
//
//*****************************************************************************
unsigned char Process_Control_Msg(unsigned char *cntrlbuf, int cntrlbytecnt) {
	unsigned char connect = FALSE;
	unsigned char command = cntrlbuf[0];
	unsigned char subcommand = cntrlbuf[1];
	unsigned char responsebuf[RESPONSESIZE];
	int err, i, responsebufsize = 0;
    unsigned char temp;

	// Is valid IP request?
	if((cntrlbytecnt == IPREQUESTSIZE) && (command == IPREQUESTCMD) && (subcommand == IPREQUESTSCMD)) {
		// Load IP response header
		responsebuf[responsebufsize++] = IPREQUESTCMD;
		responsebuf[responsebufsize++] = IPREQUESTSCMD;
		responsebuf[responsebufsize++] = NULL;
		responsebuf[responsebufsize++] = IPADDRSIZE;
		responsebuf[responsebufsize++] = NULL;

		// Load IP message data
		for(i = 0; i < IPADDRSIZE; i++) {
			responsebuf[responsebufsize++] = ipaddr[i];
		}

		// Flag as connect request
		connect = TRUE;
	}

	// Is valid status command?
	if((cntrlbytecnt == STATUSCMDSIZE) && (command == STATUSCOMMAND)) {
		// Handle subcommand
		switch(subcommand) {
			// Version request
			case VERSION:
				// Load version response message header
				responsebuf[responsebufsize++] = STATUSCOMMAND;
				responsebuf[responsebufsize++] = VERSION;
				responsebuf[responsebufsize++] = NULL;
				responsebuf[responsebufsize++] = VERSIONSIZE;
				responsebuf[responsebufsize++] = NULL;

				// Load version response message data
				for(i = 0; i < VERSIONSIZE; i++) {
					responsebuf[responsebufsize++] = Version[i];
				}
				break;

			// MAC address request
			case MACADDR:
				// Load MAC address response message header
				responsebuf[responsebufsize++] = STATUSCOMMAND;
				responsebuf[responsebufsize++] = MACADDR;
				responsebuf[responsebufsize++] = NULL;
				responsebuf[responsebufsize++] = MACADDRSIZE;
				responsebuf[responsebufsize++] = NULL;

				// Load MAC address response message data
				for(i = 0; i < MACADDRSIZE; i++) {
					responsebuf[responsebufsize++] = macaddr[i];
				}
				break;

			// Device status request
			case DEVSTATUS:
				// Load device status response message header
				responsebuf[responsebufsize++] = STATUSCOMMAND;
				responsebuf[responsebufsize++] = DEVSTATUS;
				responsebuf[responsebufsize++] = NULL;
				responsebuf[responsebufsize++] = DEVSTATSIZE;
				responsebuf[responsebufsize++] = NULL;

				// Load device status response message data
				responsebuf[responsebufsize++] = device_status;
				break;

			// Invalid subcommand
			default:
				break;
		}
	}

	// Is valid reset request?
	if((cntrlbytecnt == RESETCMDSIZE) && (command == RESETCMD) && (subcommand == RESETSCMD)) {
		// Load reset device response message header
		responsebuf[responsebufsize++] = RESETCMD;
		responsebuf[responsebufsize++] = RESETSCMD;
		responsebuf[responsebufsize++] = NULL;
		responsebuf[responsebufsize++] = DEVSTATSIZE;
		responsebuf[responsebufsize++] = NULL;

		// Reset simulator
		Simulator_Reset();
		
		// Load reset device status response message data
		responsebuf[responsebufsize++] = device_status;
	}

	// Is valid GPIO set request?
	if((cntrlbytecnt == GPIOSETCMDSIZE) && (command == GPIOSETCMD) && (subcommand == GPIOSETSCMD)) {
        temp = inp(GPIO_PORTB);
        temp &= 0x0F;   // keep ready LED settings
        temp |= (cntrlbuf[5] << 4);
        outp(GPIO_PORTB,temp);  // output new setting
    }

	// Is valid GPIO request?
	if((cntrlbytecnt == GPIOREQCMDSIZE) && (command == GPIOREQCMD) && (subcommand == GPIOREQSCMD)) {
		// Load GPIO response message header
		responsebuf[responsebufsize++] = GPIOREQCMD;
		responsebuf[responsebufsize++] = GPIOREQSCMD;
		responsebuf[responsebufsize++] = NULL;
		responsebuf[responsebufsize++] = GPIORESPSIZE;
		responsebuf[responsebufsize++] = NULL;

		// Load GPIO Port C response message data
		responsebuf[responsebufsize++] = inp(GPIO_PORTC);
	}

	// Check if response message to send
	if(responsebufsize) {
		// Send response
		err = sendto(CtrlSocket, (char *)&responsebuf, responsebufsize, FLAGS_ZERO,
			                             &cntlr_ip, sizeof(cntlr_ip));
#ifdef DEBUG_CNTRL
		printf("Response msg =");
		for(i = 0; i < responsebufsize; i++) {
			printf(" %x", responsebuf[i]);
		}
		printf("\n");
#endif

		// Check for socket error
		if(err == SOCKET_ERROR) {
			printf("Process_Control_Msg: Error %d\n", WSAGetLastError());
		}
	}

	// Return connect indication
	return(connect);
}

//*****************************************************************************
//
//	   FUNCTION: void Get_MAC_Addr(void)
//	DESCRIPTION: This function parses MAC.TXT file for MAC address.
//
//	     INPUTS: None	
//	    RETURNS: None		
//        NOTES: This function parses the MAC address.
//
//*****************************************************************************
void Get_MAC_Addr(void) {
	FILE *fp;
	unsigned char ch;
	char *chp;
	char line[MAXLINELEN];
	int i, j;

	// Open and scan MAC.TXT file for MAC address line
	chp = line;
	fp = fopen("MAC.TXT", "r");
	do {
		fgets(line, MAXLINELEN, fp);
	} while(*chp != 'M');
	fclose(fp);

	// Parse out MAC address
	chp = &line[MACOFFSET];
	for(i = 0; i < MACADDRSIZE; i++) { // Cycle through required number of bytes
		for(j = 0; j < 2; j++) {	// Cycle through two characters for each byte
			ch = *chp;				// Get nybble character
			if(isalpha(ch)) {		// Check if alpha character
				ch = toupper(ch);	// Make sure it is upper case
				ch -= 0x37;			// Subtract ascii hex alpha offset
			} else {				// Convert digit character
				ch -= 0x30;			// Subtract ascii hex digit offset
			}
			if(j == 0) {			// Check if most significant nybble
				ch = ch << 4;		// Shift nybble into position
				macaddr[i] = ch;	// Save first nybble
				chp++;				// Go to next nybble
			} else {
				macaddr[i] |= ch;	// Or in second nybble
				chp += 2;			// Skip over ':' to next digit
			}
		}
	}
}

//*****************************************************************************
//
//	   FUNCTION: void Simulator_Reset(void)
//	DESCRIPTION: This function closes USB sockets then resets each USB board.
//
//	     INPUTS: None	
//	    RETURNS: None		
//        NOTES: This function resets the simulator USB channels.
//
//*****************************************************************************
void Simulator_Reset(void) {
	int err;

	// close only if USB1 is connected
	if(device_status & USB1_CONNECT) {
		// Close USB1 socket
		err = closesocket(USB1Socket);

		// Check for socket close error
		if(err == SOCKET_ERROR) {
			printf("Simulator_Reset USB1: Error %d\n", WSAGetLastError());
		}
	}

	// close only if USB2 is connected
	if(device_status & USB2_CONNECT) {
		// Close USB2 socket
		err = closesocket(USB2Socket);

		// Check for socket close error
		if(err == SOCKET_ERROR) {
			printf("Simulator_Reset USB2: Error %d\n", WSAGetLastError());
		}
	}

	// close only if USB3 is connected
	if(device_status & USB3_CONNECT) {
		// Close USB3 socket
		err = closesocket(USB3Socket);

		// Check for socket close error
		if(err == SOCKET_ERROR) {
			printf("Simulator_Reset USB3: Error %d\n", WSAGetLastError());
		}
	}

	// close only if USB4 is connected
	if(device_status & USB4_CONNECT) {
		// Close USB4 socket
		err = closesocket(USB4Socket);

		// Check for socket close error
		if(err == SOCKET_ERROR) {
			printf("Simulator_Reset USB4: Error %d\n", WSAGetLastError());
		}
	}

	// Reset device status word
	device_status = 0;

	// Check for connect on USB channel 1
	if(USB_Init(USB1)) {
		if(Open_USB_Socket(USB1)) {
			device_status |= USB1_CONNECT;
		}
	}

	// Check for connect on USB channel 2
	if(USB_Init(USB2)) {
		if(Open_USB_Socket(USB2)) {
			device_status |= USB2_CONNECT;
		}
	}

	// Check for connect on USB channel 3
	if(USB_Init(USB3)) {
		if(Open_USB_Socket(USB3)) {
			device_status |= USB3_CONNECT;
		}
	}

	// Check for connect on USB channel 4
	if(USB_Init(USB4)) {
		if(Open_USB_Socket(USB4)) {
			device_status |= USB4_CONNECT;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\Ether.h ===
//*****************************************************************************
//	    Filename: Ether.h
//       Project: Microsoft USB Simulator
//	   Copyright: INDesign-LLC, 2000
//
//   Description: This is the header file for the ether module.  It contains
//				  information supporting communications thru the network
//                channel.
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/Ether.h $
// $Revision: 1.16 $
// $Date: 2001/02/15 14:01:01Z $ 
// $Author: klpayne $
// $Log: Ether.h $
// Revision 1.16  2001/02/15 14:01:01Z  klpayne
// Add support for GPIO set/response commands
// Revision 1.15  2001/02/07 15:37:36Z  rjgardner
// Change number of MAC address bytes retrieved as per MS request.
// Revision 1.14  2001/01/25 15:02:58Z  rjgardner
// Remove public function prototype declarations
// Revision 1.13  2001/01/12 20:46:36Z  rjgardner
// Add defines for USB socket reset command
// Revision 1.12  2001/01/10 20:44:56Z  rjgardner
// Return version number size to 5 bytes as per specification.
// Revision 1.11  2001/01/09 21:29:27Z  rjgardner
// Combine IP and status response buffer size define into a single
// define RESPONSESIZE.  Add a size define for the device status
// data length DEVSTATSIZE.
// Revision 1.10  2001/01/03 21:46:49Z  rjgardner
// Add prototype for Open_USB_Socket
// Revision 1.9  2000/12/28 18:12:33Z  rjgardner
// Add MAC address constants
// Revision 1.8  2000/12/22 20:55:27Z  rjgardner
// Add defines for response to status commands from the controller.
// Revision 1.7  2000/12/19 19:57:50Z  rjgardner
// Add new constant IPRESPONSEOFFSET
// Revision 1.6  2000/12/19 18:13:23Z  rjgardner
// Remove global variable extern declarations
// Revision 1.5  2000/12/18 21:52:40Z  rjgardner
// Add support for new functions Process_Connect,
// Process_Socket_In and Process_Socket_Out.
// Revision 1.4  2000/12/16 18:41:14Z  rjgardner
// Add updates for Ether.c revision.
// Revision 1.3  2000/12/14 21:22:34Z  rjgardner
// Update for new Ether.c
// Revision 1.2  2000/12/13 22:30:04Z  rjgardner
// Remove unnecessary definitions.
// Revision 1.1  2000/12/06 19:18:17Z  rjgardner
// Initial revision
//
//*****************************************************************************
#ifndef ETHER_H
#define ETHER_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------
// Version Request command for NETSOCK
#define VREQUEST    0x101

// UDP Port Defines
#define CONTROLPORT 200
#define USB1PORT    201
#define USB2PORT    202
#define USB3PORT    203
#define USB4PORT    204

// Datagram size defines
#define MAXDGRAMSIZE		1024
#define RESPONSESIZE		16

// IP request command defines
#define IPREQUESTSIZE		5
#define IPADDRSIZE			4
#define IPREQUESTCMD		3
#define IPREQUESTSCMD		0

// Status command defines
#define STATUSCOMMAND		4
#define STATUSCMDSIZE		5

// Status subcommand defines
#define VERSIONSIZE 		5
#define MACADDRSIZE			6
#define DEVSTATSIZE			1

// Valid status subcommands
enum subcommands {
	VERSION = 1,
	MACADDR,
	DEVSTATUS
};

// Reset command defines
#define RESETCMD			5
#define RESETSCMD			4
#define RESETCMDSIZE		5

// GPIO set command defines
#define GPIOSETCMDSIZE 		6
#define GPIOSETCMD			5
#define GPIOSETSCMD			5

// GPIO request command defines
#define GPIOREQCMDSIZE		5
#define GPIOREQCMD			5
#define GPIOREQSCMD			6
#define GPIORESPSIZE		1

// Define socket channel designators
enum sockets {
	CNTRL = 0,
	USB1,
	USB2,
	USB3,
	USB4
};

// MAC address defines
#define MAXLINELEN	80
#define MACOFFSET	23

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------

//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\NETSOCK.H ===
//*******************************************************************//
//      NETSOCK.H                                                    //
//                                                                   //
//      Access to Embedded Netsock(tm) TCP/IP stack                  //
//                                                                   //
//      Copyright (c)1998-99 Micro/sys, Inc.                         //
//                                                                   //
//      This file released with Embedded Netsock Version 1.10        //
//*******************************************************************//

#define NETSOCK_H_VERSION       0x1001  // Represents Version 1.10
										// version is byte swapped

#include <dos.h>                        // int86() and int86x() prototypes

//*******************************************************************//
//                                                                   //
//      Type and Structure definitions                               //
//                                                                   //
//*******************************************************************//

typedef int SOCKET;

// standard 32-bit IP address structure (Berkeley)
// confusing because of access by bytes, words, or long
struct in_addr {
	union {
		  struct { unsigned char s_b1, s_b2, s_b3, s_b4; } S_un_b;      // byte access
		  struct { unsigned short s_w1, s_w2; } S_un_w;                 // word access
		  unsigned long S_addr;                                         // long access
	} S_un;
};

#define s_addr  S_un.S_addr     // nickname for accessing in_addr as long

// standard structure for specifying socket address (Berkeley)
struct sockaddr_in {
		short                   sin_family;     // address family (i.e. AF_INET)
		unsigned short          sin_port;       // port for transport layer
		struct in_addr          sin_addr;       // 32-bit IP address structure
		char                    sin_zero[8];    // unused padding
};

// standard structure for information regarding the Sockets implementation
// returned by WSAStartup()
#define WSADESCRIPTION_LEN      256
#define WSASYSSTATUS_LEN        256
typedef struct {
   unsigned int         wVersion;
   unsigned int         wHighVersion;
   char                 szDescription[WSADESCRIPTION_LEN+1];
   char                 szSystemStatus[WSASYSSTATUS_LEN+1];
   unsigned short       iMaxSockets;
   unsigned short       iMaxUdpDg;
   char far *           lpVendorInfo;
}  WSAData;

// Embedded Netsock current operating configuration
// From Flash Setup(tm), possibly modified by DHCP initialization
struct NetsockConfig {
	unsigned char DHCPGetIP_mask_gate;
	unsigned char IPAddr[4];
	unsigned char NetMask[4];
	unsigned char reserved1[4];
	char LocalName[40];
	char reserved2[40];

	unsigned int  AdaptorIOPort;
	unsigned char AdaptorIRQnum;
	unsigned char AdaptorEtherAddr[6];

	unsigned char NumSockets;
	unsigned char reserved3;
	unsigned char SignificantOtherIP[4];
	unsigned char DHCPGetLocalName;
	unsigned char reserved4;
	unsigned char reserved5;
	unsigned char DHCPServerIP[4];
	unsigned char reserved6[4];
	unsigned char reserved7[4];
	unsigned char reserved8;
	unsigned char reserved9;
	};

//*******************************************************************//
//                                                                   //
//      Common functions                                             //
//                                                                   //
//*******************************************************************//

int LoadEmbeddedNetsock(void);
int ENgetnetconfig(struct NetsockConfig * cfg, int len);

#ifndef ALTERNATE_API
//*******************************************************************//
//                                                                   //
//      Winsock API functions                                        //
//                                                                   //
//*******************************************************************//

int WSAStartup(unsigned int wVersionRequested, WSAData *lpWSAData);
int WSACleanup(void);
int closesocket(SOCKET s);
int bind(SOCKET s, const struct sockaddr_in far * name, int namelen);
int getsockopt(SOCKET s, int level, int optname, char far * optval, int far * optlen);
unsigned long htonl(unsigned long hostlong);
unsigned short htons(unsigned short hostshort);
int ioctlsocket(SOCKET s, long cmd, unsigned long far *argp);
unsigned long inet_addr(const char far * cp);
char far *inet_ntoa( struct in_addr in);
unsigned long ntohl(unsigned long netlong);
unsigned short ntohs(unsigned short netshort);
int recvfrom(SOCKET s, char far * buf, int len, int flags, struct sockaddr_in far * from, int far * fromlen);
int sendto(SOCKET s, const char far* buf, int len, int flags, const struct sockaddr_in far * to, int tolen);
int setsockopt(SOCKET s, int level, int optname, const char far * optval, int optlen);
SOCKET socket(int af, int type, int protocol);
int WSAGetLastError(void);
void WSASetLastError(int err);
#endif  // not ALTERNATE_API

#ifdef ALTERNATE_API
//*******************************************************************//
//                                                                   //
//      Alternate API functions                                      //
//                                                                   //
//*******************************************************************//

int ENStartup(void);
int ENsocket(int type, unsigned int localport);
int ENsendto(int sock, char * buffer, int len, unsigned long destIP, unsigned int destport);
int ENrecvfrom(int sock, char * buffer, int len, unsigned long * fromIP, unsigned int * fromport);
int ENclosesocket(int sock);
int ENsetsockopt(SOCKET s, int optname, int optval);
int ENgetsockopt(SOCKET s, int optname);
int ENgetsockrxavail(int sock);
int ENCleanup(void);
unsigned long IPaddress(char * IPstring);
char * IPstring(unsigned long IPaddress);
#endif  // ALTERNATE_API

//*******************************************************************//
//                                                                   //
//      Various constant definitions for function calls              //
//                                                                   //
//*******************************************************************//

//	 run-time access to Netsock functions


//   supported socket types

#define SOCK_DGRAM      2               // UDP datagram sockets
#define SOCK_RAW        3               // raw protocol socket

//      level at which options are defined

#define SOL_SOCKET      0xffff          // socket level options

//   socket options

#define SO_DEBUG        0x01            // turn on debugging info
#define SO_BROADCAST    0x20            // permit sending of broadcast msgs
#define SO_SNDTIMEO     0x1005          // send timeout
#define SO_RCVTIMEO     0x1006          // receive timeout
#define SO_MAX_MSG_SIZE 0x2003                  // max UDP message size (read only)

//      protocols

#define IPPROTO_IP      0               // IP
#define IPPROTO_ICMP    1               // control message protocol
#define IPPROTO_UDP     17              // user datagram protocol
#define IPPROTO_RAW     255             // raw IP packet

//      address families supported

#define AF_INET                 2
#define INADDR_ANY              (unsigned long)0x00000000
#define INADDR_BROADCAST        (unsigned long)0xFFFFFFFF

//      cmd values for ioctlsocket()

#define FIONREAD        (0x4004467FUL)  // UNIX -> Windows -> this strange value

//      various defines

#define FLAGS_ZERO      (0)             // only valid flags value for sendto() and recvfrom()

//*******************************************************************//
//                                                                   //
//      Error return values                                          //
//                                                                   //
//*******************************************************************//

//      Socket creation and use errors

#define         INVALID_SOCKET          (SOCKET)(~0)
#define         SOCKET_ERROR            (-1)

// values returned by WSAGetLastError
#define         WSAEACCES               10013
#define         WSAEFAULT               10014
#define         WSAEINVAL               10022
#define         WSAEMFILE               10024
#define         WSAENOTSOCK             10038
#define         WSAEDESTADDRREQ         10039
#define         WSAEMSGSIZE             10040
#define         WSAEPROTOTYPE           10041
#define         WSAENOPROTOOPT          10042
#define         WSAEPROTONOSUPPORT      10043
#define         WSAEAFNOSUPPORT         10047
#define         WSAENOBUFS              10055
#define         WSAETIMEDOUT            10060
#define         WSAEHOSTUNREACH         10065
#define         WSASYSNOTREADY          10091
#define         WSAVERNOTSUPPORTED      10092
#define         WSANOTINITIALISED       10093

// Embedded Netsock Alternate API errors

#define         ENE_LDERR_BIOS          (-1)
#define         ENE_LDERR_ADAPTER       (-2)
#define         ENE_LDERR_MEM           (-3)
#define         ENE_LDERR_NETSOCK       (-4)

#define         ENE_NETWORKSTART        (-5)
#define         ENE_NOTRUNNING          (-6)
#define         ENE_SOCKTYPE            (-7)
#define         ENE_INVALIDSOCKET       (-8)
#define         ENE_MAXSOCKETS          (-9)
#define         ENE_MEMORY              (-10)
#define         ENE_BUFFERTOOSMALL      (-11)
#define         ENE_MSGTOOBIG           (-12)
#define         ENE_TIMEOUT             (-13)
#define         ENE_PARAM               (-14)
#define         ENE_NOBROADCAST         (-15)
#define         ENE_HOSTUNREACH         (-16)


#ifdef NETSOCK_MASTER
//*******************************************************************//
//                                                                   //
//      Access to built-in Netsock functions                         //
//                                                                   //
//*******************************************************************//

#define MSYS_INT                (0x1A)  // Netsock uses INT 1A for access
#define MSYS_FUNC_AH			(0xDD)	// Use AH = 0xDD for access
#define MSYS_FUNC_AX			(0xDD00)// Use for 16-bit loads, AL will
										//   filled in by caller

//      Loading functions

#define     ENOP_ENSIZE         (0x80)
#define     ENOP_GETCFG         (0x81)
#define     ENOP_LOADNETSOCK    (0x82)

//      Operating functions

#define FIRSTFUNC 0x90

// Winsock API functions

#define     ENOP_START              FIRSTFUNC
#define     ENOP_CLEAN              FIRSTFUNC+1
#define     ENOP_SOCKET             FIRSTFUNC+2
#define     ENOP_SETOPT             FIRSTFUNC+3
#define     ENOP_GETOPT             FIRSTFUNC+4
#define     ENOP_BIND               FIRSTFUNC+5
#define     ENOP_SENDTO             FIRSTFUNC+6
#define     ENOP_RECVFR             FIRSTFUNC+7
#define     ENOP_GETLASTER          FIRSTFUNC+8
#define     ENOP_IOCTL              FIRSTFUNC+9
#define     ENOP_CLOSE              FIRSTFUNC+10
#define     ENOP_GETCURCONFIG       FIRSTFUNC+11
#define     ENOP_SETLASTER          FIRSTFUNC+12

// Alternate API functions

#define     ENOP_ALTSTART           FIRSTFUNC+30
#define     ENOP_ALTSOCK            FIRSTFUNC+31
#define     ENOP_ALTSEND            FIRSTFUNC+32
#define     ENOP_ALTRECV            FIRSTFUNC+33
#define     ENOP_ALTCLOSE           FIRSTFUNC+34
#define     ENOP_ALTRXAVAIL         FIRSTFUNC+35
#define     ENOP_ALTCLEAN           FIRSTFUNC+36
#define     ENOP_ALTGETOPT          FIRSTFUNC+37
#define     ENOP_ALTSETOPT          FIRSTFUNC+38

char ddstring[20];              // return buffer for inet_ntoa()

//  Global values related to loading Embedded Netsock
unsigned int EmbeddedNetsockBaseSegment = 0;
unsigned int EmbeddedNetsockSize = 0;
unsigned int EmbeddedNetsockConfigSize = 0;
unsigned int EmbeddedNetsockVersion = 0;
unsigned int EmbeddedNetsockLoadError = ENE_LDERR_NETSOCK;

//*******************************************************************//
//                                                                   //
//      Common functions                                             //
//                                                                   //
//*******************************************************************//

int LoadEmbeddedNetsock(void)
  {
	union REGS ENRegs;
	struct SREGS ENSregs;
	//unsigned int major, minor;

	ENRegs.h.ah = MSYS_FUNC_AH;                     // Request Version Number
	ENRegs.h.al = 0x00;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	if (ENRegs.x.cflag)                     // if Micro/sys BIOS support not present
	   return(ENE_LDERR_BIOS);

        ENRegs.h.ah = MSYS_FUNC_AH;
	ENRegs.h.al = ENOP_ENSIZE;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	if (!ENRegs.h.al)                       // if 0 then no Ethernet hardware
		return(ENE_LDERR_ADAPTER);
	if (!ENRegs.x.bx)                       // if 0 then no NETSOCK
		return(ENE_LDERR_NETSOCK);

		// save sizes in global variables
	EmbeddedNetsockSize = ENRegs.x.bx;
	EmbeddedNetsockConfigSize = ENRegs.x.cx;

	// allocate memory for Embedded Netsock, fail if not enough memory
	if(_dos_allocmem(ENRegs.x.bx, &EmbeddedNetsockBaseSegment))
	  {
		EmbeddedNetsockBaseSegment = 0;
		return(ENE_LDERR_MEM);
	  }

	// load Embedded Netsock into memory
	ENRegs.h.ah = MSYS_FUNC_AH;
	ENRegs.h.al = ENOP_LOADNETSOCK;
	ENSregs.es = EmbeddedNetsockBaseSegment;
	int86x(MSYS_INT, &ENRegs, &ENRegs, &ENSregs);
	EmbeddedNetsockLoadError = 0;
	EmbeddedNetsockBaseSegment += 0x20;     // account for 512 byte header
	return(0);
  }

int ENgetnetconfig(struct NetsockConfig * cfg, int len)
  {
	union REGS ENRegs;

        if (EmbeddedNetsockLoadError)           // no successful WSAStartup yet
           return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_GETCURCONFIG;
	ENRegs.x.bx = FP_OFF(cfg);
	ENRegs.x.cx = FP_SEG(cfg);
	ENRegs.x.dx = len;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

#ifndef ALTERNATE_API
//*******************************************************************//
//                                                                   //
//      Winsock API functions                                        //
//                                                                   //
//*******************************************************************//

int WSAStartup(unsigned int wVersionRequested, WSAData *lpWSAData)
  {
   union REGS ENRegs;
   //char message[50];
   //unsigned int major, minor;
	int err;

   if(wVersionRequested != 0x0101)      // Embedded Netsock emulates
          return(WSAVERNOTSUPPORTED);   // Windows Sockets version 1.1 only!

        EmbeddedNetsockLoadError = 0;   // Assume no errors in loading
        err = LoadEmbeddedNetsock();    // Load system, any error placed in global
        if (err)
	  {
           EmbeddedNetsockLoadError = err;
           return(WSASYSNOTREADY);
	  }

   ENRegs.x.ax = MSYS_FUNC_AX | ENOP_START;
   ENRegs.x.bx = NETSOCK_H_VERSION;
   ENRegs.x.cx = FP_OFF(lpWSAData);
   ENRegs.x.dx = FP_SEG(lpWSAData);
   int86(MSYS_INT, &ENRegs, &ENRegs);

   EmbeddedNetsockVersion = (*(lpWSAData->lpVendorInfo) << 8) | *(lpWSAData->lpVendorInfo+1);
   return ENRegs.x.ax;
  }



int WSACleanup(void)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_CLEAN;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	_dos_freemem(EmbeddedNetsockBaseSegment - 0x20);
	EmbeddedNetsockBaseSegment = 0;
	EmbeddedNetsockSize = 0;
	EmbeddedNetsockConfigSize = 0;
	EmbeddedNetsockVersion = 0;
	EmbeddedNetsockLoadError = ENE_LDERR_NETSOCK;
	return ENRegs.x.ax;
  }

SOCKET socket(int af,int stype,int prot)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_SOCKET;
	ENRegs.x.bx = af;
	ENRegs.x.cx = stype;
	ENRegs.x.dx = prot;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int closesocket(SOCKET s)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_CLOSE;
	ENRegs.x.bx = s;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return(ENRegs.x.ax);
  }

int setsockopt(SOCKET sock,int level,int name,const char far *optval,int optlen)
  {
	union REGS ENRegs;
	int ENParams[6];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENParams[0] = sock;
	ENParams[1] = level;
	ENParams[2] = name;
	ENParams[3] = FP_OFF(optval);
	ENParams[4] = FP_SEG(optval);
	ENParams[5] = optlen;
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_SETOPT;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int getsockopt(SOCKET sock,int level,int name,char far *optval,int far *optlen)
  {
	union REGS ENRegs;
	int ENParams[7];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENParams[0] = sock;
	ENParams[1] = level;
	ENParams[2] = name;
	ENParams[3] = FP_OFF(optval);
	ENParams[4] = FP_SEG(optval);
	ENParams[5] = FP_OFF(optlen);
	ENParams[6] = FP_SEG(optlen);
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_GETOPT;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int bind(SOCKET sock, const struct sockaddr_in far *addr, int addrlen)
  {
	union REGS ENRegs;
	struct SREGS ENSregs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_BIND;
	ENRegs.x.bx = sock;
	ENRegs.x.cx = addrlen;
	ENRegs.x.dx = FP_OFF(addr);
	ENSregs.es = FP_SEG(addr);
	int86x(MSYS_INT, &ENRegs, &ENRegs, &ENSregs);
	return ENRegs.x.ax;
  }

int sendto(SOCKET sock, const char far *buf, int len, int flags,
		   const struct sockaddr_in far *to, int tolen)
  {
	union REGS ENRegs;
	int ENParams[8];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENParams[0] = sock;
	ENParams[1] = len;
	ENParams[2] = flags;
	ENParams[3] = tolen;
	ENParams[4] = FP_OFF(buf);
	ENParams[5] = FP_SEG(buf);
	ENParams[6] = FP_OFF(to);
	ENParams[7] = FP_SEG(to);
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_SENDTO;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int recvfrom(SOCKET sock, char far *buf, int len, int flags,
		   struct sockaddr_in far *from, int far * fromlen)
  {
	union REGS ENRegs;
	int ENParams[9];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENParams[0] = sock;
	ENParams[1] = len;
	ENParams[2] = flags;
	ENParams[3] = FP_OFF(buf);
	ENParams[4] = FP_SEG(buf);
	ENParams[5] = FP_OFF(from);
	ENParams[6] = FP_SEG(from);
	ENParams[7] = FP_OFF(fromlen);
	ENParams[8] = FP_SEG(fromlen);
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_RECVFR;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

unsigned long htonl(unsigned long hlong)
  {
	register unsigned int nethi, netlo;

	netlo = (unsigned int)((hlong & 0xffff0000L)>>16);        // host high to net low
	nethi = (unsigned int)(hlong & 0xffff);                                 // host low to net high
	nethi = ((nethi & 0xff00)>>8) | ((nethi & 0xff)<<8);    // swap bytes
	netlo = ((netlo & 0xff00)>>8) | ((netlo & 0xff)<<8);
	return ((long)nethi<<16) | (long)netlo;                 // recombine
  }

unsigned short htons(unsigned short hostshort)
  {
	return (((hostshort >> 8) & 0xff) | (hostshort << 8));
  }

void fstrcpy(char far* dest, char far* src)
{
	int n;

	/* copy each element of the string */
	for (n=0; src[n]; n++)
		dest[n] = src[n];

	dest[n] = 0;    /* null-terminate the string */
}

unsigned long inet_addr(const char far * addstr)
  {
   unsigned long a,b,c,d;
   unsigned long netIP;
   char localstr[40];

	fstrcpy((char far *)localstr, (char far *)addstr);
	sscanf(localstr,"%ld.%ld.%ld.%ld",&a,&b,&c,&d);
	netIP = ((d<<24)|(c<<16)|(b<<8) | a);
	return (netIP) ;
  }

char far *inet_ntoa(struct in_addr in)
  {
	unsigned int a,b,c,d;

	a = in.S_un.S_un_b.s_b1;
	b = in.S_un.S_un_b.s_b2;
	c = in.S_un.S_un_b.s_b3;
	d = in.S_un.S_un_b.s_b4;
	sprintf(ddstring,"%d.%d.%d.%d",d,c,b,a);
	return (char far *)ddstring;
  }

int ioctlsocket(SOCKET sock, long cmd, unsigned long far *argp)
  {
	union REGS ENRegs;
	int ENParams[5];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(SOCKET_ERROR);

	ENParams[0] = sock;
	ENParams[1] = (int)(cmd & 0xffff);
	ENParams[2] = (int)(cmd >> 16);
	ENParams[3] = FP_OFF(argp);
	ENParams[4] = FP_SEG(argp);
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_IOCTL;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

unsigned long ntohl(unsigned long nlong)
  {
	register int hosthi, hostlo;

	hostlo = (int)((nlong & 0xffff0000L)>>16);              // net high to host low
	hosthi = (int)(nlong & 0xffff);                         // net low to host high
	hosthi = ((hosthi & 0xff00)>>8) | ((hosthi & 0xff)<<8); // swap bytes
	hostlo = ((hostlo & 0xff00)>>8) | ((hostlo & 0xff)<<8);
	return ((long)hosthi<<16) | (long)hostlo;               // recombine
  }

unsigned short ntohs(unsigned short netshort)
  {
	return (((netshort >> 8) & 0xff) | (netshort << 8));
  }

int WSAGetLastError(void)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(WSANOTINITIALISED);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_GETLASTER;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

void WSASetLastError(int err)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)
	  return;

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_SETLASTER;
	ENRegs.x.bx = err;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return;
  }
#endif  // not ALTERNATE_API

#ifdef ALTERNATE_API
//*******************************************************************//
//                                                                   //
//      Alternate API functions                                      //
//                                                                   //
//*******************************************************************//

int ENStartup(void)
  {
	union REGS ENRegs;
	int err;

	err = LoadEmbeddedNetsock();
	if(err)
	  {
		EmbeddedNetsockLoadError = err;
		return(err);
	  }
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTSTART;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENsocket(int type, unsigned int localport)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTSOCK;
	ENRegs.x.bx = type;
	ENRegs.x.cx = localport;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENsendto(int sock, char * buffer, int len, unsigned long destIP, unsigned int destport)
  {
	union REGS ENRegs;
	int ENParams[7];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENParams[0] = sock;
	ENParams[1] = FP_OFF(buffer);
	ENParams[2] = FP_SEG(buffer);
	ENParams[3] = len;
	ENParams[4] = FP_OFF(destIP);
	ENParams[5] = FP_SEG(destIP);
	ENParams[6] = destport;
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTSEND;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENrecvfrom(int sock, char * buffer, int len, unsigned long * fromIP, unsigned int * fromport)
  {
	union REGS ENRegs;
	int ENParams[8];
	void far * fp;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENParams[0] = sock;
	ENParams[1] = len;
	ENParams[2] = FP_OFF(buffer);
	ENParams[3] = FP_SEG(buffer);
	ENParams[4] = FP_OFF(fromIP);
	ENParams[5] = FP_SEG(fromIP);
	ENParams[6] = FP_OFF(fromport);
	ENParams[7] = FP_SEG(fromport);
	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTRECV;
	fp=(void far *)ENParams;
	ENRegs.x.dx = FP_OFF(fp);
	ENRegs.x.cx = FP_SEG(fp);
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENclosesocket(int sock)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTCLOSE;
	ENRegs.x.bx = sock;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENgetsockrxavail(int sock)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTRXAVAIL;
	ENRegs.x.bx = sock;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENgetsockopt(int sock, int optname)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTGETOPT;
	ENRegs.x.bx = sock;
	ENRegs.x.cx = optname;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENsetsockopt(int sock, int optname, int optval)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTSETOPT;
	ENRegs.x.bx = sock;
	ENRegs.x.cx = optname;
	ENRegs.x.dx = optval;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

int ENCleanup(void)
  {
	union REGS ENRegs;

	if(EmbeddedNetsockLoadError)            // no successful WSAStartup yet
	  return(ENE_NOTRUNNING);

	ENRegs.x.ax = MSYS_FUNC_AX | ENOP_ALTCLEAN;
	int86(MSYS_INT, &ENRegs, &ENRegs);
	return ENRegs.x.ax;
  }

#endif  // ALTERNATE_API

#endif  // NETSOCK_MASTER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\sim.h ===
//*****************************************************************************
//	    Filename: sim.h
//       Project: Microsoft USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the common header file for the project
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/sim.h $
// $Revision: 1.18 $
// $Date: 2001/05/08 14:59:56Z $ 
// $Author: klpayne $
// $Log: sim.h $
// Revision 1.18  2001/05/08 14:59:56Z  klpayne
// Add prototypes for stall
// Revision 1.17  2001/01/25 17:48:51Z  rjgardner
// Remove public declaration for function Process_Connect.
// Revision 1.16  2001/01/25 15:03:52Z  rjgardner
// Add public function declarations for Ether.c which were originally
// in Ether.h
// Revision 1.15  2001/01/23 19:37:19Z  klpayne
// Fix Endpoint array for 4th board.
// Revision 1.14  2001/01/18 16:27:27Z  klpayne
// Add support for ready LED
// Revision 1.13  2001/01/17 20:23:57Z  klpayne
// Support all 8 possible endpoints
// Revision 1.12  2001/01/12 15:09:01Z  klpayne
// Support autorepeat
// Revision 1.11  2001/01/09 21:46:28Z  rjgardner
// Increase maximum USB data transfer size (MAXUSBDATA) to 1024
// Revision 1.10  2001/01/09 21:05:44Z  klpayne
// Make USB_Set_Address public
// Revision 1.9  2001/01/05 19:01:42Z  klpayne
// Cleanup defines and data struct
// Revision 1.8  2001/01/04 19:24:46Z  klpayne
// Support IRQ mapping changes
// Revision 1.7  2001/01/04 15:35:46Z  klpayne
// Interim checkin
// Revision 1.6  2000/12/22 20:51:52Z  rjgardner
// Add extern declaration for device_status byte
// Revision 1.5  2000/12/20 18:05:03Z  klpayne
// Added xmit/receive buffers to endpoint struct
// Revision 1.4  2000/12/15 21:51:46Z  klpayne
// Moved some defines from usb_brd.h to here
// Revision 1.3  2000/12/13 15:21:10Z  klpayne
// Add in GPIO support
// Revision 1.2  2000/12/06 19:20:19Z  rjgardner
// add prototype for Ether_Init
// Revision 1.1  2000/12/05 22:04:54Z  klpayne
// Initial revision
//
//*****************************************************************************
#ifndef SIM_H
#define SIM_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------
#define FALSE 0
#define TRUE 1

// GPIO defines
#define GPIO_CTRL 0x35B	// control reg
#define GPIO_PORTA 0x358	// GPIO Port A
#define GPIO_PORTB 0x359	// GPIO Port B
#define GPIO_PORTC 0x35A	// GPIO Port C

#define GPIO_CTRL_DATA 0x89	// Mode 0, Port A out, Port B out, Port C in (all)

// USB channel connect status defines
#define USB1_CONNECT 0x01
#define USB2_CONNECT 0x02
#define USB3_CONNECT 0x04
#define USB4_CONNECT 0x08

#define MAXUSBDATA	1024	// max usb data transfer size
#define MAXUSBBRDS	4		// max number of usb boards

// number of endpoints
#define USB_MAX_EP 8

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------
// defines associated with global USB info
//
struct EndpointSetup
{
    unsigned char fifosize;	// size of endpoint fifo
    unsigned char type; // type of endpoint (see enum)
    unsigned char autorepeat; // autorepeat on/off
	unsigned char ack;	// indicates need to send an ack phase
	int xmitbuffercnt;	// count of chars to xmit
    int xmitrepeatcnt;	// retains count if repeat is on
	unsigned char *xmitbufferptr;	// ptr to buffer of chars to xmit
    unsigned char xmit_buf[MAXUSBDATA];	// buffer for xmitting to controller
};

// endpoint type setting
enum Endpoint_Type
{
	USB_DISABLE_PIPE = 0,
	USB_ISOC_PIPE,
	USB_NISOC_PIPE,
	USB_CTRL_PIPE
};

extern unsigned char USB_INTR_FLAG[];
extern struct EndpointSetup Endpoints[MAXUSBBRDS+1][USB_MAX_EP]; // array of endpoint structs
extern unsigned char new_usb_addr;
extern unsigned char device_status;

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------

//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------
extern void Sim_Init(void);
extern unsigned char USB_Init(unsigned char);
extern void interrupt USB_Intr_Brd1();
extern void interrupt USB_Intr_Brd2();
extern void interrupt USB_Intr_Brd3();
extern void interrupt USB_Intr_Brd4();
extern void USB_Intr_Handler(unsigned char);
extern void USB_SetupEP(unsigned char, unsigned char);
extern void USB_Connect(unsigned char);
extern void USB_Disconnect(unsigned char);
extern void USB_Stall(unsigned char, unsigned char);
extern void USB_UnStall(unsigned char, unsigned char);
extern void Check_USB_Xmit(unsigned char, unsigned char);
extern void USB_Set_Address(unsigned char,unsigned char);
extern unsigned char Ether_Init(void);
extern unsigned char Open_USB_Socket(int);
extern unsigned char Socket_Poll(int);
extern void Process_Socket_Out(int);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\sim_init.c ===
//*****************************************************************************
//	    Filename: sim_init.c
//       Project: Microsoft USB Simulator
//	   Copyright: INDesign-LLC, 2000
//
//	 Description:
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/sim_init.c $
// $Revision: 1.6 $
// $Date: 2000/12/19 13:25:33Z $ 
// $Author: klpayne $
// $Log: sim_init.c $
// Revision 1.6  2000/12/19 13:25:33Z  klpayne
// Init buffers
// Revision 1.5  2000/12/18 22:33:01Z  rjgardner
// Remove Usb_Init from Sim_Init
// Revision 1.4  2000/12/14 21:31:33Z  klpayne
// Reorder inits
// Revision 1.3  2000/12/13 15:21:39Z  klpayne
// Add in init of GPIO
// Revision 1.2  2000/12/06 19:20:46Z  rjgardner
// add call to Ether_Init
// Revision 1.1  2000/12/05 22:04:53Z  klpayne
// Initial revision
//
//*****************************************************************************
#include <dos.h>
#include "sim.h"
#include "buffers.h"

//------------------------LOCAL CONSTANTS AND MACROS---------------------------

//-----------------------------GLOBAL VARIABLES--------------------------------

//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------
//*****************************************************************************
//
//	   FUNCTION: static void GPIO_Init(void)
//	DESCRIPTION: This function inits the GPIO.   
//
//	     INPUTS: none			
//	    RETURNS: none		
//        NOTES:
//
//*****************************************************************************
static void GPIO_Init(void) {

    outp(GPIO_CTRL,GPIO_CTRL_DATA);
    outp(GPIO_PORTA,0x55);  // init port A, all boards: reset, D+ off
}
 
//*****************************************************************************
//
//	   FUNCTION: void Sim_Init(void)
//	DESCRIPTION: This function inits the simulator.   
//
//	     INPUTS: none			
//	    RETURNS: none
//        NOTES:
//
//*****************************************************************************
void Sim_Init(void) {

    GPIO_Init();    // init the GPIO
    Init_Buffers(); // init the buffers
	Ether_Init();   // init network channel
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\sim_cmd.c ===
//*****************************************************************************
//	    Filename: sim_cmd.c
//       Project: Microsoft USB Simulator
//	   Copyright: Microsoft Corp, 2000
//
//	 Description: this file contains the functions associated with building and
//                parsing the commands between the simulator and the controller
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/sim_cmd.c $
// $Revision: 1.17 $
// $Date: 2001/05/08 14:59:30Z $ 
// $Author: klpayne $
// $Log: sim_cmd.c $
// Revision 1.17  2001/05/08 14:59:30Z  klpayne
// Add support for stall commands
// Revision 1.16  2001/02/14 17:59:23Z  klpayne
// Add parsing for support of endpoint halt command
// Revision 1.15  2001/01/29 16:07:30Z  klpayne
// Change xmit/recv buffers to allow 1024 size.
// Revision 1.14  2001/01/25 15:57:48Z  klpayne
// Add suspend/resume command support
// Revision 1.13  2001/01/23 18:44:48Z  klpayne
// Remove old set addr code
// Revision 1.12  2001/01/12 15:09:21Z  klpayne
// Modify to support local usb addr setting
// Revision 1.11  2001/01/11 14:32:20Z  klpayne
// Add USB Reset Command
// Revision 1.10  2001/01/10 20:48:14Z  klpayne
// Remove debug code, use real usb address
// Revision 1.9  2001/01/09 21:25:07Z  klpayne
// Remove new_usb_addr variable.
// Revision 1.8  2001/01/09 21:05:11Z  klpayne
// Code cleanup
// Revision 1.7  2001/01/05 19:02:28Z  klpayne
// Cleanup buffer handling
// Revision 1.6  2001/01/04 15:35:46Z  klpayne
// Interim checkin
// Revision 1.5  2000/12/20 18:06:16Z  klpayne
// Changed to use endpoint buffers.
// Changes from first system integration.
// Revision 1.4  2000/12/19 13:23:32Z  klpayne
// Initial support of buffers
// Revision 1.3  2000/12/15 21:52:11Z  klpayne
// Added test code, beginning of command parser
// Revision 1.2  2000/12/14 21:30:33Z  klpayne
// Added handshake command support
// Revision 1.1  2000/12/06 15:33:02Z  klpayne
// Initial revision
//
//*****************************************************************************
#include <stdio.h>
#include <dos.h>
#include <mem.h>
#include "sim.h"
#include "sim_cmd.h"
#include "buffers.h"
#include "USB_brd.h"

//------------------------LOCAL CONSTANTS AND MACROS---------------------------

//-----------------------------GLOBAL VARIABLES--------------------------------
unsigned char buf[1024];

unsigned char New_Usb_Addr;

//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------

//*****************************************************************************
//
//	   FUNCTION: void Sim_To_Cont_USBData(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr)
//	DESCRIPTION: this function loads up a USB data message to send to the controller   
//
//	     INPUTS: unsigned char brd - which brd we are using
//               unsigned char pid - which pid has been received
//				 unsigned char ep - which endpoint
//               unsigned int size - size of the data being sent (does not include PID)
//               unsigned char *ptr - pointer to data to load
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void Sim_To_Cont_USBData(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr) {

    unsigned char *dptr;
    
    if((*ptr == 0x00) && (*(ptr+1) == 0x05)) {    // set address, handle locally
        New_Usb_Addr = *(ptr+2);  // get new addr
    }
    
    if((*ptr == 0x02) && (*(ptr+1) == 0x01) ) {    // clear feature - endpoint halt, need to clear seq
        if(*(ptr+4) <  USB_MAX_EP) {
            USB_SetupEP(brd,*(ptr+4));  // re-setup ep
        }
    }
    
    dptr = buf;
    *dptr++ = CMDUSBDATA; // command 1
    *dptr++ = SUBUSBDATA;   // sub command 0
    *dptr++ = ep;    // set endpoint
    *dptr++ = (size+1) % 256;  // little endian mode
    *dptr++ = (size+1) / 256;  // set size to data plus pid
    *dptr++ = pid;
    memcpy(dptr,ptr,size);

    Put_Buffer((SOCK_201_XMIT + ((brd-1)*2)), (unsigned char *)&buf, (size + 6));  
}

//*****************************************************************************
//
//	   FUNCTION: void Sim_To_Cont_USBHS(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr)
//	DESCRIPTION: this function loads up a USB handshake message to send to the controller   
//
//	     INPUTS: unsigned char brd - which brd we are using
//               unsigned char pid - which pid has been received
//				 unsigned char ep - which endpoint
//               unsigned int size - size of the data being sent (does not include PID)
//               unsigned char *ptr - pointer to data to load
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void Sim_To_Cont_USBHS(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr) {

    unsigned char *dptr;
    
    dptr = buf;
    *dptr++ = CMDUSBHS; // command 2
    if((pid != USB_ACK) && (pid != USB_NAK)) {
        *dptr++ = SUBUSBHSRESET;   // sub command 3 (reset, suspend, resume)
    }
    else {
        *dptr++ = SUBUSBHSACK;   // sub command 1
    }
    *dptr++ = ep;    // set endpoint
    *dptr++ = (size+1) % 256;  // little endian mode
    *dptr++ = (size+1) / 256;  // set size to data plus pid
    *dptr++ = pid;
    memcpy(dptr,ptr,size);

    Put_Buffer((SOCK_201_XMIT + ((brd-1)*2)), (unsigned char *)&buf, (size + 6));  

}

//*****************************************************************************
//
//	   FUNCTION: void Cont_To_Sim_Parser(unsigned char brd)
//	DESCRIPTION: this function parses commands received from the controller   
//
//	     INPUTS: unsigned char brd - which board commands are meant for
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void Cont_To_Sim_Parser(unsigned char brd) {

    unsigned char *ptr;
    unsigned char ep;
    unsigned char i;
    
    if(Get_Buffer((SOCK_201_RCV + ((brd-1)*2)), (unsigned char *)&buf) == 0) {    // no data, return
        return;
    }
    
    ptr = buf;
    if(*ptr == CMDUSBDATA) {  // usb data (1)
        ptr += 2;   // get endpoint
        ep = *ptr++;
        Endpoints[brd][ep].xmitbuffercnt = *ptr++;    // get size of data
        Endpoints[brd][ep].xmitbuffercnt += (*ptr * 256);    // little endian format
        Endpoints[brd][ep].xmitbuffercnt--;    // ignore PID
        if(Endpoints[brd][ep].autorepeat) { // if autorepeat is on, save count
            Endpoints[brd][ep].xmitrepeatcnt = Endpoints[brd][ep].xmitbuffercnt;
        }
        ptr += 2;   // skip PID portion of data
        for(i=0;i<Endpoints[brd][ep].xmitbuffercnt;i++) { // load up receive buffer
            Endpoints[brd][ep].xmit_buf[i] = *ptr++;
        }
        Endpoints[brd][ep].xmitbufferptr = Endpoints[brd][ep].xmit_buf;
        
        if(Endpoints[brd][ep].xmitbuffercnt == 0) { // need to send null ack phase
            Endpoints[brd][ep].ack = 1;
        }
        Check_USB_Xmit(brd,ep);    // force transmit
    }
    else if(*ptr == CMDSIMSETUP) {   // sim setup (5)
        ptr++;  // check sub command
        if(*ptr == SUBATTRIB) {   // attrib (EP) setup (1)
            ptr++;  // get to ep
            ep = *ptr;
            ptr += 3;   // skip field size, get data
            Endpoints[brd][ep].fifosize = *ptr++;    // get fifo size
            Endpoints[brd][ep].type = *ptr++;    // get type
            Endpoints[brd][ep].autorepeat = *ptr++;
            USB_SetupEP(brd,ep);  // setup new ep parameters
        }
        else if(*ptr == SUBCONNECT) {   // connect/disconnect (3)
            ptr += 4;   // get to connect info
            if(*ptr == 0x00) {    // disconnect
                USB_Disconnect(brd);
            }
            else {
                USB_Connect(brd);
            }
        }
        else if(*ptr == SUBSTALL) {   // stall/unstall (7)
            ptr++;  // get to ep
            ep = *ptr;
            ptr += 3;   // skip field size, get data
            if(*ptr == 0x01) {  // stall
                USB_Stall(brd,ep);
            }
            else {  // unstall
                USB_UnStall(brd,ep);
            }
        }
        else {
            ;
        }
    }
    else {
        ;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\sim_cmd.h ===
//*****************************************************************************
//	    Filename: sim_cmd.h
//       Project: Microsoft USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the header file for the sim_cmd.c file
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/sim_cmd.h $
// $Revision: 1.6 $
// $Date: 2001/05/08 14:59:08Z $ 
// $Author: klpayne $
// $Log: sim_cmd.h $
// Revision 1.6  2001/05/08 14:59:08Z  klpayne
// Add stall subcommand
// Revision 1.5  2001/01/11 14:32:48Z  klpayne
// Add USB Reset Command
// Revision 1.4  2000/12/20 18:06:39Z  klpayne
// Add prototype for sim_to_cmd()
// Revision 1.3  2000/12/19 13:23:32Z  klpayne
// Initial support of buffers
// Revision 1.2  2000/12/14 21:30:47Z  klpayne
// Added handshake command support
// Revision 1.1  2000/12/06 15:33:02Z  klpayne
// Initial revision
//
//*****************************************************************************
#ifndef SIM_CMD_H
#define SIM_CMD_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------

enum CMDS	// commands
{
	CMDUSBDATA = 1,
	CMDUSBHS,
	CMDIPQUERY,
	CMDSIMSTAT,
	CMDSIMSETUP
};

enum SUBCMDSUSBDATA	// subcommands for USB data command
{
	SUBUSBDATA = 0
};

enum SUBCMDSUSBHA	// subcommands for USB HS command
{
	SUBUSBHSACK = 1,
	SUBUSBHSOTHER,
    SUBUSBHSRESET
};

enum SUBCMDIPQUERY // subcommands for IP query command
{
	SUBIPQUERY = 0
};

enum SUBCMDSIMSTAT // subcommands for sim status command
{
	SUBVERSION = 1,
	SUBMACADDR,
	SUBSTATUS
};

enum SUBCMDSIMSETUP // subcommands for sim setup command
{
	SUBATTRIB = 1,
	SUBADDR,
	SUBCONNECT,
    SUBSTALL = 7
};

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------

//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------
extern void Sim_To_Cont_USBData(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr);
extern void Sim_To_Cont_USBHS(unsigned char brd, unsigned char pid, unsigned char ep, unsigned int size, unsigned char *ptr);
extern void Cont_To_Sim_Parser(unsigned char brd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\version.h ===
//****************************************************************************
//	    Filename: version.h
//       Project: USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the header file for the simulator application.  It contains
//				  the simulator release version number in human readable form.
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/version.h $
// $Revision: 1.13 $
// $Date: 2001/05/08 14:58:47Z $ 
// $Author: klpayne $
// $Log: version.h $
// Revision 1.13  2001/05/08 14:58:47Z  klpayne
// Version 00.11
// Revision 1.12  2001/03/23 20:03:34Z  klpayne
// Update version to V00.10
// Revision 1.11  2001/03/01 13:25:37Z  klpayne
// Update version to 00.09
// Revision 1.10  2001/02/14 17:58:18Z  klpayne
// Update to version 00.08
// Revision 1.9  2001/02/09 12:52:35Z  klpayne
// Update to V00.07
// Revision 1.8  2001/01/30 13:51:07Z  klpayne
// Update to version 00.06
// Revision 1.7  2001/01/16 14:29:23Z  klpayne
// Update to version 00.05
// Revision 1.6  2001/01/12 15:10:59Z  klpayne
// Update to version 00.04
// Revision 1.5  2001/01/11 13:40:24Z  rjgardner
// Change Version variable to be const rather than static.
// Revision 1.4  2001/01/10 20:40:06Z  klpayne
// Update to 00.03
// Revision 1.3  2001/01/08 14:35:47Z  rjgardner
// Update version number to be 00.02
// Revision 1.2  2000/12/21 15:33:50Z  rjgardner
// Correct module definition
// Revision 1.1  2000/12/21 14:24:22Z  rjgardner
// Initial revision
//
//****************************************************************************
#ifndef VERSION_H
#define VERSION_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------

const unsigned char Version[] = {'0', '0', '.', '1', '1'};

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------

//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\USB_brd.h ===
//****************************************************************************
//	    Filename: USB_brd.h
//       Project: USB Simulator
//	   Copyright: Microsoft, 2000
//
//   Description: This is the header file for the USB_brd module.  It contains
//				  information supporting interfacing the USB_brd and the USB
//				  chip contained on that board.
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/USB_brd.h $
// $Revision: 1.9 $
// $Date: 2001/01/25 15:58:52Z $ 
// $Author: klpayne $
// $Log: USB_brd.h $
// Revision 1.9  2001/01/25 15:58:52Z  klpayne
// Add suspend/resume commands
// Revision 1.8  2001/01/11 14:34:43Z  klpayne
// Add support for USB Reset Command
// Revision 1.7  2001/01/05 19:01:42Z  klpayne
// Cleanup defines and data struct
// Revision 1.6  2001/01/04 19:24:47Z  klpayne
// Support IRQ mapping changes
// Revision 1.5  2000/12/15 21:52:49Z  klpayne
// Adjusted board addresses, moved some defines to sim.h
// Revision 1.4  2000/12/13 15:24:34Z  klpayne
// Move intr processing out of intr handler
// Revision 1.3  2000/12/06 22:05:03Z  klpayne
// Code cleanup
// Revision 1.2  2000/12/06 17:42:57Z  klpayne
// Added support for sim_cmd
// Revision 1.1  2000/12/05 22:04:53Z  klpayne
// Initial revision
//
//****************************************************************************
#ifndef USB_BRD_H
#define USB_BRD_H

//-----------------------PUBLIC CONSTANTS AND MACROS---------------------------

// defines for USB chip registers
#define USB_TXDAT        0x00 // Transmit FIFO Data              W 
#define USB_TXCNTL       0x01 // Tx FIFO Byte Count Low        R/W 
#define USB_TXCNTH       0x02 // Tx FIFO Byte Count High       R/W 
#define USB_TXCON        0x03 // Tx FIFO Control               R/W 
#define USB_TXFLG        0x04 // Tx FIFO Flag                      
#define USB_RXDAT        0x05 // Rx Data Receive FIFO          R   
#define USB_RXCNTL       0x06 // Rx FIFO Byte Count Low        R/W 
#define USB_RXCNTH       0x07 // Rx FIFO Byte Count High       R/W  
#define USB_RXCON        0x08 // Rx FIFO Control               R/W 
#define USB_RXFLG        0x09 // Rx FIFO Flags                 R/W  
#define USB_EPINDEX      0x0A // Endpoint Index                R/W 
#define USB_EPCON        0x0B // Endpoint Control              R/W 
#define USB_TXSTAT       0x0C // Tx FIFO Status                R/W  
#define USB_RXSTAT       0x0D // Rx FIFO Status                R/W   
#define USB_SOFL         0x0E // Start Of Frame Low            R/W 
#define USB_SOFH         0x0F // Start Of Frame High           R/W  
#define USB_FADDR        0x10 // Function Address              R/W 
#define USB_SCR          0x11 // System Control                R/W 
#define USB_SSR          0x12 // System Status                 R/W 
#define USB_SBI          0x14 // Serial Bus Interrupt          R/W 
#define USB_SBI1         0x15 // Serial Bus Interrupt 1        R/W 
#define USB_SBIE         0x16 // Serial Bus Interrupt Enable   R/W 
#define USB_SBIE1        0x17 // Serial Bus Interrupt Enable 1 R/W 
#define USB_REV          0x18 // Hardware Revision Number      R/                                  
#define USB_LOCK         0x19 // Suspend Power Off Locking     R/W 
#define USB_PEND         0x1A // Pend Hardware Status Update   R/W 
#define USB_SCRATCH      0x1B // Scratch Firmware Information  R/W 
#define USB_MCSR         0x1C // Misc. Control/Status          R/W 
#define USB_DSAV         0x1D // Data Set Available            R/W 
#define USB_DSAV1        0x1E // Data Set Available 1          R/W 

// base addresses for each USB board
// NOTE: dip switches on boards MUST be set to match these
#define USB_BRD_1	0x200	// must use IRQ10
#define USB_BRD_2	0x300	// must use IRQ11
#define USB_BRD_3	0x320	// must use IRQ12
#define USB_BRD_4	0x380	// must use IRQ15

// defines for IRQ addresses
#define IRQ09 0x71
#define IRQ10 0x72
#define IRQ14 0x76
#define IRQ15 0x77

// defines for IRQ mask bits
#define IRQ09_MASK 0x02
#define IRQ10_MASK 0x04
#define IRQ14_MASK 0x40
#define IRQ15_MASK 0x80

// value returned when no board is present
#define NO_USB_BRD 0x00

// defines for all/no bits in a register
#define USB_REG_ALL_BITS 0xff
#define USB_REG_NO_BITS 0x00
                                                                 
//    Register definitions for USV_TXCON                        
//    Note: FIFO specified by EPINDEX                              
#define TXCON_TXCLR        0x80 // big Clear & Flush
                                // bits 6:5 determine FIFO size
#define TXCON_NONISO_16    0x00
#define TXCON_NONISO_64    0x20
#define TXCON_NONISO_8     0x40
#define TXCON_NONISO_32    0x60

#define TXCON_ISO_64       0x00
#define TXCON_ISO_256      0x20
#define TXCON_ISO_512      0x40
#define TXCON_ISO_1024     0x60  

#define TXCON_RESERVED     0x10 // RESERVED bit always 0 

#define TXCON_TXISO        0x08 // Tx Iso Data           R/W 
#define TXCON_ATM          0x04 // Auto Tx Management    R/W 
#define TXCON_ADVRM        0x02 // Advance Read Marker   R/W 
#define TXCON_REVRP        0x01 // Reverse Read Pointer  R/W 

//    Register definitions for USB_TXFLG
 
#define TXFLG_TXFIF1      0x80 // TXFIF[1:0]           R   
#define TXFLG_TXFIF0      0x40 // Tx FIFO Index            

#define TXFLG_RESERVED0   0x20
#define TXFLG_RESERVED1   0x10

#define TXFLG_TXEMP       0x08 // Tx Empty             R   
#define TXFLG_TXFULL      0x04 // Tx Full              R   
#define TXFLG_TXURF       0x02 // Tx FIFO Underrun     R/W   
#define TXFLG_TXOVF       0x01 // Tx FIFO Overrun      R/W 
                                                                    
//    Register definitions for USB_RXCON
//    Note: FIFO specified by EPINDEX
#define RXCON_RXCLR        0x80 // big Clear & Flush            
                                // bits 6:5 determine FIFO size 
#define RXCON_NONISO_16    0x00
#define RXCON_NONISO_64    0x20
#define RXCON_NONISO_8     0x40
#define RXCON_NONISO_32    0x60

#define RXCON_ISO_64       0x00
#define RXCON_ISO_256      0x20
#define RXCON_ISO_512      0x40
#define RXCON_ISO_1024     0x60

#define RXCON_RXFFRC       0x10 // FIFO Read Complete    R/W 
#define RXCON_RXISO        0x08 // Rx Iso Data           R/W 
#define RXCON_ARM          0x04 // Auto Rx Management    R/W 
#define RXCON_ADVRM        0x02 // Advance Write Marker  R/W 
#define RXCON_REVRP        0x01 // Reverse Write Pointer R/W 

//    Register definitions for USB_RXFLG
#define RXFLG_RXFIF1      0x80 // RXFIF[1:0]           R   
#define RXFLG_RXFIF0      0x40 // Rx FIFO Index            

#define RXFLG_RESERVED    0x20
#define RXFLG_RXFLUSH     0x10 // Rx FIFO Flush        R   

#define RXFLG_RXEMP       0x08 // Rx Empty             R   
#define RXFLG_RXFULL      0x04 // Rx Full              R   
#define RXFLG_RXURF       0x02 // Rx FIFO Underrun     R/W   
#define RXFLG_RXOVF       0x01 // Rx FIFO Overrun      R/W 

//    Register definitions for USB_EPINDEX  
//    Note: Bits 3:7 are unused
//        & bits 2:0 determine the endpoint Tx Rx pair
#define EPINDEX_EP0        0x00
#define EPINDEX_EP1        0x01
#define EPINDEX_EP2        0x02
#define EPINDEX_EP3        0x03
#define EPINDEX_EP4        0x04
#define EPINDEX_EP5        0x05
#define EPINDEX_EP6        0x06
#define EPINDEX_EP7        0x07

//    Register definitions for USB_EPCON
//    Endpoint Control Register
#define EPCON_RXSTL        0x80 // Stall Rx Endpoint      R/W 
#define EPCON_TXSTL        0x40 // Stall Tx Endpoint      R/W 
#define EPCON_CTLEP        0x20 // Control Endpoint       R/W 
#define EPCON_RXSPM        0x10 // Rx Single-Packet Mode  R/W 
#define EPCON_RXIE         0x08 // Rx Input Enable        R/W 
#define EPCON_RXEPEN       0x04 // Rx Endpoint Enable     R/W 
#define EPCON_TXOE         0x02 // Tx Output Enable       R/W 
#define EPCON_TXEPEN       0x01 // Tx Endpoint Enable     R/W 
                                                                        
//    Register definitions for USB_TXSTAT
//    Endpoint Transmit Status
#define TXSTAT_TXSEQ       0x80 // Tx Current Seq          R/W 
#define TXSTAT_TXDSAM      0x40 // Tx Data-Set-Avail Mode  R/W 
#define TXSTAT_TXNAKE      0x20 // Tx NAK Mode             R/W 
#define TXSTAT_TXFLUSH     0x10 // Tx FIFO Packet Flush    R   
#define TXSTAT_TXSOVW      0x08 // Tx Data Seq Overwrite   R/W 
#define TXSTAT_TXVOID      0x04 // Tx Void                 R/W 
#define TXSTAT_TXERR       0x02 // Tx Error                R   
#define TXSTAT_TXACK       0x01 // Tx Ack                  R   

//    Register definitions for USB_RXSTAT           
//    Endpoint Receive Status
#define RXSTAT_RXSEQ       0x80 // Rx Endpoint Seq         R/W 
#define RXSTAT_RXSETUP     0x40 // Rx SETUP Token          R/W 
#define RXSTAT_STOVW       0x20 // Start Overwrite Flag    R   
#define RXSTAT_EDOVW       0x10 // End Overwrite Flag      R/W 
#define RXSTAT_RXSOVW      0x08 // Rx Data Seq Overwrite     W 
#define RXSTAT_RXVOID      0x04 // Rx Void                 R   
#define RXSTAT_RXERR       0x02 // Rx Error                R   
#define RXSTAT_RXACK       0x01 // Rx Ack                  R   


//    Register definitions for USB_SOFH
//    Start of Frame High
#define SOFH_SOFACK        0x80 // SOF Token Rx Without Error R   
#define SOFH_ASOF          0x40 // Any SOF                    R/W 
#define SOFH_SOFIE         0x20 // SOF Interrupt Enable       R/W 
#define SOFH_FTLOCK        0x10 // Frame Timer Lock           R   
#define SOFH_SOFODIS       0x08 // SOF Pin Output Diable      R/W 

//    Register definitions for USB_SCR
//    System Control
#define SCR_IRQPOL         0x80 // IRQ Polarity               R/W 
#define SCR_RWUPE          0x40 // Enable Remote Wake-Up      R/W 
#define SCR_IE_SUSP        0x20 // Enable Suspend Int         R/W 
#define SCR_IE_RESET       0x10 // Enable Reset Int           R/W 
#define SCR_SRESET         0x08 // Software Reset             R/W 
#define SCR_IRQLVL         0x04 // Int Mode                   R/W 
#define SCR_T_IRQ          0x02 // Global Int Enable          R/W 
#define SCR_RESERVED       0x01 // RESERVED bit always 0          

//    Register definitions for USB_SSR
//    Serial Bus Interrupt
#define SSR_RESERVED       0xE0 // RESERVED bit always 0          
#define SSR_SUSPPO         0x10 // Suspend Power Off          R/W 
#define SSR_SUSDIS         0x08 // Suspend Disable            R/W 
#define SSR_RESUME         0x04 // Resume Detected            R/W 
#define SSR_SUSPEND        0x02 // Suspend Detected           R/W 
#define SSR_RESET          0x01 // USB Reset Detected         R/W 

//    Register definitions for USB_SBI 
//    Serial Bus Interrupt
#define SBI_FRXD3          0x80 // Endpoint 3  R/W 
#define SBI_FTXD3          0x40
#define SBI_FRXD2          0x20 // Endpoint 2  R/W 
#define SBI_FTXD2          0x10
#define SBI_FRXD1          0x08 // Endpoint 1  R/W 
#define SBI_FTXD1          0x04
#define SBI_FRXD0          0x02 // Endpoint 0  R/W 
#define SBI_FTXD0          0x01
                        
//    Register definitions for USB_SBI1
//    Serial Bus Interrupt 
#define SBI1_FRXD7         0x80 // Endpoint 7  R/W 
#define SBI1_FTXD7         0x40
#define SBI1_FRXD6         0x20 // Endpoint 6  R/W 
#define SBI1_FTXD6         0x10
#define SBI1_FRXD5         0x08 // Endpoint 5  R/W 
#define SBI1_FTXD5         0x04
#define SBI1_FRXD4         0x02 // Endpoint 4  R/W 
#define SBI1_FTXD4         0x01

//    Register definitions for USB_SBIE 
//    Serial Bus Interrupt Enable
#define SBIE_FRXIE3        0x80 // Endpoint 3  R/W 
#define SBIE_FTXIE3        0x40
#define SBIE_FRXIE2        0x20 // Endpoint 2  R/W 
#define SBIE_FTXIE2        0x10
#define SBIE_FRXIE1        0x08 // Endpoint 1  R/W 
#define SBIE_FTXIE1        0x04
#define SBIE_FRXIE0        0x02 // Endpoint 0  R/W 
#define SBIE_FTXIE0        0x01

//    Register definitions for USB_SBIE1
//    Serial Bus Interrupt Enable
#define SBIE1_FRXIE7       0x80 // Endpoint 7  R/W 
#define SBIE1_FTXIE7       0x40
#define SBIE1_FRXIE6       0x20 // Endpoint 6  R/W 
#define SBIE1_FTXIE6       0x10
#define SBIE1_FRXIE5       0x08 // Endpoint 5  R/W 
#define SBIE1_FTXIE5       0x04
#define SBIE1_FRXIE4       0x02 // Endpoint 4  R/W 
#define SBIE1_FTXIE4       0x01

//    Register definitions for USB_LOCK
//    Suspend Power-Off Locking
#define LOCK_RESERVED       0xFE // RESERVED bit always 0          
#define LOCK_UNLOCKED       0x01 // Locking Control/Status     R/W 

//    Register definitions for USB_PEND
//    Pend Hardware Status Update
#define PEND_RESERVED       0xFE // RESERVED bit always 0          
#define PEND_PEND           0x01 // Pend                       R/W 

//    Register definitions for USB_SCRATCH
//    Scratch Firmware Inforamtion
#define SCRATCH_IE_RESUME   0x80 // Enable Resume Int          R/W 
#define SCRATCH_SCRATCH     0x7F // Scratch Information        R/W 

//    Register definitions for USB_MCSR
//    Misc Control/Status
#define MCSR_RWUPR          0x80 // Remote Wake-Up Remember    R/W 
#define MCSR_INIT           0x40 // Device Init                R/W 
#define MCSR_SUSPS          0x20 // Suspend Status             R/W 
#define MCSR_PKGID          0x10 // Package ID                 R/W 
#define MCSR_FEAT           0x08 // Feature Enable             R/W 
#define MCSR_BDFEAT         0x04 // Board Feature Enable       R/W 
#define MCSR_SUSPLOE        0x02 // Suspend Lock Out Enable    R/W 
#define MCSR_DPEN           0x01 // DPSL Pull-Up Enable        R/W 

//    Register definitions for USB_DSAV
//    Data Set Available
#define DSAV_RXAV3          0x80 // Rx/Tx Data Set Available 3 R   
#define DSAV_TXAV3          0x40
#define DSAV_RXAV2          0x20 // Rx/Tx Data Set Available 2 R   
#define DSAV_TXAV2          0x10
#define DSAV_RXAV1          0x08 // Rx/Tx Data Set Available 1 R   
#define DSAV_TXAV1          0x04
#define DSAV_RXAV0          0x02 // Rx/Tx Data Set Available 0 R   
#define DSAV_TXAV0          0x01

//    Register definitions for USB_DSAV1
//    Data Set Available
#define DSAV1_RXAV7         0x80 // Rx/Tx Data Set Available 7 R   
#define DSAV1_TXAV7         0x40
#define DSAV1_RXAV6         0x20 // Rx/Tx Data Set Available 6 R   
#define DSAV1_TXAV6         0x10
#define DSAV1_RXAV5         0x08 // Rx/Tx Data Set Available 5 R   
#define DSAV1_TXAV5         0x04
#define DSAV1_RXAV4         0x02 // Rx/Tx Data Set Available 4 R   
#define DSAV1_TXAV4         0x01

// PIDs, handshakes for sending to controller
#define PID_SETUP 0xB4
#define PID_IN 0x96
#define PID_OUT 0x87
#define USB_ACK 0x4B
#define USB_NAK 0x5A
#define USB_DATA0 0xC3
#define USB_DATA1 0xD2
#define USB_RESET 0xFF	// not a real USB PID
#define USB_SUSPEND 0xFE	// not a real USB PID
#define USB_RESUME 0xFD	// not a real USB PID

//-------------------------EXTERN PUBLIC VARIABLES-----------------------------

//-----------------------PUBLIC STRUCTURE DEFINITIONS--------------------------

//------------------------PUBLIC FUNCTION PROTOTYPES---------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\USB_brd.c ===
//*****************************************************************************
//	    Filename: USB_brd.c
//       Project: Microsoft USB Simulator
//	   Copyright: INDesign-LLC, 2000
//
//	 Description: This file contains all of the functions related to handling
//                the USB interface, both public and private functions.
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/USB_brd.c $
// $Revision: 1.28 $
// $Date: 2001/05/08 15:00:27Z $ 
// $Author: klpayne $
// $Log: USB_brd.c $
// Revision 1.28  2001/05/08 15:00:27Z  klpayne
// Add data toggle clear for xmit
// Add stall/unstall support
// Revision 1.27  2001/03/23 20:02:57Z  klpayne
// Revision 1.26  2001/02/14 17:58:53Z  klpayne
// Correct mistake in resetting SEQ bit in endpoint setup
// Revision 1.25  2001/02/09 12:53:08Z  klpayne
// Clean-up SOF intr
// Revision 1.24  2001/01/30 13:50:47Z  klpayne
// Allow disabling of endpoint 0
// Revision 1.23  2001/01/25 15:58:31Z  klpayne
// Add suspend/resume support.
// Make USB_SetAddr static.
// Revision 1.22  2001/01/23 19:37:19Z  klpayne
// Fix Endpoint array for 4th board.
// Revision 1.21  2001/01/18 16:27:54Z  klpayne
// Explore suspend/resume support
// Revision 1.20  2001/01/17 20:23:57Z  klpayne
// Support all 8 possible endpoints
// Revision 1.19  2001/01/17 15:10:42Z  klpayne
// Firm up board detect.
// Revision 1.18  2001/01/16 13:44:06Z  klpayne
// Build for new board irqs
// Revision 1.17  2001/01/12 15:09:45Z  klpayne
// Modify to support local usb addr setting
// Support autorepeat
// Revision 1.16  2001/01/11 14:34:17Z  klpayne
// Add support for USB Reset,
// Clean up after disconnect
// Add enable of SOF intr on isoc pipe setup
// Revision 1.15  2001/01/10 20:49:17Z  klpayne
// Clean up set endpoint
// Revision 1.14  2001/01/09 21:14:13Z  klpayne
// Clean up interrupt handling
// Revision 1.13  2001/01/08 21:19:39Z  klpayne
// Set board 1 to IRQ10/addr 200 to work with old hardware
// Revision 1.12  2001/01/05 19:03:10Z  klpayne
// Make endpoints/board
// Revision 1.11  2001/01/04 19:24:19Z  klpayne
// Support changes to IRQ mapping
// Revision 1.10  2001/01/04 15:35:46Z  klpayne
// Interim checkin
// Revision 1.9  2000/12/20 18:07:03Z  klpayne
// Added test code.
// Revision 1.8  2000/12/19 13:23:33Z  klpayne
// Initial support of buffers
// Revision 1.7  2000/12/15 21:52:25Z  klpayne
// USB operation fixes
// Revision 1.6  2000/12/14 21:32:58Z  klpayne
// Clean up intr handling
// Revision 1.5  2000/12/13 15:24:33Z  klpayne
// Move intr processing out of intr handler
// Revision 1.4  2000/12/06 22:04:46Z  klpayne
// Code cleanup
// Revision 1.3  2000/12/06 15:32:46Z  klpayne
// added calls to sim_cmd functions
// Revision 1.2  2000/12/06 14:11:34Z  klpayne
// Add transmit framework
// Revision 1.1  2000/12/05 22:04:53Z  klpayne
// Initial revision
//
//*****************************************************************************
#include <stdio.h>
#include <dos.h>
#include "sim.h"
#include "USB_brd.h"
#include "sim_cmd.h"

//#define OLDBRD 1
//#define DOSUSPEND 1
//------------------------LOCAL CONSTANTS AND MACROS---------------------------
static unsigned int BRD_ADDRESSES[] = {USB_BRD_1, USB_BRD_2, USB_BRD_3, USB_BRD_4};
static void interrupt (*USB_INTR_VECT[])() = {USB_Intr_Brd1, USB_Intr_Brd2, USB_Intr_Brd3, USB_Intr_Brd4}; // intr vectors/brd
#ifdef OLDBRD
static unsigned int DOS_INTR[] = {IRQ10, IRQ09, IRQ14, IRQ15};  // interrupts/brd
static unsigned char DOS_INTR_MASK[] = {IRQ10_MASK, IRQ09_MASK, IRQ14_MASK, IRQ15_MASK};    // intr masks/brd
#else
static unsigned int DOS_INTR[] = {IRQ09, IRQ10, IRQ14, IRQ15};  // interrupts/brd
static unsigned char DOS_INTR_MASK[] = {IRQ09_MASK, IRQ10_MASK, IRQ14_MASK, IRQ15_MASK};    // intr masks/brd
#endif
static unsigned char USB_BRD_RESET[] = {0x02, 0x08, 0x20, 0x80};    // bits to control reset/brd
static unsigned char USB_BRD_DPLUS[] = {0x01, 0x04, 0x10, 0x40};    // bits to control D+/brd

static unsigned char DSAV_RBITS[] = {DSAV_RXAV0, DSAV_RXAV1, DSAV_RXAV2, DSAV_RXAV3};   // bits for looking at DSAV Recieve flags/EP
static unsigned char DSAV1_RBITS[] = {DSAV1_RXAV4, DSAV1_RXAV5, DSAV1_RXAV6, DSAV1_RXAV7};   // bits for looking at DSAV Recieve flags/EP
static unsigned char DSAV_TBITS[] = {DSAV_TXAV0, DSAV_TXAV1, DSAV_TXAV2, DSAV_TXAV3};   // bits for looking at DSAV Transmit flags/EP
static unsigned char DSAV1_TBITS[] = {DSAV1_TXAV4, DSAV1_TXAV5, DSAV1_TXAV6, DSAV1_TXAV7};   // bits for looking at DSAV Recieve flags/EP
static unsigned char INTR_BITS[] = {(SBIE_FRXIE0 | SBIE_FTXIE0), (SBIE_FRXIE1 | SBIE_FTXIE1), (SBIE_FRXIE2 | SBIE_FTXIE2), (SBIE_FRXIE3 | SBIE_FTXIE3)};   // bits for enabling intrs/EP
static unsigned char INTR1_BITS[] = {(SBIE1_FRXIE4 | SBIE1_FTXIE4), (SBIE1_FRXIE5 | SBIE1_FTXIE5), (SBIE1_FRXIE6 | SBIE1_FTXIE6), (SBIE1_FRXIE7 | SBIE1_FTXIE7)};   // bits for enabling intrs/EP

static unsigned int NON_ISOC_FIFO_SIZE[] = {16, 64, 8, 32}; // actual fifo sizes for non-isoc fifos
static unsigned int ISOC_FIFO_SIZE[] = {64, 256, 512, 1024}; // actual fifo sizes for isoc fifos

//-----------------------------GLOBAL VARIABLES--------------------------------
unsigned char usbdata[MAXUSBDATA];    // usb data buffer
struct EndpointSetup Endpoints[MAXUSBBRDS+1][USB_MAX_EP]; // array of endpoint structs
static unsigned char Usbaddr;   // usb device addr
unsigned char USB_INTR_FLAG[MAXUSBBRDS]; // flag indicating usb intr has occurred/board

extern unsigned char New_Usb_Addr;

//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------

// The following are local, private functions for USB access
//
//*****************************************************************************
//
//	   FUNCTION: static void USB_Write(unsigned char brd, unsigned char reg, unsigned char val)
//	DESCRIPTION: this function handles the low-level writing to the USB chip non-special shared registers   
//
//	     INPUTS: unsigned char brd - which board (address) to write to
//				 unsigned char reg - which reg of the chip to write to
//				 unsigned char val - value to write to reg			
//	    RETURNS: nothing		
//        NOTES: certain registers are shared access registers (both firmware and hardware
//				 can write to them).  these registers should be accessed via USB_Write_SR()
//
//*****************************************************************************
static void USB_Write(unsigned char brd, unsigned char reg, unsigned char val) {

    if (reg > USB_DSAV1) {	// illegal register value
        return;
	}

	outp((BRD_ADDRESSES[brd-1] + reg),(int)val); // set value

}

//*****************************************************************************
//
//	   FUNCTION: static void USB_Write_SR(unsigned char brd, unsigned char reg, unsigned char mask, unsigned char val)
//	DESCRIPTION: this function handles the low-level writing to the USB chip special shared registers   
//
//	     INPUTS: unsigned char brd - which board (address) to write to
//				 unsigned char reg - which reg of the chip to write to
//               unsigned char mask - mask to use in read/modify/write action
//				 unsigned char val - value to write to reg			
//	    RETURNS: nothing		
//        NOTES: certain registers are shared access registers (both firmware and hardware
//				 can write to them).  these registers must have the PEND bit set
//				 before access and then a read/modify/write sequence performed
//
//*****************************************************************************
static void USB_Write_SR(unsigned char brd, unsigned char reg, unsigned char mask, unsigned char val) {

	unsigned char temp_val;

    if (reg > USB_DSAV1) {	// illegal register value
        return;
	}

	outp((BRD_ADDRESSES[brd-1] + USB_PEND),(int)1); // set pending bit

    // Read-Modify-Write register
	temp_val = inp(BRD_ADDRESSES[brd-1] + reg);
	temp_val &= ~mask;
	outp((BRD_ADDRESSES[brd-1] + reg),(int)(temp_val | (val & mask)));

	outp((BRD_ADDRESSES[brd-1] + USB_PEND),(int)0); // clear pending bit

}

//*****************************************************************************
//
//	   FUNCTION: static unsigned char USB_Read(unsigned char brd, unsigned char reg)
//	DESCRIPTION: this function handles the low-level reading from the USB chip registers   
//
//	     INPUTS: unsigned char brd - which board (address) to read from
//				 unsigned char reg - which reg of the chip to read from
//	    RETURNS: unsigned char value of register		
//        NOTES:
//
//*****************************************************************************
static unsigned char USB_Read(unsigned char brd, unsigned char reg) {
    
	return(inp(BRD_ADDRESSES[brd-1] + reg));
}

//*****************************************************************************
//
//	   FUNCTION: static void USB_Set_Address(unsigned char brd, unsigned char addr)
//	DESCRIPTION: this function handles setting the new USB device address  
//
//	     INPUTS: unsigned char brd - which brd to set address
//               unsigned char addr - new address
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
static void USB_Set_Address(unsigned char brd, unsigned char addr) {

    Usbaddr = addr;
	USB_Write(brd,USB_FADDR,Usbaddr);	// set USB address
}

//*****************************************************************************
//
//	   FUNCTION: static void USB_SOF_Handler(unsigned char brd)
//	DESCRIPTION: this function handles a SOF interrupt  
//
//	     INPUTS: unsigned char brd - the active board
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
static void USB_SOF_Handler(unsigned char brd) {

    unsigned char ep, active;
    unsigned int rcvsize, i;

    for(ep=1;ep<USB_MAX_EP;ep++) {   // see if we have an isoc pipe, ep 0 can not be
        if(Endpoints[brd][ep].type == USB_ISOC_PIPE) {    // endpoint is set up as a isoc pipe

            USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP
            
            if(ep < EPINDEX_EP4) {
                active = USB_Read(brd,USB_DSAV) & DSAV_RBITS[ep]; 
            }
            else {
                active = USB_Read(brd,USB_DSAV1) & DSAV1_RBITS[ep]; 
            }

            if(active) {   // see if data received
                if(USB_Read(brd,USB_RXSTAT) & RXSTAT_RXERR) {   // check error handling
                    if(USB_Read(brd,USB_RXFLG) & RXFLG_RXOVF) {
                        USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
                    }
                }		
                else {  // no error, process data
			        rcvsize = USB_Read(brd,USB_RXCNTH) << 8;    // get number of bytes received
			        rcvsize += USB_Read(brd,USB_RXCNTL);
                    for(i=0;i<rcvsize;i++) {    // get data
                        usbdata[i] = USB_Read(brd,USB_RXDAT);
                    }
    	    		if (USB_Read(brd,USB_RXFLG) & RXFLG_RXURF) {    // if underflow, clear, otherwise unlock
	    	    		USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
		    	    }
    		    	else {
	    		    	USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXFFRC);
    		    	}

                    if(USB_Read(brd,USB_RXSTAT) & RXSTAT_RXSEQ) {   // DATA0 must have been last one
                        Sim_To_Cont_USBData(brd,USB_DATA0,ep,rcvsize,usbdata);  // notify controller of data
                    }
                    else {  // DATA1 must have been last one
                        Sim_To_Cont_USBData(brd,USB_DATA1,ep,rcvsize,usbdata);  // notify controller of data
                    }

                }
            }
            						
            if(ep < EPINDEX_EP4) {
                active = USB_Read(brd,USB_DSAV) & DSAV_TBITS[ep]; 
            }
            else {
                active = USB_Read(brd,USB_DSAV1) & DSAV1_TBITS[ep]; 
            }

            if(active) {   // check for transmit available
                // see if we have anything to xmit, may be in the middle of a large packet, or may have received
                // data from last check.  if data has been received, the appropriate endpoint buffer will be loaded
                Check_USB_Xmit(brd, ep);
            }
        }
    }
    USB_Write_SR(brd,USB_SOFH,SOFH_ASOF,USB_REG_NO_BITS);   // clear intr bit
}

//*****************************************************************************
//
//	   FUNCTION: static void USB_EP_Rcv(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function handles endpoint receive intrs for non-isoc pipes,
//               isoc pipes are handled in sof handler
//
//	     INPUTS: unsigned char brd - the active board
//               unsigned char ep - the active endpoint
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
static void USB_EP_Rcv(unsigned char brd, unsigned char ep) {
    
    unsigned int rcvsize, i;
    unsigned char rcvstat;

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    if(Endpoints[brd][ep].type == USB_CTRL_PIPE) {    // endpoint is set up as a control pipe

        rcvstat = USB_Read(brd,USB_RXSTAT); // get recv status
		
        if(rcvstat & RXSTAT_RXSETUP) {	// we have a SETUP packet
            usbdata[0] = Usbaddr;
            usbdata[1] = ep;
            Sim_To_Cont_USBData(brd,PID_SETUP, ep, (unsigned int)2, usbdata); // notify controller of SETUP PID

            USB_Write_SR(brd,USB_RXSTAT,RXSTAT_EDOVW,USB_REG_NO_BITS);   // clear bit to unlock fifo
			rcvsize = USB_Read(brd,USB_RXCNTH) << 8;    // get number of bytes received
			rcvsize += USB_Read(brd,USB_RXCNTL);
            for(i=0;i<rcvsize;i++) {    // get data
                usbdata[i] = USB_Read(brd,USB_RXDAT);
            }

            rcvstat = USB_Read(brd,USB_RXSTAT); // re-read status reg
            USB_Write_SR(brd,USB_RXSTAT,RXSTAT_RXSETUP,USB_REG_NO_BITS);   // clear bit to indicate done w/setup
		
            if(rcvstat & RXSTAT_RXSEQ) {   // DATA0 must have been last one
                Sim_To_Cont_USBData(brd,USB_DATA0,ep,rcvsize,usbdata);  // notify controller of data
            }
            else {  // DATA1 must have been last one
                Sim_To_Cont_USBData(brd,USB_DATA1,ep,rcvsize,usbdata);  // notify controller of data
            }

            if(rcvstat & RXSTAT_RXACK) {	// we have an ack
                Sim_To_Cont_USBHS(brd,USB_ACK, ep, (unsigned int)0, usbdata); // notify controller of ACK
            }

            if (!(rcvstat & (RXSTAT_EDOVW | RXSTAT_STOVW))) {  // unlock current packet
					USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXFFRC);
            }
            Endpoints[brd][ep].xmitbuffercnt = 0;   // flush any unsent data

        }
        else {  // not a setup, get data received and notify controller
            // Error handling for overflow case. Clear FIFO
            // and break out.
            if (rcvstat & RXSTAT_RXERR) {
                if (USB_Read(brd,USB_RXFLG) & RXFLG_RXOVF) {
                    USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
                }
            }
            else {  // we have received valid data, grab it and send to controller
                usbdata[0] = Usbaddr;
                usbdata[1] = ep;
                Sim_To_Cont_USBData(brd,PID_OUT, ep, (unsigned int)2, usbdata); // notify controller of OUT PID
                
    			rcvsize = USB_Read(brd,USB_RXCNTH) << 8;    // get number of bytes received
	    		rcvsize += USB_Read(brd,USB_RXCNTL);
                for(i=0;i<rcvsize;i++) {    // get data
                    usbdata[i] = USB_Read(brd,USB_RXDAT);
                }
	    		if (USB_Read(brd,USB_RXFLG) & RXFLG_RXURF) {    // if underflow, clear, otherwise unlock
		    		USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
			    }
    			else {
	    			USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXFFRC);
		    	}

                if(rcvstat & RXSTAT_RXSEQ) {   // DATA0 must have been last one
                    Sim_To_Cont_USBData(brd,USB_DATA0,ep,rcvsize,usbdata);  // notify controller of data
                }
                else {  // DATA1 must have been last one
                    Sim_To_Cont_USBData(brd,USB_DATA1,ep,rcvsize,usbdata);  // notify controller of data
                }

                if(rcvstat & RXSTAT_RXACK) {	// we have an ack
                    Sim_To_Cont_USBHS(brd,USB_ACK, ep, (unsigned int)0, usbdata); // notify controller of ACK
                }
            }
        }
    }
    else {  // not control pipe, isoc pipe handled by SOF intr, process everything else the same
        rcvstat = USB_Read(brd,USB_RXSTAT); // get recv status
        // Error handling for overflow case. Clear FIFO
        // and break out.
        if (rcvstat & RXSTAT_RXERR) {
            if (USB_Read(brd,USB_RXFLG) & RXFLG_RXOVF) {
                USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
                printf("rcv ovf error, ep%d\r\n",ep);
            }
        }
        else {  // we have received valid data, grab it and send to controller
            usbdata[0] = Usbaddr;
            usbdata[1] = ep;
            Sim_To_Cont_USBData(brd,PID_OUT, ep, (unsigned int)2, usbdata); // notify controller of OUT PID
                
			rcvsize = USB_Read(brd,USB_RXCNTH) << 8;    // get number of bytes received
			rcvsize += USB_Read(brd,USB_RXCNTL);
            for(i=0;i<rcvsize;i++) {    // get data
                usbdata[i] = USB_Read(brd,USB_RXDAT);
            }
            if (USB_Read(brd,USB_RXFLG) & RXFLG_RXURF) {    // we read too many things
                USB_Write(brd,USB_RXCON, USB_Read(brd,USB_RXCON) | RXCON_RXCLR);
// log error to controller????
                printf("rcv urf error, ep%d\r\n",ep);
            }
            else {  // everything okay, clear fifo
                USB_Write(brd,USB_RXCON, (USB_Read(brd,USB_RXCON) | RXCON_RXFFRC));
            }

            if(USB_Read(brd,USB_RXSTAT) & RXSTAT_RXSEQ) {   // DATA0 must have been last one
                Sim_To_Cont_USBData(brd,USB_DATA0,ep,rcvsize,usbdata);  // notify controller of data
            }
            else {  // DATA1 must have been last one
                Sim_To_Cont_USBData(brd,USB_DATA1,ep,rcvsize,usbdata);  // notify controller of data
            }

            if(rcvstat & RXSTAT_RXACK) {	// we have an ack
                Sim_To_Cont_USBHS(brd,USB_ACK, ep, (unsigned int)0, usbdata); // notify controller of ACK
            }
        }
    }

}

//*****************************************************************************
//
//	   FUNCTION: static void USB_EP_Xmit(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function handles endpoint transmit intrs, for non-isoc pipes
//               isoc-pipes are handled in sof handler  
//
//	     INPUTS: unsigned char brd - the active board
//               unsigned char ep - the active endpoint
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
static void USB_EP_Xmit(unsigned char brd, unsigned char ep) {

    unsigned char txstat;

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    txstat = USB_Read(brd,USB_TXSTAT);  // read tx status
    if(txstat & TXSTAT_TXVOID) {  // we have nak'd, let controller know
		USB_Write(brd,USB_TXSTAT, USB_Read(brd,USB_TXSTAT) & ~(TXSTAT_TXVOID | TXSTAT_TXNAKE));    // clear & disable nak indication

        usbdata[0] = Usbaddr;
        usbdata[1] = ep;
        Sim_To_Cont_USBData(brd,PID_IN, ep, (unsigned int)2, usbdata); // notify controller of IN PID
        Sim_To_Cont_USBHS(brd,USB_NAK, ep, (unsigned int)0, usbdata); // notify controller of NAK
    }
    else if(txstat & TXSTAT_TXACK) {  // we have ack'd, let controller know
        USB_Write(brd,USB_TXSTAT,USB_Read(brd,USB_TXSTAT) | TXSTAT_TXNAKE);   // enable NAK intrs on IN PIDs

        usbdata[0] = Usbaddr;
        usbdata[1] = ep;
        Sim_To_Cont_USBData(brd,PID_IN, ep, (unsigned int)2, usbdata); // notify controller of IN PID
        Sim_To_Cont_USBHS(brd,USB_ACK, ep, (unsigned int)0, usbdata); // notify controller of ACK
        if(New_Usb_Addr != 0) { // we've just finished the status phase of a set addr command
            USB_Set_Address(brd,New_Usb_Addr);
            New_Usb_Addr = 0;   // clear indication
        }
        
    }
    Check_USB_Xmit(brd,ep); // check and see if we have anything to xmit
    
}


//*****************************************************************************
//
//	   FUNCTION: static void USB_EP_Handler(unsigned char brd)
//	DESCRIPTION: this function handles endpoint intrs  
//
//	     INPUTS: unsigned char brd - the active board
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
static void USB_EP_Handler(unsigned char brd) {

    unsigned char sbi;

    sbi = USB_Read(brd,USB_SBI);    // check for endpoint intrs on first 4 EPs
    while(sbi) {
		
        if(sbi & SBI_FRXD0) {   // check for receive intr, EP0
            USB_EP_Rcv(brd,EPINDEX_EP0);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FRXD0,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FRXD1) {   // check for receive intr, EP1
            USB_EP_Rcv(brd,EPINDEX_EP1);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FRXD1,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FRXD2) {   // check for receive intr, EP2
            USB_EP_Rcv(brd,EPINDEX_EP2);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FRXD2,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FRXD3) {   // check for receive intr, EP3
            USB_EP_Rcv(brd,EPINDEX_EP3);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FRXD3,USB_REG_NO_BITS);   // clear intr bit
        }

        // now check transmit intrs
        if(sbi & SBI_FTXD0) {   // check for transmit intr, EP0
            USB_EP_Xmit(brd,EPINDEX_EP0);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FTXD0,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FTXD1) {   // check for transmit intr, EP1
            USB_EP_Xmit(brd,EPINDEX_EP1);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FTXD1,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FTXD2) {   // check for transmit intr, EP2
            USB_EP_Xmit(brd,EPINDEX_EP2);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FTXD2,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI_FTXD3) {   // check for transmit intr, EP3
            USB_EP_Xmit(brd,EPINDEX_EP3);   // process endpoint
            USB_Write_SR(brd,USB_SBI,SBI_FTXD3,USB_REG_NO_BITS);   // clear intr bit
        }
        sbi = USB_Read(brd,USB_SBI);    // check for endpoint intrs
    }

    sbi = USB_Read(brd,USB_SBI1);    // check for endpoint intrs on second 4 EPs
    while(sbi) {
        if(sbi & SBI1_FRXD4) {   // check for receive intr, EP4
            USB_EP_Rcv(brd,EPINDEX_EP4);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FRXD4,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FRXD5) {   // check for receive intr, EP5
            USB_EP_Rcv(brd,EPINDEX_EP5);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FRXD5,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FRXD6) {   // check for receive intr, EP6
            USB_EP_Rcv(brd,EPINDEX_EP6);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FRXD6,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FRXD7) {   // check for receive intr, EP7
            USB_EP_Rcv(brd,EPINDEX_EP7);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FRXD7,USB_REG_NO_BITS);   // clear intr bit
        }

        // now check transmit intrs
        if(sbi & SBI1_FTXD4) {   // check for transmit intr, EP4
            USB_EP_Xmit(brd,EPINDEX_EP4);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FTXD4,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FTXD5) {   // check for transmit intr, EP5
            USB_EP_Xmit(brd,EPINDEX_EP5);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FTXD5,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FTXD6) {   // check for transmit intr, EP6
            USB_EP_Xmit(brd,EPINDEX_EP6);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FTXD6,USB_REG_NO_BITS);   // clear intr bit
        }
        if(sbi & SBI1_FTXD7) {   // check for transmit intr, EP7
            USB_EP_Xmit(brd,EPINDEX_EP7);   // process endpoint
            USB_Write_SR(brd,USB_SBI1,SBI1_FTXD7,USB_REG_NO_BITS);   // clear intr bit
        }
        sbi = USB_Read(brd,USB_SBI1);    // check for endpoint intrs
    }
}

// The following are public functions for USB access
//
//*****************************************************************************
//
//	   FUNCTION: unsigned char USB_Init(unsigned char brd)
//	DESCRIPTION: this function initializes the USB chip on the selected board,
//				 if its there and alive   
//
//	     INPUTS: unsigned char brd - which board (address) to init			
//	    RETURNS: TRUE if board was there and could be initialized, FALSE if not		
//        NOTES: this function should be used to initially bring a board up.
//				 USB_SetEP() should be used to set up each endpoint after that.
//
//*****************************************************************************
unsigned char USB_Init(unsigned char brd) {

    unsigned char i;
    unsigned int temp;

    outp(GPIO_PORTA,(inp(GPIO_PORTA) | USB_BRD_RESET[brd-1]));  // un-reset board

    // init the endpoint structures, ep0 is always control
    Endpoints[brd][0].fifosize = 0x02;  // non-isoc size of 8
    Endpoints[brd][0].type = USB_CTRL_PIPE;   // control endpoint         
    Endpoints[brd][0].autorepeat = 0x00; // no auto repeat
    Endpoints[brd][0].xmitbuffercnt = 0x00;  // no chars
    Endpoints[brd][0].xmitbufferptr = (unsigned char *)NULL; // null ptr
    for(i=1;i<USB_MAX_EP;i++) { // remaining endpoints
        Endpoints[brd][i].fifosize = 00;  // non-isoc size of 16
        Endpoints[brd][i].type = USB_DISABLE_PIPE;   // endpoint disabled        
        Endpoints[brd][i].autorepeat = 0x00; // no auto repeat
        Endpoints[brd][i].xmitbuffercnt = 0x00;  // no chars
        Endpoints[brd][i].xmitbufferptr = (unsigned char *)NULL; // null ptr
    }

    USB_INTR_FLAG[brd-1] = FALSE;

    // perform a software reset to be sure we are starting from a known point
    USB_Write(brd,USB_SCR,(SCR_SRESET));
    for(temp=0;temp<10000;temp++) {    // give reset time
        ;
    }
    USB_Write(brd,USB_SCR,0x00);
    for(temp=0;temp<10000;temp++) {    // give reset time
        ;
    }

    // see if we have a board by writing/reading from the scratch register    
    USB_Write(brd,USB_SCRATCH, 0x55);
    USB_Write(brd,USB_SCR,0x00);    // dummy write to clear bus if no board?
	if(USB_Read(brd,USB_SCRATCH) != 0x55) {	// if no board, return FALSE
	    return FALSE;
	}

    // enable Endpoint 0 only and its RX and TX done intrs, also disable SOF intrs
    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0); // select EP0
    
    USB_Write_SR(brd,USB_EPCON,(EPCON_CTLEP|EPCON_RXSPM|EPCON_RXIE|EPCON_RXEPEN|EPCON_TXOE|EPCON_TXEPEN),
     USB_REG_ALL_BITS);
    
    USB_Write(brd,USB_TXSTAT,TXSTAT_TXNAKE);   // enable NAK intrs on IN PIDs
    USB_Write(brd,USB_RXCON,(RXCON_RXCLR | RXCON_NONISO_8 | RXCON_ARM));
    USB_Write(brd,USB_TXCON,(TXCON_TXCLR | TXCON_NONISO_8 | TXCON_ATM));

    USB_Write_SR(brd,USB_SOFH,SOFH_SOFIE,USB_REG_NO_BITS);  // disable SOF interrupt 
    
    // Disable all other endpoints 
    for (i = 1; i < USB_MAX_EP; i++)
    {
        USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+i); // select EP
        USB_Write_SR(brd,USB_EPCON,USB_REG_ALL_BITS,USB_REG_NO_BITS);   // set all bits to 0
    }
    
    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0); // select EP0, again

    // enable endpoint 0
    USB_Write_SR(brd,USB_SBIE,(SBIE_FRXIE0 | SBIE_FTXIE0),USB_REG_ALL_BITS);   // enable EP0 xmit/rcv intr
    USB_Write_SR(brd,USB_SBIE1,USB_REG_ALL_BITS,USB_REG_NO_BITS);   // set all bits to 0, disable all intrs

    // no suspend/resume or remote wakeup interrupts, intr polarity is active hi 
    USB_Write(brd,USB_SCR,(SCR_T_IRQ | SCR_IRQPOL | SCR_IE_RESET | SCR_IE_SUSP));
    USB_Write_SR(brd,USB_SSR,SSR_RESET,USB_REG_NO_BITS);   // clear reset bit

    // DO NOT connect to USB bus (wait for connect command) and enable the new chip feature  
    USB_Write(brd,USB_MCSR, (USB_Read(brd,USB_MCSR) | MCSR_FEAT));
    outp(GPIO_PORTA,(inp(GPIO_PORTA) | USB_BRD_DPLUS[brd-1]));  // disable D+ on board

    Usbaddr = 0;
	USB_Write(brd,USB_FADDR,0x00);	// set USB address to 0

    // set DOS intr vector addr
    disable();
    setvect(DOS_INTR[brd-1],USB_INTR_VECT[brd-1]);
    outp(0xA1,(inp(0xA1) & ~DOS_INTR_MASK[brd-1]));
    enable();

    return TRUE;    // we have a board, its set up
}

//*****************************************************************************
//
//	   FUNCTION: void USB_SetupEP(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function sets up an Endpoint   
//
//	     INPUTS: unsigned char brd - which board (address) to use
//               unsigned char ep - which endpoint to set up			
//	    RETURNS: nothing		
//        NOTES: this function does not assume any other EP settings, that is,
//               it doesn't re-init the chip before making changes, it assumes
//               the calling function handles that, if necessary.  This function
//               will disable EP0 if requested.
//
//*****************************************************************************
void USB_SetupEP(unsigned char brd, unsigned char ep) {

    unsigned char temp;

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    if(Endpoints[brd][ep].type == USB_DISABLE_PIPE) {  // disable EP, even EP0
        USB_Write_SR(brd,USB_EPCON,USB_REG_ALL_BITS,USB_REG_NO_BITS);   // clear all bits
        if(ep < EPINDEX_EP4) {   // clear intr bits
            USB_Write_SR(brd,USB_SBIE,INTR_BITS[ep],USB_REG_NO_BITS);
        }
        else {
            USB_Write_SR(brd,USB_SBIE1,INTR1_BITS[ep],USB_REG_NO_BITS);
        }
        // not set global structure
        Endpoints[brd][ep].fifosize = 00;  // non-isoc size of 16
        Endpoints[brd][ep].type = USB_DISABLE_PIPE;   // endpoint disabled        
        Endpoints[brd][ep].autorepeat = 0x00; // no auto repeat
        Endpoints[brd][ep].xmitbuffercnt = 0x00;  // no chars
        Endpoints[brd][ep].xmitbufferptr = (unsigned char *)NULL; // null ptr
    }
    else {
        if((ep == EPINDEX_EP0) || (Endpoints[brd][ep].type == USB_CTRL_PIPE)) {  // control eps are always single buffering, control pipe, others always double
            USB_Write(brd,USB_RXCON, (RXCON_RXCLR | (Endpoints[brd][ep].fifosize << 5) | RXCON_ARM));
            USB_Write(brd,USB_TXCON, (TXCON_TXCLR | (Endpoints[brd][ep].fifosize << 5) | TXCON_ATM));
            USB_Write_SR(brd,USB_EPCON,(EPCON_CTLEP|EPCON_RXSPM|EPCON_RXIE|EPCON_RXEPEN|EPCON_TXOE|EPCON_TXEPEN),USB_REG_ALL_BITS);
            temp = USB_Read(brd,USB_TXSTAT);    // get current values
            temp &= ~TXSTAT_TXSEQ;   // reset xmit data toggle
            temp |= TXSTAT_TXSOVW;  // set bit to allow data toggle reset
            temp |= TXSTAT_TXNAKE;  // enable NAK intrs on IN PIDS
            USB_Write(brd,USB_TXSTAT,temp);   // enable NAK intrs on IN PIDs, reset xmit seq
            USB_Write_SR(brd,USB_RXSTAT,(RXSTAT_RXSOVW | RXSTAT_RXSEQ),(RXSTAT_RXSOVW | ~RXSTAT_RXSEQ));    // reset recv seq 
        }
        else if(Endpoints[brd][ep].type == USB_ISOC_PIPE) {  // set for isoc mode
            USB_Write(brd,USB_RXCON, (RXCON_RXCLR | (Endpoints[brd][ep].fifosize << 5) |RXCON_RXISO | RXCON_ARM));
            USB_Write(brd,USB_TXCON, (TXCON_TXCLR | (Endpoints[brd][ep].fifosize << 5) |TXCON_TXISO | TXCON_ATM));
            USB_Write_SR(brd,USB_EPCON,(EPCON_RXIE|EPCON_RXEPEN|EPCON_TXOE|EPCON_TXEPEN),USB_REG_ALL_BITS);
            temp = USB_Read(brd,USB_TXSTAT);    // get current values
            temp &= ~TXSTAT_TXSEQ;   // reset xmit data toggle
            temp |= TXSTAT_TXSOVW;  // set bit to allow data toggle reset
            temp &= ~TXSTAT_TXNAKE;  // disable NAK intrs on IN PIDS
            USB_Write(brd,USB_TXSTAT,temp);   // disable NAK intrs on IN PIDs, reset xmit seq
            USB_Write_SR(brd,USB_RXSTAT,(RXSTAT_RXSOVW | RXSTAT_RXSEQ),(RXSTAT_RXSOVW | ~RXSTAT_RXSEQ));    // reset recv seq 
//            USB_Write_SR(brd,USB_SOFH,SOFH_SOFIE,USB_REG_ALL_BITS);  // enable SOF interrupt 

        }
        else {  // enabled, not control or isoc pipe
            USB_Write(brd,USB_RXCON, (RXCON_RXCLR | (Endpoints[brd][ep].fifosize << 5) | RXCON_ARM));
            USB_Write(brd,USB_TXCON, (TXCON_TXCLR | (Endpoints[brd][ep].fifosize << 5) | TXCON_ATM));
            USB_Write_SR(brd,USB_EPCON,(EPCON_RXSPM|EPCON_RXIE|EPCON_RXEPEN|EPCON_TXOE|EPCON_TXEPEN),USB_REG_ALL_BITS);
            temp = USB_Read(brd,USB_TXSTAT);    // get current values
            temp &= ~TXSTAT_TXSEQ;   // reset xmit data toggle
            temp |= TXSTAT_TXSOVW;  // set bit to allow data toggle reset
            temp |= TXSTAT_TXNAKE;  // enable NAK intrs on IN PIDS
            USB_Write(brd,USB_TXSTAT,temp);   // enable NAK intrs on IN PIDs, reset xmit seq
            USB_Write_SR(brd,USB_RXSTAT,(RXSTAT_RXSOVW | RXSTAT_RXSEQ),(RXSTAT_RXSOVW | ~RXSTAT_RXSEQ));    // reset recv seq 
        }
        if(ep < EPINDEX_EP4) {   // enable xmit/rcv intrs
            USB_Write_SR(brd,USB_SBIE,INTR_BITS[ep],USB_REG_ALL_BITS);
        }
        else {
            USB_Write_SR(brd,USB_SBIE1,INTR1_BITS[ep],USB_REG_ALL_BITS);
        }
    }
}


//*****************************************************************************
//
//	   FUNCTION: void USB_Intr_Handler(unsigned char brd)
//	DESCRIPTION: this function is the common handler for all USB board interrupts  
//
//	     INPUTS: unsigned char brd - the active board
//	    RETURNS: nothing		
//        NOTES: its an interrupt, as usual, get in and out as fast as possible
//               a SOF intr is check for first, and if there is one, the SOF
//               handler is called to process any ISOC channels
//               next the System Status register is checked for suspend/resume intrs
//               lastly the Serial Bus Interrupts are checked for any endpoint intrs
//
//*****************************************************************************
void USB_Intr_Handler(unsigned char brd) {

    unsigned char val;


    val = USB_Read(brd,USB_SOFH);   // check for SOF intr

    // if the interrupt is enabled & a start of frame is received,
    // then it is a possible an ISOC Interrupt is here
	if((val & SOFH_SOFIE) && (val & SOFH_ASOF))	{
        USB_SOF_Handler(brd);
    }

    // read the ssr (System Status) register
    val = USB_Read(brd,USB_SSR);
    if(val & (SSR_RESET | SSR_RESUME | SSR_SUSPEND))	{	
        
        if (val & SSR_RESET) {    // USB reset intr
            USB_Write(brd,USB_SSR,0x00);   // clear all intrs
            USB_Write(brd,USB_PEND,0x00);   // clear pending bit
            USB_Write(brd,USB_SCR,(SCR_T_IRQ | SCR_IRQPOL | SCR_IE_RESET | SCR_IE_SUSP));
            USB_Write_SR(brd,USB_SSR,SSR_RESUME,USB_REG_NO_BITS);   // clear resume bit
            
            Sim_To_Cont_USBHS(brd,USB_RESET, 0, (unsigned int)0, usbdata); // notify controller of RESET
//            val = USB_Init(brd); // reset and re-connect to USB bus
            return;
        }

        if (val & SSR_RESUME) { // USB resume intr, note: pending bit is still set from suspend
            USB_Write(brd,USB_SSR,0x00);   // clear all intrs
            USB_Write(brd,USB_PEND,0x00);   // clear pending bit
            USB_Write(brd,USB_SCR,(SCR_T_IRQ | SCR_IRQPOL | SCR_IE_RESET | SCR_IE_SUSP));
            USB_Write_SR(brd,USB_SSR,SSR_RESUME,USB_REG_NO_BITS);   // clear resume bit
            Sim_To_Cont_USBHS(brd,0xFD, 0, (unsigned int)0, usbdata); // notify controller of RESUME
        }

        if (val & SSR_SUSPEND) {  // USB suspend intr
#if DOSUSPEND
            USB_Write(brd,USB_PEND,0x01);   // set pending bit, leave it set until resume
            USB_Write(brd,USB_SSR, (USB_Read(brd,USB_SSR) & ~SSR_SUSPEND));    // clear suspend
            USB_Write(brd,USB_SCRATCH, (USB_Read(brd,USB_SCRATCH) | SCRATCH_IE_RESUME));    // enable resume intr
            val = USB_Read(brd,USB_SSR); // re-read SSR
            if (val & SSR_SUSPEND) {  // still have suspend?
                USB_Write(brd,USB_SCR, USB_Read(brd,USB_SCR) & (~SCR_IE_SUSP)); // disable suspend intr
                
                USB_Write_SR(brd,USB_SBI,USB_REG_ALL_BITS,USB_REG_NO_BITS);   // clear any pending intr bit
                USB_Write_SR(brd,USB_SBI1,USB_REG_ALL_BITS,USB_REG_NO_BITS);   // clear any pending intr bit

                // go into suspend mode by setting/clearing suspend bit
                USB_Write(brd,USB_SSR, SSR_SUSPEND);    // set suspend
                USB_Write(brd,USB_SSR, 0x00);   // reset suspend bit

                Sim_To_Cont_USBHS(brd,0xFE, 0, (unsigned int)0, usbdata); // notify controller of SUSPEND
                return; // we are now "asleep", return
			}
#else
            USB_Write_SR(brd,USB_SSR,SSR_SUSPEND,USB_REG_NO_BITS);   // clear suspend bit
            USB_Write(brd,USB_SCR, USB_Read(brd,USB_SCR) & (~SCR_IE_SUSP)); // disable suspend intr
            Sim_To_Cont_USBHS(brd,0xFE, 0, (unsigned int)0, usbdata); // notify controller of SUSPEND
#endif
        }
    }
    USB_EP_Handler(brd);  // check endpoint intrs
}

//*****************************************************************************
//
//	   FUNCTION: void interrupt USB_Intr_Brd1()
//	DESCRIPTION: this function handles an interrupt received from the USB brd 1
//               this function calls the common handler with the approp. brd number  
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: its an interrupt, as usual, get in and out as fast as possible
//
//*****************************************************************************
void interrupt USB_Intr_Brd1() {

    USB_INTR_FLAG[0] = TRUE;    // flag intr happened
    outp(0xA0,0x20);    // re-enable intrs
    outp(0x20,0x20);

}

//*****************************************************************************
//
//	   FUNCTION: void interrupt USB_Intr_Brd2()
//	DESCRIPTION: this function handles an interrupt received from the USB brd 2
//               this function calls the common handler with the approp. brd number  
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: its an interrupt, as usual, get in and out as fast as possible
//
//*****************************************************************************
void interrupt USB_Intr_Brd2() {

    USB_INTR_FLAG[1] = TRUE;    // flag intr happened
    outp(0xA0,0x20);    // re-enable intrs
    outp(0x20,0x20);

}

//*****************************************************************************
//
//	   FUNCTION: void interrupt USB_Intr_Brd3()
//	DESCRIPTION: this function handles an interrupt received from the USB brd 3
//               this function calls the common handler with the approp. brd number  
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: its an interrupt, as usual, get in and out as fast as possible
//
//*****************************************************************************
void interrupt USB_Intr_Brd3() {

    USB_INTR_FLAG[2] = TRUE;    // flag intr happened
    outp(0xA0,0x20);    // re-enable intrs
    outp(0x20,0x20);

}

//*****************************************************************************
//
//	   FUNCTION: void interrupt USB_Intr_Brd4()
//	DESCRIPTION: this function handles an interrupt received from the USB brd 4
//               this function calls the common handler with the approp. brd number  
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: its an interrupt, as usual, get in and out as fast as possible
//
//*****************************************************************************
void interrupt USB_Intr_Brd4() {

    USB_INTR_FLAG[3] = TRUE;    // flag intr happened
    outp(0xA0,0x20);    // re-enable intrs
    outp(0x20,0x20);

}

//*****************************************************************************
//
//	   FUNCTION: void USB_Connect(void)
//	DESCRIPTION: this function handles connecting the USB board  
//
//	     INPUTS: none
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void USB_Connect(unsigned char brd) {

    // connect to USB bus 
    USB_Write(brd,USB_MCSR, (USB_Read(brd,USB_MCSR) | MCSR_DPEN));
    outp(GPIO_PORTA,(inp(GPIO_PORTA) & ~USB_BRD_DPLUS[brd-1]));  // enable D+ on board
}

//*****************************************************************************
//
//	   FUNCTION: void USB_Disconnect(unsigned char brd)
//	DESCRIPTION: this function handles dis-connecting the USB board  
//
//	     INPUTS: unsigned char brd - board to use
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void USB_Disconnect(unsigned char brd) {

    unsigned char i;

    // connect to USB bus 
    USB_Write(brd,USB_MCSR, (USB_Read(brd,USB_MCSR) & ~MCSR_DPEN));
    outp(GPIO_PORTA,(inp(GPIO_PORTA) | USB_BRD_DPLUS[brd-1]));  // disable D+ on board
    for(i=1;i<USB_MAX_EP;i++) { // leave EP0 as control, disable remaining endpoints
        Endpoints[brd][i].fifosize = 00;  // non-isoc size of 16
        Endpoints[brd][i].type = USB_DISABLE_PIPE;   // endpoint disabled        
        Endpoints[brd][i].autorepeat = 0x00; // no auto repeat
        Endpoints[brd][i].xmitbuffercnt = 0x00;  // no chars
        Endpoints[brd][i].xmitbufferptr = (unsigned char *)NULL; // null ptr
        USB_SetupEP(brd,i);
    }
    USB_Write_SR(brd,USB_SOFH,SOFH_SOFIE,USB_REG_NO_BITS);  // disable SOF interrupt 
}

//*****************************************************************************
//
//	   FUNCTION: void USB_Stall(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function handles stalling an endpoint  
//
//	     INPUTS: unsigned char brd - board to use
//               unsigned char ep - endpoint to stall
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void USB_Stall(unsigned char brd, unsigned char ep) {

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    USB_Write_SR(brd,USB_EPCON,(EPCON_TXSTL | EPCON_RXSTL),USB_REG_ALL_BITS);   // set stall bits
}

//*****************************************************************************
//
//	   FUNCTION: void USB_UnStall(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function handles un-stalling an endpoint  
//
//	     INPUTS: unsigned char brd - board to use
//               unsigned char ep - endpoint to stall
//	    RETURNS: nothing		
//        NOTES: 
//
//*****************************************************************************
void USB_UnStall(unsigned char brd, unsigned char ep) {

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    USB_Write_SR(brd,USB_EPCON,(EPCON_TXSTL | EPCON_RXSTL),USB_REG_NO_BITS);   // clear stall bits
}

//*****************************************************************************
//
//	   FUNCTION: void Check_USB_Xmit(unsigned char brd, unsigned char ep)
//	DESCRIPTION: this function handles transmitting any data, if any  
//
//	     INPUTS: unsigned char brd - the active board
//               unsigned char ep - the active endpoint
//	    RETURNS: nothing		
//        NOTES: see if we have anything to xmit, may be in the middle of a large packet, or may have received
//               data from last check.  if data has been received, the appropriate endpoint buffer will be loaded
//
//*****************************************************************************
void Check_USB_Xmit(unsigned char brd, unsigned char ep) {

    int txsize;
    unsigned char i;
    int fifosize;

    USB_Write(brd,USB_EPINDEX,EPINDEX_EP0+ep); // select EP

    if(Endpoints[brd][ep].xmitbuffercnt) {    // we have characters to xmit
        if(Endpoints[brd][ep].type == USB_ISOC_PIPE){    // figure out actual fifo size
            fifosize = ISOC_FIFO_SIZE[Endpoints[brd][ep].fifosize];
        }
        else {
            fifosize = NON_ISOC_FIFO_SIZE[Endpoints[brd][ep].fifosize];
        }
        if(Endpoints[brd][ep].xmitbuffercnt > fifosize) {  // still more than we can send at once
            txsize = fifosize;
        }
        else { // use all
            txsize = Endpoints[brd][ep].xmitbuffercnt;
        }

        for(i=0;i<txsize;i++) {
            USB_Write(brd,USB_TXDAT,*Endpoints[brd][ep].xmitbufferptr++); // load up transmit buffer
        }
			/* Check for overflow of Tx FIFO */
        if (USB_Read(brd,USB_TXFLG) & TXFLG_TXOVF) {    // check for overflwo
				USB_Write(brd,USB_TXCON, USB_Read(brd,USB_TXCON) | TXCON_TXCLR);
// log error to controller????
                printf("TX%d Overflow\r\n",ep);
        }
        else {
            Endpoints[brd][ep].xmitbuffercnt -= txsize;
            if ( Endpoints[brd][ep].xmitbuffercnt <= 0 ) {
                Endpoints[brd][ep].xmitbuffercnt = 0;
            }
            if(Endpoints[brd][ep].autorepeat) { // if autorepeat is on, reload ptr and count
                Endpoints[brd][ep].xmitbuffercnt = Endpoints[brd][ep].xmitrepeatcnt;
                Endpoints[brd][ep].xmitbufferptr = Endpoints[brd][ep].xmit_buf;
            }
        }
        USB_Write(brd,USB_TXCNTH, ((txsize & 0xff00) >> 8));
        USB_Write(brd,USB_TXCNTL, (txsize & 0x00ff));
    }
    else if(Endpoints[brd][ep].ack) {    // send ack phase
        USB_Write(brd,USB_TXCNTH, 0x00);
        USB_Write(brd,USB_TXCNTL, 0x00);
        Endpoints[brd][ep].ack = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\Firmware\sim_main.c ===
//*****************************************************************************
//	    Filename: sim_main.c
//       Project: Microsoft USB Simulator
//	   Copyright: INDesign-LLC, 2000
//
//	 Description:
//
//
// MKS Source Control
// $Source: p:/Microsoft/621-USB_Simulator/Code/rcs/sim_main.c $
// $Revision: 1.12 $
// $Date: 2001/01/25 17:46:59Z $ 
// $Author: rjgardner $
// $Log: sim_main.c $
// Revision 1.12  2001/01/25 17:46:59Z  rjgardner
// Drop call to Process_Socket_In and incorporate functionality into
// function Socket_Poll.  Drop call to Process_Connect and 
// incorporate functionality into function Process_Control_Msg.
// Revision 1.11  2001/01/18 16:27:27Z  klpayne
// Add support for ready LED
// Revision 1.10  2001/01/04 19:24:46Z  klpayne
// Support IRQ mapping changes
// Revision 1.9  2001/01/03 21:44:18Z  rjgardner
// Revision 1.8  2000/12/22 20:53:21Z  rjgardner
// Add storage declaration for device_status and add logic to initialize
// and set properly on USB1 connect.
// Revision 1.7  2000/12/21 14:31:18Z  rjgardner
// Add Version.h header file and code to print to the console.
// Revision 1.6  2000/12/20 18:07:52Z  klpayne
// Added call to command process for board.
// Revision 1.5  2000/12/18 22:32:30Z  rjgardner
// Attempt to Init USB board 1 on network connect
// Revision 1.4  2000/12/18 21:53:36Z  rjgardner
// Rough structure of main process loop
// Revision 1.3  2000/12/14 21:31:49Z  klpayne
// Remove debug toggle
// Revision 1.2  2000/12/13 15:24:33Z  klpayne
// Move intr processing out of intr handler
// Revision 1.1  2000/12/05 22:04:53Z  klpayne
// Initial revision
//
//*****************************************************************************

#include <stdio.h>
#include <dos.h>
#include "sim.h"
#include "USB_brd.h"
#include "sim_cmd.h"
#include "Ether.h"
#include "Version.h"

//------------------------LOCAL CONSTANTS AND MACROS---------------------------

//-----------------------------GLOBAL VARIABLES--------------------------------

unsigned char device_status = 0;

//----------------------STATIC LOCAL FUNCTION PROTOTYPES-----------------------


//*****************************************************************************
//
//	   FUNCTION: void main(void)
//	DESCRIPTION: The main loop.   
//
//	     INPUTS:			
//	    RETURNS:		
//        NOTES:
//
//*****************************************************************************
void main(void) {
	unsigned char Connected = FALSE;
	int socket = USB1;
    unsigned char brd = USB1;

	// Display version number
	printf("USB Simulator Version: %s\n", Version);

    Sim_Init();
    outp(GPIO_PORTB,0x01);  // illuminate ready LED
    while(1) {
		// Check if we are connected to a controller
		if(Connected) {
			// Check for USB data to controller
	        if(USB_INTR_FLAG[brd-1] == TRUE) {  // brd 1 has an intr
    	        USB_INTR_FLAG[brd-1] = FALSE;
        	    USB_Intr_Handler(brd);    // common handler
	        }
			// Check buffer for USB data from controller
            Cont_To_Sim_Parser(brd);

			// Poll socket for Controller PC messages
			Socket_Poll(socket);

			// Check buffer for data to Controller PC
			Process_Socket_Out(socket);

			 // Restart socket rotation
			if((++socket) > USB4) {
				socket = CNTRL;
			}
            // Restart board rotation
            if((++brd) > USB4) {
                brd = USB1;
            }
		} else {
			// Check for network connect
			if(Socket_Poll(CNTRL)) {
				// Flag connect
				Connected = TRUE;

				// Check for connect on USB channel 1
				if(USB_Init(USB1)) {
					if(Open_USB_Socket(USB1)) {
						device_status |= USB1_CONNECT;
					}
				}

				// Check for connect on USB channel 2
				if(USB_Init(USB2)) {
					if(Open_USB_Socket(USB2)) {
						device_status |= USB2_CONNECT;
					}
				}

				// Check for connect on USB channel 3
				if(USB_Init(USB3)) {
					if(Open_USB_Socket(USB3)) {
						device_status |= USB3_CONNECT;
					}
				}

				// Check for connect on USB channel 4
				if(USB_Init(USB4)) {
					if(Open_USB_Socket(USB4)) {
						device_status |= USB4_CONNECT;
					}
				}

				printf("con - %02X\r\n",device_status);                
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\consts.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    consts.h

Abstract:

    Constant values.

    typedefs will be available in the COM object's type library

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _USB_CONSTS_H_
#define _USB_CONSTS_H_

#ifndef __USBSIMULATORLib_LIBRARY_DEFINED__ // prevent multiple definitions within COM object

//
// Error Codes
//
typedef enum
    {
    USBSIM_ERROR_OK                =  0,  // A-OK
    USBSIM_ERROR_CONNECTED         =  1,  // Device is already connected
    USBSIM_ERROR_NOTCONNECTED      =  2,  // Device is not connected
    USBSIM_ERROR_CONNECT_FAILED    =  3,  // Use GetLastError to get more information
    USBSIM_ERROR_SOCKET_ERROR      =  4,  // Use GetLastError to get more information
    USBSIM_ERROR_INVALID_USB_PORT  =  5,  // Parameter is out of range or denotes a port currently not in use
    USBSIM_ERROR_INVALID_SIMULATOR =  6,  // Parameter is out of range or denotes a port currently not in use
    USBSIM_ERROR_INVALID_DEVICE    =  7,  // Pointer to a USBDevice is not valid
    USBSIM_ERROR_USER_ABORT        =  8,  // Abort specifed by the user
    USBSIM_ERROR_TIMEOUT           =  9,  // Timeout waiting for response from simulator
    USBSIM_ERROR_DATA_CORRUPTED    = 10,  // Got data from the simulator but it is likely corrupted
    USBSIM_ERROR_SEND_FAILURE      = 11,  // Use GetLastError to get more information
    } USBSimulatorErrorCodes;


//
// USB Endpoint Mode
//
typedef enum
    {
    ENDPOINT_DISABLE = 0,
    ENDPOINT_ENABLE,
    ENDPOINT_AUTOREPEAT
    } EndpointModes;


//
// Device Type IDs
//
typedef enum
    {
    DEVICE_UNKNOWN = -1,
    DEVICE_DUKE,
    DEVICE_MU,
    DEVICE_HAWK,
    DEVICE_DVDREMOTE,
    DEVICE_MAX_TYPES
    } DeviceTypes;


//
// Logging class
//
typedef enum 
    {
    RECORDING_FORMAT_TEXT_LOG,
    RECORDING_FORMAT_CHIEF_UTG,
    RECORDING_FORMAT_TEXT_XML
    } RecordingFormats;

//
// Port values used in USBDevice::Plug
//
typedef enum
    {
    USBSIM_HOST_PORT1 = 1,
    USBSIM_HOST_PORT2,
    USBSIM_HOST_PORT3,
    USBSIM_HOST_PORT4
    } USBSimulatorPorts;


//
// USB PID values (USB Specification section 8.3.1 table 8-1)
//
#define USB_PID_MDATA       0xF0
#define USB_PID_DATA2       0xE1
#define USB_PID_DATA1       0xD2
#define USB_PID_DATA0       0xC3
#define USB_PID_SETUP       0xB4
#define USB_PID_SOF         0xA5
#define USB_PID_IN          0x96
#define USB_PID_OUT         0x87
#define USB_PID_STALL       0x78
#define USB_PID_NYET        0x69
#define USB_PID_NAK         0x5A
#define USB_PID_ACK         0x4B
#define USB_PID_ERR         0x3C
#define USB_PID_PING        0x2D
#define USB_PID_SPLIT       0x1E
#define USB_PID_RESERVED    0x0F
#define USB_PID_PRE         USB_PID_ERR

#endif // __USBSIMULATORLib_LIBRARY_DEFINED__
#endif // _USB_SIMULATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\BulkDevice.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    BulkDevice.h

Abstract:

    USB Device child class that handles MU enumeration and storage

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _BULKDEVICE_H_
#define _BULKDEVICE_H_

#pragma pack(push, 1) // align structure members on a byte boundry
struct CBW
    {
    unsigned __int8  pid;

    // header
    unsigned __int32 sig;           // CBW Signature - same for all transactions
    unsigned __int32 tag;           // CBW Tag - unique identifier for a transaction, returned in CSW
    unsigned __int32 dataLength;    // Length (in bytes) of the data stage of the transaction
    unsigned __int8  flag;          // Sets data direction among other things, 0x00-WRTIE, 0x80-READ
    unsigned __int8  drive;         // Sets Logical Unit - something to do with have multiple drives in on device
    unsigned __int8  length;        // Length of the valid portion of the RBC

    // RBC
    unsigned __int8  opCode;        // Command ID
    unsigned __int8  rbcDrive;      // Bitwise field containing LUN
    BigEndian<unsigned __int32> address;       // Logical Block Address - Address in Block numbers of the destination
    unsigned __int8  reserved2;     
    unsigned __int16 param2;        // RBC Length - Length in Block numbers of the data
    unsigned __int8  control;       
    unsigned __int8  fill[6];       
    };
struct CSW
    {
    unsigned __int8  pid;

    // header
    unsigned __int32 sig;
    unsigned __int32 tag;
    unsigned __int32 dataLength;
    unsigned __int8  result;
    };
struct MUCapacity
    {
    BigEndian<unsigned __int32> numBlocks;
    BigEndian<unsigned __int16> logicalSize;
    BigEndian<unsigned __int16> blockSize;
    };
#pragma pack(pop)


/*****************************************************************************

Class Description:

    BulkDevice

    USB Device child class that handles MU enumeration and storage

Notes:
    

*****************************************************************************/
class BulkDevice : public USBDevice
    {
    public:
        unsigned enumerateState[10];

    protected:
        MUCapacity capacity;
        unsigned __int8 *storage;

    public:
        BulkDevice();
        ~BulkDevice();

    // virtual member functions
    public:
        DWORD EndpointConfig(unsigned config);
        DWORD Receive(void);
        const char* GetName(void);
        bool IsEnumerated(void);

    protected:
        DWORD HandleSETUP(void);
        DWORD HandleOUT(void);
        DWORD HandleIN(void);

    public:
        void SetCapacity(DWORD numBlocks, unsigned short blockSize, unsigned short logicalSize);
        DWORD StoreMU(char *filename);
        DWORD LoadMU(char *filename);

    public:
        friend class CMU; // give the COM object access to us
    };

#endif // _BULKDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\IsocDevice.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    IsocDevice.h

Abstract:

    USB Device child class that handles Hawk enumeration and communication

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _ISOCDEVICE_H_
#define _ISOCDEVICE_H_



/*****************************************************************************

Class Description:

    IsocDevice

    USB Device child class that handles Hawk enumeration and communication

Notes:
    

*****************************************************************************/
class IsocDevice : public USBDevice
    {
    public:
        unsigned enumerateState[10];

    protected:

    public:
        IsocDevice();
        ~IsocDevice();

    // virtual member functions
    public:
        DWORD EndpointConfig(unsigned config);
        DWORD Receive(void);
        const char* GetName(void);
        bool IsEnumerated(void);

    protected:
        DWORD HandleSETUP(void);
        DWORD HandleOUT(void);
        DWORD HandleIN(void);

    public:
        friend class CHawk; // give the COM object access to us
    };

#endif // _ISOCDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\simpacket.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    SimPacket.h

Abstract:

    Defines the packet structures and values for the commands and subcomands
    Defines USB values

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#ifndef _SIMPACKET_H_
#define _SIMPACKET_H_

//
// TCP / UDP Ports
//
#define SIM_NETPORT_CLIENT_OFFSET 10
enum _SIM_NET_PORTS
    {
    SIM_NETPORT_IPQUERY = 200,
    SIM_NETPORT_BASE = 200,
    SIM_NETPORT_USB1,
    SIM_NETPORT_USB2,
    SIM_NETPORT_USB3,
    SIM_NETPORT_USB4,
    SIM_NETPORT_MAX
    };

//
// Network Packet Commands & Subcommands
//
enum _SIM_COMMANDS
    {
    SIM_CMD_USBDATA = 1,
    SIM_CMD_USBEXTRADATA,
    SIM_CMD_IPQUERY,
    SIM_CMD_STATUS,
    SIM_CMD_SETUP,
    SIM_CMD_MAX
    };
static const char * const commandStrings[SIM_CMD_MAX] = {"", "USB", "USB", "IPQUERY", "STATUS", "SETUP" };
static const char * const subcommandStrings[SIM_CMD_MAX][7] = { 
    {"", "", "", "", "", "", "" },
    {"DATA", "", "", "", "", "", "" },
    {"", "ACK/NAK", "OTHER", "RESET", "", "", "" },
    {"IPQUERY", "", "", "", "", "", "" },
    {"", "VERSION", "MACADDR", "GETCONNECTED", "", "", "" },
    {"", "ENDPOINT", "USBADDR", "CONNECT/DISCONNECT", "RESET", "SET GPIO", "GET GPIO" }
    };


// SIM CMD USBDATA
enum _SIM_USBDATA_SUBCOMMANDS
    {
    SIM_SUBCMD_USBDATA = 0
    };

// SIM CMD USBEXTRADATA
enum _SIM_USBEXTRADATA_SUBCOMMANDS
    {
    SIM_SUBCMD_USBEXTRADATA_ACKNAK = 1,
    SIM_SUBCMD_USBEXTRADATA_OTHER,
    SIM_SUBCMD_USBEXTRADATA_RESET
    };

// SIM CMD IPQUERY
enum _SIM_IPQUERY_SUBCOMMANDS
    {
    SIM_SUBCMD_IPQUERY = 0
    };

// SIM CMD STATUS
enum _SIM_STATUS_SUBCOMMANDS
    {
    SIM_SUBCMD_STATUS_VERSION = 1,
    SIM_SUBCMD_STATUS_MACADDR,
    SIM_SUBCMD_STATUS_CONNECTED
    };

// SIM CMD SETUP
enum _SIM_SETUP_SUBCOMMANDS
    {
    SIM_SUBCMD_SETUP_ENDPOINT = 1,
    SIM_SUBCMD_SETUP_USBADDRESS,
    SIM_SUBCMD_SETUP_CONNECT,
    SIM_SUBCMD_SETUP_RESET,
    SIM_SUBCMD_SETUP_SET_GPIO,
    SIM_SUBCMD_SETUP_GET_GPIO
    };

enum _SIM_USBEXTRADATA_RESET_VALUES
    {
    SIM_USB_PORT_RESUME =   0xFD,
    SIM_USB_PORT_SUSPEND =  0xFE,
    SIM_USB_PORT_RESET =    0xFF
    };

//
// Values for the EndpointSetup structure
//
enum _SIM_ENDPOINT_SETUP_TYPES
    {
    SIM_ENDPOINT_SETUP_TYPE_DISABLED = 0,
    SIM_ENDPOINT_SETUP_TYPE_ISOC,
    SIM_ENDPOINT_SETUP_TYPE_NOISOC,
    SIM_ENDPOINT_SETUP_TYPE_CONTROL
    };
enum _SIM_ENDPOINT_SETUP_SIZE
    {
    SIM_ENDPOINT_SETUP_SIZE_ISOC64 = 0,
    SIM_ENDPOINT_SETUP_SIZE_ISOC256,
    SIM_ENDPOINT_SETUP_SIZE_ISOC512,
    SIM_ENDPOINT_SETUP_SIZE_ISOC1024,

    SIM_ENDPOINT_SETUP_SIZE_NOISOC16 = 0,
    SIM_ENDPOINT_SETUP_SIZE_NOISOC64,
    SIM_ENDPOINT_SETUP_SIZE_NOISOC8,
    SIM_ENDPOINT_SETUP_SIZE_NOISOC32
    };
enum _SIM_ENDPOINT_SETUP_AUTO_REPEAT
    {
    SIM_ENDPOINT_SETUP_AUTO_DISABLED = 0,
    SIM_ENDPOINT_SETUP_AUTO_ENABLED
    };


//
// Network Packet structures
//
#pragma warning(push)
#pragma warning(disable:4200) // A structure or union contained an array with zero size
#pragma pack(push, 1) // align structure members on a byte boundry

struct SimPacketHeader
    {
    unsigned __int8  command;
    unsigned __int8  subcommand;
    unsigned __int8  param;
    unsigned __int16 dataSize;
    };

struct SimPacket : public SimPacketHeader
    {
    unsigned char data[0];
    };

template <class DataType>
struct SimPacketTyped
    {
    SimPacketHeader header;
    DataType data;
    };


//
// Specific "data" structs used in the network communication
//
struct USBPacket
    {
    unsigned __int8 pid;
    unsigned char data[0];
    };

struct EndpointSetup
    {
    unsigned __int8 fifoSize;
    unsigned __int8 type;
    unsigned __int8 autoRepeat;
    };

#pragma pack(pop)
#pragma warning(pop)






#endif //_SIMPACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\cworkerthread.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CWorkerThread.h

Abstract:

    Base class for handling worker threads

Author:

    Josh Poley (jpoley)

Notes:

    If you get the following error:
        error C2065: '_beginthread' : undeclared identifier
    Then you are building your project in single threaded mode, switch it 
    to multi-threaded.

*****************************************************************************/

#ifndef _CWORKERTHRAD_H_
#define _CWORKERTHRAD_H_

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _XBOX
    #include <xtl.h>
#else
    #include <windows.h>
    #include <winsock2.h>
#endif
#include <stdio.h>
#include <crtdbg.h>
#include <process.h>    //_beginthread, _endthread

static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

/*****************************************************************************

Class Description:

    Worker thread class

Methods:



Data:



NOTE: 
    
    Remember to nest any member read/write with Lock and Unlock 

    In the implementation of the ThreadFunct function, the user must check 
        the bExit flag and exit gracefully if set.

*****************************************************************************/
class __declspec(dllexport) CWorkerThread
    {
    private:
        CRITICAL_SECTION criter;
        DWORD dwThreadHandle;
        DWORD dwThreadID;
        DWORD dwThreadExitCode;

    protected:
        BOOL bExit;

        DWORD dwLocalThreadID;

    // constructors / destructors
    public:
        CWorkerThread();
        CWorkerThread(DWORD localID);
        virtual ~CWorkerThread();

    // public access and information
    public:
        void Lock(void) { EnterCriticalSection(&criter); }
        void Unlock(void) { LeaveCriticalSection(&criter); }

        #ifdef _WIN32_WINNT
        BOOL Lock(DWORD dwTimeOut);
        #endif

        DWORD GetThreadHandle(void) { Lock(); DWORD h = dwThreadHandle; Unlock(); return h; }
        DWORD GetThreadID(void) { Lock(); DWORD id = dwThreadID; Unlock(); return id; }
        DWORD GetLocalThreadID(void) { Lock(); DWORD id = dwLocalThreadID; Unlock(); return id; }
        void  SetLocalThreadID(DWORD id) { Lock(); dwLocalThreadID = id; Unlock(); }
        DWORD GetThreadExitCode(void) { Lock(); DWORD e = dwThreadExitCode; Unlock(); return e; }
        BOOL  GetExitFlag(void) { Lock(); BOOL e = bExit; Unlock(); return e; }

        void Run(void);
        BOOL SoftBreak(DWORD dwTimeOut);
        BOOL HardBreak(void);

        BOOL WaitForExit(DWORD dwTimeOut);

        // thread manipulation
        DWORD SuspendThread(void);
        DWORD ResumeThread(void);

    // internal functions
    private:
        void SetThreadHandle(DWORD h) { Lock(); dwThreadHandle = h; Unlock(); }
        void SetThreadID(DWORD id) { Lock(); dwThreadID = id; Unlock(); }
        void SetThreadExitCode(DWORD c) { Lock(); dwThreadExitCode = c; Unlock(); }

        friend DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

    // overrideable functions
    public:
        /*****************************************************************************
        NOTE: in the implementation of this function, the user must check 
               the bExit flag and exit gracefully if set:
        while(1)
            {
            if(GetExitFlag()) break;
            }
        *****************************************************************************/
        virtual DWORD ThreadFunct(void) { return 0; }
    };

#endif // _CWORKERTHRAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\usbsimulator.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    USBSimulator.h

Abstract:

    Defines the Simulator control class and the Device base class.

    Library allows for this sort of usage:

        usbsim.FindSimulators();

        XIDDevice *duke = new XIDDevice();
        usbsim.Plug(1, 1, duke);
        Sleep(...)
        duke->SetInputReport(...); // button a down
        Sleep(...)
        duke->SetInputReport(...); // button a up, dpad left
        usbsim.Unplug(duke);
        delete duke;

        BulkDevice *mu = new BulkDevice();
        usbsim.Plug(2, 1, mu);
        Sleep(15000);              // let stuff happen
        usbsim.Unplug(mu);
        delete mu;

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _USB_SIMULATOR_H_
#define _USB_SIMULATOR_H_

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>
#include <crtdbg.h>

#ifdef _XBOX
    #include <xtl.h>
#else
    #include <windows.h>
#include <winsock2.h>
#endif

#include "CWorkerThread.h"
#include "SimPacket.h"
#include "consts.h"

#define ARRAYSIZE(ptr)      (sizeof(ptr) / sizeof(ptr[0]))


//
// Magic Numbers
//
#define USBSIM_MAX_SIMULATORS           4   // # ports on an xbox
#define USBSIM_MAX_USBPORTS             4   // # usb devices on a simulator
#define USBSIM_RECV_RETRYS              4   // # of times network code will retry an operation
#define USBSIM_UDP_DELAY              200   // milliseconds between fast sends (UDP stack on sim drops packets if too fast)
#define KILOBYTE                     1024   
#define MEGABYTE      (KILOBYTE*KILOBYTE)   



class Recorder
    {
    private:
        LARGE_INTEGER counterFrequency;
        LARGE_INTEGER startTime;

    public:
        int style;
        char filename[MAX_PATH];
        char fullFilename[MAX_PATH];

    public:
        Recorder();

    public:
        void SetFilename(char *name);
        void SetFormat(int formatType);
        void LogPacket(char *data, int len, DWORD deviceID, bool outGoing);
        unsigned LogPrint(char* format, ...);

    };
extern Recorder recorder; // global recording object


class USBDevice;

/*****************************************************************************

Class Description:

    USBSimulator

    This object manages information on remote simulators, and allows a device
    class to attach to a given simulator.

Notes:
    

*****************************************************************************/
class USBSimulator
    {
    public:
        DWORD ip[USBSIM_MAX_SIMULATORS]; // == to S_addr in the in_addr struct

    public:
        bool record;        // used to initialize the devices record settings

    public:
        USBSimulator();
        USBSimulator(bool startRecording, int recordingFormat);
        ~USBSimulator();

    public:
        DWORD Plug(int port, char simulator, USBDevice *vdevice);
        DWORD Unplug(USBDevice *vdevice);

    public:
        DWORD FindSimulators(void);
        DWORD SetIP(char simulator, char *ipAddr);
        template<class DataType> DWORD SendCommand(char simulator, unsigned __int8 command, unsigned __int8 subcommand, DataType &data)
            {
            // NOTE: This member function is inlined because of template limitations in VC
            SOCKADDR_IN dest;
            SOCKET sock;
            SimPacketHeader request = { command, subcommand, 0, 0 };
            SimPacketTyped<DataType> response;
            int addrsize=sizeof(SOCKADDR_IN);
            int err;

            if(simulator > USBSIM_MAX_SIMULATORS || simulator < 0 || ip[simulator] == 0) return USBSIM_ERROR_INVALID_SIMULATOR;

            sock = socket(AF_INET, SOCK_DGRAM, 0);
            dest.sin_family = AF_INET;
            dest.sin_port = htons(SIM_NETPORT_BASE);
            dest.sin_addr.s_addr = ip[simulator];
            err = sendto(sock, (char*)&request, sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, addrsize);
            if(err == SOCKET_ERROR)
                {
                shutdown(sock, SD_BOTH);
                closesocket(sock);
                return USBSIM_ERROR_SOCKET_ERROR;
                }

            TIMEVAL timeout;
            FD_SET bucket;
            bucket.fd_count = 1;
            bucket.fd_array[0] = sock;
            timeout.tv_sec = 0;
            timeout.tv_usec = 1000000; // 1 second
            err = select(0, &bucket, NULL, NULL, &timeout);
            if(err == 0 || err == SOCKET_ERROR)
                {
                shutdown(sock, SD_BOTH);
                closesocket(sock);
                return USBSIM_ERROR_TIMEOUT;
                }

            err = recvfrom(sock, (char*)&response, sizeof(response), 0, (SOCKADDR*)&dest, &addrsize);
            if(err == 0 || err == USBSIM_ERROR_SOCKET_ERROR)
                {
                shutdown(sock, SD_BOTH);
                closesocket(sock);
                return USBSIM_ERROR_SOCKET_ERROR;
                }

            shutdown(sock, SD_BOTH);
            closesocket(sock);

            memcpy(&data, &response, min(sizeof(DataType), err));
            return USBSIM_ERROR_OK;
            }

    public:
        friend class CSimulator;
    };


/*****************************************************************************

Class Description:

    USBDevice

    This class defines the core functionality for every "device". All devices
    are children of this object.

Notes:
    

*****************************************************************************/
class USBDevice : public CWorkerThread
    {
    private:
        TIMEVAL timeout;

    protected:
        bool record;            // wether or not to log traffic
        DWORD simIP;            // simulator IP address
        char usbPort;           // port we are on
        unsigned short destPort;// net port number in network byte order
        SOCKET sock;

    protected: // usb communication
        char *receiveBuffer;    // buffer which receives incomming data
        unsigned bufferSize;    // max size of above buffer
        bool dataToggle;        // keep track of DATA0(false) vs DATA1(true)
        unsigned __int8 deviceDescriptor[8];
        unsigned __int8 configurationDescriptor[32];

    public:
        USBDevice();
        virtual ~USBDevice();

    protected:
        int IsDataAvailable(void);
        DWORD GetPacket(void);
        DWORD WaitForUSBPacket(int command, int subcommand, int pid);
        int recv(SOCKET s, char *buf, int len, int flags);
        int send(SOCKET s, char *buf, int len, int flags);
        int sendto(SOCKET s, char *buf, int len, int flags, struct sockaddr *to, int tolen);
        int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);

    public:
        DWORD Plug(void);
        DWORD Unplug(void);
        DWORD SetupEndpoint(unsigned endpoint, unsigned type, unsigned fifoSize, unsigned autoRepeat);

    // virtual member functions
    public:
        DWORD ThreadFunct(void);
        virtual DWORD EndpointConfig(unsigned config) = 0;
        virtual DWORD Receive(void) = 0;
        virtual const char* GetName(void) = 0;
        virtual bool IsEnumerated(void) = 0;

    public:
        friend class USBSimulator; // give the USBSimulator access to us
    };


//
// Debug output printing functions
//
void DebugPrint(char* format, ...);
void PrintPacket(SimPacket *packet);

//
// Utility functions
//
const char* const GetPIDName(unsigned char pid);

//
// Dealing with Endians
//
#define ENDIAN_SHIFT_32(v) ((((v) >> 24) & 0x000000FFL) | (((v) >>  8) & 0x0000FF00L) | (((v) <<  8) & 0x00FF0000L) | (((v) << 24) & 0xFF000000L))
#define ENDIAN_SHIFT_16(v) ((unsigned __int16)((((v) >> 8) & 0x00FF) | (((v) << 8) & 0xFF00)))
template <class T> class BigEndian
    {
    private:
        T value;

    public:
        // Read
        //operator unsigned __int16()             { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator unsigned short()               { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        //operator __int16()                      { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator short()                        { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }

        //operator unsigned __int32()             { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator unsigned long()                { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator unsigned int()                 { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        //operator __int32()                      { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator long()                         { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }
        operator int()                          { return sizeof(T)==2?ENDIAN_SHIFT_16(value):ENDIAN_SHIFT_32(value); }

        // Write
        //T operator=(unsigned __int16 newVal)    { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(unsigned short newVal)      { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        //T operator=(__int16 newVal)             { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(short newVal)               { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }

        //T operator=(unsigned __int32 newVal)    { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(unsigned long newVal)       { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(unsigned int newVal)        { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        //T operator=(__int32 newVal)             { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(long newVal)                { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
        T operator=(int newVal)                 { return value = (T)(sizeof(T)==2?ENDIAN_SHIFT_16(newVal):ENDIAN_SHIFT_32(newVal)); }
    };



//
// All child devices will go here:
//
#include "XIDDevice.h"      // Duke XID device
#include "BulkDevice.h"     // MU Bulk device
#include "IsocDevice.h"     // Isoc device


#endif // _USB_SIMULATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\inc\xiddevice.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    XIDDevice.h

Abstract:

    USB Device child class that handles XID enumeration and reporting

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#ifndef _XIDDEVICE_H_
#define _XIDDEVICE_H_

#pragma pack(push, 1) // align structure members on a byte boundry
struct XIDInputReport
    {
    unsigned __int8  reportID;
    unsigned __int8  size;
    unsigned __int16 buttons;
    unsigned __int8  analogButtons[8];
    __int16 thumbLX;
    __int16 thumbLY;
    __int16 thumbRX;
    __int16 thumbRY;
    };
extern const XIDInputReport defaultXIDReport;
#pragma pack(pop)



/*****************************************************************************

Class Description:

    XIDDevice

    USB Device child class that handles XID enumeration and reporting

Notes:
    

*****************************************************************************/
class XIDDevice : public USBDevice
    {
    public:
        unsigned enumerateState[10];

    protected:
        unsigned __int8 *xidPacket;
        unsigned __int8 *inCapabilities;
        unsigned __int8 *outCapabilities;
        unsigned __int8 *xidDescriptor;
        unsigned xidPacketLen;
        unsigned inCapabilitiesLen;
        unsigned outCapabilitiesLen;
        unsigned xidDescriptorLen;

    public:
        XIDDevice();
        ~XIDDevice();

    // virtual member functions
    public:
        DWORD EndpointConfig(unsigned config);
        DWORD Receive(void);
        const char* GetName(void);
        bool IsEnumerated(void);

    protected:
        DWORD HandleSETUP(void);
        DWORD HandleOUT(void);
        DWORD HandleIN(void);

    public:
        DWORD SetInputReport(XIDInputReport *xid);
        DWORD SetInputReport(unsigned __int8 reportID, unsigned __int8 size, unsigned __int16 buttons, unsigned __int8 *analogButtons, unsigned __int16 thumbLX, unsigned __int16 thumbLY, unsigned __int16 thumbRX, unsigned __int16 thumbRY);

    public:
        friend class CDuke; // give the COM object access to us
    };

#endif // _XIDDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\ctrltest\ctrltest.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    ctrltest.cpp

Abstract:

    USB Simulator Test app

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\..\inc\USBSimulator.h"
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

// Tests
void DukeTest(USBSimulator &usbsim);
void MUTest(USBSimulator &usbsim);
void HawkTest(USBSimulator &usbsim);


int main(int argc, char* argv[])
    {
    printf("USB Simulator Test\n\n");

    //
    // configure the Simulator object
    //
    USBSimulator usbsim;                                    // no logging
    //USBSimulator usbsim(true, RECORDING_FORMAT_CHIEF_UTG);  // CATC Chief readable format
    //USBSimulator usbsim(true, RECORDING_FORMAT_TEXT_LOG);   // text format

    //
    // Look for simulators on the network
    //
    unsigned numSimulators = usbsim.FindSimulators();
    printf("Found %u simulators\n", numSimulators);
    if(numSimulators == 0)
        {
        printf("Startup 1 or more USB Simulators on the network first!\n");
        printf("Press Enter...");
        getchar();
        return 0;
        }

    // Point to a specific simulator
    usbsim.ip[0] = inet_addr("157.56.10.18");

    //
    // Get the version and MAC address from the first simulator
    //
    SimPacketTyped<unsigned char [128]> simData;
    memset(&simData, 0, sizeof(simData));
    usbsim.SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_VERSION, simData);
    simData.data[simData.header.dataSize] = '\0';
    printf("   Sim[0] Version:  %s\n", simData.data);

    memset(&simData, 0, sizeof(simData));
    usbsim.SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_MACADDR, simData);
    printf("   Sim[0] MAC Addr: %02X %02X %02X %02X %02X %02X\n", simData.data[0], simData.data[1], simData.data[2], simData.data[3], simData.data[4], simData.data[5]);


    //
    // Run the tests
    //
    //DukeTest(usbsim);
    //MUTest(usbsim);
    //HawkTest(usbsim);


    //
    // Done
    //
    printf("\nPress <Enter>...");
    getchar();
    return 0;
    }


/*****************************************************************************

Routine Description:

    Duke Test

Arguments:

    USBSimulator

Return Value:

    none

*****************************************************************************/
void DukeTest(USBSimulator &usbsim)
    {
    DWORD err;

    XIDInputReport xidPacket = defaultXIDReport;
    unsigned state;

    printf("\nRunning Duke Test\n");
    XIDDevice *xid = new XIDDevice;

    printf("   Inserting the device\n");
    err = usbsim.Plug(USBSIM_HOST_PORT1, 0, xid);
    _ASSERT(err == USBSIM_ERROR_OK);

    printf("   Waiting for several seconds...\n");

    Sleep(1000); // let the enumeration happen
    if(xid->IsEnumerated()) printf("   Duke enumerated!\n");

    // move down
    for(state = 0; state<80; state++)
        {
        xidPacket.thumbLY = -32000;
        xid->SetInputReport(&xidPacket);
        Sleep(50);

        xidPacket.thumbLY = 0;
        xid->SetInputReport(&xidPacket);
        Sleep(50);
        }

    // move up
    for(state = 0; state<80; state++)
        {
        xidPacket.thumbLY = 32000;
        xid->SetInputReport(&xidPacket);
        Sleep(50);

        xidPacket.thumbLY = 0;
        xid->SetInputReport(&xidPacket);
        Sleep(50);
        }

    printf("\n   Press <Enter> to unplug the device...");
    getchar();

    printf("   Removing the device\n");
    err = usbsim.Unplug(xid);
    _ASSERT(err == USBSIM_ERROR_OK);
    delete xid;
    }




/*****************************************************************************

Routine Description:

    MU Test

Arguments:

    USBSimulator

Return Value:

    none

*****************************************************************************/
void MUTest(USBSimulator &usbsim)
    {
    DWORD err;

    printf("\nRunning MU Test\n");
    BulkDevice *mu = new BulkDevice;

    printf("   Inserting the device\n");
    err = usbsim.Plug(USBSIM_HOST_PORT1, 0, mu);
    _ASSERT(err == USBSIM_ERROR_OK);

    Sleep(1000); // let stuff happen

    if(mu->IsEnumerated()) printf("   MU enumerated!\n");

    printf("\n   Press <Enter> to unplug the device...");
    getchar();

    printf("   Removing the device\n");
    err = usbsim.Unplug(mu);
    _ASSERT(err == USBSIM_ERROR_OK);
    delete mu;
    }



/*****************************************************************************

Routine Description:

    Hawk Test

Arguments:

    USBSimulator

Return Value:

    none

*****************************************************************************/
void HawkTest(USBSimulator &usbsim)
    {
    DWORD err;

    printf("\nRunning Hawk Test\n");
    IsocDevice *isoc = new IsocDevice;

    printf("   Inserting the device\n");
    err = usbsim.Plug(USBSIM_HOST_PORT1, 0, isoc);
    _ASSERT(err == USBSIM_ERROR_OK);

    printf("   Waiting for several seconds...\n");

    Sleep(1000); // let the enumeration happen
    if(isoc->IsEnumerated()) printf("   Hawk enumerated!\n");

    printf("\n   Press <Enter> to unplug the device...");
    getchar();

    printf("   Removing the device\n");
    err = usbsim.Unplug(isoc);
    _ASSERT(err == USBSIM_ERROR_OK);
    delete isoc;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\simsim\csockserver.h ===
// CSockServer.h
//
// This class will allow the creation of the Winsock Server object that
// can send and receive data within it's own thread.
//
// It is derived from a Thread class created from Josh Poley
//
// CSockServer is a modification of a class created by Jim Helm
///////////////////////////////////////////////////////////////////////
#ifndef _CSOCKSERVER_H_
#define _CSOCKSERVER_H_

#include <winsock2.h>
#include "CWorkerThread.h"

class CSockServer : public CWorkerThread
    {
    private:
        SOCKET m_socket;                                        // Socket used to "listen" for connections
        //SOCKET m_remotesocket;                                  // Socket returned by "accepted" connections
        WSADATA m_wsadata;                                      // Winsock data structure
        //LPHOSTENT m_lpHostEntry;                                // Pointer to a HOST Entry Structure
        struct sockaddr_in m_sockaddr;                          // Our Sock Address structure
        USHORT m_usPort;                                        // Port of our current server

        int GetSocket(int af=AF_INET,
                    int socktype=SOCK_STREAM,
                    int protocol=IPPROTO_TCP);                  // Get our socket
        //SOCKET GetRemoteSocket();                               // Returns the "accepted" socket from our server thread
        virtual DWORD ThreadFunct(void);                        // Thread function to handle accepting connections

    public:
        int m_socktype;
        HWND parent;
        char m_key[1024];

    public:
        CSockServer();                                          // Constructor
        ~CSockServer();                                         // Destructor
        //int GetHostByNameOrAddress(LPCSTR lpHostNameOrAddr);  // Populates the m_lpHostEntry structure
        int Init(WORD wVersionRequested=MAKEWORD(1,1));         // Initialize Windows Sockets
        int BindSocket();                                       // Bind or Name our socket
        int OpenServerSocket(int socktype);                     // Create the socket for our server
        void CloseOpenSockets();                                // Shutdown all of our open sockets
        int CloseSocket(SOCKET s);                              // Close our socket
        BOOL IsDataAvailable(SOCKET s);

        USHORT GetPort() { Lock(); USHORT usTemp = m_usPort; Unlock(); return (usTemp); }   // Returns the port number of the server
        void SetPort(USHORT usNewPort) { Lock(); m_usPort = usNewPort; Unlock(); }  // Sets the port number of the server
    };

#endif // _CSOCKSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\simsim\csockserver.cpp ===
// CSockServer.cpp
//
// This class will allow the creation of the Winsock Server object that
// can send and receive data within it's own thread.
//
// It is derived from a Thread class created from Josh Poley
//
// CSockServer is a modification of a class created by Jim Helm
///////////////////////////////////////////////////////////////////////
#include "CSockServer.h"

#include "..\..\inc\SimPacket.h"
void HandleDukeStuff(SOCKET sock);
#include <stdio.h>

// Bind or Name our socket
int CSockServer::BindSocket()
    {
    int nReturnVal=0;						// Return Value for BindSocket()

    m_sockaddr.sin_family = AF_INET;
    m_sockaddr.sin_port = htons(GetPort());
    m_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); // (u_long)0x9D370D57

    nReturnVal = bind(m_socket, (LPSOCKADDR)&m_sockaddr, sizeof(SOCKADDR));
    if(SOCKET_ERROR == nReturnVal)
        {
        //nReturnVal = GetLastError();
        //Trace("Bind failed!\n");
        //Trace("WS Last Error : %d\n", GetLastWSError());
        printf("Bind failed!\n");
        }

    return (nReturnVal);
    }


// Close our Socket
int CSockServer::CloseSocket(SOCKET s)
    {
    int nReturnVal=0;		// Return Value of CloseSocket()

    Lock();
    if(NULL == s)
        {
        s = m_socket;
        }

    // Shutdown the socket (will fail if not connected)
    nReturnVal = shutdown(s, SD_BOTH);
    if(SOCKET_ERROR == nReturnVal)
        {
        //nReturnVal = GetLastError();
        //Trace("Shutdown(s) failed!\n");
        //Trace("WS Last Error : %s\n", GetLastWSError());
        }

    // Close the socket
    nReturnVal = closesocket(s);
    if(SOCKET_ERROR == nReturnVal)
        {
        //nReturnVal = GetLastError();
        //Trace("closesocket(s) failed!\n");
        //Trace("WS Last Error : %s\n", GetLastWSError());
        }
    Unlock();

    return (nReturnVal);
    }

// Constructor
CSockServer::CSockServer()
    {
    parent = NULL;
    m_socket = NULL;
    m_socktype = SOCK_DGRAM;
    m_key[0] = '\0';
    }

// Destructor
CSockServer::~CSockServer()
    {
    CloseSocket(m_socket);
    }


// Get our Socket
int CSockServer::GetSocket(int af, int socktype, int protocol)
    {
    int nReturnVal=0;		// Return value for GetSocket()

    m_socket = socket(af, socktype, protocol);
    if(INVALID_SOCKET == m_socket)
        {
        //nReturnVal=WSAGetLastError();
        printf("socket failed: Last WS Error: %u\n", WSAGetLastError ());
        }

    return nReturnVal;
    }

// Initialize our Windows Socket
// Returns 0 if successful, non-zero if there was a problem
int CSockServer::Init(WORD wVersionRequested)
    {
    int nReturnVal=0;			// Return value of Init()

    nReturnVal = WSAStartup(wVersionRequested, &m_wsadata);

    return nReturnVal;
    }

// Create our server socket
int CSockServer::OpenServerSocket(int socktype)
    {
    int nReturnVal;			// Return value for OpenServerSocket()
    if(socktype == SOCK_DGRAM) nReturnVal = GetSocket(AF_INET, socktype, 0);
    else nReturnVal = GetSocket(AF_INET, socktype, IPPROTO_TCP);
    if(WSANOTINITIALISED == nReturnVal)
        {
        if(0 == Init())
            {
            nReturnVal = GetSocket();
            }
        }
    return nReturnVal;
    }

BOOL CSockServer::IsDataAvailable(SOCKET s)
    {
    TIMEVAL timeout;
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = s;
    timeout.tv_sec = 60;
    timeout.tv_usec = 0;

    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == 0 || err == SOCKET_ERROR)
        {
        return FALSE;
        }

    return TRUE;
    }

extern DWORD clientAddress;
extern unsigned short clientPort;
extern bool clientConnected;

// Thread code for our Winsock Server
DWORD CSockServer::ThreadFunct(void)
    {
	DWORD nReturnVal=0;				// Return Value of ThreadFunct()
    char buffer[1024];
    SimPacket *packet = (SimPacket*)buffer;
    int err;
    SOCKADDR_IN dest;
    int addrsize=sizeof(SOCKADDR);

	while(!GetExitFlag())
        {
        if(m_usPort == SIM_NETPORT_USB1)
            {
            TIMEVAL timeout;
            FD_SET bucket;
            bucket.fd_count = 1;
            bucket.fd_array[0] = m_socket;
            timeout.tv_sec = 5;
            timeout.tv_usec = 0;
            err = select(0, &bucket, NULL, NULL, &timeout);
            if(err == 0 || err == SOCKET_ERROR) continue;

            err = recvfrom(m_socket, buffer, 1024, 0, (SOCKADDR*)&dest, &addrsize);
            printf("Got Packet: %d, %d, %d, %d\n", packet->command, packet->subcommand, packet->param, packet->dataSize);
            if(err>0)
                {
                if(packet->command == SIM_CMD_SETUP && packet->subcommand == SIM_SUBCMD_SETUP_CONNECT)
                    {
                    if(packet->data[0] == 1)
                        {
                        clientPort = dest.sin_port;
                        clientAddress = dest.sin_addr.S_un.S_addr;
                        printf("Client Port: %d, IP: %s\n", ntohs(clientPort), inet_ntoa(dest.sin_addr));
                        HandleDukeStuff(m_socket);
                        }
                    else if(packet->data[0] == 1) printf("Device disconnected\n");
                    }
                else
                    {
                    Sleep(10);
                    }
                }
            else
                {
                Sleep(10);
                continue;
                }
            }
        else
            {
            TIMEVAL timeout;
            FD_SET bucket;
            bucket.fd_count = 1;
            bucket.fd_array[0] = m_socket;
            timeout.tv_sec = 5;
            timeout.tv_usec = 0;
            err = select(0, &bucket, NULL, NULL, &timeout);
            if(err == 0 || err == SOCKET_ERROR) continue;

            err = recvfrom(m_socket, buffer, 1024, 0, (SOCKADDR*)&dest, &addrsize);
            if(err>0)
                {
                buffer[err] = '\0';
                }
            else
                {
                Sleep(10);
                continue;
                }

            if(packet->command == SIM_CMD_IPQUERY)
                {
                printf("Received IP Query request, sending response\n");
                packet->subcommand = 0;
                packet->dataSize = 4;
                packet->data[0] = 1;
                packet->data[1] = 2;
                packet->data[2] = 3;
                packet->data[3] = 4;
                sendto(m_socket, buffer, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
                }
            else if(packet->command == SIM_CMD_STATUS && packet->subcommand == SIM_SUBCMD_STATUS_CONNECTED)
                {
                printf("Received Device Status command, sending response\n");
                packet->dataSize = 1;
                packet->data[0] = clientConnected ? 1 : 0;
                sendto(m_socket, buffer, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
                }
            else if(packet->command == SIM_CMD_STATUS && packet->subcommand == SIM_SUBCMD_STATUS_VERSION)
                {
                printf("Received Version command, sending response\n");
                strcpy((char*)packet->data, "SimSim v 1.1");
                packet->dataSize = strlen((char*)packet->data)+1;
                sendto(m_socket, buffer, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
                }
            else
                {
                printf("Received unknown command/subcommand: %u, %u\n", packet->command, packet->subcommand);
                }
            }
        }

    return nReturnVal;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\simsim\cworkerthread.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CWorkerThread.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/
#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif
#include <stdio.h>
#include <windows.h>
#include <process.h>
#include "CWorkerThread.h"

static DWORD ExceptionHandler(LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    //xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    //DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }

/*****************************************************************************

Routine Description:

    LocalThreadFunct

Arguments:

    LPVOID lpParameter  - a valid CWorkerThread class

Return Value:

    0 on error, ~0 on execption, or the thread's exit value

Notes:


*****************************************************************************/
static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter)
    {
    DWORD returnCode = 0;
    HWND window = NULL;
    UINT msg = 0;
    LPARAM lparam = 0;
    CWorkerThread *localPointer = (CWorkerThread*)lpParameter;

    if(!localPointer)
        {
        // a valid CWorkerThread class must be supplied via the lpParameter!
        //_ASSERT(localPointer);
        return 0;
        }

    // turn off the exit flag and set notification values
    localPointer->Lock();
    localPointer->bExit = FALSE;
    window = localPointer->notifyWindow;
    msg = localPointer->notifyMsg;
    lparam = localPointer->notifylParam;
    localPointer->Unlock();

    // set the thread id
    localPointer->SetThreadID(GetCurrentThreadId());

    // run the main thread function (this is the custom function)
#ifdef _DEBUG
    returnCode = localPointer->ThreadFunct();
#else
    __try
        {
        returnCode = localPointer->ThreadFunct();
        }
   __except(ExceptionHandler(GetExceptionInformation()))
        {
        returnCode = (DWORD)~0x0L;
        }
#endif

    // invalidate the thread handle & id
    localPointer->SetThreadID((DWORD)~0x0L);
    localPointer->SetThreadHandle((DWORD)~0x0L);

    // store the return code from the main thread function
    localPointer->Lock();
    localPointer->dwThreadExitCode = returnCode;
    localPointer->Unlock();

    // send notification if necessary
    if(window)
        {
        //No messages in XBOX so below line is commented out
        //PostMessage(window, msg, (WPARAM)returnCode, lparam);
        }

    // exit thread
    return returnCode;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::Run
    start up a worker thread

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
void CWorkerThread::Run(void)
    {
    DWORD handle = _beginthread((void (__cdecl *)(void *))LocalThreadFunct, 0, this);
    SetThreadHandle(handle);
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread()
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;

    dwLocalThreadID = 0;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    DWORD localID

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread(DWORD localID)
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;
    
    dwLocalThreadID = localID;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::~CWorkerThread
    worker thread data destructor

Arguments:

    none

Return Value:

    none

Notes:

    If the thread does not exit, this function will be caught in an infinate 
        loop.

*****************************************************************************/
CWorkerThread::~CWorkerThread()
    {
    if(GetThreadHandle() != (DWORD)~0x0L)
        {
        DWORD timeout = 1000; // start with 1 sec

        // if your code infinite loops here, you have a blocking problem
        while(!SoftBreak(timeout))
            {
            timeout *= 2;
            if(timeout == 64000) OutputDebugStringA("CWorkerThread::~CWorkerThread(): Possible deadlock\n");
            }
        }

    DeleteCriticalSection(&criter);
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::SoftBreak

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timedout before the thread exited

Notes:

*****************************************************************************/
BOOL CWorkerThread::SoftBreak(DWORD dwTimeOut)
    {
    Lock();
    bExit = TRUE;
    Unlock();

    return WaitForExit(dwTimeOut);
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::HardBreak

Arguments:

    none

Return Value:

    TRUE - operation succedded, FALSE - the operation failed.

Notes:

    This function does not perform any locking or unlocking.

    WARNING: Do not use this function execpt in DIRE situations. This WILL 
        cause leaks, and perhaps blocking or crashes if critical sections 
        are not released!

*****************************************************************************/
BOOL CWorkerThread::HardBreak(void)
    {
    DWORD dwHandle = dwThreadHandle;
    bExit = TRUE;
    dwThreadHandle = (DWORD)~0x0L;
    dwThreadExitCode = (DWORD)~0x0L;
    dwThreadID = (DWORD)~0x0L;

    if(dwHandle != (DWORD)~0x0L)
        {
        OutputDebugStringA("CWorkerThead::HardBreak() called!\n");
        return TerminateThread((void*)dwHandle, (DWORD)~0x0L);
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::WaitForExit

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timeout was reached

Notes:

*****************************************************************************/
BOOL CWorkerThread::WaitForExit(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(GetThreadHandle() != (DWORD)~0x0L)
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Lock

Arguments:

    DWORD dwTimeOut - timeout value in ms
   
Return Value:

    TRUE - critical section entered, FALSE - timeout

Notes:

*****************************************************************************/
#ifdef _WIN32_WINNT // TryEnterCriticalSection only available on NT
#include "winbase.h"
BOOL CWorkerThread::Lock(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(!TryEnterCriticalSection(&criter))
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }
#endif

/*****************************************************************************

Routine Description:

    CWorkerThread::SetExitNotify

Arguments:

    HWND   notifyDestination  - handle to the destination window
    UINT   message            - the message to send
    LPARAM lParam             - custom parameter to send

Return Value:

    none

Notes:

    WPARAM of the message is always the return code for the thread

*****************************************************************************/
void CWorkerThread::SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam)
    {
    Lock();
    notifyWindow = notifyDestination;
    notifyMsg = message;
    notifylParam = lParam;
    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::SuspendThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API SuspendThread

*****************************************************************************/
DWORD CWorkerThread::SuspendThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
        {
        return ::SuspendThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::ResumeThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API ResumeThread

*****************************************************************************/
DWORD CWorkerThread::ResumeThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
        {
        return ::ResumeThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    Utils.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"

// USB PID names based on the lower 4 bits of the PID value 
static const char * const usbPIDStrings[] = { 
    "MDATA",
    "DATA2",
    "DATA1",
    "DATA0",
    "SETUP",
    "SOF",
    "IN",
    "OUT",
    "STALL",
    "NYET",
    "NAK",
    "ACK",
    "ERR",
    "PING",
    "SPLIT",
    "RESERVED"
    };

const char* const GetPIDName(unsigned char pid)
    {
    return usbPIDStrings[pid&0x0F];
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }

void PrintPacket(SimPacket *packet)
    {
    DebugPrint("SimPacket:\n  command:    %d\n  subcommand: %d\n  datasize:   %d\n  data:       ", packet->command, packet->subcommand, packet->dataSize);
    for(unsigned i=0; i<packet->dataSize; i++)
        DebugPrint("%02X ", packet->data[i]);
    DebugPrint("\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\BulkDevice.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    BulkDevice.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"

static const char* const DeviceName = "Bulk Device";

/*****************************************************************************

Routine Description:

    Default Constructor/Destructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
BulkDevice::BulkDevice()
    {
    for(unsigned i=0; i<10; i++)
        enumerateState[i] = 0;

    storage = NULL;
    SetCapacity(0x3EFF, 0x0200, 0); // 8megs

    bufferSize = 9*1024;
    receiveBuffer = new char[bufferSize];

    memcpy(deviceDescriptor, "\x12\x01\x10\x01\x00\x00\x00\x08", 8);
    memcpy(configurationDescriptor, "\x09\x02\x20\x00\x01\x01\x00\x80\x1E\x09\x04\x00\x00\x02\x08\x42\x50\x00\x07\x05\x81\x02\x40\x00\x00\x07\x05\x02\x02\x40\x00\x00", 32);
    }
BulkDevice::~BulkDevice()
    {
    delete[] receiveBuffer;
    delete[] storage;
    }


/*****************************************************************************

Routine Description:

    GetName

    Returns a textual description of this device, used for logging

Arguments:

    none

Return Value:

    char*   ptr to a global string

*****************************************************************************/
const char* BulkDevice::GetName(void)
    {
    return DeviceName;
    }


/*****************************************************************************

Routine Description:

    EndpointConfig

    Configures up the Endpoint settings on the simulator

Arguments:

    config      0 - disable
                1 - normal state
                2 - repeat state
                

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD BulkDevice::EndpointConfig(unsigned config)
    {
    DWORD error = USBSIM_ERROR_OK;
    unsigned i;

    if(record) recorder.LogPrint("Configuring endpoints.");
    switch(config)
        {
        case 0:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 1:
            dataToggle = true;
            for(i=0; i<10; i++)
                enumerateState[i] = 0;
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_NOISOC, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 2:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_NOISOC, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
                }
            break;
        default: 
            break;
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    Receive

    Handles all incomming packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD BulkDevice::Receive(void)
    {
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;

    // USB request
    if(packet->command == SIM_CMD_USBDATA)
        {
        if(usb->pid == USB_PID_SETUP) return HandleSETUP();
        else if(usb->pid == USB_PID_OUT) return HandleOUT();
        else if(usb->pid == USB_PID_IN) return HandleIN();
            {
            DebugPrint("Unexpected USB packet:\n");
            PrintPacket(packet);
            }
        }
    else if(packet->command == SIM_CMD_USBEXTRADATA)
        {
        if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_ACKNAK)
            {
            if(usb->pid == USB_PID_NAK)
                {
                DebugPrint("DETECTED MISSING IN - Responding to the NAK\n");
                return HandleIN();
                }
            return USBSIM_ERROR_OK;
            }
        else if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_RESET)
            {
            Lock();
            for(unsigned i=0; i<8; i++)
                {
                enumerateState[i] = 0;
                }
            Unlock();

            DebugPrint("Reset packet:\n");
            PrintPacket(packet);
            }
        }

    // other packets
    else
        {
        DebugPrint("Unexpected packet:\n");
        PrintPacket(packet);
        }

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    HandleSETUP

    Handles all USB SETUP packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD BulkDevice::HandleSETUP(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    bool notdone;


    enumerateState[1] = 1;
    enumerateState[7] = 1;

    error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_DATA0);
    if(error != USBSIM_ERROR_OK) return error;

    //
    // Get Device Descriptor
    //
    if(memcmp(usb->data, "\x80\x06\x00\x01\x00\x00\x08\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, deviceDescriptor, packet->dataSize-1);
            ++enumerateState[0];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Set Address
    //
    else if(memcmp(usb->data, "\x00\x05", 2) == 0 && memcmp(usb->data+3, "\x00\x00\x00\x00\x00", 5) == 0)
        {
        unsigned char addr = usb->data[2];
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

            packet->command = SIM_CMD_SETUP;
            packet->subcommand = SIM_SUBCMD_SETUP_USBADDRESS;
            packet->dataSize = 1;
            packet->data[0] = addr;
            //Lock();
            //++enumerateState[1];
            //Unlock();
            Sleep(USBSIM_UDP_DELAY);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Get Configuration Descriptor
    //
    else if(memcmp(usb->data, "\x80\x06\x00\x02\x00\x00\x50\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, configurationDescriptor, packet->dataSize-1);
            ++enumerateState[2];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xC3;
            Lock();
            memcpy(packet->data+1, configurationDescriptor+8, packet->dataSize-1);
            ++enumerateState[3];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, configurationDescriptor+16, packet->dataSize-1);
            ++enumerateState[4];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xC3;
            Lock();
            memcpy(packet->data+1, configurationDescriptor+24, packet->dataSize-1);
            ++enumerateState[5];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            Lock();
            memcpy(packet->data, "\xD2", packet->dataSize);
            ++enumerateState[6];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Set Configuration
    //
    else if(memcmp(usb->data, "\x00\x09\x01\x00\x00\x00\x00\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            //Lock();
            //++enumerateState[7];
            //Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Unknown SETUP/DATA0 packet
    //
    else
        {
        DebugPrint("Unexpected SETUP/DATA0 packet:\n");
        PrintPacket(packet);
		
        notdone = true;
        while(notdone == true)
            {
            error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
            if(error == USBSIM_ERROR_OK)
                {
                if(packet->param != 0)
                    {	// its not control pipe IN
                    HandleIN();
                    }
                else
                    {	// its on the control endpoint, handle it
                    packet->command = SIM_CMD_USBDATA;
                    packet->subcommand = SIM_SUBCMD_USBDATA;
                    packet->dataSize = 1;
                    memcpy(packet->data, "\xD2", packet->dataSize);
                    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
                    notdone = false;
                    }
                }
            }
        }

    return error;
    }

/*****************************************************************************

Routine Description:

    HandleOUT

    Handles all USB OUT packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD BulkDevice::HandleOUT(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    SimPacketTyped<CSW> csw;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;

    error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, -1);
    if(error != USBSIM_ERROR_OK) return error;

    SimPacketTyped<CBW> *cbw = (SimPacketTyped<CBW>*)packet;

    //
    // Read Capacity
    //
    if(cbw->data.opCode == 0x25)
        {
        csw.data.sig = cbw->data.sig + 0x10000000;
        csw.data.tag = cbw->data.tag;
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            dataToggle = true;
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            Lock();
            memcpy(packet->data+1, &capacity, sizeof(MUCapacity));
            Unlock();
            packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
            dataToggle = !dataToggle;
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }

        // Send CSW
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            csw.data.dataLength = 0;
            csw.data.result = 0;
            csw.header.command = SIM_CMD_USBDATA;
            csw.header.subcommand = SIM_SUBCMD_USBDATA;
            csw.header.param = packet->param;
            csw.header.dataSize = 14;
            memcpy(cbw, &csw, sizeof(csw));
            packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
            dataToggle = !dataToggle;
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Read Block
    //
    else if(cbw->data.opCode == 0x28)
        {
        csw.data.sig = cbw->data.sig + 0x10000000;
        csw.data.tag = cbw->data.tag;
        DWORD address = (DWORD)cbw->data.address*(DWORD)capacity.blockSize;
        DWORD length = cbw->data.dataLength;
        DWORD index = 0;

        for(index = 0; index < length; index+=64)
            {
            error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
            if(error == USBSIM_ERROR_OK)
                {
                dataToggle = true;
                packet->command = SIM_CMD_USBDATA;
                packet->subcommand = SIM_SUBCMD_USBDATA;
                packet->dataSize = 65;
                Lock();
                memcpy(packet->data+1, storage+address+index, 64);
                Unlock();
                packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
                dataToggle = !dataToggle;
                sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
                }
            else break;
            }

        // Send CSW
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            csw.data.dataLength = 0;
            csw.data.result = 0;

            /*
            // TODO BUGBUG: DONT LEAVE THIS CODE IN!
            DebugPrint("Address: %u\n", address);
            if(address == 4096)
                {
                csw.data.result = 1;
                DebugPrint("Sending CSW FAIL***********************************\n");
                }
            // END TODO BUGBUG
            */

            csw.header.command = SIM_CMD_USBDATA;
            csw.header.subcommand = SIM_SUBCMD_USBDATA;
            csw.header.param = packet->param;
            csw.header.dataSize = 14;
            memcpy(cbw, &csw, sizeof(csw));
            packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
            dataToggle = !dataToggle;
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Write Block
    //
    else if(cbw->data.opCode == 0x2A)
        {
        csw.data.sig = cbw->data.sig + 0x10000000;
        csw.data.tag = cbw->data.tag;
        DWORD address = (DWORD)cbw->data.address*(DWORD)capacity.blockSize;
        DWORD length = cbw->data.dataLength;
        DWORD index = 0;
        unsigned __int8 result = 0;

        for(index = 0; index < length; )
            {
            error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, -1);
            if(error == USBSIM_ERROR_OK)
                {
                if(packet->data[0] == USB_PID_DATA0 || packet->data[0] == USB_PID_DATA1)
                    {
                    Lock();
                    memcpy(storage+address+index, packet->data+1, 64);
                    Unlock();
                    index += 64;
                    }
                else if(packet->data[0] == USB_PID_IN)
                    {
                    error = 1;
                    break;
                    }
                }
            else break;
            }

        // Send CSW
        if(!result) error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            csw.data.dataLength = 0;
            csw.data.result = result;
            csw.header.command = SIM_CMD_USBDATA;
            csw.header.subcommand = SIM_SUBCMD_USBDATA;
            csw.header.param = packet->param;
            csw.header.dataSize = 14;
            memcpy(cbw, &csw, sizeof(csw));
            packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
            dataToggle = !dataToggle;
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }
    else if(packet->dataSize > 1) // Unknown OUT/DATA0 packet
        {
        DebugPrint("Unexpected OUT/DATA0 packet:\n");
        PrintPacket(packet);

        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    HandleIN

    Handles all USB IN packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD BulkDevice::HandleIN(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;

    packet->command = SIM_CMD_USBDATA;
    packet->subcommand = SIM_SUBCMD_USBDATA;
    packet->dataSize = 1;
    memcpy(packet->data, "\xD2", packet->dataSize);
    Sleep(USBSIM_UDP_DELAY);
    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

    return error;
    }


/*****************************************************************************

Routine Description:


Arguments:


Return Value:


Notes:


*****************************************************************************/
bool BulkDevice::IsEnumerated(void)
    {
    bool enumed = true;
    //DebugPrint("BULK: ");
    Lock();
    for(unsigned i=0; i<8; i++)
        {
        if(enumerateState[i] == 0)
            {
            //DebugPrint(" %d", i);
            enumed = false;
            }
        }
    Unlock();
    //DebugPrint("\n");

    return enumed;
    }


/*****************************************************************************

Routine Description:

    SetCapacity

    Changes the default memory unit capacity

Arguments:

    DWORD           numBlocks
    unsigned short  blockSize
    unsigned short  logicalSize

Return Value:

    none

Notes:

    default size (8meg):
        numBlocks   = 0x3EFF
        blockSize   = 0x0200
        logicalSize = 0

*****************************************************************************/
void BulkDevice::SetCapacity(DWORD numBlocks, unsigned short blockSize, unsigned short logicalSize)
    {
    Lock();
    delete[] storage;

    capacity.numBlocks = numBlocks;
    capacity.blockSize = blockSize;
    capacity.logicalSize = logicalSize;
    storage = new unsigned __int8[numBlocks * blockSize];
    memset(storage, 0xFF, numBlocks * blockSize);
    Unlock();
    }


/*****************************************************************************

Routine Description:

    StoreMU

    Write the MU data to a file

Arguments:

    char *filename

Return Value:

    none

*****************************************************************************/
DWORD BulkDevice::StoreMU(char *filename)
    {
    FILE *f = fopen(filename, "wb");
    if(!f) return GetLastError();

    Lock();
    size_t err = fwrite(storage, (unsigned int)capacity.numBlocks * (unsigned int)capacity.blockSize, 1, f);
    Unlock();

    fclose(f);

    if(err != (unsigned int)capacity.numBlocks * (unsigned int)capacity.blockSize) return GetLastError();

    return 0;
    }


/*****************************************************************************

Routine Description:

    LoadMU

    Reads the MU data from a file

Arguments:

    char *filename

Return Value:

    none

*****************************************************************************/
DWORD BulkDevice::LoadMU(char *filename)
    {
    FILE *f = fopen(filename, "rb");
    if(!f) return GetLastError();

    Lock();
    size_t err = fread(storage, (unsigned int)capacity.numBlocks * (unsigned int)capacity.blockSize, 1, f);
    Unlock();

    fclose(f);

    if(err != (unsigned int)capacity.numBlocks * (unsigned int)capacity.blockSize) return GetLastError();

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\usbsimulator.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    USBSimulator.cpp

Abstract:

    This object manages information on remote simulators, and allows a device
    class to attach to a given simulator.

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"
#include <malloc.h>

static const char* const recordingFormatExt[] = { "log", "utg", "xml" };
Recorder recorder; // global recording object

/*****************************************************************************

Routine Description:

    Default Constructor/Destructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
USBSimulator::USBSimulator()
    {
    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    WSAStartup(version, &wsaData);

    for(size_t i=0; i<USBSIM_MAX_SIMULATORS; i++)
        {
        ip[i] = 0;
        }
    record = false;
    }

USBSimulator::USBSimulator(bool startRecording, int recordingFormat)
    {
    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    WSAStartup(version, &wsaData);

    for(size_t i=0; i<USBSIM_MAX_SIMULATORS; i++)
        {
        ip[i] = 0;
        }
    record = startRecording;
    recorder.SetFormat(recordingFormat);

    if(record)
        {
        recorder.LogPrint("");
        recorder.LogPrint("");
        recorder.LogPrint("******************************************************************************");
        recorder.LogPrint("* Started Logfile");
        recorder.LogPrint("******************************************************************************");
        }
    }

USBSimulator::~USBSimulator()
    {
    WSACleanup();
    }


/*****************************************************************************

Routine Description:
    
    SetIP

    Sets the IP addrss on a given simulator

Arguments:

    char simulator  - the simulator to set the IP of
    char *ip        - Ipv4 textual representation of the IP address (a.b.c.d)

Return Value:

    DWORD - binary version of the IP address

*****************************************************************************/
DWORD USBSimulator::SetIP(char simulator, char *ipAddr)
    {
    return ip[simulator] = inet_addr(ipAddr);
    }


/*****************************************************************************

Routine Description:
    
    FindSimulators

    Creates a list of IP Addresses for simulator devices that are connected
    through the network.

Arguments:

    none

Return Value:

    DWORD - the number of simulators that responded to the query

Notes:


*****************************************************************************/
DWORD USBSimulator::FindSimulators(void)
    {
    DWORD count=0;
    SOCKET sock=0;
    int err=0;
    BOOL val=TRUE;
    SOCKADDR_IN dest;
    int addrsize=sizeof(SOCKADDR_IN);
    char buffer[128];
    SimPacketHeader ipQuery = { SIM_CMD_IPQUERY, 0, 0, 0 };
    SimPacket *response = (SimPacket*)buffer;

    // broadcast ip query
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    err = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&val, sizeof(BOOL));
    dest.sin_family = AF_INET;
    dest.sin_port = htons(0);
    dest.sin_addr.s_addr = htonl(INADDR_ANY);
    err = bind(sock, (SOCKADDR *)&dest, sizeof(SOCKADDR_IN));
    if(err == SOCKET_ERROR)
        {
        return 0;
        }
    dest.sin_port = htons(SIM_NETPORT_IPQUERY);
    dest.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    err = sendto(sock, (char*)&ipQuery, sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, addrsize);
    if(err == SOCKET_ERROR)
        {
        return 0;
        }

    TIMEVAL timeout;
    FD_SET bucket;

    for(unsigned i=0; i<USBSIM_MAX_SIMULATORS; i++)
        {
        bucket.fd_count = 1;
        bucket.fd_array[0] = sock;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        // wait for responses
        err = select(0, &bucket, NULL, NULL, &timeout);
        if(err == 0 || err == SOCKET_ERROR) break; // we hit timeout so bail

        // grab the response
        err = recvfrom(sock, buffer, 128, 0, (SOCKADDR*)&dest, &addrsize);
        if(err == 0) break; // no more data

        DebugPrint("Found Client [%u.%u.%u.%u]:\n", dest.sin_addr.S_un.S_un_b.s_b1, dest.sin_addr.S_un.S_un_b.s_b2, dest.sin_addr.S_un.S_un_b.s_b3, dest.sin_addr.S_un.S_un_b.s_b4);

        if(response->command != SIM_CMD_IPQUERY)
            {
            // error
            }
        else
            {
            ip[count] = dest.sin_addr.S_un.S_addr;
            ++count;
            }
        }

    // null out the unused spots
    for(i=count; i<USBSIM_MAX_SIMULATORS; i++)
        {
        ip[i] = 0;
        }

    // clean up
    closesocket(sock);

    return count;
    }


/*****************************************************************************

Routine Description:

    Plug

    Inserts a new device into a "port" on a simulator. Internally we connect
    to the simulator on the proper UDP port, then initialize the device and
    start it's worker thread.

Arguments:

    int port            [in] 1-4
    char simulator      [in] 0 based index of which simulator to attach to
    USBDevice *vdevice  [in] pointer to a new USBDevice class (or child)

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:

    The device must not be currently attached to any other simulator!

*****************************************************************************/
DWORD USBSimulator::Plug(int port, char simulator, USBDevice *vdevice)
    {
    SOCKADDR_IN dest;

    if(!vdevice) return USBSIM_ERROR_INVALID_DEVICE;
    if(vdevice->sock != INVALID_SOCKET) return USBSIM_ERROR_CONNECTED;

    if(simulator > USBSIM_MAX_SIMULATORS || simulator < 0 || ip[simulator] == 0) return USBSIM_ERROR_INVALID_SIMULATOR;
    if(port < 0 || port > USBSIM_MAX_USBPORTS) return USBSIM_ERROR_INVALID_USB_PORT;

    port += SIM_NETPORT_BASE;

    // connect to the simulator
    vdevice->sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(vdevice->sock == INVALID_SOCKET) return USBSIM_ERROR_CONNECT_FAILED;
    dest.sin_family = AF_INET;
    dest.sin_port = htons((unsigned short)(port+SIM_NETPORT_CLIENT_OFFSET));
    dest.sin_addr.s_addr = htonl(INADDR_ANY);
    if(bind(vdevice->sock, (SOCKADDR *)&dest, sizeof(SOCKADDR_IN)) == SOCKET_ERROR) return USBSIM_ERROR_CONNECT_FAILED;

    // initialize settings in the device
    vdevice->record = record;
    vdevice->usbPort = (char)(port-SIM_NETPORT_BASE);
    vdevice->simIP = ip[simulator];
    vdevice->destPort = htons((unsigned short)port);
    if(record) recorder.LogPrint("Inserted device (%s) on port %d of simulator %u.%u.%u.%u", vdevice->GetName(), vdevice->usbPort, ((unsigned char*)&vdevice->simIP)[0], ((unsigned char*)&vdevice->simIP)[1], ((unsigned char*)&vdevice->simIP)[2], ((unsigned char*)&vdevice->simIP)[3]);

    // send any device specific setup commands
    vdevice->EndpointConfig(1);

    // Start the USB Thread that listens for commands and responds to them
    vdevice->Run();

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    Unplug

    This removes the device from the simulator and then signals the device's 
    worker thread to exit.

Arguments:

    USBDevice *vdevice  [in] pointer to a device plugged in using Plug()

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD USBSimulator::Unplug(USBDevice *vdevice)
    {
    if(!vdevice) return USBSIM_ERROR_INVALID_DEVICE;
    if(vdevice->sock == INVALID_SOCKET) return USBSIM_ERROR_NOTCONNECTED;

    // tell the thread to shut down
    shutdown(vdevice->sock, SD_RECEIVE);
    vdevice->SoftBreak(500);

    recorder.LogPrint("Removed device (%s) from port %d of simulator %u.%u.%u.%u", vdevice->GetName(), vdevice->usbPort, ((unsigned char*)&vdevice->simIP)[0], ((unsigned char*)&vdevice->simIP)[1], ((unsigned char*)&vdevice->simIP)[2], ((unsigned char*)&vdevice->simIP)[3]);

    return USBSIM_ERROR_OK;
    }







/*****************************************************************************

Routine Description:

    Recorder

    Constructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
Recorder::Recorder()
    {
    strcpy(filename, "usbsim");
    QueryPerformanceFrequency(&counterFrequency);
    counterFrequency.QuadPart /= 1000; // convert from seconds to ms
    QueryPerformanceCounter(&startTime);
    SetFormat(RECORDING_FORMAT_TEXT_LOG);
    }


/*****************************************************************************

Routine Description:

    SetFilename

    Sets the filename and adds the proper extension based on the current 
    format.

Arguments:

    none

Return Value:

    none

*****************************************************************************/
void Recorder::SetFilename(char *name)
    {
    strcpy(filename, name);
    sprintf(fullFilename, "%s.%s", filename, recordingFormatExt[style]);
    }


/*****************************************************************************

Routine Description:

    SetFormat

    Changes the format of the log file

Arguments:

    int formatType, one of the RECORDING_FORMATS enums

Return Value:

    none

*****************************************************************************/
void Recorder::SetFormat(int formatType)
    {
    if(formatType >= ARRAYSIZE(recordingFormatExt)) return;
    style = formatType;
    sprintf(fullFilename, "%s.%s", filename, recordingFormatExt[style]);
    }


/*****************************************************************************

Routine Description:

    LogPacket

    Takes a network packet, formats it and writes it to the log.

Arguments:

    char *data      [in] pointer to the network packet
    int len         [in] size of the packet
    DWORD deviceID  [in] identifier for the usb "device"
    bool outGoing   [in] true for send (to simulator), or false for recv

Return Value:

    none

*****************************************************************************/
void Recorder::LogPacket(char *data, int len, DWORD deviceID, bool outGoing)
    {
    SimPacket *packet = (SimPacket*)data;
    USBPacket *usb = (USBPacket*)packet->data;
    char *buffer = (char*)_alloca(len*4 + 1024); // allocate space on the stack
    char *ptr = buffer;
    bool usbData = false;

    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    counter.QuadPart -= startTime.QuadPart;
    counter.QuadPart /= counterFrequency.QuadPart;

    if(packet->command == SIM_CMD_USBDATA || (packet->command==SIM_CMD_USBEXTRADATA && packet->subcommand!=SIM_SUBCMD_USBEXTRADATA_RESET)) usbData = true;

    //
    // RECORDING_FORMAT_TEXT_LOG
    //
    if(style == RECORDING_FORMAT_TEXT_LOG)
        {
        ptr += sprintf(ptr, "%08I64u %08X %s // (%s, %s%s%s)\n    %d, %d, %d, %d", counter.QuadPart, deviceID, (outGoing?"[TO SIM]:  ":"[FROM SIM]:"), commandStrings[packet->command%SIM_CMD_MAX], subcommandStrings[packet->command%SIM_CMD_MAX][packet->subcommand], (usbData?": ":""), (usbData?GetPIDName(usb->pid):""), packet->command, packet->subcommand, packet->param, packet->dataSize);
        if(packet->dataSize) ptr += sprintf(ptr, "\n   ");
        for(unsigned i=0; i<packet->dataSize; i++)
            ptr += sprintf(ptr, " %02X", packet->data[i]);
        }


    //
    // RECORDING_FORMAT_TEXT_XML
    //
    else if(style == RECORDING_FORMAT_TEXT_XML)
        {
        ptr += sprintf(ptr, "<PACKET TIME='%08I64u' DIRECTION='%s'>\n", counter.QuadPart, (outGoing?"TO SIM":"FROM SIM"));
        ptr += sprintf(ptr, "    <DESCRIPTION>%s, %s%s%s</DESCRIPTION>\n", commandStrings[packet->command%SIM_CMD_MAX], subcommandStrings[packet->command%SIM_CMD_MAX][packet->subcommand], (usbData?": ":""), (usbData?GetPIDName(usb->pid):""));
        ptr += sprintf(ptr, "    <DEVICEID>%08X</DEVICEID>\n", deviceID);
        ptr += sprintf(ptr, "    <HEADER>\n");
        ptr += sprintf(ptr, "        <COMMAND>    %2d </COMMAND>\n", packet->command);
        ptr += sprintf(ptr, "        <SUBCOMMAND> %2d </SUBCOMMAND>\n", packet->subcommand);
        ptr += sprintf(ptr, "        <ENDPOINT>   %2d </ENDPOINT>\n", packet->param);
        ptr += sprintf(ptr, "        <DATASIZE>   %2d </DATASIZE>\n", packet->dataSize);
        ptr += sprintf(ptr, "        </HEADER>\n");
        ptr += sprintf(ptr, "    <DATA>\n       ");
        for(unsigned i=0; i<packet->dataSize; i++)
            ptr += sprintf(ptr, " %02X", packet->data[i]);
        ptr += sprintf(ptr, "\n        </DATA>\n");
        ptr += sprintf(ptr, "    </PACKET>");
        }


    //
    // RECORDING_FORMAT_CHIEF_UTG
    //
    else if(style == RECORDING_FORMAT_CHIEF_UTG)
        {
        if(usbData)
            {
            ptr += sprintf(ptr, "pid=%s", GetPIDName(usb->pid));
            if(usb->pid == USB_PID_SETUP || usb->pid == USB_PID_IN || usb->pid == USB_PID_OUT)
                {
                ptr += sprintf(ptr, " addr=%u endp=%u ", usb->data[0], usb->data[1]);
                }
            else if(usb->pid == USB_PID_DATA0 || usb->pid == USB_PID_DATA1 || usb->pid == USB_PID_DATA2 || usb->pid == USB_PID_MDATA)
                {
                ptr += sprintf(ptr, "\n  data=(\n   ");
                for(unsigned i=1; i<packet->dataSize; i++)
                    ptr += sprintf(ptr, " %02X", packet->data[i]);
                ptr += sprintf(ptr, "\n    )\n  ");
                }
            else ptr += sprintf(ptr, " ");
            ptr += sprintf(ptr, "eop=3 idle=TO_EOF");
            }
        else
            {
            ptr += sprintf(ptr, "; Network Command: %d, %d, %d, %d", packet->command, packet->subcommand, packet->param, packet->dataSize);
            }
        }


    FILE *f = fopen(fullFilename, "a+");
    if(f)
        {
        fprintf(f, "%s\n", buffer);
        fclose(f);
        }
    }


/*****************************************************************************

Routine Description:

    LogPrint

    Writes a formatted string (like printf) to the log.

Arguments:

    char* format    [in] format specifier
    ...             [in] arguments to the format

Return Value:

    unsigned - number of bytes written

*****************************************************************************/
unsigned Recorder::LogPrint(char* format, ...)
    {
    int bytes;
    char *buffer = (char*)_alloca(1024); // allocate space on the stack
    char *ptr = buffer;

    va_list args;
    va_start(args, format);

    if(style == RECORDING_FORMAT_TEXT_LOG)
        {
        }
    else if(style == RECORDING_FORMAT_TEXT_XML)
        {
        if(*format != '\0') ptr += sprintf(ptr, "<COMMENT><![CDATA[");
        }
    else if(style == RECORDING_FORMAT_CHIEF_UTG)
        {
        if(*format != '\0') ptr += sprintf(ptr, "; ");
        }

    // insert the formatted text
    bytes = vsprintf(ptr, format, args);
    if(bytes == -1) bytes = 0;
    ptr += bytes;

    if(style == RECORDING_FORMAT_TEXT_LOG)
        {
        }
    else if(style == RECORDING_FORMAT_TEXT_XML)
        {
        if(*format != '\0') ptr += sprintf(ptr, "]]></COMMENT>");
        }
    else if(style == RECORDING_FORMAT_CHIEF_UTG)
        {
        }

    FILE *f = fopen(fullFilename, "a+");
    if(f)
        {
        fprintf(f, "%s\n", buffer);
        fclose(f);
        }

    va_end(args);
    return (unsigned) bytes;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\cworkerthread.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CWorkerThread.cpp

Abstract:

    Base class for handling worker threads

Author:

    Josh Poley (jpoley)

*****************************************************************************/
#include "..\inc\CWorkerThread.h"


/*****************************************************************************

Routine Description:

    LocalThreadFunct

Arguments:

    LPVOID lpParameter  - a valid CWorkerThread class

Return Value:

    0 on error, ~0 on execption, or the thread's exit value

Notes:


*****************************************************************************/
static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter)
    {
    DWORD returnCode = 0;
    CWorkerThread *localPointer = (CWorkerThread*)lpParameter;

    if(!localPointer)
        {
        // a valid CWorkerThread class must be supplied via the lpParameter!
        //_ASSERT(localPointer);
        return 0;
        }

    // turn off the exit flag and set notification values
    localPointer->Lock();
    localPointer->bExit = FALSE;
    localPointer->Unlock();

    // set the thread id
    localPointer->SetThreadID(GetCurrentThreadId());

    // run the main thread function (this is the custom function)
    returnCode = localPointer->ThreadFunct();

    localPointer->SetThreadHandle((DWORD)~0x0L);

    // store the return code from the main thread function
    // invalidate the thread handle & id
    localPointer->Lock();
#ifndef _XBOX // dont overwrite the handle if XBOX build
    localPointer->dwThreadHandle = (DWORD)~0x0L;
#endif
    localPointer->dwThreadID = (DWORD)~0x0L;
    localPointer->dwThreadExitCode = returnCode;
    localPointer->Unlock();

    // exit thread
    return returnCode;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::Run
    start up a worker thread

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
void CWorkerThread::Run(void)
    {
#ifdef _XBOX

    DWORD handle = (DWORD)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)LocalThreadFunct, this, 0, 0);
    SetThreadHandle(handle);

#else

    DWORD handle = _beginthread((void (__cdecl *)(void *))LocalThreadFunct, 0, this);
    SetThreadHandle(handle);

#endif
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread()
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    dwLocalThreadID = 0;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    DWORD localID

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread(DWORD localID)
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    dwLocalThreadID = localID;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::~CWorkerThread
    worker thread data destructor

Arguments:

    none

Return Value:

    none

Notes:

    If the thread does not exit, this function will be caught in an infinate 
        loop.

*****************************************************************************/
CWorkerThread::~CWorkerThread()
    {
    if(GetThreadHandle() != (DWORD)~0x0L)
        {
        DWORD timeout = 1000; // start with 1 sec

        // if your code infinite loops here, you have a blocking problem
        while(!SoftBreak(timeout))
            {
            timeout *= 2;
            if(timeout == 64000) OutputDebugStringA("CWorkerThread::~CWorkerThread(): Possible deadlock\n");
            }
        }

#ifdef _XBOX
    DWORD h = GetThreadHandle();
    if(h != (DWORD)~0x0L)
        {
        CloseHandle((HANDLE)h);
        SetThreadHandle((DWORD)~0x0L);
        }
#endif

    DeleteCriticalSection(&criter);
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::SoftBreak

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timedout before the thread exited

Notes:

*****************************************************************************/
BOOL CWorkerThread::SoftBreak(DWORD dwTimeOut)
    {
    Lock();
    bExit = TRUE;
    Unlock();

    return WaitForExit(dwTimeOut);
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::HardBreak

Arguments:

    none

Return Value:

    TRUE - operation succedded, FALSE - the operation failed.

Notes:

    This function does not perform any locking or unlocking.

    WARNING: Do not use this function execpt in DIRE situations. This WILL 
        cause leaks, and perhaps blocking or crashes if critical sections 
        are not released!

*****************************************************************************/
BOOL CWorkerThread::HardBreak(void)
    {
    DWORD dwHandle = dwThreadHandle;
    bExit = TRUE;
    dwThreadHandle = (DWORD)~0x0L;
    dwThreadExitCode = (DWORD)~0x0L;
    dwThreadID = (DWORD)~0x0L;

    if(dwHandle != (DWORD)~0x0L)
        {
#ifdef _XBOX
        OutputDebugStringA("CWorkerThead::HardBreak() called!\n");
        return FALSE;
#else
        OutputDebugStringA("CWorkerThead::HardBreak() called!\n");
        return TerminateThread((void*)dwHandle, (DWORD)~0x0L);
#endif
        }

    return FALSE;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::WaitForExit

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timeout was reached

Notes:

*****************************************************************************/
BOOL CWorkerThread::WaitForExit(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(GetThreadID() != (DWORD)~0x0L)
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

#ifdef _XBOX
    DWORD h = GetThreadHandle();
    if(h != (DWORD)~0x0L)
        {
        CloseHandle((HANDLE)h);
        SetThreadHandle((DWORD)~0x0L);
        }
#endif

    return TRUE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Lock

Arguments:

    DWORD dwTimeOut - timeout value in ms
   
Return Value:

    TRUE - critical section entered, FALSE - timeout

Notes:

*****************************************************************************/
#ifdef _WIN32_WINNT // TryEnterCriticalSection only available on NT
#include "winbase.h"
BOOL CWorkerThread::Lock(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(!TryEnterCriticalSection(&criter))
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }
#endif


/*****************************************************************************

Routine Description:

    CWorkerThread::SuspendThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API SuspendThread

*****************************************************************************/
DWORD CWorkerThread::SuspendThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
        {
        return ::SuspendThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }

/*****************************************************************************

Routine Description:

    CWorkerThread::ResumeThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API ResumeThread

*****************************************************************************/
DWORD CWorkerThread::ResumeThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
        {
        return ::ResumeThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\simsim\simsim.cpp ===
// simsim.cpp : Defines the entry point for the console application.
//

#include "CSockServer.h"
#include "..\..\inc\SimPacket.h"
#include <stdio.h>

DWORD SendPacket(SOCKET sock, unsigned __int8 command, unsigned __int8 subcommand, unsigned __int8 param, unsigned __int8 dataSize, char *data);
BOOL IsDataAvailable(SOCKET s);
DWORD clientAddress;
unsigned short clientPort;
bool clientConnected = false;

int main(int argc, char* argv[])
    {
    CSockServer bcastSrv;
    bcastSrv.Init();
    bcastSrv.SetPort(SIM_NETPORT_IPQUERY);
    bcastSrv.m_socktype = SOCK_DGRAM;
    bcastSrv.OpenServerSocket(bcastSrv.m_socktype);
    bcastSrv.BindSocket();
    bcastSrv.Run();

    CSockServer deviceSrv;
    deviceSrv.Init();
    deviceSrv.SetPort(SIM_NETPORT_USB1);
    deviceSrv.m_socktype = SOCK_DGRAM;
    deviceSrv.OpenServerSocket(deviceSrv.m_socktype);
    deviceSrv.BindSocket();
    deviceSrv.Run();

    printf("Running the server. Press Enter to quit.\n");
    getchar();

    bcastSrv.CloseSocket(NULL);
    deviceSrv.CloseSocket(NULL);

    if(!bcastSrv.SoftBreak(2000)) bcastSrv.HardBreak();
    if(!deviceSrv.SoftBreak(2000)) deviceSrv.HardBreak();

    return 0;
    }


void HandleDukeStuff(SOCKET sock)
    {
    char buffer[1024];
    SimPacket *packet = (SimPacket*)buffer;
    int bytes = 0;
    printf("Device Connected on port %d. Sending Enumeration packets...\n", SIM_NETPORT_USB1);
    clientConnected = true;

    // Get Device Descriptor
    printf(" Get Device Descriptor\n");
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\xB4\x00\x00");
    printf("   SETUP (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 9, "\xC3\x80\x06\x00\x01\x00\x00\xff\x00");
    printf("   DATA0 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x4B"); // ACK

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x00\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x00\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x00\x00"); // repeat the IN
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x4B"); // ACK

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x87\x00\x00");
    printf("   OUT   (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 1, "\xD2");
    printf("   DATA1 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x4B"); // ACK

    // Set Address
    printf(" Set Address\n");
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\xB4\x00\x00");
    printf("   SETUP (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 9, "\xC3\x00\x05\x01\x00\x00\x00\x00\x00");
    printf("   DATA0 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x00\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    // Get Configuration Descriptor
    printf(" Get Configuration Descriptor\n");
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\xB4\x02\x00");
    printf("   SETUP (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 9, "\xC3\x80\x06\x00\x02\x00\x00\x50\x00");
    printf("   DATA0 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    // Set Configuration
    printf(" Set Configuration\n");
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\xB4\x02\x00");
    printf("   SETUP (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 9, "\xC3\x00\x09\x01\x00\x00\x00\x00\x00");
    printf("   DATA0 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    // Get XID Descriptor
    printf(" Get XID Descriptor\n");
    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\xB4\x02\x00");
    printf("   SETUP (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 9, "\xC3\xC1\x06\x00\x41\x00\x00\x08\x00");
    printf("   DATA0 (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());

    bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x00");
    printf("   IN    (%2d bytes) (ec: %u)\n", bytes, WSAGetLastError());
    bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK

    printf(" Device on port %d should be enumerated by now. Sending INs on EP 2...\n", SIM_NETPORT_USB1);
    SOCKADDR_IN dest;
    dest.sin_family = AF_INET;
    dest.sin_port = clientPort;
    dest.sin_addr.s_addr = clientAddress;
    do
        {
        bytes = SendPacket(sock, SIM_CMD_USBDATA, 0, 0, 3, "\x96\x02\x02");
        bytes = SendPacket(sock, SIM_CMD_USBEXTRADATA, 1, 0, 1, "\x5A"); // NAK
        if(bytes == 0 || bytes == SOCKET_ERROR) break;
        if(IsDataAvailable(sock))
            {
            int addressSize = sizeof(SOCKADDR);
            bytes = recvfrom(sock, buffer, 1024, 0, (SOCKADDR*)&dest, &addressSize);
            if(packet->command == SIM_CMD_SETUP && packet->subcommand == SIM_SUBCMD_SETUP_CONNECT && packet->data[0] == 0)
                {
                printf("Device Closed.\n");
                break;
                }
            if(bytes == 0 || bytes == SOCKET_ERROR)
                {
                printf("Socket Error.\n");
                break;
                }
            }
        } while(1);

    clientConnected = false;
    }


DWORD SendPacket(SOCKET sock, unsigned __int8 command, unsigned __int8 subcommand, unsigned __int8 param, unsigned __int8 dataSize, char *data)
    {
    SOCKADDR_IN dest;
    dest.sin_family = AF_INET;
    dest.sin_port = clientPort;
    dest.sin_addr.s_addr = clientAddress;

    char buffer[1024];
    SimPacket *packet = (SimPacket*)buffer;
    packet->command = command;
    packet->subcommand = subcommand;
    packet->param = param;
    packet->dataSize = dataSize;
    memcpy(packet->data, data, packet->dataSize);
    return sendto(sock, buffer, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR));
    }


BOOL IsDataAvailable(SOCKET s)
    {
    TIMEVAL timeout;
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = s;
    timeout.tv_sec = 0;
    timeout.tv_usec = 500000;

    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == 0 || err == SOCKET_ERROR)
        {
        return FALSE;
        }

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\test\simsim\cworkerthread.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CWorkerThread.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Revision History:

Note:
    If you get the following error:
        error C2065: '_beginthread' : undeclared identifier
    Then you are building your project in single threaded mode, switch it to multi-threaded.

*****************************************************************************/

#ifndef _CWORKERTHRAD_H_
#define _CWORKERTHRAD_H_

#include <process.h>    // _beginthread, _endthread

static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

/*****************************************************************************

Class Description:

    Worker thread class

Methods:



Data:



NOTE: 
    
    Remember to nest any member read/write with Lock and Unlock 

    In the implementation of the ThreadFunct function, the user must check 
        the bExit flag and exit gracefully if set.

*****************************************************************************/
class CWorkerThread
    {
    private:
        CRITICAL_SECTION criter;
        DWORD dwThreadHandle;
        DWORD dwThreadID;
        DWORD dwThreadExitCode;

    protected:
        BOOL bExit;

        DWORD dwLocalThreadID;

        // exit notification params
        HWND notifyWindow;
        UINT notifyMsg;
        LPARAM notifylParam;

    // constructors / destructors
    public:
        CWorkerThread();
        CWorkerThread(DWORD localID);
        ~CWorkerThread();

    // public access and information
    public:
        void Lock(void) { EnterCriticalSection(&criter); }
        void Unlock(void) { LeaveCriticalSection(&criter); }

        #ifdef _WIN32_WINNT
        BOOL Lock(DWORD dwTimeOut);
        #endif

        DWORD GetThreadHandle(void) { Lock(); DWORD h = dwThreadHandle; Unlock(); return h; }
        DWORD GetThreadID(void) { Lock(); DWORD id = dwThreadID; Unlock(); return id; }
        DWORD GetLocalThreadID(void) { Lock(); DWORD id = dwLocalThreadID; Unlock(); return id; }
        void  SetLocalThreadID(DWORD id) { Lock(); dwLocalThreadID = id; Unlock(); }
        DWORD GetThreadExitCode(void) { Lock(); DWORD e = dwThreadExitCode; Unlock(); return e; }
        BOOL  GetExitFlag(void) { Lock(); BOOL e = bExit; Unlock(); return e; }

        void Run(void);
        BOOL SoftBreak(DWORD dwTimeOut);
        BOOL HardBreak(void);

        BOOL WaitForExit(DWORD dwTimeOut);

        // thread manipulation
        DWORD SuspendThread(void);
        DWORD ResumeThread(void);

        // notifications
        void SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam);

    // internal functions
    private:
        void SetThreadHandle(DWORD h) { Lock(); dwThreadHandle = h; Unlock(); }
        void SetThreadID(DWORD id) { Lock(); dwThreadID = id; Unlock(); }
        void SetThreadExitCode(DWORD c) { Lock(); dwThreadExitCode = c; Unlock(); }

        friend DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

    // overrideable functions
    public:
        /*****************************************************************************
        NOTE: in the implementation of this function, the user must check 
               the bExit flag and exit gracefully if set:
        while(1)
            {
            if(GetExitFlag()) break;
            }
        *****************************************************************************/
        virtual DWORD ThreadFunct(void) { return 0; }
    };

#endif // _CWORKERTHRAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\IsocDevice.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    IsocDevice.cpp

Abstract:

    USB Device child class that handles Hawk enumeration and communication

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"

static const char* const DeviceName = "Isoc Device";

/*****************************************************************************

Routine Description:

    Default Constructor/Destructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
IsocDevice::IsocDevice()
    {
    for(unsigned i=0; i<10; i++)
        enumerateState[i] = 0;

    bufferSize = 9*1024;
    receiveBuffer = new char[bufferSize];
    }
IsocDevice::~IsocDevice()
    {
    delete[] receiveBuffer;
    }


/*****************************************************************************

Routine Description:

    GetName

    Returns a textual description of this device, used for logging

Arguments:

    none

Return Value:

    char*   ptr to a global string

*****************************************************************************/
const char* IsocDevice::GetName(void)
    {
    return DeviceName;
    }


/*****************************************************************************

Routine Description:

    EndpointConfig

    Configures up the Endpoint settings on the simulator

Arguments:

    config      0 - disable
                1 - normal state
                2 - repeat state
                

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD IsocDevice::EndpointConfig(unsigned config)
    {
    DWORD error = USBSIM_ERROR_OK;
    unsigned i;

    if(record) recorder.LogPrint("Configuring endpoints.");
    switch(config)
        {
        case 0:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 1:
            dataToggle = true;
            for(i=0; i<10; i++)
                enumerateState[i] = 0;
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_ISOC, SIM_ENDPOINT_SETUP_SIZE_ISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 2:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_ISOC, SIM_ENDPOINT_SETUP_SIZE_ISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
                }
            break;
        default: 
            break;
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    Receive

    Handles all incomming packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD IsocDevice::Receive(void)
    {
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;

    // USB request
    if(packet->command == SIM_CMD_USBDATA)
        {
        if(usb->pid == USB_PID_SETUP) return HandleSETUP();
        else if(usb->pid == USB_PID_OUT) return HandleOUT();
        else if(usb->pid == USB_PID_IN) return HandleIN();
        else
            {
            DebugPrint("Unexpected USB packet:\n");
            PrintPacket(packet);
            }
        }
    else if(packet->command == SIM_CMD_USBEXTRADATA)
        {
        if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_ACKNAK)
            {
            if(usb->pid == USB_PID_NAK)
                {
                DebugPrint("DETECTED MISSING IN - Responding to the NAK\n");
                return HandleIN();
                }
            return USBSIM_ERROR_OK;
            }
        else if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_RESET)
            {
            Lock();
            for(unsigned i=0; i<9; i++)
                {
                enumerateState[i] = 0;
                }
            Unlock();

            DebugPrint("Reset packet:\n");
            PrintPacket(packet);
            }
        }

    // other packets
    else
        {
        DebugPrint("Unexpected packet:\n");
        PrintPacket(packet);
        }

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    HandleSETUP

    Handles all USB SETUP packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD IsocDevice::HandleSETUP(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    bool notdone;

    error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_DATA0);
    if(error != USBSIM_ERROR_OK) return error;

    //
    // Get Device Descriptor
    //
    if(memcmp(usb->data, "\x80\x06\x00\x01\x00\x00\x08\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xD2\x12\x01\x10\x01\x00\x00\x00\x08", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[0];
            Unlock();
            }
        }

    //
    // Set Address
    //
    else if(memcmp(usb->data, "\x00\x05", 2) == 0 && memcmp(usb->data+3, "\x00\x00\x00\x00\x00", 5) == 0)
        {
        unsigned char addr = usb->data[2];
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

            packet->command = SIM_CMD_SETUP;
            packet->subcommand = SIM_SUBCMD_SETUP_USBADDRESS;
            packet->dataSize = 1;
            packet->data[0] = addr;
            Sleep(USBSIM_UDP_DELAY);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[1];
            Unlock();
            }
        }

    //
    // Get Configuration Descriptor
    //
    else if(memcmp(usb->data, "\x80\x06\x00\x02\x00\x00\x50\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xD2\x09\x02\x2D\x00\x02\x01\x00\x80", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[2];
            Unlock();
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xC3\x32\x09\x04\x00\x00\x01\x78\x02", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[3];
            Unlock();
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xD2\x00\x00\x09\x05\x04\x05\x32\x00", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[4];
            Unlock();
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xC3\x01\x00\x00\x09\x04\x01\x00\x01", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[5];
            Unlock();
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            memcpy(packet->data, "\xD2\x78\x02\x00\x00\x09\x05\x85\x05", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[6];
            Unlock();
            }
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 6;
            memcpy(packet->data, "\xC3\x32\x00\x01\x00\x00", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[7];
            Unlock();
            }
        }

    //
    // Set Configuration
    //
    else if(memcmp(usb->data, "\x00\x09\x01\x00\x00\x00\x00\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[8];
            Unlock();
            }
        }

    //
    // Unknown SETUP/DATA0 packet
    //
    else
        {
        DebugPrint("Unexpected SETUP/DATA0 packet:\n");
        PrintPacket(packet);
		
        notdone = true;
        while(notdone == true)
            {
            error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
            if(error == USBSIM_ERROR_OK)
                {
                if(packet->param != 0)
                    {	// its not control pipe IN
                    HandleIN();
                    }
                else
                    {	// its on the control endpoint, handle it
                    packet->command = SIM_CMD_USBDATA;
                    packet->subcommand = SIM_SUBCMD_USBDATA;
                    packet->dataSize = 1;
                    memcpy(packet->data, "\xD2", packet->dataSize);
                    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
                    notdone = false;
                    }
                }
            }
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    HandleOUT

    Handles all USB OUT packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD IsocDevice::HandleOUT(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;

    error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, -1);
    if(error != USBSIM_ERROR_OK) return error;

    //
    // 
    //
    if(packet->dataSize > 1) // Unknown OUT/DATA0 packet
        {
        DebugPrint("Unexpected OUT/DATA0 packet:\n");
        PrintPacket(packet);

        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    HandleIN

    Handles all USB IN packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD IsocDevice::HandleIN(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;

    packet->command = SIM_CMD_USBDATA;
    packet->subcommand = SIM_SUBCMD_USBDATA;
    packet->dataSize = 1;
    memcpy(packet->data, "\xD2", packet->dataSize);
    Sleep(USBSIM_UDP_DELAY);
    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

    return error;
    }


/*****************************************************************************

Routine Description:


Arguments:


Return Value:


Notes:


*****************************************************************************/
bool IsocDevice::IsEnumerated(void)
    {
    bool enumed = true;
    Lock();
    for(unsigned i=0; i<9; i++)
        {
        if(enumerateState[i] == 0)
            {
            enumed = false;
            }
        }
    Unlock();

    return enumed;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\usbdevice.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    USBDevice.cpp

Abstract:

    This class defines the core functionality for every "device". All devices
    are children of this object.

    Defined in "USBSimulator.h"

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"


/*****************************************************************************

Routine Description:

    Default Constructor/Destructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
USBDevice::USBDevice()
    {
    simIP = 0;
    usbPort = 0;
    destPort = 0;
    sock = INVALID_SOCKET;
    record = false;
    receiveBuffer = 0;
    bufferSize = 0;
    dataToggle = false;

    timeout.tv_sec = 0;
    timeout.tv_usec = 250000;
    }

USBDevice::~USBDevice()
    {
    // make sure the thread stopped, and wait for it if it hasn't
    DWORD threadTimeout = 500;
    while(SoftBreak(threadTimeout) != TRUE)
        {
        threadTimeout *= 2;
        if(threadTimeout >= 100000)
            {
            // the thread did not respond so do the evil and terminate it
            HardBreak();
            }
        }

    // make sure the user USBSimulator.Unplug()s the device before destroying it
    _ASSERT(sock == INVALID_SOCKET);
    }




/*****************************************************************************

Routine Description:

    recv

    Override Winsock's recv to include logging

Arguments:

    see documentation on 'recv' 

Return Value:

    see documentation on 'recv' 

*****************************************************************************/
int USBDevice::recv(SOCKET s, char *buf, int len, int flags)
    {
    int ret = ::recv(s, buf, len, flags);

    if(record)
        {
        DWORD err = GetLastError();
        if(ret == SOCKET_ERROR) recorder.LogPrint("recv error: %u\r\n", err);
        else recorder.LogPacket(buf, len, (DWORD)this, false);
        SetLastError(err);
        }

    return ret;
    }


/*****************************************************************************

Routine Description:

    send

    Override Winsock's send to include logging

Arguments:

    see documentation on 'send' 

Return Value:

    see documentation on 'send' 

*****************************************************************************/
int USBDevice::send(SOCKET s, char *buf, int len, int flags)
    {
    if(record) recorder.LogPacket(buf, len, (DWORD)this, true);

    return ::send(s, buf, len, flags);
    }


/*****************************************************************************

Routine Description:

    recvfrom

    Override Winsock's recvfrom to include logging

Arguments:

    see documentation on 'recvfrom'

Return Value:

    see documentation on 'recvfrom'

*****************************************************************************/
int USBDevice::recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
    {
    int ret = ::recvfrom(s, buf, len, flags, from, fromlen);

    if(record)
        {
        DWORD err = GetLastError();
        if(ret == SOCKET_ERROR) recorder.LogPrint("recvfrom error: %u\r\n", err);
        else recorder.LogPacket(buf, len, (DWORD)this, false);
        SetLastError(err);
        }

    return ret;
    }


/*****************************************************************************

Routine Description:

    sendto

    Override Winsock's sendto to include logging

Arguments:

    see documentation on 'sendto'

Return Value:

    see documentation on 'sendto'

*****************************************************************************/
int USBDevice::sendto(SOCKET s, char *buf, int len, int flags, struct sockaddr *to, int tolen)
    {
    int ret = ::sendto(s, buf, len, flags, to, tolen);

    if(record)
        {
        DWORD err = GetLastError();
        recorder.LogPacket(buf, len, (DWORD)this, true);
        SetLastError(err);
        }

    return ret;
    }


/*****************************************************************************

Routine Description:

    IsDataAvailable

    Checks to see if there is new data in the receive buffer

Arguments:

    none

Return Value:

    0 or SOCKET_ERROR - no data is available
    1 - data is available to recv

*****************************************************************************/
int USBDevice::IsDataAvailable(void)
    {
    FD_SET bucket;

    bucket.fd_count = 1;
    bucket.fd_array[0] = sock;

    return select(0, &bucket, NULL, NULL, &timeout);
    }


/*****************************************************************************

Routine Description:

    GetPacket

    Looks for a new data in the receive buffer, and reads just enough for 1
    packet.

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:

    If the packet is a usb packet (SIM_CMD_USBDATA) AND its an IN packet, then
    we HAVE to look at the next packet. If the next packet is an ACK then the
    application has already responded to the IN and we DO NOT return it (but
    we do return the ACK). Otherwise (next packet was a NAK) we return the IN 
    and leave the NAK in the receive buffer.

*****************************************************************************/
DWORD USBDevice::GetPacket(void)
    {
    SOCKADDR_IN dest;
    int addressSize = sizeof(SOCKADDR);
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    int err = 0;
    unsigned long size = 0;

    for(unsigned i=0; i<USBSIM_RECV_RETRYS; i++)
        {
        err = IsDataAvailable();
        if(err == SOCKET_ERROR) return USBSIM_ERROR_SOCKET_ERROR;
        else if(err == 1)
            {
            // get the size of the packet
            ioctlsocket(sock, FIONREAD, &size);

            // assert if our receiveBuffer is not big enough!
            _ASSERT(size < bufferSize);

            // read the packet header & data
            addressSize = sizeof(SOCKADDR);
            err = recvfrom(sock, (char*)packet, size, 0, (SOCKADDR*)&dest, &addressSize);
            if(err == 0 || (err == SOCKET_ERROR && WSAGetLastError() != WSAEMSGSIZE)) return USBSIM_ERROR_SOCKET_ERROR;


            // If we get an IN, we need to determin if we have to deal with it
            // or if its already been handled. To do this, we look at the next 
            // packet for a NAK or an ACK.
            if(packet->command == SIM_CMD_USBDATA && packet->data[0] == USB_PID_IN)
                {
                err = IsDataAvailable();
                if(err != 1)
                    {
                    DebugPrint("NO ACK/NAK FOLLOWING IN!\n");
                    // assume we need to respond to it
                    }
                else
                    {
                    // get the size of the packet
                    ioctlsocket(sock, FIONREAD, &size);

                    SimPacket *packet2 = (SimPacket*)(receiveBuffer+sizeof(SimPacketHeader)+packet->dataSize);
                    addressSize = sizeof(SOCKADDR);
                    err = recvfrom(sock, (char*)packet2, size, 0, (SOCKADDR*)&dest, &addressSize);
                    if(!(err == 0 || (err == SOCKET_ERROR && GetLastError() != WSAEMSGSIZE)))
                        {
                        if(packet2->command == SIM_CMD_USBEXTRADATA && packet2->data[0] == USB_PID_ACK)
                            {
                            // eat the IN (its just info - no need to respond to it), return the ack
                            memmove(packet, packet2, sizeof(SimPacketHeader)+packet2->dataSize);
                            }
                        }
                    }
                // otherwise, IN not followed by an ACK, return the IN
                }

            return USBSIM_ERROR_OK;
            }

        if(GetExitFlag()) return USBSIM_ERROR_USER_ABORT;
        }

    return USBSIM_ERROR_TIMEOUT;
    }


/*****************************************************************************

Routine Description:

    WaitForUSBPacket

    Calls GetPacket(), if the returned packet meets the specified requirements 
    we will return that packet, otherwise we will wait around for it.

Arguments:

    int command     [in] packet type (-1 for ignore this filter)
    int subcommand  [in] packet sub type (-1 for ignore this filter)
    int pid         [in] specific value for data[0] (-1 for ignore this filter)

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD USBDevice::WaitForUSBPacket(int command, int subcommand, int pid)
    {
    DWORD err = 0;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;

    for(int i=0; i<USBSIM_RECV_RETRYS; i++)
        {
        if(GetExitFlag()) return USBSIM_ERROR_USER_ABORT;
        err = GetPacket();
        if(err == USBSIM_ERROR_TIMEOUT) continue;
        else if(err != USBSIM_ERROR_OK) return err;

        if(command != -1) if(packet->command != command) continue;
        if(subcommand != -1) if(packet->subcommand != subcommand) continue;
        if(pid != -1) if(usb->pid != pid) continue;
        return USBSIM_ERROR_OK;
        }

    return USBSIM_ERROR_TIMEOUT;
    }


/*****************************************************************************

Routine Description:

    Plug

    Inserts a new device into a "port" on a simulator. Internally we connect
    to the simulator on the proper UDP port, then initialize the device and
    start it's worker thread.

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:

    The device must not be currently attached to any other simulator!

*****************************************************************************/
DWORD USBDevice::Plug(void)
    {
    SOCKADDR_IN dest;

    if(sock != INVALID_SOCKET) return USBSIM_ERROR_CONNECTED;

    if(usbPort < 0 || usbPort > USBSIM_MAX_USBPORTS) return USBSIM_ERROR_INVALID_USB_PORT;

    // connect to the simulator
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == INVALID_SOCKET)
        {
        if(GetLastError() == 10093)
            {
            WSADATA wsaData;
            unsigned short version = MAKEWORD(2, 2);
            WSAStartup(version, &wsaData);
            if((sock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET) return USBSIM_ERROR_CONNECT_FAILED;
            }
        else return USBSIM_ERROR_CONNECT_FAILED;
        }
    dest.sin_family = AF_INET;
    dest.sin_port = htons((unsigned short)(usbPort+SIM_NETPORT_BASE+SIM_NETPORT_CLIENT_OFFSET));
    dest.sin_addr.s_addr = htonl(INADDR_ANY);
    if(bind(sock, (SOCKADDR *)&dest, sizeof(SOCKADDR_IN)) == SOCKET_ERROR) return USBSIM_ERROR_CONNECT_FAILED;

    // initialize settings in the device
    if(record) recorder.LogPrint("Inserted device (%s) on port %d of simulator %u.%u.%u.%u", GetName(), usbPort, ((unsigned char*)&simIP)[0], ((unsigned char*)&simIP)[1], ((unsigned char*)&simIP)[2], ((unsigned char*)&simIP)[3]);

    // send any device specific setup commands
    EndpointConfig(1);

    // Start the USB Thread that listens for commands and responds to them
    Run();

    Sleep(250);

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    Unplug

    This removes the device from the simulator and then signals the device's 
    worker thread to exit.

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD USBDevice::Unplug(void)
    {
    if(sock == INVALID_SOCKET) return USBSIM_ERROR_NOTCONNECTED;

    // tell the thread to shut down
    shutdown(sock, SD_RECEIVE);
    SoftBreak(500);

    if(record) recorder.LogPrint("Removed device (%s) from port %d of simulator %u.%u.%u.%u", GetName(), usbPort, ((unsigned char*)&simIP)[0], ((unsigned char*)&simIP)[1], ((unsigned char*)&simIP)[2], ((unsigned char*)&simIP)[3]);

    return USBSIM_ERROR_OK;
    }

    
/*****************************************************************************

Routine Description:

    SetupEndpoint

    Sends a SIM_SUBCMD_SETUP_ENDPOINT packet with the specified settings for
    a given endpoint number.

Arguments:

    unsigned endpoint   [in] 0-7 specifies which endpoint we are setting
    unsigned type       [in] the type (see enum _SIM_ENDPOINT_SETUP_TYPES)
    unsigned fifoSize   [in] the size (see enum _SIM_ENDPOINT_SETUP_SIZE)
    unsigned autoRepeat [in] auto repeat (see _SIM_ENDPOINT_SETUP_AUTO_REPEAT)

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:

    The enum definitions are in "SimPacket.h"

    See document "621F01" for descriptions of the endpoint settings

*****************************************************************************/
DWORD USBDevice::SetupEndpoint(unsigned endpoint, unsigned type, unsigned fifoSize, unsigned autoRepeat)
    {
    SOCKADDR_IN dest;
    if(sock == INVALID_SOCKET) return USBSIM_ERROR_NOTCONNECTED;

    SimPacketTyped<EndpointSetup> setup;
    setup.header.command = SIM_CMD_SETUP;
    setup.header.subcommand = SIM_SUBCMD_SETUP_ENDPOINT;
    setup.header.param = (unsigned __int8)endpoint;
    setup.header.dataSize = sizeof(EndpointSetup);
    setup.data.fifoSize = (unsigned __int8)fifoSize;
    setup.data.type = (unsigned __int8)type;
    setup.data.autoRepeat = (unsigned __int8)autoRepeat;

    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    sendto(sock, (char*)&setup, sizeof(setup), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    ThreadFunct

    The is the worker thread function for every device. The thread will exit 
    when this function returns.

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:

    See CWorkerThread.h & CWorkerThread.cpp for more information on this
    member function.

*****************************************************************************/
DWORD USBDevice::ThreadFunct(void)
    {
    DWORD error = 0;

    // send the "connect" command
    SimPacketTyped<unsigned __int8[1]> connectCmd = { SIM_CMD_SETUP, SIM_SUBCMD_SETUP_CONNECT, 0, 1, 1 };
    SOCKADDR_IN dest;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    if(sendto(sock, (char*)&connectCmd, sizeof(connectCmd), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
        {
        return USBSIM_ERROR_SEND_FAILURE;
        }

    while(! GetExitFlag())
        {
        // check for available data
        error = GetPacket();
        if(error == USBSIM_ERROR_TIMEOUT) continue;
        else if(error != USBSIM_ERROR_OK) break;

        // Process the data
        Receive();
        }

    // send the "disconnect" command
    SimPacketTyped<unsigned __int8[1]> disconnectCmd = { SIM_CMD_SETUP, SIM_SUBCMD_SETUP_CONNECT, 0, 1, 0 };
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    Sleep(USBSIM_UDP_DELAY);
    sendto(sock, (char*)&disconnectCmd, sizeof(disconnectCmd), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

    // close socket
    shutdown(sock, SD_SEND);
    closesocket(sock);
    sock = INVALID_SOCKET;

    return error;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\UsbSimRec\dukelistener.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	dukelistener.cpp

  Abstract:

	Defines the USB Simulator Recorder functions which talk to USB devices and pass input events
	to the SimMessenger and ScriptWriter

  Author:

	Mabel Santos (t-msanto) 25-May-2001

  Revision History:

*************************************************************************************************/

#include "usbsimrec.h"

DWORD ConnectedDukes = 0;
LARGE_INTEGER Frequency;
XINPUT_GAMEPAD BaseState = {0};
XDEVICE_PREALLOC_TYPE Dukes[] = { { XDEVICE_TYPE_GAMEPAD, NUM_PORTS } };

/*************************************************************************************************

Routine Description:

	InitGamepads
	
	Detects controllers connected at startup.  Calls DukeInsert(), DukeRemove(), SimInit(), 
	SimInsert(), SimRemove(), Script(), and ScriptInsert() to initialize the duke, simulator,
	and script data structures.
	
Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void InitGamepads( void )
{
	DWORD Port;
	
	DebugOutput( "Calling SimInit()\r\n" );

	// Initialize simulator stuff
	SimInit();

	switch( ScriptType )
	{

	case 1:
		DebugOutput( "Calling JScript() constructor\r\n" );
		ScriptFile = new JScript();
		break;

	default:
		DebugOutput( "InitGamepads() Error: Unknown script type\r\n" );
		DebugOutput( "Please specify a valid script type in the .INI file and restart the program\r\n" );
		return;
	
	// Add other script type cases here
	}

	DebugOutput( "Initializing peripheral control software\r\n" );

	// Initialize peripheral control software
	XInitDevices( sizeof( Dukes ) / sizeof( XDEVICE_PREALLOC_TYPE ), Dukes );
	//XInitDevices( 1, Dukes );
	DebugOutput( "Determining which ports have connected controllers\r\n" );

	// Determine which ports have connected controllers
	ConnectedDukes = XGetDevices( XDEVICE_TYPE_GAMEPAD );

	DebugOutput( "Getting performance counter frequency\r\n" );

	// Get the performance counter frequency
	QueryPerformanceFrequency( &Frequency );

	DebugOutput( "Converting frequency to ticks/millisecond\r\n" );

	// Convert frequency from ticks/second to ticks/millisecond
	Frequency.QuadPart /= 1000;

	DebugOutput( "Setting information for each port\r\n" );

	// Set information for each port
	for( Port = 0; Port < NUM_PORTS; ++Port )
	{
		// Is there a controller connected to the port?
		if( 1 << Port & ConnectedDukes )
		{	
			DebugOutput( "Port %u: Found a controller\r\n", Port+1 );

			DebugOutput( "Port %u: Calling DukeInsert()\r\n", Port+1 );
			DukeInsert( Port );

			DebugOutput( "Port %u: Calling SimInsert()\r\n", Port+1 );
			// Pass information along to the simulator
			SimInsert( Port );

			DebugOutput( "Port %u: Calling ScriptInsert()\r\n", Port+1 );
			// Pass information along to the script
			ScriptFile->ScriptInsert( Port );
		}
		else
		{	
			DebugOutput( "Port %u: Did not find a controller\r\n", Port+1 );

			DebugOutput( "Port %u: Calling DukeRemove()\r\n", Port+1 );
			DukeRemove( Port );
			
			DebugOutput( "Port %u: Calling SimRemove()\r\n", Port+1 );
			// Pass information along to the simulator
			SimRemove( Port );
			
			DebugOutput( "Port %u: Don't need to call ScriptRemove()\r\n", Port+1 );
			// We don't need to pass anything to the script if there is
			// no controller connected to the port
		}
	}
}

/*************************************************************************************************

Routine Description:

	DetectChanges

	Detects device insertions and removals and updates list of connected controllers.  Calls 
	HandleChanges to deal with device changes.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void DetectChanges( void )
{
	DWORD Insertions, Removals;
    
	//DebugOutput( "Checking for controller insertions and removals\r\n" );

	// Were there any device changes since the last time we checked?
    if( XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &Insertions, &Removals ) )
    {
		DebugOutput( "Calling HandleChanges\r\n" );
		// Call handler to service the insertion and/or removal
        HandleChanges( Insertions, Removals );

		DebugOutput( "Updating ConnectedDukes\r\n" );
		// Update connected controllers
        ConnectedDukes &= ~Removals;
        ConnectedDukes |= Insertions;
    }
}

/*************************************************************************************************

Routine Description:

	HandleChanges

	Detects device insertions and removals.  Calls DukeInsert(), DukeRemove(), SimInsert(),
	SimRemove(), ScriptInsert(), and ScriptRemove() to create, plug, unplug, and delete the 
	appropriate Duke objects.

Arguments:

	DWORD Insertions	Bit mask of ports into which controllers have been inserted since the
						last time we checked.
	DWORD Removals		Bit mask of ports from which controllers have been removed since the
						last time we checked.

Return Value:

	none

*************************************************************************************************/

void HandleChanges( DWORD Insertions, DWORD Removals )
{
	DWORD Port;
	
	for( Port = 0; Port < NUM_PORTS; ++Port )
    {
		// Close removals
		if( ( 1 << Port & Removals ) && DukeStates[Port].DukeHandle )
        {
			DebugOutput( "Port %u: Controller removed\r\n", Port+1 );

			DebugOutput( "Port %u: Calling ScriptRemove()\r\n", Port+1 );
			// Pass information along to the script
			ScriptFile->ScriptRemove( Port );

			DebugOutput( "Port %u: Calling SimRemove()\r\n", Port+1 );
			// Pass information along to the simulator
			SimRemove( Port );

			DebugOutput( "Port %u: Calling DukeRemove()\r\n", Port+1 );
			DukeRemove( Port );
		}
		// Open insertions
        if( 1 << Port & Insertions )
        {
			DebugOutput( "Port %u: Controller inserted\r\n", Port+1 );

			DebugOutput( "Port %u: Calling DukeInsert()\r\n", Port+1 );
			DukeInsert( Port );

			DebugOutput( "Port %u: Calling SimInsert()\r\n", Port+1 );
			// Pass information along to the simulator
			SimInsert( Port );
			
			DebugOutput( "Port %u: Calling ScriptInsert()\r\n", Port+1 );
			// Pass information along to the script
			ScriptFile->ScriptInsert( Port );
		}
	}
}

/*************************************************************************************************

Routine Description:

	ReadGamepads

	Detects button presses and releases.  Passes controller state and timing information to the 
	simulator and script through SimSetState() and ScriptSetState().

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void ReadGamepads( void )
{
	DWORD Port;

	LARGE_INTEGER NewChange;
	LARGE_INTEGER ElapsedTime;
	
	//DebugOutput( "Checking for button presses and releases\r\n" );

	for( Port = 0; Port < NUM_PORTS; ++Port )
	{
		// Is there a controller connected to the port?
		if( ( 1 << Port & ConnectedDukes ) && DukeStates[Port].DukeHandle )
		{
			//DebugOutput( "Port %u: Found a controller\r\n", Port+1 );

			//DebugOutput( "Port %u: Getting current state\r\n", Port+1 );
			// Get current state
			XInputGetState( DukeStates[Port].DukeHandle, &CurrState );

			//DebugOutput( "Port %u: Comparing current state to last known state\r\n", Port+1 );
			// Is the current state different from the last known state?
			if( memcmp( (void*) &DukeStates[Port].LastState, (void*) &CurrState.Gamepad, 
					sizeof( CurrState.Gamepad ) - sizeof( CurrState.Gamepad.sThumbLX )
					- sizeof( CurrState.Gamepad.sThumbLY ) - sizeof( CurrState.Gamepad.sThumbRX )
					- sizeof( CurrState.Gamepad.sThumbRY ) ) != 0 ||
				abs ( CurrState.Gamepad.sThumbLX - DukeStates[Port].LastState.sThumbLX ) > 
					MaxDrift ||
				abs ( CurrState.Gamepad.sThumbLY - DukeStates[Port].LastState.sThumbLY ) > 
					MaxDrift ||
				abs ( CurrState.Gamepad.sThumbRX - DukeStates[Port].LastState.sThumbRX ) > 
					MaxDrift ||
				abs ( CurrState.Gamepad.sThumbRY - DukeStates[Port].LastState.sThumbRY ) >
					MaxDrift )

			 {
				//DebugOutput( "Port %u: Calculating elapsed time since last state change\r\n", Port+1 );
				// Get current time and calculate elapsed time since last change
				QueryPerformanceCounter( &NewChange );
				ElapsedTime.QuadPart = ( NewChange.QuadPart - DukeStates[Port].LastChange.QuadPart )
					/ Frequency.QuadPart;

				//DebugOutput( "Port %u: Checking if elapsed time is at least one millisecond\r\n", Port+1 );
				// Has at least one millisecond passed since the last state change?
				if( ElapsedTime.QuadPart >= 1 )
				{
					DebugOutput( "Port %u: State has changed\r\n", Port+1 );
				
					DebugOutput( "Port %u: Updating last state change time\r\n", Port+1 );
					// Update last state change time 
					DukeStates[Port].LastChange = NewChange;

					DebugOutput( "Port %u: Updating current state\r\n", Port+1 );
					// Update current state
					DukeStates[Port].LastState = CurrState.Gamepad;

					DebugOutput( "Port %u: Calling SimSetState()\r\n", Port+1 );
					// Pass information along to the simulator
					SimSetState( Port );
					
					DebugOutput( "Port %u: Calling ScriptSetState()\r\n", Port+1 );
					// Pass information along to the script
					ScriptFile->ScriptSetState( Port, ElapsedTime );
				}
			}
		}
	}
}

/*************************************************************************************************

Routine Description:

	DukeInsert

    Opens a handle and updates the appropriate data structures when a controller is inserted.

Arguments:

    DWORD Port			Array index to be used for inserting the Duke.

Return Value: 

	none

*************************************************************************************************/

void DukeInsert( DWORD Port )
{
	DebugOutput( "Port %u: Opening handle\r\n", Port+1 );
	// Open handle
	DukeStates[Port].DukeHandle = XInputOpen( XDEVICE_TYPE_GAMEPAD, Port, XDEVICE_NO_SLOT, NULL );

	if( DukeStates[Port].DukeHandle == NULL )
	{
		DebugOutput( "Port %u: XInputOpen() Error: %u\r\n", Port, GetLastError() );
		DebugOutput( "Port %u: Setting handle to invalid\r\n", Port+1 );
		// Set handle to invalid
		DukeStates[Port].DukeHandle = 0;
	}

	DebugOutput( "Port %u: Setting current state to default state\r\n", Port+1 );
	// Set current state to default state
	DukeStates[Port].LastState = BaseState;
					
	DebugOutput( "Port %u: Setting last state change time to current time\r\n", Port+1 );
	// Set last state change time to current time
	QueryPerformanceCounter( &DukeStates[Port].LastChange );
}

/*************************************************************************************************

Routine Description:

	DukeRemove

    Closes a handle and updates the appropriate data structures when a controller is removed.

Arguments:

    DWORD Port			Array index to be used for removing the Duke.

Return Value: 

	none

*************************************************************************************************/

void DukeRemove( DWORD Port )
{
	if( DukeStates[Port].DukeHandle )
	{
		DebugOutput( "Port %u: Closing handle\r\n", Port+1 );
		// Close handle
		XInputClose( DukeStates[Port].DukeHandle );
	}

	DebugOutput( "Port %u: Setting handle to invalid\r\n", Port+1 );
	// Set handle to invalid
	DukeStates[Port].DukeHandle = 0;

	DebugOutput( "Port %u: Setting current state to default state\r\n", Port+1 );
	// Set current state to default state
	DukeStates[Port].LastState = BaseState;

	DebugOutput( "Port %u: Setting last state change time to current time\r\n", Port+1 );
	// Set last state change time to current time
	QueryPerformanceCounter( &DukeStates[Port].LastChange );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\UsbSimRec\scriptwriter.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	scriptwriter.cpp

  Abstract:

	Defines the USB Simulator Recorder functions which write input events to a JScript file.

  Author:

	Mabel Santos (t-msanto) 25-May-2001

  Revision History:

*************************************************************************************************/

#include "usbsimrec.h"

/*************************************************************************************************

Routine Description:

	Default JScript constructor

	Creates a script object.  Writes statements to declare functions and data structures in the
	script file.

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

JScript::JScript( void )
{
	DebugOutput( "Opening script output file: %s\r\n", FileName );

	// Open script output file in append mode
	OutFile.open( FileName, ios::app );
	// assert( OutFile );
	if( OutFile )
	{
		// Write file name, date and time stamp
		OutFile << "// USB SIMULATOR RECORDER" << endl;
		OutFile << "// Script File: " << FileName << endl;

		char DateBuff[9];
		char TimeBuff[9];
		_strdate(DateBuff);
		_strtime(TimeBuff);
 
		OutFile << "// Created " << DateBuff << " " << TimeBuff << endl;
		OutFile << endl;

		DebugOutput( "Writing declaration statements to script file: %s\r\n", FileName );
		// Write declaration statements to script file

		// Rate for script replay
		OutFile << "var rate = 1;" << endl;

		// InsertDevice function for plugging in Duke
		OutFile << endl;
		OutFile << "function InsertDevice(dev)" << endl;
		OutFile << "{" << endl;
		OutFile << "var retry = 3;" << endl;
		OutFile << "var time;" << endl;
		OutFile << "do  {" << endl;
		OutFile << "    dev.Plug();" << endl;
		OutFile << "    for(time=32; time<1000; time*=2)" << endl;
		OutFile << "        {" << endl;
		OutFile << "        WScript.Sleep(time);" << endl;
		OutFile << "        if(dev.enumerated == true) return true;" << endl;
		OutFile << "        }" << endl;
		OutFile << "        dev.Unplug();" << endl;
		OutFile << "    WScript.Sleep(250);" << endl;
		OutFile << "    --retry;" << endl;
		OutFile << "    } while(retry != 0);" << endl;
		OutFile << "return false;" << endl;
		OutFile << "}" << endl;

		// Declare Dukes array
		OutFile << endl;
		OutFile << "dukes = new Array(" << NUM_PORTS << ");" << endl;

		// Create USB Simulator object
		OutFile << endl;
		OutFile << "var simulator = WScript.CreateObject(\"USBSimulator.Simulator\");" << endl;
		OutFile << "var version = simulator.GetVersion(\"" << SimIp << "\");" << endl;
		OutFile << "var address = simulator.GetMACAddr(\"" << SimIp << "\");" << endl;
		OutFile << "var boards = simulator.GetUSBPorts(\"" << SimIp << "\");" << endl;
		OutFile << "var numboards = (boards&0x01?1:0) + (boards&0x02?1:0) + (boards&0x04?1:0) ";
		OutFile << "+ (boards&0x08?1:0) + (boards&0x10?1:0) + (boards&0x20?1:0) + (boards&0x40?1:0) ";
		OutFile << "+ (boards&0x80?1:0);" << endl;

		OutFile << endl;
		OutFile << "WScript.Echo(\" Version:    \" + version + \"\\n\");" << endl;
		OutFile << "WScript.Echo(\" MAC Addr:   \" + address + \"\\n\");" << endl;
		OutFile << "WScript.Echo(\" USB Boards: \" + numboards + \" (mask: \" + boards + \")\\n\");" << endl;

		DebugOutput( "Closing script output file: %s\r\n", FileName );
	}
	else
	{ 
		DebugPrint( "File %s: Open operation FAILED.\r\n", FileName );
		DebugPrint( "Please check that the hard drive on the recorder Xbox is not full and restart the program.\r\n" );
	}
	// Close output file and flush the output buffer
	OutFile.close();
}

/*************************************************************************************************

Routine Description:

	ScriptInsert

	Writes statements to create and plug in a Duke object in the script file.

Arguments:

	DWORD Port		Array index to be used for inserting the new Duke.

Return Value:

	none

*************************************************************************************************/

void
JScript::ScriptInsert( DWORD Port )
{
	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
	{
		DebugOutput( "Opening script output file: %s\r\n", FileName );
		// Open script output file in append mode
		OutFile.open( FileName, ios::app );
		//assert( OutFile );
		if( OutFile )
		{
			DebugOutput( "Writing insertion statements to script file: %s\r\n", FileName );
			// Write insertion statements to script file
			OutFile << endl;
			OutFile << "dukes[" << Port << "] = WScript.CreateObject(\"USBSimulator.Duke\");" << endl;
			OutFile << "dukes[" << Port << "].port = " << Port + 1 << ";" << endl;
			OutFile << "dukes[" << Port << "].ip = \"" << SimIp << "\";" << endl;
			OutFile << "InsertDevice(dukes[" << Port << "]);" << endl;

			DebugOutput( "Closing script output file: %s\r\n", FileName );
		}
		else
		{ 
			DebugPrint( "File %s: Open operation FAILED.\r\n", FileName );
			DebugPrint( "Please check that the hard drive on the recorder Xbox is not full and restart the program.\r\n" );
		}
		// Close output file and flush the output buffer
		OutFile.close();
	}
}

/*************************************************************************************************

Routine Description:

	ScriptRemove

	Writes statements to unplug, free and disconnect a Duke object in the script file.

Arguments:

	DWORD Port		Array index to be used for removing the Duke.

Return Value:

	none

*************************************************************************************************/

void
JScript::ScriptRemove( DWORD Port )
{
	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
	{
		DebugOutput( "Opening script output file: %s\r\n", FileName );
		// Open script output file in append mode
		OutFile.open( FileName, ios::app );
		//assert( OutFile );

		if( OutFile )
		{
			DebugOutput( "Writing removal statements to script file: %s\r\n", FileName );
			// Write removal statements to script file
			OutFile << endl;
			OutFile << "dukes[" << Port << "].Unplug();" << endl;
			OutFile << "dukes[" << Port << "].Free();" << endl;
			OutFile << "WScript.DisconnectObject(dukes[" << Port << "]);" << endl;

			DebugOutput( "Closing script output file: %s\r\n", FileName );
		}
		else
		{ 
			DebugPrint( "File %s: Open operation FAILED.\r\n", FileName );
			DebugPrint( "Please check that the hard drive on the recorder Xbox is not full and restart the program.\r\n" );
		}
		// Close output file and flush the output buffer
		OutFile.close();
	}
}

/*************************************************************************************************

Routine Description:

	ScriptSetState

	Writes statements to set the Duke button state in the script file.  Uses the controller state
	and timing information obtained in ReadGamepads().

Arguments:

	DWORD Port					Array index to be used for setting the Duke button state.
	LARGE_INTEGER ElapsedTime	Number of milliseconds to sleep before changing state.

Return Value:

	none

*************************************************************************************************/

void
JScript::ScriptSetState( DWORD Port, const LARGE_INTEGER& ElapsedTime ) 						
{
	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
	{
		// Variable to hold string version of elapsed time
		char TimeBuffer[10];
	
		DebugOutput( "Opening script output file: %s\r\n", FileName );
		// Open script output file in append mode
		OutFile.open( FileName, ios::app );
		//assert( OutFile );
		if( OutFile )
		{
			// Convert elapsed time to a string
			sprintf( TimeBuffer, "%I64u", ElapsedTime.QuadPart );
		
			DebugOutput( "Writing controller state statements to script file: %s\r\n", FileName );
			// Write controller state statements to script file
			OutFile << endl;
			OutFile << "WScript.Sleep(" << TimeBuffer << " / rate);" << endl;
			OutFile << "dukes[" << Port << "].SetButtonState( " << CurrState.Gamepad.wButtons << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[0] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[1] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[2] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[3] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[4] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[5] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[6] << ", "
				<< (DWORD) CurrState.Gamepad.bAnalogButtons[7] << ", "
				<< CurrState.Gamepad.sThumbLX << ", " << CurrState.Gamepad.sThumbLY << ", " 
				<< CurrState.Gamepad.sThumbRX << ", " << CurrState.Gamepad.sThumbRY << " );" << endl;

			DebugOutput( "Closing script output file: %s\r\n", FileName );
		}
		else
		{ 
			DebugPrint( "File %s: Open operation FAILED.\r\n", FileName );
			DebugPrint( "Please check that the hard drive on the recorder Xbox is not full and restart the program.\r\n" );
		}
		// Close output file and flush the output buffer
		OutFile.close();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\usbsim.lib\xiddevice.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    XIDDevice.cpp

Abstract:

    USB Device child class that handles XID enumeration and reporting

Author:

    Josh Poley (jpoley)

Revision History:

*****************************************************************************/

#include "..\inc\USBSimulator.h"

static const char* const DeviceName = "XID Device";
const XIDInputReport defaultXIDReport = { 0, sizeof(XIDInputReport), 0, {0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, 0, 0 };


/*****************************************************************************

Routine Description:

    Default Constructor/Destructor

Arguments:

    none

Return Value:

    none

*****************************************************************************/
XIDDevice::XIDDevice()
    {
    dataToggle = true;
    for(unsigned i=0; i<10; i++)
        enumerateState[i] = 0;
    bufferSize = 1024;
    receiveBuffer = new char[bufferSize];

    xidPacketLen = sizeof(XIDInputReport);
    inCapabilitiesLen = sizeof(XIDInputReport);
    outCapabilitiesLen = 6;
    xidDescriptorLen = 8;

    xidPacket = new unsigned __int8[xidPacketLen];
    inCapabilities = new unsigned __int8[inCapabilitiesLen];
    outCapabilities = new unsigned __int8[outCapabilitiesLen];
    xidDescriptor = new unsigned __int8[xidDescriptorLen];

    memcpy(deviceDescriptor, "\x12\x01\x10\x01\x00\x00\x00\x40", 8);
    memcpy(configurationDescriptor, "\x09\x02\x20\x00\x01\x01\x00\x80\x00\x09\x04\x00\x00\x02\x58\x00\x00\x00\x07\x05\x82\x03\x20\x00\x04\x07\x05\x03\x03\x20\x00\x04", 32);

    memcpy(xidPacket, &defaultXIDReport, xidPacketLen);
    memcpy(inCapabilities, "\x00\x14\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\xff\x00\xff\x00\xff\x00\xff", inCapabilitiesLen);
    memcpy(outCapabilities, "\x00\x06\xFF\xFF\xFF\xFF", outCapabilitiesLen);
    memcpy(xidDescriptor, "\x08\x42\x00\x01\x01\x01\x14\x06", xidDescriptorLen);
    }
XIDDevice::~XIDDevice()
    {
    delete[] receiveBuffer;
    }


/*****************************************************************************

Routine Description:

    GetName

    Returns a textual description of this device, used for logging

Arguments:

    none

Return Value:

    char*   ptr to a global string

*****************************************************************************/
const char* XIDDevice::GetName(void)
    {
    return DeviceName;
    }


/*****************************************************************************

Routine Description:

    EndpointConfig

    Configures up the Endpoint settings on the simulator

Arguments:

    config      0 - disable
                1 - normal state
                2 - repeat state
                

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

*****************************************************************************/
DWORD XIDDevice::EndpointConfig(unsigned config)
    {
    DWORD error = USBSIM_ERROR_OK;
    unsigned i;

    if(record) recorder.LogPrint("Configuring endpoints.");
    switch(config)
        {
        case 0:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_DISABLED, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 1:
            dataToggle = true;
            for(i=0; i<10; i++)
                enumerateState[i] = 0;
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_NOISOC, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_DISABLED);
                }
            break;
        case 2:
            error = SetupEndpoint(0, SIM_ENDPOINT_SETUP_TYPE_CONTROL, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
            for(i=1; i<3; i++)
                {
		        Sleep(USBSIM_UDP_DELAY);
                error = SetupEndpoint(i, SIM_ENDPOINT_SETUP_TYPE_NOISOC, SIM_ENDPOINT_SETUP_SIZE_NOISOC64, SIM_ENDPOINT_SETUP_AUTO_ENABLED);
                }
            break;
        default: 
            break;
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    Receive

    Handles all incomming packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD XIDDevice::Receive(void)
    {
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;

    // USB request
    if(packet->command == SIM_CMD_USBDATA)
        {
        if(usb->pid == USB_PID_SETUP) return HandleSETUP();
        else if(usb->pid == USB_PID_OUT) return HandleOUT();
        else if(usb->pid == USB_PID_IN) return HandleIN();
        else
            {
            //DebugPrint("Unexpected USB packet:\n");
            //PrintPacket(packet);
            }
        }
    else if(packet->command == SIM_CMD_USBEXTRADATA)
        {
        if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_ACKNAK)
            {
            if(usb->pid == USB_PID_NAK)
                {
                DebugPrint("DETECTED MISSING IN - Responding to the NAK\n");
                return HandleIN();
                }

            return USBSIM_ERROR_OK;
            }
        else if(packet->subcommand == SIM_SUBCMD_USBEXTRADATA_RESET)
            {
            Lock();
            for(unsigned i=0; i<5; i++)
                {
                enumerateState[i] = 0;
                }
            Unlock();

            DebugPrint("Reset packet:\n");
            PrintPacket(packet);
            }
        else
            {
            DebugPrint("Reset packet:\n");
            PrintPacket(packet);
            }
        }

    // other packets
    else
        {
        DebugPrint("Unexpected packet:\n");
        PrintPacket(packet);
        }

    return USBSIM_ERROR_OK;
    }


/*****************************************************************************

Routine Description:

    HandleSETUP

    Handles all USB SETUP packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD XIDDevice::HandleSETUP(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    USBPacket *usb = (USBPacket*)packet->data;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;
    bool notdone;

    error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_DATA0);
    if(error != USBSIM_ERROR_OK) return error;

    //
    // Get Device Descriptor
    //
    if(memcmp(usb->data, "\x80\x06\x00\x01\x00\x00\x08\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 9;
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, deviceDescriptor, packet->dataSize-1);
            ++enumerateState[0];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Set Address
    //
    else if(memcmp(usb->data, "\x00\x05", 2) == 0 && memcmp(usb->data+3, "\x00\x00\x00\x00\x00", 5) == 0)
        {
        unsigned char addr = usb->data[2];
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

            packet->command = SIM_CMD_SETUP;
            packet->subcommand = SIM_SUBCMD_SETUP_USBADDRESS;
            packet->dataSize = 1;
            packet->data[0] = addr;
            Lock();
            ++enumerateState[1];
            Unlock();
            Sleep(USBSIM_UDP_DELAY);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Get Configuration Descriptor
    //
    else if(memcmp(usb->data, "\x80\x06\x00\x02\x00\x00", 6) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 33;
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, configurationDescriptor, packet->dataSize-1);
            ++enumerateState[2];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }

    //
    // Set Configuration
    //
    else if(memcmp(usb->data, "\x00\x09\x01\x00\x00\x00\x00\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = 1;
            memcpy(packet->data, "\xD2", packet->dataSize);
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            Lock();
            ++enumerateState[3];
            Unlock();
            }
        }

    //
    // XID Descriptor
    //
    else if(memcmp(usb->data, "\xC1\x06\x00\x42\x00\x00\x10\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = (unsigned __int16)(xidDescriptorLen + 1);
            packet->data[0] = 0xD2;
            Lock();
            memcpy(packet->data+1, xidDescriptor, packet->dataSize-1);
            ++enumerateState[4];
            Unlock();
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }


    //
    // XID Capabilities
    //
    else if(memcmp(usb->data, "\xC1\x01\x00", 3) == 0)
        {
        unsigned char capsize = usb->data[6];
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            packet->command = SIM_CMD_USBDATA;
            packet->subcommand = SIM_SUBCMD_USBDATA;
            packet->dataSize = (unsigned __int16)(capsize + 1);
            packet->data[0] = 0xD2;
            if(capsize == 0x06) // get capabilities for the motors
                {
                Lock();
                memcpy(packet->data+1, outCapabilities, packet->dataSize-1);
                Unlock();
                }
            else if(capsize == 0x14) // button report
                {
                Lock();
                memcpy(packet->data+1, inCapabilities, packet->dataSize-1);
                Unlock();
                }
            else
                {
                DebugPrint("Unexpected SETUP/DATA0 packet (XID Capabilities):\n");
                PrintPacket(packet);
                }
            sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
            }
        }


    //
    // 
    //
    else if(memcmp(usb->data, "\xA1\x01\x00\x01\x00\x00\x14\x00", 8) == 0)
        {
        error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
        if(error == USBSIM_ERROR_OK)
            {
            dataToggle = false;
            HandleIN();
            }
        }

    //
    // Unknown SETUP/DATA0 packet
    //
    else
        {
        DebugPrint("Unexpected SETUP/DATA0 packet:\n");
        PrintPacket(packet);
		
        notdone = true;
        while(notdone == true)
            {
            error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, USB_PID_IN);
            if(error == USBSIM_ERROR_OK)
                {
                if(packet->param != 0)
                    {	// its not control pipe IN
                    HandleIN();
                    }
                else
                    {	// its on the control endpoint, handle it
                    packet->command = SIM_CMD_USBDATA;
                    packet->subcommand = SIM_SUBCMD_USBDATA;
                    packet->dataSize = 1;
                    memcpy(packet->data, "\xD2", packet->dataSize);
                    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));
                    notdone = false;
                    }
                }
            }
        }

    return error;
    }


/*****************************************************************************

Routine Description:

    HandleOUT

    Handles all USB OUT packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD XIDDevice::HandleOUT(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    //SimPacket *packet = (SimPacket*)receiveBuffer;

    //error = WaitForUSBPacket(SIM_CMD_USBDATA, SIM_SUBCMD_USBDATA, -1);
    //if(error != USBSIM_ERROR_OK) return error;

    //DebugPrint("Unexpected OUT packet:\n");
    //PrintPacket(packet);

    return error;
    }


/*****************************************************************************

Routine Description:

    HandleIN

    Handles all USB IN packets

Arguments:

    none

Return Value:

    DWORD   USBSIM error code (see "USBSimulator.h")

Notes:


*****************************************************************************/
DWORD XIDDevice::HandleIN(void)
    {
    DWORD error = USBSIM_ERROR_OK;
    SOCKADDR_IN dest;
    SimPacket *packet = (SimPacket*)receiveBuffer;
    dest.sin_family = AF_INET;
    dest.sin_port = destPort;
    dest.sin_addr.s_addr = simIP;

    packet->command = SIM_CMD_USBDATA;
    packet->subcommand = SIM_SUBCMD_USBDATA;
    packet->dataSize = (unsigned __int16)(xidPacketLen + 1);

    Lock();
    memcpy(packet->data+1, xidPacket, xidPacketLen);
    Unlock();

    packet->data[0] = (unsigned char)(dataToggle ? USB_PID_DATA0 : USB_PID_DATA1);
    dataToggle = !dataToggle;
    Sleep(USBSIM_UDP_DELAY);
    sendto(sock, (char*)packet, packet->dataSize+sizeof(SimPacketHeader), 0, (SOCKADDR*)&dest, sizeof(SOCKADDR_IN));

    return error;
    }


/*****************************************************************************

Routine Description:


Arguments:


Return Value:


Notes:


*****************************************************************************/
DWORD XIDDevice::SetInputReport(XIDInputReport *xid)
    {
    Lock();
    if(xid)
        memcpy(xidPacket, xid, sizeof(XIDInputReport));
    else
        memcpy(xidPacket, &defaultXIDReport, sizeof(XIDInputReport));
    Unlock();

    return 0;
    }
DWORD XIDDevice::SetInputReport(unsigned __int8  reportID, unsigned __int8  size, unsigned __int16 buttons, unsigned __int8 *analogButtons, unsigned __int16 thumbLX, unsigned __int16 thumbLY, unsigned __int16 thumbRX, unsigned __int16 thumbRY)
    {
    XIDInputReport report = { reportID, size, buttons, {0, 0, 0, 0, 0, 0, 0, 0}, thumbLX, thumbLY, thumbRX, thumbRY };

    for(unsigned i=0; i<8; i++)
        report.analogButtons[i] = analogButtons[i];

    return SetInputReport(&report);
    }


/*****************************************************************************

Routine Description:


Arguments:


Return Value:


Notes:


*****************************************************************************/
bool XIDDevice::IsEnumerated(void)
    {
    Lock();
    bool enumed = true;
    for(unsigned i=0; i<5; i++)
        {
        if(enumerateState[i] == 0)
            {
            enumed = false;
            }
        }
    Unlock();

    return enumed;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\UsbSimRec\simmessenger.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	simmessenger.cpp

  Abstract:

	Defines the USB Simulator Recorder functions which send input events to a USB Simulator.

  Author:

	Mabel Santos (t-msanto) 25-May-2001

  Revision History:

*************************************************************************************************/

#include "usbsimrec.h"

SIM_INFO SimDukes[NUM_PORTS];

/*************************************************************************************************

Routine Description:

	SimInit

	Finds connected simulators.  Attaches to a specific simulator and gets information from it.

Arguments:
	
	None

Return Value:

	None
	
*************************************************************************************************/

void SimInit( void )
{
	unsigned NumSimulators;
	SimPacketTyped<unsigned char [128]> SimData;

	DebugOutput( "Looking for simulators\r\n");
	// Are there any simulators connected?
	NumSimulators = UsbSim->FindSimulators();

	DebugOutput( "Finding simulator: %s\r\n", SimIp );
	// Point to the simulator specified in INI file
	UsbSim->ip[0] = inet_addr( SimIp );
	
	// Check if we can talk to the specified simulator
	memset(&SimData, 0, sizeof(SimData));
	UsbSim->SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_VERSION, SimData);
	SimData.data[SimData.header.dataSize] = '\0';
	
	// Keep looping until the specified simulator is found
	while( NumSimulators == 0 || SimData.header.dataSize == 0 || SimData.data[0] == '\0' )
	{
		DebugPrint( "Did NOT find simulator: %s. Trying again...\r\n", SimIp );
		Sleep( 500 );
		NumSimulators = UsbSim->FindSimulators();
		UsbSim->ip[0] = inet_addr( SimIp );
		memset(&SimData, 0, sizeof(SimData));
		UsbSim->SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_VERSION, SimData);
		SimData.data[SimData.header.dataSize] = '\0';
	}

	// Reaching here means we were able to get the simulator version
	DebugOutput( "Found simulator: %s\r\n", SimIp );
	
	// Display the version and MAC address of the simulator
    DebugOutput("Sim Version: %s\r\n", SimData.data);

    memset(&SimData, 0, sizeof(SimData));
    UsbSim->SendCommand(0, SIM_CMD_STATUS, SIM_SUBCMD_STATUS_MACADDR, SimData);
    DebugOutput("Sim MAC Addr: %02X %02X %02X %02X %02X %02X\r\n", SimData.data[0], SimData.data[1], SimData.data[2], SimData.data[3], SimData.data[4], SimData.data[5]);
  }

/*************************************************************************************************

Routine Description:

	SimInsert

	Creates a new Duke device.  Calls SimPlug() to plug in the Duke and get it enumerated.

Arguments:

	DWORD Port		Array index to be used for inserting the new Duke.

Return Value:

	none

*************************************************************************************************/

void SimInsert( DWORD Port )
{
	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
	{
		DebugOutput( "Port %u: Creating new Duke device\r\n", Port+1 );
		// Create new Duke device
		SimDukes[Port].DukeDevice = new XIDDevice;
	
		DebugOutput( "Port %u: Setting XID report to default value\r\n", Port+1 );
		// Set XID report to default value
		SimDukes[Port].XidPacket = defaultXIDReport;

		DebugOutput( "Port %u: Calling SimPlug()\r\n", Port+1 );
		// Wait for Duke to get enumerated
		SimPlug( Port );
	}
}

/*************************************************************************************************

Routine Description:

	SimPlug

	Loops around, plugging in a new Duke and waiting for it to get enumerated.  If enumeration 
	does not succeed after 3 attempts, asks the user to unplug the controller and plug it back in.

Arguments:

	DWORD Port		Array index to be used for plugging in the new Duke.

Return Value:

	none

*************************************************************************************************/

void SimPlug( DWORD Port )
{
	DWORD Result;
	DWORD Retry;
	DWORD Timer;

	// Try a maximum of 3 times to get Duke enumerated
	for( Retry = 3; Retry > 0; Retry-- )
	{
		DebugOutput( "Port %u: Plugging in Duke\r\n", Port+1 );
		// Plug in the Duke
		Result = UsbSim->Plug( Port + 1, 0, SimDukes[Port].DukeDevice );
		_ASSERT(Result == USBSIM_ERROR_OK);
		
		// Wait for enumeration to happen
		for( Timer = 0; Timer < 3000; Timer += 250 )
		{
			Sleep( 250 );
			if( SimDukes[Port].DukeDevice->IsEnumerated() )
			{
				DebugOutput( "Port %u: Duke enumerated\r\n", Port+1 );
				return;
			}
		}

		// Reaching here means we need to try again
		DebugOutput( "Port %u: Duke NOT enumerated. Trying again...\r\n", Port+1 );
		
		DebugOutput( "Port %u: Unplugging Duke\r\n", Port+1 );
		// Unplug the Duke
		Result = UsbSim->Unplug( SimDukes[Port].DukeDevice );
		_ASSERT(Result == USBSIM_ERROR_OK);
	}

	// Reaching here means we must ask the user to unplug the Duke and plug it back in
	DebugPrint( "Port %u: Duke enumeration FAILED.\r\n", Port+1 );
	DebugPrint( "Please unplug the controller and plug it back in.\r\n", Port+1 );
	Sleep(5000);
}

/*************************************************************************************************

Routine Description:

	SimRemove

	Unplugs a Duke device and deletes it.

Arguments:

	DWORD Port		Array index to be used for removing the Duke.

Return Value:

	none

*************************************************************************************************/

void SimRemove( DWORD Port )
{
	DWORD Result;

	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
    {
		DebugOutput( "Port %u: Unplugging Duke\r\n", Port+1 );
		// Unplug the Duke
		Result = UsbSim->Unplug( SimDukes[Port].DukeDevice );
		_ASSERT(Result == USBSIM_ERROR_OK);

		DebugOutput( "Port %u: Deleting Duke device\r\n", Port+1 );
		// Delete Duke device
		delete SimDukes[Port].DukeDevice;
	}

	DebugOutput( "Port %u: Setting Duke device pointer to null\r\n", Port+1 );
	// Set DukeDevice pointer to null
	SimDukes[Port].DukeDevice = NULL;

	DebugOutput( "Port %u: Setting XID report to default value\r\n", Port+1 );
	// Set XID report to default value
	SimDukes[Port].XidPacket = defaultXIDReport;
}

/*************************************************************************************************

Routine Description:

	SimSetState

	Uses the controller state obtained in ReadGamepads() to simulate button presses and releases.


Arguments:

	DWORD Port		Array index to be used for simulating Duke button presses and releases.

Return Value:

	none

*************************************************************************************************/

void SimSetState( DWORD Port )
{
	// Is there a controller plugged into the port?
	if( DukeStates[Port].DukeHandle )
	{
		DebugOutput( "Port %u: Copying current state of controller\r\n", Port+1 );
		// Copy current state of controller
		memcpy( (void*) &(SimDukes[Port].XidPacket.buttons), (void*) &CurrState.Gamepad,
			sizeof( CurrState.Gamepad ) );

		DebugOutput( "Port %u: Sending new controller state\r\n", Port+1 );
		// Send new controller state
		SimDukes[Port].XidPacket.size = sizeof(XIDInputReport);
		SimDukes[Port].DukeDevice->SetInputReport( &SimDukes[Port].XidPacket );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\UsbSimRec\usbsimrec.cpp ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	usbsimrec.cpp

  Abstract:

	Defines the USB Simulator Recorder functions which allow real time USB interaction and
	logging for future playback.

  Author:

	Mabel Santos (t-msanto) 25-May-2001

  Revision History:

*************************************************************************************************/

#include "usbsimrec.h"

DWORD DebugOn;
LONG MaxDrift;
DWORD ScriptType;
const DWORD BuffLen = 1024;
char *SimIp = new char[BuffLen];
char *FileName = new char[BuffLen];
STATE_INFO DukeStates[NUM_PORTS];
XINPUT_STATE CurrState;
USBSimulator *UsbSim;
Script *ScriptFile;

/*************************************************************************************************

Routine Description:

	StringTrim

	Extracts a value from a line in the testini.ini file.  Trims off spaces, tabs, and comments.

Arguments:

	char *String				String to be trimmed.

Return Value:

	none

*************************************************************************************************/

void StringTrim( char *String )
{
	DWORD Pos;

	// Find the first occurrence of a whitespace character
	Pos = strcspn( String, " \t" );

	// Set first whitespace character and all trailing characters to NULL
	memset( &String[Pos], '\0', BuffLen - Pos );
}

/*************************************************************************************************

Routine Description:

	DebugOutput
 
	Displays debug output statements when the DebugOn flag is set.

Arguments:

	LPTSTR ptszFormat,...		Format string to be displayed.

Return Value:

	none

*************************************************************************************************/

void DebugOutput( char *ptszFormat, ...)
{
	// Is the DebugOn flag set?
	if( DebugOn )
	{
		char tszBuf[MAX_PATH*2];
		va_list arglist;

	    va_start( arglist, ptszFormat );
		_vsnprintf( tszBuf, sizeof(tszBuf), ptszFormat, arglist );
		OutputDebugStringA( tszBuf );
		va_end(arglist);
	}
}

/*************************************************************************************************

Routine Description:

	main function

Arguments:

	none

Return Value:

	none

*************************************************************************************************/

void __cdecl main( void )
{
	XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    int nXnetResult = XNetStartup( &xnsp );
    if(nXnetResult != NO_ERROR)
    {
		DebugOutput("XNetStartup() Error: %u\n", nXnetResult);
    }
	// Sleep for 5 secs because sockets are not fully initialized immediately after call to
	// XNetStartup()
    Sleep(5000);

	UsbSim = new USBSimulator;

	DebugOutput( "Getting INI file settings\r\n" );
    // Get INI file settings

	// Default value for DebugOn = 0
	DebugOn = GetProfileIntA( "Settings", "DebugOn", 0 );
	if( DebugOn < 0 || DebugOn > 1 ) { DebugOn = 0; }

	// Default value for MaxDrift = 5000
	MaxDrift = GetProfileIntA( "Settings", "MaxDrift", 5000 );
	if( MaxDrift < 5000 ) { MaxDrift = 5000; }

	// Default value for ScriptType = 1 (JScript)
	ScriptType = GetProfileIntA( "Settings", "ScriptType", 1 );
	if( ScriptType != 1 ) { ScriptType = 1; }

	// Default value for SimIp = "0.0.0.0" 
	GetProfileStringA( "Settings", "SimIp", "0.0.0.0", SimIp, BuffLen );
	StringTrim( SimIp );	

	// Default value for FileName = "U:\script.js"
	GetProfileStringA( "Settings", "FileName", "U:\\script.js", FileName, BuffLen );
	StringTrim( FileName );
	if( ( memcmp( (void*) FileName, "U:\\", 3 ) != 0 ) && 
		( memcmp( (void*) FileName, "T:\\", 3 ) != 0 ) ) { FileName = "U:\\script.js"; }

	//DebugOutput( "Calling InitGamepads()\r\n" );
	InitGamepads();

	while( TRUE )
	{
		//DebugOutput( "Calling DetectChanges()\r\n" );
		DetectChanges();
		//DebugOutput( "Calling ReadGamepads()\r\n" );
		ReadGamepads();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\AnsiBstr.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    AnsiBstr.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*****************************************************************************/

#ifndef _ANSIBSTR_H_
#define _ANSIBSTR_H_

class AnsiBstr
    {
    public:
        PCHAR astr;
        BSTR bstr;

    public:
        AnsiBstr();
        AnsiBstr(BSTR b);
        AnsiBstr(PCHAR a);

        void SetStr(BSTR b);
        void SetStr(PCHAR a);

        operator PCHAR(void) const { return astr; }
        operator BSTR(void) const { return bstr; }


        ~AnsiBstr();
    };

extern PCHAR CreateAnsiFromBstr(BSTR bstr);
extern BSTR CreateBstrFromAnsi(const char *pszText);
extern BSTR CreateBstrFromAnsi(const char *pszText, size_t length);
extern char* Unicode2AnsiHack(unsigned short *str);
extern char* Ansi2UnicodeHack(char *str);
extern char* Ansi2UnicodeHack(char *str, size_t length);

#endif // _ANSIBSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\IncLib\USBXBDriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    USBXBDriver.h

Abstract:

    header of exposed routines from the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __slixdriver_h__
#define __slixdriver_h__

#define _IN
#define _OUT
#define _OPT


typedef long USBD_STATUS;
typedef unsigned char       BYTE;
typedef unsigned long		DWORD;

#ifdef __cplusplus
extern "C" { //to prevent name mangling... 
#endif

/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE Port,_IN BYTE Slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len);


/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE Port,_IN BYTE Slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _IN char * data, _IN DWORD len);


/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received.  OPT if data[6] == 0
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE Port,_IN BYTE Slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _OPT _IN _OUT USHORT *len2);


USBD_STATUS SlixdReset(_IN BYTE Port,_IN BYTE Slot, _IN BYTE InterfaceNumber);



#ifdef __cplusplus
} //extern "C"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\IncLib\USBXBtransfer.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usbxtransfer.h

Abstract:

    a shared header for usbxcom and xboxserver, including networking protocols

Author:

    Jason Gould (a-jasgou) June 2000
	Dennis Krueger <a-denkru> November 2001

--*/
#ifndef __usbxtransfer_h_
#define __usbxtransfer_h_

#define __TRANSFER_BASE struct{unsigned long size; BYTE type;} 

typedef __TRANSFER_BASE TRANSFER_BASE;					//base structure for all sends

#pragma warning(push)
#pragma warning(disable:4200)	//since we're using 0-length arrays... kill the warning

typedef struct 
{
	BYTE bPort;
	BYTE bSlot;
	BYTE bInterfaceNumber;
} Topology;

typedef struct : TRANSFER_BASE{	//box->2k IN data
	BYTE ret;
	char data[0];	
} TRANSFER_IN;					

typedef struct : TRANSFER_BASE{ //2k->box OUT data
	BYTE Port;
	BYTE Slot;
	BYTE interfacenumber;
	BYTE endpoint;
	BYTE dataPid;
	char data[0];
} TRANSFER_OUT;

typedef struct : TRANSFER_BASE{	//2k->box SETUP data
	BYTE Port;
	BYTE Slot;
	BYTE interfacenumber;
	BYTE endpoint;
	char data[0];
} TRANSFER_SETUP;

typedef struct : TRANSFER_BASE{	//2k->box DataToggle messages
	BYTE endpoint;
} TRANSFER_DATA_TOGGLE;

typedef struct : TRANSFER_BASE{	//2k->box DataToggle messages
	ULONG ulTimeoutValue;
} TRANSFER_USB_TIMEOUT;

typedef struct : TRANSFER_BASE{
	BYTE bDeviceCount;
	Topology TopArray[0];
} TRANSFER_DEVICE_STATE;

typedef struct : TRANSFER_BASE{	//box->2k result of OUT or SETUP
	BYTE ret;
} TRANSFER_RETURN;

typedef struct : TRANSFER_BASE{	//2k->box request for IN
	BYTE Port;
	BYTE Slot;
	BYTE interfacenumber;
	BYTE endpoint;
	DWORD max;
} TRANSFER_INIT_IN;

typedef struct : TRANSFER_RETURN{
	DWORD linefailed;
} TRANSFER_RETURN_END_QUEUE;

typedef struct : TRANSFER_BASE{
	BYTE successonnak;
} TRANSFER_BEGIN_QUEUE;

typedef struct : TRANSFER_BASE{
} TRANSFER_INIT_END_QUEUE;

typedef struct : TRANSFER_BASE{
} TRANSFER_REFRESH_CONFIG;

typedef struct : TRANSFER_BASE{
	BYTE Port;
	BYTE Slot;
	BYTE interfacenumber;
} TRANSFER_RESET;

#pragma warning(pop)

typedef union ussTransferData{	//all possible data & transfer types
	__TRANSFER_BASE;
	TRANSFER_INIT_IN initin;
	TRANSFER_IN in;
	TRANSFER_OUT out;
	TRANSFER_SETUP setup;
	TRANSFER_DATA_TOGGLE toggle;
	TRANSFER_RETURN ret;
	TRANSFER_RESET reset;
	TRANSFER_RETURN_END_QUEUE retendqueue;
	TRANSFER_INIT_END_QUEUE initendqueue;
	TRANSFER_BEGIN_QUEUE beginqueue;
	TRANSFER_USB_TIMEOUT UsbTimeout;
	TRANSFER_DEVICE_STATE DeviceState;
	char all[1032];
} TRANSFERDATA, *pTRANSFERDATA;

#define RECV_TIMEOUT				10000

#define PID_OUT						0x01
#define PID_IN						0x69
#define PID_SETUP					0x2D
#define PID_DATA0					0xC3
#define PID_DATA1					0x4B

//these aren't PID codes, but they are being used in the same way, in my code, 
//as the 5 codes above. They are just arbitrary numbers...
#define PID_GET_DEVICE_STATE		0xD8
#define PID_SET_USB_TIMEOUT			0xD9
#define PID_RET						0xDA	
#define PID_INIT_IN					0xDB 
#define PID_RESET					0xDC
#define PID_BEGIN_QUEUE				0xDD
#define PID_INIT_END_QUEUE			0xDE
#define PID_RETURN_END_QUEUE		0xDF

const BYTE XSTATUS_Success            = 0x00;
const BYTE XSTATUS_Ack                = 0x02;
const BYTE XSTATUS_Nak                = 0x0A;
const BYTE XSTATUS_Stall              = 0x0E;
const BYTE XSTATUS_Ignore             = 0x80;
const BYTE XSTATUS_DataCRCError       = 0x81;
const BYTE XSTATUS_DataToggleError    = 0x82;
const BYTE XSTATUS_SyncError          = 0x83;
const BYTE XSTATUS_BabbleError        = 0x84;
const BYTE XSTATUS_PIDError           = 0x85;
const BYTE XSTATUS_ShortPacketError   = 0x86;
const BYTE XSTATUS_ConfigurationError = 0x87;
const BYTE XSTATUS_TransmissionError  = 0x92;	//this is new, as of 6/21/2000
const BYTE XSTATUS_UserError          = 0x95;	//new, as of 8-28-2000


//Macro to fill in a TRANSFER_IN_INIT packet to send from Slix2k to Slixbox
#define CREATE_BEGIN_QUEUE(_sockdata, _SuccessOnNak)					\
	_sockdata.size = sizeof(TRANSFER_BEGIN_QUEUE);		\
	_sockdata.type = PID_BEGIN_QUEUE;					\
	_sockdata.beginqueue.successonnak = (BYTE)_SuccessOnNak;

#define CREATE_INIT_END_QUEUE(_sockdata)					\
	_sockdata.size = sizeof(TRANSFER_INIT_END_QUEUE);		\
	_sockdata.type = PID_INIT_END_QUEUE;				

#define CREATE_ININIT(_sockdata, _Port,_Slot, _interfacenumber, _endpoint, _maxsize)	\
	_sockdata.size = sizeof(TRANSFER_INIT_IN);				\
	_sockdata.type = PID_INIT_IN;							\
	_sockdata.initin.Port = _Port;							\
	_sockdata.initin.Slot = _Slot;							\
	_sockdata.initin.interfacenumber = _interfacenumber;	\
	_sockdata.initin.max = _maxsize;						\
	_sockdata.initin.endpoint = _endpoint;

//Macro to fill in a TRANSFER_OUT packet to send from Slix2k to Slixbox
#define CREATE_OUT(_sockdata, _Port,_Slot, _interfacenumber, _endpoint, _pid, _data, _size)	\
	_sockdata.size = sizeof(TRANSFER_OUT) + _size;						\
	_sockdata.type = PID_OUT;											\
	_sockdata.out.Port = _Port;											\
	_sockdata.out.Slot = _Slot;											\
	_sockdata.out.interfacenumber = _interfacenumber;					\
	_sockdata.out.endpoint = _endpoint;									\
	_sockdata.out.dataPid = _pid;										\
	{int _arf; for(_arf = 0; _arf < _size; _arf++) sockdata.out.data[_arf] = _data[_arf];}	

//Macro to fill in a TRANSFER_SETUP packet to send from Slix2k to Slixbox
#define CREATE_SETUP(_sockdata, _Port,_Slot, _interfacenumber, _endpoint, _data, _size)		\
	_sockdata.size = sizeof(TRANSFER_SETUP) + _size;					\
	_sockdata.type = PID_SETUP;											\
	_sockdata.setup.Port = _Port;										\
	_sockdata.setup.Slot = _Slot;										\
	_sockdata.setup.interfacenumber = _interfacenumber;					\
	_sockdata.setup.endpoint = _endpoint;								\
	{int _arf; for(_arf = 0; _arf < _size; _arf++) sockdata.setup.data[_arf] = _data[_arf]; }

//#include "\MyAssert.h"	//definition of MyAssert, & its support features
#define PID_OUT                    0x01
#define PID_IN                     0x69
#define PID_SETUP                  0x2D
#define PID_DATA0			       0xC3
#define PID_DATA1			       0x4B

const BYTE STATUS_Success            = 0x00;
const BYTE STATUS_Ack                = 0x02;
const BYTE STATUS_Nak                = 0x0A;
const BYTE STATUS_Stall              = 0x0E;
const BYTE STATUS_Ignore             = 0x80;
const BYTE STATUS_DataCRCError       = 0x81;
const BYTE STATUS_DataToggleError    = 0x82;
const BYTE STATUS_SyncError          = 0x83;
const BYTE STATUS_BabbleError        = 0x84;
const BYTE STATUS_PIDError           = 0x85;
const BYTE STATUS_ShortPacketError   = 0x86;
const BYTE STATUS_ConfigurationError = 0x87;
const BYTE STATUS_TransmissionError	 = 0x89;

#define MAX_PORTS 8					    //max num of ports on the xbox (currently 5)
#define MAX_SLOTS 4						//max num of slots on a duke, plus 1 (currently 3)
#define MAX_INTERFACES 4				// max num of interfaces (currently 2 on Hawk)
#define XPortNumber		53331
#define XBoxEventsPortNumber 53335


class CXBoxTopology
{
public:
	BYTE m_bPort;
	BYTE m_bSlot;
	BYTE m_bInterfaceNumber;
};

// added support for event handling separate from main packet processing
class CEventPacket
{
public:
	int		m_iEventCode;  
	CXBoxTopology m_Topology;
	ULONG	m_ulErrorCode;
};

typedef enum {
	eInsertionEvent = 3,
	eRemovalEvent
} EVENTTYPES;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\usbsim\UsbSimRec\usbsimrec.h ===
/*************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

	usbsimrec.h

  Abstract:

	Defines the USB Simulator Recorder data structures and function prototypes.

  Author:

	Mabel Santos (t-msanto) 25-May-2001

  Revision History:

*************************************************************************************************/


#ifndef _USBSIMREC_
#define _USBSIMREC_

#include <xtl.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <conio.h>
#include <iostream>
#include <fstream.h>
#include <assert.h>


#include "..\inc\usbsimulator.h"
#include "..\..\..\inc\profilep.h"

#define NUM_PORTS XGetPortCount()  // Number of controller ports on an Xbox


// INI FILE STUFF

// Flag to indicate debug mode
extern DWORD DebugOn;

// Threshold for thumbstick drift
extern LONG MaxDrift;

// Type of script file to generate
extern DWORD ScriptType;

// Buffer length for character strings
extern const DWORD BuffLen;

// IP address of USB simulator to attach to
extern char *SimIp;

// Name of script file
extern char *FileName;  

void StringTrim( char *String );

void DebugOutput( char *ptszFormat, ... );


// DUKELISTENER STUFF

// Connected controllers
extern DWORD ConnectedDukes;

// A controller's handle, last known state and last state change time
struct STATE_INFO {
	HANDLE DukeHandle;
	XINPUT_GAMEPAD LastState;
	LARGE_INTEGER LastChange;
};

// States of different controllers
extern STATE_INFO DukeStates[NUM_PORTS];

// Variable for retrieving the performance counter's frequency
// Used for calculating timing information
extern LARGE_INTEGER Frequency;

// Variable for querying a controller's current state
extern XINPUT_STATE CurrState;

// Default controller state
extern XINPUT_GAMEPAD BaseState;

// Array for initializing controllers
extern XDEVICE_PREALLOC_TYPE Dukes[];

void InitGamepads( void );

void DetectChanges( void );

void HandleChanges( DWORD Insertions, DWORD Removals );

void ReadGamepads( void );

void DukeInsert( DWORD Port );

void DukeRemove( DWORD Port );


// SIMMESSENGER STUFF

// A XIDDevice object and input report for simulating controllers
struct SIM_INFO {
	XIDDevice *DukeDevice;
	XIDInputReport XidPacket;
};

// Duke objects for different controllers
extern SIM_INFO SimDukes[NUM_PORTS];

// USB Simulator
extern USBSimulator *UsbSim;

void SimInit( void );

void SimInsert( DWORD Port );

void SimPlug( DWORD Port );

void SimRemove( DWORD Port );

void SimSetState( DWORD Port );


// SCRIPTWRITER STUFF

// Script abstract superclass
class Script
{
public:

	// Output filestream
	ofstream OutFile;

	Script(){}

	virtual ~Script(){}

	virtual void ScriptInsert( DWORD Port ) = 0;

	virtual void ScriptRemove( DWORD Port ) = 0;

	virtual void ScriptSetState( DWORD Port, const LARGE_INTEGER& ElapsedTime ) = 0;
};


// JScript subclass
class JScript : public Script
{
public:

	JScript( void );

	~JScript(){}

	void ScriptInsert( DWORD Port );

	void ScriptRemove( DWORD Port );

	void ScriptSetState( DWORD Port, const LARGE_INTEGER& ElapsedTime );
};

// Script File
extern Script *ScriptFile;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__408B1A2C_694C_4E37_A630_B8489F64E8D5__INCLUDED_)
#define AFX_STDAFX_H__408B1A2C_694C_4E37_A630_B8489F64E8D5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__408B1A2C_694C_4E37_A630_B8489F64E8D5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by USBXBCOM.rc
//
#define IDS_PROJNAME                    100
#define IDB_USBXBCTL                    101
#define IDR_USBXBCTL                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\AnsiBstr.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    AnsiBstr.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*****************************************************************************/
#include "stdafx.h"
#include "ansibstr.h"

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Default Constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr()
    {
    astr = NULL;
    bstr = NULL;
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a BSTR input

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr(BSTR b)
    {
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::AnsiBstr
    Constructor with a char* input

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::AnsiBstr(PCHAR a)
    {
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::~AnsiBstr
    Destructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
AnsiBstr::~AnsiBstr()
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    BSTR b - pointer to a null terminated wide char string

Return Value:

    none

Notes:

*****************************************************************************/
void AnsiBstr::SetStr(BSTR b)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    astr = CreateAnsiFromBstr(b);
    bstr = CreateBstrFromAnsi(astr);
    }

/*****************************************************************************

Routine Description:

    AnsiBstr::SetStr
    Changes the values of the strings (deletes old ones if necessary)

Arguments:

    PCHAR a - pointer to a null terminated char string

Return Value:

    none

Notes:

*****************************************************************************/
void AnsiBstr::SetStr(PCHAR a)
    {
    if(astr) LocalFree(astr);
    if(bstr) SysFreeString(bstr);
    bstr = CreateBstrFromAnsi(a);
    astr = CreateAnsiFromBstr(bstr);
    }


/*****************************************************************************

Routine Description:

    CreateAnsiFromBstr
    Allocates memory and converts from a BSTR

Arguments:

    BSTR bstr - pointer to a null terminated wide char string

Return Value:

    PCHAR - pointer to the newly allocated string

Notes:

*****************************************************************************/
PCHAR CreateAnsiFromBstr(BSTR bstr)
    {
    if(!bstr) return NULL;

    size_t bstrLen, pszLen;
    PCHAR psz = NULL;

    bstrLen = wcslen(bstr);
    pszLen = bstrLen * sizeof(CHAR);

    psz = (PCHAR)LocalAlloc(LPTR, pszLen + sizeof(CHAR));

    if(!psz) return NULL;

    WideCharToMultiByte(CP_ACP, 0, bstr, bstrLen, psz, pszLen + sizeof(CHAR), NULL, NULL);

    return psz;
    }

/*****************************************************************************

Routine Description:

    CreateBstrFromAnsi
    Allocates memory and converts from a PCHAR

Arguments:

    PCHAR pszText - pointer to a null terminated char string

Return Value:

    BSTR - return pointer to the new string

Notes:

*****************************************************************************/
BSTR CreateBstrFromAnsi(const char *pszText)
    {
    if(!pszText) return NULL;

    size_t TextLen, pszTextLen;

    pszTextLen = strlen(pszText);
    TextLen = pszTextLen * sizeof(WCHAR);

    BSTR pbstr = SysAllocStringByteLen(NULL, TextLen);

    if(!pbstr) return NULL;

    MultiByteToWideChar(CP_ACP, 0, pszText, pszTextLen, pbstr, TextLen + sizeof(WCHAR));

    return pbstr;
    }


/*****************************************************************************

Routine Description:

    CreateBstrFromAnsi
    Allocates memory and converts from a PCHAR

Arguments:

    PCHAR pszText - pointer to a null terminated char string

Return Value:

    BSTR - return pointer to the new string

Notes:

*****************************************************************************/
BSTR CreateBstrFromAnsi(const char *pszText, size_t length)
    {
    if(!pszText) return NULL;

    size_t TextLen, pszTextLen;

    pszTextLen = length;
    TextLen = pszTextLen * sizeof(WCHAR);

    BSTR pbstr = SysAllocStringByteLen(pszText, TextLen);

    if(!pbstr) return NULL;

    pbstr = (BSTR)Ansi2UnicodeHack((char*)pbstr, length);

    pbstr[length] = '\0';

    return pbstr;
    }


/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str, size_t length)
    {
    if(!str) return NULL;

    int align = 0;
    int len = length;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((unsigned long)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((unsigned long)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\USBXBCOM.cpp ===
// USBXBCOM.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f USBXBCOMps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "USBXBCOM.h"

#include "USBXBCOM_i.c"
#include "USBXBCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_USBXBCtl, CUSBXBCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_USBXBCOMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\USBXBCOMCP.h ===
#ifndef _USBXBCOMCP_H_
#define _USBXBCOMCP_H_




template <class T>
class CProxy_IUSBXBCtlEvents : public IConnectionPointImpl<T, &DIID__IUSBXBCtlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_InsertionEvent(BYTE bPort, BYTE bSlot, BYTE bInterfaceNumber)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = bPort;
				pvars[1] = bSlot;
				pvars[0] = bInterfaceNumber;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_RemovalEvent(BYTE bPort, BYTE bSlot, BYTE bInterfaceNumber)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = bPort;
				pvars[1] = bSlot;
				pvars[0] = bInterfaceNumber;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_XBOXEvent(BYTE EventType, BYTE Port, BYTE Slot, BYTE InterfaceNumber)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[3] = EventType;
				pvars[2] = Port;
				pvars[1] = Slot;
				pvars[0] = InterfaceNumber;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\Utils.h ===
USHORT MakeChars(BYTE bByte);
BOOL MakeWStringOfBytes(BYTE * pInBuff,int iInLen, WCHAR * pOutBuff, int iOutLen);
BOOL MakeStringOfBytes(BYTE * pInBuff,int iInLen, char * pOutBuff, int iOutLen);
BOOL MakeBytesOfString(char * pszString,BYTE * pOutBuff,int iOutLen);
BOOL UnspaceString(char * pszInString, char * pOutBuffer, int iOutLen);
int BstrToBinary(BSTR * pBstr, BYTE * pBuffer, int iBuffLen);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\USBXBCtl.h ===
// USBXBCtl.h : Declaration of the CUSBXBCtl

#ifndef __USBXBCTL_H_
#define __USBXBCTL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "..\IncLib\USBXBtransfer.h"
#include "utils.h"
#include "ansibstr.h"
#include "USBXBCOMCP.h"


#define MAKE_SPACE 0x01 // flag for spacinating input to client


/////////////////////////////////////////////////////////////////////////////
// CUSBXBCtl
class ATL_NO_VTABLE CUSBXBCtl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IUSBXBCtl, &IID_IUSBXBCtl, &LIBID_USBXBCOMLib>,
	public CComControl<CUSBXBCtl>,
	public IPersistStreamInitImpl<CUSBXBCtl>,
	public IOleControlImpl<CUSBXBCtl>,
	public IOleObjectImpl<CUSBXBCtl>,
	public IOleInPlaceActiveObjectImpl<CUSBXBCtl>,
	public IViewObjectExImpl<CUSBXBCtl>,
	public IOleInPlaceObjectWindowlessImpl<CUSBXBCtl>,
	public IPersistStorageImpl<CUSBXBCtl>,
	public ISpecifyPropertyPagesImpl<CUSBXBCtl>,
	public IQuickActivateImpl<CUSBXBCtl>,
	public IDataObjectImpl<CUSBXBCtl>,
	public IProvideClassInfo2Impl<&CLSID_USBXBCtl, &DIID__IUSBXBCtlEvents, &LIBID_USBXBCOMLib>,
	public CComCoClass<CUSBXBCtl, &CLSID_USBXBCtl>,
	public CProxy_IUSBXBCtlEvents< CUSBXBCtl >,
	public IConnectionPointContainerImpl<CUSBXBCtl>
{
public:
	CUSBXBCtl();
	~CUSBXBCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_USBXBCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUSBXBCtl)
	COM_INTERFACE_ENTRY(IUSBXBCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CUSBXBCtl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CUSBXBCtl)
	CHAIN_MSG_MAP(CComControl<CUSBXBCtl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IUSBXBCtl
public:
	ULONG m_ulDataSizeIn;
	int ssSend(SOCKET socket, TRANSFERDATA * pSockData, int iSize);
	void Initialize();
	char m_cServerName[30];
	USHORT GetPort(char * service);
	ULONG GetAddr();
	SOCKET m_Socket;
	SOCKET ssConnectTCP();
	STDMETHOD(get_LastXError)(/*[out, retval]*/ int *pVal);
	int m_iLastError;
	BOOL m_fInited;
	SOCKET  m_hXBoxEventsSocket;
	HRESULT OnDrawAdvanced(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : USBXBCtl");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}
public :
	STDMETHOD(RefreshConfiguration)(/*[out,retval]*/ UCHAR * pVal);
	STDMETHOD(InArray)(/*[in]*/ BYTE Port, /*[in]*/ BYTE Slot, /*[in]*/ BYTE Interface, /*[out]*/ SAFEARRAY * Data);
	BYTE m_bEnabledEvents;
	HANDLE m_hEventThread;
	STDMETHOD(Setup)(UCHAR Port,UCHAR Slot, UCHAR interfacenumber, UCHAR Endpoint, BSTR * pData, /*[out, retval]*/ UCHAR * pRetVal);
	STDMETHOD(Out)(UCHAR Port,UCHAR Slot, UCHAR interfacenumber, UCHAR Endpoint, UCHAR pid, BSTR * pData, int iDataSize, /*[out, retval]*/ UCHAR * ReturnValue );
	STDMETHOD(In)(UCHAR Port,UCHAR Slot, UCHAR interfacenumber, UCHAR Endpoint, UCHAR Format, /*[out,retval]*/ BSTR * pbsRet);
	STDMETHOD(Reset)(UCHAR Port,UCHAR Slot, UCHAR interfacenumber, /*[out,retval]*/ UCHAR * ucReturn);
	STDMETHOD(EnableEvents)(BYTE bEventMask);
	STDMETHOD(SetUsbTimeout)(ULONG ulTimeout,UCHAR * ucReturn);
	STDMETHOD(get_TimeoutValue)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_TimeoutValue)(/*[in]*/ short newVal);
	HANDLE			m_hInsertMutex;
	short			m_sTimeout;
	BOOLEAN m_fStayAlive;

BEGIN_CONNECTION_POINT_MAP(CUSBXBCtl)
	CONNECTION_POINT_ENTRY(DIID__IUSBXBCtlEvents)
END_CONNECTION_POINT_MAP()

};

#endif //__USBXBCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\USBXBCtl.cpp ===
// USBXBCtl.cpp : Implementation of CUSBXBCtl

#include "stdafx.h"
#include <process.h>    /* _beginthread, _endthread */

#include "USBXBCOM.h"
#include "USBXBCtl.h"


/////////////////////////////////////////////////////////////////////////////
// CUSBXBCtl

CUSBXBCtl::CUSBXBCtl()
{
		m_fInited = FALSE;
		m_Socket = 0;
		m_iLastError = 0;
		m_ulDataSizeIn = 0;
		m_hInsertMutex = CreateMutex(NULL,FALSE,NULL);
		m_hEventThread = INVALID_HANDLE_VALUE;
}

CUSBXBCtl::~CUSBXBCtl()
{
	m_fStayAlive = FALSE;  // Kill event thread
}



STDMETHODIMP CUSBXBCtl::get_LastXError(int *pVal)
{

	*pVal = m_iLastError;
	return S_OK;
}

// arbitrary assignments

#define XPort				"53331"
#define XBoxEventsPort		"53335"

SOCKET CUSBXBCtl::ssConnectTCP()
{
	SOCKET hsock;
	WSADATA wsadata;
	int ret;
	SOCKADDR_IN RemoteName;

	ret = WSAStartup(2, &wsadata);	//initialize Winsock
	if(ret != 0) {
		m_iLastError = ret; // save error code for possible retrieval
		return 0;
	}

	hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);	//create a socket
	if(hsock==INVALID_SOCKET) 
	{
		m_iLastError = WSAGetLastError();
		return 0;
	}

	RemoteName.sin_addr.S_un.S_addr = GetAddr();	//get address of server
	if(RemoteName.sin_addr.S_un.S_addr == INADDR_NONE) {
		m_iLastError = WSAGetLastError();
		return 0;
	}

	RemoteName.sin_port = htons(XPortNumber); //GetPort(XPort);	//get port for the address
	if(RemoteName.sin_port==0)
	{
		m_iLastError =  WSAGetLastError();
		return 0;
	}

	RemoteName.sin_family = AF_INET;

	BOOL fTrue = TRUE;
	setsockopt(hsock, IPPROTO_TCP, TCP_NODELAY, (char*)&fTrue, sizeof(BOOLEAN));

/* bugbug disable rcv timeout while debugging
	int OptVal = 500; // mSecs
	int iResult = setsockopt(hsock, SOL_SOCKET, SO_RCVTIMEO, (char*)&OptVal, sizeof(int));
	if(iResult)
	{
		int wsaerror = WSAGetLastError();
	}
*/
	ret = connect(hsock, (LPSOCKADDR)&RemoteName, sizeof(SOCKADDR));  //connect to server
	if(ret == SOCKET_ERROR) 
	{
		m_iLastError =  WSAGetLastError();
		return INVALID_SOCKET;
	}

	// now hard work is done, setup sideband events port to use for xbox to pc event notifications
	m_hXBoxEventsSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);	//create a socket
	if(m_hXBoxEventsSocket==INVALID_SOCKET) 
	{
		m_iLastError = WSAGetLastError();
		return 0;
	}

 
	RemoteName.sin_port = htons(XBoxEventsPortNumber);	//get port for the address

	RemoteName.sin_family = AF_INET;


	fTrue = TRUE;
	setsockopt(m_hXBoxEventsSocket, IPPROTO_TCP, TCP_NODELAY, (char*)&fTrue, sizeof(BOOLEAN));

	ret = connect(m_hXBoxEventsSocket, (LPSOCKADDR)&RemoteName, sizeof(SOCKADDR));  //connect to server
	if(ret == SOCKET_ERROR) 
	{
		m_iLastError =  WSAGetLastError();
		return INVALID_SOCKET;
	}


	return hsock;	

}

ULONG CUSBXBCtl::GetAddr()
{
	unsigned long ret = INADDR_ANY;
	LPHOSTENT host;

	ret = inet_addr(m_cServerName);	//check first for "#.#.#.#" format...
	if((ret == INADDR_NONE) && strcmp(m_cServerName, "255.255.255.255"))	//if that didn't work,
	{
		host = gethostbyname(m_cServerName);	//try to get it by name...
		if(!host) {						//if that didn't work,
			return INADDR_ANY;				//return 0
		}
		ret = *(unsigned long *)(host->h_addr_list[0]);	//return the address from hostname
	}
	return ret;	//return the address from "#.#.#.#" format

}

USHORT CUSBXBCtl::GetPort(char *service)
{
	LPSERVENT servent;
	if(isdigit(service[0]))
		return (USHORT) atoi(service);

	servent = getservbyname(service, "tcp");
	if(!servent)
		return 0;
	return servent->s_port;

}

STDMETHODIMP CUSBXBCtl::Reset(UCHAR Port,UCHAR Slot, UCHAR InterfaceNumber, UCHAR *ucReturn)
{

	TRANSFERDATA sockdata;
	int iResult;
	*ucReturn = 0; // error value
	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}
	sockdata.size = sizeof(TRANSFER_RESET);	//set up the packet to send to slixbox
	sockdata.type = PID_RESET;
	sockdata.reset.Port= Port;
	sockdata.reset.Slot = Slot;
	sockdata.reset.interfacenumber = InterfaceNumber;

	iResult = ssSend(m_Socket, &sockdata, sockdata.size);
	if(iResult <= 0)
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	} 


	iResult = recv(m_Socket, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(iResult <= 0) {
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	*ucReturn = sockdata.ret.ret;	//return the handshake packet from the device

	return S_OK;
}


#define IniName "USBXBCom.ini"


void EventHandler(PVOID  pContext)
{

	CEventPacket ThisEvent;
	CUSBXBCtl * pXBCtl = (CUSBXBCtl *) pContext;
	int			iReceived;
	int			iErrorCounter;

	while(pXBCtl->m_fStayAlive)
	{
		// sit on listen/rcv

		OutputDebugString("Entering Event Receive\n");
		iReceived = recv(pXBCtl->m_hXBoxEventsSocket, (char*)&ThisEvent, sizeof(CEventPacket), 0);	//receive some data back

		if(iReceived <= 0) 
		{
			pXBCtl->m_iLastError = WSAGetLastError();
			pXBCtl->m_hEventThread = INVALID_HANDLE_VALUE;
			_endthread(); // exit thread if failure, reinit of main stream will restart
		}
		OutputDebugString("Processing Event\n");

		iErrorCounter = 0;
		// process packet
		switch(ThisEvent.m_iEventCode)
		{
			case eInsertionEvent:
			{
				// fire insertion event
				pXBCtl->Fire_InsertionEvent(ThisEvent.m_Topology.m_bPort,
							ThisEvent.m_Topology.m_bSlot,
							ThisEvent.m_Topology.m_bInterfaceNumber);
				break;
			}
			case eRemovalEvent:
			{
				// fire removal event
				pXBCtl->Fire_RemovalEvent(ThisEvent.m_Topology.m_bPort,
							ThisEvent.m_Topology.m_bSlot,
							ThisEvent.m_Topology.m_bInterfaceNumber);
				break;
			}
		}
		

	}// while
	
	pXBCtl->m_hEventThread = INVALID_HANDLE_VALUE;
	_endthread();

}

void CUSBXBCtl::Initialize()
{
	m_fInited = FALSE; // default to fail
	// get server name
	char NameBuffer[100];
	DWORD dwResult;
	dwResult = GetPrivateProfileString(
					"USBXBConfig",		// No section
					"ServerName",		// key name caseinsensitive
					"Fail",				// Default Name
					NameBuffer,			// targer buffer
					sizeof(NameBuffer),
					IniName		// needs to be in Windows directory
					);

	if(0 == dwResult || !strcmp(NameBuffer,"Fail"))
	{
		// if no name in .ini file, try an ip address
		dwResult = GetPrivateProfileString(
					"USBXBConfig",		// No section
					"IPAddress",		// key name caseinsensitive
					"BadIni",			// Default Name
					NameBuffer,			// targer buffer
					sizeof(NameBuffer),
					IniName				// needs to be in Windows directory
					);

	}
	if(0 == dwResult)
	{
		return;
	}

	strcpy(m_cServerName,NameBuffer);
	m_Socket = ssConnectTCP();

	if(INVALID_SOCKET == m_Socket)
	{
		m_iLastError = WSAGetLastError();
		return;
	}
	m_fInited = TRUE;
	return;

}

int CUSBXBCtl::ssSend(SOCKET socket, TRANSFERDATA *pSockData, int iSize)
{
	iSize = pSockData->size;
	int sent = 0;
	int iResult;
	while(sent < iSize) {
		iResult = send(socket, &(pSockData->all[sent]), iSize, 0);
		if(iResult == SOCKET_ERROR) {
			m_iLastError = WSAGetLastError();
			return 0;
		}
		sent += iResult;
	}
	return sent;

}

STDMETHODIMP CUSBXBCtl::In(UCHAR Port,UCHAR Slot, UCHAR Interface , UCHAR Endpoint, UCHAR Format, BSTR *pbsRet)
{
	UCHAR cTempBuffer[sizeof(TRANSFERDATA)];
	char cSpacedBuffer[sizeof(TRANSFERDATA) + (sizeof(TRANSFERDATA)/3)];
	char cTempBuffer2[(sizeof(TRANSFERDATA)*2) + 50];

	TRANSFERDATA sockdata;		//network data buffer
	TRANSFERDATA sockdata2;
	int temp;
	int received = 0;			//data received so far
	int totaltoreceive = sizeof(TRANSFERDATA);	//max data to receive


	// Insure we have active connection to XBOX server
	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}

	if(m_Socket == INVALID_SOCKET || 0 == m_Socket)
	{
		m_iLastError = INVALID_SOCKET;
		return E_FAIL;
	}

	
	CREATE_ININIT(sockdata, Port,Slot ,Interface, Endpoint,totaltoreceive /*m_ulDataSizeIn*/);		//set up the request for an IN

	temp = ssSend(m_Socket, &sockdata, sockdata.size); 

	if(temp <= 0) 
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	received = recv(m_Socket, (char*)&sockdata2, totaltoreceive - received, 0);	//receive some data back

	if(received <= 0) 
	{
		*pbsRet = NULL;
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	if(sockdata2.in.ret)
	{
		*pbsRet = NULL;  // if not success
		m_iLastError = sockdata2.in.ret;
		return E_FAIL;
	}

	for(temp = 0; temp < received - (int)(sizeof(TRANSFER_IN)); temp++) 
	{	//copy the received data into 
			cTempBuffer[temp] = sockdata2.in.data[temp];						//the supplied buffer
	}


	m_ulDataSizeIn = received - sizeof(TRANSFER_IN);					//set the received data length

	if(0 == m_ulDataSizeIn)
	{
		*pbsRet = NULL;
	} else
	{
		MakeStringOfBytes(cTempBuffer,m_ulDataSizeIn,cTempBuffer2,sizeof(cTempBuffer2));

		char * pSourceBuffer = cTempBuffer2;

		if(MAKE_SPACE & Format)
		{
			// reformat string with spaces every two characters
			int icharcount = strlen(cTempBuffer2);
			memset(cSpacedBuffer,0x00,sizeof(cSpacedBuffer));
			char * cTarget = cSpacedBuffer;
			for(int i = 0; i < icharcount; i++)
			{
				*(cTarget++) = cTempBuffer2[i];
				if( i % 2)
				{
					*(cTarget++) = 0x20;
				}
			}
			pSourceBuffer = cSpacedBuffer;
		}

		*pbsRet = CreateBstrFromAnsi(pSourceBuffer);
	}
	
	return S_OK;
}

STDMETHODIMP CUSBXBCtl::Out(UCHAR Port,UCHAR Slot, UCHAR Interface, UCHAR Endpoint, UCHAR pid, BSTR * pData, int iDataSize, /*[out, retval]*/ UCHAR * ReturnValue )
{
	BYTE szDataPid = 0;
	TRANSFERDATA sockdata;
	int temp;


	// Insure we have active connection to XBOX server
	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}
	if(m_Socket == INVALID_SOCKET || 0 == m_Socket)
	{
		m_iLastError = INVALID_SOCKET;
		return E_FAIL;
	}
		
	if(iDataSize >= 1024)
	{
		m_iLastError = ERROR_NOT_ENOUGH_MEMORY;
		return E_FAIL;
	}

	//set up the data packet to send to slixbox
	BYTE bBuffer[1026];
	int iBytesConverted = BstrToBinary(pData, bBuffer, sizeof(bBuffer));


	CREATE_OUT(sockdata, Port,Slot, Interface, Endpoint, szDataPid, bBuffer, iBytesConverted);

	//send the data to slixbox
	temp = ssSend(m_Socket, &sockdata, sockdata.size);
	if(temp <= 0) 
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

//	if(isqueue) return 0;

	//try to receive a handshake packet back...
	temp = recv(m_Socket, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(temp <= 0) 
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;

	}

    *ReturnValue = sockdata.ret.ret;	//return the handshake packet from the device

	return S_OK;
}


STDMETHODIMP CUSBXBCtl::Setup(UCHAR Port,UCHAR Slot, UCHAR Interface, UCHAR Endpoint, BSTR * pData, /*[out, retval]*/UCHAR * pRetVal)
{
	int sdcount = 0, i = 0;
	TRANSFERDATA sockdata;
	int temp;

	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			*pRetVal = XSTATUS_ConfigurationError;
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}

	if(m_Socket == INVALID_SOCKET || 0 == m_Socket)
	{
		*pRetVal = XSTATUS_ConfigurationError;
		m_iLastError = INVALID_SOCKET;
		return E_FAIL;
	}

	if(NULL == pData)
	{
		*pRetVal = XSTATUS_ConfigurationError;
		m_iLastError = ERROR_INVALID_DATA;
		return E_FAIL;
	}

	BYTE bBuffer[1026];
	int iBytesConverted = BstrToBinary(pData, bBuffer, sizeof(bBuffer));

	if(0 == iBytesConverted)
	{
		*pRetVal = XSTATUS_ConfigurationError;
		m_iLastError = ERROR_INVALID_DATA;
		return E_FAIL;
	}

	//set up the data packet to send to slixbox
	CREATE_SETUP(sockdata, Port,Slot, Interface, Endpoint, bBuffer, iBytesConverted);

	//send the data to slixbox
	temp = ssSend(m_Socket, &sockdata, sockdata.size);
	if(temp <= 0) 
	{
		*pRetVal = XSTATUS_ConfigurationError;
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	//try to receive a handshake packet back...
	temp = recv(m_Socket, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(temp <= 0) 
	{
		*pRetVal = XSTATUS_ConfigurationError;
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	*pRetVal = sockdata.ret.ret;	//return the handshake packet from the device
	return S_OK;


}


STDMETHODIMP CUSBXBCtl::get_TimeoutValue(short *pVal)
{
	*pVal = m_sTimeout;
	return S_OK;
}


STDMETHODIMP CUSBXBCtl::put_TimeoutValue(short newVal)
{
	m_sTimeout = newVal;

	// set the socket with the new timeout value
	int iResult = setsockopt(m_Socket, SOL_SOCKET, SO_RCVTIMEO, (char *) &newVal, sizeof(int));
	if(iResult)
	{
		m_iLastError = WSAGetLastError();
	}
	return S_OK;
}


STDMETHODIMP CUSBXBCtl::SetUsbTimeout(ULONG ulTimeout, UCHAR * ucReturn)
{
	TRANSFERDATA sockdata;
	int iResult;
	*ucReturn = 0; // error value
	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}
	sockdata.size = sizeof(TRANSFER_USB_TIMEOUT);	//set up the packet to send to slixbox
	sockdata.type = PID_SET_USB_TIMEOUT;
	sockdata.UsbTimeout.ulTimeoutValue = ulTimeout;

	iResult = ssSend(m_Socket, &sockdata, sockdata.size);
	if(iResult <= 0)
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	} 


	iResult = recv(m_Socket, (char*)&sockdata, 256, 0);	//temp = num of bytes received
	if(iResult <= 0) {
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	*ucReturn = sockdata.ret.ret;	//return the handshake packet from the device

	return S_OK;
}



STDMETHODIMP CUSBXBCtl::EnableEvents(BYTE bEventMask)
{

	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}

	// start thread to listen for xbox events
	if(INVALID_HANDLE_VALUE == m_hEventThread)
	{
		m_hEventThread = (HANDLE) _beginthread(EventHandler,0,this);
		// start thread to listen for xbox events
		if(INVALID_HANDLE_VALUE == m_hEventThread )
		{
			ReleaseMutex(m_hInsertMutex);
			return E_FAIL;
		}
	}
	// release the mutex and let the event thread start processing current events
	ReleaseMutex(m_hInsertMutex);
	
	return S_OK;
}

STDMETHODIMP CUSBXBCtl::InArray(BYTE Port, BYTE Slot, BYTE Interface, SAFEARRAY *Data)
{
	return S_OK;
}

STDMETHODIMP CUSBXBCtl::RefreshConfiguration(UCHAR * pVal)
{

	TRANSFERDATA sockdata;
	int iResult;

	if(FALSE == m_fInited)
	{
		Initialize();
		if(FALSE == m_fInited)
		{
			return E_FAIL; // failed initialization, error in m_iLastError
		}
	}

	sockdata.size = sizeof(TRANSFER_REFRESH_CONFIG);	//set up the packet to send to slixbox
	sockdata.type = PID_GET_DEVICE_STATE;

	iResult = ssSend(m_Socket, &sockdata, sockdata.size);
	if(iResult <= 0)
	{
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	} 


	iResult = recv(m_Socket, (char*)&sockdata, sizeof(TRANSFERDATA), 0);	
	if(iResult <= 0) {
		m_iLastError = WSAGetLastError();
		return E_FAIL;
	}

	// now fire events for each device topology received
	for(int i = 0; i < sockdata.DeviceState.bDeviceCount; i++)
	{
		// fire insertion event
		Fire_InsertionEvent(
				sockdata.DeviceState.TopArray[i].bPort,
				sockdata.DeviceState.TopArray[i].bSlot,
				sockdata.DeviceState.TopArray[i].bInterfaceNumber);
	}

	*pVal = sockdata.ret.ret;	//return the handshake packet from the device


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBCOM\Utils.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "AnsiBstr.h"

// input BStr from COM interface representing binary string, e.g.: 00 11 AB
// convert from BStr to char *
// remove any embedded space
// convert from chars to binary

int BstrToBinary(BSTR * pBstr, BYTE * pBuffer, int iBuffLen)
{
		// first convert from bstr to char 
	PCHAR pcTemp = CreateAnsiFromBstr(*pBstr);
	// next remove spaces
	char * pNewStr = (char *) malloc(strlen(pcTemp)+2);
	if(NULL == pNewStr)
	{
		return 0;
	}
	// remove any unwanted formatting spaces
	BOOL bResult = UnspaceString(pcTemp,pNewStr,strlen(pcTemp)+1);
	if(FALSE == bResult)
	{
		return 0;
	}
	LocalFree(pcTemp); // release string allocated by CreateAnsiFromBstr
	// finally convert from string to binary
	bResult = MakeBytesOfString(pNewStr,pBuffer,iBuffLen);
	if(FALSE == bResult)
	{
		return 0;
	}
	int iBytes = strlen(pNewStr)/2;
	free(pNewStr);
	return iBytes;
}

// convert an input byte, e.g. 0x1a to characters e.g. "1a"
USHORT MakeChars(BYTE bByte)
{
	USHORT usResult;
	BYTE bLNibble,bHNibble;

	bLNibble =  (UCHAR) (bByte & 0x0f);
	bHNibble = (UCHAR) (bByte >> 4);
	if(bHNibble < 10)
	{
		usResult = (USHORT) (bHNibble + 0x30);
	} else
	{
		usResult = (USHORT) (bHNibble + 0x41 - 0x0a);
	}
	usResult <<= 8;
	if(bLNibble < 10)
	{
		usResult = (USHORT) (usResult +  (bLNibble + 0x30));
	} else
	{
		usResult = (USHORT) (usResult +  (bLNibble + 0x41 - 0x0a));
	}
	return usResult;
}

// input buffer and len
// output pszWide String representation of Len bytes from the buffer, e.g. L"0012ab"

BOOL MakeWStringOfBytes(BYTE * pInBuff,int iInLen, WCHAR * pOutBuff, int iOutLen)
{
	USHORT	usByteChars;
	USHORT * pTemp = (USHORT *) pOutBuff; // going to move two chars at a time
	if(iOutLen < (iInLen * 4) + 2) return FALSE;
	for(int i = 0; i < iInLen; i++)
	{
		// get byte
		usByteChars = MakeChars(pInBuff[i]);

		*pTemp++ =(WCHAR) (usByteChars >> 8); // upper character
		*pTemp++ = (WCHAR) (usByteChars & 0xff); // lower character

	}
	pTemp[i] = 0x00; // terminate string
	return TRUE;
}


// input buffer and len
// output pszString representation of Len bytes from the buffer, e.g. "0012ab"
BOOL MakeStringOfBytes(BYTE * pInBuff,int iInLen, char * pOutBuff, int iOutLen)
{
	USHORT	usByteChars;
	char * pTemp =  pOutBuff; // going to move two chars at a time
	if(iOutLen < (iInLen * 4) + 2) return FALSE;
	for(int i = 0; i < iInLen; i++)
	{
		// get byte
		usByteChars = MakeChars(pInBuff[i]);

		*pTemp++ = (char) (usByteChars >> 8); // upper character
		*pTemp++ = (char) (usByteChars & 0xff); // lower character

	}
	*pTemp = 0x00; // terminate string
	return TRUE;
}

// remove spaces from string

BOOL UnspaceString(char * pszInString, char * pOutBuffer, int iOutLen)
{
	char * pInput = pszInString;
	char * pOutput = pOutBuffer;
	int iLen = strlen(pszInString);
	if(iOutLen < iLen+1)
	{
		return FALSE;
	}
	for(int i = 0; i < iLen; i++)
	{
		if(*pInput != 0x20)
		{
			*pOutput++ = *pInput;
		}
		pInput++;
	}
	*pOutput = 0x00;
	return TRUE;
}

// input pszString of binary hex, e.g. "0123ABCD"
// output binary hex, e.g. 0x0123abcd

BOOL MakeBytesOfString(char * pszString,BYTE * pOutBuff,int iOutLen)
{
	CHAR bTemp;
	BYTE bVal;
	BYTE bCurValue;
	BOOL fFlag = FALSE;
	int iLen = strlen(pszString);
	if(iOutLen < iLen/2 || iOutLen % 2 )
	{
		return 0;
	}

	for(int i = 0; i < iLen; i++)
	{
		bTemp = pszString[i];
		if(bTemp > 0x2f && bTemp < 0x3A)
		{   // decimal number
			bVal = bTemp - 0x30;
		} else
		{
			bTemp &= 0xDF; // fix any case problems
			if(bTemp > 0x40 && bTemp < 0x47) // a through f
			{
				bVal = bTemp - 0x37;
			} else
			{
				return 0; // not in numeric range
			}
		}
		if(FALSE == fFlag)
		{
			fFlag = TRUE;
			bCurValue = bVal << 4;
		} else
		{
			fFlag = FALSE;
			bCurValue |= bVal;
			pOutBuff[i/2] = bCurValue;
		}

	}
	return TRUE;
}


/// utility support for linked list of insertions and removal tracking
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBDriver\IUSBXBDriver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/


extern "C" {
#include <nt.h>
#include <ntos.h>
}

#include <xtl.h>

#include <stdio.h>
#include <usb.h>
#include "..\inclib\USBXBDriver.h"
#include "iUSBXBdriver.h"

//#include "slixdriver.cpp"
//extern void SLIX_RemoveDevice (IN IUsbDevice *Device);


ULONG	gMillisecWait = 4; // defaults to 4 millisecs
//#define PORT_FROM_ADDRESS(a) ((a) & 0x0f)
//#define SLOT_FROM_ADDRESS(a) (((a) >> 4) & 0x7)

//#define ENDPOINT_TYPE(e) ((e >> 4) & 3)
#define ENDPOINT_DIRECTION(e) (e & 0x80)

#define ENDPOINT_NUM(e) (ENDPOINT_DIRECTION(e)?(e & 15):((e & 15)+16))                                                  //changed by Bing from 15 to 31

#define ENDPOINT_NUM_DIRECTION(e) (e & 0x8f)


typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

volatile int gYouMayPass = 0;

//#pragma warning(disable:4035) 
//disable "no return". rdtsc changes edx:eax, which is where __int64 is returned.
//this incriments roughly 733000000 times/second.
//733000 = 1 millisecond, etc.
//__int64 __inline gettsc() {_asm {rdtsc} }	
//#pragma warning(default:4035)


KEVENT gEventActivation;




VOID CompleteProc (PURB urb, PVOID con)
{
 	gYouMayPass = ~urb->Header.Status;	//encoding it for the moment...
}

VOID IsochCompleteProc (USBD_ISOCH_TRANSFER_STATUS* puits, PVOID con)
{
 	gYouMayPass = ~puits->Status;	//encoding it for the moment...
}


//#define USB_ENDPOINT_TYPE_CONTROL                 0x00
//#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
//#define USB_ENDPOINT_TYPE_BULK                    0x02
//#define USB_ENDPOINT_TYPE_INTERRUPT               0x03
HANDLE GetEndpoint(IUsbDevice * pud, BYTE endpoint)
{
	URB urb;
	int temp;
	PDEVICE_EXTENSION pExt;
	pExt = (PDEVICE_EXTENSION) pud->GetExtension();
	void** Endpoints = pExt->Endpoints;
	
	BYTE bEndpointType = pExt->EndpointType[endpoint & 0x0f];
	DBGPRINT(3, ("Endpoint %d, Endpoint Type %d\n",endpoint,bEndpointType));

	if((0 == ENDPOINT_NUM(endpoint)) || (16==ENDPOINT_NUM(endpoint)) ) 
	{	//default (control) endpoint
		if(Endpoints[0] != (void*)-1) 
		{	//if it's been opened already
			return Endpoints[0];		//return it...
		}

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
		pud->SubmitRequest(&urb);
		Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
		return NULL;

	} else 
	{	//normal endpoint

		if(bEndpointType == USB_ENDPOINT_TYPE_ISOCHRONOUS) 
		{ //isoch

			//if it's not already opened...
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) 
			{
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
// no need to do this, now have actual type from descriptor
//				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
// 					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));

			}

			return Endpoints[ENDPOINT_NUM(endpoint)];

		} else 
		{ //not isoch
			if(Endpoints[ENDPOINT_NUM(endpoint)] != (void*) -1 && Endpoints[ENDPOINT_NUM(endpoint)] != NULL)
			{
				return Endpoints[ENDPOINT_NUM(endpoint)];
			}

			RtlZeroMemory(&urb,sizeof(URB));

			USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), bEndpointType, SLIX_MAX_BULK_PACKET_SIZE, 1);
			pud->SubmitRequest(&urb);
			Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
			return urb.OpenEndpoint.EndpointHandle;
		}

	}
}

 

void CloseEndpoint(IUsbDevice * pud, BYTE endpoint, HANDLE eh)
{
//	URB urb;
//	int temp;
//	void** Endpoints = ((PDEVICE_EXTENSION)pud->GetExtension())->Endpoints;

//
//	if(0 == ENDPOINT_NUM(endpoint)) {	//default (control) endpoint
//		if(Endpoints[0] == (void*)-1) {	//if it's been closed already
//			return; //Endpoints[0];		//return it...
//		} else {

		//RtlZeroMemory(&urb,sizeof(URB));
//		USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&urb.CloseEndpoint, arf,0);

		//USB_BUILD_OPEN_DEFAULT_ENDPOINT((&urb.OpenEndpoint));
//		pud->SubmitRequest(&urb);
		//Endpoints[endpoint] = NULL;		//NULL is always returned for the default endpoint handle
//		return;// NULL;
//		}

//	} else {//normal endpoint
//		if(ENDPOINT_TYPE(endpoint) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { //isoch

			//if it's not already opened...

			/* we will consider this later on
			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				DBGPRINT(3, ("Attempting to open isoch endpoint: "));
				((DEVICE_EXTENSION*)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] 
					= USB_ENDPOINT_TYPE_ISOCHRONOUS; //so we can close it properly

				RtlZeroMemory(&urb,sizeof(URB));
                USB_BUILD_ISOCH_OPEN_ENDPOINT((&urb.IsochOpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), 256, 0);
				temp = pud->SubmitRequest(&urb);
				DBGPRINT(3, ("returned 0x%8x\n", temp));
				Endpoints[ENDPOINT_NUM(endpoint)] = urb.IsochOpenEndpoint.EndpointHandle;

				URB urb2;
				RtlZeroMemory(&urb2,sizeof(URB));
				USB_BUILD_ISOCH_START_TRANSFER((&urb2.IsochStartTransfer), Endpoints[ENDPOINT_NUM(endpoint)], 
					0, URB_FLAG_ISOCH_START_ASAP);
				temp = pud->SubmitRequest(&urb2);
				DBGPRINT(3, ("StartTransfer returned 0x%8x\n", temp));
            
			}
			*/

//			return; //Endpoints[ENDPOINT_NUM(endpoint)];

//		} else { //not isoch
//			if(Endpoints[ENDPOINT_NUM(endpoint)] == (void*) -1 || Endpoints[ENDPOINT_NUM(endpoint)] == NULL) {
				//already closed
//				return; //Endpoints[ENDPOINT_NUM(endpoint)];
//			} else {
			//RtlZeroMemory(&urb,sizeof(URB));

			//USB_BUILD_OPEN_ENDPOINT((&urb.OpenEndpoint), ENDPOINT_NUM_DIRECTION(endpoint), ENDPOINT_TYPE(endpoint), SLIX_MAX_BULK_PACKET_SIZE, 1);
			
			
//            USB_BUILD_CLOSE_ENDPOINT(&urb.CloseEndpoint,Endpoints[ENDPOINT_NUM(endpoint)] , arf,0);
//			pud->SubmitRequest(&urb);
			//Endpoints[ENDPOINT_NUM(endpoint)] = urb.OpenEndpoint.EndpointHandle;
//			return; // urb.OpenEndpoint.EndpointHandle;
//			}
//		}

//	}

	//intiliaze it again
  // Endpoints[ENDPOINT_NUM(endpoint)]=(void *) -1;
  //((PDEVICE_EXTENSION)pud->GetExtension())->EndpointType[ENDPOINT_NUM(endpoint)] = 0;



}


/*************************************************************************************
Function:   SlixdIn
Purpose:	create & send an IN packet, receive the data, return any errors
Params:     in Address --- the topology of the device to receive from (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to receive from 
			out data --- pointer to the buffer to receive data
			in out len --- pointer to max length of data buffer, receives size of data received
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdIn(_IN BYTE port,_IN BYTE slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _OUT char * data, _IN _OUT DWORD * len)
{	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG templen = 8;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	BYTE closeendpoint = Endpoint;
	__int64 maxwaittime;

	de = &gpDriverExtension->Nodes[port][slot][InterfaceNumber];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		DBGPRINT(2,("SlixdIn: Port %d, Slot %d, pud==NULL\n", port, slot));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	if(!(de->flags & DF_CONNECTED)){
		DBGPRINT(2,("SlixdIn: de->DeviceFlags & DF_CONNECTED"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}
	
	if(data == NULL) {
		if(len != NULL) *len = 0;
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3, ("ERROR! Can't send additional INs to endpoint 0\n"));
		*len = 0;
		return USBD_STATUS_ERROR;
	}

	if(FALSE == de->EndpointSupported[Endpoint])
	{
		DebugPrint("Endpoint Tested address = %x\n",&de->EndpointSupported[Endpoint]);

		return USBD_STATUS_ERROR;
	}


	Endpoint |= 0x80;

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		DBGPRINT(3, ("ourendpoint == NULL && Endpoint != 0\n"));
		if(len) *len = 0;
		return USBD_STATUS_ERROR;
	} 

	if(de->EndpointType[ENDPOINT_NUM(Endpoint)] == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)*len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = gMillisecWait;	//default = 4
	} else 
	{	//non-isoch
		*len = (*len + 63) & ~63;	//round up to the nearest 64 bytes so we don't get buffer overflows
	
		if(!*len) {	//len == 0
			DBGPRINT(3, ("*len == 0!!!\n"));
			*len = 64;
		}
		
		templen = *len > 192 ? 191 : *len;
	
		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, templen, USB_TRANSFER_DIRECTION_IN, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = gMillisecWait;	//roughly 4 milliseconds
		//(if a 64-byte packet comes back, ohci requests another one until our buffer is full)
	}
	gYouMayPass = 0;

	DWORD dwTime = GetTickCount();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass /*&& (gettsc() - tim) < maxwaittime*/) { }	//wait to time out, or for request to come back
/*
	if((gettsc() - tim) > maxwaittime) {	//if we timed out
		pud->CancelRequest(&urb);			//cancel request
		while(!gYouMayPass) { }				//and wait for the thing to cancel
	}

*/	//we got a response!
	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n"
				"returned data size: %d, first 8 bytes = %016I64x\n", 
				retcode, urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	if(de->EndpointType[ENDPOINT_NUM(Endpoint)] == USB_ENDPOINT_TYPE_ISOCHRONOUS) { 
		//*len = *len //hope that we really got that much data back
	} else {
		*len = (USHORT)urb.BulkOrInterruptTransfer.TransferBufferLength;
	}

	//CloseEndpoint(pud, Endpoint, ourendpoint);
	CloseEndpoint(pud, closeendpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdOut
Purpose:	create & send an OUT packet, send the data, return any errors
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdOut(_IN BYTE port,_IN BYTE slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _IN char * data, _IN DWORD len)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	__int64 maxwaittime;

	
	de = &gpDriverExtension->Nodes[port][slot][InterfaceNumber];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(Endpoint == 0) {
		DBGPRINT(3,("ERROR! Can't send additional OUTs to endpoint 0\n"));
//		*len = 0;
		return USBD_STATUS_ERROR;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);
	
	if(data == NULL) {
		if(len != 0) {
			return USBD_STATUS_ERROR;	//trying to send data that doesn't exist??
		}
	}

	//if(ourendpoint == NULL && Endpoint != 0) {
	if(ourendpoint == NULL && (ENDPOINT_NUM(Endpoint) != 0)) {                                           //changed by Bing from above line to this, this should be the same as SlixDIN().
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}


	if(de->EndpointType[ENDPOINT_NUM(Endpoint)] == USB_ENDPOINT_TYPE_ISOCHRONOUS) {		//isoch
		USBD_ISOCH_BUFFER_DESCRIPTOR bufd;

		bufd.Context = (void*)pud;
		bufd.FrameCount = 1;
		bufd.Pattern[0] = (USHORT)len;
		bufd.Pattern[1] = 0;
		bufd.TransferBuffer = data;
		bufd.TransferComplete = IsochCompleteProc; 
		RtlZeroMemory(&urb, sizeof(URB));
		USB_BUILD_ISOCH_ATTACH_BUFFER((&urb.IsochAttachBuffer), ourendpoint, USBD_DELAY_INTERRUPT_0_MS, &bufd);
		maxwaittime = gMillisecWait;	//3.1 milliseconds

	} else 
	{	//non-isoch

		RtlZeroMemory(&urb,sizeof(URB));
		USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(&urb.BulkOrInterruptTransfer,
			ourendpoint, data, len, USB_TRANSFER_DIRECTION_OUT, 
			CompleteProc, (void*)pud, TRUE);
		maxwaittime = gMillisecWait;		//wait 3 milliseconds

	}
	gYouMayPass = 0;



	DWORD dwTime = GetTickCount();
	retcode = pud->SubmitRequest(&urb);

	while(!gYouMayPass && (GetTickCount() - dwTime) < maxwaittime) { }	//wait to time out, or for response

	if((GetTickCount() - dwTime) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}

	CloseEndpoint(pud, Endpoint, ourendpoint);

	return retcode;
}

/*************************************************************************************
Function:   SlixdSetup
Purpose:	create & send a SETUP packet, send the data, return any errors
note: more stuff may be needed to receive or send additional data...
Params:     in Address --- the topology of the device to send to (see PORT_FROM_ADDRESS above)
			in Endpoint --- the endpoint of the device to send to
			in data --- pointer to the buffer to receive data
			in len --- number of bytes to send
			data2 --- pointer to buffer to receive or send data. OPT if data[6]==0
			len2 --- p to length of data2 if sending, p to max length if receiving, & 
				will receive length of data received. Not optional.
Return:     a USBD_STATUS code indicating error or success.
*************************************************************************************/
USBD_STATUS SlixdSetup(_IN BYTE port,_IN BYTE slot, _IN BYTE InterfaceNumber, _IN BYTE Endpoint, _IN char * data, _IN DWORD len, 
					   _OPT _IN _OUT char * data2, _IN _OUT USHORT *len2)
{
	DEVICE_EXTENSION * de;
	URB urb;
	IUsbDevice * pud;
	LONG temp;
	USBD_STATUS retcode = USBD_STATUS_ERROR;
	HANDLE ourendpoint;
	USHORT extlen;
	BYTE direction;
	DWORD maxwaittime;



	de = &gpDriverExtension->Nodes[port][slot][InterfaceNumber];
	pud = de->Device;

	if (pud == NULL) {
		//the device isn't connected
		return USBD_STATUS_ERROR;
	}

	if(data == NULL) {
		DBGPRINT(1, ("data == NULL"));
		return USBD_STATUS_ERROR;
	} else if(len != 8) {
		DBGPRINT(1, ("Setup packets should be 8 bytes! len = %d, data = %016I64x, len2 = %d", len, *(INT64*)data, *len2));
		return USBD_STATUS_ERROR;
	} 

	extlen = (*(USHORT*)&data[6]); //get the length of the data to send/recv
	if(!len2) {
		DBGPRINT(1, ("Setup: len2 is NOT optional!"));
		return USBD_STATUS_ERROR;
	} else if(*len2 < extlen) {
		DBGPRINT(1, ("sending data without enough buffer length?? len2: %d, extlen: %d", *len2, extlen));
		return USBD_STATUS_ERROR;
	}

	if(*len2 > 2048) *len2 = 2048;	//can't send or expect too much data, due to ohci requrements

	if(*len2 > 0) {
		if(data2 == NULL) {
			DBGPRINT(1, ("data2 == NULL"));
			return USBD_STATUS_ERROR;
		}

		direction = (data[0] & 128) ? USB_TRANSFER_DIRECTION_IN : USB_TRANSFER_DIRECTION_OUT;
	} else {
		direction = 0;
	}

	ourendpoint = GetEndpoint(pud, Endpoint);

	if(ourendpoint == NULL && Endpoint != 0) {
		//the endpoint couldn't be opened... if Endpoint == 0, the endpoint handle is always NULL.
		return USBD_STATUS_ERROR;
	}
	
	RtlZeroMemory(&urb,sizeof(URB));
	USB_BUILD_CONTROL_TRANSFER(&urb.ControlTransfer,
		ourendpoint, data2, *len2, direction,		////////////////////data2
		CompleteProc, (void*)pud, TRUE,
		data[0], data[1], (*(USHORT*)&data[2]), (*(USHORT*)&data[4]), (*(USHORT*)&data[6]) );


	gYouMayPass = 0;
	DWORD dwTime = GetTickCount();
	retcode = pud->SubmitRequest(&urb);

    maxwaittime = gMillisecWait;        //wait 3 milliseconds
	
    while(!gYouMayPass && (GetTickCount() - dwTime) < maxwaittime) { }               //wait for 3 milliseconds, or for the response.

	if((GetTickCount() - dwTime) > maxwaittime) {
		pud->CancelRequest(&urb);
		while(!gYouMayPass) { }
	}

	if(~gYouMayPass != USBD_STATUS_CANCELED) {
		retcode = ~gYouMayPass;
		if(retcode != USBD_STATUS_SUCCESS) {
			DBGPRINT(3, ("request completed, with error: %x\n", retcode));
			DBGPRINT(3, ("returned data size: %d, first 8 bytes = %016I64x\n", 
				urb.BulkOrInterruptTransfer.TransferBufferLength, *(INT64*)data));
		}
	}


	*len2 = (USHORT)urb.ControlTransfer.TransferBufferLength;

	CloseEndpoint(pud, Endpoint, ourendpoint);
	return retcode;
}



/*************************************************************************************
Function:   SlixdReset
Purpose:	reset the last-used device
Params:     due to sli requriements, no params... :o(
Return:     error if last device used doesn't exist
*************************************************************************************/
USBD_STATUS SlixdReset(_IN BYTE bPort,_IN BYTE bSlot, _IN BYTE bInterface)
{
	DEVICE_EXTENSION * de;
	IUsbDevice * pud;
	KIRQL kirql;
	if(bSlot > 0x7) bSlot = 0;

	de = &gpDriverExtension->Nodes[bPort][bSlot][bInterface];
	pud = de->Device;

	if (pud == NULL) { //device isn't connected
		return USBD_STATUS_ERROR;
	}

    kirql = KeRaiseIrqlToDpcLevel();
		pud->DeviceNotResponding();
    KeLowerIrql(kirql);
	
	return USBD_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBDriver\USBXBDriver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    islixd.cpp

Abstract:

    interface to the slixbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/

extern "C" 
{
#include <nt.h>
#include <ntos.h>
}


#include <scsi.h>
//#include <ntdddisk.h>

#include <xtl.h>

#include <usb.h>
#include <stdio.h>
#include "..\inclib\usbxbtransfer.h"

#include "IUSBXBdriver.h"



ULONG               DebugFlags;     // DBGF_* Flags
ULONG               DebugLevel=5;     // Level of debug output
SLIX_DRIVER_EXTENSION gde = {{0},0};
PSLIX_DRIVER_EXTENSION gpDriverExtension = &gde;

URB CloseUrb[MAX_ENDPOINTS];                                                                                              //changed by Bing from 16 to 32
URB StopUrb[MAX_ENDPOINTS];

// we have two stacks and one linked list in order to track and record changes in device states
// one stack for insertion events, one stack for removal events and one doubly-linked list of active devices

HANDLE ghEventActivation;
CXBoxTopology gPluggedStack[32];
HANDLE ghInsertionLock;
int	giPluggedCount = 0;
CXBoxTopology gUnpluggedStack[32];
int giUnpluggedCount = 0;
HANDLE ghUnplugLock;


//the following mess allows slix to grab & talk to all devices
#define SLIX1_Init DriverInit
#define SLIX2_Init DriverInit
#define SLIX3_Init DriverInit
#define SLIX4_Init DriverInit
#define SLIX5_Init DriverInit
#define SLIX6_Init DriverInit
#define SLIX7_Init DriverInit
#define SLIX8_Init DriverInit
#define SLIX9_Init DriverInit
#define SLIX10_Init DriverInit



#define SLIX1_AddDevice SLIX_AddDevice
#define SLIX2_AddDevice SLIX_AddDevice
#define SLIX3_AddDevice SLIX_AddDevice
#define SLIX4_AddDevice SLIX_AddDevice
#define SLIX5_AddDevice SLIX_AddDevice
#define SLIX6_AddDevice SLIX_AddDevice
#define SLIX7_AddDevice SLIX_AddDevice
#define SLIX8_AddDevice SLIX_AddDevice
#define SLIX9_AddDevice SLIX_AddDevice
#define SLIX10_AddDevice SLIX_AddDevice

#define SLIX1_RemoveDevice SLIX_RemoveDevice
#define SLIX2_RemoveDevice SLIX_RemoveDevice
#define SLIX3_RemoveDevice SLIX_RemoveDevice
#define SLIX4_RemoveDevice SLIX_RemoveDevice
#define SLIX5_RemoveDevice SLIX_RemoveDevice
#define SLIX6_RemoveDevice SLIX_RemoveDevice
#define SLIX7_RemoveDevice SLIX_RemoveDevice
#define SLIX8_RemoveDevice SLIX_RemoveDevice
#define SLIX9_RemoveDevice SLIX_RemoveDevice
#define SLIX10_RemoveDevice SLIX_RemoveDevice


#define SLIXDEVICEPORT  (&SLIXDEVICEPORT_TABLE)
#define SLIXDEVICESLOT  (&SLIXDEVICESLOT_TABLE)
DECLARE_XPP_TYPE(SLIXDEVICEPORT)
DECLARE_XPP_TYPE(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX1_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX2_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX3_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX4_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX5_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX6_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX7_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX8_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX9_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
USB_DEVICE_TYPE_TABLE_BEGIN(SLIX10_)
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICEPORT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT),
USB_DEVICE_TYPE_TABLE_ENTRY(SLIXDEVICESLOT)
USB_DEVICE_TYPE_TABLE_END()
#define XBOX_DEVICE_CLASS_XHAWK_DEVICE 0x78
#define XBOX_DEVICE_CLASS_INPUT_DEVICE 0x58
USB_CLASS_DRIVER_DECLARATION(SLIX1_, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX1_, 1, XBOX_DEVICE_CLASS_XHAWK_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX2_, USB_DEVICE_CLASS_COMMUNICATIONS, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX3_, USB_DEVICE_CLASS_HUMAN_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(SLIX3_, 1, XBOX_DEVICE_CLASS_INPUT_DEVICE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX4_, USB_DEVICE_CLASS_MONITOR, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX5_, USB_DEVICE_CLASS_PHYSICAL_INTERFACE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX6_, USB_DEVICE_CLASS_POWER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX7_, USB_DEVICE_CLASS_PRINTER, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX8_, USB_DEVICE_CLASS_STORAGE, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX9_, USB_DEVICE_CLASS_RESERVED, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION(SLIX10_, USB_DEVICE_CLASS_VENDOR_SPECIFIC, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassAAASLIX") //ohci should load this before anything else
USB_CLASS_DECLARATION_POINTER(SLIX1_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX1_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX2_)
USB_CLASS_DECLARATION_POINTER(SLIX3_)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(SLIX3_, 1)
USB_CLASS_DECLARATION_POINTER(SLIX4_)
USB_CLASS_DECLARATION_POINTER(SLIX5_)
USB_CLASS_DECLARATION_POINTER(SLIX6_)
USB_CLASS_DECLARATION_POINTER(SLIX7_)
USB_CLASS_DECLARATION_POINTER(SLIX8_)
USB_CLASS_DECLARATION_POINTER(SLIX9_)
USB_CLASS_DECLARATION_POINTER(SLIX10_)
#pragma data_seg()


//apis we are replacing by over-writing xid.sys... xapi is still looking for these!
/*
extern "C" void XInputClose(int){}
extern "C" void XInputGetCapabilities(int,int){}
extern "C" void XInputGetState(int,int){}
extern "C" void XInputOpen(int,int,int,int){}
extern "C" void XInputPoll(int){}
extern "C" void XInputSetState(int,int){}
*/

		
void KeepCode()
{
	return;
}





/*************************************************************************************
Function:   DriverInit
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
void
DriverInit (IUsbInit *pUsbInit)
{
    DBGPRINT(2, ("enter:  DriverInit\n"));    
    ULONG port, slot,USBInterface;
    UCHAR realMaxPorts = (UCHAR)XGetPortCount();

	gpDriverExtension = &gde;

	for (port = 0;port < MAX_PORTS; port++) 
	{
		for (slot = 0; slot < MAX_SLOTS; slot++) 
		{
			for (USBInterface = 0; USBInterface < MAX_INTERFACES; USBInterface++)
			{
				gpDriverExtension->Nodes[port][slot][USBInterface].Device = NULL;
			}
		}
    }
    
	ghEventActivation = CreateEvent(NULL,FALSE,FALSE,NULL);
	ghInsertionLock = CreateMutex(NULL,FALSE,NULL);
	ghUnplugLock = CreateMutex(NULL,FALSE,NULL);
    //
    //  Allocate a whole bunch of resources, we don't
    //  care that much how much memory we take, and
    //  we don't want to run out.
    //
    USB_RESOURCE_REQUIREMENTS resourceRequirements;
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_DIRECT;
    resourceRequirements.MaxDevices = realMaxPorts;
    resourceRequirements.MaxCompositeInterfaces = 3;
    resourceRequirements.MaxControlEndpoints = 2;
    resourceRequirements.MaxBulkEndpoints = 2;
    resourceRequirements.MaxInterruptEndpoints = 2;    
    resourceRequirements.MaxControlTDperTransfer = 40;
    resourceRequirements.MaxBulkTDperTransfer = 40;
    resourceRequirements.MaxIsochEndpoints = 2;
    resourceRequirements.MaxIsochMaxBuffers = 5;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_HIGH_POWER;
    pUsbInit->RegisterResources(&resourceRequirements);
    resourceRequirements.ConnectorType = USB_CONNECTOR_TYPE_LOW_POWER;
    resourceRequirements.MaxDevices = realMaxPorts*2;
    pUsbInit->RegisterResources(&resourceRequirements);

    DBGPRINT(2, ("exit:  DriverInit\n"));    

    return;// status;
}

//callback for endpoint closes (below) to allow them to be asynchronous
VOID Arf (PURB urb, PVOID context)
{ }




/*************************************************************************************
Function:   SLIX_RemoveDevice
Purpose:	called by pnp when a device is unplugged. Removes that interface from our array
Params:     Device = the interface to talk to usbd
Return:     none
*************************************************************************************/

VOID SLIX_RemoveDevice (IN IUsbDevice *Device)
{
	HANDLE ourendpoints[MAX_ENDPOINTS];
	int i;

    DBGPRINT(2, ("enter: SLIX_RemoveDevice\n"));
	if(Device == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called with NULL Device!\n"));
		return;
	}

    PDEVICE_EXTENSION   pDevExt = (PDEVICE_EXTENSION) Device->GetExtension();

	if(pDevExt == NULL) {
		DBGPRINT(1, ("SLIX_RemoveDevice called for device that has already been removed!!\n"
			"IUsbDevice passed: %p. Port: %x\n", Device, Device->GetPort()))
	}


	pDevExt->flags = 0;

	pDevExt->Device = 0;


	if(pDevExt->Endpoints[0] == NULL) {	//-1 == closed, other == open
		RtlZeroMemory(&CloseUrb[0],sizeof(URB));
		USB_BUILD_CLOSE_DEFAULT_ENDPOINT((&CloseUrb[0].CloseEndpoint), Arf, 0);
		Device->SubmitRequest(&CloseUrb[0]);
	}
	for(i = 1; i < MAX_ENDPOINTS; i++)	{                                                                            //changed by Bing from 16 to 32
		if(pDevExt->Endpoints[i] != (void*)-1 && pDevExt->Endpoints[i] != (void*)NULL) {
			RtlZeroMemory(&CloseUrb[i],sizeof(URB));
			if(pDevExt->EndpointType[i] == 1) {
				RtlZeroMemory(&StopUrb[i],sizeof(URB));
				USB_BUILD_ISOCH_STOP_TRANSFER((&StopUrb[i].IsochStopTransfer), pDevExt->Endpoints[i]);
				Device->SubmitRequest(&StopUrb[i]);
				USB_BUILD_ISOCH_CLOSE_ENDPOINT((&CloseUrb[i].IsochCloseEndpoint), pDevExt->Endpoints[i], Arf, 0);
			} else {
				USB_BUILD_CLOSE_ENDPOINT((&CloseUrb[i].CloseEndpoint), pDevExt->Endpoints[i], Arf, 0);
			}
			Device->SubmitRequest(&CloseUrb[i]);
		}
	}

	for(i = 0; i < MAX_ENDPOINTS; i++) {
		pDevExt->Endpoints[i] = (void*)-1;
		pDevExt->EndpointType[i] = 0;
	}

	Device->SetExtension(NULL);
	Device->RemoveComplete();

	CXBoxTopology Topo;
	Topo.m_bInterfaceNumber = pDevExt->bInterfaceNumber;
	Topo.m_bPort = pDevExt->bPort;
	Topo.m_bSlot = pDevExt->bSlot;
	gUnpluggedStack[giUnpluggedCount++] = Topo;
	SetEvent(ghEventActivation);
	DBGPRINT(2, ("exit:  SLIX_RemoveDevice\n"));
}

/*************************************************************************************
Function:   SLIX_AddDevice
Purpose:	the actually useful entrypoint of the slixbox driver. Sets up lots of stuff
Params:     DriverObject --- the object slixboxdriver will use...
			RegistryPath --- irrelevant
Return:     STATUS_SUCCESS, or some error code
*************************************************************************************/
VOID SLIX_AddDevice (IN IUsbDevice *Device)
{
    PSLIX_DRIVER_EXTENSION driverExtension;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION pDevExt;
	ULONG ulPort;
    BYTE bSlot,bUSBInterface;
	URB urb;
	int i;
	
    const USB_INTERFACE_DESCRIPTOR    *pInterfaceDescriptor;
	const USB_CONFIGURATION_DESCRIPTOR * pConfigurationDescriptor;
	USB_ENDPOINT_DESCRIPTOR * pEndpoint;
	DBGPRINT(2, ("enter: SLIX_AddDevice\n"));
	ASSERT(Device != NULL /* SLIX_RemoveDevice */);

	driverExtension = gpDriverExtension;

	// get topology so we know where we are plugged in
	ulPort = Device->GetPort();
    bSlot = 0;
    if(ulPort >= 16)
    {
        bSlot = 1;
        ulPort -= 16;
    }

	pInterfaceDescriptor = Device->GetInterfaceDescriptor();
	bUSBInterface = pInterfaceDescriptor->bInterfaceNumber;

	DBGPRINT(3, ("interface Class: %d, interface Subclass: %d , interface number: %d\n", 
		pInterfaceDescriptor->bInterfaceClass,
		pInterfaceDescriptor->bInterfaceSubClass,
		bUSBInterface));

	//if it's an MU or hawk, move it to the next port...
	//(if we didn't do this, it would be impossible ot distinguish top-slot from control pad)
	if((pInterfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_HUMAN_INTERFACE) 
		&& (pInterfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_PHYSICAL_INTERFACE)
		&& (pInterfaceDescriptor->bInterfaceClass != XBOX_DEVICE_CLASS_INPUT_DEVICE)) {
		bSlot++;
	}	

	pDevExt = &driverExtension->Nodes[ulPort][bSlot][bUSBInterface];

	pDevExt->bPort = (BYTE) ulPort;
	pDevExt->bSlot = bSlot;
	pDevExt->bInterfaceNumber = bUSBInterface;


	// Set our DeviceExtension in our CUSB class data
	DBGPRINT(3, ("Device->SetExtension\n"));
	Device->SetExtension(pDevExt);

	for(i = 0; i < MAX_ENDPOINTS; i++)
	{
		pDevExt->Endpoints[i] = (void*)-1;
		pDevExt->EndpointType[i] = 0;
		pDevExt->EndpointSupported[i] = FALSE;
	}

	pConfigurationDescriptor = Device->GetConfigurationDescriptor();

	// fill in endpoint types
	int iTotalLen = pConfigurationDescriptor->wTotalLength;
	BYTE * pTemp = (BYTE *) pConfigurationDescriptor;
	BYTE * pEnd = pTemp + iTotalLen;

	while(pTemp < pEnd)
	{
		pTemp += pTemp[0];
		// now must start examining type, may be multiple interface descriptors
		if(pTemp[1] == 0x05) // check if endpoint
		{
			BYTE bEndpointNumber;
			pEndpoint = (USB_ENDPOINT_DESCRIPTOR *) pTemp;
			bEndpointNumber = pEndpoint->bEndpointAddress & 0x0f;
			pDevExt->EndpointType[bEndpointNumber] = pEndpoint->bmAttributes & 0x03;
			DebugPrint("Endpoint Supported address = %x\n",&pDevExt->EndpointSupported[bEndpointNumber]);
			
			pDevExt->EndpointSupported[bEndpointNumber] = TRUE;
		}
	}

	// save our device class pointer
	pDevExt->Device = Device;
	pDevExt->flags |= DF_CONNECTED;


	// update current topology
	CXBoxTopology Topo;
	Topo.m_bInterfaceNumber = pDevExt->bInterfaceNumber;
	Topo.m_bPort = pDevExt->bPort;
	Topo.m_bSlot = pDevExt->bSlot;

	Device->SetClassSpecificType(1);
	Device->AddComplete(USBD_STATUS_SUCCESS);
	// insert onto notification stack

	gPluggedStack[giPluggedCount++] = Topo;
	SetEvent(ghEventActivation);
	DBGPRINT(2, ("exit:  SLIX_AddDevice\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBDriver\IUSBXBDriver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i_slixdriver.h

Abstract:

    internal header for the SliXbox driver

Author:

    Jason Gould (a-jasgou) July 2000

--*/
#ifndef __i_slixdriver_h_
#define __i_slixdriver_h_

#include "..\inclib\usbxbtransfer.h"
//*****************************************************************************
//**  Defines  ****************************************************************
//*****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif
	ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer
#ifdef __cplusplus
}
#endif



#define SLIX_DRIVER_EXTENSION_ID 0
#define BACK_PORT 0xf					//the number corresponding to the back-port of the xbox 
#define MAX_ENDPOINTS 32                                                                                        //changed by Bing
#define SLIX_MAX_BULK_PACKET_SIZE    0x40	//max bytes that can be transfered in a packet


// PDEVICE_EXTENSION->DeviceFlags state flags
//
//#define DF_MRB_IN_PROGRESS          0x00000002
//#define DF_PERSISTENT_ERROR         0x00000004
//#define DF_RESET_IN_PROGRESS        0x00000008
//#define DF_DEVICE_DISCONNECTED      0x00000010
#define DF_CONNECTED   0x0001
#define DF_INITIALIZED 0x0002


#define INCREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedIncrement((PLONG)&((deviceExtension)->PendingIoCount))

#define DECREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedDecrement((PLONG)&((deviceExtension)->PendingIoCount))

typedef unsigned char BYTE;	
typedef unsigned long DWORD;

typedef struct _DEVICE_EXTENSION
{
    // device class interface to USB core stack
    IUsbDevice                      *Device;
	VOID*							Endpoints[MAX_ENDPOINTS];            //changed by Bing
	UCHAR							EndpointType[MAX_ENDPOINTS];         //changed by Bing
	BOOL							EndpointSupported[MAX_ENDPOINTS];	// added by djk
	DWORD flags;

	BYTE							bPort;
	BYTE							bSlot;
	BYTE							bInterfaceNumber;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct SLIX_DRIVER_EXTENSION {				//driver extension, holds all relevant data
//    USB_PNP_CLASS_DRIVER_DESCRIPTION ClassDescriptionList[16];	//basically unused except in DriverInit
    DEVICE_EXTENSION Nodes[MAX_PORTS][MAX_SLOTS][MAX_INTERFACES]; //[port][slot]		//pointers to the deviceObjects of each possible device
	BYTE LastAddress;								//last device referenced in IN, OUT, or SETUP
}  SLIX_DRIVER_EXTENSION, *PSLIX_DRIVER_EXTENSION;



extern SLIX_DRIVER_EXTENSION * gpDriverExtension;	//pointer to the driver extension is global...

#if DBG || DEBUG_LOG

extern ULONG               DebugFlags;     // DBGF_* Flags
extern ULONG               DebugLevel;     // Level of debug output

#define DBGPRINT(level, _x_) \
    if (level <= DebugLevel) { \
        KdPrint(("SlixD: ")); \
        KdPrint( _x_ ); \
    }


#else

#define DBGPRINT(level, _x_)

#endif



/*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************


NTSTATUS SLIX_Create (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS SLIX_Close (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);


NTSTATUS SLIX_DeviceControl (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID SLIX_StartIo (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//VOID SLIX_TimeoutDpc (IN PKDPC Dpc, IN PVOID Context, IN PVOID SysArg1, IN PVOID SysArg2);



typedef struct _REQUEST {
	BYTE* pData;
	int MaxData;
	
} REQUEST, *PREQUEST;
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBServer\USBXBsock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixboxsock.cpp

Abstract:

    declares networking functions for slixbox to communicate with slix2k

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#ifndef __USBXBTransfer_h_
#define __USBXBTransfer_h_

#define NODSOUND
#include <xtl.h>
#include "..\inclib\USBXBTransfer.h" 

#ifdef __cplusplus
extern "C" {
#include <winsockx.h>
#endif
	ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer
    DWORD WINAPI TestMain();              //our entry-point
	int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow);
#ifdef __cplusplus
}
#endif
//int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend);
//int ssRecv(SOCKET hsock, TRANSFERDATA  * sockdata, int maxrecv, int timeout = RECV_TIMEOUT);
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int len);
SOCKET ssInitServer();
SOCKET ssInitEventServer();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBServer\USBXBsock.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixboxsock.cpp

Abstract:

    winsock routines used on SliXbox

Author:

    Jason Gould (a-jasgou) June 2000

--*/

#include "USBXBsock.h"
#include  "draw.h"


SOCKET			ggSock			= INVALID_SOCKET;;
SOCKET			gEventSock	= INVALID_SOCKET;
HANDLE			gDoRead			= INVALID_HANDLE_VALUE;
HANDLE			gHasRead		= INVALID_HANDLE_VALUE;
HANDLE			gDoQuit			= INVALID_HANDLE_VALUE;
HANDLE			gReadThread 	= INVALID_HANDLE_VALUE;
int				gToRecv			= 0;
SOCKET			gReadSock		= INVALID_SOCKET;
char			gReadData[256];
DWORD WINAPI	ReadThread(LPVOID pParam);

#define XBoxEventsPortNumber 53335

SOCKET ssInitEventServer()
{
	sockaddr_in name;
	SOCKET sock;

	// create a socket
	DebugPrint("Getting socket()\n");
	memset(&name,0x00,sizeof(sockaddr_in)); // clear structure
	gEventSock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if(gEventSock == INVALID_SOCKET) {
		DebugPrint("gEventSock == INVALID_SOCKET), %d\n", WSAGetLastError());
		return 1;
	}

    name.sin_family = AF_INET;
    name.sin_port = htons(XBoxEventsPortNumber);
    name.sin_addr.s_addr = htonl(INADDR_ANY); // (u_long) 0; //(u_long)0x9D370D57?

	DebugPrint("bind()\n");
    if(SOCKET_ERROR == bind(gEventSock, (LPSOCKADDR)&name, sizeof(SOCKADDR))) 
	{
		closesocket(gEventSock);	
		DebugPrint("bind returned SOCKET_ERROR, %d\n", WSAGetLastError());
		return 2;
	}

	DebugPrint("listen()\n");
	if (SOCKET_ERROR == listen(gEventSock, 1)) 
	{
		closesocket(gEventSock);
		DebugPrint("listen returned SOCKET_ERROR, %d\n", WSAGetLastError());
		return 3;
	}

	DebugPrint("USBXBAccept()\n");
	sock = accept(gEventSock, NULL, NULL);
	if(sock == INVALID_SOCKET) 
	{
		closesocket(gEventSock);
		DebugPrint("gSock == INVALID_SOCKET, %d\n", WSAGetLastError());
		return 4;
	}
	DebugPrint("Returning from accept with socket = %x\n", sock);

	return sock;
}

SOCKET ssInitServer()
{
	SOCKET sock;
    XNetStartupParams  XNetParams;
	WSADATA wsadata;
	sockaddr_in name;
	DebugPrint("XNetStartup()\n");
    ZeroMemory(&XNetParams, sizeof(XNetParams));
    XNetParams.cfgSizeOfStruct = sizeof(XNetParams);
    XNetParams.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	XNetStartup(&XNetParams);
	DebugPrint("WSAStartup(2, ..)\n");
	WSAStartup(2, &wsadata);

	DebugPrint("Getting socket()\n");
	ggSock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if(ggSock == INVALID_SOCKET) {
		DebugPrint("ggSock == INVALID_SOCKET), %d\n", WSAGetLastError());
		return 1;
	}

    name.sin_family = AF_INET;
    name.sin_port = htons(XPortNumber);
    name.sin_addr.s_addr = htonl(INADDR_ANY); // (u_long) 0; //(u_long)0x9D370D57?

	DebugPrint("bind()\n");
    if(SOCKET_ERROR == bind(ggSock, (LPSOCKADDR)&name, sizeof(SOCKADDR))) {
		DebugPrint("bind returned SOCKET_ERROR, %d\n", WSAGetLastError());
		return 2;
	}

	// now get local IP address and display a banner
	WCHAR Banner[50];
    XNADDR xnaddr;
    UINT iTimeout = 500;    // Five seconds maximum just in case

	while(XNetGetTitleXnAddr(&xnaddr)== 0 && iTimeout-- > 0) Sleep(10);

	wsprintf(Banner,L"IP Address = %d.%d.%d.%d",
				xnaddr.ina.S_un.S_un_b.s_b1,
				xnaddr.ina.S_un.S_un_b.s_b2,
				xnaddr.ina.S_un.S_un_b.s_b3,
				xnaddr.ina.S_un.S_un_b.s_b4
				);
	

	drCls();
	drPrintf(40,40,Banner);
	drShowScreen();

ListenLine:
	DebugPrint("listen()\n");
	if (SOCKET_ERROR == listen(ggSock, 1)) {
		DebugPrint("listen returned SOCKET_ERROR, %d\n", WSAGetLastError());
		goto ListenLine;
		return 3;
	}

	DebugPrint("USBXBAccept()\n");
	sock = accept(ggSock, NULL, NULL);
	if(sock == INVALID_SOCKET) {
		DebugPrint("gSock == INVALID_SOCKET, %d\n", WSAGetLastError());
		return 4;
	}
	DebugPrint("Returning from accept with socket = %x\n", sock);

	return sock;
}

/*
int ssSend(SOCKET hsock, TRANSFERDATA * sockdata, int tosend)
{
	tosend = sockdata->size;
	int sent = 0;
	int temp;
	while(sent < tosend) {
		temp = send(hsock, &(sockdata->all[sent]), tosend - sent, 0);
		if(temp == SOCKET_ERROR || temp <= 0) {
			DebugPrint("send error: %d\n", WSAGetLastError());
			return 0;
		}
		sent += temp;
	}
	return sent;
}
*/

/*
int ssCloseTCP(SOCKET hsock, TRANSFERDATA * inbuf, int len)
{
	int ret;
	int bytesdone = 0;

	shutdown(hsock, 1);
	ret = 1;
	if(inbuf) {
		if(SOCKET_ERROR == recv(hsock, (char*)inbuf, len, 0)) {
			DebugPrint("recv error: %d\n", WSAGetLastError());
		}
	}
	
	SetEvent(gDoQuit);
//	if(WaitForSingleObject(gHasRead, 100))
//		TerminateThread(gReadThread, 1);

	ret = closesocket(hsock);

	WSACleanup();
	XnetCleanup();	
	return ret;
}
*/

/*
int ssRecv(SOCKET hsock, TRANSFERDATA  * sockdata, int maxrecv, int timeout)
{
	int received = 0;
	gToRecv = maxrecv;
	gReadSock = hsock;
	SetEvent(gDoRead);
	ResetEvent(gHasRead);
	if(WAIT_OBJECT_0 == WaitForSingleObject(gHasRead, timeout)) {
		memcpy((void*)sockdata, (void*)gReadData, sizeof(sockdata));
		return sockdata->size;
	}
	return 0;
}
*/
/*
DWORD WINAPI ReadThread(LPVOID pParam)
{
	int received = 0;
	int temp;
	int torecv;
	SOCKET hsock;
	
	HANDLE events[] = {gDoRead, gDoQuit, gHasRead};

	while(1) {
//		temp = WaitForMultipleObjects(2, events, FALSE, INFINITE);
//		if(WAIT_OBJECT_0 + 1 == temp) { //if we're supposed to quit...
//			SetEvent(gHasRead);
//			break;	//quit
//		}
//		DebugPrint("gDoRead received.\n");
//		ResetEvent(gDoRead);
		memset(gReadData, 0, sizeof(gReadData));

		torecv = gToRecv;
		hsock = gReadSock;

		received = 0;
		do {
			temp = recv(hsock, &gReadData[received], torecv - received, 0);
			DebugPrint("recv() returned %d!", temp);
			torecv = gReadData[0];
			if(temp == 0 || temp == SOCKET_ERROR) {
				listen(hsock, 1);
				accept(hsock, NULL, NULL);
			}
			received += temp;
		} while (received < torecv);
		SetEvent(gHasRead);
	}
	return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\;                         \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Mar-2000

------------------------------------------------------------------------------*/

#ifndef _XLOG_KDX

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef _XBOX

#include <ntos.h>

#include <xtl.h>
#include <xboxp.h>
#include <ldr.h>
#include <xbeimage.h>

#include <xtestlib.h>
#include <xnetref.h>

#else

#include <windows.h>
#include <winsock2.h>
#include <rpc.h>

#endif // _XBOX

#include <stdio.h>

#include <xmem.h>
#include <xlog.h>

#include "util.h"
#include "xlogging.h"

#else

#include <windows.h>
#include <winsock2.h>
#include <rpc.h>
#include <wdbgexts.h>
#include <xboxverp.h>
#include <stdio.h>

#include <xlog.h>
#include "xlogging.h"

#endif // _XLOG_KDX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBServer\USBXBServer.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    USBXBServer.h

Abstract:

    main header file for usb xbox server

Author:

    Jason Gould (a-jasgou) June 2000

--*/
#ifndef __slixbox_h_
#define __slixbox_h_

#define NODSOUND //prevent some weird build break
#include <xtl.h>

#include <winsockx.h>
#include <stdio.h>
#include <time.h>			
#include "USBXBsock.h"

#include "..\inclib\USBXBtransfer.h"



class CListNode
{
public:
	CListNode *		pNext;
	CListNode *		pPrev;
	CXBoxTopology   m_Topology;
};


//#include "usbd.h"

#ifdef __cplusplus
extern "C" {
#endif
	ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer
	int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow);
#ifdef __cplusplus
}
#endif

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)


//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\USBXBOX\USBXBServer\USBXBServer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slixbox.cpp

Abstract:

    slixbox main loop, initialization, and other stuff

Author:

    Jason Gould (a-jasgou) June 2000

--*/



#include "USBXBServer.h"
#include "..\inclib\usbxbdriver.h"
#include  "draw.h"

#pragma warning(disable : 4035)
INT64 __inline GetTime() { 	_asm rdtsc }
#pragma warning(default : 4035)
#define measure(Description, code) {INT64 _ttt1, _ttt2; _ttt1 = GetTime(); code; _ttt2 = GetTime(); DebugPrint(Description ": %I64d\n", (_ttt2 - _ttt1) / 733);}

BYTE UsbdCodeToSliCode(USBD_STATUS u, BOOL isIn);

extern HANDLE ghEventActivation;
extern HANDLE ghInsertionLock;
extern CXBoxTopology gPluggedStack[];
extern int giPluggedCount;
extern CXBoxTopology gUnpluggedStack[];
extern int giUnpluggedCount;
extern HANDLE ghUnplugLock;
extern ULONG gMillisecWait;
extern SOCKET gEventSock;

SOCKET gSock;
CListNode * gActiveDevices = NULL;
BOOL gfKeepAlive = TRUE;



// utility function to maintain linked list of inserted devices


void RecordInsertion(CXBoxTopology * pThisDevice)
{
	CListNode * pNewNode = new CListNode;
	memset(pNewNode,0x00,sizeof(CListNode));
	pNewNode->m_Topology.m_bPort = pThisDevice->m_bPort;
	pNewNode->m_Topology.m_bSlot = pThisDevice->m_bSlot;
	pNewNode->m_Topology.m_bInterfaceNumber = pThisDevice->m_bInterfaceNumber;

	if(NULL == gActiveDevices)
	{
		gActiveDevices = pNewNode;
	} else
	{
		// go to end of list
		CListNode * pCurrNode = gActiveDevices;
		while(pCurrNode->pNext)
		{
			pCurrNode = pCurrNode->pNext;
		}
		pCurrNode->pNext = pNewNode;
		pNewNode->pPrev = pCurrNode;
	}

}

void RecordRemoval(CXBoxTopology * pThisDevice)
{

	// first check to see if it's on the inserted device list.  If so
	// ... we just remove it from the inserted list and forget about it
	CListNode * pTempNode = gActiveDevices;
	while(pTempNode)
	{
		if(pTempNode->m_Topology.m_bPort == pThisDevice->m_bPort &&
			pTempNode->m_Topology.m_bSlot == pThisDevice->m_bSlot &&
			pTempNode->m_Topology.m_bInterfaceNumber == pThisDevice->m_bInterfaceNumber)
		{
			// found a match, remove from insertion list
			CListNode * pBack = pTempNode->pPrev;
			CListNode * pNext = pTempNode->pNext;
			delete pTempNode; // free removed node
			if(NULL == pBack) 
			{
				// this is top of list
				if(pNext)
				{
					pNext->pPrev = NULL;
				}
				gActiveDevices = pNext;
			} else
			{
				// link around this one to remove
				pBack->pNext = pNext;
				if(pNext)
				{
					pNext->pPrev = pBack;
				}
			}
			return;
			
		}
		pTempNode = pTempNode->pNext;
	}
}


void EventNotifier()
{
	SOCKET sEventSocket;
	CEventPacket ThePacket;
	BYTE bPort,bSlot,bInterfaceNumber;
	int index, iEventCode, iEventCount;
	CXBoxTopology * pThisDevice;
	// open and connect port to pc
	sEventSocket = ssInitEventServer();


	while(gfKeepAlive)
	{

		while(1) // loop to handle ongoing event notifications
		{
			DebugPrint("Waiting for event to report\n");
			WaitForSingleObject(ghEventActivation,INFINITE);
CheckNextEvent:
			WaitForSingleObject(ghInsertionLock,INFINITE);			
			if(giPluggedCount)
			{
				index = --giPluggedCount;
				pThisDevice = &gPluggedStack[index];
				// update active devices list
				RecordInsertion(pThisDevice);

				iEventCode = eInsertionEvent;
			} else
			{
				WaitForSingleObject(ghUnplugLock,INFINITE);
				if(giUnpluggedCount)
				{
					index = --giUnpluggedCount;
					pThisDevice = &gUnpluggedStack[index];
					// update active devices list
					RecordRemoval(pThisDevice);
					iEventCode = eRemovalEvent;
				} else
				{
					ReleaseMutex(ghUnplugLock);
					continue;
				}
				ReleaseMutex(ghUnplugLock);
			}
			ReleaseMutex(ghInsertionLock);


			ThePacket.m_iEventCode = iEventCode;
			ThePacket.m_ulErrorCode = 0;
			ThePacket.m_Topology.m_bInterfaceNumber = pThisDevice->m_bInterfaceNumber;
			ThePacket.m_Topology.m_bPort = pThisDevice->m_bPort;
			ThePacket.m_Topology.m_bSlot = pThisDevice->m_bSlot;
			ReleaseMutex(ghInsertionLock);
			DebugPrint("Reporting Insertion event Port %d Slot %d Interface %d\n",
							ThePacket.m_Topology.m_bPort,
							ThePacket.m_Topology.m_bSlot,
							ThePacket.m_Topology.m_bInterfaceNumber);

ResendEvent:
			int iResult = send(sEventSocket,(char *) &ThePacket,sizeof(CEventPacket),0);
			if(SOCKET_ERROR == iResult)
			{
				// only error we're expecting is due to a disconnect from the pc
				// dispose of this socket and reestablish a new link
				goto RestartEvents;
			}
			goto CheckNextEvent; // catch any doubled up insertions

		}

RestartEvents:
		// got here due to Winsock error, reestablish connection and resume event looping
		DebugPrint("Evemt send failed, error %d\n", WSAGetLastError());
		if (SOCKET_ERROR == closesocket(sEventSocket))	{
			DebugPrint("closesocket failed, error %d\n", WSAGetLastError());
		}
/*		if (SOCKET_ERROR == listen(gEventSock, 1)) {
			DebugPrint("listen failed, error %d\n", WSAGetLastError());
		}
*/		sEventSocket = accept(gEventSock, NULL, NULL);
		if(sEventSocket == INVALID_SOCKET) {
			DebugPrint("accept failed, error %d\n", WSAGetLastError());
		}
		goto ResendEvent; // retry event which failed

	} // while
	// wait for notification events from add and remove routines
	// send to pc
	// loop
}

//
//  Call USB's init function directly since we do not link to xapi.
//

/*************************************************************************************
Function:   init
Purpose:	do all initialization for slixbox
Params:     none
Return:     0 if good, non-0 if bad
*************************************************************************************/
int init()
{
	gSock = ssInitServer();
	// Initiate event handling thread
	CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)EventNotifier,NULL,0,NULL);
	return 0;
}

extern SOCKET		ggSock;
extern SOCKET		gEventSock;
#define SETUP_IN	1
#define SETUP_OUT	2
#define SETUP_NONE	0

typedef struct {
	char * data2;		//to be malloced as needed. Holds the big data buffer
	char data[8];		//the main setup packet
	long datasize;		//size of data[]
	BYTE type;			//SETUP_IN, SETUP_OUT, or SETUP_NONE, depending on the type of setup
	USHORT expected;	//total size of data2, the number of bytes to send to either islixboxd or slix
	USHORT current;		//number of bytes sent so far to islixboxd or slix
} SetupBuffer;

typedef struct _QUEUE {
	struct _QUEUE* next;
	TRANSFERDATA * d;
} QUEUE, *PQUEUE;

QUEUE q = {0,0};

SetupBuffer sbs[MAX_PORTS][MAX_SLOTS][MAX_INTERFACES][16];	//[PORT][SLOT][INTERFACE][endpoint] //////port //slot //endpoint

typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

BYTE parse(TRANSFERDATA * c, BOOL isqueue) 
{
	TRANSFERDATA t;
	SetupBuffer *tempsb;
	USBD_STATUS temp;
	int i;
	USHORT sTemp = 0;
	int size;
	static int slixdout=0,slixdin=0;
	memset(&t,0x00,sizeof(TRANSFERDATA));
	
	switch(c->type) 
	{	//the type of packet we receive
		case PID_INIT_IN:	//a request for an IN
			if(sbs[c->initin.Port][c->initin.Slot][c->initin.interfacenumber][c->initin.endpoint].type != SETUP_IN) {
				if(c->initin.endpoint == 0) // no IN's on the control endpoint
				{
					t.in.ret = XSTATUS_UserError;
					t.size = sizeof(TRANSFER_IN);
					temp = send(gSock,(char*)&t,t.size,0);
					break;

				} else 
				{
					//normal in request... (no setup packet buffering)
					//send in the request!
					slixdin++;
					temp = SlixdIn(c->initin.Port,c->initin.Slot, c->initin.interfacenumber,c->initin.endpoint,&t.in.data[0], &c->initin.max);
					t.in.ret = UsbdCodeToSliCode(temp, TRUE);	//prepare the return code
	//				DebugPrint("Printing from Slixbox.cpp->parse->IN, Slixdout=%d, Slixdin=%d\n", slixout, slixdin);
	//				DebugPrint("from SlixdIn, code %02x, data %d %016I64x\n", t.in.ret, c->initin.max, *(__int64*)&t.in.data[0]);
				}

				t.type = PID_IN;							//and the type of packet we're sending back
				t.size = c->initin.max + sizeof(TRANSFER_IN);//size of packet we're sending

				if(isqueue) return t.in.ret;

				temp = send(gSock, (char*)&t, t.size, 0);			//send the packet

	//				DebugPrint("send returned %d\n", temp);
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
				break;										//and go back to the main loop again
				
			} else 
			{
				//DebugPrint("buffered in...\n");
				//we're doing setup packet buffering for this address!
				tempsb = &sbs[c->initin.Port][c->initin.Slot][c->initin.interfacenumber][c->initin.endpoint];

				t.size = (sizeof(TRANSFER_IN) +	//size of the packet to send...
					min((signed)c->initin.max, (tempsb->expected - tempsb->current)));

				t.type = PID_IN;	//type of the packet to send
				t.in.ret = XSTATUS_Success;	//"handshake" to send back

				if (tempsb->current >= tempsb->expected && ((t.size - sizeof(TRANSFER_IN)) < 8)) {	//if we've sent all the data...
					//DebugPrint("All data sent. (current %d, expected %d) Setup packet is completed...\n", tempsb->current, tempsb->expected);
					free(tempsb->data2);					//free our buffer
					tempsb->data2 = NULL;
					tempsb->type = SETUP_NONE;				//and stop buffering this endpoint
				}


				for(i = 0; i < (signed)t.size - (signed)sizeof(TRANSFER_IN); i++) {		//copy the data to the slixboxsock buffer
					t.in.data[i] = tempsb->data2[tempsb->current++];
				}
				
				if(isqueue) return t.in.ret;

				temp = send(gSock, (char*)&t, t.size, 0);				//& send that data !
	//				DebugPrint("send returned %d\n", temp);
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

				break;
			}

		case PID_OUT:
			if(sbs[c->out.Port][c->out.Slot][c->out.interfacenumber][c->out.endpoint].type != SETUP_OUT) {
				//normal OUT operation
	//				DebugPrint("Out request received\n");

				//send the data out!
				slixdout++;
				temp = SlixdOut(c->out.Port,c->out.Slot,c->out.interfacenumber, c->out.endpoint, c->out.data, c->out.size - sizeof(c->out));

				t.ret.ret = UsbdCodeToSliCode(temp, FALSE);		//get our return code
				

				t.type = PID_RET;								//prepare our packet
				t.size = sizeof(TRANSFER_RETURN);				//size of the packet

				if(isqueue) return t.ret.ret;
				
				temp = send(gSock, (char*)&t, t.size, 0);		// & send the packet!
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
				break;

			} else {
				//DebugPrint("Buffered Out...\n");
				//we're doing SETUP packet buffering...
				tempsb = &sbs[c->out.Port][c->out.Slot][c->out.interfacenumber][c->out.endpoint];

				c->out.size = min((signed)c->out.size, (tempsb->expected - tempsb->current)); //so we don't over-run data2
	//                       (signed)c->out.size - (signed)sizeof(TRANSFER_OUT); i++){	//copy the data into the buffer for islixboxd
				for(i=0; i < (signed)c->out.size; i++){	//copy the data into the buffer for islixboxd
					tempsb->data2[tempsb->current++] = c->out.data[i];
				}

				//if we have enough to send...
				if(tempsb->current >= tempsb->expected) {
					//DebugPrint("Sending our buffer, %d bytes", tempsb->expected);
					//sned the stuff to islixboxd
					temp = SlixdSetup(c->out.Port,c->out.Slot,c->out.interfacenumber, c->out.endpoint, 
						tempsb->data, tempsb->datasize, 
						tempsb->data2, &tempsb->expected);

					free(tempsb->data2);	//release the data buffer
					tempsb->data2 = NULL;
					tempsb->type = SETUP_NONE;	//and stop buffering this endpoint

					t.ret.ret = UsbdCodeToSliCode(temp, FALSE); //prepare the return value

					t.type = PID_RET;							//prepare the slixboxsock packet ...
					t.size = sizeof(TRANSFER_RETURN);
					
					if(isqueue) return t.ret.ret;

					temp = send(gSock, (char*)&t, t.size, 0);	//send that packet
					if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

					break;
				} else {
					//DebugPrint("Bytes collected: %d, bytes expected: %d\n", tempsb->current, tempsb->expected);
					//produce a fake packet to send back, so recv is happy on slix.
					t.ret.ret = XSTATUS_Ack;


					t.type = PID_RET;
					t.size = sizeof(TRANSFER_RETURN);
					
					if(isqueue) return t.ret.ret;

					temp = send(gSock, (char*)&t, t.size, 0);
					if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
					break;
				}
			}

		case PID_SETUP:
	//			DebugPrint("PID_SETUP received");

			sTemp = *(USHORT*)&(c->setup.data[6]); //get the USHORT stored starting at &data[6]
			tempsb = &sbs[c->setup.Port][c->setup.Slot][c->setup.interfacenumber][c->setup.endpoint];
			size = c->setup.size - sizeof(c->setup);

			if(sTemp == 0 ) {
				//this is a "no-data" setup transfer (just the setup packet)
	//			DebugPrint("no-data setup transfer.\n");

				//send our data!
	//				DebugPrint("SlixBox Setup: address %x, endpoint %x, data %16I64x, size %d, size2 %d", c->setup.address, c->setup.endpoint, *(INT64*)c->setup.data, size, sTemp);
				temp = SlixdSetup(c->setup.Port,c->setup.Slot,c->setup.interfacenumber,c->setup.endpoint, c->setup.data, size, NULL, &sTemp);
	//				DebugPrint("SlixdSetup returned %x", temp);

				t.ret.ret = UsbdCodeToSliCode(temp, FALSE);	//prepare the return value
				

				t.type = PID_RET;							//and prepare the return packet
				t.size = sizeof(TRANSFER_RETURN);

				if(isqueue) return t.ret.ret;
				
				temp = send(gSock, (char*)&t, t.size, 0);			//send the return packet
				if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
				break;

			} else {
				//this setup transfer requires some data!
	//			DebugPrint("setup requires data.\n");

				if(tempsb->data2) {			//if we didn't get around to freeing the data before... (it could happen)
					free(tempsb->data2);	//do it now...
					tempsb->data2 = NULL;
				}

				//prepare the setup buffering structure
				
				tempsb->expected = *(USHORT*)&c->setup.data[6];				//size of data2 to buffer
				tempsb->data2 = (char*)malloc(*(USHORT*)&c->setup.data[6]);	//create that buffer
				tempsb->current = 0;										//we haven't collected any yet!

				if(c->setup.data[0] & 0x80) {								
					//this is a SETUP_IN transfer, so we do the INs now, & send data to slix when requested

					tempsb->type = SETUP_IN;		

					//send the setup packet, get the data back
					temp = SlixdSetup(c->setup.Port,c->setup.Slot,c->setup.interfacenumber, c->setup.endpoint, c->setup.data, size, 
						tempsb->data2, &tempsb->expected);

	//				DebugPrint("Setup requires INs. %d bytes buffered.\n", tempsb->expected);

				} else {
					//this is a SETUP_OUT transfer, so we will wait to collect the data from the user.

					//store our setup packet
					for(i = 0; i < size; i++) {
						tempsb->data[i] = c->setup.data[i];
					}
					tempsb->datasize = size;		//size of the setup packet
					tempsb->type = SETUP_OUT;

					temp = USBD_STATUS_SUCCESS;		//bogus return value ... 
				}
			}
		
			t.ret.ret = UsbdCodeToSliCode(temp, FALSE);	//convert the return code


			t.type = PID_RET;							//prepare the return packet
			t.size = sizeof(TRANSFER_RETURN);
			
			if(isqueue) return t.ret.ret;

			temp = send(gSock, (char*)&t, t.size, 0);	//send the return packet	
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;
	  case PID_RESET:
			temp = SlixdReset(c->reset.Port,c->reset.Slot,c->reset.interfacenumber);

			t.ret.ret = UsbdCodeToSliCode(temp, TRUE);


			t.type = PID_RET;
			t.size = sizeof(TRANSFER_RETURN);

			if(isqueue) return t.ret.ret;
			
			temp = send(gSock, (char*)&t, t.size, 0);
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());

			break;
		case PID_SET_USB_TIMEOUT:
		{
			gMillisecWait = c->UsbTimeout.ulTimeoutValue;
			t.ret.ret = 0;


			t.type = PID_RET;
			t.size = sizeof(TRANSFER_RETURN);

			
			temp = send(gSock, (char*)&t, t.size, 0);
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;
		}
		case PID_GET_DEVICE_STATE:
		{
			t.ret.ret = 0; // return ok status
			t.type = PID_GET_DEVICE_STATE;
			BYTE bDeviceCount = 0;
			// build response array
			// first report current configuration to deliver
			CListNode * pCurrTop = gActiveDevices;
			while(pCurrTop)
			{
				// found an active device, send notification
				t.DeviceState.TopArray[bDeviceCount].bInterfaceNumber =  pCurrTop->m_Topology.m_bInterfaceNumber;
				t.DeviceState.TopArray[bDeviceCount].bPort = pCurrTop->m_Topology.m_bPort;
				t.DeviceState.TopArray[bDeviceCount].bSlot = pCurrTop->m_Topology.m_bSlot;
				bDeviceCount++;
				pCurrTop = pCurrTop->pNext;
			}
			t.DeviceState.bDeviceCount = bDeviceCount;
			// send reply
			t.size = sizeof(TRANSFER_RETURN) + sizeof(TRANSFER_DEVICE_STATE) + (sizeof(Topology) * bDeviceCount);
			temp = send(gSock, (char*)&t, t.size, 0);
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			break;
		}

		default:
			DebugPrint("ssRecv received data of unknown type 0x%02x.\n", c->type);
			return XSTATUS_TransmissionError;
			break;
	}
	return XSTATUS_Success;
}

/*************************************************************************************
Function:   main
Purpose:	entrypoint, main loop, etc
Params:     none
Return:     it shouldn't ever... this is an xbox app.
*************************************************************************************/
void __cdecl main()
{
	TRANSFERDATA c;	//in-bound stuff

	TRANSFERDATA t;	//out-bound stuff

    XInitDevices(0,NULL);
	
	DebugPrint("sizeof(TRANSFERDATA) (should be 256): %d\n", sizeof(TRANSFERDATA));

 	DebugPrint("SliXbox has begun!\n");
	int r;
	int count = 3;
	USHORT sTemp = 0;
	int size;
	int i;
	SetupBuffer *tempsb;
	USBD_STATUS temp;
	int queue = 0;
	QUEUE *pq, *pq2;
	BYTE NakIsOK;

	//[topology][endpoint] // even though endpoint should only be 0...
	//this holds all the stuff for the setup packet "buffering"
	
	memset(sbs, 0, sizeof(sbs));//zero the sbs array

	drInit();
	while ((r = init()) != 0) {	//keep trying to init since there is no point in quitting
		DebugPrint("init failed with return value %d. Trying again.\n", r);
		Sleep(2000);
	}
	
	DebugPrint("init worked!\n");

	while(1) {
		memset(&c,0x00,sizeof(c));
		DebugPrint("Waiting on recv in main\n");
		temp = recv(gSock, (char*)&c, 256, 0);

		if(temp <= 0) {

			DebugPrint("recv failed in main resetting, error %d\n", WSAGetLastError());
			if (SOCKET_ERROR == closesocket(gSock))	{
				DebugPrint("closesocket failed, error %d\n", WSAGetLastError());
			}
/*			if (SOCKET_ERROR == listen(ggSock, 1)) {
				DebugPrint("listen failed, error %d\n", WSAGetLastError());
			}
			
*/			DebugPrint("Waiting on accept in main\n");
			gSock = accept(ggSock, NULL, NULL);
			if(gSock == INVALID_SOCKET) {
				DebugPrint("accept failed, error %d\n", WSAGetLastError());
			}

			continue;
		} else {
		}

		switch(c.type) {	//the type of packet we receive
		case PID_BEGIN_QUEUE:
			if(queue) {
				DebugPrint("Error! Queue already in progress!\n");
				break;
			}
			NakIsOK = c.beginqueue.successonnak;
			queue = 1;
			pq = &q;
			break;
		case PID_INIT_END_QUEUE:
			t.type = PID_RETURN_END_QUEUE;
			t.size = sizeof(TRANSFER_RETURN_END_QUEUE);
			t.retendqueue.linefailed = 0;
			t.retendqueue.ret = XSTATUS_Success;
			if(!queue) {
				DebugPrint("Error! no queue to end!\n");
				break;
			}
			for(pq = q.next; pq;)	{
				if(0 == t.retendqueue.linefailed) {
					temp = parse((TRANSFERDATA*)pq->d, TRUE);
				}
				pq2 = pq;
				pq = pq->next;
				free(pq2);
                pq2 = NULL;
				if((temp == XSTATUS_Ack) || (temp == XSTATUS_Success) || ((temp == XSTATUS_Nak) && NakIsOK)) {
				} else {
					t.retendqueue.linefailed = queue;
					t.retendqueue.ret = (BYTE)temp;
				}
				queue++;
			}
			temp = send(gSock, (char*)&t, t.size, 0);			//send the packet
			if(temp <= 0) DebugPrint("send error: %d\n", WSAGetLastError());
			queue = 0;
			break;
		default:
			if(queue == 0) {
				parse(&c, FALSE);
			} else {
				pq->next = (QUEUE*)malloc(sizeof(QUEUE));
				pq = pq->next;
				pq->next = 0;
				pq->d = (TRANSFERDATA*)malloc(c.size);
				memcpy(pq->d, &c, c.size);
			}
			break;
		}

	} 
}



/*************************************************************************************
Function:   UsbdCodeToSliCode
Purpose:	convert status codes from usbd to slix
Params:		u --- the usbd status code to convert
			isIn --- TRUE if this code is from an IN, FALSE if it is from an OUT or SETUP
Return:		the sli status code
Note:		if (isIn), USBD_STATUS_SUCCESS becomes STATUS_Success, otherwise, XSTATUS_Ack
*************************************************************************************/
BYTE UsbdCodeToSliCode(USBD_STATUS u, BOOL isIn)
{
	switch (u)
	{
	case USBD_STATUS_SUCCESS:
		if(isIn)
			return XSTATUS_Success;
		else
			return XSTATUS_Ack;
	case USBD_STATUS_PENDING:
	case 0xC000000F:			//this "error" doesn't seem to be defined anywhere, 
								//but it is sent to the callback when the request is cancelled.
		return XSTATUS_Nak;

	case USBD_STATUS_CRC:
		return XSTATUS_DataCRCError;
	case USBD_STATUS_BTSTUFF:
		return XSTATUS_SyncError;
	case USBD_STATUS_DATA_TOGGLE_MISMATCH:
		return XSTATUS_DataToggleError;
	case USBD_STATUS_STALL_PID:
		return XSTATUS_Stall;
	case USBD_STATUS_PID_CHECK_FAILURE:
	case USBD_STATUS_UNEXPECTED_PID:
		return XSTATUS_PIDError;
	case USBD_STATUS_DATA_OVERRUN:
		return XSTATUS_ShortPacketError;
	case USBD_STATUS_DATA_UNDERRUN:
		return XSTATUS_ShortPacketError;

	case USBD_STATUS_HALTED:
		DebugPrint("Usbd error: halted 0x%x\n", u);
		goto narf;
	case USBD_STATUS_DEV_NOT_RESPONDING:
		DebugPrint("Usbd error: dev_not_responding 0x%x\n", u);
		goto narf;
	case USBD_STATUS_ERROR:
		DebugPrint("Usbd error: \"ERROR\" 0x%x\n", u);
		goto narf;
	case USBD_STATUS_RESERVED1:
		DebugPrint("Usbd error: reserved1 0x%x\n", u);
		goto narf;
	case USBD_STATUS_RESERVED2:
		DebugPrint("Usbd error: reserved2 0x%x\n", u);
		goto narf;
	case USBD_STATUS_BUFFER_OVERRUN:
		DebugPrint("Usbd error: buffer_overrun 0x%x\n", u);
		goto narf;
	case USBD_STATUS_BUFFER_UNDERRUN:
		DebugPrint("Usbd error: buffer_underrun 0x%x\n", u);
		goto narf;
	case USBD_STATUS_NOT_ACCESSED:
		DebugPrint("Usbd error: not_accessed 0x%x\n", u);
		goto narf;
	case USBD_STATUS_FIFO:
		DebugPrint("Usbd error: fifo 0x%x\n", u);
		goto narf;
	default:
		DebugPrint("Unknown usbd error! 0x%x\n", u);
narf:
		return XSTATUS_ConfigurationError;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 13-Mar-2000

------------------------------------------------------------------------------*/

#pragma once



namespace xLogNamespace {

// Function prototypes

LPWSTR
MultiByteToUnicodeString(
    IN  HANDLE  hMemObject,
    IN  LPSTR   lpszString_A
);

LPSTR
UnicodeToMultiByteString(
    IN  HANDLE  hMemObject,
    IN  LPWSTR  lpszString_W
);

BOOL
FormatAndWriteString(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszFormatString_A,
    IN  ...
);

BOOL
LogBanner(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszTitleString_A,
    IN  LPSTR   lpszLogString_A
);

SOCKET
ConnectWebServer(
    IN  u_long  HttpAddr
);

BOOL
PostString(
    IN  SOCKET  sWebSocket,
    IN  LPSTR   szString_A,
    IN  DWORD   dwStringLen
);

VOID
PostResult(
    IN  HANDLE  hLog,
    IN  DWORD   dwVariationResult,
    IN  LPSTR   lpszComponentName_A,
    IN  LPSTR   lpszSubcomponentName_A,
    IN  LPSTR   lpszFunctionName_A,
    IN  LPSTR   lpszVariationName_A,
    IN  LPSTR   lpszLogString_A
);

VOID
IncrementVariationResult(
    IN  HANDLE  hLog,
    IN  DWORD   dwVariationResult,
    IN  BOOL    bIncrementTotal
);

BOOL
AddRefNet(
);

VOID
ReleaseNet(
);

LPSTR
GetHostName(
    IN HANDLE  hMemObject
);

} // namespace xLogNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xlog.dll

Author:

  Steven Kehrli (steveke) 13-Mar-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace xLogNamespace {

LPWSTR
MultiByteToUnicodeString(
    IN  HANDLE  hMemObject,
    IN  LPSTR   lpszString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Converts a multi-byte string to a UNICODE string

Arguments:

  hMemObject - Handle to the memory object for memory allocation
  lpszString_A - Pointer to a null-terminated multi-byte string

Return Value:

  LPWSTR:
    If the function succeeds, the return value is a pointer to the null-terminated UNICODE string
    If the function fails, the return value is NULL

------------------------------------------------------------------------------*/
{
    // lpszString_W is the UNICODE equivalent of lpszString_A
    LPWSTR    lpszString_W = NULL;
    // dwBufferSize is the size of the UNICODE string
    DWORD     dwBufferSize = 0;

    // NtStatus is the nt status code returned by RtlMultiByteToUnicodeString()
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    // dwErrorCode is the win32 error code represented by NtStatus
    DWORD     dwErrorCode = ERROR_SUCCESS;



    // Get the size of the lpszString_W string
    NtStatus = RtlMultiByteToUnicodeSize(&dwBufferSize, lpszString_A, strlen(lpszString_A) + 1);

    if (!NT_SUCCESS(NtStatus)) {
        // Get the last error code
        dwErrorCode = RtlNtStatusToDosError(NtStatus);

        goto FunctionFailed0;
    }

    // Allocate the memory for the lpszString_W string
    lpszString_W = (LPWSTR) xMemAlloc(hMemObject, dwBufferSize);

    if (NULL == lpszString_W) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed0;
    }

    // Get the lpszString_W string
    NtStatus = RtlMultiByteToUnicodeN(lpszString_W, dwBufferSize, NULL, lpszString_A, strlen(lpszString_A) + 1);

    if (!NT_SUCCESS(NtStatus)) {
        // Get the last error code
        dwErrorCode = RtlNtStatusToDosError(NtStatus);

        goto FunctionFailed1;
    }

    return lpszString_W;

FunctionFailed1:
    // Free the lpszString_W string
    xMemFree(hMemObject, lpszString_W);

FunctionFailed0:
    // Set the last error code
    SetLastError(dwErrorCode);

    return NULL;
}



LPSTR
UnicodeToMultiByteString(
    IN  HANDLE  hMemObject,
    IN  LPWSTR  lpszString_W
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Converts a UNICODE string to a multi-byte string

Arguments:

  hMemObject - Handle to the memory object for memory allocation
  lpszString_W - Pointer to a null-terminated UNICODE string

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to a null-terminated multi-byted string
    If the function fails, the return value is NULL

------------------------------------------------------------------------------*/
{
    // lpszString_A is the multi-byte equivalent of lpszString_W
    LPSTR     lpszString_A = NULL;
    // dwBufferSize is the size of the multi-byte string
    DWORD     dwBufferSize = 0;

    // NtStatus is the nt status code returned by RtlMultiByteToUnicodeString()
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    // dwErrorCode is the win32 error code represented by NtStatus
    DWORD     dwErrorCode = ERROR_SUCCESS;



    // Get the size of the lpszString_A string
    NtStatus = RtlUnicodeToMultiByteSize(&dwBufferSize, lpszString_W, (wcslen(lpszString_W) + 1) * sizeof(WCHAR));

    if (!NT_SUCCESS(NtStatus)) {
        // Get the last error code
        dwErrorCode = RtlNtStatusToDosError(NtStatus);

        goto FunctionFailed0;
    }

    // Allocate the memory for the lpszString_A string
    lpszString_A = (LPSTR) xMemAlloc(hMemObject, dwBufferSize);

    if (NULL == lpszString_A) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed0;
    }

    // Get the lpszString_A string
    NtStatus = RtlUnicodeToMultiByteN(lpszString_A, dwBufferSize, NULL, lpszString_W, (wcslen(lpszString_W) + 1) * sizeof(WCHAR));

    if (!NT_SUCCESS(NtStatus)) {
        // Get the last error code
        dwErrorCode = RtlNtStatusToDosError(NtStatus);

        goto FunctionFailed1;
    }

    return lpszString_A;

FunctionFailed1:
    // Free the lpszString_A string
    xMemFree(hMemObject, lpszString_A);

FunctionFailed0:
    // Set the last error code
    SetLastError(dwErrorCode);

    return NULL;
}



BOOL
FormatAndWriteString(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszFormatString_A,
    IN  ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Formats and writes a string to the log file

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszFormatString_A - Pointer to a null-terminated string (ANSI) that consists of format-control specifications

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;
    // varg_ptr is a pointer to the variable argument list
    va_list       varg_ptr = NULL;
    // szOutputString_A is the line of log output
    CHAR          szOutputString_A[1025] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD         dwBytesWritten = 0;
    // bReturnValue is the return value of this function
    BOOL          bReturnValue = TRUE;



    // Get the variable argument list
    va_start(varg_ptr, lpszFormatString_A);
    _vsnprintf(szOutputString_A, 1024, lpszFormatString_A, varg_ptr);

#ifdef _XBOX
    // Wait for access to the console socket critical section
    EnterCriticalSection(pLogObject->pConsoleSocketcs);

    // Echo the line to the remote console, if specified
    if (INVALID_SOCKET != pLogObject->sConsoleSocket) {
        if (SOCKET_ERROR == send(pLogObject->sConsoleSocket, szOutputString_A, strlen(szOutputString_A), 0)) {
            goto FunctionExit;
        }
    }

    // Release access to the console socket critical section
    LeaveCriticalSection(pLogObject->pConsoleSocketcs);
#endif

    // Write the line to the log file, if specified
    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        if (FALSE == WriteFile(pLogObject->hLogFile, szOutputString_A, strlen(szOutputString_A), &dwBytesWritten, NULL)) {
            goto FunctionExit;
        }
    }

    // Echo the line to the debugger, if specified
    if (0 != (XLO_DEBUG & pLogObject->dwLogOptions)) {
        OutputDebugStringA(szOutputString_A);
    }

    bReturnValue = TRUE;

FunctionExit:
    return bReturnValue;
}



BOOL
LogBanner(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszTitleString_A,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs a banner

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszTitleString_A - Pointer to a null-terminated string (ANSI) that specifies the title string
  lpszLogString_A - Pointer to a null-terminated string (ANSI) that specifies the log string

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // LocalTime is the current local time in hours, minutes, seconds, etc.
    SYSTEMTIME  LocalTime;



    // Get the current time
    GetLocalTime(&LocalTime);

    // Write the banner to the log file
    if (NULL == lpszLogString_A) {
        return FormatAndWriteString(hLog, "\r\n**********\r\n%s,%02d/%02d/%04d,%02d:%02d:%02d\r\n**********\r\n", lpszTitleString_A, LocalTime.wMonth, LocalTime.wDay, LocalTime.wYear, LocalTime.wHour, LocalTime.wMinute, LocalTime.wSecond);
    }

    return FormatAndWriteString(hLog, "\r\n**********\r\n%s,%02d/%02d/%04d,%02d:%02d:%02d\r\n%s**********\r\n", lpszTitleString_A, LocalTime.wMonth, LocalTime.wDay, LocalTime.wYear, LocalTime.wHour, LocalTime.wMinute, LocalTime.wSecond, lpszLogString_A);
}



SOCKET
ConnectWebServer(
    IN  u_long  HttpAddr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Connects to the web server

Arguments:

  HttpAddr - Address of the web server

Return Value:

  SOCKET:
    If the function succeeds, the return value is a valid socket descriptor.
    If the function fails, the return value is INVALID_SOCKET.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // sWebSocket is the web socket
    SOCKET        sWebSocket = INVALID_SOCKET;
    // webname is the address and port of the web server
    SOCKADDR_IN   webname = {AF_INET, 0, 0, 0};
    // szDebugString is the debug string
    CHAR          szDebugString[61];
    // dwErrorCode is the win32 error code
    DWORD         dwErrorCode = ERROR_SUCCESS;


    
    // Setup the web address and port
    webname.sin_port = htons(80);
    webname.sin_addr.s_addr = HttpAddr;

    // Create the connection
    sWebSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == sWebSocket) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        sprintf(szDebugString, "xLog: Cannot create the web socket - ec = %u\r\n", dwErrorCode);
        OutputDebugStringA(szDebugString);
    }
    // Connect to the web server
    else if (SOCKET_ERROR == connect(sWebSocket, (SOCKADDR *) &webname, sizeof(webname))) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        sprintf(szDebugString, "xLog: Cannot connect to the web server - ec = %u\r\n", dwErrorCode);
        OutputDebugStringA(szDebugString);

        closesocket(sWebSocket);
        sWebSocket = INVALID_SOCKET;
    }

    if (ERROR_SUCCESS != dwErrorCode) {
        SetLastError(dwErrorCode);
    }

    return sWebSocket;
}



BOOL
PostString(
    IN  SOCKET  sWebSocket,
    IN  LPSTR   szString_A,
    IN  DWORD   dwStringLen
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sends a string to the web server

Arguments:

  sWebSocket - Web socket descriptor
  szString_A - Pointer to a null-terminated string (ANSI)
  dwStringLen - Specifies the length of the string

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // webname is the address and port of the web server
    SOCKADDR_IN   webname = {AF_INET, 0, 0, 0};
    // dwErrorCode is the win32 error code
    DWORD         dwErrorCode = ERROR_SUCCESS;



    // Send the web post
    if (SOCKET_ERROR == send(sWebSocket, szString_A, dwStringLen, 0)) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        closesocket(sWebSocket);
    }
    // Receive the web post
    else if (SOCKET_ERROR == recv(sWebSocket, szString_A, dwStringLen, 0)) {
        // Get the last error code
        dwErrorCode = WSAGetLastError();

        closesocket(sWebSocket);
    }
    
    if (ERROR_SUCCESS != dwErrorCode) {
        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return (ERROR_SUCCESS == dwErrorCode);
}



VOID
PostResult(
    IN  HANDLE  hLog,
    IN  DWORD   dwVariationResult,
    IN  LPSTR   lpszComponentName_A,
    IN  LPSTR   lpszSubcomponentName_A,
    IN  LPSTR   lpszFunctionName_A,
    IN  LPSTR   lpszVariationName_A,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Posts a string to the web server

Arguments:

  hLog - Handle to the XLOG_OBJECT
  dwVariationResult - Specifies the logging level for this line of output.  It can be one of the XLL_ #defines.
  lpszComponentName_A - Pointer to a null-terminated string (ANSI) that specifies the component name
  lpszSubcomponentName_A - Pointer to a null-terminated string (ANSI) that specifies the subcomponent name
  lpszFunctionName_A - Pointer to a null-terminated string (ANSI) that specifies the function name
  lpszVariationName_A - Pointer to a null-terminated string (ANSI) that specifies the variation name
  lpszLogString_A - Pointer to a null-terminated string (ANSI)

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;
    
    // szWebPostLogData_A is the line of web post data
    CHAR          szWebPostLogData_A[WEBPOST_LOGDATA_LENGTH] = {'\0'};
    // szWebPostLog_A is the web post
    CHAR          szWebPostLog_A[WEBPOST_LOG_LENGTH] = {'\0'};
    // szWebPostEntry_A is the web post entry for the file
    CHAR          szWebPostEntry_A[5 + 12 + WEBPOST_LOG_LENGTH + 3] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD         dwBytesWritten = 0;

    // szDebugString is the debug string
    CHAR          szDebugString[61];



    if (NULL != pLogObject->lpszLogPage_A) {
        // Format the web post data
        sprintf(szWebPostLogData_A, WEBPOST_LOGDATA_FORMAT_A, pLogObject->szHostName_A, pLogObject->szObjectUUID_A, pLogObject->szOwnerAlias_A, GetCurrentThreadId(), dwVariationResult, lpszComponentName_A, lpszSubcomponentName_A, lpszFunctionName_A, lpszVariationName_A, lpszLogString_A);

        // Format the web post
        sprintf(szWebPostLog_A, WEBPOST_FORMAT_A, pLogObject->lpszLogPage_A, pLogObject->lpszHttpServer_A, strlen(szWebPostLogData_A), szWebPostLogData_A);

        if (INVALID_HANDLE_VALUE != pLogObject->hWebPostFile) {
            // Format the web post entry for the file
            sprintf(szWebPostEntry_A, "%03u\r\n0x%08x\r\n%s\r\n", strlen(szWebPostLog_A), pLogObject->HttpAddr, szWebPostLog_A);

            // Write the web post entry to the file
            WriteFile(pLogObject->hWebPostFile, szWebPostEntry_A, strlen(szWebPostEntry_A), &dwBytesWritten, NULL);

            // Flush the file buffers to prevent corruption
            FlushFileBuffers(pLogObject->hWebPostFile);
        }
    }
}



VOID
IncrementVariationResult(
    IN  HANDLE  hLog,
    IN  DWORD   dwVariationResult,
    IN  BOOL    bIncrementTotal
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Increments the variation result counters

Arguments:

  hLog - Handle to the XLOG_OBJECT
  dwVariationResult - Specifies the variation result.  It can be one of the XLL_ #defines.
  bIncrementTotal - Specifies if the total variations counter should be incremented.

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;



    if (TRUE == bIncrementTotal) {
        // Increment the dwVariationsTotal member
        pLogObject->dwVariationsTotal++;
    }

    switch (dwVariationResult) {

    case XLL_EXCEPTION:
        // Increment the variations excepted counter
        pLogObject->dwVariationsException++;
        break;

    case XLL_BREAK:
        // Increment the variations broken counter
        pLogObject->dwVariationsBreak++;
        break;

    case XLL_FAIL:
        // Increment the variations failed counter
        pLogObject->dwVariationsFail++;
        break;

    case XLL_WARN:
        // Increment the variations warned counter
        pLogObject->dwVariationsWarning++;
        break;

    case XLL_BLOCK:
        // Increment the variations blocked counter
        pLogObject->dwVariationsBlock++;
        break;

    case XLL_PASS:
        // Increment the variations passed counter
        pLogObject->dwVariationsPass++;
        break;

    default:
        // Increment the variations unknown counter
        pLogObject->dwVariationsUnknown++;
        break;
    }
}



BOOL
AddRefNet(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Increments the reference count for the net stack

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // WSAData is the details of the Winsock implementation
    WSADATA            WSAData;
    // dwErrorCode is the last error code
    DWORD              dwErrorCode = ERROR_SUCCESS;



#ifdef _XBOX
    // Initialize the net stack
    dwErrorCode = XNetAddRef();
    if (0 == dwErrorCode) {
        goto FunctionFailed0;
    }
#endif

    // Initialize Winsock
    ZeroMemory(&WSAData, sizeof(WSAData));
    dwErrorCode = WSAStartup(MAKEWORD(2, 2), &WSAData);
    if (0 != dwErrorCode) {
        goto FunctionFailed1;
    }

    return TRUE;

FunctionFailed1:
#ifdef _XBOX
    // Terminate the net stack
    XNetRelease();

FunctionFailed0:
#endif
    return FALSE;
}



VOID
ReleaseNet(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decrements the reference count for the net stack

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Terminate Winsock
    WSACleanup();

#ifdef _XBOX
    // Terminate the net stack
    XNetRelease();
#endif
}



LPSTR
GetHostName(
    IN HANDLE  hMemObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the host name

Arguments:

  hMemObject - Handle to the memory object for memory allocation

Return Value:

  LPSTR:
    If the function succeeds, the return value is a pointer to the host name.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // lpszHostName is a pointer to the host name
    LPSTR  lpszHostName = NULL;
#ifdef _XBOX
    // HostNameLen is the length of the host name buffer
    DWORD  dwHostNameLen = 18;

    // MacAddr is the mac address
    BYTE   MacAddr[6];
    // dwType is the type
    DWORD  dwType = 0;
    // dwSize is the size
    DWORD  dwSize = 0;
#else
    // HostNameLen is the length of the host name buffer
    DWORD  dwHostNameLen = MAX_COMPUTERNAME_LENGTH + 1;
#endif

    // dwErrorCode is the last error code
    DWORD  dwErrorCode = ERROR_SUCCESS;



    // Allocate the memory for the host name
    lpszHostName = (LPSTR) xMemAlloc(hMemObject, dwHostNameLen);
    if (NULL == lpszHostName) {
        goto FunctionExit;
    }

#ifdef _XBOX
    // Get the mac address
    dwErrorCode = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &dwType, MacAddr, sizeof(MacAddr), &dwSize);
    if (ERROR_SUCCESS != dwErrorCode) {
        goto FunctionExit;
    }

    // Copy the standard host name
    sprintf(lpszHostName, "%02x-%02x-%02x-%02x-%02x-%02x", MacAddr[0], MacAddr[1], MacAddr[2], MacAddr[3], MacAddr[4], MacAddr[5]);
#else
    if (FALSE == GetComputerNameA(lpszHostName, &dwHostNameLen)) {
        dwErrorCode = GetLastError();
        goto FunctionExit;
    }
#endif

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (NULL != lpszHostName) {
            // Free the host name
            xMemFree(hMemObject, lpszHostName);
            lpszHostName = NULL;
        }

        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return lpszHostName;
}

} // namespace xLogNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xmem\xmemp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xmemp.h

Abstract:

  This module contains the private definitions for xmem.c

Author:

  Steven Kehrli (steveke) 1-Nov-2001

------------------------------------------------------------------------------*/

#pragma once



namespace xMemNamespace {

// Memory allocation structure

typedef struct _XMEM_ALLOCATION {
    LPVOID                   lpMem;                // Pointer to the memory allocation
    INT64                    *lpMemTail;           // Pointer to the memory allocation tail
    SIZE_T                   dwBytes;              // Specifies the size of the allocation
    CHAR                     szFile[MAX_PATH];     // Specifies the file name of the allocation
    DWORD                    dwLine;               // Specifies the line number of the allocation
    DWORD                    dwThreadId;           // Specifies the thread id of the allocation
    SYSTEMTIME               LocalTime;            // Specifies the time of the allocation
    struct _XMEM_ALLOCATION  *pPrevMemAllocation;  // Pointer to the previous memory allocation in the list
    struct _XMEM_ALLOCATION  *pNextMemAllocation;  // Pointer to the next memory allocation in the list
} XMEM_ALLOCATION, *PXMEM_ALLOCATION;

#define XMEM_ALLOCATION_TAIL  0x083E546BF7C1AB94

typedef struct _XMEM_OBJECT {
    HANDLE                   hHeap;                // Handle to the private heap
    PCRITICAL_SECTION        pcsMem;               // Pointer to the critical section to synchronize access to this object
    PXMEM_ALLOCATION         pMemAllocation;       // Pointer to the list of memory allocations
    CHAR                     szFile[MAX_PATH];     // Specifies the file name of the object
    DWORD                    dwLine;               // Specifies the line number of the object
    DWORD                    dwThreadId;           // Specifies the thread if of the object
    SYSTEMTIME               LocalTime;            // Specifies the time of the object
    struct _XMEM_OBJECT      *pPrevMemObject;      // Pointer to the previous object in the list
    struct _XMEM_OBJECT      *pNextMemObject;      // Pointer to the next object in the list
} XMEM_OBJECT, *PXMEM_OBJECT;

} // namespace xMemNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\xlogging.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  xlogging.h

Abstract:

  This module contains the definitions for xlogging.c

Author:

  Steven Kehrli (steveke) 13-Mar-2000

------------------------------------------------------------------------------*/

#pragma once



namespace xLogNamespace {

// Global definitions

#define BOX_ID_LENGTH            18                      // Maximum length of the box id, in characters
#define OBJECT_ID_LENGTH         38                      // Maximum length of the object id, in characters
#define OS_BUILD_LENGTH          13                      // Maximum length of the os build string, in characters
#define HW_BUILD_LENGTH          13                      // Maximum length of the hw build string, in characters
#define THREAD_ID_LENGTH         4                       // Maximum length of a thread id, in characters
#define TIME_LENGTH              8                       // Maximum length of the time string, in characters
#define LOG_LEVEL_VALUE_LENGTH   10                      // Maximum length of the log level value, in characters
#define LOG_LEVEL_STRING_LENGTH  25                      // Maximum length of the log level string, in characters
#define LOG_OUTPUT_LENGTH        THREAD_ID_LENGTH + TIME_LENGTH + LOG_LEVEL_STRING_LENGTH + COMPONENT_NAME_LENGTH + SUBCOMPONENT_NAME_LENGTH + FUNCTION_NAME_LENGTH + VARIATION_NAME_LENGTH + LOG_STRING_LENGTH + 8

#define NO_COMPONENT_STRING      "{No Component}"        // Default string when no component is specified
#define NO_SUBCOMPONENT_STRING   "{No Subcomponent}"     // Default string when no subcomponent is specified
#define NO_FUNCTION_STRING       "{No Function}"         // Default string when no function is specified
#define NO_VARIATION_STRING      "{No Variation}"        // Default string when no variation is specified

#ifdef _XBOX

#define WEBPOST_LOGFILE_NAME     "T:\\xlog_webpost.log"  // Default web post log file name

#else

#define WEBPOST_LOGFILE_NAME     "xlog_webpost.log"      // Default web post log file name

#endif // _XBOX



// Structure definitions

typedef struct _XLOG_OBJECT {
    HANDLE                     hMemObject;                                          // Handle to the memory object
    CRITICAL_SECTION           *pcs;                                                // Pointer to the object to synchronize access to this log object.
    UUID                       ObjectUUID;                                          // A UUID to uniquely identify this log object.
    CHAR                       szObjectUUID_A[39];                                  // String representation of the ObjectUUID.
    CHAR                       szOwnerAlias_A[OWNER_ALIAS_LENGTH + 1];              // Null-terminated string that specifies the owner alias of this log object.
    CHAR                       szHostName_A[BOX_ID_LENGTH + 1];                     // Null-terminated string that specifies the host name.
    DWORD                      dwPlatformId;                                        // Specifies the operating system platform.
    BOOL                       KernelDebug;                                         // Specifies if ntoskrnl is free or debug.
    ULONG                      KernelVersion;                                       // Specifies the version number of ntoskrnl.
    BOOL                       XapiDebug;                                           // Specifies if xapi is free or debug.
    ULONG                      XapiVersion;                                         // Specifies the version number of xapi.
    DWORD                      dwMajorVersion;                                      // Specifies the major version number of the operating system.
    DWORD                      dwMinorVersion;                                      // Specifies the minor version number of the operating system.
    DWORD                      dwBuildNumber;                                       // Specifies the build number of the operating system.
    LPSTR                      lpszLogFileName_A;                                   // Pointer to a null-terminated string that specifies the filename to which the log output will be directed.  This member is NULL if no log file will be created.
    DWORD                      dwLogFileNameLen;                                    // Specifies the size of the lpszLogFileName_A, in bytes, including the null-terminating character.
    HANDLE                     hLogFile;                                            // An open handle to the specified log file.  This member is INVALID_HANDLE_VALUE if no log file is created.
    LPSTR                      lpszHttpServer_A;                                    // Pointer to a null-terminated string that specifies the http server to which the web posts will be directed.  This member is NULL if no web posts will be made.
    DWORD                      dwHttpServerLen;                                     // Specifies the size of the lpszHttpServer_A, in bytes, including the null-terminating character.
    u_long                     HttpAddr;                                            // Specifies the address of the http server, in network byte order.
    LPSTR                      lpszConfigPage_A;                                    // Pointer to a null-terminated string that specifies the web page to which the system configuration will be web-posted.  This member is NULL if no web posts will be made.
    DWORD                      dwConfigPageLen;                                     // Specifies the size of the lpszConfigPage_A, in bytes, including the null-terminating character.
    LPSTR                      lpszStatePage_A;                                     // Pointer to a null-terminated string that specifies the web page to which the system state will be web-posted.  This member is NULL if no web posts will be made.
    DWORD                      dwStatePageLen;                                      // Specifies the size of the lpszStatePage_A, in bytes, including the null-terminating character.
    LPSTR                      lpszLogPage_A;                                       // Pointer to a null-terminated string that specifies the web page to which the log output will be web-posted.  This member is NULL if no web posts will be made.
    DWORD                      dwLogPageLen;                                        // Specifies the size of the lpszLogPage_A, in bytes, including the null-terminating character.
    LPSTR                      lpszWebPostFileName_A;                               // Pointer to a null-terminated string that specifies the file to cache web posts.  This member is NULL is web posts are made immediately.
    DWORD                      dwWebPostFileNameLen;                                // Specifies the size of lpszWebPostFileName_A, in bytes, including the null-terminating character.
    HANDLE                     hWebPostFile;                                        // An open handle to the specified web post log file.  This member is INVALID_HANDLE_VALUE is web posts are made immediately.
    CRITICAL_SECTION           *pConsoleSocketcs;                                   // Pointer to the object to synchronize access to the console socket.
    SOCKET                     sConsoleSocket;                                      // Socket descriptor used for directing output to a remote console.
    DWORD                      dwLogLevel;                                          // Specifies the logging level for this log object.  It can be any combination of the XLL_ #defines.
    DWORD                      dwLogOptions;                                        // Specifies the logging options for this log object.  It can be any combination of the XLO_ #defines.
    DWORD                      dwVariationsTotal;                                   // Specifies the number of variations total for this log object.
    DWORD                      dwVariationsException;                               // Specifies the number of variations excepted for this log object.
    DWORD                      dwVariationsBreak;                                   // Specifies the number of variations broken for this log object.
    DWORD                      dwVariationsFail;                                    // Specifies the number of variations failed for this log object.
    DWORD                      dwVariationsWarning;                                 // Specifies the number of variations warned for this log object.
    DWORD                      dwVariationsBlock;                                   // Specifies the number of variations blocked for this log object.
    DWORD                      dwVariationsPass;                                    // Specifies the number of variations passed for this log object.
    DWORD                      dwVariationsUnknown;                                 // Specifies the number of variations unknown for this log object.
    struct _THREAD_INFO        *pThreadInfo;                                        // Pointer to the list of thread info associated with this log object.
} XLOG_OBJECT, *PXLOG_OBJECT;



typedef struct _XLOG_OBJECT_INFO_A {
    LPSTR                      lpszLogFileName_A;                                   // Pointer to the log file name
    LPSTR                      lpszHttpServer_A;                                    // Pointer to the http server name
    LPSTR                      lpszConfigPage_A;                                    // Pointer to the http server config page
    LPSTR                      lpszStatePage_A;                                     // Pointer to the http server state page
    LPSTR                      lpszLogPage_A;                                       // Pointer to the http server log page
    LPSTR                      lpszWebPostFileName_A;                               // Pointer to the web post log file
    SOCKET                     sConsoleSocket;                                      // Specifies the console socket
    DWORD                      dwLogLevel;                                          // Specifies the log level
    DWORD                      dwLogOptions;                                        // Specifies the log options
} XLOG_OBJECT_INFO_A, *PXLOG_OBJECT_INFO_A;



typedef struct _XLOG_OBJECT_INFO_W {
    LPWSTR                     lpszLogFileName_W;                                   // Pointer to the log file name
    LPWSTR                     lpszHttpServer_W;                                    // Pointer to the http server name
    LPWSTR                     lpszConfigPage_W;                                    // Pointer to the http server config page
    LPWSTR                     lpszStatePage_W;                                     // Pointer to the http server state page
    LPWSTR                     lpszLogPage_W;                                       // Pointer to the http server log page
    LPWSTR                     lpszWebPostFileName_W;                               // Pointer to the web post log file
    SOCKET                     sConsoleSocket;                                      // Specifies the console socket
    DWORD                      dwLogLevel;                                          // Specifies the log level
    DWORD                      dwLogOptions;                                        // Specifies the log options
} XLOG_OBJECT_INFO_W, *PXLOG_OBJECT_INFO_W;



typedef struct _FUNCTION_INFO {
    LPSTR                      lpszComponentName_A;                                 // Pointer to the null-terminated string that specifies the component name (szComponentName_A).
    LPSTR                      lpszSubcomponentName_A;                              // Pointer to the null-terminated string that specifies the subcomponent name (szSubcomponentName_A).
    LPSTR                      lpszFunctionName_A;                                  // Pointer to the null-terminated string that specifies the function name (szFunctionName_A).
    CHAR                       szComponentName_A[COMPONENT_NAME_LENGTH + 1];        // Null-terminated string that specifies the component name.
    CHAR                       szSubcomponentName_A[SUBCOMPONENT_NAME_LENGTH + 1];  // Null-terminated string that specifies the subcomponent name.
    CHAR                       szFunctionName_A[FUNCTION_NAME_LENGTH + 1];          // Null-terminated string that specifies the function name.
} FUNCTION_INFO, *PFUNCTION_INFO;



typedef struct _VARIATION_ELEMENT {
    LPSTR                      lpszVariationName_A;                                 // Pointer to the null-terminated string that specifies the variation name (szVariationName_A).
    LPSTR                      lpszLogString_A;                                     // Pointer to the null-terminated string that specifies the log string (szLogString_A).
    DWORD                      dwVariationResult;                                   // Specifies the variation result.
    BOOL                       bVariationTime;                                      // Specifies if variation time is logged.
    ULONGLONG                  InitialTime;                                         // Specifies the time at the start of the variation.
    ULONGLONG                  InitialKernelTime;                                   // Specifies the kernel time at the start of the variation.
    ULONGLONG                  InitialIdleTime;                                     // Specifies the idle time at the start of the variation.
    ULONGLONG                  InitialDpcTime;                                      // Specifies the dpc time at the start of the variation.
    ULONGLONG                  InitialInterruptTime;                                // Specifies the interrupt time at the start of the variation.
    struct _VARIATION_ELEMENT  *pPrevVariationElement;                              // Pointer to the previous variation element in the list.
    struct _VARIATION_ELEMENT  *pNextVariationElement;                              // Pointer to the next variation element in the list.
    CHAR                       szVariationName_A[VARIATION_NAME_LENGTH + 1];        // Null-terminated string that specifies the variation name.
    CHAR                       szLogString_A[LOG_STRING_LENGTH + 1];                // Null-terminated string that specifies the log string.
} VARIATION_ELEMENT, *PVARIATION_ELEMENT;



typedef struct _THREAD_INFO {
    DWORD                      dwThreadId;                                          // Specifies the parent of this thread info
    PFUNCTION_INFO             pFunctionInfo;                                       // Pointer to the function info associated with this thread
    PVARIATION_ELEMENT         pVariationList;                                      // Pointer to the list of variation elements associated with this thread
    struct _THREAD_INFO        *pPrevThreadInfo;                                    // Pointer to the previous thread info in the list
    struct _THREAD_INFO        *pNextThreadInfo;                                    // Pointer to the next thread info in the list
} THREAD_INFO, *PTHREAD_INFO;



typedef struct _WEBPOST_LOGFILE {
    CHAR                       szWebPostFileName_A[MAX_PATH];                       // Null-terminated string that specifies the web post log file name.
    DWORD                      dwRefCount;                                          // Specifies the reference count of the log file.
    HANDLE                     hFile;                                               // Handle to the log file.
    struct _WEBPOST_LOGFILE    *pPrevWebPostLogFile;                                // Pointer to the previous web post log file in the list.
    struct _WEBPOST_LOGFILE    *pNextWebPostLogFile;                                // Pointer to the next web post log file in the list.
} WEBPOST_LOGFILE, *PWEBPOST_LOGFILE;



typedef struct _WEB_SOCKET {
    u_long                     HttpAddr;                                            // Specifies the address of the http server, in network byte order.
    SOCKET                     sWebSocket;                                          // Socket descriptor used for web posts.
    struct _WEB_SOCKET         *pPrevWebSocket;                                     // Pointer to the previous web socket in the list.
    struct _WEB_SOCKET         *pNextWebSocket;                                     // Pointer to the next web socket in the list.
} WEB_SOCKET, *PWEB_SOCKET;



typedef struct _XLOG_INFO {
    HANDLE                     hMemObject;                                          // Handle to the memory object
    DWORD                      dwRefCount;                                          // dwRefCount is the xLog ref count
    PWEBPOST_LOGFILE           pWebPostLogFile;                                     // pWebPostLogFile is a pointer to the list of web post log files
    LPSTR                      lpszHostName_A;                                      // lpszHostName_A is a pointer to a null-terminated string that specifies the host name
    LPSTR                      lpszDiskModel;                                       // lpszDiskModel is a pointer to a null-terminated string that specifies the disk model
    LPSTR                      lpszDiskSerial;                                      // lpszDiskSerial is a pointer to a null-terminated string that specifies the disk serial number
} XLOG_INFO, *PXLOG_INFO;



// More global definitions

#define OS_PLATFORM_XBOX  1
#define OS_PLATFORM_NT    2

#define WEBPOST_CONFIGDATA_FORMAT_UNKNOWN_A                \
    "boxID=%s"                                             \
    "&testID=%s"                                           \
    "&osBuild=00.00.0000.00"                               \
    "&hwBuild=00.00.0000.00"
#define WEBPOST_CONFIGDATA_FORMAT_XBOX_A                   \
    "boxID=%s"                                             \
    "&testID=%s"                                           \
    "&osBuild=%02u.%02u.%04u.%02u"                         \
    "&hwBuild=%02u.%02u.%04u.%02u"
#define WEBPOST_CONFIGDATA_FORMAT_NT_A                     \
    "boxID=%s"                                             \
    "&testID=%s"                                           \
    "&osBuild=%02u.%02u.%04u.%02u"                         \
    "&hwBuild=00.00.0000.00"
#define WEBPOST_CONFIGDATA_FORMAT_LENGTH  32
#define WEBPOST_CONFIGDATA_LENGTH         WEBPOST_CONFIGDATA_FORMAT_LENGTH + BOX_ID_LENGTH + OBJECT_ID_LENGTH + OS_BUILD_LENGTH + HW_BUILD_LENGTH + 1

#define WEBPOST_LOGDATA_FORMAT_A                           \
    "boxID=%s"                                             \
    "&testID=%s"                                           \
    "&tester=%s"                                           \
    "&threadID=%04x"                                       \
    "&logLevel=%d"                                         \
    "&component=%s"                                        \
    "&subcomponent=%s"                                     \
    "&function=%s"                                         \
    "&variation=%s"                                        \
    "&logString=%s"
#define WEBPOST_LOGDATA_FORMAT_LENGTH     99
#define WEBPOST_LOGDATA_LENGTH            WEBPOST_LOGDATA_FORMAT_LENGTH + BOX_ID_LENGTH + OBJECT_ID_LENGTH + OWNER_ALIAS_LENGTH + THREAD_ID_LENGTH + LOG_LEVEL_VALUE_LENGTH + COMPONENT_NAME_LENGTH + SUBCOMPONENT_NAME_LENGTH + FUNCTION_NAME_LENGTH + VARIATION_NAME_LENGTH + LOG_STRING_LENGTH + 1

#define WEBPOST_FORMAT_A                                  \
    "HEAD %s HTTP/1.1\r\n"                                 \
    "Accept: */*\r\n"                                      \
    "User-Agent: MSIE 5.0 - XBox Test Logging\r\n"         \
    "Host: %s\r\n"                                         \
    "Content-Length: %d\r\n"                               \
    "Content-Type: application/x-www-form-urlencoded\r\n"  \
    "\r\n"                                                 \
    "%s"
#define WEBPOST_FORMAT_LENGTH             148
#define WEBPAGE_LENGTH                    256
#define HOST_NAME_LENGTH                  128
#define CONTENTLENGTH_LENGTH              10
#define WEBPOST_CONFIG_LENGTH             WEBPOST_FORMAT_LENGTH + WEBPAGE_LENGTH + HOST_NAME_LENGTH + CONTENTLENGTH_LENGTH + WEBPOST_CONFIGDATA_LENGTH
#define WEBPOST_LOG_LENGTH                WEBPOST_FORMAT_LENGTH + WEBPAGE_LENGTH + HOST_NAME_LENGTH + CONTENTLENGTH_LENGTH + WEBPOST_LOGDATA_LENGTH
#define MAX_WEBPOST_LENGTH                WEBPOST_CONFIG_LENGTH > WEBPOST_LOG_LENGTH ? WEBPOST_CONFIG_LENGTH : WEBPOST_LOG_LENGTH



// Function prototypes

VOID
ReleaseWebPostLogFile(
    IN  LPSTR   lpszWebPostFileName_A
);

BOOL
UploadWebPostLogFile(
    IN  HANDLE  hFile
);

BOOL
xPostConfiguration(
    IN  HANDLE  hLog
);

BOOL
WINAPI
xLogConfiguration(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString_A
);

BOOL
WINAPI
xLogResourceStatus(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString_A
);

BOOL
WINAPI
xLogResults(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString
);

} // namespace xLogNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\xlogging.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  xlogging.c

Abstract:

  This module is the Xbox logging library

Author:

  Steven Kehrli (steveke) 19-Mar-2000

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace xLogNamespace;

namespace xLogNamespace {

// Global variables
// g_hLogInfoMutex is the object to synchronize access to the xlog info
HANDLE     g_hLogInfoMutex = NULL;
// g_LogInfo is the xlog info
XLOG_INFO  g_LogInfo = {
                          INVALID_HANDLE_VALUE,  // hMemObject
                          0,                     // dwRefCount
                          NULL,                  // pWebPostLogFile
                          NULL,                  // lpszHostName_A
                          NULL,                  // lpszDiskModel
                          NULL,                  // lpszDiskSerial
                         };



HANDLE
xCreateLog_X(
    IN  PXLOG_OBJECT_INFO_A  pLogObjectInfo_A,
    IN  PXLOG_OBJECT_INFO_W  pLogObjectInfo_W
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates a lob object:
    Creates an XLOG_OBJECT
    Creates a log file, if specified
    Logs and web posts the system configuration, if specified
    Logs and web posts the system state, if specified

Arguments:

  pLogObjectInfo_A - Pointer to the ANSI xlog object info
  pLogObjectInfo_W - Pointer to the UNICODE xlog object info

Return Value:

  HANDLE:
    If the function succeeds, the return value is a handle to the XLOG_OBJECT
    If the function fails, the return value is INVALID_HANDLE_VALUE

------------------------------------------------------------------------------*/
{
    // lpszLogFileName_A is a pointer to the log file name
    LPSTR             lpszLogFileName_A = NULL;
    // lpszHttpServer_A is a pointer to the http server name
    LPSTR             lpszHttpServer_A = NULL;
    // lpszConfigPage_A is a pointer to the http server config page
    LPSTR             lpszConfigPage_A = NULL;
    // lpszStatePage_A is a pointer to the http server state page
    LPSTR             lpszStatePage_A = NULL;
    // lpszLogPage_A is a pointer to the http server log page
    LPSTR             lpszLogPage_A = NULL;
    // lpszWebPostFileName_A is a pointer to the web post log file
    LPSTR             lpszWebPostFileName_A = NULL;
    // sConsoleSocket specifies the console socket
    SOCKET            sConsoleSocket = INVALID_SOCKET;
    // dwLogLevel specifies the log level
    DWORD             dwLogLevel = 0;
    // dwLogOptions specifies the log options
    DWORD             dwLogOptions = 0;

    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT      pLogObject = NULL;
    // dwBufferSize is the size of the XLOG_OBJECT buffer, in bytes
    DWORD             dwBufferSize = sizeof(XLOG_OBJECT);
    // uipOffset is an offset into the XLOG_OBJECT buffer for the strings
    UINT_PTR          uipOffset = sizeof(XLOG_OBJECT);

    // pCurrentWebPostLogFile is a pointer to the current web post log file in the list of web post log files
    PWEBPOST_LOGFILE  pCurrentWebPostLogFile = NULL;

#ifdef _XBOX
    // nResult is the int status code returned by a function
    INT               nResult = 0;
#else
    // RpcStatus is the rpc status code returned by a function
    RPC_STATUS        RpcStatus = RPC_S_OK;
    // OSVersionInfo is the version info
    OSVERSIONINFO     OSVersionInfo;
#endif

    // szDebugString is the debug string
    CHAR              szDebugString[61];
    // dwErrorCode is the last error code
    DWORD             dwErrorCode = ERROR_SUCCESS;



    // Create the xlog info mutex
    g_hLogInfoMutex = CreateMutexA(NULL, FALSE, "xLogInfoMutex");

    // Wait for the xlog info mutex
    WaitForSingleObject(g_hLogInfoMutex, INFINITE);

    // Increment the xLog ref count
    g_LogInfo.dwRefCount++;

    if (1 == g_LogInfo.dwRefCount) {
        // Create the memory object
        g_LogInfo.hMemObject = xMemCreate();
        if (INVALID_HANDLE_VALUE == g_LogInfo.hMemObject) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }

#ifdef _XBOX
        // Get the disk model and serial number
        g_LogInfo.lpszDiskModel = (LPSTR) xMemAlloc(g_LogInfo.hMemObject, HalDiskModelNumber->Length + 1);

        if (NULL == g_LogInfo.lpszDiskModel) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }

        strncpy(g_LogInfo.lpszDiskModel, HalDiskModelNumber->Buffer, HalDiskModelNumber->Length);

        g_LogInfo.lpszDiskSerial = (LPSTR) xMemAlloc(g_LogInfo.hMemObject, HalDiskSerialNumber->Length + 1);

        if (NULL == g_LogInfo.lpszDiskSerial) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }

        strncpy(g_LogInfo.lpszDiskSerial, HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length);
#endif
        // Get the host name and host addr
        g_LogInfo.lpszHostName_A = GetHostName(g_LogInfo.hMemObject);

        if (NULL == g_LogInfo.lpszHostName_A) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }

    // Get the xlog object info
    if (NULL == pLogObjectInfo_A) {
        if (NULL != pLogObjectInfo_W->lpszLogFileName_W) {
            lpszLogFileName_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszLogFileName_W);
            if (NULL == lpszLogFileName_A) {
                // Get the last error code
                dwErrorCode = GetLastError();

                goto FunctionFailed;
            }
        }

        if (NULL != pLogObjectInfo_W->lpszHttpServer_W) {
            lpszHttpServer_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszHttpServer_W);
            if (NULL == lpszHttpServer_A) {
                // Get the last error code
                dwErrorCode = GetLastError();

                goto FunctionFailed;
            }

            if (NULL != pLogObjectInfo_W->lpszConfigPage_W) {
                lpszConfigPage_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszConfigPage_W);
                if (NULL == lpszConfigPage_A) {
                    // Get the last error code
                    dwErrorCode = GetLastError();

                    goto FunctionFailed;
                }
            }

            if (NULL != pLogObjectInfo_W->lpszStatePage_W) {
                lpszStatePage_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszStatePage_W);
                if (NULL == lpszStatePage_A) {
                    // Get the last error code
                    dwErrorCode = GetLastError();

                    goto FunctionFailed;
                }
            }

            if (NULL != pLogObjectInfo_W->lpszLogPage_W) {
                lpszLogPage_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszLogPage_W);
                if (NULL == lpszLogPage_A) {
                    // Get the last error code
                    dwErrorCode = GetLastError();

                    goto FunctionFailed;
                }
            }

            if (NULL != pLogObjectInfo_W->lpszWebPostFileName_W) {
                lpszWebPostFileName_A = UnicodeToMultiByteString(g_LogInfo.hMemObject, pLogObjectInfo_W->lpszWebPostFileName_W);
                if (NULL == lpszWebPostFileName_A) {
                    // Get the last error code
                    dwErrorCode = GetLastError();

                    goto FunctionFailed;
                }
            }
            else {
                lpszWebPostFileName_A = WEBPOST_LOGFILE_NAME;
            }
        }

        sConsoleSocket = pLogObjectInfo_W->sConsoleSocket;
        dwLogLevel = pLogObjectInfo_W->dwLogLevel;
        dwLogOptions = pLogObjectInfo_W->dwLogOptions;
    }
    else {
        lpszLogFileName_A = pLogObjectInfo_A->lpszLogFileName_A;
        if (NULL != pLogObjectInfo_A->lpszHttpServer_A) {
            lpszHttpServer_A = pLogObjectInfo_A->lpszHttpServer_A;
            lpszConfigPage_A = pLogObjectInfo_A->lpszConfigPage_A;
            lpszStatePage_A = pLogObjectInfo_A->lpszStatePage_A;
            lpszLogPage_A = pLogObjectInfo_A->lpszLogPage_A;
            lpszWebPostFileName_A = pLogObjectInfo_A->lpszWebPostFileName_A;
            if (NULL == lpszWebPostFileName_A) {
                lpszWebPostFileName_A = WEBPOST_LOGFILE_NAME;
            }
        }
        sConsoleSocket = pLogObjectInfo_A->sConsoleSocket;
        dwLogLevel = pLogObjectInfo_A->dwLogLevel;
        dwLogOptions = pLogObjectInfo_A->dwLogOptions;
    }

    // Increase the size of the XLOG_OBJECT buffer to store the strings

    // Critical Sections
    // pcs critical section
    dwBufferSize += sizeof(CRITICAL_SECTION);

    // pWebSocketcs critical section
    dwBufferSize += sizeof(CRITICAL_SECTION);

    // pConsoleSocketcs critical section
    dwBufferSize += sizeof(CRITICAL_SECTION);

    // lpszLogFileName
    if (NULL != lpszLogFileName_A) {
        dwBufferSize += strlen(lpszLogFileName_A) + 1;
    }

    // lpszHttpServer
    if (NULL != lpszHttpServer_A) {
        dwBufferSize += strlen(lpszHttpServer_A) + 1;

        // lpszConfigPage
        if (NULL != lpszConfigPage_A) {
            dwBufferSize += strlen(lpszConfigPage_A) + 1;
        }

        // lpszStatePage
        if (NULL != lpszStatePage_A) {
            dwBufferSize += strlen(lpszStatePage_A) + 1;
        }

        // lpszLogPage
        if (NULL != lpszLogPage_A) {
            dwBufferSize += strlen(lpszLogPage_A) + 1;
        }

        // lpszWebPostFileName
        if (NULL != lpszWebPostFileName_A) {
            dwBufferSize += strlen(lpszWebPostFileName_A) + 1;
        }
    }

    // Allocate the memory for the XLOG_OBJECT buffer
    pLogObject = (PXLOG_OBJECT) xMemAlloc(g_LogInfo.hMemObject, dwBufferSize);
    if (NULL == pLogObject) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Initialize the XLOG_OBJECT
    pLogObject->hLogFile = INVALID_HANDLE_VALUE;
    pLogObject->hWebPostFile = INVALID_HANDLE_VALUE;
    pLogObject->sConsoleSocket = INVALID_SOCKET;

    // Set the memory object
    pLogObject->hMemObject = g_LogInfo.hMemObject;

    // Initialize the critical sections
    // pcs critical section
    pLogObject->pcs = (CRITICAL_SECTION *) ((UINT_PTR) pLogObject + uipOffset);
    uipOffset += sizeof(CRITICAL_SECTION);
    InitializeCriticalSection(pLogObject->pcs);

    // pConsoleSocket critical section
    pLogObject->pConsoleSocketcs = (CRITICAL_SECTION *) ((UINT_PTR) pLogObject + uipOffset);
    uipOffset += sizeof(CRITICAL_SECTION);
    InitializeCriticalSection(pLogObject->pConsoleSocketcs);

#ifdef _XBOX
    // Increment the net stack reference count
    if (FALSE == AddRefNet()) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Create the UUID
    nResult = XNetRandom((BYTE *) &pLogObject->ObjectUUID, sizeof(pLogObject->ObjectUUID));
    if (0 != nResult) {
        // Get the last error code
        dwErrorCode = nResult;
    }

    // Terminate the net stack
    ReleaseNet();

    if (0 != nResult) {
        goto FunctionFailed;
    }
#else
    // Create the UUID
    RpcStatus = UuidCreate(&pLogObject->ObjectUUID);
    if (RPC_S_OK != RpcStatus) {
        // Set the last error code
        dwErrorCode = (DWORD) RpcStatus;

        goto FunctionFailed;
    }
#endif

    // Get the UNICODE string representation of the object guid
    sprintf(pLogObject->szObjectUUID_A, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", pLogObject->ObjectUUID.Data1, pLogObject->ObjectUUID.Data2, pLogObject->ObjectUUID.Data3, pLogObject->ObjectUUID.Data4[0], pLogObject->ObjectUUID.Data4[1], pLogObject->ObjectUUID.Data4[2], pLogObject->ObjectUUID.Data4[3], pLogObject->ObjectUUID.Data4[4], pLogObject->ObjectUUID.Data4[5], pLogObject->ObjectUUID.Data4[6], pLogObject->ObjectUUID.Data4[7]);

    // Copy the host name
    strncpy(pLogObject->szHostName_A, g_LogInfo.lpszHostName_A, BOX_ID_LENGTH);

#ifdef _XBOX
    // Set the OS type
    pLogObject->dwPlatformId = OS_PLATFORM_XBOX;

    // Get the version info
    pLogObject->KernelDebug = !!(0x8000 & XboxKrnlVersion->Qfe);
    pLogObject->KernelVersion = XboxKrnlVersion->Build;

    pLogObject->XapiDebug = XeImageHeader()->XapiLibraryVersion->DebugBuild;
    pLogObject->XapiVersion = XeImageHeader()->XapiLibraryVersion->BuildVersion;
#else
    // Set the OS type
    pLogObject->dwPlatformId = OS_PLATFORM_NT;

    // Get the version info
    ZeroMemory(&OSVersionInfo, sizeof(OSVersionInfo));
    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);
    if (FALSE == GetVersionEx(&OSVersionInfo)) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Copy the version info
    pLogObject->dwMajorVersion = OSVersionInfo.dwMajorVersion;
    pLogObject->dwMinorVersion = OSVersionInfo.dwMinorVersion;
    pLogObject->dwBuildNumber = OSVersionInfo.dwBuildNumber;
#endif

    // Get the web server info, if specified
    if (NULL != lpszHttpServer_A) {
        // Get the web address
        pLogObject->HttpAddr = inet_addr(lpszHttpServer_A);
        if (INADDR_NONE == pLogObject->HttpAddr) {
            // Set the last error code
            dwErrorCode = ERROR_INVALID_PARAMETER;

            goto FunctionFailed;
        }
    }

    // Create the log file, if specified
    if (NULL != lpszLogFileName_A) {
        // Create the log file
        pLogObject->hLogFile = CreateFileA(lpszLogFileName_A, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, (0 != (dwLogOptions & XLO_REFRESH)) ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        // The last error code is always set by CreateFile
        dwErrorCode = GetLastError();

        if (INVALID_HANDLE_VALUE == pLogObject->hLogFile) {
            goto FunctionFailed;
        }

        if ((0 == (dwLogOptions & XLO_REFRESH)) && (ERROR_ALREADY_EXISTS == dwErrorCode)) {
            // File already exists, so set the file pointer to the end of the file
            SetFilePointer(pLogObject->hLogFile, 0, NULL, FILE_END);
        }
    }

    // Create the web post log file, if specified
    if (NULL != lpszWebPostFileName_A) {
        // Set the current web post log file to the head of the web post log file list
        pCurrentWebPostLogFile = g_LogInfo.pWebPostLogFile;

        while (NULL != pCurrentWebPostLogFile) {
            if (0 == _stricmp(lpszWebPostFileName_A, pCurrentWebPostLogFile->szWebPostFileName_A)) {
                break;
            }

            // Set the current web post log file to the next web post log file in the list
            pCurrentWebPostLogFile = pCurrentWebPostLogFile->pNextWebPostLogFile;
        }

        if (NULL == pCurrentWebPostLogFile) {
            // The web post log file was not found

            // Create the web post log file
            pLogObject->hWebPostFile = CreateFileA(lpszWebPostFileName_A, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE == pLogObject->hWebPostFile) {
                // Get the last error code
                dwErrorCode = GetLastError();

                goto FunctionFailed;
            }

            // Create the web post log file element
            pCurrentWebPostLogFile = (PWEBPOST_LOGFILE) xMemAlloc(g_LogInfo.hMemObject, sizeof(WEBPOST_LOGFILE));
            if (NULL == pCurrentWebPostLogFile) {
                // Get the last error code
                dwErrorCode = GetLastError();

                // Flush the file buffers to prevent corruption
                FlushFileBuffers(pLogObject->hWebPostFile);

                // Close the log file
                CloseHandle(pLogObject->hWebPostFile);
                pLogObject->hWebPostFile = INVALID_HANDLE_VALUE;

                // Delete the web post log file
                DeleteFileA(lpszWebPostFileName_A);

                goto FunctionFailed;
            }

            // Copy the web post log file name
            strncpy(pCurrentWebPostLogFile->szWebPostFileName_A, lpszWebPostFileName_A, sizeof(pCurrentWebPostLogFile->szWebPostFileName_A));

            // Set the ref count
            pCurrentWebPostLogFile->dwRefCount = 1;

            // Set the handle to the web post log file
            pCurrentWebPostLogFile->hFile = pLogObject->hWebPostFile;

            // Set the pointer to the next web post log file
            pCurrentWebPostLogFile->pNextWebPostLogFile = g_LogInfo.pWebPostLogFile;
            if (NULL != g_LogInfo.pWebPostLogFile) {
                g_LogInfo.pWebPostLogFile->pPrevWebPostLogFile = pCurrentWebPostLogFile;
            }

            // Set the head of the web post log file list to the current web post log file
            g_LogInfo.pWebPostLogFile = pCurrentWebPostLogFile;
        }
        else {
            // The web post log file was found

            // Increment the ref count
            pCurrentWebPostLogFile->dwRefCount++;

            // Get the handle to the web post log file
            pLogObject->hWebPostFile = pCurrentWebPostLogFile->hFile;
        }
    }

    // Set the XLOG_OBJECT members

    // lpszLogFileName
    if (NULL != lpszLogFileName_A) {
        pLogObject->lpszLogFileName_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
        strcpy(pLogObject->lpszLogFileName_A, lpszLogFileName_A);
        pLogObject->dwLogFileNameLen = strlen(pLogObject->lpszLogFileName_A) + 1;
        uipOffset += pLogObject->dwLogFileNameLen;
    }

    // lpszHttpServer
    if (NULL != lpszHttpServer_A) {
        pLogObject->lpszHttpServer_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
        strcpy(pLogObject->lpszHttpServer_A, lpszHttpServer_A);
        pLogObject->dwHttpServerLen = strlen(pLogObject->lpszHttpServer_A) + 1;
        uipOffset += pLogObject->dwHttpServerLen;

        // lpszConfigPage
        if (NULL != lpszConfigPage_A) {
            pLogObject->lpszConfigPage_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
            strcpy(pLogObject->lpszConfigPage_A, lpszConfigPage_A);
            pLogObject->dwConfigPageLen = strlen(pLogObject->lpszConfigPage_A) + 1;
            uipOffset += pLogObject->dwConfigPageLen;
        }

        // lpszStatePage
        if (NULL != lpszStatePage_A) {
            pLogObject->lpszStatePage_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
            strcpy(pLogObject->lpszStatePage_A, lpszStatePage_A);
            pLogObject->dwStatePageLen = strlen(pLogObject->lpszStatePage_A) + 1;
            uipOffset += pLogObject->dwStatePageLen;
        }

        // lpszLogPage
        if (NULL != lpszLogPage_A) {
            pLogObject->lpszLogPage_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
            strcpy(pLogObject->lpszLogPage_A, lpszLogPage_A);
            pLogObject->dwLogPageLen = strlen(pLogObject->lpszLogPage_A) + 1;
            uipOffset += pLogObject->dwLogPageLen;
        }

        // lpszWebPostFileName
        if (NULL != lpszWebPostFileName_A) {
            pLogObject->lpszWebPostFileName_A = (LPSTR) ((UINT_PTR) pLogObject + uipOffset);
            strcpy(pLogObject->lpszWebPostFileName_A, lpszWebPostFileName_A);
            pLogObject->dwWebPostFileNameLen = strlen(pLogObject->lpszWebPostFileName_A) + 1;
            uipOffset += pLogObject->dwWebPostFileNameLen;
        }
    }

    // sConsoleSocket
    pLogObject->sConsoleSocket = sConsoleSocket;

    // dwLogLevel
    pLogObject->dwLogLevel = dwLogLevel;

    // dwLogOptions
    pLogObject->dwLogOptions = dwLogOptions;

    // Log the start banner
    if (FALSE == LogBanner(pLogObject, "xLog Started", NULL)) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Log the system configuration, if specified
    if (0 != (dwLogOptions & XLO_CONFIG)) {
        if (FALSE == xLogConfiguration(pLogObject, NULL)) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }

    // Web post the system configuration, if specified
    if (NULL != pLogObject->lpszConfigPage_A) {
        xPostConfiguration(pLogObject);
    }

    // Log the system state, if specified
    if (0 != (dwLogOptions & XLO_STATE)) {
        if (FALSE == xLogResourceStatus(pLogObject, NULL)) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }
    }

    // Log a blank line
    if (FALSE == FormatAndWriteString(pLogObject, "\r\n")) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hLogFile);
    }

    // Get the xlog object info
    if (NULL != pLogObjectInfo_W) {
        if (NULL != lpszLogFileName_A) {
            xMemFree(g_LogInfo.hMemObject, lpszLogFileName_A);
        }

        if (NULL != lpszHttpServer_A) {
            xMemFree(g_LogInfo.hMemObject, lpszHttpServer_A);
        }

        if (NULL != lpszConfigPage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszConfigPage_A);
        }

        if (NULL != lpszStatePage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszStatePage_A);
        }

        if (NULL != lpszLogPage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszLogPage_A);
        }

        if ((NULL != pLogObjectInfo_W->lpszWebPostFileName_W) && (NULL != lpszWebPostFileName_A)) {
            xMemFree(g_LogInfo.hMemObject, lpszWebPostFileName_A);
        }
    }

    // Release the xlog info mutex
    ReleaseMutex(g_hLogInfoMutex);

    return pLogObject;

FunctionFailed:
    if (NULL != pLogObject) {
        // Decrement the ref count of the web post log file, if necessary
        if (INVALID_HANDLE_VALUE != pLogObject->hWebPostFile) {
            ReleaseWebPostLogFile(pLogObject->lpszWebPostFileName_A);
        }

        // Close the log file, if necessary
        if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
            // Flush the file buffers to prevent corruption
            FlushFileBuffers(pLogObject->hLogFile);

            // Close the log file
            CloseHandle(pLogObject->hLogFile);
        }

        // Delete the critical sections
        DeleteCriticalSection(pLogObject->pConsoleSocketcs);
        DeleteCriticalSection(pLogObject->pcs);

        // Free the XLOG_OBJECT buffer
        xMemFree(g_LogInfo.hMemObject, pLogObject);
    }

    // Free the xlog object info, if necessary
    if (NULL == pLogObjectInfo_A) {
        if (NULL != lpszLogFileName_A) {
            xMemFree(g_LogInfo.hMemObject, lpszLogFileName_A);
        }

        if (NULL != lpszHttpServer_A) {
            xMemFree(g_LogInfo.hMemObject, lpszHttpServer_A);
        }

        if (NULL != lpszConfigPage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszConfigPage_A);
        }

        if (NULL != lpszStatePage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszStatePage_A);
        }

        if (NULL != lpszLogPage_A) {
            xMemFree(g_LogInfo.hMemObject, lpszLogPage_A);
        }

        if (NULL != lpszWebPostFileName_A) {
            xMemFree(g_LogInfo.hMemObject, lpszWebPostFileName_A);
        }
    }

    if (1 == g_LogInfo.dwRefCount) {
#ifdef _XBOX
        // Free the disk model and serial number
        if (NULL != g_LogInfo.lpszDiskModel) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszDiskModel);
            g_LogInfo.lpszDiskModel = NULL;
        }

        if (NULL != g_LogInfo.lpszDiskSerial) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszDiskSerial);
            g_LogInfo.lpszDiskSerial = NULL;
        }
#endif
        // Free the host name
        if (NULL != g_LogInfo.lpszHostName_A) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszHostName_A);
            g_LogInfo.lpszHostName_A = NULL;
        }

        // Close the memory object
        if (INVALID_HANDLE_VALUE != g_LogInfo.hMemObject) {
            xMemClose(g_LogInfo.hMemObject);
            g_LogInfo.hMemObject = INVALID_HANDLE_VALUE;
        }
    }

    // Decrement the xLog ref count
    g_LogInfo.dwRefCount--;

    // Release the xlog info mutex
    ReleaseMutex(g_hLogInfoMutex);

    // Set the last error code
    SetLastError(dwErrorCode);

    return INVALID_HANDLE_VALUE;
}

} // namespace xLogNamespace



HANDLE
WINAPI
xCreateLog_W(
    IN  LPWSTR              lpszLogFileName_W,
    IN  PWEB_SERVER_INFO_W  pWebServerInfo_W,
    IN  SOCKET              sConsoleSocket,
    IN  DWORD               dwLogLevel,
    IN  DWORD               dwLogOptions
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  UNICODE version of xCreateLog()

Arguments:

  lpszLogFileName_W - Pointer to a null-terminated string (UNICODE) that specifies the filename to which the log output will be directed.  This member is NULL if no log file will be created.
  pWebServerInfo - Pointer to the web server information (http server and web pages)
  sConsoleSocket - Socket descriptor used for directing output to a remote console.
  dwLogLevel - Specifies the logging level for this log object.  It can be any combination of the XLL_ #defines.
  dwLogOptions - Specifies the logging options for this log object.  It can be any combination of the XLO_ #defines.

Return Value:

  HANDLE:
    If the function succeeds, the return value is a handle to the XLOG_OBJECT
    If the function fails, the return value is INVALID_HANDLE_VALUE

------------------------------------------------------------------------------*/
{
    // xLogObjectInfo_W is the UNICODE xlog object info
    XLOG_OBJECT_INFO_W  xLogObjectInfo_W;



    // Initialize the xlog object info
    ZeroMemory(&xLogObjectInfo_W, sizeof(xLogObjectInfo_W));

    // Set the xlog object info
    xLogObjectInfo_W.lpszLogFileName_W = lpszLogFileName_W;

    if (NULL != pWebServerInfo_W) {
        xLogObjectInfo_W.lpszHttpServer_W = pWebServerInfo_W->lpszHttpServer;
        xLogObjectInfo_W.lpszConfigPage_W = pWebServerInfo_W->lpszConfigPage;
        xLogObjectInfo_W.lpszStatePage_W = pWebServerInfo_W->lpszStatePage;
        xLogObjectInfo_W.lpszLogPage_W = pWebServerInfo_W->lpszLogPage;
        xLogObjectInfo_W.lpszWebPostFileName_W = pWebServerInfo_W->lpszWebPostFileName;
    }

    xLogObjectInfo_W.sConsoleSocket = sConsoleSocket;
    xLogObjectInfo_W.dwLogLevel = dwLogLevel;
    xLogObjectInfo_W.dwLogOptions = dwLogOptions;

    // Create the log object
    return xCreateLog_X(NULL, &xLogObjectInfo_W);
}



HANDLE
WINAPI
xCreateLog_A(
    IN  LPSTR               lpszLogFileName_A,
    IN  PWEB_SERVER_INFO_A  pWebServerInfo_A,
    IN  SOCKET              sConsoleSocket,
    IN  DWORD               dwLogLevel,
    IN  DWORD               dwLogOptions
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  ANSI version of xCreateLog()

Arguments:

  lpszLogFileName_A - Pointer to a null-terminated string (ANSI) that specifies the filename to which the log output will be directed.  This member is NULL if no log file will be created.
  pWebServerInfo - Pointer to the web server information (http server and web pages)
  sConsoleSocket - Socket descriptor used for directing output to a remote console.
  dwLogLevel - Specifies the logging level for this log object.  It can be any combination of the XLL_ #defines.
  dwLogOptions - Specifies the logging options for this log object.  It can be any combination of the XLO_ #defines.

Return Value:

  HANDLE:
    If the function succeeds, the return value is a handle to the XLOG_OBJECT
    If the function fails, the return value is INVALID_HANDLE_VALUE

------------------------------------------------------------------------------*/
{
    // xLogObjectInfo_A is the ANSI xlog object info
    XLOG_OBJECT_INFO_A  xLogObjectInfo_A;



    // Initialize the xlog object info
    ZeroMemory(&xLogObjectInfo_A, sizeof(xLogObjectInfo_A));

    // Set the xlog object info
    xLogObjectInfo_A.lpszLogFileName_A = lpszLogFileName_A;

    if (NULL != pWebServerInfo_A) {
        xLogObjectInfo_A.lpszHttpServer_A = pWebServerInfo_A->lpszHttpServer;
        xLogObjectInfo_A.lpszConfigPage_A = pWebServerInfo_A->lpszConfigPage;
        xLogObjectInfo_A.lpszStatePage_A = pWebServerInfo_A->lpszStatePage;
        xLogObjectInfo_A.lpszLogPage_A = pWebServerInfo_A->lpszLogPage;
        xLogObjectInfo_A.lpszWebPostFileName_A = pWebServerInfo_A->lpszWebPostFileName;
    }

    xLogObjectInfo_A.sConsoleSocket = sConsoleSocket;
    xLogObjectInfo_A.dwLogLevel = dwLogLevel;
    xLogObjectInfo_A.dwLogOptions = dwLogOptions;

    // Create the log object
    return xCreateLog_X(&xLogObjectInfo_A, NULL);
}



HANDLE
WINAPI
xSetLogSocket(
    IN  HANDLE  hLog,
    IN  SOCKET  sConsoleSocket
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Changes the console socket

Arguments:

  hLog - Handle to the XLOG_OBJECT
  sConsoleSocket - Socket descriptor used for directing output to a remote console.

Return Value:

  HANDLE:
    The return value is the handle to the changed XLOG_OBJECT

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        return hLog;
    }

    // Wait for access to the console socket critical section
    EnterCriticalSection(pLogObject->pConsoleSocketcs);

    // Change the console socket
    pLogObject->sConsoleSocket = sConsoleSocket;

    // Release access to the console socket critical section
    LeaveCriticalSection(pLogObject->pConsoleSocketcs);

    return pLogObject;
}



BOOL
WINAPI
xCloseLog(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes a lob object:
    Logs the variation results
    Logs and web posts the system state, if specified
    Closes the log file, if necessary
    Frees the XLOG_OBJECT

Arguments:

  hLog - Handle to the XLOG_OBJECT

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT        pLogObject = (PXLOG_OBJECT) hLog;
    // pNextThreadInfo is a pointer to the next thread info in the list
    PTHREAD_INFO        pNextThreadInfo = NULL;
    // pNextVariationElement is a pointer to the next variation element in the lsit
    PVARIATION_ELEMENT  pNextVariationElement = NULL;
    // pNextWebPostLogFile is a pointer to the next web post log file in the list
    PWEBPOST_LOGFILE    pNextWebPostLogFile = NULL;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Create the xlog info mutex
    g_hLogInfoMutex = CreateMutexA(NULL, FALSE, "xLogInfoMutex");

    // Wait for the xlog info mutex
    WaitForSingleObject(g_hLogInfoMutex, INFINITE);

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    while (NULL != pLogObject->pThreadInfo) {
        // Set the pointer to the next thread info in the list
        pNextThreadInfo = pLogObject->pThreadInfo->pNextThreadInfo;
        if (NULL != pNextThreadInfo) {
            pNextThreadInfo->pPrevThreadInfo = NULL;
        }

        // Free the variation info
        ASSERT(NULL == pLogObject->pThreadInfo->pVariationList);
        while (NULL != pLogObject->pThreadInfo->pVariationList) {
            // Set the pointer to the next variation element in the list
            pNextVariationElement = pLogObject->pThreadInfo->pVariationList->pNextVariationElement;
            if (NULL != pNextVariationElement) {
                pNextVariationElement->pPrevVariationElement = NULL;
            }

            // Free the variation element
            xMemFree(pLogObject->hMemObject, pLogObject->pThreadInfo->pVariationList);

            // Set the pointer to the next variation element in the list
            pLogObject->pThreadInfo->pVariationList = pNextVariationElement;
        }

        // Free the function info
        if (NULL != pLogObject->pThreadInfo->pFunctionInfo) {
            xMemFree(pLogObject->hMemObject, pLogObject->pThreadInfo->pFunctionInfo);
            pLogObject->pThreadInfo->pFunctionInfo = NULL;
        }

        // Free the current thread info
        xMemFree(pLogObject->hMemObject, pLogObject->pThreadInfo);

        // Set the pointer to the next thread info in the list
        pLogObject->pThreadInfo = pNextThreadInfo;
    }

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    // Log the variation results
    xLogResults(hLog, NULL);

    // Log the system state, if specified
    if (0 != (pLogObject->dwLogOptions & XLO_STATE)) {
        xLogResourceStatus(hLog, NULL);
    }

    // Log the end banner
    LogBanner(hLog, "xLog Ended", NULL);

    // Decrement the ref count of the web post log file, if necessary
    if (INVALID_HANDLE_VALUE != pLogObject->hWebPostFile) {
        ReleaseWebPostLogFile(pLogObject->lpszWebPostFileName_A);
    }

    // Close the log file, if necessary
    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hLogFile);

        // Close the log file
        CloseHandle(pLogObject->hLogFile);
    }

    // Delete the critical sections
    DeleteCriticalSection(pLogObject->pConsoleSocketcs);
    DeleteCriticalSection(pLogObject->pcs);

    // Free the XLOG_OBJECT buffer
    xMemFree(g_LogInfo.hMemObject, pLogObject);

    // Decrement the xLog ref count
    g_LogInfo.dwRefCount--;

    if (0 == g_LogInfo.dwRefCount) {
        while (NULL != g_LogInfo.pWebPostLogFile) {
            // Assert the web post log file ref count is 0
            ASSERT(0 == g_LogInfo.pWebPostLogFile->dwRefCount);

            // Get the next web post log file in the list
            pNextWebPostLogFile = g_LogInfo.pWebPostLogFile->pNextWebPostLogFile;
            if (NULL != pNextWebPostLogFile) {
                pNextWebPostLogFile->pPrevWebPostLogFile = NULL;
            }

            // Flush the file buffers to prevent corruption
            FlushFileBuffers(g_LogInfo.pWebPostLogFile->hFile);

            // Upload the current web post log file
            if (TRUE == UploadWebPostLogFile(g_LogInfo.pWebPostLogFile->hFile)) {
                // Close the web post log file
                CloseHandle(g_LogInfo.pWebPostLogFile->hFile);

                // Delete the web post log file
                DeleteFileA(g_LogInfo.pWebPostLogFile->szWebPostFileName_A);
            }
            else {
                // Close the web post log file
                CloseHandle(g_LogInfo.pWebPostLogFile->hFile);
            }

            // Free the current web post log file
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.pWebPostLogFile);

            // Set the pointer to the next web post log file in the list
            g_LogInfo.pWebPostLogFile = pNextWebPostLogFile;
        }

#ifdef _XBOX
        // Free the disk model and serial number
        if (NULL != g_LogInfo.lpszDiskModel) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszDiskModel);
            g_LogInfo.lpszDiskModel = NULL;
        }

        if (NULL != g_LogInfo.lpszDiskSerial) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszDiskSerial);
            g_LogInfo.lpszDiskSerial = NULL;
        }
#endif
        // Free the host name
        if (NULL != g_LogInfo.lpszHostName_A) {
            xMemFree(g_LogInfo.hMemObject, g_LogInfo.lpszHostName_A);
            g_LogInfo.lpszHostName_A = NULL;
        }

        // Close the memory object
        if (INVALID_HANDLE_VALUE != g_LogInfo.hMemObject) {
            xMemClose(g_LogInfo.hMemObject);
            g_LogInfo.hMemObject = INVALID_HANDLE_VALUE;
        }
    }

    // Release the xlog info mutex
    ReleaseMutex(g_hLogInfoMutex);

    return TRUE;
}



namespace xLogNamespace {

VOID
ReleaseWebPostLogFile(
    IN  LPSTR   lpszWebPostFileName_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decrements the reference count of a web post log file

Arguments:

  lpszWebPostFileName_A - Pointer to a null-terminated string (ANSI) that specifies the web post log file

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pCurrentWebPostLogFile is a pointer to the current web post log file in the list
    PWEBPOST_LOGFILE  pCurrentWebPostLogFile = NULL;



    // Set the pointer to the head of the web post log file list
    pCurrentWebPostLogFile = g_LogInfo.pWebPostLogFile;

    while (NULL != pCurrentWebPostLogFile) {
        if (0 == _stricmp(lpszWebPostFileName_A, pCurrentWebPostLogFile->szWebPostFileName_A)) {
            // Decrement the ref count
            pCurrentWebPostLogFile->dwRefCount--;

            break;
        }

        // Set the pointer to the next web post log file in the list
        pCurrentWebPostLogFile = pCurrentWebPostLogFile->pNextWebPostLogFile;
    }
}



BOOL
UploadWebPostLogFile(
    IN  HANDLE  hFile
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Posts the results cached in the file specified by hFile

Arguments:

  hFile - Handle to the web post log file

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // bNetStackInitialized specifies if the net stack is initialized
    BOOL         bNetStackInitialized = FALSE;
    // szWebPostLen_A is the web post length
    CHAR         szWebPostLen_A[6];
    // szHttpAddr_A is the string representation of the http server host address
    CHAR         szHttpAddr_A[13];
    // szWebPost_A is the web post
    CHAR         szWebPost_A[MAX_WEBPOST_LENGTH];
    // HttpAddr is the host address of the http server, in network byte order.
    u_long       HttpAddr;
    // dwByte is a counter to enumerate each byte of the http server host address, from high to low
    DWORD        dwByte;
    // pWebSockets is a pointer to the list of web sockets
    PWEB_SOCKET  pWebSockets = NULL;
    // pCurrentWebSocket is a pointer to the current web socket in the list
    PWEB_SOCKET  pCurrentWebSocket = NULL;
    // dwBytesRead is the number of bytes read from the file
    DWORD        dwBytesRead;
    // dwBytesToRead is the number of bytes to read from the file
    DWORD        dwBytesToRead;
    // dwErrorCode is the last error code
    DWORD        dwErrorCode = ERROR_SUCCESS;



    // Increment the net stack reference count
    bNetStackInitialized = AddRefNet();
    if (FALSE == bNetStackInitialized) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionExit;
    }

    // Set the file pointer to the end of the file
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    while (TRUE) {
        // Get the web post length
        ZeroMemory(szWebPostLen_A, sizeof(szWebPostLen_A));
        if (FALSE == ReadFile(hFile, szWebPostLen_A, 5, &dwBytesRead, NULL)) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionExit;
        }

        if (0 == dwBytesRead) {
            break;
        }

        // Calculate the length of the web post
        dwBytesToRead = ((szWebPostLen_A[0] - '0') * 100) + ((szWebPostLen_A[1] - '0') * 10) + (szWebPostLen_A[2] - '0') + 2;

        // Get the http server host address
        ZeroMemory(szHttpAddr_A, sizeof(szHttpAddr_A));
        if (FALSE == ReadFile(hFile, szHttpAddr_A, 12, &dwBytesRead, NULL)) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionExit;
        }

        // Calculate the host address of the http server
        for (HttpAddr = 0, dwByte = 0; dwByte < 8; dwByte++) {
            if (('a' <= szHttpAddr_A[2 + dwByte]) && ('f' >= szHttpAddr_A[2 + dwByte])) {
                HttpAddr = (HttpAddr << 4) + 10 + (szHttpAddr_A[2 + dwByte] - 'a');
            }
            else if (('A' <= szHttpAddr_A[2 + dwByte]) && ('F' >= szHttpAddr_A[2 + dwByte])) {
                HttpAddr = (HttpAddr << 4) + 10 + (szHttpAddr_A[2 + dwByte] - 'A');
            }
            else {
                HttpAddr = (HttpAddr << 4) + (szHttpAddr_A[2 + dwByte] - '0');
            }
        }

        // Get the web post
        ZeroMemory(szWebPost_A, sizeof(szWebPost_A));
        if (FALSE == ReadFile(hFile, szWebPost_A, dwBytesToRead, &dwBytesRead, NULL)) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionExit;
        }
        szWebPost_A[dwBytesToRead - 1] = '\0';
        szWebPost_A[dwBytesToRead - 2] = '\0';

        // Check if a connection to the http server exists
        pCurrentWebSocket = pWebSockets;

        while (NULL != pCurrentWebSocket) {
            if (HttpAddr == pCurrentWebSocket->HttpAddr) {
                break;
            }

            // Set the current web socket to the next web socket in the list
            pCurrentWebSocket = pCurrentWebSocket->pNextWebSocket;
        }

        if (NULL == pCurrentWebSocket) {
            // A connection to the http server does not exist

            // Create the web socket
            pCurrentWebSocket = (PWEB_SOCKET) xMemAlloc(g_LogInfo.hMemObject, sizeof(WEB_SOCKET));
            if (NULL == pCurrentWebSocket) {
                // Get the last error code
                dwErrorCode = GetLastError();

                goto FunctionExit;
            }

            // Add the new web socket to the head of the list
            pCurrentWebSocket->pNextWebSocket = pWebSockets;
            if (NULL != pWebSockets) {
                pWebSockets->pPrevWebSocket = pCurrentWebSocket;
            }

            // Set the head of the web socket list to the current web socket
            pWebSockets = pCurrentWebSocket;

            // Set the host address of the http server
            pCurrentWebSocket->HttpAddr = HttpAddr;

            // Set the web socket
            pCurrentWebSocket->sWebSocket = INVALID_SOCKET;
        }

        if (INVALID_SOCKET == pCurrentWebSocket->sWebSocket) {
            // Connect to the web server
            pCurrentWebSocket->sWebSocket = ConnectWebServer(HttpAddr);
        }

        // Send the web post
        if ((INVALID_SOCKET == pCurrentWebSocket->sWebSocket) || (FALSE == PostString(pCurrentWebSocket->sWebSocket, szWebPost_A, strlen(szWebPost_A)))) {
            // Get the last error code
            dwErrorCode = GetLastError();

            shutdown(pCurrentWebSocket->sWebSocket, SD_BOTH);
            closesocket(pCurrentWebSocket->sWebSocket);
            pCurrentWebSocket->sWebSocket = INVALID_SOCKET;
        }
    }

FunctionExit:
    // Close the web sockets
    while (NULL != pWebSockets) {
        pCurrentWebSocket = pWebSockets;
        pWebSockets = pWebSockets->pNextWebSocket;
        if (NULL != pWebSockets) {
            pWebSockets->pPrevWebSocket = NULL;
        }

        // Close the current web socket
        shutdown(pCurrentWebSocket->sWebSocket, SD_BOTH);
        closesocket(pCurrentWebSocket->sWebSocket);

        // Free the current web socket
        xMemFree(g_LogInfo.hMemObject, pCurrentWebSocket);
    }

    // Decrement the net stack reference count, if necessary
    if (TRUE == bNetStackInitialized) {
        ReleaseNet();
    }

    if (ERROR_SUCCESS != dwErrorCode) {
        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return (ERROR_SUCCESS == dwErrorCode);
}

} // namespace xLogNamespace



BOOL
WINAPI
xSetOwnerAlias(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszOwnerAlias_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the owner alias of the log object

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszOwnerAlias_A - Pointer to a null-terminated string (ANSI) that specifies the owner alias

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Initialize the owner alias
    ZeroMemory(pLogObject->szOwnerAlias_A, sizeof(pLogObject->szOwnerAlias_A));

    // Copy the owner alias
    if (NULL != lpszOwnerAlias_A) {
        strncpy(pLogObject->szOwnerAlias_A, lpszOwnerAlias_A, OWNER_ALIAS_LENGTH);
    }

    return TRUE;
}



BOOL
WINAPI
xSetComponent(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszComponentName_A,
    IN  LPSTR   lpszSubcomponentName_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the component and subcomponent used in logging for the thread

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszComponentName_A - Pointer to a null-terminated string (ANSI) that specifies the component name
  lpszSubcomponentName_A - Pointer to a null-terminated string (ANSI) that specifies the subcomponent name

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT    pLogObject = (PXLOG_OBJECT) hLog;
    // dwThreadId is the id of the current thread
    DWORD           dwThreadId = GetCurrentThreadId();
    // pCurrentThreadInfo a pointer to the thread info for the current thread
    PTHREAD_INFO    pCurrentThreadInfo = NULL;
    // bThreadInfoAllocated indicates the thread info was allocated
    BOOL            bThreadInfoAllocated = FALSE;
    // lpszComma is a pointer to a comma in the component name or subcomponent name
    LPSTR           lpszComma = NULL;
    // dwErrorCode is the last error code
    DWORD           dwErrorCode = ERROR_SUCCESS;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Assert parameters are both NULL or both not NULL
    ASSERT(((NULL == lpszComponentName_A) && (NULL == lpszSubcomponentName_A)) || ((NULL != lpszComponentName_A) && (NULL != lpszSubcomponentName_A)));

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    if ((NULL == lpszComponentName_A) && (NULL == lpszSubcomponentName_A)) {
        if (NULL != pCurrentThreadInfo) {
            if (NULL != pCurrentThreadInfo->pFunctionInfo) {
                // Free the memory for the function info
                xMemFree(pLogObject->hMemObject, pCurrentThreadInfo->pFunctionInfo);
                pCurrentThreadInfo->pFunctionInfo = NULL;
            }

            if (NULL == pCurrentThreadInfo->pVariationList) {
                // Remove the thread info from the list
                if (NULL != pCurrentThreadInfo->pPrevThreadInfo) {
                    pCurrentThreadInfo->pPrevThreadInfo->pNextThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
                }
                else {
                    pLogObject->pThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
                }

                if (NULL != pCurrentThreadInfo->pNextThreadInfo) {
                    pCurrentThreadInfo->pNextThreadInfo->pPrevThreadInfo = pCurrentThreadInfo->pPrevThreadInfo;
                }

                // Free the memory for the thread info
                xMemFree(pLogObject->hMemObject, pCurrentThreadInfo);                
            }
        }

        goto FunctionExit;
    }

    if (NULL == pCurrentThreadInfo) {
        // Allocate the memory for the thread info
        pCurrentThreadInfo = (PTHREAD_INFO) xMemAlloc(pLogObject->hMemObject, sizeof(THREAD_INFO));
        if (NULL == pCurrentThreadInfo) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionExit;
        }

        bThreadInfoAllocated = TRUE;

        // Set the thread id
        pCurrentThreadInfo->dwThreadId = dwThreadId;

        // Add the thread info to the list
        pCurrentThreadInfo->pNextThreadInfo = pLogObject->pThreadInfo;
        if (NULL != pLogObject->pThreadInfo) {
            pLogObject->pThreadInfo->pPrevThreadInfo = pCurrentThreadInfo;
        }
        pLogObject->pThreadInfo = pCurrentThreadInfo;
    }

    if (NULL == pCurrentThreadInfo->pFunctionInfo) {
        // Allocate the memory for the function info
        pCurrentThreadInfo->pFunctionInfo = (PFUNCTION_INFO) xMemAlloc(pLogObject->hMemObject, sizeof(FUNCTION_INFO));
        if (NULL == pCurrentThreadInfo->pFunctionInfo) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionExit;
        }

        // Set the pointer to the component name
        pCurrentThreadInfo->pFunctionInfo->lpszComponentName_A = pCurrentThreadInfo->pFunctionInfo->szComponentName_A;
        // Set the pointer to the subcomponent name
        pCurrentThreadInfo->pFunctionInfo->lpszSubcomponentName_A = pCurrentThreadInfo->pFunctionInfo->szSubcomponentName_A;
    }

    // Reset the component name
    ZeroMemory(pCurrentThreadInfo->pFunctionInfo->szComponentName_A, COMPONENT_NAME_LENGTH + 1);

    // Copy the component name
    strncpy(pCurrentThreadInfo->pFunctionInfo->szComponentName_A, lpszComponentName_A, COMPONENT_NAME_LENGTH);

    // Parse the component name for commas and replace with spaces
    lpszComma = pCurrentThreadInfo->pFunctionInfo->szComponentName_A;
    while (NULL != (lpszComma = strchr(lpszComma, ','))) {
        *lpszComma = ' ';
    }

    // Reset the subcomponent name
    ZeroMemory(pCurrentThreadInfo->pFunctionInfo->szSubcomponentName_A, SUBCOMPONENT_NAME_LENGTH + 1);

    // Copy the subcomponent name
    strncpy(pCurrentThreadInfo->pFunctionInfo->szSubcomponentName_A, lpszSubcomponentName_A, SUBCOMPONENT_NAME_LENGTH);

    // Parse the subcomponent name for commas and replace with spaces
    lpszComma = pCurrentThreadInfo->pFunctionInfo->szSubcomponentName_A;
    while (NULL != (lpszComma = strchr(lpszComma, ','))) {
        *lpszComma = ' ';
    }

    // Reset the function name
    ZeroMemory(pCurrentThreadInfo->pFunctionInfo->szFunctionName_A, FUNCTION_NAME_LENGTH + 1);
    pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A = NULL;

FunctionExit:
    if (ERROR_SUCCESS != dwErrorCode) {
        if (TRUE == bThreadInfoAllocated) {
            // Remove the thread info from the list
            pLogObject->pThreadInfo = pLogObject->pThreadInfo->pNextThreadInfo;
            if (NULL != pLogObject->pThreadInfo) {
                pLogObject->pThreadInfo->pPrevThreadInfo = NULL;
            }

            // Free the thread info
            xMemFree(pLogObject->hMemObject, pCurrentThreadInfo);
        }
    }

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    if (ERROR_SUCCESS != dwErrorCode) {
        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return (ERROR_SUCCESS == dwErrorCode);
}



BOOL
WINAPI
xSetFunctionName(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszFunctionName_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the function name used in logging for the thread

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszFunctionName_A - Pointer to a null-terminated string (ANSI) that specifies the function name

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT    pLogObject = (PXLOG_OBJECT) hLog;
    // dwThreadId is the id of the current thread
    DWORD           dwThreadId = GetCurrentThreadId();
    // pCurrentThreadInfo a pointer to the thread info for the current thread
    PTHREAD_INFO    pCurrentThreadInfo = NULL;
    // lpszComma is a pointer to a comma in the component name or subcomponent name
    LPSTR           lpszComma = NULL;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Assert lpszFunctionName_A is not NULL
    ASSERT(NULL != lpszFunctionName_A);

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    // Assert pCurrentThreadInfo is not NULL
    ASSERT(NULL != pCurrentThreadInfo);
    // Assert pFunctionInfo is not NULL
    ASSERT(NULL != pCurrentThreadInfo->pFunctionInfo);
    // Assert component name is not NULL
    ASSERT(NULL != pCurrentThreadInfo->pFunctionInfo->lpszComponentName_A);
    // Assert subcomponent name is not NULL
    ASSERT(NULL != pCurrentThreadInfo->pFunctionInfo->lpszSubcomponentName_A);

    // Reset the function name
    ZeroMemory(pCurrentThreadInfo->pFunctionInfo->szFunctionName_A, FUNCTION_NAME_LENGTH + 1);

    // Copy the function name
    strncpy(pCurrentThreadInfo->pFunctionInfo->szFunctionName_A, lpszFunctionName_A, FUNCTION_NAME_LENGTH);

    // Parse the function name for commas and replace with spaces
    lpszComma = pCurrentThreadInfo->pFunctionInfo->szFunctionName_A;
    while (NULL != (lpszComma = strchr(lpszComma, ','))) {
        *lpszComma = ' ';
    }

    // Set the pointer to the function name
    pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A = pCurrentThreadInfo->pFunctionInfo->szFunctionName_A;

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    return TRUE;
}



BOOL
WINAPI
xStartVariationEx(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszVariationName_A,
    IN  int     nVariationTime
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Starts a variation logging sequence for the thread:
    Creates a new variation element
    Adds the new variation element to the head of the variation list
    Copies the variation name into the variation element
    Increments the dwVariationsTotal member in the XLOG_OBJECT
    Logs the variation name
    Caches current times

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszVariationName_A - Pointer to a null-terminated string (ANSI) that specifies the variation name
  nVariationTime - Specifies if variation times are logged

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT        pLogObject = (PXLOG_OBJECT) hLog;
    // dwThreadId is the id of the current thread
    DWORD               dwThreadId = GetCurrentThreadId();
    // pCurrentThreadInfo a pointer to the thread info for the current thread
    PTHREAD_INFO        pCurrentThreadInfo = NULL;
    // bThreadInfoAllocated indicates the thread info was allocated
    BOOL                bThreadInfoAllocated = FALSE;
    // pVariationElement is a pointer to the new variation element
    PVARIATION_ELEMENT  pVariationElement = NULL;
    // lpszComma is a pointer to a comma in the variation name
    LPSTR               lpszComma = NULL;
    // bReturnCode is the return code of this function
    BOOL                bReturnCode = TRUE;
    // dwErrorCode is the last error code
    DWORD               dwErrorCode = ERROR_SUCCESS;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Assert lpszVariationName_A is not NULL
    ASSERT(NULL != lpszVariationName_A);

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    if (NULL == pCurrentThreadInfo) {
        // Allocate the memory for the thread info
        pCurrentThreadInfo = (PTHREAD_INFO) xMemAlloc(pLogObject->hMemObject, sizeof(THREAD_INFO));
        if (NULL == pCurrentThreadInfo) {
            // Get the last error code
            dwErrorCode = GetLastError();

            goto FunctionFailed;
        }

        bThreadInfoAllocated = TRUE;

        // Set the thread id
        pCurrentThreadInfo->dwThreadId = dwThreadId;

        // Add the thread info to the list
        pCurrentThreadInfo->pNextThreadInfo = pLogObject->pThreadInfo;
        if (NULL != pLogObject->pThreadInfo) {
            pLogObject->pThreadInfo->pPrevThreadInfo = pCurrentThreadInfo;
        }
        pLogObject->pThreadInfo = pCurrentThreadInfo;
    }

    // Allocate the memory for a variation element
    pVariationElement = (PVARIATION_ELEMENT) xMemAlloc(pLogObject->hMemObject, sizeof(VARIATION_ELEMENT));
    if (NULL == pVariationElement) {
        // Get the last error code
        dwErrorCode = GetLastError();

        goto FunctionFailed;
    }

    // Add the variation element to the list
    pVariationElement->pNextVariationElement = pCurrentThreadInfo->pVariationList;
    if (NULL != pCurrentThreadInfo->pVariationList) {
        pCurrentThreadInfo->pVariationList->pPrevVariationElement = pVariationElement;
    }
    pCurrentThreadInfo->pVariationList = pVariationElement;

    // Copy the variation name
    strncpy(pVariationElement->szVariationName_A, lpszVariationName_A, VARIATION_NAME_LENGTH);

    // Parse the variation name for commas and replace with spaces
    lpszComma = pVariationElement->szVariationName_A;
    while (NULL != (lpszComma = strchr(lpszComma, ','))) {
        *lpszComma = ' ';
    }

    // Set the pointer to the variation name
    pVariationElement->lpszVariationName_A = pVariationElement->szVariationName_A;

    // Increment the dwVariationsTotal member
    pLogObject->dwVariationsTotal++;

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    // Log the variation name
    bReturnCode = xLog(hLog, XLL_VARIATION_START, "Variation Started: %s", lpszVariationName_A);

#ifdef _XBOX
    pVariationElement->bVariationTime = FALSE;
    if (0 == nVariationTime) {
        pVariationElement->bVariationTime = (0 != (XLL_VARIATION_TIME & pLogObject->dwLogLevel));
    }
    else if (0 > nVariationTime) {
        pVariationElement->bVariationTime = FALSE;
    }
    else if (0 < nVariationTime) {
        pVariationElement->bVariationTime = TRUE;
    }

    if (TRUE == pVariationElement->bVariationTime) {
        // Get the current times
        GetSystemTimeAsFileTime((FILETIME *) &pVariationElement->InitialTime);
        QueryCpuTimesInformation((LARGE_INTEGER *) &pVariationElement->InitialKernelTime, (LARGE_INTEGER *) &pVariationElement->InitialIdleTime, (LARGE_INTEGER *) &pVariationElement->InitialDpcTime, (LARGE_INTEGER *) &pVariationElement->InitialInterruptTime, NULL);
    }
#else
    pVariationElement->bVariationTime = FALSE;
#endif

    return bReturnCode;

FunctionFailed:
    if (NULL != pVariationElement) {
        // Remove the variation element from the list
        pCurrentThreadInfo->pVariationList = pVariationElement->pNextVariationElement;
        if (NULL != pCurrentThreadInfo->pVariationList) {
            pCurrentThreadInfo->pVariationList->pPrevVariationElement = NULL;
        }

        // Free the variation element
        xMemFree(pLogObject->hMemObject, pVariationElement);
    }

    if (TRUE == bThreadInfoAllocated) {
        // Remove the thread info from the list
        pLogObject->pThreadInfo = pLogObject->pThreadInfo->pNextThreadInfo;
        if (NULL != pLogObject->pThreadInfo) {
            pLogObject->pThreadInfo->pPrevThreadInfo = NULL;
        }

        // Free the thread info
        xMemFree(pLogObject->hMemObject, pCurrentThreadInfo);
    }

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    // Set the last error code
    SetLastError(dwErrorCode);

    return FALSE;
}



BOOL
WINAPI
xStartVariation(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszVariationName_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Passthrough to xStartVariationEx

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszVariationName_A - Pointer to a null-terminated string (ANSI) that specifies the variation name

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Call xStartVariationEx
    return xStartVariationEx(hLog, lpszVariationName_A, 0);
}



DWORD
WINAPI
xEndVariation(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Ends a variation logging sequence for the thread:
    Gets the variation list from TLS
    Gets the variation result from the head of the variation list
    Increments the appropriate variation result member in the XLOG_OBJECT
    Logs and web posts the variation name and result
    Sets the new head of the variation list in TLS
    Frees the old head of the variation list

Arguments:

  hLog - Handle to the XLOG_OBJECT

Return Value:

  DWORD:
    The dwVariationResult value from TLS.

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT        pLogObject = (PXLOG_OBJECT) hLog;
    // dwThreadId is the id of the current thread
    DWORD               dwThreadId = GetCurrentThreadId();
    // pCurrentThreadInfo a pointer to the thread info for the current thread
    PTHREAD_INFO        pCurrentThreadInfo = NULL;
    // pVariationElement is a pointer to the variation element
    PVARIATION_ELEMENT  pVariationElement = NULL;
    // dwVariationResult is the variation result
    DWORD               dwVariationResult = 0;

    // lpszComponentName_A is a pointer to the component name
    LPSTR               lpszComponentName_A = NO_COMPONENT_STRING;
    // lpszSubcomponentName_A is a pointer to the subcomponent name
    LPSTR               lpszSubcomponentName_A = NO_SUBCOMPONENT_STRING;
    // lpszFunctionName_A is a pointer to the function name
    LPSTR               lpszFunctionName_A = NO_FUNCTION_STRING;
    // lpszVariationName_A is a pointer to the variation name
    LPSTR               lpszVariationName_A = NO_VARIATION_STRING;

#ifdef _XBOX
    // CurrentTime is the current time
    ULONGLONG           CurrentTime;
    // CurrentSeconds is the current time (seconds)
    ULONGLONG           CurrentSeconds;
    // CurrentMilliSeconds is the current time (milli-seconds)
    ULONGLONG           CurrentMilliSeconds;
    // CurrentMicroSeconds is the current time (micro-seconds)
    ULONGLONG           CurrentMicroSeconds;

    // CurrentKernelTime is the current kernel time
    ULONGLONG           CurrentKernelTime;
    // CurrentKernelSeconds is the current kernel time (seconds)
    ULONGLONG           CurrentKernelSeconds;
    // CurrentKernelMilliSeconds is the current kernel time (milli-seconds)
    ULONGLONG           CurrentKernelMilliSeconds;
    // CurrentKernelMicroSeconds is the current kernel time (micro-seconds)
    ULONGLONG           CurrentKernelMicroSeconds;

    // CurrentIdleTime is the current idle time
    ULONGLONG           CurrentIdleTime;
    // CurrentIdleSeconds is the current idle time (seconds)
    ULONGLONG           CurrentIdleSeconds;
    // CurrentIdleMilliSeconds is the current idle time (milli-seconds)
    ULONGLONG           CurrentIdleMilliSeconds;
    // CurrentIdleMicroSeconds is the current idle time (micro-seconds)
    ULONGLONG           CurrentIdleMicroSeconds;

    // CurrentDpcTime is the current dpc time
    ULONGLONG           CurrentDpcTime;
    // CurrentDpcSeconds is the current dpc time (seconds)
    ULONGLONG           CurrentDpcSeconds;
    // CurrentDpcMilliSeconds is the current dpc time (milli-seconds)
    ULONGLONG           CurrentDpcMilliSeconds;
    // CurrentDpcMicroSeconds is the current dpc time (micro-seconds)
    ULONGLONG           CurrentDpcMicroSeconds;

    // CurrentInterruptTime is the current interrupt time
    ULONGLONG           CurrentInterruptTime;
    // CurrentInterruptSeconds is the current interrupt time (seconds)
    ULONGLONG           CurrentInterruptSeconds;
    // CurrentInterruptMilliSeconds is the current interrupt time (milli-seconds)
    ULONGLONG           CurrentInterruptMilliSeconds;
    // CurrentInterruptMicroSeconds is the current interrupt time (micro-seconds)
    ULONGLONG           CurrentInterruptMicroSeconds;



    // Get the current times
    QueryCpuTimesInformation((LARGE_INTEGER *) &CurrentKernelTime, (LARGE_INTEGER *) &CurrentIdleTime, (LARGE_INTEGER *) &CurrentDpcTime, (LARGE_INTEGER *) &CurrentInterruptTime, NULL);
    GetSystemTimeAsFileTime((FILETIME *) &CurrentTime);
#endif

    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    // Assert pCurrentThreadInfo is not NULL
    ASSERT(NULL != pCurrentThreadInfo);
    // Assert pVariationList is not NULL
    ASSERT(NULL != pCurrentThreadInfo->pVariationList);
    // Assert variation name is not NULL
    ASSERT(NULL != pCurrentThreadInfo->pVariationList->lpszVariationName_A);
    // Assert variation result is not 0
    ASSERT(0 != pCurrentThreadInfo->pVariationList->dwVariationResult);

    // Get the variation element
    pVariationElement = pCurrentThreadInfo->pVariationList;

#ifdef _XBOX
    if (TRUE == pVariationElement->bVariationTime) {
        // Calculate and log the times
        CurrentTime = CurrentTime - pVariationElement->InitialTime;
        CurrentMicroSeconds = CurrentTime / 10;
        CurrentMilliSeconds = CurrentTime / 10000;
        CurrentSeconds = CurrentTime / 10000000;
        CurrentMilliSeconds -= (CurrentSeconds * 1000);
        CurrentMicroSeconds -= ((CurrentSeconds * 1000 * 1000) + (CurrentMilliSeconds * 1000));
        xLog(hLog, XLL_VARIATION_TIME, "Variation Time - %I64u.%03I64u.%03I64u Seconds", CurrentSeconds, CurrentMilliSeconds, CurrentMicroSeconds);

        CurrentKernelTime = CurrentKernelTime - pVariationElement->InitialKernelTime;
        CurrentKernelMicroSeconds = CurrentKernelTime / 10;
        CurrentKernelMilliSeconds = CurrentKernelTime / 10000;
        CurrentKernelSeconds = CurrentKernelTime / 10000000;
        CurrentKernelMilliSeconds -= (CurrentKernelSeconds * 1000);
        CurrentKernelMicroSeconds -= ((CurrentKernelSeconds * 1000 * 1000) + (CurrentKernelMilliSeconds * 1000));
        xLog(hLog, XLL_VARIATION_TIME, "Kernel Time - %I64u.%03I64u.%03I64u Seconds", CurrentKernelSeconds, CurrentKernelMilliSeconds, CurrentKernelMicroSeconds);

        CurrentIdleTime = CurrentIdleTime - pVariationElement->InitialIdleTime;
        CurrentIdleMicroSeconds = CurrentIdleTime / 10;
        CurrentIdleMilliSeconds = CurrentIdleTime / 10000;
        CurrentIdleSeconds = CurrentIdleTime / 10000000;
        CurrentIdleMilliSeconds -= (CurrentIdleSeconds * 1000);
        CurrentIdleMicroSeconds -= ((CurrentIdleSeconds * 1000 * 1000) + (CurrentIdleMilliSeconds * 1000));
        xLog(hLog, XLL_VARIATION_TIME, "Idle Time - %I64u.%03I64u.%03I64u Seconds", CurrentIdleSeconds, CurrentIdleMilliSeconds, CurrentIdleMicroSeconds);

        CurrentDpcTime = CurrentDpcTime - pVariationElement->InitialDpcTime;
        CurrentDpcMicroSeconds = CurrentDpcTime / 10;
        CurrentDpcMilliSeconds = CurrentDpcTime / 10000;
        CurrentDpcSeconds = CurrentDpcTime / 10000000;
        CurrentDpcMilliSeconds -= (CurrentDpcSeconds * 1000);
        CurrentDpcMicroSeconds -= ((CurrentDpcSeconds * 1000 * 1000) + (CurrentDpcMilliSeconds * 1000));
        xLog(hLog, XLL_VARIATION_TIME, "Dpc Time - %I64u.%03I64u.%03I64u Seconds", CurrentDpcSeconds, CurrentDpcMilliSeconds, CurrentDpcMicroSeconds);

        CurrentInterruptTime = CurrentInterruptTime - pVariationElement->InitialInterruptTime;
        CurrentInterruptMicroSeconds = CurrentInterruptTime / 10;
        CurrentInterruptMilliSeconds = CurrentInterruptTime / 10000;
        CurrentInterruptSeconds = CurrentInterruptTime / 10000000;
        CurrentInterruptMilliSeconds -= (CurrentInterruptSeconds * 1000);
        CurrentInterruptMicroSeconds -= ((CurrentInterruptSeconds * 1000 * 1000) + (CurrentInterruptMilliSeconds * 1000));
        xLog(hLog, XLL_VARIATION_TIME, "Interrupt Time - %I64u.%03I64u.%03I64u Seconds", CurrentInterruptSeconds, CurrentInterruptMilliSeconds, CurrentInterruptMicroSeconds);
    }
#endif

    // Get the variation result
    dwVariationResult = pVariationElement->dwVariationResult;

    // Increment the variation result
    IncrementVariationResult(hLog, dwVariationResult, FALSE);

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    // Log the variation name
    xLog(hLog, XLL_VARIATION_END, "Variation Ended: %s", pVariationElement->lpszVariationName_A);

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    if (NULL != pCurrentThreadInfo->pFunctionInfo) {
        // Set the component name
        lpszComponentName_A = pCurrentThreadInfo->pFunctionInfo->lpszComponentName_A;
        // Set the subcomponent name
        lpszSubcomponentName_A = pCurrentThreadInfo->pFunctionInfo->lpszSubcomponentName_A;

        if (NULL != pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A) {
            // Set the function name
            lpszFunctionName_A = pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A;
        }
    }

    // Set the variation name
    lpszVariationName_A = pVariationElement->lpszVariationName_A;

    // Post the result
    PostResult(hLog, dwVariationResult, lpszComponentName_A, lpszSubcomponentName_A, lpszFunctionName_A, lpszVariationName_A, pVariationElement->lpszLogString_A);

    // Remove the variation element from the list
    pCurrentThreadInfo->pVariationList = pVariationElement->pNextVariationElement;
    if (NULL != pCurrentThreadInfo->pVariationList) {
        pCurrentThreadInfo->pVariationList->pPrevVariationElement = NULL;
    }

    if ((NULL == pCurrentThreadInfo->pFunctionInfo) && (NULL == pCurrentThreadInfo->pVariationList)) {
        // Remove the thread info from the list
        if (NULL != pCurrentThreadInfo->pPrevThreadInfo) {
            pCurrentThreadInfo->pPrevThreadInfo->pNextThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
        }
        else {
            pLogObject->pThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
        }

        if (NULL != pCurrentThreadInfo->pNextThreadInfo) {
            pCurrentThreadInfo->pNextThreadInfo->pPrevThreadInfo = pCurrentThreadInfo->pPrevThreadInfo;
        }

        // Free the memory for the thread info
        xMemFree(pLogObject->hMemObject, pCurrentThreadInfo);                
    }

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    // Free the variation element
    xMemFree(pLogObject->hMemObject, pVariationElement);

    return dwVariationResult;
}



namespace xLogNamespace {

BOOL
LogString(
    IN  HANDLE  hLog,
    IN  DWORD   dwLogLevel,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes the line of output to the log file.

Arguments:

  hLog - Handle to the XLOG_OBJECT
  dwLogLevel - Specifies the logging level for this line of output.  It can be one of the XLL_ #defines.
  lpszLogString_A - Pointer to a null-terminated string (ANSI) that specifies the log string

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT        pLogObject = (PXLOG_OBJECT) hLog;
    // dwThreadId is the id of the current thread
    DWORD               dwThreadId = GetCurrentThreadId();
    // pCurrentThreadInfo a pointer to the thread info for the current thread
    PTHREAD_INFO        pCurrentThreadInfo = NULL;
    // pVariationElement is a pointer to the variation element
    PVARIATION_ELEMENT  pVariationElement = NULL;

    // lpszComponentName_A is a pointer to the component name
    LPSTR               lpszComponentName_A = NO_COMPONENT_STRING;
    // lpszSubcomponentName_A is a pointer to the subcomponent name
    LPSTR               lpszSubcomponentName_A = NO_SUBCOMPONENT_STRING;
    // lpszFunctionName_A is a pointer to the function name
    LPSTR               lpszFunctionName_A = NO_FUNCTION_STRING;
    // lpszVariationName_A is a pointer to the variation name
    LPSTR               lpszVariationName_A = NO_VARIATION_STRING;

    // LocalTime is the current local time in hours, minutes, seconds, etc.
    SYSTEMTIME          LocalTime = {0, 0, 0, 0, 0, 0, 0, 0};
    // lpszLogLevel is a pointer to the string representation of the log level
    LPSTR               lpszLogLevel_A = NULL;
    // szOutputString is the line of log output
    CHAR                szOutputString_A[LOG_OUTPUT_LENGTH] = {'\0'};

    // dwErrorCode is the last error code
    DWORD               dwErrorCode = ERROR_SUCCESS;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Get the current thread info
    pCurrentThreadInfo = pLogObject->pThreadInfo;

    while (NULL != pCurrentThreadInfo) {
        if (dwThreadId == pCurrentThreadInfo->dwThreadId) {
            break;
        }

        // Set the current thread info to the next thread info in the list
        pCurrentThreadInfo = pCurrentThreadInfo->pNextThreadInfo;
    }

    // Get the variation element
    pVariationElement = (NULL == pCurrentThreadInfo) ? NULL : pCurrentThreadInfo->pVariationList;

    if (NULL != pVariationElement) {
        // Check if the variation result should be updated
        if ((0 == pVariationElement->dwVariationResult) || (dwLogLevel <= pVariationElement->dwVariationResult)) {
            // Update the variation result
            pVariationElement->dwVariationResult = dwLogLevel;

            // Reset the log string
            ZeroMemory(pVariationElement->szLogString_A, LOG_STRING_LENGTH + 1);

            // Copy the log string
            strncpy(pVariationElement->szLogString_A, lpszLogString_A, LOG_STRING_LENGTH);

            // Set the pointer to the log string
            pVariationElement->lpszLogString_A = pVariationElement->szLogString_A;
        }
    }
    else {
        // Increment the variation result
        IncrementVariationResult(hLog, dwLogLevel, TRUE);
    }

    if ((NULL != pCurrentThreadInfo) && (NULL != pCurrentThreadInfo->pFunctionInfo)) {
        // Set the component name
        lpszComponentName_A = pCurrentThreadInfo->pFunctionInfo->lpszComponentName_A;
        // Set the subcomponent name
        lpszSubcomponentName_A = pCurrentThreadInfo->pFunctionInfo->lpszSubcomponentName_A;

        if (NULL != pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A) {
            // Set the function name
            lpszFunctionName_A = pCurrentThreadInfo->pFunctionInfo->lpszFunctionName_A;
        }
    }

    if (NULL != pVariationElement) {
        // Set the variation name
        lpszVariationName_A = pVariationElement->lpszVariationName_A;
    }

    // Post the result, if necessary
    if (NULL == pVariationElement) {
        // Post the result
        PostResult(hLog, dwLogLevel, lpszComponentName_A, lpszSubcomponentName_A, lpszFunctionName_A, lpszVariationName_A, lpszLogString_A);
    }

    // Check if the line of output should be logged and/or echoed to the debugger
    if ((0 == (dwLogLevel & pLogObject->dwLogLevel)) && (XLL_VARIATION_TIME != dwLogLevel)) {
        goto FunctionExit;
    }

    // Get the current time
    GetLocalTime(&LocalTime);

    // Get the string representation of the log level
    switch (dwLogLevel) {

    case XLL_EXCEPTION:
        lpszLogLevel_A = "EXCEPTION";
        break;

    case XLL_BREAK:
        lpszLogLevel_A = "BREAK";
        break;

    case XLL_FAIL:
        lpszLogLevel_A = "FAIL";
        break;

    case XLL_WARN:
        lpszLogLevel_A = "WARN";
        break;

    case XLL_BLOCK:
        lpszLogLevel_A = "BLOCK";
        break;

    case XLL_PASS:
        lpszLogLevel_A = "PASS";
        break;

    case XLL_INFO:
        lpszLogLevel_A = "INFO";
        break;

    case XLL_VARIATION_START:
        lpszLogLevel_A = "VARIATION START";
        break;

    case XLL_VARIATION_END:
        // Get the variation result
        switch (pVariationElement->dwVariationResult) {

        case XLL_EXCEPTION:
            lpszLogLevel_A = "VARIATION END: EXCEPTION";
            break;

        case XLL_BREAK:
            lpszLogLevel_A = "VARIATION END: BREAK";
            break;

        case XLL_FAIL:
            lpszLogLevel_A = "VARIATION END: FAIL";
            break;

        case XLL_WARN:
            lpszLogLevel_A = "VARIATION END: WARN";
            break;

        case XLL_BLOCK:
            lpszLogLevel_A = "VARIATION END: BLOCK";
            break;

        case XLL_PASS:
            lpszLogLevel_A = "VARIATION END: PASS";
            break;

        default:
            lpszLogLevel_A = "VARIATION END: UNKNOWN";
            break;
        }

        break;

    case XLL_VARIATION_TIME:
        lpszLogLevel_A = "VARIATION TIME";
        break;

    default:
        lpszLogLevel_A = "UNKNOWN";
        break;
    }

    // Format the line of output
    sprintf(szOutputString_A, "%04x,%02d:%02d:%02d,%s,%s,%s,%s,%s,%s\r\n", dwThreadId, LocalTime.wHour, LocalTime.wMinute, LocalTime.wSecond, lpszLogLevel_A, lpszComponentName_A, lpszSubcomponentName_A, lpszFunctionName_A, lpszVariationName_A, lpszLogString_A);

    // Log the line of output
    if (FALSE == FormatAndWriteString(hLog, szOutputString_A)) {
        // Get the last error code
        dwErrorCode = GetLastError();
    }

    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hLogFile);
    }

    if (XLL_BREAK == dwLogLevel) {
        // Echo the line to the debuffer if not already done so
        if (0 == (XLO_DEBUG & pLogObject->dwLogOptions)) {
            OutputDebugStringA(szOutputString_A);
        }

        // Break into the debugger, if specified
        DebugBreak();
    }

FunctionExit:
    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    return (ERROR_SUCCESS == dwErrorCode);
}

} // namespace xLogNamespace



BOOL
WINAPI
xLog_va(
    IN  HANDLE   hLog,
    IN  DWORD    dwLogLevel,
    IN  LPSTR    lpszFormatString_A,
    IN  va_list  varg_ptr
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Passthrough to LogString:
    Gets the function info from TLS
    Gets the variation list from TLS
    Sets the component name, subcomponent name, function name, and variation name to default values
    Formats the log string
    If variation list is not NULL:
      Updates the variation result and log string if dwLogLevel is more severe
    Checks if dwLogLevel is severe enough to log
    If function info is not NULL:
      Gets the component name, subcomponent name, and function name
    If variation list is not NULL:
      Gets the variation name
    Calls LogString

Arguments:

  hLog - Handle to the XLOG_OBJECT
  dwLogLevel - Specifies the logging level for this line of output.  It can be one of the XLL_ #defines.
  lpszFormatString_A - Pointer to a null-terminated string (ANSI) that consists of format-control specifications
  varg_ptr - Pointer to the variable argument list

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // szLogString is the string in the line of log output
    CHAR   szLogString_A[LOG_STRING_LENGTH + 1] = {'\0'};
    // lpszComma is a pointer to a comma in the log string
    LPSTR  lpszComma = NULL;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Format the log string
    _vsnprintf(szLogString_A, LOG_STRING_LENGTH, lpszFormatString_A, varg_ptr);

    // Parse the log string for commas and replace with spaces
    lpszComma = szLogString_A;
    while (NULL != (lpszComma = strchr(lpszComma, ','))) {
        *lpszComma = ' ';
    }

    // Call LogString
    return LogString(hLog, dwLogLevel, szLogString_A);
}



BOOL
WINAPI
xLog(
    IN  HANDLE  hLog,
    IN  DWORD   dwLogLevel,
    IN  LPSTR   lpszFormatString_A,
    IN  ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Passthrough to xLog_va:
    Gets the variable argument list
    Call xLog_va

Arguments:

  hLog - Handle to the XLOG_OBJECT
  dwLogLevel - Specifies the logging level for this line of output.  It can be one of the XLL_ #defines.
  lpszFormatString_A - Pointer to a null-terminated string (ANSI) that consists of format-control specifications

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr = NULL;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Get the variable argument list
    va_start(varg_ptr, lpszFormatString_A);

    // Call xLog_va
    return xLog_va(hLog, dwLogLevel, lpszFormatString_A, varg_ptr);
}



namespace xLogNamespace {

BOOL
xPostConfiguration(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Web posts the system configuration

Arguments:

  hLog - Handle to the XLOG_OBJECT

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;

    // szWebPostConfigData_A is the line of web post data
    CHAR          szWebPostConfigData_A[WEBPOST_CONFIGDATA_LENGTH] = {'\0'};
    // szWebPostConfig_A is the web post
    CHAR          szWebPostConfig_A[WEBPOST_CONFIG_LENGTH] = {'\0'};
    // szWebPostLen_A is the web post length
    CHAR          szWebPostLen_A[6] = {'\0'};
    // szHttpAddr_A is the string representation of the http server host address
    CHAR          szHttpAddr_A[13] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD         dwBytesWritten = 0;

    // szDebugString is the debug string
    CHAR          szDebugString[61];

    // bReturnCode is the return code of this function
    BOOL          bReturnCode = TRUE;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    if (OS_PLATFORM_XBOX == pLogObject->dwPlatformId) {
        // Format the web post data
        sprintf(szWebPostConfigData_A, WEBPOST_CONFIGDATA_FORMAT_XBOX_A, pLogObject->szHostName_A, pLogObject->szObjectUUID_A, 0, 0, pLogObject->XapiVersion, (TRUE == pLogObject->XapiDebug) ? 1 : 0, 0, 0, pLogObject->KernelVersion, (TRUE == pLogObject->KernelDebug) ? 1 : 0);
    }
    else if (OS_PLATFORM_NT == pLogObject->dwPlatformId) {
        // Format the web post data
        sprintf(szWebPostConfigData_A, WEBPOST_CONFIGDATA_FORMAT_NT_A, pLogObject->szHostName_A, pLogObject->szObjectUUID_A, pLogObject->dwMajorVersion, pLogObject->dwMinorVersion, pLogObject->dwBuildNumber, 0);
    }
    else {
        // Format the web post data
        sprintf(szWebPostConfigData_A, WEBPOST_CONFIGDATA_FORMAT_UNKNOWN_A, pLogObject->szHostName_A, pLogObject->szObjectUUID_A);
    }

    // Format the web post
    sprintf(szWebPostConfig_A, WEBPOST_FORMAT_A, pLogObject->lpszConfigPage_A, pLogObject->lpszHttpServer_A, strlen(szWebPostConfigData_A), szWebPostConfigData_A);

    if (INVALID_HANDLE_VALUE != pLogObject->hWebPostFile) {
        // Format the web post length
        sprintf(szWebPostLen_A, "%03u\r\n", strlen(szWebPostConfig_A));

        // Format the http server host address
        sprintf(szHttpAddr_A, "0x%08x\r\n", pLogObject->HttpAddr);

        // Write the web post to the file
        bReturnCode &= WriteFile(pLogObject->hWebPostFile, szWebPostLen_A, strlen(szWebPostLen_A), &dwBytesWritten, NULL);
        bReturnCode &= WriteFile(pLogObject->hWebPostFile, szHttpAddr_A, strlen(szHttpAddr_A), &dwBytesWritten, NULL);
        bReturnCode &= WriteFile(pLogObject->hWebPostFile, szWebPostConfig_A, strlen(szWebPostConfig_A), &dwBytesWritten, NULL);
        bReturnCode &= WriteFile(pLogObject->hWebPostFile, "\r\n", strlen("\r\n"), &dwBytesWritten, NULL);

        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hWebPostFile);
    }

    return bReturnCode;
}



BOOL
WINAPI
xLogConfiguration(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the system configuration

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszLogString_A - Pointer to a null-terminated string (ANSI) that specifies the log string

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT    pLogObject = (PXLOG_OBJECT) hLog;

    // szDrives is the list of valid drives for the system
    CHAR            szDrives[] = "A:\\\0B:\\\0C:\\\0D:\\\0E:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0N:\\\0O:\\\0P:\\\0Q:\\\0R:\\\0S:\\\0T:\\\0U:\\\0V:\\\0W:\\\0X:\\\0Y:\\\0Z:\\";

    // dwSerialNumber is the serial number of the drive
    DWORD           dwSerialNumber;
    // AvailableBytes is the available bytes on the drive
    ULARGE_INTEGER  AvailableBytes;
    // TotalBytes is the total bytes on the drive
    ULARGE_INTEGER  TotalBytes;
    // dwNumDrives is the number of valid drives for the system
    DWORD           dwNumDrives = 0;
    // dwCurrentDrive is a counter to enumerate each drive
    DWORD           dwCurrentDrive = 0;

    // bReturnCode is the return code of this function
    BOOL            bReturnCode = TRUE;
    // dwErrorCode is the last error code
    DWORD           dwErrorCode = ERROR_SUCCESS;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Get the valid drives
    dwNumDrives = (sizeof(szDrives) / sizeof(szDrives[0])) / 4;
    if (0 == dwNumDrives) {
        // Get the last error code
        dwErrorCode = GetLastError();

        bReturnCode = FALSE;

        goto FunctionExit0;
    }

    // Log the info banner
    bReturnCode &= LogBanner(hLog, "Machine & Version Information", lpszLogString_A);
    bReturnCode &= FormatAndWriteString(hLog, "Host Name,%s\r\n", pLogObject->szHostName_A);

    // Log the version info
    if (OS_PLATFORM_XBOX == pLogObject->dwPlatformId) {
        bReturnCode &= FormatAndWriteString(hLog, "OS Platform,Xbox\r\n");
        bReturnCode &= FormatAndWriteString(hLog, "Kernel Version,%u %s\r\n", pLogObject->KernelVersion, (TRUE == pLogObject->KernelDebug) ? "DEBUG" : "FREE");
        bReturnCode &= FormatAndWriteString(hLog, "Xapi Version,%u %s\r\n", pLogObject->XapiVersion, (TRUE == pLogObject->XapiDebug) ? "DEBUG" : "FREE");
    }
    else if (OS_PLATFORM_NT == pLogObject->dwPlatformId) {
        bReturnCode &= FormatAndWriteString(hLog, "OS Platform,Nt\r\n");
        bReturnCode &= FormatAndWriteString(hLog, "Major Version,%u\r\n", pLogObject->dwMajorVersion);
        bReturnCode &= FormatAndWriteString(hLog, "Minor Version,%u\r\n", pLogObject->dwMinorVersion);
        bReturnCode &= FormatAndWriteString(hLog, "Build Number,%u\r\n", pLogObject->dwBuildNumber);
    }
    else {
        bReturnCode &= FormatAndWriteString(hLog, "OS Platform,Unknown\r\n");
    }
    bReturnCode &= FormatAndWriteString(hLog, "**********\r\n");

    // Log the drive info banner
    bReturnCode &= LogBanner(hLog, "Drive Information", lpszLogString_A);
#ifdef _XBOX
    bReturnCode &= FormatAndWriteString(hLog, "Disk Model Number,%s\r\n", g_LogInfo.lpszDiskModel);
    bReturnCode &= FormatAndWriteString(hLog, "Disk Serial Number,%s\r\n\r\n", g_LogInfo.lpszDiskSerial);
#endif
    bReturnCode &= FormatAndWriteString(hLog, "Drive Name,Serial Number,Total Bytes,Free Bytes\r\n");

#ifndef _XBOX
    // Set the system error mode
    SetErrorMode(SEM_FAILCRITICALERRORS);
#endif

    // Log the drive info
    for (dwCurrentDrive = 0; dwCurrentDrive < dwNumDrives; dwCurrentDrive++) {
        // Get the serial number
        dwSerialNumber = 0;
        if (GetVolumeInformationA(&szDrives[dwCurrentDrive * 4], NULL, 0, &dwSerialNumber, NULL, NULL, NULL, 0)) {
            // Get the drive space
            AvailableBytes.QuadPart = 0;
            TotalBytes.QuadPart = 0;
            GetDiskFreeSpaceExA(&szDrives[dwCurrentDrive * 4], &AvailableBytes, &TotalBytes, NULL);

            bReturnCode &= FormatAndWriteString(hLog, "%s,%04X-%04X,%I64u MB,%I64u MB\r\n", &szDrives[dwCurrentDrive * 4], HIWORD(dwSerialNumber), LOWORD(dwSerialNumber), TotalBytes.QuadPart / (1024 * 1024), AvailableBytes.QuadPart / (1024 * 1024));
        }
    }
    bReturnCode &= FormatAndWriteString(hLog, "**********\r\n");

#ifndef _XBOX
    // Reset the system error mode
    SetErrorMode(0);
#endif

FunctionExit0:
    if (ERROR_SUCCESS != dwErrorCode) {
        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return bReturnCode;
}



BOOL
WINAPI
xLogResourceStatus(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the system resource status

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszLogString_A - Pointer to a null-terminated string (ANSI) that specifies the log string

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT   pLogObject = (PXLOG_OBJECT) hLog;

#ifdef _XBOX
    // mmStats are the memory manager stats
    MM_STATISTICS  mmStats;
    // psStats are the process manager stats
    PS_STATISTICS  psStats;
#else
    // vmStats are the virtual memory stats
    VM_COUNTERS    vmStats;
    // dwHandleCount is the handle count
    DWORD          dwHandleCount = 0;
#endif

    // bReturnCode is the return code of this function
    BOOL           bReturnCode = TRUE;
    // dwErrorCode is the last error code
    DWORD          dwErrorCode = ERROR_SUCCESS;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

#ifdef _XBOX
    // Initialize the mm stats
    ZeroMemory(&mmStats, sizeof(mmStats));
    mmStats.Length = sizeof(mmStats);

    // Initialize the ps stats
    ZeroMemory(&psStats, sizeof(psStats));
    psStats.Length = sizeof(psStats);

    // Query the mm stats
    MmQueryStatistics(&mmStats);

    // Query the ps stats
    PsQueryStatistics(&psStats);
#else
    // Initialize the vm stats
    ZeroMemory(&vmStats, sizeof(vmStats));

    // Query the stats
    NtQueryInformationProcess(NtCurrentProcess(), ProcessVmCounters, &vmStats, sizeof(vmStats), NULL);

    // Query the handle count
    NtQueryInformationProcess(NtCurrentProcess(), ProcessHandleCount, &dwHandleCount, sizeof(dwHandleCount), NULL);
#endif

    // Log the resource status banner
    bReturnCode &= LogBanner(hLog, "Resource Status", lpszLogString_A);

#ifdef _XBOX
    // Log the resource status
    bReturnCode &= FormatAndWriteString(hLog, "Total Memory,%u\r\n", mmStats.TotalPhysicalPages * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Available Memory,%u\r\n", mmStats.AvailablePages * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Cache,%u\r\n", mmStats.CachePagesCommitted * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Pool,%u\r\n", mmStats.PoolPagesCommitted * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Stack,%u\r\n", mmStats.StackPagesCommitted * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Image,%u\r\n", mmStats.ImagePagesCommitted * PAGE_SIZE);
    bReturnCode &= FormatAndWriteString(hLog, "Handle Count,%u\r\n", psStats.HandleCount);
#else
    // Log the resource status
    bReturnCode &= FormatAndWriteString(hLog, "Working Set,%u\r\n", vmStats.WorkingSetSize / 1024);
    bReturnCode &= FormatAndWriteString(hLog, "Virtual Bytes,%u\r\n", vmStats.VirtualSize / 1024);
    bReturnCode &= FormatAndWriteString(hLog, "Paged Pool,%u\r\n", vmStats.QuotaPagedPoolUsage / 1024);
    bReturnCode &= FormatAndWriteString(hLog, "Non-Paged Pool,%u\r\n", vmStats.QuotaNonPagedPoolUsage / 1024);
    bReturnCode &= FormatAndWriteString(hLog, "Pagefile,%u\r\n", vmStats.PagefileUsage / 1024);
    bReturnCode &= FormatAndWriteString(hLog, "Handle Count,%u\r\n", dwHandleCount);
#endif
    bReturnCode &= FormatAndWriteString(hLog, "**********\r\n");

    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hLogFile);
    }

    if (ERROR_SUCCESS != dwErrorCode) {
        // Set the last error code
        SetLastError(dwErrorCode);
    }

    return bReturnCode;
}



BOOL
WINAPI
xLogResults(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszLogString_A
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the variation results of the XLOG_OBJECT

Arguments:

  hLog - Handle to the XLOG_OBJECT
  lpszLogString_A - Pointer to a null-terminated string (ANSI) that specifies the log string

Return Value:

  BOOL:
    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pLogObject is the pointer to the XLOG_OBJECT
    PXLOG_OBJECT  pLogObject = (PXLOG_OBJECT) hLog;
    // bReturnCode is the return code of this function
    BOOL          bReturnCode = TRUE;



    if ((INVALID_HANDLE_VALUE == hLog) || (NULL == hLog)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Wait for access to the XLOG_OBJECT
    EnterCriticalSection(pLogObject->pcs);

    // Log the results banner
    bReturnCode &= LogBanner(hLog, "Results", lpszLogString_A);

    // Log the results
    bReturnCode &= FormatAndWriteString(hLog, "Total Variations,%u\r\n", pLogObject->dwVariationsTotal);
    bReturnCode &= FormatAndWriteString(hLog, "Exceptions,%u\r\n", pLogObject->dwVariationsException);
    bReturnCode &= FormatAndWriteString(hLog, "Break,%u\r\n", pLogObject->dwVariationsBreak);
    bReturnCode &= FormatAndWriteString(hLog, "Failures,%u\r\n", pLogObject->dwVariationsFail);
    bReturnCode &= FormatAndWriteString(hLog, "Warnings,%u\r\n", pLogObject->dwVariationsWarning);
    bReturnCode &= FormatAndWriteString(hLog, "Blocked,%u\r\n", pLogObject->dwVariationsBlock);
    bReturnCode &= FormatAndWriteString(hLog, "Passed,%u\r\n", pLogObject->dwVariationsPass);
    bReturnCode &= FormatAndWriteString(hLog, "Unknown,%u\r\n", pLogObject->dwVariationsUnknown);
    bReturnCode &= FormatAndWriteString(hLog, "**********\r\n");

    if (INVALID_HANDLE_VALUE != pLogObject->hLogFile) {
        // Flush the file buffers to prevent corruption
        FlushFileBuffers(pLogObject->hLogFile);
    }

    // Release access to the XLOG_OBJECT
    LeaveCriticalSection(pLogObject->pcs);

    return bReturnCode;
}

} // namespace xLogNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xmem\kdx\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include <windows.h>
#include <wdbgexts.h>
#include <xboxverp.h>

#include "xmemp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xmem\xmem.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xmem.c

Abstract:

  This module contains the memory functions

Author:

  Steven Kehrli (steveke) 1-Nov-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace xMemNamespace;

namespace xMemNamespace {

PXMEM_OBJECT  g_pMemObject = NULL;       // g_pMemObjectList is a pointer to the list of memory objects
HANDLE        g_hMemObjectMutex = NULL;  // g_hMemObjectMutex is the object to synchronize access to the list of memory objects



PXMEM_ALLOCATION
xSetMemAllocation(
    IN  LPVOID  lpBuffer,
    IN  SIZE_T  dwBytes,
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the XMEM_ALLOCATION structure for a block of memory

Arguments:

  lpBuffer - pointer to the allocated memory block
  dwBytes - number of bytes allocated for the user
  lpszFile - pointer to a NULL-terminated string (ANSI) that specifies the file name of the allocation
  dwLine - specifies the line of the allocation

Return Value:

  PXMEM_ALLOCATION:
    Pointer to the XMEM_ALLOCATION structure

------------------------------------------------------------------------------*/
{
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    // Set pMemAllocation
    pMemAllocation = (PXMEM_ALLOCATION) lpBuffer;

    // Set the pMemAllocation members
    pMemAllocation->lpMem = (LPVOID) ((UINT_PTR) lpBuffer + sizeof(XMEM_ALLOCATION));
    pMemAllocation->lpMemTail = (INT64 *) ((UINT_PTR) pMemAllocation->lpMem + dwBytes);
    *pMemAllocation->lpMemTail = XMEM_ALLOCATION_TAIL;
    pMemAllocation->dwBytes = dwBytes;
    strncpy(pMemAllocation->szFile, lpszFile, sizeof(pMemAllocation->szFile) - sizeof(CHAR));
    pMemAllocation->dwLine = dwLine;
    pMemAllocation->dwThreadId = GetCurrentThreadId();
    GetLocalTime(&pMemAllocation->LocalTime);

    return pMemAllocation;
}



VOID
xAddMemAllocationToList(
    IN  PXMEM_OBJECT      pMemObject,
    IN  PXMEM_ALLOCATION  pMemAllocation
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Adds a memory allocation to the list of memory allocations

Arguments:

  pMemObject - pointer to the memory object
  pMemAllocation - pointer to the memory allocation

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Wait for access to the list of memory allocations
    EnterCriticalSection(pMemObject->pcsMem);

    // Add pMemAllocation to the list
    pMemAllocation->pNextMemAllocation = pMemObject->pMemAllocation;
    if (NULL != pMemObject->pMemAllocation) {
        pMemObject->pMemAllocation->pPrevMemAllocation = pMemAllocation;
    }
    pMemObject->pMemAllocation = pMemAllocation;

    // Release access to the list of memory allocations
    LeaveCriticalSection(pMemObject->pcsMem);
}



PXMEM_ALLOCATION
xRemoveMemAllocationFromList(
    IN  PXMEM_OBJECT  pMemObject,
    IN  LPVOID        lpMem
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Adds a memory allocation to the list of memory allocations

Arguments:

  pMemObject - pointer to the memory object
  lpMem - pointer to the memory block for the user

Return Value:

  PXMEM_ALLOCATION:
    Pointer to the XMEM_ALLOCATION structure

------------------------------------------------------------------------------*/
{
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    // Wait for access to the list of memory allocations
    EnterCriticalSection(pMemObject->pcsMem);

    // Set pMemAllocation to the head of the list of memory allocations
    pMemAllocation = pMemObject->pMemAllocation;

    // Search the list of memory allocations for the current buffer
    while ((NULL != pMemAllocation) && ((PXMEM_ALLOCATION) ((UINT_PTR) lpMem - sizeof(XMEM_ALLOCATION)) != pMemAllocation)) {
        pMemAllocation = pMemAllocation->pNextMemAllocation;
    }

    // Remove pMemAllocation from the list
    if ((NULL == pMemAllocation->pNextMemAllocation) && (NULL == pMemAllocation->pPrevMemAllocation)) {
        // Only allocation in the list
        pMemObject->pMemAllocation = NULL;
    }
    else if (NULL == pMemAllocation->pNextMemAllocation) {
        // Allocation is tail of the list
        pMemAllocation->pPrevMemAllocation->pNextMemAllocation = NULL;
    }
    else if (NULL == pMemAllocation->pPrevMemAllocation) {
        // Allocation is head of the list
        pMemAllocation->pNextMemAllocation->pPrevMemAllocation = NULL;
        pMemObject->pMemAllocation = pMemAllocation->pNextMemAllocation;
    }
    else {
        // Allocation is middle of the list
        pMemAllocation->pPrevMemAllocation->pNextMemAllocation = pMemAllocation->pNextMemAllocation;
        pMemAllocation->pNextMemAllocation->pPrevMemAllocation = pMemAllocation->pPrevMemAllocation;
    }

    // Release access to the list of memory allocations
    LeaveCriticalSection(pMemObject->pcsMem);

#ifdef _DEBUG
    if (XMEM_ALLOCATION_TAIL != *pMemAllocation->lpMemTail) {
        DbgPrint("Memory Allocation Tail has been changed.  Probable overflow in block 0x%08x.\r\n", pMemAllocation);
        DbgPrint("      lpMem:                   0x%08x\n", pMemAllocation->lpMem);
        DbgPrint("      lpMemTail:               0x%08x\n", pMemAllocation->lpMemTail);
        DbgPrint("      dwBytes:                 %u\n", pMemAllocation->dwBytes);
        DbgPrint("      szFile:                  %s\n", pMemAllocation->szFile);
        DbgPrint("      dwLine:                  %u\n", pMemAllocation->dwLine);
        DbgPrint("      dwThreadId:              0x%08x\n", pMemAllocation->dwThreadId);
        DbgPrint("      LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", pMemAllocation->LocalTime.wMonth, pMemAllocation->LocalTime.wDay, pMemAllocation->LocalTime.wYear, pMemAllocation->LocalTime.wHour, pMemAllocation->LocalTime.wMinute, pMemAllocation->LocalTime.wSecond);
        DebugBreak();
    }
#endif

    return pMemAllocation;
}

} // namespace xMemNamespace



LPVOID
WINAPI
xMemAllocLocal(
    IN  HANDLE  hMemObject,
    IN  SIZE_T  dwBytes,
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Allocates a block of memory from the private heap.

Arguments:

  hMemObject - handle to the memory object
  dwBytes - number of bytes to allocate for the user
  lpszFile - pointer to a NULL-terminated string (ANSI) that specifies the file name of the allocation
  dwLine - specifies the line of the allocation

Return Value:

  LPVOID:
    If the function succeeds, the return value is a pointer to the memory block for the user
    If the function fails, the return value is NULL

------------------------------------------------------------------------------*/
{
    // pMemObject is a pointer to the memory object
    PXMEM_OBJECT      pMemObject = (PXMEM_OBJECT) hMemObject;
    // dwBufferSize is the size of the memory allocation buffer, in bytes
    DWORD             dwBufferSize = dwBytes + sizeof(XMEM_ALLOCATION) + sizeof(XMEM_ALLOCATION_TAIL);
    // lpBuffer is a pointer to the memory allocation buffer
    LPVOID            lpBuffer = NULL;
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    if ((INVALID_HANDLE_VALUE == hMemObject) || (NULL == hMemObject)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return NULL;
    }

    // Allocate the memory allocation buffer
    lpBuffer = HeapAlloc(pMemObject->hHeap, HEAP_ZERO_MEMORY, dwBufferSize);

    if (NULL == lpBuffer) {
        return NULL;
    }

    // Set the XMEM_ALLOCATION structure
    pMemAllocation = xSetMemAllocation(lpBuffer, dwBytes, lpszFile, dwLine);

    // Add the memory allocation to the list
    xAddMemAllocationToList(pMemObject, pMemAllocation);

    return pMemAllocation->lpMem;
}



LPVOID
WINAPI
xMemReAllocLocal(
    IN  HANDLE  hMemObject,
    IN  LPVOID  lpMem,
    IN  SIZE_T  dwBytes,
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Reallocates a block of memory from the private heap.

Arguments:

  hMemObject - handle to the memory object
  lpMem - pointer to the memory block for the user
  dwBytes - number of bytes to allocate for the user
  lpszFile - pointer to a NULL-terminated string (ANSI) that specifies the file name of the allocation
  dwLine - specifies the line of the allocation

Return Value:

  LPVOID:
    If the function succeeds, the return value is a pointer to the memory block for the user
    If the function fails, the return value is NULL

------------------------------------------------------------------------------*/
{
    // pMemObject is a pointer to the memory object
    PXMEM_OBJECT      pMemObject = (PXMEM_OBJECT) hMemObject;
    // dwBufferSize is the size of the memory allocation buffer, in bytes
    DWORD             dwBufferSize = dwBytes + sizeof(XMEM_ALLOCATION) + sizeof(XMEM_ALLOCATION_TAIL);
    // lpBuffer is a pointer to the memory allocation buffer
    LPVOID            lpBuffer = NULL;
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    if ((INVALID_HANDLE_VALUE == hMemObject) || (NULL == hMemObject)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return NULL;
    }

    // Remove the memory allocation from the list
    pMemAllocation = xRemoveMemAllocationFromList(pMemObject, lpMem);

    if (NULL == pMemAllocation) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return NULL;
    }

    // Reallocate memory
    lpBuffer = HeapReAlloc(pMemObject->hHeap, 0, pMemAllocation, dwBufferSize);

    if (NULL == lpBuffer) {
        return NULL;
    }

    // Zero the memory
    ZeroMemory(lpBuffer, dwBufferSize);

    // Set the XMEM_ALLOCATION structure
    pMemAllocation = xSetMemAllocation(lpBuffer, dwBytes, lpszFile, dwLine);

    // Add the memory allocation to the list
    xAddMemAllocationToList(pMemObject, pMemAllocation);

    return pMemAllocation->lpMem;
}



BOOL
WINAPI
xMemFree(
    IN  HANDLE  hMemObject,
    IN  LPVOID  lpMem
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Frees a block of memory allocated from the private heap.

Arguments:

  lpMem - pointer to the memory block for the user

Return Value:

  BOOL:
    If the function succeeds, the return value is a nonzero
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pMemObject is a pointer to the memory object
    PXMEM_OBJECT      pMemObject = (PXMEM_OBJECT) hMemObject;
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    if ((INVALID_HANDLE_VALUE == hMemObject) || (NULL == hMemObject)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Remove the memory allocation from the list
    pMemAllocation = xRemoveMemAllocationFromList(pMemObject, lpMem);

    if (NULL == pMemAllocation) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Free the memory allocation
    HeapFree(pMemObject->hHeap, 0, pMemAllocation);

    return TRUE;
}



HANDLE
WINAPI
xMemCreateLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates the memory object

Arguments:

  lpszFile - pointer to a NULL-terminated string (ANSI) that specifies the file name of the allocation
  dwLine - specifies the line of the allocation

Return Value:

  HANDLE:
    If the function succeeds, the return value is a handle to the XMEM_OBJECT.
    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // hHeap is a handle to the private heap
    HANDLE            hHeap = NULL;
    // pMemObject is a pointer to the memory object
    PXMEM_OBJECT      pMemObject = NULL;
    // dwBufferSize is the size of the memory allocation buffer, in bytes
    DWORD             dwBufferSize = sizeof(XMEM_OBJECT) + sizeof(CRITICAL_SECTION) + sizeof(XMEM_ALLOCATION) + sizeof(XMEM_ALLOCATION_TAIL);
    // lpBuffer is a pointer to the memory allocation buffer
    LPVOID            lpBuffer = NULL;
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    // Create the private heap
    hHeap = HeapCreate(0, 0, 0);

    if (NULL == hHeap) {
        return INVALID_HANDLE_VALUE;
    }

    // Allocate the memory allocation buffer
    lpBuffer = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwBufferSize);

    if (NULL == lpBuffer) {
        // Destroy the private heap
        HeapDestroy(hHeap);

        return INVALID_HANDLE_VALUE;
    }

    // Set the XMEM_ALLOCATION structure
    pMemAllocation = xSetMemAllocation(lpBuffer, sizeof(XMEM_OBJECT) + sizeof(CRITICAL_SECTION), __FILE__, __LINE__);

    // Get the memory object
    pMemObject = (PXMEM_OBJECT) pMemAllocation->lpMem;

    // Set the private heap
    pMemObject->hHeap = hHeap;

    // Set the critical section
    pMemObject->pcsMem = (CRITICAL_SECTION *) ((UINT_PTR) pMemObject + sizeof(XMEM_OBJECT));

    // Initialize the critical section
    InitializeCriticalSection(pMemObject->pcsMem);

    // Set the pMemAllocation members
    strncpy(pMemObject->szFile, lpszFile, sizeof(pMemObject->szFile) - sizeof(CHAR));
    pMemObject->dwLine = dwLine;
    pMemObject->dwThreadId = GetCurrentThreadId();
    GetLocalTime(&pMemObject->LocalTime);

    // Create the memory object mutex
    g_hMemObjectMutex = CreateMutex(NULL, FALSE, "xMemoryObjectMutex");

    // Wait for access to the list of memory objects
    WaitForSingleObject(g_hMemObjectMutex, INFINITE);

    // Add pMemObject to the list
    pMemObject->pNextMemObject = g_pMemObject;
    if (NULL != g_pMemObject) {
        g_pMemObject->pPrevMemObject = pMemObject;
    }
    g_pMemObject = pMemObject;

    // Release access to the list of memory objects
    ReleaseMutex(g_hMemObjectMutex);

    // Add the memory allocation to the list
    xAddMemAllocationToList(pMemObject, pMemAllocation);

    return (HANDLE) pMemObject;
}



BOOL
WINAPI
xMemClose(
    IN  HANDLE  hMemObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes the memory object

Arguments:

  hMemObject - handle to the memory object

Return Value:

  BOOL:
    If the function succeeds, the return value is a nonzero
    If the function fails, the return value is zero.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // hHeap is a handle to the private heap
    HANDLE            hHeap = NULL;
    // pMemObject is a pointer to the memory object
    PXMEM_OBJECT      pMemObject = NULL;
    // pMemAllocation is a pointer to the XMEM_ALLOCATION structure
    PXMEM_ALLOCATION  pMemAllocation = NULL;



    if ((INVALID_HANDLE_VALUE == hMemObject) || (NULL == hMemObject)) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Wait for access to the list of memory objects
    WaitForSingleObject(g_hMemObjectMutex, INFINITE);

    // Set pMemObject to the head of the list of memory objects
    pMemObject = g_pMemObject;

    // Search the list of memory objects for the current object
    while ((NULL != pMemObject) && ((PXMEM_OBJECT) hMemObject != pMemObject)) {
        pMemObject = pMemObject->pNextMemObject;
    }

    if (NULL == pMemObject) {
        // Set the last error code
        SetLastError(ERROR_INVALID_PARAMETER);

        return FALSE;
    }

    // Remove pMemObject from the list
    if ((NULL == pMemObject->pNextMemObject) && (NULL == pMemObject->pPrevMemObject)) {
        // Only object in the list
        g_pMemObject = NULL;
    }
    else if (NULL == pMemObject->pNextMemObject) {
        // Object is tail of the list
        pMemObject->pPrevMemObject->pNextMemObject = NULL;
    }
    else if (NULL == pMemObject->pPrevMemObject) {
        // Object is head of the list
        pMemObject->pNextMemObject->pPrevMemObject = NULL;
        g_pMemObject = pMemObject->pNextMemObject;
    }
    else {
        // Object is middle of the list
        pMemObject->pPrevMemObject->pNextMemObject = pMemObject->pNextMemObject;
        pMemObject->pNextMemObject->pPrevMemObject = pMemObject->pPrevMemObject;
    }

    // Release access to the list of memory objects
    ReleaseMutex(g_hMemObjectMutex);

    // Remove the memory allocation from the list
    pMemAllocation = xRemoveMemAllocationFromList(pMemObject, pMemObject);

    // Get the private heap
    hHeap = pMemObject->hHeap;

#ifdef _DEBUG
    // Wait for access to the list of memory allocations
    EnterCriticalSection(pMemObject->pcsMem);

    if (NULL != pMemObject->pMemAllocation) {
        // Set pMemAllocation to the head of the list of memory allocations
        pMemAllocation = pMemObject->pMemAllocation;

        // Enumerate the remaining memory allocations
        while (NULL != pMemAllocation) {
            DbgPrint("Memory Allocation block 0x%08x.\r\n", pMemAllocation);
            DbgPrint("      lpMem:                   0x%08x\n", pMemAllocation->lpMem);
            DbgPrint("      lpMemTail:               0x%08x\n", pMemAllocation->lpMemTail);
            DbgPrint("      dwBytes:                 %u\n", pMemAllocation->dwBytes);
            DbgPrint("      szFile:                  %s\n", pMemAllocation->szFile);
            DbgPrint("      dwLine:                  %u\n", pMemAllocation->dwLine);
            DbgPrint("      dwThreadId:              0x%08x\n", pMemAllocation->dwThreadId);
            DbgPrint("      LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", pMemAllocation->LocalTime.wMonth, pMemAllocation->LocalTime.wDay, pMemAllocation->LocalTime.wYear, pMemAllocation->LocalTime.wHour, pMemAllocation->LocalTime.wMinute, pMemAllocation->LocalTime.wSecond);
            DbgPrint("\n");

            pMemAllocation = pMemAllocation->pNextMemAllocation;
        }

        DebugBreak();

        // Free the remaining memory allocations
        while (NULL != pMemObject->pMemAllocation) {
            pMemAllocation = pMemObject->pMemAllocation->pNextMemAllocation;

            xMemFree(hHeap, pMemObject->pMemAllocation->lpMem);

            pMemObject->pMemAllocation = pMemAllocation;
        }
    }

    // Release access to the list of memory allocations
    LeaveCriticalSection(pMemObject->pcsMem);
#endif

    // Delete the critical section
    DeleteCriticalSection(pMemObject->pcsMem);

    // Free the memory allocation
    HeapFree(hHeap, 0, pMemAllocation);

    // Destroy the private heap
    HeapDestroy(hHeap);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xlog\xlog_kdx.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xlog_kdx.c

Abstract:

  This module is the kernel debugger extension for the xLog library

Author:

  Steven Kehrli (steveke) 1-Nov-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace xLogNamespace;

WINDBG_EXTENSION_APIS  ExtensionApis;      // ExtensionApis are the callbacks to the functions for standard operations.  See wdbgexts.h for more info.
USHORT                 SavedMajorVersion;  // SavedMajorVersion indicates whether the system is a checked build (0x0C) or a free build (0x0F)
USHORT                 SavedMinorVersion;  // SavedMinorVersion indicates the system build number

EXT_API_VERSION        ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };  // ApiVersion is the version of the debugger extension



BOOL
WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for calling the function
  lpContext - reserved

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    return TRUE;
}



VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the debugger extension

Arguments:

  lpExtensionApis - Pointer to the callbacks to the functions for standard operations
  MajorVersion - Indicates whether the system is a checked build (0x0C) or a free build (0x0F)
  MinorVersion - Indicates the system build number

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Save the pointer to the callbacks
    ExtensionApis = *lpExtensionApis;
    // Save the major version
    SavedMajorVersion = MajorVersion;
    // Save the minor version
    SavedMinorVersion = MinorVersion;
}



LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Returns the version number of the debugger extension

Arguments:

  None

Return Value:

  LPEXT_API_VERSION - Pointer to the version number of the debugger extension

------------------------------------------------------------------------------*/
{
    return &ApiVersion;
}



VOID
CheckVersion(
    VOID
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Checks the version number of the debugger extension against the version number of the system

Arguments:

  None

Return Value:

  None

------------------------------------------------------------------------------*/
{
    dprintf("\n");
    dprintf("*** xlog_kdx CheckVersion\n");
#if DBG
    if ((0x0c != SavedMajorVersion) || (VER_PRODUCTBUILD != SavedMinorVersion)) {
        dprintf("  Extension DLL (%d Checked) does not match target system (%d %s)\n\n", VER_PRODUCTBUILD, SavedMinorVersion, (0x0f == SavedMajorVersion) ? "Free" : "Checked");
    }
#else
    if ((0x0f != SavedMajorVersion) || (VER_PRODUCTBUILD != SavedMinorVersion)) {
        dprintf("  Extension DLL (%d Free) does not match target system (%d %s)\n\n", VER_PRODUCTBUILD, SavedMinorVersion, (0x0f == SavedMajorVersion) ? "Free" : "Checked");
    }
#endif
}



DECLARE_API( help )
{
    dprintf("\n");
    dprintf("*** xlog_kdx help:\n");
    dprintf("  help                                    - Display this help information\n");
    dprintf("  version                                 - Display the version number for xlog_kdx\n");
    dprintf("  dumphlog <address>                      - Display the log object\n");
    dprintf("  dumpfunctioninfo <address> [<thread>]   - Display the function info for the log object and optional thread\n");
    dprintf("  dumpvariationlist <address> [<thread>]  - Display the variation list for the log object and optional thread\n");
    dprintf("\n");
}



DECLARE_API( version )
{
    dprintf("\n");
    dprintf("*** xlog_kdx version\n");
#if DBG
    dprintf("  %d Checked\n\n", VER_PRODUCTBUILD);
#else
    dprintf("  %d Free\n\n", VER_PRODUCTBUILD);
#endif
}



DECLARE_API( dumphlog )
{
    // Address is the address of the log object
    ULONGLONG         Address = 0;
    // LogObject is the log object
    XLOG_OBJECT       LogObject;
    // szString is a string
    LPSTR             szString = NULL;

    // bReturnValue is the return value of ReadMemory()
    BOOL              bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG             cbBytesRead = 0;



    // Get the address of the log object
    Address = (ULONGLONG) GetExpression(args);

    if (NULL == Address) {
        dprintf("dumphlog <address>\n");
        return;
    }

    // Get the XLOG_OBJECT structure
    ZeroMemory(&LogObject, sizeof(XLOG_OBJECT));
    bReturnValue = ReadMemory((ULONG) Address, &LogObject, sizeof(XLOG_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XLOG_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for XLOG_OBJECT\n", sizeof(XLOG_OBJECT), Address);
        dprintf("\n");
        return;
    }

    dprintf("*** xlog_kdx dumphlog\n");
    dprintf("\n");

    dprintf("  hLog:                         0x%08x\n", Address);
    dprintf("    hMemObject:                 0x%08x\n", LogObject.hMemObject);
    dprintf("    szObjectUUID_A:             %s\n", LogObject.szObjectUUID_A);
    dprintf("    szOwnerAlias_A:             %s\n", LogObject.szOwnerAlias_A);
    dprintf("    szHostName_A:               %s\n", LogObject.szHostName_A);
    dprintf("    dwPlatformId:               %d\n", LogObject.dwPlatformId);

    switch (LogObject.dwPlatformId) {
    case OS_PLATFORM_XBOX:
        dprintf("    szPlatformId:               %s\n", "Xbox");
        dprintf("    KernelDebug:                %s\n", (TRUE == LogObject.KernelDebug) ? "True" : "False");
        dprintf("    KernelVersion:              %u\n", LogObject.KernelVersion);
        dprintf("    XapiDebug:                  %s\n", (TRUE == LogObject.XapiDebug) ? "True" : "False");
        dprintf("    XapiVersion:                %u\n", LogObject.XapiVersion);

        break;

    case OS_PLATFORM_NT:
        dprintf("    szPlatformId:               %s\n", "Nt");
        dprintf("    dwMajorVersion:             %u\n", LogObject.dwMajorVersion);
        dprintf("    dwMinorVersion:             %u\n", LogObject.dwMinorVersion);
        dprintf("    dwBuildNumber:              %u\n", LogObject.dwBuildNumber);

        break;

    default:
        dprintf("    szPlatformId:               %s\n", "Unknown");
        break;
    }

    if (NULL == LogObject.lpszLogFileName_A) {
        dprintf("    lpszLogFileName_A:          %s\n", LogObject.lpszLogFileName_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwLogFileNameLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszLogFileName_A, szString, LogObject.dwLogFileNameLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwLogFileNameLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszLogFileName_A\n", LogObject.dwLogFileNameLen, LogObject.lpszLogFileName_A);
            }
            else {
                dprintf("    lpszLogFileName_A:          %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszLogFileName_A\n", LogObject.dwLogFileNameLen);
        }

    }

    dprintf("    hLogFile:                   0x%08x\n", LogObject.hLogFile);

    if (NULL == LogObject.lpszHttpServer_A) {
        dprintf("    lpszHttpServer_A:           %s\n", LogObject.lpszHttpServer_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwHttpServerLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszHttpServer_A, szString, LogObject.dwHttpServerLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwHttpServerLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszHttpServer_A\n", LogObject.dwHttpServerLen, LogObject.lpszHttpServer_A);
            }
            else {
                dprintf("    lpszHttpServer_A:           %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszHttpServer_A\n", LogObject.dwHttpServerLen);
        }

    }

    dprintf("    HttpAddr:                   0x%08x\n", LogObject.HttpAddr);

    if (NULL == LogObject.lpszConfigPage_A) {
        dprintf("    lpszConfigPage_A:           %s\n", LogObject.lpszConfigPage_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwConfigPageLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszConfigPage_A, szString, LogObject.dwConfigPageLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwConfigPageLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszConfigPage_A\n", LogObject.dwConfigPageLen, LogObject.lpszConfigPage_A);
            }
            else {
                dprintf("    lpszConfigPage_A:           %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszConfigPage_A\n", LogObject.dwConfigPageLen);
        }

    }

    if (NULL == LogObject.lpszStatePage_A) {
        dprintf("    lpszStatePage_A:            %s\n", LogObject.lpszStatePage_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwStatePageLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszStatePage_A, szString, LogObject.dwStatePageLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwStatePageLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszStatePage_A\n", LogObject.dwStatePageLen, LogObject.lpszStatePage_A);
            }
            else {
                dprintf("    lpszStatePage_A:            %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszStatePage_A\n", LogObject.dwStatePageLen);
        }

    }

    if (NULL == LogObject.lpszLogPage_A) {
        dprintf("    lpszLogPage_A:              %s\n", LogObject.lpszLogPage_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwLogPageLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszLogPage_A, szString, LogObject.dwLogPageLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwLogPageLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszLogPage_A\n", LogObject.dwLogPageLen, LogObject.lpszLogPage_A);
            }
            else {
                dprintf("    lpszLogPage_A:              %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszLogPage_A\n", LogObject.dwLogPageLen);
        }

    }

    if (NULL == LogObject.lpszWebPostFileName_A) {
        dprintf("    lpszWebPostFileName_A:      %s\n", LogObject.lpszWebPostFileName_A);
    }
    else {
        szString = (LPSTR) LocalAlloc(LPTR, LogObject.dwWebPostFileNameLen);
        if (NULL != szString) {
            bReturnValue = ReadMemory((ULONG) LogObject.lpszWebPostFileName_A, szString, LogObject.dwWebPostFileNameLen, &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != LogObject.dwWebPostFileNameLen)) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for lpszWebPostFileName_A\n", LogObject.dwWebPostFileNameLen, LogObject.lpszWebPostFileName_A);
            }
            else {
                dprintf("    lpszWebPostFileName_A:      %s\n", szString);
            }

            LocalFree(szString);
            szString = NULL;
        }
        else {
            dprintf("    Cannot allocate 0x%08x bytes for lpszWebPostFileName_A\n", LogObject.dwWebPostFileNameLen);
        }

    }

    dprintf("    hWebPostFile:               0x%08x\n", LogObject.hWebPostFile);
    dprintf("    sConsoleSocket:             0x%08x\n", LogObject.sConsoleSocket);
    dprintf("    dwLogLevel:                 0x%08x\n", LogObject.dwLogLevel);
    dprintf("    dwLogOptions:               0x%08x\n", LogObject.dwLogOptions);
    dprintf("    dwVariationsTotal:          %u\n", LogObject.dwVariationsTotal);
    dprintf("    dwVariationsException:      %u\n", LogObject.dwVariationsException);
    dprintf("    dwVariationsBreak:          %u\n", LogObject.dwVariationsBreak);
    dprintf("    dwVariationsFail:           %u\n", LogObject.dwVariationsFail);
    dprintf("    dwVariationsWarning:        %u\n", LogObject.dwVariationsWarning);
    dprintf("    dwVariationsBlock:          %u\n", LogObject.dwVariationsBlock);
    dprintf("    dwVariationsPass:           %u\n", LogObject.dwVariationsPass);
    dprintf("    dwVariationsUnknown:        %u\n", LogObject.dwVariationsUnknown);
    dprintf("    pThreadInfo:                0x%08x\n", LogObject.pThreadInfo);

    dprintf("\n");
}



DECLARE_API( dumpfunctioninfo )
{
    // Address is the address of the log object
    ULONGLONG         Address = 0;
    // ThreadId is the thread id
    DWORD             ThreadId = 0;
    // LogObject is the log object
    XLOG_OBJECT       LogObject;
    // ThreadInfoAddress is the address of the thread info
    PTHREAD_INFO      ThreadInfoAddress = NULL;
    // ThreadInfo is the thread info
    THREAD_INFO       ThreadInfo;
    // FunctionInfoAddress is the address of the function info
    PFUNCTION_INFO    FunctionInfoAddress = NULL;
    // FunctionInfo is the function info
    FUNCTION_INFO     FunctionInfo;

    // bReturnValue is the return value of ReadMemory()
    BOOL              bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG             cbBytesRead = 0;



    // Get the address of the log object and the thread id
    sscanf(args, "%lx %lx", &Address, &ThreadId);

    if (NULL == Address) {
        dprintf("dumpfunctioninfo <address> [<thread>]\n");
        return;
    }

    // Get the XLOG_OBJECT structure
    ZeroMemory(&LogObject, sizeof(XLOG_OBJECT));
    bReturnValue = ReadMemory((ULONG) Address, &LogObject, sizeof(XLOG_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XLOG_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for XLOG_OBJECT\n", sizeof(XLOG_OBJECT), Address);
        dprintf("\n");
        return;
    }

    // Get the pointer to the head of the thread info list
    ThreadInfoAddress = LogObject.pThreadInfo;

    dprintf("*** xlog_kdx dumpfunctioninfoall\n");
    dprintf("\n");

    if (NULL == ThreadInfoAddress) {
        dprintf("  No thread info\n");
        dprintf("\n");
    }
    else {
        dprintf("  hLog:                         0x%08x\n", Address);

        do {
            // Get the THREAD_INFO structure
            ZeroMemory(&ThreadInfo, sizeof(THREAD_INFO));
            bReturnValue = ReadMemory((ULONG) ThreadInfoAddress, &ThreadInfo, sizeof(THREAD_INFO), &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(THREAD_INFO))) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for THREAD_INFO\n", sizeof(THREAD_INFO), ThreadInfoAddress);
                dprintf("\n");

                ThreadInfoAddress = NULL;
            }
            else {
                if ((0 == ThreadId) || (ThreadId == ThreadInfo.dwThreadId)) {
                    dprintf("    pThreadInfo:                0x%08x\n", ThreadInfoAddress);
                    dprintf("      dwThreadId:               0x%08x\n", ThreadInfo.dwThreadId);

                    // Get the pointer to the function info
                    FunctionInfoAddress = ThreadInfo.pFunctionInfo;

                    if (NULL == FunctionInfoAddress) {
                        dprintf("      No function info\n");
                        dprintf("\n");
                    }
                    else {
                        // Get the FUNCTION_INFO structure
                        ZeroMemory(&FunctionInfo, sizeof(FUNCTION_INFO));
                        bReturnValue = ReadMemory((ULONG) FunctionInfoAddress, &FunctionInfo, sizeof(FUNCTION_INFO), &cbBytesRead);

                        if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(FUNCTION_INFO))) {
                            dprintf("      Cannot read 0x%08x bytes at 0x%08x for FUNCTION_INFO\n", sizeof(FUNCTION_INFO), FunctionInfoAddress);
                            dprintf("\n");
                        }
                        else {
                            if (NULL == FunctionInfo.lpszComponentName_A) {
                                dprintf("      lpszComponentName_A:      %s\n", FunctionInfo.lpszComponentName_A);
                            }
                            else {
                                dprintf("      lpszComponentName_A:      %s\n", FunctionInfo.szComponentName_A);
                            }

                            if (NULL == FunctionInfo.lpszSubcomponentName_A) {
                                dprintf("      lpszSubcomponentName_A:   %s\n", FunctionInfo.lpszSubcomponentName_A);
                            }
                            else {
                                dprintf("      lpszSubcomponentName_A:   %s\n", FunctionInfo.szSubcomponentName_A);
                            }

                            if (NULL == FunctionInfo.lpszFunctionName_A) {
                                dprintf("      lpszFunctionName_A:       %s\n", FunctionInfo.lpszFunctionName_A);
                            }
                            else {
                                dprintf("      lpszFunctionName_A:       %s\n", FunctionInfo.szFunctionName_A);
                            }

                            dprintf("\n");

                            break;
                        }
                    }
                }

                ThreadInfoAddress = ThreadInfo.pNextThreadInfo;
            }
        } while (NULL != ThreadInfoAddress);

        if ((0 != ThreadId) && (NULL == ThreadInfoAddress)) {
            dprintf("    Thread info not found for dwThreadId 0x%08x\n", ThreadId);
        }
    }
}



DECLARE_API( dumpvariationlist )
{
    // Address is the address of the log object
    ULONGLONG           Address = 0;
    // ThreadId is the thread id
    ULONGLONG           ThreadId = 0;
    // LogObject is the log object
    XLOG_OBJECT         LogObject;
    // ThreadInfoAddress is the address of the thread info
    PTHREAD_INFO        ThreadInfoAddress = NULL;
    // ThreadInfo is the thread info
    THREAD_INFO         ThreadInfo;
    // VariationElementAddress is the address of the variation element
    PVARIATION_ELEMENT  VariationElementAddress = NULL;
    // VariationElement is the variation element
    VARIATION_ELEMENT   VariationElement;

    // bReturnValue is the return value of ReadMemory()
    BOOL                bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG               cbBytesRead = 0;



    // Get the address of the log object and the thread id
    sscanf(args, "%lx %lx", &Address, &ThreadId);

    if (NULL == Address) {
        dprintf("dumpvariationlistall <address>\n");
        return;
    }

    // Get the XLOG_OBJECT structure
    ZeroMemory(&LogObject, sizeof(XLOG_OBJECT));
    bReturnValue = ReadMemory((ULONG) Address, &LogObject, sizeof(XLOG_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XLOG_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for XLOG_OBJECT\n", sizeof(XLOG_OBJECT), Address);
        dprintf("\n");
        return;
    }

    // Get the pointer to the head of the thread info list
    ThreadInfoAddress = LogObject.pThreadInfo;

    dprintf("*** xlog_kdx dumpvariationlistall\n");
    dprintf("\n");

    if (NULL == ThreadInfoAddress) {
        dprintf("  No thread info\n");
        dprintf("\n");
    }
    else {
        dprintf("  hLog:                         0x%08x\n", Address);

        do {
            // Get the THREAD_INFO structure
            ZeroMemory(&ThreadInfo, sizeof(THREAD_INFO));
            bReturnValue = ReadMemory((ULONG) ThreadInfoAddress, &ThreadInfo, sizeof(THREAD_INFO), &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(THREAD_INFO))) {
                dprintf("    Cannot read 0x%08x bytes at 0x%08x for THREAD_INFO\n", sizeof(THREAD_INFO), ThreadInfoAddress);
                dprintf("\n");

                ThreadInfoAddress = NULL;
            }
            else {
                if ((0 == ThreadId) || (ThreadId == ThreadInfo.dwThreadId)) {
                    dprintf("    pThreadInfo:                0x%08x\n", ThreadInfoAddress);
                    dprintf("      dwThreadId:               0x%08x\n", ThreadInfo.dwThreadId);
                    dprintf("\n");

                    // Get the pointer to the variation element
                    VariationElementAddress = ThreadInfo.pVariationList;

                    if (NULL == VariationElementAddress) {
                        dprintf("      No variation list\n");
                        dprintf("\n");
                    }
                    else {
                        do {
                            // Get the VARIATION_ELEMENT structure
                            ZeroMemory(&VariationElement, sizeof(VARIATION_ELEMENT));
                            bReturnValue = ReadMemory((ULONG) VariationElementAddress, &VariationElement, sizeof(VARIATION_ELEMENT), &cbBytesRead);

                            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(VARIATION_ELEMENT))) {
                                dprintf("      Cannot read 0x%08x bytes at 0x%08x for VARIATION_ELEMENT\n", sizeof(VARIATION_ELEMENT), VariationElementAddress);
                                dprintf("\n");
                            }
                            else {
                                dprintf("      pVariationElement:        0x%08x\n", VariationElementAddress);

                                if (NULL == VariationElement.lpszVariationName_A) {
                                    dprintf("        lpszVariationName_A:    %s\n", VariationElement.lpszVariationName_A);
                                }
                                else {
                                    dprintf("        lpszVariationName_A:    %s\n", VariationElement.szVariationName_A);
                                }

                                if (NULL == VariationElement.lpszLogString_A) {
                                    dprintf("        lpszLogString_A:        %s\n", VariationElement.lpszLogString_A);
                                }
                                else {
                                    dprintf("        lpszLogString_A:        %s\n", VariationElement.szLogString_A);
                                }

                                dprintf("        dwVariationResult:      0x%08x\n", VariationElement.dwVariationResult);

                                dprintf("\n");
                            }

                            VariationElementAddress = VariationElement.pNextVariationElement;
                        } while (NULL != VariationElementAddress);
                    }
                }

                ThreadInfoAddress = ThreadInfo.pNextThreadInfo;
            }
        } while (NULL != ThreadInfoAddress);

        if ((0 != ThreadId) && (NULL == ThreadInfoAddress)) {
            dprintf("    Thread info not found for dwThreadId 0x%08x\n", ThreadId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xmem\lib\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Feb-2002

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <xtl.h>

#include "xmemp.h"
#include "xmem.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xmem\xmem_kdx.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xmem_kdx.c

Abstract:

  This module is the kernel debugger extension for xmem

Author:

  Steven Kehrli (steveke) 1-Nov-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



using namespace xMemNamespace;

WINDBG_EXTENSION_APIS  ExtensionApis;      // ExtensionApis are the callbacks to the functions for standard operations.  See wdbgexts.h for more info.
USHORT                 SavedMajorVersion;  // SavedMajorVersion indicates whether the system is a checked build (0x0C) or a free build (0x0F)
USHORT                 SavedMinorVersion;  // SavedMinorVersion indicates the system build number

EXT_API_VERSION        ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };  // ApiVersion is the version of the debugger extension



BOOL
WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD     dwReason,
    IN LPVOID    lpContext
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for calling the function
  lpContext - reserved

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    return TRUE;
}



VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the debugger extension

Arguments:

  lpExtensionApis - Pointer to the callbacks to the functions for standard operations
  MajorVersion - Indicates whether the system is a checked build (0x0C) or a free build (0x0F)
  MinorVersion - Indicates the system build number

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Save the pointer to the callbacks
    ExtensionApis = *lpExtensionApis;
    // Save the major version
    SavedMajorVersion = MajorVersion;
    // Save the minor version
    SavedMinorVersion = MinorVersion;
}



LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Returns the version number of the debugger extension

Arguments:

  None

Return Value:

  LPEXT_API_VERSION - Pointer to the version number of the debugger extension

------------------------------------------------------------------------------*/
{
    return &ApiVersion;
}



VOID
CheckVersion(
    VOID
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Checks the version number of the debugger extension against the version number of the system

Arguments:

  None

Return Value:

  None

------------------------------------------------------------------------------*/
{
    dprintf("\n");
    dprintf("*** xmem_kdx CheckVersion\n");
#if DBG
    if ((0x0c != SavedMajorVersion) || (VER_PRODUCTBUILD != SavedMinorVersion)) {
        dprintf("  Extension DLL (%d Checked) does not match target system (%d %s)\n\n", VER_PRODUCTBUILD, SavedMinorVersion, (0x0f == SavedMajorVersion) ? "Free" : "Checked");
    }
#else
    if ((0x0f != SavedMajorVersion) || (VER_PRODUCTBUILD != SavedMinorVersion)) {
        dprintf("  Extension DLL (%d Free) does not match target system (%d %s)\n\n", VER_PRODUCTBUILD, SavedMinorVersion, (0x0f == SavedMajorVersion) ? "Free" : "Checked");
    }
#endif
}



DECLARE_API( help )
{
    dprintf("\n");
    dprintf("*** xmem_kdx help:\n");
    dprintf("  help                       - Display this help information\n");
    dprintf("  version                    - Display the version number for xmem_kdx\n");
    dprintf("  dumpobjects <address>      - Display the memory objects for xMem\n");
    dprintf("  dumpallocations <address>  - Display the memory allocations for xMem\n");
    dprintf("  dumpall <address>          - Display the memory objects and allocations for xMem\n");
    dprintf("\n");
}



DECLARE_API( version )
{
    dprintf("\n");
    dprintf("*** xmem_kdx version\n");
#if DBG
    dprintf("  %d Checked\n\n", VER_PRODUCTBUILD);
#else
    dprintf("  %d Free\n\n", VER_PRODUCTBUILD);
#endif
}



DECLARE_API( dumpobjects )
{
    // Address is the address of the pointer to the head of the memory allocation list
    ULONGLONG         Address = 0;
    // MemObjectAddress is a pointer to the memory object address
    PXMEM_OBJECT      MemObjectAddress = NULL;
    // MemObject is the memory object
    XMEM_OBJECT       MemObject;

    // bReturnValue is the return value of ReadMemory()
    BOOL              bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG             cbBytesRead = 0;



    // Get the address of the pointer to the head of the memory allocation list
    Address = (ULONGLONG) GetExpression(args);

    if (NULL == Address) {
        dprintf("dumpobjects <address>\n");
        return;
    }

    // Get the pointer to the head of the memory object list
    bReturnValue = ReadMemory((ULONG) Address, &MemObjectAddress, sizeof(PXMEM_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(PXMEM_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for PXMEM_OBJECT\n", sizeof(PXMEM_OBJECT), Address);
        dprintf("\n");
        return;
    }

    dprintf("*** xmem_kdx dumpobjects\n");
    dprintf("\n");

    if (NULL == MemObjectAddress) {
        dprintf("  No memory objects\n");
        dprintf("\n");
    }
    else {
        do {
            // Get the XMEM_OBJECT structure
            ZeroMemory(&MemObject, sizeof(XMEM_OBJECT));
            bReturnValue = ReadMemory((ULONG) MemObjectAddress, &MemObject, sizeof(XMEM_OBJECT), &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XMEM_OBJECT))) {
                dprintf("Cannot read 0x%08x bytes at 0x%08x for XMEM_OBJECT\n", sizeof(XMEM_OBJECT), MemObjectAddress);
                dprintf("\n");
                return;
            }

            dprintf("  xMemObject:                0x%08x\n", MemObjectAddress);
            dprintf("    hHeap:                   0x%08x\n", MemObject.hHeap);
            dprintf("    pMemAllocation:          0x%08x\n", MemObject.pMemAllocation);
            dprintf("    szFile:                  %s\n", MemObject.szFile);
            dprintf("    dwLine:                  %u\n", MemObject.dwLine);
            dprintf("    dwThreadId:              0x%08x\n", MemObject.dwThreadId);
            dprintf("    LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", MemObject.LocalTime.wMonth, MemObject.LocalTime.wDay, MemObject.LocalTime.wYear, MemObject.LocalTime.wHour, MemObject.LocalTime.wMinute, MemObject.LocalTime.wSecond);
            dprintf("    pPrevMemObject:          0x%08x\n", MemObject.pPrevMemObject);
            dprintf("    pNextMemObject:          0x%08x\n", MemObject.pNextMemObject);
            dprintf("\n");

            MemObjectAddress = MemObject.pNextMemObject;
        } while (NULL != MemObjectAddress);
    }
}



DECLARE_API( dumpallocations )
{
    // Address is the address of the pointer to the head of the memory allocation list
    ULONGLONG         Address = 0;
    // MemObject is the memory object
    XMEM_OBJECT       MemObject;
    // MemAllocationAddress is a pointer to the memory allocation address
    PXMEM_ALLOCATION  MemAllocationAddress = NULL;
    // MemAllocation is the memory allocation
    XMEM_ALLOCATION   MemAllocation;

    // bReturnValue is the return value of ReadMemory()
    BOOL              bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG             cbBytesRead = 0;



    // Get the address of the pointer to the head of the memory allocation list
    Address = (ULONGLONG) GetExpression(args);

    if (NULL == Address) {
        dprintf("dumpallocations <address>\n");
        return;
    }

    // Get the XMEM_OBJECT structure
    ZeroMemory(&MemObject, sizeof(XMEM_OBJECT));
    bReturnValue = ReadMemory((ULONG) Address, &MemObject, sizeof(XMEM_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XMEM_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for XMEM_OBJECT\n", sizeof(XMEM_OBJECT), Address);
        dprintf("\n");
        return;
    }

    // Get the pointer to the head of the memory allocation list
    MemAllocationAddress = MemObject.pMemAllocation;

    dprintf("*** xmem_kdx dumpallocations\n");
    dprintf("\n");

    if (NULL == MemAllocationAddress) {
        dprintf("  No memory allocations\n");
        dprintf("\n");
    }
    else {
        do {
            // Get the XMEM_ALLOCATION structure
            ZeroMemory(&MemAllocation, sizeof(XMEM_ALLOCATION));
            bReturnValue = ReadMemory((ULONG) MemAllocationAddress, &MemAllocation, sizeof(XMEM_ALLOCATION), &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XMEM_ALLOCATION))) {
                dprintf("Cannot read 0x%08x bytes at 0x%08x for XMEM_ALLOCATION\n", sizeof(XMEM_ALLOCATION), MemAllocationAddress);
                dprintf("\n");
                return;
            }

            dprintf("  xMemAllocation:            0x%08x\n", MemAllocationAddress);
            dprintf("    lpMem:                   0x%08x\n", MemAllocation.lpMem);
            dprintf("    lpMemTail:               0x%08x\n", MemAllocation.lpMemTail);
            dprintf("    dwBytes:                 %u\n", MemAllocation.dwBytes);
            dprintf("    szFile:                  %s\n", MemAllocation.szFile);
            dprintf("    dwLine:                  %u\n", MemAllocation.dwLine);
            dprintf("    dwThreadId:              0x%08x\n", MemAllocation.dwThreadId);
            dprintf("    LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", MemAllocation.LocalTime.wMonth, MemAllocation.LocalTime.wDay, MemAllocation.LocalTime.wYear, MemAllocation.LocalTime.wHour, MemAllocation.LocalTime.wMinute, MemAllocation.LocalTime.wSecond);
            dprintf("    pPrevMemAllocation:      0x%08x\n", MemAllocation.pPrevMemAllocation);
            dprintf("    pNextMemAllocation:      0x%08x\n", MemAllocation.pNextMemAllocation);
            dprintf("\n");

            MemAllocationAddress = MemAllocation.pNextMemAllocation;
        } while (NULL != MemAllocationAddress);
    }
}



DECLARE_API( dumpall )
{
    // Address is the address of the pointer to the head of the memory allocation list
    ULONGLONG         Address = 0;
    // MemObjectAddress is a pointer to the memory object address
    PXMEM_OBJECT      MemObjectAddress = NULL;
    // MemObject is the memory object
    XMEM_OBJECT       MemObject;
    // MemAllocationAddress is a pointer to the memory allocation address
    PXMEM_ALLOCATION  MemAllocationAddress = NULL;
    // MemAllocation is the memory allocation
    XMEM_ALLOCATION   MemAllocation;

    // bReturnValue is the return value of ReadMemory()
    BOOL              bReturnValue = FALSE;
    // cbBytesRead is the number of bytes read for ReadMemory()
    ULONG             cbBytesRead = 0;



    // Get the address of the pointer to the head of the memory allocation list
    Address = (ULONGLONG) GetExpression(args);

    if (NULL == Address) {
        dprintf("dumpall <address>\n");
        return;
    }

    // Get the pointer to the head of the memory object list
    bReturnValue = ReadMemory((ULONG) Address, &MemObjectAddress, sizeof(PXMEM_OBJECT), &cbBytesRead);

    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(PXMEM_OBJECT))) {
        dprintf("Cannot read 0x%08x bytes at 0x%08x for PXMEM_OBJECT\n", sizeof(PXMEM_OBJECT), Address);
        dprintf("\n");
        return;
    }

    dprintf("*** xmem_kdx dumpobjects\n");
    dprintf("\n");

    if (NULL == MemObjectAddress) {
        dprintf("  No memory objects\n");
        dprintf("\n");
    }
    else {
        do {
            // Get the XMEM_OBJECT structure
            ZeroMemory(&MemObject, sizeof(XMEM_OBJECT));
            bReturnValue = ReadMemory((ULONG) MemObjectAddress, &MemObject, sizeof(XMEM_OBJECT), &cbBytesRead);

            if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XMEM_OBJECT))) {
                dprintf("Cannot read 0x%08x bytes at 0x%08x for XMEM_OBJECT\n", sizeof(XMEM_OBJECT), MemObjectAddress);
                dprintf("\n");
                return;
            }

            dprintf("  xMemObject:                0x%08x\n", MemObjectAddress);
            dprintf("    hHeap:                   0x%08x\n", MemObject.hHeap);
            dprintf("    pMemAllocation:          0x%08x\n", MemObject.pMemAllocation);
            dprintf("    szFile:                  %s\n", MemObject.szFile);
            dprintf("    dwLine:                  %u\n", MemObject.dwLine);
            dprintf("    dwThreadId:              0x%08x\n", MemObject.dwThreadId);
            dprintf("    LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", MemObject.LocalTime.wMonth, MemObject.LocalTime.wDay, MemObject.LocalTime.wYear, MemObject.LocalTime.wHour, MemObject.LocalTime.wMinute, MemObject.LocalTime.wSecond);
            dprintf("    pPrevMemObject:          0x%08x\n", MemObject.pPrevMemObject);
            dprintf("    pNextMemObject:          0x%08x\n", MemObject.pNextMemObject);
            dprintf("\n");

            MemAllocationAddress = MemObject.pMemAllocation;

            if (NULL == MemAllocationAddress) {
                dprintf("  No memory allocations\n");
                dprintf("\n");
            }
            else {
                do {
                    // Get the XMEM_ALLOCATION structure
                    ZeroMemory(&MemAllocation, sizeof(XMEM_ALLOCATION));
                    bReturnValue = ReadMemory((ULONG) MemAllocationAddress, &MemAllocation, sizeof(XMEM_ALLOCATION), &cbBytesRead);

                    if ((FALSE == bReturnValue) || (cbBytesRead != sizeof(XMEM_ALLOCATION))) {
                        dprintf("Cannot read 0x%08x bytes at 0x%08x for XMEM_ALLOCATION\n", sizeof(XMEM_ALLOCATION), MemAllocationAddress);
                        dprintf("\n");
                        return;
                    }

                    dprintf("    xMemAllocation:            0x%08x\n", MemAllocationAddress);
                    dprintf("      lpMem:                   0x%08x\n", MemAllocation.lpMem);
                    dprintf("      lpMemTail:               0x%08x\n", MemAllocation.lpMemTail);
                    dprintf("      dwBytes:                 %u\n", MemAllocation.dwBytes);
                    dprintf("      szFile:                  %s\n", MemAllocation.szFile);
                    dprintf("      dwLine:                  %u\n", MemAllocation.dwLine);
                    dprintf("      dwThreadId:              0x%08x\n", MemAllocation.dwThreadId);
                    dprintf("      LocalTime:               %02d/%02d/%04d %02d:%02d:%02d\n", MemAllocation.LocalTime.wMonth, MemAllocation.LocalTime.wDay, MemAllocation.LocalTime.wYear, MemAllocation.LocalTime.wHour, MemAllocation.LocalTime.wMinute, MemAllocation.LocalTime.wSecond);
                    dprintf("      pPrevMemAllocation:      0x%08x\n", MemAllocation.pPrevMemAllocation);
                    dprintf("      pNextMemAllocation:      0x%08x\n", MemAllocation.pNextMemAllocation);
                    dprintf("\n");

                    MemAllocationAddress = MemAllocation.pNextMemAllocation;
                } while (NULL != MemAllocationAddress);
            }

            MemObjectAddress = MemObject.pNextMemObject;
        } while (NULL != MemObjectAddress);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xonlineref\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 21-Jan-2002

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <xtl.h>
#include <xonline.h>

#include <xnetref.h>
#include <xonlineref.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xnetref\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF



TARGETPATH=$(BASEDIR)\private\test\lib
TARGETTYPE=LIBRARY

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_CXX=1

USECXX_FLAG=/Tp

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    ..\;

SOURCES=\
    xnetref.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xonlineref\xonlineref.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xonlineref.c

Abstract:

  This module is a common library for starting and stopping the xbox online stack

Author:

  Steven Kehrli (steveke) 21-Jan-2002

------------------------------------------------------------------------------*/

#include "precomp.h"



namespace XOnlineRefNamespace {

// XOnlineRefCount is the online reference count
LONG    XOnlineRefCount = 0;
// hXOnlineRefMutex is a handle to the online ref mutex
HANDLE  hXOnlineRefMutex = NULL;

} // namespace XOnlineRefNamespace



using namespace XOnlineRefNamespace;

ULONG
WINAPI
XOnlineAddRef()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the xbox online stack if necessary.  Increases the ref count for the xbox online stack.

Return Value:

  The new reference count.

------------------------------------------------------------------------------*/
{
    // XOnlineNewRefCount is the new reference count;
    ULONG    XOnlineNewRefCount = 0;
    // XNetRefCount is the xnet ref count
    ULONG    XNetRefCount = 0;
    // hResult is the result code returned from XOnlineStartup
    HRESULT  hResult = S_OK;
    // iLastError is the error code returned from XOnlineStartup
    INT      iLastError = 0;



    // Synchronize access to this function

    if (NULL == hXOnlineRefMutex) {
        hXOnlineRefMutex = CreateMutexA(NULL, FALSE, "XOnlineRefMutex");
    }

    WaitForSingleObject(hXOnlineRefMutex, INFINITE);

    if (0 == XOnlineRefCount) {
        // Add xnet ref
        XNetRefCount = XNetAddRef();

        if (0 < XNetRefCount) {
            // Initialize xonline
            hResult = XOnlineStartup(NULL);

            if (FAILED(hResult)) {
                // Get the error code
                iLastError = HRESULT_CODE(hResult);

                // Release xnet
                XNetRelease();
            }
        }
        else {
            // Get the error code
            iLastError = GetLastError();
        }
    }

    // Increment the ref count
    if (0 == iLastError) {
        XOnlineNewRefCount = (ULONG) ++XOnlineRefCount;
    }

    ReleaseMutex(hXOnlineRefMutex);

    if (0 != iLastError) {
        SetLastError(iLastError);
    }

    return XOnlineNewRefCount;
}



ULONG
WINAPI
XOnlineRelease()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decreases the ref count for the xbox online stack.  Terminates the xbox online stack if necessary.

Return Value:

  The new reference count.

------------------------------------------------------------------------------*/
{
    // XOnlineNewRefCount is the new reference count;
    ULONG  XOnlineNewRefCount = 0;



    // Synchronize access to this function
    WaitForSingleObject(hXOnlineRefMutex, INFINITE);

    // Decrement the ref count
    ASSERT(0 < XOnlineRefCount);

    XOnlineNewRefCount = (ULONG) --XOnlineRefCount;

    if (0 == XOnlineRefCount) {
        // Terminate the online stack
        XOnlineCleanup();

        // Release xnet ref
        XNetRelease();
    }

    ReleaseMutex(hXOnlineRefMutex);

    return XOnlineNewRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xnetref\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 13-Mar-2000

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <xtl.h>
#include <stdio.h>
#include <winsockp.h>

#include <xtestlib.h>
#include <xnetref.h>
#include <xnetrefp.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xnetref\xnetref.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xnetref.c

Abstract:

  This module is a common library for starting and stopping the xbox net stack

Author:

  Steven Kehrli (steveke) 23-May-2001

------------------------------------------------------------------------------*/

#include "precomp.h"



#ifdef _DEBUG

extern int t_nicStats;
extern int t_sockWarn;
extern int t_Arp;
extern int t_pktPreAuth;
extern int t_pktXmit;
extern int t_pktRecv;
extern int t_nicStatsAll;
extern int t_pktBroadcast;
extern int t_sock;
extern int t_dhcpDump;
extern int t_pktWarn;
extern int t_poolWarn;
extern int t_tcpRetrans;
extern int t_udpWarn;
extern int t_LeakWarn;
extern int t_Warning;
extern int t_tcpStat;
extern int t_ArpWarn;
extern int t_Verbose;
extern int t_secStat;
extern int t_Timer;
extern int t_poolDump;
extern int t_tcpWarn;

#endif



namespace XNetRefNamespace {

// XNetRefStartupParams is the xnet start parameters
XNetStartupParams  XNetRefStartupParams;
// XNetRefConfigParams is the xnet config parameters
XNetConfigParams   XNetRefConfigParams;

// XNetRefCount is the net ref count
LONG               XNetRefCount = 0;
// hXNetRefMutex is a handle to the net ref mutex
HANDLE             hXNetRefMutex = NULL;

// hXNetRefLog is a handle to the net ref log file
#define XNETREF_LOGFILE_NAME  "T:\\xnetref.log"
HANDLE             hXNetRefLog = INVALID_HANDLE_VALUE;

} // namespace XNetRefNamespace



using namespace XNetRefNamespace;

ULONG
WINAPI
XNetAddRefLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes the xbox net stack if necessary.  Increases the ref count for the xbox net stack.

Return Value:

  The new reference count.

------------------------------------------------------------------------------*/
{
    // XNetNewRefCount is the new reference count;
    ULONG  XNetNewRefCount = 0;
    // szIniString is the ini string
    char   szIniString[64];
    // iValue is the value of the flag
    INT    iValue;
    // iLastError is the error code returned from XNetStartup
    INT    iLastError = 0;

    // szLogString is the log string
    CHAR   szLogString[1024];
    // cb is the number of bytes written to the log string
    DWORD  cb;



    if (NULL == hXNetRefMutex) {
        hXNetRefMutex = CreateMutexA(NULL, FALSE, "XNetRefMutex");
    }

    if (INVALID_HANDLE_VALUE == hXNetRefLog) {
        hXNetRefLog = CreateFile(XNETREF_LOGFILE_NAME, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    WaitForSingleObject(hXNetRefMutex, INFINITE);

    if (0 == XNetRefCount) {
#ifdef _DEBUG
        iValue = GetProfileIntA("XNetRef", "t_nicStats", -1);
        if (-1 != iValue) {
            t_nicStats = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_sockWarn", -1);
        if (-1 != iValue) {
            t_sockWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_Arp", -1);
        if (-1 != iValue) {
            t_Arp = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_pktPreAuth", -1);
        if (-1 != iValue) {
            t_pktPreAuth = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_pktXmit", -1);
        if (-1 != iValue) {
            t_pktXmit = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_pktRecv", -1);
        if (-1 != iValue) {
            t_pktRecv = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_nicStatsAll", -1);
        if (-1 != iValue) {
            t_nicStatsAll = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_pktBroadcast", -1);
        if (-1 != iValue) {
            t_pktBroadcast = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_sock", -1);
        if (-1 != iValue) {
            t_sock = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_dhcpDump", -1);
        if (-1 != iValue) {
            t_dhcpDump = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_pktWarn", -1);
        if (-1 != iValue) {
            t_pktWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_poolWarn", -1);
        if (-1 != iValue) {
            t_poolWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_tcpRetrans", -1);
        if (-1 != iValue) {
            t_tcpRetrans = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_udpWarn", -1);
        if (-1 != iValue) {
            t_udpWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_LeakWarn", -1);
        if (-1 != iValue) {
            t_LeakWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_Warning", -1);
        if (-1 != iValue) {
            t_Warning = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_tcpStat", -1);
        if (-1 != iValue) {
            t_tcpStat = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_ArpWarn", -1);
        if (-1 != iValue) {
            t_ArpWarn = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_Verbose", -1);
        if (-1 != iValue) {
            t_Verbose = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_secStat", -1);
        if (-1 != iValue) {
            t_secStat = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_Timer", -1);
        if (-1 != iValue) {
            t_Timer = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_poolDump", -1);
        if (-1 != iValue) {
            t_poolDump = iValue;
        }

        iValue = GetProfileIntA("XNetRef", "t_tcpWarn", -1);
        if (-1 != iValue) {
            t_tcpWarn = iValue;
        }
#endif
        ZeroMemory(&XNetRefConfigParams, sizeof(XNetRefConfigParams));

        // Get the config sector
        XNetLoadConfigParams(&XNetRefConfigParams);

        // Get the new ip address
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_ina", NULL, szIniString, sizeof(szIniString))) {
            XNetRefConfigParams.ina.s_addr = inet_addr(szIniString);
        }

        // Get the new ip subnet mask address
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_inaMask", NULL, szIniString, sizeof(szIniString))) {
            XNetRefConfigParams.inaMask.s_addr = inet_addr(szIniString);
        }

        // Get the new ip gateway address
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_inaGateway", NULL, szIniString, sizeof(szIniString))) {
            XNetRefConfigParams.inaGateway.s_addr = inet_addr(szIniString);
        }

        // Get the new primary DNS address
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_inaDnsPrimary", NULL, szIniString, sizeof(szIniString))) {
            XNetRefConfigParams.inaDnsPrimary.s_addr = inet_addr(szIniString);
        }

        // Get the new secondary DNS address
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_inaDnsSecondary", NULL, szIniString, sizeof(szIniString))) {
            XNetRefConfigParams.inaDnsSecondary.s_addr = inet_addr(szIniString);
        }

        // Get the DHCP host name
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_achDhcpHostName", NULL, szIniString, sizeof(szIniString))) {
            strncpy(XNetRefConfigParams.achDhcpHostName, szIniString, sizeof(XNetRefConfigParams.achDhcpHostName) - 1);
        }

        // Get the PPPoE user name
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_achPppUserName", NULL, szIniString, sizeof(szIniString))) {
            strncpy(XNetRefConfigParams.achPppUserName, szIniString, sizeof(XNetRefConfigParams.achPppUserName) - 1);
        }

        // Get the PPPoE password
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_achPppPassword", NULL, szIniString, sizeof(szIniString))) {
            strncpy(XNetRefConfigParams.achPppPassword, szIniString, sizeof(XNetRefConfigParams.achPppPassword) - 1);
        }

        // Get the PPPoE server name
        ZeroMemory(szIniString, sizeof(szIniString));
        if (0 != GetProfileStringA("XNetRef", "config_achPppServer", NULL, szIniString, sizeof(szIniString))) {
            strncpy(XNetRefConfigParams.achPppServer, szIniString, sizeof(XNetRefConfigParams.achPppServer) - 1);
        }

        // Set the start parameters
        ZeroMemory(&XNetRefStartupParams, sizeof(XNetRefStartupParams));

        XNetRefStartupParams.cfgSizeOfStruct                    = sizeof(XNetRefStartupParams);
        XNetRefStartupParams.cfgFlags                           = (BYTE) GetProfileIntA("XNetRef", "cfgFlags",                           0);
        XNetRefStartupParams.cfgFlags                           |= XNET_STARTUP_MANUAL_CONFIG;
#ifdef XNETREF_I
        XNetRefStartupParams.cfgFlags                           |= XNET_STARTUP_BYPASS_SECURITY;
#endif
        XNetRefStartupParams.cfgPrivatePoolSizeInPages          = (BYTE) GetProfileIntA("XNetRef", "cfgPrivatePoolSizeInPages",          0);
        XNetRefStartupParams.cfgEnetReceiveQueueLength          = (BYTE) GetProfileIntA("XNetRef", "cfgEnetReceiveQueueLength",          0);
        XNetRefStartupParams.cfgIpFragMaxSimultaneous           = (BYTE) GetProfileIntA("XNetRef", "cfgIpFragMaxSimultaneous",           0);
        XNetRefStartupParams.cfgIpFragMaxPacketDiv256           = (BYTE) GetProfileIntA("XNetRef", "cfgIpFragMaxPacketDiv256",           0);
        XNetRefStartupParams.cfgSockMaxSockets                  = (BYTE) GetProfileIntA("XNetRef", "cfgSockMaxSockets",                  0);
        XNetRefStartupParams.cfgSockDefaultRecvBufsizeInK       = (BYTE) GetProfileIntA("XNetRef", "cfgSockDefaultRecvBufsizeInK",       0);
        XNetRefStartupParams.cfgSockDefaultSendBufsizeInK       = (BYTE) GetProfileIntA("XNetRef", "cfgSockDefaultSendBufsizeInK",       0);
        XNetRefStartupParams.cfgKeyRegMax                       = (BYTE) GetProfileIntA("XNetRef", "cfgKeyRegMax",                       0);
        XNetRefStartupParams.cfgSecRegMax                       = (BYTE) GetProfileIntA("XNetRef", "cfgSecRegMax",                       0);

        iLastError = XNetStartup(&XNetRefStartupParams);

        // Set the xnet config parameters
        XNetConfig(&XNetRefConfigParams, XNET_CONFIG_NORMAL);
    }

    if (0 == iLastError) {
        XNetNewRefCount = (ULONG) ++XNetRefCount;
    }

    // Update the log file
    sprintf(szLogString, "XNetAddRef:\r\n");
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  File Name:   %s\r\n", lpszFile);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  Line Number: %u\r\n", dwLine);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  Ref Count:   %u\r\n", XNetNewRefCount);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  Error Code:  %u\r\n", iLastError);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    ReleaseMutex(hXNetRefMutex);

    if (0 != iLastError) {
        SetLastError(iLastError);
    }

    return XNetNewRefCount;
}



ULONG
WINAPI
XNetReleaseLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Decreases the ref count for the xbox net stack.  Terminates the xbox net stack if necessary.

Return Value:

  The new reference count.

------------------------------------------------------------------------------*/
{
    // XNetNewRefCount is the new reference count;
    ULONG  XNetNewRefCount = 0;

    // szLogString is the log string
    CHAR   szLogString[1024];
    // cb is the number of bytes written to the log string
    DWORD  cb;



    // Synchronize access to this library

    if (NULL == hXNetRefMutex) {
        hXNetRefMutex = CreateMutexA(NULL, FALSE, "XNetRefMutex");
    }

    WaitForSingleObject(hXNetRefMutex, INFINITE);

    // Decrement the ref count
    ASSERT(0 < XNetRefCount);

    if (0 < XNetRefCount) {
        XNetNewRefCount = (ULONG) --XNetRefCount;

        if (0 == XNetRefCount) {
            // Terminate the net stack
            XNetCleanup();

            ZeroMemory(&XNetRefStartupParams, sizeof(XNetRefStartupParams));
            ZeroMemory(&XNetRefConfigParams, sizeof(XNetRefConfigParams));
        }
    }

    // Update the log file
    sprintf(szLogString, "XNetRelease:\r\n");
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  File Name:   %s\r\n", lpszFile);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  Line Number: %u\r\n", dwLine);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    sprintf(szLogString, "  Ref Count:   %u\r\n", XNetNewRefCount);
    WriteFile(hXNetRefLog, szLogString, strlen(szLogString), &cb, NULL);

    // Release access to this library
    ReleaseMutex(hXNetRefMutex);

    return XNetNewRefCount;
}



ULONG
WINAPI
XNetRefGetParams(
    XNetStartupParams  *pXNetRefStartupParams,
    XNetConfigParams   *pXNetRefConfigParams
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the xnet start parameters.

Arguments:

  pXNetRefStartupParams - Pointer to the buffer to receive the xnet start parameters
  pXNetRefConfigParams - Pointer to the buffer to receive the xnet config parameters

Return Value:

  The new reference count.

------------------------------------------------------------------------------*/
{
    // XNetNewRefCount is the new reference count;
    ULONG  XNetNewRefCount = 0;



    // Synchronize access to this library

    if (NULL == hXNetRefMutex) {
        hXNetRefMutex = CreateMutexA(NULL, FALSE, "XNetRefMutex");
    }

    WaitForSingleObject(hXNetRefMutex, INFINITE);

    if (0 != XNetRefCount) {
        // Copy the xnet start parameters
        if (NULL != pXNetRefStartupParams) {
            CopyMemory(pXNetRefStartupParams, &XNetRefStartupParams, sizeof(XNetRefStartupParams));
        }

        // Copy the xnet config parameters
        if (NULL != pXNetRefConfigParams) {
            CopyMemory(pXNetRefConfigParams, &XNetRefConfigParams, sizeof(XNetRefConfigParams));
        }
    }

    // Copy the xnet ref count
    XNetNewRefCount = XNetRefCount;

    // Release access to this library
    ReleaseMutex(hXNetRefMutex);

    return XNetNewRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\getini.c ===
#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

INT	
NTAPI
GetIniInt( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN INT		nDefault,				// return value if key name not found
	IN LPCSTR	lpFileName				// initialization file name
)
{
	return GetPrivateProfileIntA( lpAppName, lpKeyName, nDefault, lpFileName );
}


FLOAT 
NTAPI
GetIniFloat( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN FLOAT	fDefault,				// return value if key name not found
	IN LPCSTR	lpFileName				// initialization file name
)
{
	CHAR szBuf[MAX_PATH];
	CHAR szDefault[MAX_PATH];

	FLOAT fVal = 0.0f;

	sprintf( szDefault, "%f", fDefault );

	GetPrivateProfileStringA( (LPCSTR)lpAppName, (LPCSTR)lpKeyName, szDefault, szBuf, MAX_PATH, (LPCSTR)lpFileName );

	fVal = (FLOAT)atof( szBuf );

	return fVal;
}

INT
NTAPI
GetIniString( 
	IN LPCSTR	lpAppName,				// section name
	IN LPCSTR	lpKeyName,				// key name
	IN LPCSTR	lpDefault,				// return value if key name not found
	OUT LPSTR	lpReturnedString,
	IN DWORD	nSize,
	IN LPCSTR	lpFileName				// initialization file name
)
{
	INT nNumChars = 0;
	CHAR* pChar;

	nNumChars = GetPrivateProfileStringA( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName );
	if ( 0 == nNumChars )
	{
		strcpy( lpReturnedString, lpDefault );
		return nNumChars;
	}

	pChar = strtok( lpReturnedString, "\n;" );
	strcpy( lpReturnedString, pChar );
	nNumChars = strlen( lpReturnedString );
	return nNumChars;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\dllmain.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    DLL entry point for xtestlib

Author:

    Sakphong Chanbai (schanbai) 08-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include "misc.h"
#include "leak.h"
#include "heaptrack.h"
#include "xlog.h"

//
// Flag set if running under Xbox development kit
//

BOOL XTestLibRunningInDevkit = FALSE;


BOOL
XTestLibIsRunningInDevkit(
    VOID
    )
{
    return XTestLibRunningInDevkit;
}


VOID
CDECL
XTestLibStartup(
    VOID
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    OBJECT_STRING DevkitDirectoryName;

    //
    // Copy TESTINI.INI from DVD to title partition if it doesn't exist
    //
    if ( !CopyFile(OTEXT("d:\\testini.ini"), OTEXT("t:\\testini.ini"), TRUE) ) {
        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            DbgPrint(
                "XTESTLIB: warning! unable to copy testini.ini from D: to T: (%s)\n",
                WinErrorSymbolicName(GetLastError())
                );
        }
    }

    NtGlobalFlag = GetProfileIntA(
                        "GeneralSettings",
                        "NtGlobalFlags",
                        NtGlobalFlag
                        );

    //
    // The default behavior of checked kernel has these 2 bits set
    //
#if DBG
    NtGlobalFlag |= FLG_ENABLE_CLOSE_EXCEPTIONS | FLG_ENABLE_KDEBUG_SYMBOL_LOAD;
#endif
    KdPrint(( "XTESTLIB: NtGlobalFlags = 0x%p\n", NtGlobalFlag ));

#if 0
    if ( !InitializeHeapHandleTracking() ) {
        KdPrint(( "XTESTLIB: unable to initialize heap handle tracking\n" ));
    }

    if ( !InitializeHeapAllocationHistory() ) {
        KdPrint(( "XTESTLIB: unable to initialize allocation tracking\n" ));
    }
#endif

    //
    // Check to see if we are running in DEVKIT
    // BUGBUG: is there any way better than this?
    //

    RtlInitObjectString(
        &DevkitDirectoryName,
        OTEXT("\\Device\\Harddisk0\\Partition1\\Devkit")
        );

    InitializeObjectAttributes(
        &ObjA,
        &DevkitDirectoryName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtQueryFullAttributesFile( &ObjA, &NetworkInfo );
    if ( NT_SUCCESS(Status) ) {
        if ( NetworkInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            XTestLibRunningInDevkit = TRUE;
        }
    }
}


VOID
CDECL
XTestLibCleanup(
    VOID
    )
{
#if 0
    UninitializeHeapHandleTracking();
    UninitializeHeapAllocationHistory();
#endif
}


//
// Setup a startup pointer to be called by CRT
//
#pragma data_seg(".CRT$XIU")
PROC xtestlib_startup = (PROC)XTestLibStartup;
#pragma data_seg()


//
// Setup a cleanup pointer to be called by CRT
//
#pragma data_seg(".CRT$XTU")
PROC xtestlib_cleanup = (PROC)XTestLibCleanup;
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\cmdline.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

    Command line processing routines

Author:

    Sakphong Chanbai (schanbai) 08-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"


static
VOID
Parse_CmdlineW(
    IN LPWSTR cmdstart,
    IN LPWSTR * argv OPTIONAL,
    OUT LPWSTR lpstr OPTIONAL,
    OUT INT *numargs,
    OUT INT *numbytes
    )

/*++

Routine Description:

    Parses the command line and sets up the Unicode argv[] array.
    On entry, cmdstart should point to the command line,
    argv should point to memory for the argv array, lpstr
    points to memory to place the text of the arguments.
    If these are NULL, then no storing (only counting)
    is done.  On exit, *numargs has the number of
    arguments (plus one for a final NULL argument),
    and *numbytes has the number of bytes used in the buffer
    pointed to by args.

Arguments:

    cmdstart - pointer to command line of the form <progname><nul><args><nul>
    argv - where to build argv array; NULL means don't build array
    lpstr - where to place argument text; NULL means don't store text
    numargs - returns number of argv entries created
    numbytes - number of bytes used in args buffer

Return Value:

    None

--*/

{
    LPWSTR p;
    WCHAR c;
    INT inquote;                    // 1 = inside quotes
    INT copychar;                   // 1 = copy char to *args
    WORD numslash;                  // Num of backslashes seen

    *numbytes = 0;
    *numargs = 1;                   // The program name at least

    // First scan the program name, copy it, and count the bytes
    p = cmdstart;
    if (argv) {
        *argv++ = lpstr;
    }

    //
    // A quoted program name is handled here. The handling is much
    // simpler than for other arguments. Basically, whatever lies
    // between the leading double-quote and next one, or a terminal null
    // character is simply accepted. Fancier handling is not required
    // because the program name must be a legal NTFS/HPFS file name.
    // Note that the double-quote characters are not copied, nor do they
    // contribute to numbytes.
    //
    if (*p == L'\"') {
        //
        // Scan from just past the first double-quote through the next
        // double-quote, or up to a null, whichever comes first
        //
        while ((*(++p) != L'\"') && (*p != L'\0')) {
            *numbytes += sizeof(WCHAR);
            if (lpstr) {
                *lpstr++ = *p;
            }
        }

        // Append the terminating null
        *numbytes += sizeof(WCHAR);
        if (lpstr) {
            *lpstr++ = L'\0';
        }

        // If we stopped on a double-quote (usual case), skip over it
        if (*p == L'\"') {
            p++;
        }
    } else {
        // Not a quoted program name
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr) {
                *lpstr++ = *p;
            }

            c = (WCHAR) *p++;

        } while (c > L' ');

        if (c == L'\0') {
            p--;
        } else {
            if (lpstr) {
                *(lpstr - 1) = L'\0';
            }
        }
    }

    inquote = 0;

    // Loop on each argument
    for ( ; ; ) {
        if (*p) {
            while (*p == L' ' || *p == L'\t') {
                ++p;
            }
        }

        if (*p == L'\0') {
            break;                  // End of args
        }

        // Scan an argument
        if (argv) {
            *argv++ = lpstr;        // Store ptr to arg
        }

        ++*numargs;

        // Loop through scanning one argument
        for ( ; ; ) {
            copychar = 1;

            //
            // Rules: 2N backslashes + " ==> N backslashes and begin/end quote
            //        2N+1 backslashes + " ==> N backslashes + literal "
            //        N backslashes ==> N backslashes
            //
            numslash = 0;
            while (*p == L'\\') {
                // Count number of backslashes for use below
                ++p;
                ++numslash;
            }

            if (*p == L'\"') {
                // if 2N backslashes before, start/end quote, otherwise copy literally
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == L'\"') {
                            p++;        // Double quote inside quoted string
                        } else {        // skip first quote char and copy second
                            copychar = 0;
                        }
                    } else {
                        copychar = 0;   // Don't copy quote
                    }

                    inquote = !inquote;
                }
                numslash /= 2;          // Divide numslash by two
            }

            // Copy slashes
            while (numslash--) {
                if (lpstr) {
                    *lpstr++ = L'\\';
                }
                *numbytes += sizeof(WCHAR);
            }

            // If at end of arg, break loop
            if (*p == L'\0' || (!inquote && (*p == L' ' || *p == L'\t'))) {
                break;
            }

            // copy character into argument
            if (copychar) {
                if (lpstr) {
                    *lpstr++ = *p;
                }
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        // Null-terminate the argument
        if (lpstr) {
            *lpstr++ = L'\0';         // terminate string
        }
        *numbytes += sizeof(WCHAR);
    }

}


static
VOID
Parse_CmdlineA(
    IN LPSTR cmdstart,
    IN LPSTR * argv OPTIONAL,
    OUT LPSTR lpstr OPTIONAL,
    OUT INT *numargs,
    OUT INT *numbytes
    )

/*++

Routine Description:

    Parses the command line and sets up the ANSI argv[] array.
    On entry, cmdstart should point to the command line,
    argv should point to memory for the argv array, lpstr
    points to memory to place the text of the arguments.
    If these are NULL, then no storing (only counting)
    is done.  On exit, *numargs has the number of
    arguments (plus one for a final NULL argument),
    and *numbytes has the number of bytes used in the buffer
    pointed to by args.

Arguments:

    cmdstart - pointer to command line of the form <progname><nul><args><nul>
    argv - where to build argv array; NULL means don't build array
    lpstr - where to place argument text; NULL means don't store text
    numargs - returns number of argv entries created
    numbytes - number of bytes used in args buffer

Return Value:

    None

--*/

{
    LPSTR p;
    CHAR c;
    INT inquote;                    // 1 = inside quotes
    INT copychar;                   // 1 = copy char to *args
    WORD numslash;                  // Num of backslashes seen

    *numbytes = 0;
    *numargs = 1;                   // The program name at least

    // First scan the program name, copy it, and count the bytes
    p = cmdstart;
    if (argv) {
        *argv++ = lpstr;
    }

    //
    // A quoted program name is handled here. The handling is much
    // simpler than for other arguments. Basically, whatever lies
    // between the leading double-quote and next one, or a terminal null
    // character is simply accepted. Fancier handling is not required
    // because the program name must be a legal NTFS/HPFS file name.
    // Note that the double-quote characters are not copied, nor do they
    // contribute to numbytes.
    //
    if (*p == '\"') {
        //
        // Scan from just past the first double-quote through the next
        // double-quote, or up to a null, whichever comes first
        //
        while ((*(++p) != '\"') && (*p != '\0')) {
            *numbytes += sizeof(CHAR);
            if (lpstr) {
                *lpstr++ = *p;
            }
        }

        // Append the terminating null
        *numbytes += sizeof(CHAR);
        if (lpstr) {
            *lpstr++ = '\0';
        }

        // If we stopped on a double-quote (usual case), skip over it
        if (*p == '\"') {
            p++;
        }
    } else {
        // Not a quoted program name
        do {
            *numbytes += sizeof(CHAR);
            if (lpstr) {
                *lpstr++ = *p;
            }

            c = (CHAR) *p++;

        } while (c > ' ');

        if (c == '\0') {
            p--;
        } else {
            if (lpstr) {
                *(lpstr - 1) = '\0';
            }
        }
    }

    inquote = 0;

    // Loop on each argument
    for ( ; ; ) {
        if (*p) {
            while (*p == ' ' || *p == '\t') {
                ++p;
            }
        }

        if (*p == '\0') {
            break;                  // End of args
        }

        // Scan an argument
        if (argv) {
            *argv++ = lpstr;        // Store ptr to arg
        }

        ++*numargs;

        // Loop through scanning one argument
        for ( ; ; ) {
            copychar = 1;

            //
            // Rules: 2N backslashes + " ==> N backslashes and begin/end quote
            //        2N+1 backslashes + " ==> N backslashes + literal "
            //        N backslashes ==> N backslashes
            //
            numslash = 0;
            while (*p == '\\') {
                // Count number of backslashes for use below
                ++p;
                ++numslash;
            }

            if (*p == '\"') {
                // if 2N backslashes before, start/end quote, otherwise copy literally
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == '\"') {
                            p++;        // Double quote inside quoted string
                        } else {        // skip first quote char and copy second
                            copychar = 0;
                        }
                    } else {
                        copychar = 0;   // Don't copy quote
                    }

                    inquote = !inquote;
                }
                numslash /= 2;          // Divide numslash by two
            }

            // Copy slashes
            while (numslash--) {
                if (lpstr) {
                    *lpstr++ = '\\';
                }
                *numbytes += sizeof(CHAR);
            }

            // If at end of arg, break loop
            if (*p == '\0' || (!inquote && (*p == ' ' || *p == '\t'))) {
                break;
            }

            // copy character into argument
            if (copychar) {
                if (lpstr) {
                    *lpstr++ = *p;
                }
                *numbytes += sizeof(CHAR);
            }
            ++p;
        }

        // Null-terminate the argument
        if (lpstr) {
            *lpstr++ = '\0';         // terminate string
        }
        *numbytes += sizeof(CHAR);
    }

}


LPWSTR *
NTAPI
CommandLineToArgvW(
    IN LPCWSTR lpCmdLine,
    OUT int * pNumArgs
    )

/*++

Routine Description:

    Read the command line and create the argv array for C programs.

Arguments:

    lpCmdLine - [in] Pointer to a null-terminated Unicode command-line string.
        An application will usually directly pass on the value returned by a 
        call to the GetCommandLineW function. If this parameter is the empty 
        string, "", the function returns the path to the current executable file. 

    pNumArgs - [out] Pointer to an integer variable that receives the count of 
        arguments parsed. 

Return Value:

    If the function succeeds, the return value is a non-NULL pointer to the 
    constructed argument list, which is an array of Unicode strings. 
    
    If the function fails, the return value is NULL. 
    To get extended error information, call GetLastError. 

--*/

{
    LPWSTR * argv_U;
    LPWSTR   cmdstart;  // start of command line to parse
    INT      numbytes;
    WCHAR    pgmname[MAX_PATH];

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // BUGBUG: remove comment below when xapi is ready for us
    // Get the program name pointer from Win32 Base
    //GetModuleFileName(NULL, pgmname, sizeof(pgmname) / sizeof(WCHAR));

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    //   possibly another program), then we use pgmname as the command line
    //   to parse, so that argv[0] is initialized to the program name
    //
    cmdstart = (*lpCmdLine == TEXT('\0')) ? pgmname : (LPWSTR)lpCmdLine;

    // First find out how much space is needed to store args
    Parse_CmdlineW(cmdstart, NULL, NULL, pNumArgs, &numbytes);

    // Allocate space for argv[] vector and strings
    argv_U = (LPWSTR*)GlobalAlloc(LMEM_ZEROINIT, (*pNumArgs+1) * sizeof(LPWSTR) + numbytes);

    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // Store args and argv ptrs in just allocated block
    Parse_CmdlineW(cmdstart, argv_U,
                  (LPWSTR)(((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                  pNumArgs, &numbytes
                 );

    return argv_U;
}


LPSTR *
NTAPI
CommandLineToArgvA(
    IN LPCSTR lpCmdLine,
    OUT int * pNumArgs
    )

/*++

Routine Description:

    Read the command line and create the argv array for C programs.

Arguments:

    lpCmdLine - [in] Pointer to a null-terminated ANSI command-line string.
        An application will usually directly pass on the value returned by a 
        call to the GetCommandLineA function. If this parameter is the empty 
        string, "", the function returns the path to the current executable file. 

    pNumArgs - [out] Pointer to an integer variable that receives the count of 
        arguments parsed. 

Return Value:

    If the function succeeds, the return value is a non-NULL pointer to the 
    constructed argument list, which is an array of ANSI strings. 
    
    If the function fails, the return value is NULL. 
    To get extended error information, call GetLastError. 

--*/

{
    LPSTR * argv_U;
    LPSTR   cmdstart;  // start of command line to parse
    INT     numbytes;
    CHAR    pgmname[MAX_PATH];

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // BUGBUG: remove comment below when xapi is ready for us
    // Get the program name pointer from Win32 Base
    //GetModuleFileName(NULL, pgmname, sizeof(pgmname) / sizeof(WCHAR));

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    //   possibly another program), then we use pgmname as the command line
    //   to parse, so that argv[0] is initialized to the program name
    //
    cmdstart = (*lpCmdLine == '\0') ? pgmname : (LPSTR)lpCmdLine;

    // First find out how much space is needed to store args
    Parse_CmdlineA(cmdstart, NULL, NULL, pNumArgs, &numbytes);

    // Allocate space for argv[] vector and strings
    argv_U = (LPSTR*)GlobalAlloc(LMEM_ZEROINIT, (*pNumArgs+1) * sizeof(LPSTR) + numbytes);

    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // Store args and argv ptrs in just allocated block
    Parse_CmdlineA(cmdstart, argv_U,
                  (LPSTR)(((LPBYTE)argv_U) + *pNumArgs * sizeof(LPSTR)),
                  pNumArgs, &numbytes
                 );

    return argv_U;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\heaptrack.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heaptrack.h

Abstract:

    Routines to tracking private heap created by HeapCreate/HeapDestroy

Author:

    Sakphong Chanbai (schanbai) 11-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef __HEAPTRACK_INCLUDED__

#define __HEAPTRACK_INCLUDED__


BOOL
InitializeHeapHandleTracking(
    VOID
    );


VOID
UninitializeHeapHandleTracking(
    VOID
    );


#endif // __HEAPTRACK_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\heaptrack.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heaptrack.c

Abstract:

    Routines to tracking private heap created by HeapCreate/HeapDestroy.
    The basic idea is that IATs (of HeapCreate/HeapDestroy) of implicit
    modules will be intercepted during DLL_PROCESS_ATTACH of XTESTLIB.DLL.
    IATs of dynamic, explicit modules will be intercepted during image
    load notification callback from NTOSKRNL

    For implicit module, the tricky part is the way harness.exe get built.
    Makes sure that XTESTLIB.LIB is the very first library to link with so
    that XTESTLIB will get DLL_PROCESS_ATTACH before other modules and
    be able to intercept IATs. Otherwise we will miss HeapCreate called
    during DLL_PROCESS_ATTACH

Author:

    Sakphong Chanbai (schanbai) 11-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "misc.h"
#include "xeutils.h"
#include "prochook.h"
#include "heaptrack.h"


#define RET_ADDR( c ) *((PULONG)&(c) - 1)


typedef HANDLE (WINAPI *HEAPCREATEPROC)(DWORD, SIZE_T, SIZE_T);
typedef BOOL (WINAPI *HEAPDESTROYPROC)(HANDLE);

CRITICAL_SECTION HeapHandleDatabaseLock;
PPRIVATE_HEAP_RECORD HeapHandleDatabase;

PXIMAGE_MODULE_HEADER XapiModuleHeader;
HEAPCREATEPROC HeapCreateProc;
HEAPDESTROYPROC HeapDestroyProc;


BOOL
InsertHeapHandleToDatabase(
    HANDLE HeapHandle,
    ULONG  OwnerModuleIndex
    )

/*++

Routine Description:

    This is a routine to insert heap handle from database

Arguments:

    HeapHandle - Heap handle returned by HeapCreate or GetProcessHeap
    OwnerModuleIndex - XE module index of owner who created the heap

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
    ULONG i, ModuleIndex;
    PPRIVATE_HEAP_RECORD p = HeapHandleDatabase;

    for ( i=0; i<MAX_HEAP_HANDLE_TRACKING; i++, p++ ) {
        if ( !p->HeapHandle ) {
            ASSERT( p->OwnerModuleIndex == ~0UL );
            p->HeapHandle = HeapHandle;
            p->OwnerModuleIndex = OwnerModuleIndex;
            break;
        }
    }

    return i < MAX_HEAP_HANDLE_TRACKING;
}


BOOL
RemoveHeapHandleFromDatabase(
    HANDLE HeapHandle,
    ULONG  OwnerModuleIndex
    )

/*++

Routine Description:

    This is a routine to remove heap handle from database

Arguments:

    HeapHandle - Heap handle returned by HeapCreate or GetProcessHeap

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
    ULONG i, ModuleIndex;
    PPRIVATE_HEAP_RECORD p = HeapHandleDatabase;

    for ( i=0; i<MAX_HEAP_HANDLE_TRACKING; i++, p++ ) {
        if ( p->HeapHandle == HeapHandle ) {
            ASSERT( p->OwnerModuleIndex == OwnerModuleIndex );
            p->HeapHandle = NULL;
            p->OwnerModuleIndex = ~0UL;
            break;
        }
    }

    return i < MAX_HEAP_HANDLE_TRACKING;
}


HANDLE
WINAPI
xxx_HeapCreate(
    DWORD  flOptions,
    SIZE_T dwInitialSize,
    SIZE_T MaximumSize
    )

/*++

Routine Description:

    The HeapCreate function creates a heap object that can be used by the calling
    process. The function reserves space in the virtual address space of the
    process and allocates physical storage for a specified initial portion of
    this block

Arguments:

    flOptions - Specifies optional attributes for the new heap. These options
        affect subsequent access to the new heap through calls to the heap functions
        See MSDN for more details

    dwInitialSize - Specifies the initial size, in bytes, of the heap. This value
        determines the initial amount of physical storage that is allocated for
        the heap. The value is rounded up to the next page boundary

    dwMaximumSize - If dwMaximumSize is a nonzero value, it specifies the maximum
        size, in bytes, of the heap. The HeapCreate function rounds dwMaximumSize
        up to the next page boundary, and then reserves a block of that size in
        the process's virtual address space for the heap. See MSDN for more details

Return Value:

    Handle to newly created heap or NULL if the function fails

--*/

{
    HANDLE HeapHandle = HeapCreateProc( flOptions, dwInitialSize, MaximumSize );

    if ( HeapHandle && HeapHandleDatabase ) {
        try {
            EnterCriticalSection( &HeapHandleDatabaseLock );
            InsertHeapHandleToDatabase( HeapHandle, XeModuleIndexFromAddress(RET_ADDR(flOptions)) );
        } finally {
            LeaveCriticalSection( &HeapHandleDatabaseLock );
        }
    }

    return HeapHandle;
}


BOOL
WINAPI
xxx_HeapDestroy(
    HANDLE HeapHandle
    )

/*++

Routine Description:

    The HeapDestroy function destroys the specified heap object. HeapDestroy
    decommits and releases all the pages of a private heap object, and it
    invalidates the handle to the heap

Arguments:

    HeapHandle - Specifies the heap to be destroyed. This parameter should be
    a heap handle returned by the HeapCreate function. Do not use the handle to
    the process heap returned by the GetProcessHeap function

Return Value:

    TRUE if succeeds, FALSE otherwise

--*/

{
    BOOL b = HeapDestroyProc( HeapHandle );

    if ( HeapHandle && b && HeapHandleDatabase ) {
        try {
            EnterCriticalSection( &HeapHandleDatabaseLock );
            RemoveHeapHandleFromDatabase( HeapHandle, XeModuleIndexFromAddress(RET_ADDR(HeapHandle)) );
        } finally {
            LeaveCriticalSection( &HeapHandleDatabaseLock );
        }
    }

    return b;
}


VOID
XTestLibLoadImageNotifyRoutine(
    PUNICODE_STRING FullImageName,
    PVOID   ImageHandle,
    PVOID   ImageBaseAddress,
    BOOLEAN Unloading
    )

/*++

Routine Description:

    This is a callback routine notified when there is a module about to load
    or unload. We will hook xapi!HeapCreate and xapi!HeapDestroy here.

Arguments:

    None

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
    if ( Unloading || !XapiModuleHeader || !HeapCreateProc || !HeapDestroyProc ) {
        return;
    }

    // Hijack xapi!HeapCreate to xxx_HeapCreate
    HookPEImportedFunctionEx(
        (ULONG_PTR)ImageBaseAddress,
        "xapi.dll",
        (PROC)HeapCreateProc,
        (PROC)xxx_HeapCreate
        );

    // Hijack xapi!HeapDestroy to xxx_HeapDestroy
    HookPEImportedFunctionEx(
        (ULONG_PTR)ImageBaseAddress,
        "xapi.dll",
        (PROC)HeapDestroyProc,
        (PROC)xxx_HeapDestroy
        );
}


BOOL
InitializeHeapHandleTracking(
    VOID
    )

/*++

Routine Description:

    This routine initializes critical section, allocates buffer to track
    private heap created by HeapCreate/HeapDestroy, setup load image notification
    callback and intercepts HeapCreate/HeapDestroy from implicit module

Arguments:

    None

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
    NTSTATUS Status;
    PXIMAGE_HEADER ImageHeader;
    PXIMAGE_MODULE_HEADER ModuleHeader;
    PVOID VarImageHeader;
    PPRIVATE_HEAP_RECORD p;
    ULONG i;

    InitializeCriticalSection( &HeapHandleDatabaseLock );

    ImageHeader = XTestLibLocateXImageHeader();
    if ( !ImageHeader ) {
        DbgPrint( "XTESTLIB: unable to get XE image header\n" );
        DebugBreak();
        return FALSE;
    }

    XapiModuleHeader = XeModuleHeaderFromModuleName( "xapi.dll" );
    if ( !XapiModuleHeader ) {
        DbgPrint( "XTESTLIB: unable to get module header of xapi.dll\n" );
        DebugBreak();
        return FALSE;
    }

    HeapCreateProc = (HEAPCREATEPROC)GetProcAddress( (HMODULE)XapiModuleHeader, "HeapCreate" );
    HeapDestroyProc = (HEAPDESTROYPROC)GetProcAddress( (HMODULE)XapiModuleHeader, "HeapDestroy" );

    if ( !HeapCreateProc || !HeapDestroyProc ) {
        DbgPrint( "XTESTLIB: unable to get proc address of HeapCreate/HeapDestroy\n" );
        DebugBreak();
        return FALSE;
    }

    HeapHandleDatabase = AllocateKernelPool( sizeof(PRIVATE_HEAP_RECORD) * MAX_HEAP_HANDLE_TRACKING );
    if ( !HeapHandleDatabase ) {
        DbgPrint( "XTESTLIB: unable to allocate memory for private heap tracking\n" );
        DebugBreak();
        return FALSE;
    }

    for ( p=HeapHandleDatabase, i=0; i<MAX_HEAP_HANDLE_TRACKING; p++, i++ ) {
        p->OwnerModuleIndex = ~0UL;
    }

    ASSERT( GetProcessHeap() != NULL );

    if ( GetProcessHeap() ) {
        InsertHeapHandleToDatabase( GetProcessHeap(), 0 );
    }

    VarImageHeader = (PVOID)(ImageHeader->HeadersBase + XIMAGE_FIXED_HEADER_SIZE(ImageHeader));
    ModuleHeader = XIMAGE_FIRST_MODULE(ImageHeader, VarImageHeader); 

    for ( i=0; i<ImageHeader->OptionalHeader.NumberOfModules; i++, ModuleHeader++ ) {

        //
        // Only do this for implicit module, load image callback will take care
        // of explicit module later once it is being loaded
        //
        if ( ModuleHeader->ModuleFlags & XIMAGE_MODFLAG_IMPLICIT ) {
            HookImportedFunction( (HMODULE)ModuleHeader, "xapi.dll", "HeapCreate", (PROC)xxx_HeapCreate );
            HookImportedFunction( (HMODULE)ModuleHeader, "xapi.dll", "HeapDestroy", (PROC)xxx_HeapDestroy );
        }
    }

    Status = PsSetLoadImageNotifyRoutine( XTestLibLoadImageNotifyRoutine );
    if ( !NT_SUCCESS(Status) ) {
        DbgPrint( "XTESTLIB: PsSetLoadImageNotifyRoutine failed 0x%x\n", Status );
        DebugBreak();
        return FALSE;
    }

    return TRUE;
}


VOID
UninitializeHeapHandleTracking(
    VOID
    )

/*++

Routine Description:

    This routine frees memory allocate by InitializeHeapHandleTracking

Arguments:

    None

Return Value:

    None

--*/

{
    DeleteCriticalSection( &HeapHandleDatabaseLock );

    if ( HeapHandleDatabase ) {
        FreeKernelPool( HeapHandleDatabase );
    }
}


BOOL
WINAPI
GetHeapTrackingDatabase(
    PPRIVATE_HEAP_RECORD HeapRecordPtr,
    SIZE_T BufferSize
    )

/*++

Routine Description:

    This routine copies raw data from heap handle tracking database to specified
    buffer.

Arguments:

    HeapRecordPtr - Buffer to receive heap handle tracking data
    BufferSize - Size of buffer in byte

Return Value:

    TRUE if succeeds, FALSE otherwise. To get extended error information, call GetLastError

--*/

{
#if 0
    DWORD ErrorCode = ERROR_NOACCESS;
    BOOL Success = FALSE;

    if ( BufferSize < (sizeof(PRIVATE_HEAP_RECORD) * MAX_HEAP_HANDLE_TRACKING) ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    try {
        EnterCriticalSection( &HeapHandleDatabaseLock );
        RtlCopyMemory( HeapRecordPtr, HeapHandleDatabase, sizeof(PRIVATE_HEAP_RECORD) * MAX_HEAP_HANDLE_TRACKING );
        ErrorCode = ERROR_SUCCESS;
        Success = TRUE;
    } finally {
        LeaveCriticalSection( &HeapHandleDatabaseLock );
    }

    SetLastError( ErrorCode );
    return Success;
#endif

    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\leak.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    leak.c

Abstract:

    Leak debugging routines

Author:

    Sakphong Chanbai (schanbai) 22-May-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "prochook.h"
#include "leak.h"
#include "misc.h"


CRITICAL_SECTION HistoryDatabaseLock;
LIST_ENTRY HistoryDatabase;
ULONG HistoryEntriesCount;
LONG AllocationTrackingEnabled = 0;


BOOL
InitializeHeapAllocationHistory(
    VOID
    )

/*++

Routine Description:
              
    Initialize heap and critical section for heap allocation history

Arguments:

    None

Return:
    
    TRUE if success, FALSE otherwise

--*/

{
    InitializeListHead( &HistoryDatabase );
    InitializeCriticalSection( &HistoryDatabaseLock );
    HistoryEntriesCount = 0;
    return TRUE;
}


VOID
UninitializeHeapAllocationHistory(
    VOID
    )
{
    PLIST_ENTRY Entry;
    PALLOCATION_HISTORY p;

    EnterCriticalSection( &HistoryDatabaseLock );

    Entry = HistoryDatabase.Flink;
    while ( Entry != &HistoryDatabase ) {
        p = CONTAINING_RECORD( Entry, ALLOCATION_HISTORY, List );
        ASSERT( p );
        ASSERT_SIGNATURE( p );
        ASSERT( p->AllocType < AllocationType_Max );
        Entry = Entry->Flink;
        FreeKernelPool( p );
    }

    HistoryEntriesCount = 0;
    InitializeListHead( &HistoryDatabase );
    LeaveCriticalSection( &HistoryDatabaseLock );

    DeleteCriticalSection( &HistoryDatabaseLock );
}


VOID
InsertAllocationHistory(
    ULONG Caller,
    PVOID MemBlock,
    ULONG Size,
    AllocationType AllocType
    )
{
    PLIST_ENTRY Entry;
    PALLOCATION_HISTORY p;
    ULONG AllocSize = sizeof(ALLOCATION_HISTORY);
    ULONG Hash;

    if ( !MemBlock || !AllocationTrackingEnabled ) {
        return;
    }

    EnterCriticalSection( &HistoryDatabaseLock );

    // Find insertion point or that the list is sorted by caller
    Entry = HistoryDatabase.Flink;
    while ( Entry != &HistoryDatabase ) {
        p = CONTAINING_RECORD( Entry, ALLOCATION_HISTORY, List );
        ASSERT( p );
        ASSERT_SIGNATURE( p );
        ASSERT( p->AllocType < AllocationType_Max );
        if ( p->Caller == Caller ) {
            break;
        }
        Entry = Entry->Flink;
    }

    if ( AllocationTrackingEnabled & CAPTURE_STACK_BACK_TRACE ) {
        AllocSize += ( sizeof(PULONG) * MAX_STACK_DEPTH );
    }

    p = (PALLOCATION_HISTORY)AllocateKernelPool( AllocSize );

    if ( p ) {
        p->Caller = Caller;
        p->MemBlock = MemBlock;
        p->AllocType = AllocType;
        p->Size = Size;

        if ( AllocationTrackingEnabled & CAPTURE_STACK_BACK_TRACE ) {
            p->StackBackTrace = (PVOID*)( (PBYTE)p + sizeof(ALLOCATION_HISTORY) );
            RtlCaptureStackBackTrace( 2, MAX_STACK_DEPTH, p->StackBackTrace, &Hash );
        } else {
            p->StackBackTrace = NULL;
        }

#if DBG
        p->Signature = AllocationHistorySignature;
#endif

        InsertHeadList( Entry, &p->List );
        HistoryEntriesCount++;
    } else {
        DbgPrint( "XTESTLIB: unable to allocate allocation history\n" );
    }
    
    LeaveCriticalSection( &HistoryDatabaseLock );
}


BOOL
RemoveAllocationHistory(
    PVOID MemBlock
    )
{
    PLIST_ENTRY Entry;
    PALLOCATION_HISTORY p;
    BOOL Found = FALSE;

    if ( !AllocationTrackingEnabled  ) {
        return TRUE;
    }

    EnterCriticalSection( &HistoryDatabaseLock );

    Entry = HistoryDatabase.Flink;
    while ( Entry != &HistoryDatabase ) {
        p = CONTAINING_RECORD( Entry, ALLOCATION_HISTORY, List );
        ASSERT( p );
        ASSERT_SIGNATURE( p );
        ASSERT( p->AllocType < AllocationType_Max );
        if ( p->MemBlock == MemBlock ) {
            Found = TRUE;
            RemoveEntryList( &p->List );
            HistoryEntriesCount--;
            FreeKernelPool( p );
            break;
        }
        Entry = Entry->Flink;
    }
    
    if ( !Found ) {
        if ( AllocationTrackingEnabled & DETECT_INVALID_FREE ) {
            DbgPrint( "\nXTESTLIB: invalid de-allocation, couldn't find %p in database\n", MemBlock );
            __asm int 3;
        } else {
            Found = TRUE;
        }
    }

    LeaveCriticalSection( &HistoryDatabaseLock );
    return Found;
}


extern "C"
ULONG
WINAPI
SetAllocationTrackingOptions(
    ULONG Flags
    )
{
    return InterlockedExchange( &AllocationTrackingEnabled, Flags );
}


extern "C"
void *
__cdecl
xxx_malloc(
    size_t size
    )
{
    void * ptr = LocalAlloc( LPTR, size );
    InsertAllocationHistory( RET_ADDR(size), ptr, size, AllocationType_malloc );
    return ptr;
}


extern "C"
void *
__cdecl
xxx_calloc(
    size_t num,
    size_t size
    )
{
    size_t total = num*size;
    void * ptr = LocalAlloc( LPTR, total );
    InsertAllocationHistory( RET_ADDR(num), ptr, total, AllocationType_calloc );
    return ptr;
}


extern "C"
void
__cdecl
xxx_free(
    void * memblock
    )
{
    if ( memblock && RemoveAllocationHistory(memblock) ) {
        LocalFree( memblock );
    }
}


extern "C"
void *
__cdecl
xxx_realloc(
    void * memblock,
    size_t size
    )
{
    void * ptr;

    if ( !memblock ) {
        ptr = LocalAlloc( LPTR, size );
        InsertAllocationHistory( RET_ADDR(memblock), ptr, size, AllocationType_realloc );
    } else if ( size == 0 ) {
        ptr = NULL;
        xxx_free( memblock );
    } else {
        ptr = LocalReAlloc( memblock, size, LPTR );
        if ( ptr ) {
            RemoveAllocationHistory( memblock );
            InsertAllocationHistory( RET_ADDR(memblock), ptr, size, AllocationType_realloc );
        } else {
            ptr = NULL;
        }
    }

    return ptr;
}


HLOCAL
WINAPI
xxx_LocalAlloc(
    UINT   uFlags,
    SIZE_T uBytes
    )
{
    HLOCAL h = LocalAlloc( uFlags, uBytes );
    InsertAllocationHistory( RET_ADDR(uFlags), h, uBytes, AllocationType_LocalAlloc );
    return h;
}


extern "C"
HGLOBAL
WINAPI
xxx_GlobalAlloc(
    UINT   uFlags,
    SIZE_T uBytes
    )
{
    HGLOBAL h = GlobalAlloc( uFlags, uBytes );
    InsertAllocationHistory( RET_ADDR(uFlags), h, uBytes, AllocationType_GlobalAlloc );
    return h;
}


HLOCAL
WINAPI
xxx_LocalFree(
    HLOCAL hMem
    )
{
    if ( hMem && !RemoveAllocationHistory(hMem) ) {
        return hMem;
    }

    return LocalFree( hMem );
}


HGLOBAL
WINAPI
xxx_GlobalFree(
    HGLOBAL hMem
    )
{
    if ( hMem && !RemoveAllocationHistory(hMem) ) {
        return hMem;
    }

    return GlobalFree( hMem );
}


LPVOID
WINAPI
xxx_HeapAlloc(
    HANDLE hHeap,
    DWORD  dwFlags,
    SIZE_T dwBytes
    )
{
    LPVOID MemBlock = HeapAlloc( hHeap, dwFlags, dwBytes );
    InsertAllocationHistory( RET_ADDR(hHeap), MemBlock, dwBytes, AllocationType_HeapAlloc );
    return MemBlock;
}


BOOL
WINAPI
xxx_HeapFree(
    HANDLE hHeap,
    DWORD  dwFlags,
    LPVOID lpMem
    )
{
    if ( lpMem && !RemoveAllocationHistory(lpMem) ) {
        return FALSE;
    }

    return HeapFree( hHeap, dwFlags, lpMem );
}


void *
__cdecl
operator new(
    unsigned int size
    )
{
    void * p = LocalAlloc( LPTR, size );
    InsertAllocationHistory( RET_ADDR(size), p, size, AllocationType_operator_new );
    return p;
}


void
__cdecl
operator delete(
    void * lpMem
    )
{
    if ( lpMem && !RemoveAllocationHistory(lpMem) ) {
        return;
    }

    LocalFree( lpMem );
}


void *
__cdecl
operator new[](
    unsigned int size
    )
{
    void * p = LocalAlloc( LPTR, size );
    InsertAllocationHistory( RET_ADDR(size), p, size, AllocationType_operator_new_bracket );
    return p;
}


void
__cdecl
operator delete[](
    void * lpMem
    )
{
    if ( lpMem && !RemoveAllocationHistory(lpMem) ) {
        return;
    }

    LocalFree( lpMem );
}


LPVOID
WINAPI
xxx_VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    )
{
    LPVOID pv = VirtualAlloc( lpAddress, dwSize, flAllocationType, flProtect );

    // Insert allocation tracking only MEM_COMMIT
    if ( flAllocationType & MEM_COMMIT ) {
        InsertAllocationHistory( RET_ADDR(lpAddress), pv, dwSize, AllocationType_VirtualAlloc );
    }

    return pv;
}


BOOL
WINAPI
xxx_VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  dwFreeType
    )
{
    RemoveAllocationHistory( lpAddress );
    return VirtualFree( lpAddress, dwSize, dwFreeType );
}


struct {
    LPCSTR ModuleName;
    LPCSTR ProcName;
    PROC   NewProcAddress;
} ProcToBeHooked[] = {
    "xapi.dll", "LocalAlloc",   (PROC)xxx_LocalAlloc,
    "xapi.dll", "LocalFree",    (PROC)xxx_LocalFree,
    "xapi.dll", "GlobalAlloc",  (PROC)xxx_GlobalAlloc,
    "xapi.dll", "GlobalFree",   (PROC)xxx_GlobalFree,
    "xapi.dll", "HeapAlloc",    (PROC)xxx_HeapAlloc,
    "xapi.dll", "HeapFree",     (PROC)xxx_HeapFree,
    "xapi.dll", "VirtualAlloc", (PROC)xxx_VirtualAlloc,
    "xapi.dll", "VirtualFree",  (PROC)xxx_VirtualFree,
};


extern "C"
BOOL
WINAPI
EnableAllocationTracking(
    HMODULE XeModuleHandle
    )
{
    SIZE_T i, ArraySize = sizeof(ProcToBeHooked)/sizeof(ProcToBeHooked[0]);

    for ( i=0; i<ArraySize; i++ ) {
        HookImportedFunction(
            XeModuleHandle,
            ProcToBeHooked[i].ModuleName,
            ProcToBeHooked[i].ProcName,
            ProcToBeHooked[i].NewProcAddress
            );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\iniapis.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    iniapis.c

Abstract:

    This module contains the client side of the Win32 Initialization
    File APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

    08-Mar-2000     schanbai

          Port from base to XBox test library and remove mapping routines,
          client/server calls to CSR, registry-related routines.

    10-Mar-2000     schanbai

          Remove DBCS support from .ini file, even the file is ANSI

--*/

#include "precomp.h"
#include "misc.h"


#define BYTE_ORDER_MARK           0xFEFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE

#pragma warning( disable : 4201 )
#pragma warning( disable : 4213 )

typedef enum _INIFILE_OPERATION {
    FlushProfiles,
    ReadKeyValue,
    WriteKeyValue,
    DeleteKey,
    ReadKeyNames,
    ReadSectionNames,
    ReadSection,
    WriteSection,
    DeleteSection,
    RefreshIniFileMapping
} INIFILE_OPERATION;


typedef struct _INIFILE_CACHE {
    struct _INIFILE_CACHE *Next;
    ULONG EnvironmentUpdateCount;
    UNICODE_STRING NtFileName;
    HANDLE FileHandle;
    BOOLEAN WriteAccess;
    BOOLEAN UnicodeFile;
    BOOLEAN LockedFile;
    ULONG EndOfFile;
    PVOID BaseAddress;
    SIZE_T CommitSize;
    SIZE_T RegionSize;
    ULONG UpdateOffset;
    ULONG UpdateEndOffset;
    ULONG DirectoryInformationLength;
    FILE_NETWORK_OPEN_INFORMATION NetworkInformation;
} INIFILE_CACHE, *PINIFILE_CACHE;


typedef struct _INIFILE_PARAMETERS {
    INIFILE_OPERATION Operation;
    BOOLEAN WriteOperation;
    BOOLEAN Unicode;
    BOOLEAN ValueBufferAllocated;
    PINIFILE_CACHE IniFile;
    UNICODE_STRING FileName;
    UNICODE_STRING NtFileName;
    ANSI_STRING ApplicationName;
    ANSI_STRING VariableName;
    UNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableNameU;
    BOOLEAN MultiValueStrings;
    union {
        //
        // This structure filled in for write operations
        //
        struct {
            LPSTR ValueBuffer;
            ULONG ValueLength;
            PWSTR ValueBufferU;
            ULONG ValueLengthU;
        };
        //
        // This structure filled in for read operations
        //
        struct {
            ULONG ResultChars;
            ULONG ResultMaxChars;
            LPSTR ResultBuffer;
            PWSTR ResultBufferU;
        };
    };


    //
    // Remaining fields only valid when parsing an on disk .INI file mapped into
    // memory.
    //

    PVOID TextCurrent;
    PVOID TextStart;
    PVOID TextEnd;

    ANSI_STRING SectionName;
    ANSI_STRING KeywordName;
    ANSI_STRING KeywordValue;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PANSI_STRING AnsiKeywordValue;
    UNICODE_STRING SectionNameU;
    UNICODE_STRING KeywordNameU;
    UNICODE_STRING KeywordValueU;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PUNICODE_STRING UnicodeKeywordValue;
} INIFILE_PARAMETERS, *PINIFILE_PARAMETERS;


ULONG BaseIniFileUpdateCount = 0;


#if DBG
BOOLEAN BaseDllDumpIniCalls;

char *xOperationNames[] = {
    "FlushProfiles",
    "ReadKeyValue",
    "WriteKeyValue",
    "DeleteKey",
    "ReadKeyNames",
    "ReadSectionNames",
    "ReadSection",
    "WriteSection",
    "DeleteSection",
    "RefreshIniFileMapping"
};
#endif

ULONG
BaseDllIniFileNameLength(
                        IN BOOLEAN Unicode,
                        IN PVOID *Name
                        )
{
    if (Unicode) {
        PWSTR p;

        p = *Name;
        while (*p == L' ') {
            p++;
        }
        *Name = p;
        while (*p != UNICODE_NULL) {
            p++;
        }

        if (p > (PWSTR)*Name) {
            while (*--p == L' ') {
            }
            p++;
        }

        return (ULONG)(p - (PWSTR)*Name);
    } else {
        PCH p;

        p = *Name;
        while (*p == ' ') {
            p++;
        }
        *Name = p;
        while (*p != '\0') {
            p++;
        }

        if (p > (PCH)*Name) {
            while (*--p == ' ') {
            }
            p++;
        }

        return (ULONG)(p - (PCH)*Name);
    }
}


NTSTATUS
BaseDllCaptureIniFileParameters(
                               BOOLEAN Unicode,
                               INIFILE_OPERATION Operation,
                               BOOLEAN WriteOperation,
                               BOOLEAN MultiValueStrings,
                               PVOID FileName OPTIONAL,
                               PVOID ApplicationName OPTIONAL,
                               PVOID VariableName OPTIONAL,
                               PVOID VariableValue OPTIONAL,
                               PULONG ResultMaxChars OPTIONAL,
                               PINIFILE_PARAMETERS *ReturnedParameterBlock
                               )
{
    NTSTATUS Status;
    PBYTE s;
    PWSTR p, p1;
    ULONG TotalSize,
    CharSize,
    NtFileNameLength,
    FileNameLength,
    ApplicationNameLength,
    VariableNameLength,
    VariableValueLength;
    ANSI_STRING AnsiString;
    PINIFILE_PARAMETERS a;

    if (ARGUMENT_PRESENT( FileName )) {
        if (Unicode) {
            FileNameLength = wcslen( FileName );
        } else {
            FileNameLength = strlen( FileName );
        }
    } else {
        FileNameLength = 0;
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        ApplicationNameLength = BaseDllIniFileNameLength( Unicode, &ApplicationName );
    } else {
        ApplicationNameLength = 0;
        VariableName = NULL;
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        VariableNameLength = BaseDllIniFileNameLength( Unicode, &VariableName );
    } else {
        VariableNameLength = 0;
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (ARGUMENT_PRESENT( ResultMaxChars )) {
            VariableValueLength = 0;
        } else {
            if (!MultiValueStrings) {
                if (Unicode) {
                    VariableValueLength = wcslen( VariableValue );
                } else {
                    VariableValueLength = strlen( VariableValue );
                }
            } else {
                if (Unicode) {
                    p = (PWSTR)VariableValue;
                    while (*p) {
                        while (*p++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(p - (PWSTR)VariableValue);
                } else {
                    s = (PBYTE)VariableValue;
                    while (*s) {
                        while (*s++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(s - (PBYTE)VariableValue);
                }
            }
        }
    } else {
        VariableValueLength = 0;
    }

    NtFileNameLength = xxx_RtlGetLongestNtPathLength() * sizeof( WCHAR );

    TotalSize = sizeof( *a ) + NtFileNameLength;
    if (!Unicode) {
        TotalSize += (FileNameLength + 1 ) * sizeof( WCHAR );
    }

    // We have to allocate enough buffer for DBCS string.
    CharSize = (Unicode ? sizeof(WORD) : sizeof( WCHAR ));
    TotalSize += (ApplicationNameLength + 1 +
                  VariableNameLength + 1 +
                  VariableValueLength + 1
                 ) * CharSize;
    a = AllocateKernelPool( TotalSize );
    if (a == NULL) {
        KdPrint(( "BASE: Unable to allocate IniFile parameter buffer of %u bytes\n", TotalSize ));
        return STATUS_NO_MEMORY;
    }

    a->Operation = Operation;
    a->WriteOperation = WriteOperation;
    a->Unicode = Unicode;
    a->IniFile = NULL;
    a->ValueBufferAllocated = FALSE;
    a->MultiValueStrings = MultiValueStrings;

    p = (PWSTR)(a + 1);
    a->NtFileName.Buffer = p;
    a->NtFileName.Length = 0;
    a->NtFileName.MaximumLength = (USHORT)NtFileNameLength;
    p = (PWSTR)((PCHAR)p + NtFileNameLength);

    if (ARGUMENT_PRESENT( FileName )) {
        a->FileName.MaximumLength = (USHORT)((FileNameLength + 1) * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->FileName.Length = (USHORT)(FileNameLength * sizeof( WCHAR ));
            a->FileName.Buffer = FileName;
        } else {
            AnsiString.Buffer = FileName;
            AnsiString.Length = (USHORT)FileNameLength;
            AnsiString.MaximumLength = (USHORT)(AnsiString.Length + 1);
            a->FileName.Buffer = p;
            a->FileName.Length = 0;
            p += FileNameLength + 1;
            Status = RtlAnsiStringToUnicodeString( &a->FileName, &AnsiString, FALSE );
            if (!NT_SUCCESS( Status )) {
                FreeKernelPool( a );
                return Status;
            }
        }

    } else {
        RtlInitUnicodeString( &a->FileName, L"testini.ini" );
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        // We have to keep enough buffer for DBCS string.
        a->ApplicationName.MaximumLength = (USHORT)((ApplicationNameLength * sizeof(WORD)) + 1);
        a->ApplicationNameU.MaximumLength = (USHORT)(a->ApplicationName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->ApplicationNameU.Buffer = ApplicationName;
            a->ApplicationNameU.Length = (USHORT)(ApplicationNameLength * sizeof( UNICODE_NULL ));
            a->ApplicationName.Buffer = (PBYTE)p;
            a->ApplicationName.Length = 0;
            p = (PWSTR)((PCHAR)p + (ApplicationNameLength * sizeof(WORD)) + 1);
        } else {
            a->ApplicationName.Buffer = ApplicationName;
            a->ApplicationName.Length = (USHORT)ApplicationNameLength;
            a->ApplicationNameU.Buffer = p;
            a->ApplicationNameU.Length = 0;
            p += ApplicationNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->ApplicationName, NULL );
        RtlInitUnicodeString( &a->ApplicationNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        // We have to keep enough buffer for DBCS string.
        a->VariableName.MaximumLength = (USHORT)((VariableNameLength *sizeof(WORD)) + 1);
        a->VariableNameU.MaximumLength = (USHORT)(a->VariableName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->VariableNameU.Buffer = VariableName;
            a->VariableNameU.Length = (USHORT)(VariableNameLength * sizeof( UNICODE_NULL ));
            a->VariableName.Buffer = (PBYTE)p;
            a->VariableName.Length = 0;
            p = (PWSTR)((PCHAR)p + (VariableNameLength * sizeof(WORD)) + 1);
        } else {
            a->VariableName.Buffer = VariableName;
            a->VariableName.Length = (USHORT)VariableNameLength;
            a->VariableNameU.Buffer = p;
            a->VariableNameU.Length = 0;
            p += VariableNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->VariableName, NULL );
        RtlInitUnicodeString( &a->VariableNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->WriteOperation) {
            if (Unicode) {
                a->ValueBufferU = VariableValue;
                a->ValueLengthU = VariableValueLength * sizeof( WCHAR );
                *(PBYTE)p = '\0';
                a->ValueBuffer = (PBYTE)p;
                a->ValueLength = 0;
            } else {
                a->ValueBuffer = VariableValue;
                a->ValueLength = VariableValueLength;
                *p = UNICODE_NULL;
                a->ValueBufferU = p;
                a->ValueLengthU = 0;
            }
        } else {
            if (ARGUMENT_PRESENT( ResultMaxChars )) {
                a->ResultMaxChars = *ResultMaxChars;
            } else {
                a->ResultMaxChars = 0;
            }
            a->ResultChars = 0;
            if (Unicode) {
                a->ResultBufferU = VariableValue;
                a->ResultBuffer = NULL;
            } else {
                a->ResultBuffer = VariableValue;
                a->ResultBufferU = NULL;
            }
        }
    } else {
        if (a->WriteOperation) {
            a->ValueBuffer = NULL;
            a->ValueLength = 0;
            a->ValueBufferU = NULL;
            a->ValueLengthU = 0;
        } else {
            a->ResultMaxChars = 0;
            a->ResultChars = 0;
            a->ResultBufferU = NULL;
            a->ResultBuffer = NULL;
        }
    }

    *ReturnedParameterBlock = a;
    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllAppendBufferToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PBYTE Buffer OPTIONAL,
                                 IN PWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOLEAN IncludeNull
                                 )
{
    NTSTATUS Status, OverflowStatus;
    ULONG Index;

    OverflowStatus = STATUS_SUCCESS;
    if (ARGUMENT_PRESENT( Buffer )) {
        if (ARGUMENT_PRESENT( BufferU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            ULONG CharsMbcs = Chars;
            //
            // In this point, Chars does not contains proper value for Unicode.
            // because. Chars was computed based on DBCS string length,
            // This is correct, sources string is DBCS, then
            // if the source is not DBCS. we just adjust it here.
            //
            if (a->Unicode) {
                Status = RtlMultiByteToUnicodeSize(&Chars,Buffer,Chars);
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: AnsiToUnicodeSize of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                    return Status;
                }
                Chars /= sizeof(WCHAR);
            }
            if (a->ResultChars + Chars >= a->ResultMaxChars) {
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = a->ResultMaxChars - a->ResultChars;
                if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars) {
                if (a->Unicode) {
                    Status = RtlMultiByteToUnicodeN( a->ResultBufferU + a->ResultChars,
                                                     Chars * sizeof( WCHAR ),
                                                     &Index,
                                                     Buffer,
                                                     CharsMbcs
                                                   );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                        return Status;
                    }
                } else {
                    memcpy( a->ResultBuffer + a->ResultChars, Buffer, Chars );
                }

                a->ResultChars += Chars;
            }
        }
    } else if (ARGUMENT_PRESENT( BufferU )) {
        ULONG CharsUnicode = Chars;
        //
        // In this point, Chars does not contains proper value for DBCS.
        // because. Chars was computed by just devide Unicode string length
        // by two. This is correct, sources string is Unicode, then
        // if the source is not Unicode. we just adjust it here.
        //
        if (!(a->Unicode)) {
            Status = RtlUnicodeToMultiByteSize(&Chars,BufferU,Chars * sizeof(WCHAR));
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsiSize of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                return Status;
            }
        }
        if (a->ResultChars + Chars >= a->ResultMaxChars) {
            OverflowStatus = STATUS_BUFFER_OVERFLOW;
            Chars = a->ResultMaxChars - a->ResultChars;
            if (Chars) {
                Chars -= 1;
            }
        }

        if (Chars) {
            if (a->Unicode) {
                memcpy( a->ResultBufferU + a->ResultChars, BufferU, Chars * sizeof( WCHAR ) );
            } else {
                Status = RtlUnicodeToMultiByteN( a->ResultBuffer + a->ResultChars,
                                                 Chars,
                                                 &Index,
                                                 BufferU,
                                                 CharsUnicode * sizeof( WCHAR )
                                               );
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                    return Status;
                }
            }

            a->ResultChars += Chars;
        }
    }

    if (IncludeNull) {
        if (a->ResultChars + 1 >= a->ResultMaxChars) {
            return STATUS_BUFFER_OVERFLOW;
        }

        if (a->Unicode) {
            a->ResultBufferU[ a->ResultChars ] = UNICODE_NULL;
        } else {
            a->ResultBuffer[ a->ResultChars ] = '\0';
        }

        a->ResultChars += 1;
    }

    return OverflowStatus;
}


NTSTATUS
BaseDllAppendNullToResultBuffer(
                               IN PINIFILE_PARAMETERS a
                               )
{
    return BaseDllAppendBufferToResultBuffer( a,
                                              NULL,
                                              NULL,
                                              0,
                                              TRUE
                                            );
}


NTSTATUS
BaseDllOpenIniFileOnDisk(
                        IN PINIFILE_PARAMETERS a
                        )
{
    NTSTATUS Status;
    PINIFILE_CACHE IniFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset, Length;
    OBJECT_STRING ObjectString;
    OCHAR ObjectBuffer[MAX_PATH];

    if ( a->FileName.Length > sizeof(WCHAR) && a->FileName.Buffer[0] == L'\\' ) {
        //
        // If FileName begin with backslash, this is NT-style path
        //
        a->NtFileName.Length = 0;
    } else {
        //
        // Convert to DOS-style path
        //
        wcscpy( a->NtFileName.Buffer, L"\\??\\t:\\" );
        if ( a->FileName.Length > sizeof(WCHAR) && a->FileName.Buffer[1] == L':' ) {
            a->NtFileName.Length = 8;
        } else {
            a->NtFileName.Length = 14;
        }
    }

    Status = RtlAppendUnicodeStringToString( &a->NtFileName, &a->FileName );

    IniFile = NULL;
    if (NT_SUCCESS( Status )) {
        IniFile = AllocateKernelPool( sizeof( *IniFile ) + a->NtFileName.MaximumLength );
        if (IniFile == NULL) {
            return STATUS_NO_MEMORY;
        }
        IniFile->NtFileName.Buffer = (PWSTR)(IniFile + 1);
        IniFile->NtFileName.MaximumLength = a->NtFileName.MaximumLength;
        RtlCopyUnicodeString( &IniFile->NtFileName, &a->NtFileName );
        IniFile->WriteAccess = a->WriteOperation;

        ObjectString.Buffer = ObjectBuffer;
        ObjectString.Length = 0;
        ObjectString.MaximumLength = sizeof(ObjectBuffer);
        RtlUnicodeStringToAnsiString( &ObjectString, &IniFile->NtFileName, FALSE );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &ObjectString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                  );
        if (IniFile->WriteAccess) {
            Status = NtCreateFile( &IniFile->FileHandle,
                                   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                   &ObjectAttributes,
                                   &IoStatusBlock,
                                   0,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                   FILE_OPEN_IF,
                                   FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                                 );
        } else {
            Status = NtOpenFile( &IniFile->FileHandle,
                                 SYNCHRONIZE | GENERIC_READ,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_SYNCHRONOUS_IO_NONALERT |
                                 FILE_NON_DIRECTORY_FILE
                               );
        }

#if DBG
        if (!NT_SUCCESS( Status )) {
            if (BaseDllDumpIniCalls) {
                KdPrint(( "BASEDLL: Unable to open %wZ - Status == %x\n", &a->NtFileName, Status ));
            }
        }
#endif // DBG
    }

    if (NT_SUCCESS( Status )) {
        IniFile->LockedFile = FALSE;
        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;

        if (NT_SUCCESS( Status )) {
            Status = NtQueryInformationFile( IniFile->FileHandle,
                                             &IoStatusBlock,
                                             &IniFile->NetworkInformation,
                                             sizeof( IniFile->NetworkInformation ),
                                             FileNetworkOpenInformation
                                           );
            if (Status == STATUS_BUFFER_OVERFLOW) {
                Status = STATUS_SUCCESS;
            } else if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: Unable to QueryInformation for %wZ - Status == %x\n", &a->NtFileName, Status ));
            }

            if ( NT_SUCCESS(Status) && IniFile->NetworkInformation.EndOfFile.HighPart != 0 ) {
                Status = STATUS_SECTION_TOO_BIG;
            }
        }
    }

    if (!NT_SUCCESS( Status )) {
#if DBG
        if (BaseDllDumpIniCalls) {
            KdPrint(( "BASEDLL: Open of %wZ failed - Status == %x\n",
                      &IniFile->NtFileName,
                      Status
                    ));
        }
#endif // DBG

        if (IniFile != NULL) {

            NtClose( IniFile->FileHandle );
            FreeKernelPool( IniFile );
        }

        return Status;
    }

    ASSERT( IniFile->NetworkInformation.EndOfFile.HighPart == 0 );
    IniFile->EndOfFile = IniFile->NetworkInformation.EndOfFile.LowPart;
    IniFile->CommitSize = IniFile->EndOfFile + (4 * (IniFile->UnicodeFile ? sizeof( WCHAR ) : 1));
    IniFile->RegionSize = IniFile->CommitSize + 0x100000; // Room for 256KB of growth
    Status = NtAllocateVirtualMemory( &IniFile->BaseAddress,
                                      0,
                                      &IniFile->RegionSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( &IniFile->BaseAddress,
                                          0,
                                          &IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            Status = NtReadFile( IniFile->FileHandle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 IniFile->BaseAddress,
                                 IniFile->EndOfFile,
                                 NULL
                               );
            if (NT_SUCCESS( Status ) && IoStatusBlock.Information != IniFile->EndOfFile) {
                Status = STATUS_END_OF_FILE;
            }
        }
    }

    if (NT_SUCCESS( Status )) {
        IniFile->UpdateOffset = 0xFFFFFFFF;
        IniFile->UpdateEndOffset = 0;

        IniFile->UnicodeFile = xxx_RtlIsTextUnicode( IniFile->BaseAddress, IniFile->EndOfFile, 0 );

        if (IniFile->UnicodeFile) {
            PWSTR Src;

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PWSTR)IniFile->BaseAddress && Src[ -1 ] <= L' ') {
                if (Src[-1] == L'\r' || Src[-1] == L'\n') {
                    break;
                }

                IniFile->EndOfFile -= sizeof( WCHAR );
                Src -= 1;
            }

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PWSTR)IniFile->BaseAddress) {
                if (Src[-1] != L'\n') {
                    *Src++ = L'\r';
                    *Src++ = L'\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2 * sizeof( WCHAR );
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        } else {
            PBYTE Src;

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PBYTE)IniFile->BaseAddress && Src[ -1 ] <= ' ') {
                if (Src[-1] == '\r' || Src[-1] == '\n') {
                    break;
                }

                IniFile->EndOfFile -= 1;
                Src -= 1;
            }

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PBYTE)IniFile->BaseAddress) {
                if (Src[-1] != '\n') {
                    *Src++ = '\r';
                    *Src++ = '\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2;
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        }

        a->IniFile = IniFile;
    } else {
        KdPrint(( "BASEDLL: Read of %wZ failed - Status == %x\n",
                  &IniFile->NtFileName,
                  Status
                ));

        NtClose( IniFile->FileHandle );

        FreeKernelPool( IniFile );
    }

    return Status;
}


#define STOP_AT_SECTION 1
#define STOP_AT_KEYWORD 2
#define STOP_AT_NONSECTION 3


NTSTATUS
BaseDllAdvanceTextPointer(
                         IN PINIFILE_PARAMETERS a,
                         IN ULONG StopAt
                         )
{
    BOOLEAN AllowNoEquals;

    if (StopAt == STOP_AT_NONSECTION) {
        StopAt = STOP_AT_KEYWORD;
        AllowNoEquals = TRUE;
    } else {
        AllowNoEquals = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, EndOfLine, EqualSign, EndOfFile;
        PWSTR Name, EndOfName, Value, EndOfValue;

#define INI_TEXT(quote) L##quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine && *EndOfName != INI_TEXT(']')) {
                        EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionNameU.Buffer = Name;
                    a->SectionNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionNameU.MaximumLength = a->SectionNameU.Length;
                    a->AnsiSectionName = NULL;
                    a->UnicodeSectionName = &a->SectionNameU;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL) ) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordNameU.Buffer = Name;
                        a->KeywordNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordNameU.MaximumLength = a->KeywordNameU.Length;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = &a->KeywordNameU;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValueU.Buffer = Value;
                    a->KeywordValueU.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValueU.MaximumLength = a->KeywordValueU.Length;
                    a->AnsiKeywordValue = NULL;
                    a->UnicodeKeywordValue = &a->KeywordValueU;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    } else {
        PBYTE Src, EndOfLine, EqualSign, EndOfFile;
        PBYTE Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine) {
                        if (*EndOfName == INI_TEXT(']')) {
                            break;
                        }
                        //if (IsDBCSLeadByte(*EndOfName)) {
                            //EndOfName++;
                        //}
                        EndOfName++;
                    }
                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionName.Buffer = Name;
                    a->SectionName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionName.MaximumLength = a->SectionName.Length;
                    a->AnsiSectionName = &a->SectionName;
                    a->UnicodeSectionName = NULL;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL)) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordName.Buffer = Name;
                        a->KeywordName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordName.MaximumLength = a->KeywordName.Length;
                        a->AnsiKeywordName = &a->KeywordName;
                        a->UnicodeKeywordName = NULL;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValue.Buffer = Value;
                    a->KeywordValue.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValue.MaximumLength = a->KeywordValue.Length;
                    a->AnsiKeywordValue = &a->KeywordValue;
                    a->UnicodeKeywordValue = NULL;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }

    return STATUS_NO_MORE_ENTRIES;
}


NTSTATUS
BaseDllAppendStringToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOLEAN IncludeNull
                                 )
{
    if (ARGUMENT_PRESENT( String )) {
        if (ARGUMENT_PRESENT( StringU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            return BaseDllAppendBufferToResultBuffer( a,
                                                      String->Buffer,
                                                      NULL,
                                                      String->Length,
                                                      IncludeNull
                                                    );
        }
    } else if (ARGUMENT_PRESENT( StringU )) {
        return BaseDllAppendBufferToResultBuffer( a,
                                                  NULL,
                                                  StringU->Buffer,
                                                  StringU->Length / sizeof( WCHAR ),
                                                  IncludeNull
                                                );
    } else {
        return STATUS_INVALID_PARAMETER;
    }
}


NTSTATUS
BaseDllReadSectionNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiSectionName,
                                                        a->UnicodeSectionName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


BOOLEAN
BaseDllGetApplicationName(
                         IN PINIFILE_PARAMETERS a,
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( ApplicationName )) {
        if (a->ApplicationName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->ApplicationName, &a->ApplicationNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->ApplicationNameU, Status ));
                return FALSE;
            }
        }

        *ApplicationName = &a->ApplicationName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( ApplicationNameU )) {
        if (a->ApplicationNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->ApplicationNameU, &a->ApplicationName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->ApplicationName, Status ));
                return FALSE;

            }
        }
        *ApplicationNameU = &a->ApplicationNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableName(
                      IN PINIFILE_PARAMETERS a,
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( VariableName )) {
        if (a->VariableName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->VariableName, &a->VariableNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->VariableNameU, Status ));
                return FALSE;
            }
        }

        *VariableName = &a->VariableName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableNameU )) {
        if (a->VariableNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->VariableNameU, &a->VariableName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->VariableName, Status ));
                return FALSE;

            }
        }
        *VariableNameU = &a->VariableNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableValue(
                       IN PINIFILE_PARAMETERS a,
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT PWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status;
    ULONG Index;

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->ValueLength == 0) {
            if (a->ValueBufferU == NULL || a->ValueLengthU == 0) {
                *VariableValue = "";
                *VariableValueLength = 1;
                return TRUE;
            }

            a->ValueLength = a->ValueLengthU;
            Status = RtlUnicodeToMultiByteN( a->ValueBuffer,
                                             a->ValueLength,
                                             &Index,
                                             a->ValueBufferU,
                                             a->ValueLengthU
                                           );

            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n",
                          a->ValueLengthU / sizeof( WCHAR ), a->ValueBufferU, Status
                        ));
                return FALSE;
            }

            // Set real converted size
            a->ValueLength = Index;
            a->ValueBuffer[ Index ] = '\0';       // Null terminate converted value
        } else {
            Index = a->ValueLength;
        }

        *VariableValue = a->ValueBuffer;
        *VariableValueLength = Index + 1;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableValueU )) {
        if (a->ValueLengthU == 0) {
            if (a->ValueBuffer == NULL || a->ValueLength == 0) {
                *VariableValueU = L"";
                *VariableValueLength = sizeof( UNICODE_NULL );
                return TRUE;
            }

            a->ValueLengthU = a->ValueLength * sizeof( WCHAR );
            Status = RtlMultiByteToUnicodeN( a->ValueBufferU,
                                             a->ValueLengthU,
                                             &Index,
                                             a->ValueBuffer,
                                             a->ValueLength
                                           );


            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n",
                          a->ValueLength, a->ValueBuffer, Status
                        ));
                return FALSE;
            }

            Index = Index / sizeof( WCHAR );
            a->ValueBufferU[ Index ] = UNICODE_NULL;    // Null terminate converted value
        } else {
            Index = a->ValueLengthU / sizeof( WCHAR );
        }

        *VariableValueU = a->ValueBufferU;
        *VariableValueLength = (Index + 1) * sizeof( WCHAR );
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
BaseDllFindSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    BOOL FreeUnicodeBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeUnicodeBuffer = FALSE;
            if (a->AnsiSectionName) {
                // Ansi ini file
                if (a->Unicode) {
                    // Unicode parm - convert the ansi sectio name to unicode
                    if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    a->UnicodeSectionName = &a->SectionNameU;
                    Status = RtlAnsiStringToUnicodeString( a->UnicodeSectionName,
                                                           a->AnsiSectionName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", a->AnsiSectionName, Status ));
                        return Status;
                    }

                    FreeUnicodeBuffer = TRUE;
                } else {
                    // Ansi parm
                    if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            } else {
                // Doesn't matter - Unicode ini, get the Unicode section name.
                if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            if (a->AnsiSectionName == NULL || a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeSectionName,
                                           a->UnicodeSectionName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiSectionName, a->AnsiSectionName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeUnicodeBuffer) {
                RtlFreeUnicodeString( a->UnicodeSectionName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS
BaseDllFindKeyword(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeKeywordName;
    BOOL FreeUnicodeBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeUnicodeBuffer = FALSE;

            // Here's the deal.  We want to compare Unicode if possible.  If the
            // The ini is Ansi and the input parm is ansi, use ansi.  Otherwise
            // use Unicode for everything.

            if (a->AnsiKeywordName) {
                // Ansi ini file.
                if (a->Unicode) {
                    // Unicode parm - convert the ansi ini keyword to unicode.
                    if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    a->UnicodeKeywordName = &a->KeywordNameU;
                    Status = RtlAnsiStringToUnicodeString( a->UnicodeKeywordName,
                                                           a->AnsiKeywordName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", a->AnsiKeywordName, Status ));
                        return Status;
                    }

                    FreeUnicodeBuffer = TRUE;
                } else {
                    // Ansi param
                    if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            } else {
                // Doesn't matter - Unicode ini, get the Unicode parm.
                if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            if (a->AnsiKeywordName == NULL || a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeKeywordName,
                                           a->UnicodeKeywordName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiKeywordName, a->AnsiKeywordName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeUnicodeBuffer) {
                RtlFreeUnicodeString( a->UnicodeKeywordName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}


NTSTATUS
BaseDllReadKeywordValue(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = BaseDllFindKeyword( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src;

        Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
        while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
            Src += 1;
            a->UnicodeKeywordValue->Buffer = Src;
            a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
            a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
        }

        if (a->UnicodeKeywordValue->Length >= (2 * sizeof( WCHAR )) &&
            (Src[ 0 ] == Src[ (a->UnicodeKeywordValue->Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            a->UnicodeKeywordValue->Buffer += 1;
            a->UnicodeKeywordValue->Length -= (2 * sizeof( WCHAR ));
            a->UnicodeKeywordValue->MaximumLength -= (2 * sizeof( WCHAR ));
        }
    } else {
        PBYTE Src;

        Src = (PBYTE)a->AnsiKeywordValue->Buffer;
        while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
            Src += 1;
            a->AnsiKeywordValue->Buffer = Src;
            a->AnsiKeywordValue->Length -= sizeof( UCHAR );
            a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
        }

        if (a->AnsiKeywordValue->Length >= (2 * sizeof( UCHAR )) &&
            (Src[ 0 ] == Src[ (a->AnsiKeywordValue->Length - sizeof( UCHAR )) / sizeof( UCHAR ) ]) &&
            (Src[ 0 ] == '"' || Src[ 0 ] == '\'')
           ) {
            a->AnsiKeywordValue->Buffer += 1;
            a->AnsiKeywordValue->Length -= (2 * sizeof( UCHAR ));
            a->AnsiKeywordValue->MaximumLength -= (2 * sizeof( UCHAR ));
        }
    }

    return BaseDllAppendStringToResultBuffer( a,
                                              a->AnsiKeywordValue,
                                              a->UnicodeKeywordValue,
                                              TRUE
                                            );
}


NTSTATUS
BaseDllReadKeywordNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordName,
                                                        a->UnicodeKeywordName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllReadSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_NONSECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            if (a->AnsiKeywordName || a->UnicodeKeywordName) {
                Status = BaseDllAppendStringToResultBuffer( a,
                                                            a->AnsiKeywordName,
                                                            a->UnicodeKeywordName,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }

                Status = BaseDllAppendBufferToResultBuffer( a,
                                                            a->Unicode ? NULL : "=",
                                                            a->Unicode ? L"=" : NULL,
                                                            1,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            if (a->IniFile->UnicodeFile) {
                PWSTR Src;

                Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
                while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
                    Src += 1;
                    a->UnicodeKeywordValue->Buffer = Src;
                    a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
                    a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
                }
            } else {
                PBYTE Src;

                Src = (PBYTE)a->AnsiKeywordValue->Buffer;
                while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
                    Src += 1;
                    a->AnsiKeywordValue->Buffer = Src;
                    a->AnsiKeywordValue->Length -= sizeof( UCHAR );
                    a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
                }
            }

            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordValue,
                                                        a->UnicodeKeywordValue,
                                                        TRUE
                                                      );
            if (!NT_SUCCESS( Status )) {
                return Status;
            }
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllCalculateDeleteLength(
                            IN PINIFILE_PARAMETERS a
                            )
{
    ULONG DeleteLength;

    if (a->IniFile->UnicodeFile) {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               (PCHAR)a->UnicodeKeywordName->Buffer);
    } else {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               a->AnsiKeywordName->Buffer);
    }

    return DeleteLength;
}


NTSTATUS
BaseDllModifyMappedFile(
                       IN PINIFILE_PARAMETERS a,
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       )
{
    NTSTATUS Status;
    ULONG NewEndOfFile, UpdateOffset, UpdateLength;

    NewEndOfFile = a->IniFile->EndOfFile - SizeToRemove + InsertAmount;
    if (NewEndOfFile > a->IniFile->CommitSize) {
        if (NewEndOfFile > a->IniFile->RegionSize) {
            return STATUS_BUFFER_OVERFLOW;
        }

        a->IniFile->CommitSize = NewEndOfFile;
        Status = NtAllocateVirtualMemory( &a->IniFile->BaseAddress,
                                          0,
                                          &a->IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASEDLL: Unable to allocate memory to grow %wZ - Status == %x\n",
                      &a->IniFile->NtFileName,
                      Status
                    ));

            return Status;
        }

        a->IniFile->EndOfFile = NewEndOfFile;
    }

    UpdateOffset = (ULONG)((PCHAR)AddressInFile - (PCHAR)(a->IniFile->BaseAddress)),
                   UpdateLength = (ULONG)((PCHAR)a->TextEnd - (PCHAR)AddressInFile) + InsertAmount - SizeToRemove;
    //
    // Are we deleting more than we are inserting?
    //
    if (SizeToRemove > InsertAmount) {
        //
        // Yes copy over insert string.
        //
        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );

        //
        // Delete remaining text after insertion string by moving it
        // up
        //

        RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount,
                       (PCHAR)AddressInFile + SizeToRemove,
                       UpdateLength - InsertAmount
                     );
    } else
        if (InsertAmount > 0) {
        //
        // Are we deleting less than we are inserting?
        //
        if (SizeToRemove < InsertAmount) {
            //
            // Move text down to make room for insertion
            //

            RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount - SizeToRemove,
                           (PCHAR)AddressInFile,
                           UpdateLength - InsertAmount + SizeToRemove
                         );
        } else {
            //
            // Deleting and inserting same amount, update just that text as
            // no shifting was done.
            //

            UpdateLength = InsertAmount;
        }

        //
        // Copy over insert string
        //

        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );
    } else {
        //
        // Nothing to change, as InsertAmount and SizeToRemove are zero
        //
        return STATUS_SUCCESS;
    }

    if (a->IniFile->EndOfFile != NewEndOfFile) {
        a->IniFile->EndOfFile = NewEndOfFile;
    }

    if (UpdateOffset < a->IniFile->UpdateOffset) {
        a->IniFile->UpdateOffset = UpdateOffset;
    }

    if ((UpdateOffset + UpdateLength) > a->IniFile->UpdateEndOffset) {
        a->IniFile->UpdateEndOffset = UpdateOffset + UpdateLength;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllWriteKeywordValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    BOOLEAN InsertKeywordName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PBYTE AnsiKeywordValue;
    PWSTR UnicodeKeywordValue;
    ULONG ValueLength;
    ULONG DeleteLength;
    PVOID AddressInFile = NULL;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
    } else {
        InsertSectionName = FALSE;
        Status = BaseDllFindKeyword( a );
    }

    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        if (!InsertSectionName) {
            AddressInFile = a->TextCurrent;
        }

        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeKeywordName->Length;
        } else {
            if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiKeywordName->Length;
        }

        InsertKeywordName = TRUE;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->UnicodeKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->UnicodeKeywordValue->Buffer;
            }
        } else {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->AnsiKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->AnsiKeywordValue->Buffer;
            }
        }
        InsertKeywordName = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( WCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->UnicodeKeywordValue->Buffer,
                                            a->UnicodeKeywordValue->Length,
                                            UnicodeKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    } else {
        if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( UCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->AnsiKeywordValue->Buffer,
                                            a->AnsiKeywordValue->Length,
                                            AnsiKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }

    InsertBuffer = AllocateKernelPool( InsertAmount + sizeof(UNICODE_NULL) );
    if (InsertBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = L'[';
            Src = UnicodeSectionName->Buffer;
            n = UnicodeSectionName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L']';
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }

        if (InsertKeywordName) {
            Src = UnicodeKeywordName->Buffer;
            n = UnicodeKeywordName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L'=';
        }

        Src = UnicodeKeywordValue;
        n = ValueLength / sizeof( WCHAR );
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }
    } else {
        PBYTE Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = '[';
            Src = AnsiSectionName->Buffer;
            n = AnsiSectionName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = ']';
            *Dst++ = '\r';
            *Dst++ = '\n';
        }

        if (InsertKeywordName) {
            Src = AnsiKeywordName->Buffer;
            n = AnsiKeywordName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = '=';
        }

        Src = AnsiKeywordValue;
        n = ValueLength;
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = '\r';
            *Dst++ = '\n';
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      0,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    FreeKernelPool( InsertBuffer );
    return Status;
}


NTSTATUS
BaseDllWriteSection(
                   IN PINIFILE_PARAMETERS a
                   )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    PBYTE AnsiKeywordValue, s;
    PWSTR UnicodeKeywordValue, w;
    ULONG ValueLength, SizeToRemove = 0;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteSection) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
        SizeToRemove = 0;
    } else {
        if (a->Operation == DeleteSection) {
            AddressInFile = a->TextStart;
        } else {
            AddressInFile = a->TextCurrent;
        }
        while (TRUE) {
            //
            // For delete operations need to iterate all lines in section,
            // not just those that have an = on them. Otherwise sections like
            // [foo]
            // a
            // b = c
            // d
            //
            // don't get deleted properly.
            //
            Status = BaseDllAdvanceTextPointer(
                                              a,
                                              (a->Operation == DeleteSection) ? STOP_AT_NONSECTION : STOP_AT_KEYWORD
                                              );

            if (Status == STATUS_MORE_ENTRIES) {
            } else
                if (Status == STATUS_NO_MORE_ENTRIES) {
                SizeToRemove = (ULONG)((PCHAR)a->TextCurrent - (PCHAR)AddressInFile);
                break;
            } else {
                return Status;
            }
        }

        InsertSectionName = FALSE;
    }

    if (a->Operation == DeleteSection) {
        InsertBuffer = NULL;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( WCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            w = UnicodeKeywordValue;
            InsertAmount += ValueLength;
            while (*w) {
                while (*w++) {
                }
                InsertAmount += (2-1) * sizeof( WCHAR );    // Subtract out NULL byte already in ValueLength
            }
        } else {
            if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( UCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            s = AnsiKeywordValue;
            InsertAmount += ValueLength;
            while (*s) {
                while (*s++) {
                }
                InsertAmount += 2 - 1;      // Subtract out NULL byte already in ValueLength
            }
        }

        InsertBuffer = AllocateKernelPool( InsertAmount + sizeof(UNICODE_NULL) );
        if (InsertBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        if (a->IniFile->UnicodeFile) {
            PWSTR Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = L'[';
                Src = UnicodeSectionName->Buffer;
                n = UnicodeSectionName->Length / sizeof( WCHAR );
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = L']';
                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }

            Src = UnicodeKeywordValue;
            while (*Src) {
                while ( 0 != (*Dst = *Src++) ) {
                    Dst += 1;
                }

                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }
        } else {
            PBYTE Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = '[';
                Src = AnsiSectionName->Buffer;
                n = AnsiSectionName->Length;
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = ']';
                *Dst++ = '\r';
                *Dst++ = '\n';
            }

            Src = AnsiKeywordValue;
            while (*Src) {
                while ( 0 != (*Dst = *Src++) ) {
                    Dst += 1;
                }

                *Dst++ = '\r';
                *Dst++ = '\n';
            }
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      SizeToRemove,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    FreeKernelPool( InsertBuffer );
    return Status;
}


NTSTATUS
BaseDllCloseIniFileOnDisk(
                         IN PINIFILE_PARAMETERS a
                         )
{
    PINIFILE_CACHE IniFile;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG UpdateLength;
    LARGE_INTEGER ByteOffset, Length;

    Status = STATUS_SUCCESS;
    IniFile = a->IniFile;
    if (IniFile != NULL) {
        if (IniFile->BaseAddress != NULL) {
            if (IniFile->UpdateOffset != 0xFFFFFFFF && IniFile->WriteAccess) {
                ByteOffset.HighPart = 0;
                ByteOffset.LowPart = IniFile->UpdateOffset;
                UpdateLength = IniFile->UpdateEndOffset - IniFile->UpdateOffset;
                Status = NtWriteFile( IniFile->FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      (PCHAR)(IniFile->BaseAddress) + IniFile->UpdateOffset,
                                      UpdateLength,
                                      &ByteOffset
                                    );
                if (NT_SUCCESS( Status )) {
                    if (IoStatusBlock.Information != UpdateLength) {
                        Status = STATUS_DISK_FULL;
                    } else {
                        Length.QuadPart = IniFile->EndOfFile;
                        Status = NtSetInformationFile( IniFile->FileHandle,
                                                       &IoStatusBlock,
                                                       &Length,
                                                       sizeof( Length ),
                                                       FileEndOfFileInformation
                                                     );
                    }
                }

                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: Unable to write changes for %wZ to disk - Status == %x\n",
                              &IniFile->NtFileName,
                              Status
                            ));
                }
            }

            NtFreeVirtualMemory( &IniFile->BaseAddress,
                                 &IniFile->RegionSize,
                                 MEM_RELEASE
                               );
            IniFile->BaseAddress = NULL;
            IniFile->CommitSize = 0;
            IniFile->RegionSize = 0;
        }

        if (IniFile->FileHandle != NULL) {

            Status = NtClose( IniFile->FileHandle );
            IniFile->FileHandle = NULL;
        }

        FreeKernelPool( IniFile );
    }

    return Status;
}


NTSTATUS
BaseDllReadWriteIniFileOnDisk(
                             IN PINIFILE_PARAMETERS a
                             )
{
    NTSTATUS Status;
    ULONG PartialResultChars = 0;

    if (!a->WriteOperation) {
        PartialResultChars = a->ResultChars;
    }

    Status = BaseDllOpenIniFileOnDisk( a );
    if (NT_SUCCESS( Status )) {
        try {
            a->TextEnd = (PCHAR)a->IniFile->BaseAddress + a->IniFile->EndOfFile;
            a->TextCurrent = a->IniFile->BaseAddress;
            if (a->IniFile->UnicodeFile &&
                ((*(PWCHAR)a->TextCurrent == BYTE_ORDER_MARK) ||
                 (*(PWCHAR)a->TextCurrent == REVERSE_BYTE_ORDER_MARK)))
            {
                // Skip past the BOM.
                ((PWCHAR)a->TextCurrent)++;
            }

            if (a->Operation == ReadSectionNames) {
                Status = BaseDllReadSectionNames( a );
            } else
                if (a->Operation == ReadKeyValue) {
                Status = BaseDllReadKeywordValue( a );
            } else
                if (a->Operation == ReadKeyNames) {
                Status = BaseDllReadKeywordNames( a );
            } else
                if (a->Operation == ReadSection) {
                Status = BaseDllReadSection( a );
            } else
                if (a->Operation == WriteKeyValue || a->Operation == DeleteKey) {
                Status = BaseDllWriteKeywordValue( a, NULL );
            } else
                if (a->Operation == WriteSection || a->Operation == DeleteSection) {
                Status = BaseDllWriteSection( a );
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        finally {
            BaseDllCloseIniFileOnDisk( a );
        }
    }

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        !a->WriteOperation &&
        PartialResultChars != 0
       ) {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
BaseDllReadWriteIniFile(
                       IN BOOLEAN Unicode,
                       IN BOOLEAN WriteOperation,
                       IN BOOLEAN SectionOperation,
                       IN PVOID FileName OPTIONAL,
                       IN PVOID ApplicationName OPTIONAL,
                       IN PVOID VariableName OPTIONAL,
                       IN OUT PVOID VariableValue OPTIONAL,
                       IN OUT PULONG VariableValueLength OPTIONAL
                       )
{
    BOOLEAN MultiValueStrings;
    INIFILE_OPERATION Operation;
    PINIFILE_PARAMETERS a;
    NTSTATUS Status;

    if (SectionOperation) {
        VariableName = NULL;
    }

    MultiValueStrings = FALSE;
    if (WriteOperation) {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (ARGUMENT_PRESENT( VariableName )) {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteKeyValue;
                } else {
                    Operation = DeleteKey;
                }
            } else {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteSection;
                    MultiValueStrings = TRUE;
                } else {
                    Operation = DeleteSection;
                }
            }
        } else {
#if DBG
            if (ARGUMENT_PRESENT( VariableName ) ||
                ARGUMENT_PRESENT( VariableValue )
               ) {
                return STATUS_INVALID_PARAMETER;
            } else
#endif
                if (ARGUMENT_PRESENT( FileName )) {
                Operation = RefreshIniFileMapping;
            } else {
                Operation = FlushProfiles;
            }
        }
    } else {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (!ARGUMENT_PRESENT( VariableValue )) {
                return STATUS_INVALID_PARAMETER;
            } else
                if (ARGUMENT_PRESENT( VariableName )) {
                Operation = ReadKeyValue;
            } else
                if (SectionOperation) {
                Operation = ReadSection;
                MultiValueStrings = TRUE;
            } else {
                Operation = ReadKeyNames;
                MultiValueStrings = TRUE;
            }
        } else
            if (SectionOperation || !ARGUMENT_PRESENT( VariableValue )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            VariableName = NULL;
            Operation = ReadSectionNames;
            MultiValueStrings = TRUE;
        }
    }

#if DBG
    if (WriteOperation) {
        ASSERT( Operation == WriteKeyValue || Operation == WriteSection || Operation == DeleteKey || Operation == DeleteSection || Operation == FlushProfiles || Operation == RefreshIniFileMapping );
    } else {
        ASSERT( Operation == ReadKeyValue || Operation == ReadKeyNames || Operation == ReadSectionNames || Operation == ReadSection );
    }
#endif

    Status = BaseDllCaptureIniFileParameters( Unicode,
                                              Operation,
                                              WriteOperation,
                                              MultiValueStrings,
                                              FileName,
                                              ApplicationName,
                                              VariableName,
                                              VariableValue,
                                              VariableValueLength,
                                              &a
                                            );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

#if DBG
    if (BaseDllDumpIniCalls) {
        DbgPrint( "BASEDLL: called with profile operation\n" );
        DbgPrint( "    Operation: %s  Write: %u\n", xOperationNames[ a->Operation ], a->WriteOperation );
        DbgPrint( "    FileName: %wZ\n", &a->FileName );
        DbgPrint( "    NtFileName: %wZ\n", &a->NtFileName );
        DbgPrint( "    ApplicationName: %wZ (%Z)\n", &a->ApplicationNameU, &a->ApplicationName );
        DbgPrint( "    VariableName: %wZ (%Z)\n", &a->VariableNameU, &a->VariableName );
        if (a->WriteOperation) {
            DbgPrint( "    VariableValue: %ws (%s)\n", a->ValueBufferU, a->ValueBuffer );
        }
    }
#endif // DBG

    Status = BaseDllReadWriteIniFileOnDisk( a );
#if DBG
    if (BaseDllDumpIniCalls) {
        if (NT_SUCCESS( Status ) ||
            Status == STATUS_BUFFER_OVERFLOW
           ) {
            if (!a->WriteOperation) {
                if (a->Unicode) {
                    if (a->Operation == ReadKeyValue) {
                        DbgPrint( "BASEDLL: Returning value from disk - '%.*ws' (%u)\n", a->ResultChars, a->ResultBufferU, a->ResultChars );
                    } else {
                        PWSTR s;

                        DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                        s = a->ResultBufferU;
                        s[ a->ResultChars ] = UNICODE_NULL;
                        while (*s) {
                            DbgPrint( "    %ws\n", s );
                            while (*s++) {
                            }
                        }
                    }
                } else {
                    if (a->Operation == ReadKeyValue) {
                        DbgPrint( "BASEDLL: Returning value from disk - '%.*s' (%u)\n", a->ResultChars, a->ResultBuffer, a->ResultChars );
                    } else {
                        PBYTE s;

                        DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                        s = a->ResultBuffer;
                        s[ a->ResultChars ] = '\0';
                        while (*s) {
                            DbgPrint( "    (%s)\n", s );
                            while (*s++) {
                            }
                        }
                    }
                }

                if (Status == STATUS_BUFFER_OVERFLOW) {
                    DbgPrint( "    *** above result partial as buffer too small.\n" );
                }
            } else {
                DbgPrint( "BASEDLL: Returning success for above write operation.\n" );
            }
        } else {
            DbgPrint( "BASEDLL: Profile operation %s failed: Status == %x\n", xOperationNames[ a->Operation ], Status );
        }
    }
#endif // DBG

    //if (BaseRunningInServerProcess || a->Operation == FlushProfiles) {
        //BaseDllFlushRegistryCache();
    //}

    if (NT_SUCCESS( Status )) {
        if (a->Operation == ReadSectionNames ||
            a->Operation == ReadKeyNames ||
            a->Operation == ReadSection
           ) {
            BaseDllAppendNullToResultBuffer( a );
        }
    }

    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (a->WriteOperation) {
            BaseIniFileUpdateCount++;
        } else
            if (ARGUMENT_PRESENT( VariableValueLength )) {
            *VariableValueLength = a->ResultChars;
        }
    }

    if (a->ValueBufferAllocated) {
        if (a->Unicode) {
            FreeKernelPool( a->ValueBufferU );
        } else {
            FreeKernelPool( a->ValueBuffer );
        }
    }

    FreeKernelPool( a );

    return Status;
}


DWORD
WINAPI
GetPrivateProfileStringA(
                        LPCSTR lpAppName,
                        LPCSTR lpKeyName,
                        LPCSTR lpDefault,
                        LPSTR lpReturnedString,
                        DWORD nSize,
                        LPCSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = "";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      (PVOID)lpKeyName,
                                      (PVOID)lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = '\0';
                //
                // GetPrivateProfileString(): don't leave 1st byte of double byte char alone
                //
                lpReturnedString[ n ] = '\0';
                if ( n > 0 ) {
                    LPSTR pc = lpReturnedString;
                    LPSTR pcEnd = lpReturnedString + n - 1;
                    //
                    // if the last character is the 1st byte of
                    // double byte character, erase it.
                    //
                    while ( pc <= pcEnd ) {
                        //pc += IsDBCSLeadByte( *pc ) ? 2 : 1;
                        pc += 1;
                    }
                    if ( (pc - pcEnd ) == 2 ) {
                        *pcEnd = '\0';
                    }
                }

                return ( n );
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = strlen( lpDefault );
        while (n > 0 && lpDefault[n-1] == ' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        strncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}


DWORD
WINAPI
GetPrivateProfileSectionNamesA(
                              LPSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCSTR lpFileName
                              )
{
    return GetPrivateProfileStringA( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}


DWORD
WINAPI
GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = L"";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      (PVOID)lpKeyName,
                                      (PVOID)lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = UNICODE_NULL;
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = wcslen( lpDefault );
        while (n > 0 && lpDefault[n-1] == L' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        wcsncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


DWORD
WINAPI
GetPrivateProfileSectionNamesW(
                              LPWSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCWSTR lpFileName
                              )
{
    return GetPrivateProfileStringW( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}

#define NibbleToChar(x) (N2C[x])
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))
char N2C[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};

BOOL
WINAPI
GetPrivateProfileStructA(
                        LPCSTR lpszSection,
                        LPCSTR lpszKey,
                        LPVOID lpStruct,
                        UINT uSizeStruct,
                        LPCSTR szFile
                        )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    nLen = uSizeStruct*2 + 10;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)AllocateKernelPool( nLen );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringA( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        // Room for the one byte check sum
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            BYTE cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum = (BYTE)(checksum + bStruct);
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        FreeKernelPool( lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
GetPrivateProfileStructW(
                        LPCWSTR lpszSection,
                        LPCWSTR lpszKey,
                        LPVOID   lpStruct,
                        UINT     uSizeStruct,
                        LPCWSTR szFile
                        )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    nLen = uSizeStruct*2 + 10;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen * sizeof( WCHAR )) > sizeof( szBuf )) {
        lpFreeBuffer = (PWSTR)AllocateKernelPool( nLen * sizeof(WCHAR) );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringW( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        // Room for the one byte check sum
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            WCHAR cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum = (BYTE)(checksum + bStruct);
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        FreeKernelPool( lpFreeBuffer );
    }

    return Result;
}


BOOL
WINAPI
WritePrivateProfileStringA(
                          LPCSTR lpAppName,
                          LPCSTR lpKeyName,
                          LPCSTR lpString,
                          LPCSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      (PVOID)lpKeyName,
                                      (PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        return( FALSE );
    }
}


BOOL
WINAPI
WritePrivateProfileStructA(
                          LPCSTR lpszSection,
                          LPCSTR lpszKey,
                          LPVOID lpStruct,
                          UINT   uSizeStruct,
                          LPCSTR szFile
                          )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringA( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)AllocateKernelPool( nLen );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = (BYTE)(checksum + bStruct);

        *lpBufTemp++ = NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = NibbleToChar(checksum&0x000f);
    *lpBufTemp = '\0';

    Result = WritePrivateProfileStringA( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        FreeKernelPool( lpFreeBuffer );
    }

    return Result;
}


BOOL
WINAPI
WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      (PVOID)lpKeyName,
                                      (PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        return( FALSE );
    }
}


BOOL
WINAPI
WritePrivateProfileStructW(
                          LPCWSTR lpszSection,
                          LPCWSTR lpszKey,
                          LPVOID  lpStruct,
                          UINT    uSizeStruct,
                          LPCWSTR szFile
                          )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringW( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen * sizeof( WCHAR )) > sizeof( szBuf )) {
        lpFreeBuffer = (PWSTR)AllocateKernelPool( nLen * sizeof(WCHAR) );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = (BYTE)(checksum + bStruct);

        *lpBufTemp++ = (WCHAR)NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = (WCHAR)NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = (WCHAR)NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = (WCHAR)NibbleToChar(checksum&0x000f);
    *lpBufTemp = L'\0';

    Result = WritePrivateProfileStringW( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        FreeKernelPool( lpFreeBuffer );
    }

    return Result;
}


UINT
WINAPI
GetPrivateProfileIntA(
                     LPCSTR lpAppName,
                     LPCSTR lpKeyName,
                     INT nDefault,
                     LPCSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    UCHAR ValueBuffer[ 256 ];
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringA( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Status = RtlCharToInteger( ValueBuffer, 0, &ReturnValue );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError(Status) );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}


UINT
WINAPI
GetProfileIntA(
              LPCSTR lpAppName,
              LPCSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntA( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
WINAPI
GetProfileStringA(
                 LPCSTR lpAppName,
                 LPCSTR lpKeyName,
                 LPCSTR lpDefault,
                 LPSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringA( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
WINAPI
WriteProfileStringA(
                   LPCSTR lpAppName,
                   LPCSTR lpKeyName,
                   LPCSTR lpString
                   )
{
    return( WritePrivateProfileStringA( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}


DWORD
WINAPI
GetPrivateProfileSectionA(
                         LPCSTR lpAppName,
                         LPSTR lpReturnedString,
                         DWORD nSize,
                         LPCSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      NULL,
                                      (PVOID)lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = '\0';
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}


DWORD
WINAPI
GetProfileSectionA(
                  LPCSTR lpAppName,
                  LPSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionA( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}


BOOL
WINAPI
WritePrivateProfileSectionA(
                           LPCSTR lpAppName,
                           LPCSTR lpString,
                           LPCSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      NULL,
                                      (PVOID)lpString,
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        return( FALSE );
    }
}


BOOL
WINAPI
WriteProfileSectionA(
                    LPCSTR lpAppName,
                    LPCSTR lpString
                    )
{
    return( WritePrivateProfileSectionA( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}


UINT
WINAPI
GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    WCHAR ValueBuffer[ 256 ];
    UNICODE_STRING Value;
    ANSI_STRING AnsiString;
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringW( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ) / sizeof( WCHAR ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Value.Buffer = ValueBuffer;
        Value.Length = (USHORT)(cb * sizeof( WCHAR ));
        Value.MaximumLength = (USHORT)((cb + 1) * sizeof( WCHAR ));
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &Value,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status )) {
            Status = RtlCharToInteger( AnsiString.Buffer, 0, &ReturnValue );
            RtlFreeAnsiString( &AnsiString );
        }

        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError(Status) );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}


UINT
WINAPI
GetProfileIntW(
              LPCWSTR lpAppName,
              LPCWSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntW( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
WINAPI
GetProfileStringW(
                 LPCWSTR lpAppName,
                 LPCWSTR lpKeyName,
                 LPCWSTR lpDefault,
                 LPWSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringW( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
WINAPI
WriteProfileStringW(
                   LPCWSTR lpAppName,
                   LPCWSTR lpKeyName,
                   LPCWSTR lpString
                   )
{
    return( WritePrivateProfileStringW( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}


DWORD
WINAPI
GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      NULL,
                                      (PVOID)lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = UNICODE_NULL;
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


DWORD
WINAPI
GetProfileSectionW(
                  LPCWSTR lpAppName,
                  LPWSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionW( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}


BOOL
WINAPI
WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      (PVOID)lpFileName,
                                      (PVOID)lpAppName,
                                      NULL,
                                      (PVOID)lpString,
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            SetLastError( RtlNtStatusToDosError(Status) );
        }
        return( FALSE );
    }
}


BOOL
WINAPI
WriteProfileSectionW(
                    LPCWSTR lpAppName,
                    LPCWSTR lpString
                    )
{
    return( WritePrivateProfileSectionW( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}


BOOLEAN
NTAPI
IniRemoveStringCommentW(
    IN OUT PWSTR String
    )

/*++

Routine Description:

    This routine will remove comment (';') and tailing white space from
    string retrieved by GetProfileString, GetPrivateProfileString

Arguments:

    String - Pointer to null-terminated string, usually the result from
        GetProfileString, GetPrivateProfileString

Return Value:

    TRUE if comment has been removed, otherwise return FALSE

--*/

{
    PWSTR Ptr;
    BOOLEAN b = FALSE;

    ASSERT( String != NULL );

    try {

        Ptr = wcschr( String, L';' );
        if ( Ptr ) {
            *Ptr = 0;
        }

        Ptr = String;
        Ptr += wcslen(String) - 1;
        while ( Ptr > String && *Ptr <= L' ' ) {
            Ptr--;
        }

        Ptr++;
        if ( *Ptr && *Ptr <= L' ' ) {
            *Ptr = 0;
        }

        b = TRUE;

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ;
    }

    return b;
}


BOOLEAN
NTAPI
IniRemoveStringCommentA(
    IN OUT PSTR String
    )

/*++

Routine Description:

    This routine will remove comment (';') and tailing white space from
    string retrieved by GetProfileString, GetPrivateProfileString

Arguments:

    String - Pointer to null-terminated string, usually the result from
        GetProfileString, GetPrivateProfileString

Return Value:

    TRUE if comment has been removed, otherwise return FALSE

--*/

{
    PSTR Ptr;
    BOOLEAN b = FALSE;

    ASSERT( String != NULL );

    try {

        Ptr = strchr( String, ';' );
        if ( Ptr ) {
            *Ptr = 0;
        }

        Ptr = String;
        Ptr += strlen(String) - 1;
        while ( Ptr > String && *Ptr <= ' ' ) {
            Ptr--;
        }

        Ptr++;
        if ( *Ptr && *Ptr <= ' ' ) {
            *Ptr = 0;
        }

        b = TRUE;

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ;
    }

    return b;
}


BOOL
WINAPI
XTestLibIsStressTesting(
    VOID
    )
{
    return GetProfileIntA( "GeneralSettings", "StressTestMode", FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 07-Mar-2000

Environment:

    XBox

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <xbox.h>
#include "xtestlib.h"

extern UNICODE_STRING TestRootString;

#define XTESTLIB_POOLTAG 'tstX'
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\misc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    misc.h

Abstract:

    Header file

Author:

    Sakphong Chanbai (schanbai) 07-Mar-2000

Environment:

    XBox

Revision History:

--*/


#ifndef _MISC_H_
#define _MISC_H_


#ifdef __cplusplus
extern "C" {
#endif


ULONG
NTAPI
xxx_RtlGetLongestNtPathLength(
    VOID
    );


BOOLEAN
NTAPI
xxx_RtlIsTextUnicode(
    IN PVOID Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    );


PVOID
AllocateKernelPool(
    SIZE_T Size
    );


VOID
FreeKernelPool(
    PVOID p
    );


#ifdef __cplusplus
}
#endif


#endif // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\misc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    Miscellaneous routines

Author:

    Sakphong Chanbai (schanbai) 13-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include <stdio.h>
#include "misc.h"


VOID
NTAPI
FlushDiskCache(
    VOID
    )

/*++

Routine Description:

    This routine will flush disk cache

Arguments:

    None

Return Value:

    No return value

--*/

{
    ULONG Volume, Disk;
    HANDLE Handle;
    NTSTATUS Status;
    OCHAR VolumeBuffer[MAX_PATH];
    OBJECT_STRING VolumeString;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;


    for ( Volume=1; Volume<6; Volume++ ) {

        soprintf( VolumeBuffer, OTEXT("\\Device\\Harddisk0\\Partition%d"), Volume );

        RtlInitObjectString( &VolumeString,  VolumeBuffer );

        InitializeObjectAttributes(
            &ObjA,
            &VolumeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        Status = NtCreateFile(
                    &Handle,
                    SYNCHRONIZE | GENERIC_READ,
                    &ObjA,
                    &IoStatusBlock,
                    0,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT
                 );

        if ( !NT_SUCCESS(Status) ) {
            continue;
        }

        Status = NtFlushBuffersFile( Handle, &IoStatusBlock );
        NtClose( Handle );
    }
}


VOID
NTAPI
RebootSystem(
    VOID
    )

/*++

Routine Description:

    This routine will flush disk cache and reboot the system

Arguments:

    None

Return Value:

    No return value

--*/

{
    FlushDiskCache();
    HalReturnToFirmware( HalRebootRoutine );
}


NTSTATUS
xxx_NtQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This function returns current value of performance counter and,
    optionally, the frequency of the performance counter.

    Performance frequency is the frequency of the performance counter
    in Hertz, i.e., counts/second.  Note that this value is implementation
    dependent.  If the implementation does not have hardware to support
    performance timing, the value returned is 0.

Arguments:

    PerformanceCounter - supplies the address of a variable to receive
        the current Performance Counter value.

    PerformanceFrequency - Optionally, supplies the address of a
        variable to receive the performance counter frequency.

Return Value:

    STATUS_ACCESS_VIOLATION or STATUS_SUCCESS.

--*/

{
    *PerformanceCounter = KeQueryPerformanceCounter();
    if (ARGUMENT_PRESENT(PerformanceFrequency)) {
        *PerformanceFrequency = KeQueryPerformanceFrequency();
    }

    return STATUS_SUCCESS;
}


ULONG
NTAPI
xxx_RtlGetLongestNtPathLength(
    VOID
    )
{
    //
    // BUGBUG: RtlGetLongestNtPathLength is not available right now
    //         It might not available at all, for now, we can safely
    //         use the size of maximum DOS path plus "\??\UNC\"

    return sizeof( "\\??\\UNC\\" ) + DOS_MAX_PATH_LENGTH + 1;
}


BOOLEAN
NTAPI
xxx_RtlIsTextUnicode(
    IN PVOID Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    )
{
    BOOLEAN b = FALSE;

    if ( Size >= 2 ) {

        ASSERT( Buffer != NULL );

        try {
            if ( *(PWSTR)Buffer == 0xFEFF) {
                b = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    return b;
}


PVOID
AllocateKernelPool(
    SIZE_T Size
    )
{
    PVOID p = ExAllocatePoolWithTag( Size, XTESTLIB_POOLTAG );
    if ( p ) {
        RtlZeroMemory( p, Size );
    } else {
        KdPrint(( "XTESTLIB: ExAllocatePoolWithTag returned NULL, size = %lu\n", Size ));
    }
    return p;
}


VOID
FreeKernelPool(
    PVOID p
    )
{
    ExFreePool( p );
}


VOID
QueryCpuTimesInformation(
    PLARGE_INTEGER KernelTime,
    PLARGE_INTEGER IdleTime,
    PLARGE_INTEGER DpcTime OPTIONAL,
    PLARGE_INTEGER InterruptTime OPTIONAL,
    PLARGE_INTEGER UserTime OPTIONAL
    )
{
    PKPRCB Prcb = KeGetCurrentPrcb();

    KernelTime->QuadPart = UInt32x32To64(
                                KeQueryTickCount() - Prcb->IdleThread->KernelTime,
                                *KeTimeIncrement
                                );

    IdleTime->QuadPart = UInt32x32To64(
                            Prcb->IdleThread->KernelTime,
                            *KeTimeIncrement
                            );

    if ( ARGUMENT_PRESENT(DpcTime) ) {
        DpcTime->QuadPart = UInt32x32To64( Prcb->DpcTime, *KeTimeIncrement );
    }

    if ( ARGUMENT_PRESENT(InterruptTime) ) {
        InterruptTime->QuadPart = UInt32x32To64( Prcb->InterruptTime, *KeTimeIncrement );
    }

    if ( ARGUMENT_PRESENT(UserTime) ) {
        UserTime->QuadPart = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\leak.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    leak.h

Abstract:

    Leak debugging routines

Author:

    Sakphong Chanbai (schanbai) 22-May-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef __LEAK_H__
#define __LEAK_H__


#ifdef __cplusplus
extern "C" {
#endif


//
// Allocation history for various memory allocation APIs
// (malloc, calloc, free, LocalAlloc, LocalFree, etc.)
//

typedef enum {

    AllocationType_malloc = 0,
    AllocationType_calloc,
    AllocationType_realloc,
    AllocationType_LocalAlloc,
    AllocationType_GlobalAlloc,
    AllocationType_HeapAlloc,
    AllocationType_operator_new,
    AllocationType_operator_new_bracket,
    AllocationType_VirtualAlloc,
    AllocationType_CreateEvent,
    AllocationType_OpenEvent,
    AllocationType_CreateMutex,
    AllocationType_OpenMutex,
    AllocationType_CreateSemaphore,
    AllocationType_OpenSemaphore,
    AllocationType_CreateWaitableTimer,
    AllocationType_OpenWaitableTimer,
    AllocationType_FindFirstFileA,
    AllocationType_FindFirstFileW,
    AllocationType_Max

} AllocationType;


#define AllocationHistorySignature  '@meM'

#define ASSERT_SIGNATURE( p )  ASSERT( (p)->Signature == AllocationHistorySignature )

typedef struct _ALLOCATION_HISTORY {

    LIST_ENTRY      List;
    ULONG_PTR       Caller;       // Caller address (actually it's return address)
    PVOID           MemBlock;
    ULONG           Size;
    AllocationType  AllocType;
    PVOID          *StackBackTrace;

#if DBG
    ULONG           Signature;
#endif

} ALLOCATION_HISTORY, *PALLOCATION_HISTORY;


#define ENABLE_LEAK_TRACKING        0x00000001
#define CAPTURE_STACK_BACK_TRACE    0x00000002
#define DETECT_INVALID_FREE         0x80000000
#define MAX_STACK_DEPTH             32


#define RET_ADDR( c ) *((PULONG)&(c) - 1)


BOOL
InitializeHeapAllocationHistory(
    VOID
    );


VOID
UninitializeHeapAllocationHistory(
    VOID
    );


#ifdef __cplusplus
}
#endif


#endif // __LEAK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\symbols.c ===
#include "precomp.h"

#include <ntstatus.dbg>
#include <winerror.dbg>



LPSTR
WINAPI
NtStatusSymbolicName(
    NTSTATUS  Status
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Converts status code to symbolic name

Arguments:

  Status - NT status code

Return Value:

  Pointer to symbolic name of specified status code

------------------------------------------------------------------------------*/
{
    int i = 0;

    while (ntstatusSymbolicNames[i].SymbolicName) {
        if (ntstatusSymbolicNames[i].MessageId == Status) {
            return ntstatusSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}



LPSTR
WINAPI
WinErrorSymbolicName(
    DWORD  LastError
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Converts error code to symbolic name

Arguments:

  LastError - Error code returned by GetLastError()

Return Value:

  Pointer to symbolic name of specified error code

------------------------------------------------------------------------------*/
{
    int i = 0;

    while (winerrorSymbolicNames[i].SymbolicName) {
        if (winerrorSymbolicNames[i].MessageId == LastError) {
            return winerrorSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\prochook.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    prochook.h

Abstract:

    Routines to hook imported functions

Author:

    Sakphong Chanbai (schanbai) 05-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef __HOOKPROC_H__
#define __HOOKPROC_H__

#ifdef __cplusplus
extern "C" {
#endif


PROC WINAPI HookImportedFunction(
    HMODULE hFromModule,        // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    LPCSTR pszFunctionName,     // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    );


PROC WINAPI HookImportedFunctionEx(
    HMODULE hFromModule,        // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    PROC pfnProc,               // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    );


PROC WINAPI HookPEImportedFunctionEx(
    ULONG_PTR BaseAddress,      // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    PROC pfnProc,               // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    );


#ifdef __cplusplus
}
#endif

#endif // __HOOKPROC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\xeutils.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xeutils.h

Abstract:

    Miscellaneous utility routines for XE modules

Author:

    Sakphong Chanbai (schanbai) 11-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef __XEUTILS_INCLUDED__

#define __XEUTILS_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif


//PXIMAGE_HEADER
//XTestLibLocateXImageHeader(
    //VOID
    //);


#ifdef __cplusplus
}
#endif

#endif // __XEUTILS_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\win32.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    win32.c

Abstract:

    Temporary routines for various Win32 APIs, these routines will be removed
    later when XAPI is ready

Author:

    Sakphong Chanbai (schanbai) 23-Mar-2000

Environment:

    XBox

Revision History:

--*/


#include "precomp.h"
#include "misc.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( xbDebug )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( xbDebug ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\prochook.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    prochook.cpp

Abstract:

    Routines to hook imported functions

Author:

    Sakphong Chanbai (schanbai) 05-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "prochook.h"
#include "xeutils.h"

#define MAKEPTR(cast, ptr, addValue) (cast)((DWORD)(ptr)+(DWORD)(addValue))

#ifdef __cplusplus
extern "C" {
#endif


PROC WINAPI HookImportedFunction(
    HMODULE hFromModule,        // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    LPCSTR pszFunctionName,     // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    )
{
    // Get the module handle
    HMODULE hModule = (HMODULE)XeModuleHeaderFromModuleName( "xapi.dll" );

    if ( !hModule ) {
        return NULL;
    }

    // Get the function address
    PROC pfn = GetProcAddress( hModule, pszFunctionName );

    if ( !pfn ) {
        return NULL;
    }

    // Hook it
    return HookImportedFunctionEx(
                hFromModule,
                pszFunctionModule,
                pfn,
                pfnNewProc
                );
}


PROC WINAPI HookImportedFunctionEx(
    HMODULE hFromModule,        // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    PROC pfnProc,               // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    )
{
    if ( IsBadReadPtr(hFromModule, sizeof(XIMAGE_MODULE_HEADER)) ) {
        return NULL;
    }

    return HookPEImportedFunctionEx(
                ((PXIMAGE_MODULE_HEADER)hFromModule)->ImageBase,
                pszFunctionModule,
                pfnProc,
                pfnNewProc
                );
}


PROC WINAPI HookPEImportedFunctionEx(
    ULONG_PTR BaseAddress,      // Module to intercept calls from
    LPCSTR pszFunctionModule,   // Module to intercept calls to
    PROC pfnProc,               // Function to intercept calls to
    PROC pfnNewProc             // New function (replace old function)
    )
{
    PROC pfnOriginalProc;
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_NT_HEADERS pNTHeader;
    PIMAGE_IMPORT_DESCRIPTOR pImportDesc;
    PIMAGE_THUNK_DATA pThunk;

    // Verify that a valid pfn was passed
    if ( IsBadCodePtr(pfnNewProc) ) {
        return NULL;
    }

    // First, verify the function passed to use are valid
    if ( IsBadCodePtr(pfnProc) ) {
        return NULL;
    }

    pfnOriginalProc = pfnProc;
    pDosHeader = (PIMAGE_DOS_HEADER)BaseAddress;

    // Test to make sure we're looking at a module image (the MZ header)
    if ( IsBadReadPtr(pDosHeader, sizeof(IMAGE_DOS_SIGNATURE)) ) {
        return NULL;
    }

    if ( pDosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        return NULL;
    }

    // The MZ header has a pointer to PE signature
    pNTHeader = MAKEPTR(PIMAGE_NT_HEADERS, pDosHeader, pDosHeader->e_lfanew);

    // More tests to make sure we're looking at a "PE" image
    if ( IsBadReadPtr(pNTHeader, sizeof(IMAGE_NT_HEADERS)) ) {
        return NULL;
    }

    //
    // We now have a valid pointer to the module's PE header
    // Now go get a pointer to its imports section
    //
    pImportDesc = MAKEPTR(
        PIMAGE_IMPORT_DESCRIPTOR, 
        pDosHeader, 
        pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
        );

    // Bail out if the RVA of the imports section is 0 (it doesn't exist)
    if ( pImportDesc == (PIMAGE_IMPORT_DESCRIPTOR)pNTHeader ) {
        return NULL;
    }

    //
    // Iterate through the array of imported module descriptor
    // Looking for the module whose name matches the pszFunctionModule parameter
    //
    while ( pImportDesc->Name ) {
        LPSTR pszModName = MAKEPTR( PSTR, pDosHeader, pImportDesc->Name );

        if ( _stricmp(pszModName, pszFunctionModule) == 0 ) {
            break;
        }

        // Advance to next imported module descriptor
        pImportDesc++;
    }

    // Bail out if we didn't find the import module descriptor
    if ( pImportDesc->Name == 0 ) {
        return NULL;
    }

    // Get a pointer to the found Module's import address table (IAT)
    pThunk = MAKEPTR( PIMAGE_THUNK_DATA, pDosHeader, pImportDesc->FirstThunk );

    //
    // Blast through the table of import addresses and looking for the one
    // that matches the address we got back from GetProcAddress
    //
    while ( pThunk->u1.Function )
    {
        if ( pThunk->u1.Function == (ULONG_PTR)pfnOriginalProc ) {
            // We found it! Overwrite the original address with the
            // address of interception function

            MEMORY_BASIC_INFORMATION mbi;
            DWORD oldFlags, newFlags;
            DWORD dwScratch;

            // Get original protection attribute
            VirtualQuery(&pThunk->u1.Function, &mbi, sizeof(mbi));
            oldFlags = mbi.Protect;
            newFlags = mbi.Protect;

            // Tweak to writeable
            newFlags &= ~PAGE_READONLY;
            newFlags &= ~PAGE_EXECUTE_READ;
            newFlags |= PAGE_READWRITE;

            // Modify the page's protection attributes
            if ( !VirtualProtect(&pThunk->u1.Function, sizeof(PDWORD), newFlags, &dwScratch) ) {
                //BUGBUG: handle errror here
                //DWORD dwError = GetLastError();
            }

            BOOL fFaulted = FALSE;

            __try
            {
                pThunk->u1.Function = (ULONG_PTR)pfnNewProc;
            }
            __except(1)
            {
                fFaulted = TRUE;
            }

            VirtualProtect(&pThunk->u1.Function, sizeof(PDWORD), oldFlags, &dwScratch);

            if (!fFaulted) {
                return pfnOriginalProc;
            } else {
                return NULL;
            }
        }

        // Advance to next imported function table
        pThunk++;
    }

    return NULL;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\tools\xtestlib\xeutils.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xeutils.c

Abstract:

    Miscellaneous utility routines for XE image header

Author:

    Sakphong Chanbai (schanbai) 11-Jul-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "xeutils.h"


PVOID
WINAPI
XTestLibLocateXImageHeader(
    VOID
    )

/*++

Routine Description:

    This routine returns the XE image header

Arguments:

    None

Return Value:

    Pointer to XE image header or NULL

--*/

{
    return XapiGetCurrentProcess()->XeLdrImage->ImageHeader;
}


ULONG
WINAPI
XeModuleIndexFromAddress(
    ULONG_PTR Address
    )

/*++

Routine Description:

    This routine maps specified address to index into XE modules in XE image
    See PXIMAGE_HEADER and PXIMAGE_MODULE_HEADER for more information

Arguments:

    Address - Address to be mapped

Return Value:

    Module index or 0xFFFFFFFF if error

--*/

{
    ULONG i, ModuleIndex = ~0UL;
    PXIMAGE_HEADER ImageHeader;
    PXIMAGE_MODULE_HEADER ModuleHeader;
    PVOID VarImageHeader;

    ImageHeader = XTestLibLocateXImageHeader();
    
    if ( ImageHeader ) {
        VarImageHeader = (PVOID)(ImageHeader->HeadersBase + XIMAGE_FIXED_HEADER_SIZE(ImageHeader));
        ModuleHeader = XIMAGE_FIRST_MODULE(ImageHeader, VarImageHeader); 

        for ( i=0; i<ImageHeader->OptionalHeader.NumberOfModules; i++, ModuleHeader++ ) {
            if ( Address >= ModuleHeader->ImageBase && \
                 Address < (ModuleHeader->ImageBase + ModuleHeader->OrgSizeOfImage) ) {
                ModuleIndex = i;
                break;
            }
        }
    }

    return ModuleIndex;
}


CONST PVOID
WINAPI
XeModuleHeaderFromModuleIndex(
    ULONG ModuleIndex
    )

/*++

Routine Description:

    This routine returns pointer to XE module header specified by
    module index. See PXIMAGE_HEADER and PXIMAGE_MODULE_HEADER for
    more information

Arguments:

    ModuleIndex - Index into module headers

Return Value:

    Pointer to module header or NULL

--*/

{
    PXIMAGE_HEADER ImageHeader;
    PXIMAGE_MODULE_HEADER ModuleHeader;
    PVOID VarImageHeader;

    ImageHeader = XTestLibLocateXImageHeader();

    if ( !ImageHeader || ModuleIndex >= ImageHeader->OptionalHeader.NumberOfModules ) {
        return NULL;
    }

    VarImageHeader = (PVOID)(ImageHeader->HeadersBase + XIMAGE_FIXED_HEADER_SIZE(ImageHeader));
    ModuleHeader = XIMAGE_FIRST_MODULE(ImageHeader, VarImageHeader);

    return &ModuleHeader[ ModuleIndex ];
}


CONST PCHAR
WINAPI
XeModuleNameFromModuleHeader(
    PXIMAGE_MODULE_HEADER ModuleHeader
    )
{
    PXIMAGE_HEADER ImageHeader;
    PVOID MiscData, VarImageHeader;
    
    ImageHeader = XTestLibLocateXImageHeader();

    if ( !ImageHeader ) {
        return NULL;
    }

    VarImageHeader = (PVOID)(ImageHeader->HeadersBase + XIMAGE_FIXED_HEADER_SIZE(ImageHeader));
    MiscData = XIMAGE_MISCDATA( ImageHeader, VarImageHeader );

    return (PCHAR)MiscData + ModuleHeader->NameOfs;
}


CONST PVOID
WINAPI
XeModuleHeaderFromModuleName(
    LPCSTR ModuleName
    )

/*++

Routine Description:

    This routine returns pointer to XE module header specified by
    module name. See PXIMAGE_HEADER and PXIMAGE_MODULE_HEADER for
    more information

Arguments:

    ModuleName - Name of module

Return Value:

    Pointer to module header or NULL

--*/

{
    ULONG i;
    PXIMAGE_HEADER ImageHeader;
    PXIMAGE_MODULE_HEADER ModuleHeader, TargetModuleHeader=NULL;
    PVOID VarImageHeader;
    PCHAR ModName;

    ImageHeader = XTestLibLocateXImageHeader();
    
    if ( ImageHeader ) {
        VarImageHeader = (PVOID)(ImageHeader->HeadersBase + XIMAGE_FIXED_HEADER_SIZE(ImageHeader));
        ModuleHeader = XIMAGE_FIRST_MODULE(ImageHeader, VarImageHeader); 

        for ( i=0; i<ImageHeader->OptionalHeader.NumberOfModules; i++, ModuleHeader++ ) {
            ModName = XeModuleNameFromModuleHeader( ModuleHeader );
            if ( _stricmp(ModuleName, ModName) == 0 ) {
                TargetModuleHeader = ModuleHeader;
                break;
            }
        }
    }

    return TargetModuleHeader;
}


CONST PCHAR
WINAPI
XeModuleNameFromModuleIndex(
    ULONG ModuleIndex
    )

/*++

Routine Description:

    This routine returns pointer to XE module name specified by
    module index

Arguments:

    ModuleIndex - Index of module

Return Value:

    Pointer to module name or NULL

--*/

{
    PXIMAGE_MODULE_HEADER ModuleHeader;
    
    ModuleHeader = XeModuleHeaderFromModuleIndex( ModuleIndex );

    if ( !ModuleHeader ) {
        return NULL;
    }

    return XeModuleNameFromModuleHeader( ModuleHeader );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\NetDebug.cpp ===
// NetDebug.cpp : Implementation of CNetDebug
#include "stdafx.h"
#include "XbDebug.h"
#include "NetDebug.h"
#include <comdef.h>
#include <iostream.h>



PDMN_SESSION DmSession = NULL;
BOOL fNotificationOpened = FALSE;
BOOL fConnectionOpened = FALSE;
INT EVENT_MESSAGE = 9999;

///////////////////////
// put linked list declaration here


/*
 * AnsiToUnicode converts the ANSI string pszA to a Unicode string
 * and returns the Unicode string through ppszW. Space for the
 * the converted string is allocated by AnsiToUnicode.
 */ 

HRESULT __fastcall AnsiToUnicode(LPCSTR pszA, LPOLESTR* ppszW)
{

    ULONG cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (NULL == pszA)
    {
        *ppszW = NULL;
        return NOERROR;
    }

    // Determine number of wide characters to be allocated for the
    // Unicode string.
    cCharacters =  strlen(pszA)+1;

    // Use of the OLE allocator is required if the resultant Unicode
    // string will be passed to another COM component and if that
    // component will free it. Otherwise you can use your own allocator.
    *ppszW = (LPOLESTR) CoTaskMemAlloc(cCharacters*2);
    if (NULL == *ppszW)
        return E_OUTOFMEMORY;

    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, cCharacters,
                  *ppszW, cCharacters))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszW);
        *ppszW = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }

    return NOERROR;
}




/*
 * UnicodeToAnsi converts the Unicode string pszW to an ANSI string
 * and returns the ANSI string through ppszA. Space for the
 * the converted string is allocated by UnicodeToAnsi.
 */ 

HRESULT __fastcall UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)
{

    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return NOERROR;
    }

    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    *ppszA = (LPSTR) CoTaskMemAlloc(cbAnsi);
    if (NULL == *ppszA)
        return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszA);
        *ppszA = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;

} 





struct debugline
{
	BSTR data;
	debugline *next;

};




typedef debugline* debuglinePtr;

//declare the head of the list as global
debuglinePtr LIST_HEAD;





void tail_insert(debuglinePtr& head, BSTR the_data)
{
	//This function will add a debug line to the head of the linked list
	debuglinePtr temp_ptr;
	temp_ptr = head;
	
	while (temp_ptr->next != NULL)
	{
		temp_ptr=temp_ptr->next;
	}

	debuglinePtr newline;
	newline = new debugline;

	newline->data = the_data;
	newline->next = NULL;

	temp_ptr->next = newline;
	
}




void head_insert(debuglinePtr& head, BSTR the_data)
{
	//This function will add a debug line to the head of the linked list
	
	debuglinePtr temp_ptr;
	temp_ptr = new debugline;
	if (NULL == temp_ptr)
	{
		//couldn't create the new debugline struct
		exit(1);
	}

	temp_ptr->data = the_data;

	temp_ptr->next= head;
	head = temp_ptr;
}




BSTR output_lines(debuglinePtr& head)
{
	// this function get all the data in the linked list and output it as one BSTR
	_bstr_t Full_String = head->data;
	debuglinePtr temp_ptr;
	temp_ptr = head;
	while (head->next != NULL)
	{
		_bstr_t tmpbstr( temp_ptr->data, false );
		Full_String += tmpbstr;
		temp_ptr = temp_ptr->next;	
	}
	

	return Full_String;
}




BSTR output_lines(debuglinePtr& head, int begin, int end)
{
	// this function will erase all the data in the linked list and reset the head
	_bstr_t Full_String;
	if (begin <= end)
	{
		debuglinePtr temp_ptr = head;
		// Traversing the list
		for (int i = 1; (begin > i) && (temp_ptr != NULL); i++)
		{
			temp_ptr = temp_ptr->next;
		}
		
		// Start deleting
		while (i <= end && temp_ptr != NULL)
		{
			_bstr_t tmpbstr( temp_ptr->data, false );
			Full_String += tmpbstr;
			temp_ptr = temp_ptr->next;
			i++;
		}
	}
	else
	{
		// you can put error msg here if you wish.
	}
	return (LPWSTR)Full_String;
}




void clear(debuglinePtr& head)
{
	// this function will erase all the data in the linked list and reset the head
	debuglinePtr temp_ptr;
	while (head->next != NULL)
	{
		temp_ptr = head;
		head = head->next;
		delete temp_ptr;
	}
}





void clear(debuglinePtr& head, int begin, int end)
{
	// this function will erase all the data in the linked list and reset the head
	if (begin <= end)
	{
		debuglinePtr temp_ptr = head;
		debuglinePtr temp_end = NULL;
		// Traversing the list
		for (int i = 1; (begin > i) && (temp_ptr != NULL); i++)
		{
			temp_end = temp_ptr;
			temp_ptr = temp_ptr->next;
		}
		
		// Start deleting
		while (i <= end && temp_ptr != NULL)
		{
			temp_end->next = temp_ptr->next;
			delete temp_ptr;
			temp_ptr = temp_end->next;
			i++;
		}
	}
	else
	{
		// you can put error msg here if you wish.
	}

}




///////////////////////////////////////////////////////////////////////////////
///  Sak's code

DWORD WINAPI NotificationProc( ULONG Notification, DWORD Parameter )
/*++

Routine Description:

    This is a callback routine registered by DmNotify.  It is called by XboxDbg
    for various types of notification event.

Arguments:

    Notification - Type of notification, DM_DEBUGSTR for example

    Parameter - Optional parameter based on notification type

Return Value:

    Always zero

--*/
{
	PDMN_DEBUGSTR p = NULL;
	p = (PDMN_DEBUGSTR)Parameter;

    //
    // Process only if notification type is DM_DEBUGSTR and there is
    // a valid string length
    //

    if ( Notification == DM_DEBUGSTR && p->Length ) {
        //Put into linked list here
		/*
		WCHAR* psz = new WCHAR[p->Length + 1];
		psz[p->Length] = 0;
		MultiByteToWideChar(CP_ACP, 0, p->String, p->Length, psz, p->Length);
		BSTR bstrMsg = SysAllocString(psz);
		cout<<*psz<<endl;
		delete[] psz;
		tail_insert(LIST_HEAD,bstrMsg);
		*/

		//Send Event Here
		SendMessage(HWND_BROADCAST,EVENT_MESSAGE,(LPARAM)"AUTO",(LPARAM)p->String);



    }

	
    return 0;
}






VOID TranslateError( HRESULT hr )

/*
Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string and
    output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None
*/

{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    cout<<"TRANSLATE ERROR - "<<Buffer<<endl;
}





BOOL WINAPI ConsoleCtrlHandler( DWORD CtrlType )
/*++

Routine Description:

    A HandlerRoutine function is an application-defined function used with
    the SetConsoleCtrlHandler function.  A console process uses this function
    to handle control signals received by the process

Arguments:

    CtrlType - Indicates the type of control signal received by the handler.

Return Value:

    Return FALSE to terminate the process

--*/
{
    switch ( Ctr